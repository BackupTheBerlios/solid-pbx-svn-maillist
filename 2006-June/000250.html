<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [solid-pbx-svn] r255 - in trunk: . apps configs include/asterisk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r255%20-%20in%20trunk%3A%20.%20apps%20configs%20include/asterisk&In-Reply-To=%3C200606181425.k5IEPUp8017031%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000249.html">
   <LINK REL="Next"  HREF="000251.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[solid-pbx-svn] r255 - in trunk: . apps configs include/asterisk</H1>
    <B>solid-pbx-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r255%20-%20in%20trunk%3A%20.%20apps%20configs%20include/asterisk&In-Reply-To=%3C200606181425.k5IEPUp8017031%40sheep.berlios.de%3E"
       TITLE="[solid-pbx-svn] r255 - in trunk: . apps configs include/asterisk">solid-pbx-svn-admin at lists.berlios.de
       </A><BR>
    <I>Sun Jun 18 16:25:30 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000249.html">[solid-pbx-svn] r254 - trunk/channels
</A></li>
        <LI>Next message: <A HREF="000251.html">[solid-pbx-svn] r256 - trunk/configs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#250">[ date ]</a>
              <a href="thread.html#250">[ thread ]</a>
              <a href="subject.html#250">[ subject ]</a>
              <a href="author.html#250">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-06-18 16:25:27 +0200 (Sun, 18 Jun 2006)
New Revision: 255

Modified:
   trunk/apps/app_voicemail.c
   trunk/configs/rtp.conf.sample
   trunk/include/asterisk/rtp.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32233

------------------------------------------------------------------------
r32229 | oej | 2006-06-05 10:06:02 +0200 (Mon, 05 Jun 2006) | 3 lines

- Add headers to e-mail with caller ID name and number to simplify automatic parsing
- Formatting fixes

------------------------------------------------------------------------
r32230 | oej | 2006-06-05 10:39:42 +0200 (Mon, 05 Jun 2006) | 3 lines

Issue #2863 - Improved RTCP support (John Martin, Fredrik Olsson)
   Thanks to everyone involved in working with this!

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/apps/app_voicemail.c	2006-06-18 14:25:27 UTC (rev 255)
@@ -1780,11 +1780,13 @@
 				if ((passdata = alloca(vmlen))) {
 					memset(passdata, 0, vmlen);
 					prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, cidnum, cidname, dur, date, passdata, vmlen, category);
-					pbx_substitute_variables_helper(ast,fromstring,passdata,vmlen);
+					pbx_substitute_variables_helper(ast, fromstring, passdata, vmlen);
 					fprintf(p, &quot;From: %s &lt;%s&gt;\n&quot;,passdata,who);
-				} else ast_log(LOG_WARNING, &quot;Cannot allocate workspace for variable substitution\n&quot;);
+				} else
+					ast_log(LOG_WARNING, &quot;Cannot allocate workspace for variable substitution\n&quot;);
 				ast_channel_free(ast);
-			} else ast_log(LOG_WARNING, &quot;Cannot allocate the channel for variables substitution\n&quot;);
+			} else
+				ast_log(LOG_WARNING, &quot;Cannot allocate the channel for variables substitution\n&quot;);
 		} else
 			fprintf(p, &quot;From: Asterisk PBX &lt;%s&gt;\n&quot;, who);
 		fprintf(p, &quot;To: %s &lt;%s&gt;\n&quot;, vmu-&gt;fullname, vmu-&gt;email);
@@ -1797,11 +1799,13 @@
 				if ((passdata = alloca(vmlen))) {
 					memset(passdata, 0, vmlen);
 					prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, cidnum, cidname, dur, date, passdata, vmlen, category);
-					pbx_substitute_variables_helper(ast,emailsubject,passdata,vmlen);
-					fprintf(p, &quot;Subject: %s\n&quot;,passdata);
-				} else ast_log(LOG_WARNING, &quot;Cannot allocate workspace for variable substitution\n&quot;);
+					pbx_substitute_variables_helper(ast, emailsubject, passdata, vmlen);
+					fprintf(p, &quot;Subject: %s\n&quot;, passdata);
+				} else
+					ast_log(LOG_WARNING, &quot;Cannot allocate workspace for variable substitution\n&quot;);
 				ast_channel_free(ast);
-			} else ast_log(LOG_WARNING, &quot;Cannot allocate the channel for variables substitution\n&quot;);
+			} else
+				ast_log(LOG_WARNING, &quot;Cannot allocate the channel for variables substitution\n&quot;);
 		} else
 		if (*emailtitle) {
 			fprintf(p, emailtitle, msgnum + 1, mailbox) ;
@@ -1811,6 +1815,10 @@
 		else
 			fprintf(p, &quot;Subject: [PBX]: New message %d in mailbox %s\n&quot;, msgnum + 1, mailbox);
 		fprintf(p, &quot;Message-ID: &lt;Asterisk-%d-%d-%s-%d@%s&gt;\n&quot;, msgnum, (unsigned int)ast_random(), mailbox, getpid(), host);
+		if (!ast_strlen_zero(cidnum))
+			fprintf(p, &quot;X-Asterisk-CallerID: %s\n&quot;, cidnum);
+		if (!ast_strlen_zero(cidname))
+			fprintf(p, &quot;X-Asterisk-CallerIDName: %s\n&quot;, cidname);
 		fprintf(p, &quot;MIME-Version: 1.0\n&quot;);
 		if (attach_user_voicemail) {
 			/* Something unique. */
@@ -1829,11 +1837,13 @@
 				if ((passdata = alloca(vmlen))) {
 					memset(passdata, 0, vmlen);
 					prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, cidnum, cidname, dur, date, passdata, vmlen, category);
-					pbx_substitute_variables_helper(ast,emailbody,passdata,vmlen);
-					fprintf(p, &quot;%s\n&quot;,passdata);
-				} else ast_log(LOG_WARNING, &quot;Cannot allocate workspace for variable substitution\n&quot;);
+					pbx_substitute_variables_helper(ast, emailbody, passdata, vmlen);
+					fprintf(p, &quot;%s\n&quot;, passdata);
+				} else
+					ast_log(LOG_WARNING, &quot;Cannot allocate workspace for variable substitution\n&quot;);
 				ast_channel_free(ast);
-			} else ast_log(LOG_WARNING, &quot;Cannot allocate the channel for variables substitution\n&quot;);
+			} else
+				ast_log(LOG_WARNING, &quot;Cannot allocate the channel for variables substitution\n&quot;);
 		} else {
 			fprintf(p, &quot;Dear %s:\n\n\tJust wanted to let you know you were just left a %s long message (number %d)\n&quot;
 
@@ -1843,9 +1853,7 @@
 		}
 		if (attach_user_voicemail) {
 			/* Eww. We want formats to tell us their own MIME type */
-			char *ctype = &quot;audio/x-&quot;;
-			if (!strcasecmp(format, &quot;ogg&quot;))
-				ctype = &quot;application/&quot;;
+			char *ctype = (!strcasecmp(format, &quot;ogg&quot;)) ?  &quot;application/&quot; : &quot;audio/x-&quot;;
 		
 			fprintf(p, &quot;--%s\n&quot;, bound);
 			fprintf(p, &quot;Content-Type: %s%s; name=\&quot;msg%04d.%s\&quot;\n&quot;, ctype, format, msgnum, format);

Modified: trunk/configs/rtp.conf.sample
===================================================================
--- trunk/configs/rtp.conf.sample	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/configs/rtp.conf.sample	2006-06-18 14:25:27 UTC (rev 255)
@@ -18,3 +18,5 @@
 ; allowed to continue (in 'samples', 1/8000 of a second)
 ;
 ;dtmftimeout=3000
+; rtcpinterval = 5000 	; Milliseconds between rtcp reports 
+			;(min 500, max 60000, default 5000)

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/include/asterisk/rtp.h	2006-06-18 14:25:27 UTC (rev 255)
@@ -166,6 +166,12 @@
 
 void ast_rtp_stop(struct ast_rtp *rtp);
 
+/*! \brief Return RTCP quality string */
+char *ast_rtp_get_quality(struct ast_rtp *rtp);
+
+/*! \brief Send an H.261 fast update request. Some devices need this rather than the XML message  in SIP */
+int ast_rtcp_send_h261fur(void *data);
+
 void ast_rtp_init(void);
 
 int ast_rtp_reload(void);

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/rtp.c	2006-06-18 14:25:27 UTC (rev 255)
@@ -59,6 +59,18 @@
 
 #define MAX_TIMESTAMP_SKEW	640
 
+#define RTP_SEQ_MOD     (1&lt;&lt;16) 	/*!&lt; A sequence number can't be more than 16 bits */
+#define RTCP_DEFAULT_INTERVALMS   5000	/*!&lt; Default milli-seconds between RTCP reports we send */
+#define RTCP_MIN_INTERVALMS       500	/*!&lt; Min milli-seconds between RTCP reports we send */
+#define RTCP_MAX_INTERVALMS       60000	/*!&lt; Max milli-seconds between RTCP reports we send */
+
+#define RTCP_PT_FUR     192
+#define RTCP_PT_SR      200
+#define RTCP_PT_RR      201
+#define RTCP_PT_SDES    202
+#define RTCP_PT_BYE     203
+#define RTCP_PT_APP     204
+
 #define RTP_MTU		1200
 
 #define DEFAULT_DTMF_TIMEOUT 3000	/*!&lt; samples */
@@ -68,12 +80,23 @@
 static int rtpstart = 0;		/*!&lt; First port for RTP sessions (set in rtp.conf) */
 static int rtpend = 0;			/*!&lt; Last port for RTP sessions (set in rtp.conf) */
 static int rtpdebug = 0;		/*!&lt; Are we debugging? */
+static int rtcpdebug = 0;		/*!&lt; Are we debugging RTCP? */
+static int rtcpstats = 0;		/*!&lt; Are we debugging RTCP? */
+static int rtcpinterval = RTCP_DEFAULT_INTERVALMS; /*!&lt; Time between rtcp reports in millisecs */
 static int stundebug = 0;		/*!&lt; Are we debugging stun? */
 static struct sockaddr_in rtpdebugaddr;	/*!&lt; Debug packets to/from this host */
+static struct sockaddr_in rtcpdebugaddr;	/*!&lt; Debug RTCP packets to/from this host */
 #ifdef SO_NO_CHECK
 static int nochecksums = 0;
 #endif
 
+/* Forward declarations */
+static int ast_rtcp_write(void *data);
+static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw);
+static int ast_rtcp_write_sr(void *data);
+static int ast_rtcp_write_rr(void *data);
+static unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp);
+
 /*! \brief The value of each payload format mapping: */
 struct rtpPayloadType {
 	int isAstFormat; 	/*!&lt; whether the following code is an AST_FORMAT */
@@ -95,6 +118,7 @@
 	struct ast_frame f;
 	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
 	unsigned int ssrc;		/*!&lt; Synchronization source, RFC 3550, page 10. */
+	unsigned int themssrc;		/*!&lt; Their SSRC */
 	unsigned int rxssrc;
 	unsigned int lastts;
 	unsigned int lastdigitts;
@@ -102,6 +126,16 @@
 	unsigned int lastividtimestamp;
 	unsigned int lastovidtimestamp;
 	unsigned int lasteventseqn;
+	int lastrxseqno;                /*!&lt; Last received sequence number */
+	unsigned short seedrxseqno;     /*!&lt; What sequence number did they start with?*/
+	unsigned int seedrxts;          /*!&lt; What RTP timestamp did they start with? */
+	unsigned int rxcount;           /*!&lt; How many packets have we received? */
+	unsigned int rxoctetcount;      /*!&lt; How many octets have we received? should be rxcount *160*/
+	unsigned int txcount;           /*!&lt; How many packets have we sent? */
+	unsigned int txoctetcount;      /*!&lt; How many octets have we sent? (txcount*160)*/
+	unsigned int cycles;            /*!&lt; Shifted count of sequence number cycles */
+	double rxjitter;                /*!&lt; Interarrival jitter at the moment */
+	double rxtransit;               /*!&lt; Relative transit time for previous packet */
 	unsigned int lasteventendseqn;
 	int lasttxformat;
 	int lastrxformat;
@@ -113,6 +147,8 @@
 	struct sockaddr_in them;	/*!&lt; Socket representation of the remote endpoint. */
 	struct timeval rxcore;
 	struct timeval txcore;
+	double drxcore;                 /*!&lt; The double representation of the first received packet */
+	struct timeval lastrx;          /*!&lt; timeval when we last received a packet */
 	struct timeval dtmfmute;
 	struct ast_smoother *smoother;
 	int *ioid;
@@ -143,6 +179,27 @@
 	int s;				/*!&lt; Socket */
 	struct sockaddr_in us;		/*!&lt; Socket representation of the local endpoint. */
 	struct sockaddr_in them;	/*!&lt; Socket representation of the remote endpoint. */
+	unsigned int soc;		/*!&lt; What they told us */
+	unsigned int spc;		/*!&lt; What they told us */
+	unsigned int themrxlsr;		/*!&lt; The middle 32 bits of the NTP timestamp in the last received SR*/
+	struct timeval rxlsr;		/*!&lt; Time when we got their last SR */
+	struct timeval txlsr;		/*!&lt; Time when we sent or last SR*/
+	unsigned int expected_prior;	/*!&lt; no. packets in previous interval */
+	unsigned int received_prior;	/*!&lt; no. packets received in previous interval */
+	int schedid;			/*!&lt; Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/
+	unsigned int rr_count;		/*!&lt; number of RRs we've sent, not including report blocks in SR's */
+	unsigned int sr_count;		/*!&lt; number of SRs we've sent */
+	unsigned int lastsrtxcount;     /*!&lt; Transmit packet count when last SR sent */
+	double accumulated_transit;	/*!&lt; accumulated a-dlsr-lsr */
+	double rtt;			/*!&lt; Last reported rtt */
+	unsigned int reported_jitter;	/*!&lt; The contents of their last jitter entry in the RR */
+	unsigned int reported_lost;	/*!&lt; Reported lost packets in their RR */
+	char quality[AST_MAX_USER_FIELD];
+	double maxrxjitter;
+	double minrxjitter;
+	double maxrtt;
+	double minrtt;
+	int sendfur;
 };
 
 
@@ -408,6 +465,16 @@
 /*! \brief List of current sessions */
 static AST_LIST_HEAD_STATIC(protos, ast_rtp_protocol);
 
+static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw)
+{
+	unsigned int sec, usec, frac;
+	sec = tv.tv_sec + 2208988800u; /* Sec between 1900 and 1970 */
+	usec = tv.tv_usec;
+	frac = (usec &lt;&lt; 12) + (usec &lt;&lt; 8) - ((usec * 3650) &gt;&gt; 6);
+	*msw = sec;
+	*lsw = frac;
+}
+
 int ast_rtp_fd(struct ast_rtp *rtp)
 {
 	return rtp-&gt;s;
@@ -420,6 +487,15 @@
 	return -1;
 }
 
+unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp)
+{
+	unsigned int interval;
+	/*! \todo XXX Do a more reasonable calculation on this one
+	* Look in RFC 3550 Section A.7 for an example*/
+	interval = rtcpinterval;
+	return interval;
+}
+
 void ast_rtp_set_data(struct ast_rtp *rtp, void *data)
 {
 	rtp-&gt;data = data;
@@ -483,6 +559,20 @@
 	return 1;
 }
 
+static inline int rtcp_debug_test_addr(struct sockaddr_in *addr)
+{
+	if (rtcpdebug == 0)
+		return 0;
+	if (rtcpdebugaddr.sin_addr.s_addr) {
+		if (((ntohs(rtcpdebugaddr.sin_port) != 0)
+			&amp;&amp; (rtcpdebugaddr.sin_port != addr-&gt;sin_port))
+			|| (rtcpdebugaddr.sin_addr.s_addr != addr-&gt;sin_addr.s_addr))
+		return 0;
+	}
+	return 1;
+}
+
+
 static struct ast_frame *process_cisco_dtmf(struct ast_rtp *rtp, unsigned char *data, int len)
 {
 	unsigned int event;
@@ -632,33 +722,44 @@
 struct ast_frame *ast_rtcp_read(struct ast_rtp *rtp)
 {
 	socklen_t len;
-	int hdrlen = 8;
+	int position, i, packetwords;
 	int res;
 	struct sockaddr_in sin;
-	unsigned int rtcpdata[1024];
+	unsigned int rtcpdata[8192 + AST_FRIENDLY_OFFSET];
 	char iabuf[INET_ADDRSTRLEN];
+	unsigned int *rtcpheader;
+	int pt;
+	struct timeval now;
+	unsigned int length;
+	int rc;
+	double rtt = 0;
+	double a;
+	double dlsr;
+	double lsr;
+	unsigned int msw;
+	unsigned int lsw;
+	unsigned int comp;
+	struct ast_frame *f = &amp;ast_null_frame;
 	
 	if (!rtp || !rtp-&gt;rtcp)
 		return &amp;ast_null_frame;
 
 	len = sizeof(sin);
 	
-	res = recvfrom(rtp-&gt;rtcp-&gt;s, rtcpdata, sizeof(rtcpdata),
+	res = recvfrom(rtp-&gt;rtcp-&gt;s, rtcpdata + AST_FRIENDLY_OFFSET, sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
 					0, (struct sockaddr *)&amp;sin, &amp;len);
+	rtcpheader = (unsigned int *)(rtcpdata + AST_FRIENDLY_OFFSET);
 	
 	if (res &lt; 0) {
 		if (errno != EAGAIN)
-			ast_log(LOG_WARNING, &quot;RTP Read error: %s\n&quot;, strerror(errno));
+			ast_log(LOG_WARNING, &quot;RTCP Read error: %s\n&quot;, strerror(errno));
 		if (errno == EBADF)
 			CRASH;
 		return &amp;ast_null_frame;
 	}
 
-	if (res &lt; hdrlen) {
-		ast_log(LOG_WARNING, &quot;RTP Read too short\n&quot;);
-		return &amp;ast_null_frame;
-	}
-
+	packetwords = res / 4;
+	
 	if (rtp-&gt;nat) {
 		/* Send to whoever sent to us */
 		if ((rtp-&gt;rtcp-&gt;them.sin_addr.s_addr != sin.sin_addr.s_addr) ||
@@ -670,18 +771,154 @@
 	}
 	if (option_debug)
 		ast_log(LOG_DEBUG, &quot;Got RTCP report of %d bytes\n&quot;, res);
-	return &amp;ast_null_frame;
+
+	/* Process a compound packet */
+	position = 0;
+	while (position &lt; packetwords) {
+		i = position;
+		length = ntohl(rtcpheader[i]);
+		pt = (length &amp; 0xff0000) &gt;&gt; 16;
+		rc = (length &amp; 0x1f000000) &gt;&gt; 24;
+		length &amp;= 0xffff;
+    
+		if ((i + length) &gt; packetwords) {
+			ast_log(LOG_WARNING, &quot;RTCP Read too short\n&quot;);
+			return &amp;ast_null_frame;
+		}
+		
+	if(rtcp_debug_test_addr(&amp;sin)){
+	  	ast_verbose(&quot;\n\nGot RTCP from %s:%d\n&quot;,ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr),ntohs(sin.sin_port));
+	  	ast_verbose(&quot;PT: %d(%s)\n&quot;,pt,(pt==200)?&quot;Sender Report&quot;:(pt==201)?&quot;Receiver Report&quot;:(pt==192)?&quot;H.261 FUR&quot;:&quot;Unknown&quot;);
+	  	ast_verbose(&quot;Reception reports: %d\n&quot;,rc);
+	  	ast_verbose(&quot;SSRC of sender: %u\n&quot;,rtcpheader[i+1]);
+	}
+    
+	i+=2; /* Advance past header and ssrc */
+		
+	switch(pt){
+	  	case RTCP_PT_SR:
+	  		gettimeofday(&amp;rtp-&gt;rtcp-&gt;rxlsr,NULL); /* To be able to populate the dlsr */
+	  		rtp-&gt;rtcp-&gt;spc = ntohl(rtcpheader[i+3]);
+	  		rtp-&gt;rtcp-&gt;soc = ntohl(rtcpheader[i+4]);
+	  		rtp-&gt;rtcp-&gt;themrxlsr = ((ntohl(rtcpheader[i]) &amp; 0x0000ffff) &lt;&lt; 16) | ((ntohl(rtcpheader[i+1]) &amp; 0xffff) &gt;&gt; 16); /* Going to LSR in RR*/
+    
+	  		if(rtcp_debug_test_addr(&amp;sin)){
+	  			ast_verbose(&quot;NTP timestamp: %lu.%010lu\n&quot;,(unsigned long)ntohl(rtcpheader[i]), (unsigned long)ntohl(rtcpheader[i+1])*4096);
+	  			ast_verbose(&quot;RTP timestamp: %lu\n&quot;,(unsigned long)ntohl(rtcpheader[i+2]));
+	  			ast_verbose(&quot;SPC: %lu\tSOC: %lu\n&quot;,(unsigned long)ntohl(rtcpheader[i+3]),(unsigned long)ntohl(rtcpheader[i+4]));
+	  		}
+			i += 5;
+			if (rc &lt; 1)
+				break;
+			/* Intentional fall through */
+	  	case RTCP_PT_RR:
+	  		/* This is the place to calculate RTT */
+				/* Don't handle multiple reception reports (rc &gt; 1) yet */
+	  		gettimeofday(&amp;now, NULL);
+	  		timeval2ntp(now, &amp;msw, &amp;lsw);
+	  		/* Use the one we sent them in our SR instead, rtcp-&gt;txlsr could have been rewritten if the dlsr is large */
+	  		if(ntohl(rtcpheader[i+4])){ /* We must have the LSR */
+	  			comp = ((msw &amp; 0xffff) &lt;&lt; 16) | ((lsw &amp; 0xffff0000) &gt;&gt; 16);
+	  			a = (double)((comp &amp; 0xffff0000) &gt;&gt; 16) + (double)((double)(comp &amp; 0xffff)/1000000.);
+	  			lsr = (double)((ntohl(rtcpheader[i+4]) &amp; 0xffff0000) &gt;&gt; 16) + (double)((double)(ntohl(rtcpheader[i+4]) &amp; 0xffff)/1000000.);
+	  			dlsr = (double)(ntohl(rtcpheader[i+5])/65536.);
+	  			rtt = a - dlsr - lsr;
+	  			rtp-&gt;rtcp-&gt;accumulated_transit += rtt;
+	  			rtp-&gt;rtcp-&gt;rtt = rtt;
+	  			if(rtp-&gt;rtcp-&gt;maxrtt&lt;rtt)
+	  				rtp-&gt;rtcp-&gt;maxrtt = rtt;
+	  			if(rtp-&gt;rtcp-&gt;minrtt&gt;rtt)
+	  				rtp-&gt;rtcp-&gt;minrtt = rtt;
+	  		}
+	  		rtp-&gt;rtcp-&gt;reported_jitter = ntohl(rtcpheader[i+3]);
+	  		rtp-&gt;rtcp-&gt;reported_lost = ntohl(rtcpheader[i+1]) &amp; 0xffffff;
+	  		if(rtcp_debug_test_addr(&amp;sin)){
+	  			ast_verbose(&quot;Fraction lost: %ld\n&quot;, (((long)ntohl(rtcpheader[i+1]) &amp; 0xff000000) &gt;&gt; 24));
+	  			ast_verbose(&quot;Packets lost so far: %d\n&quot;, rtp-&gt;rtcp-&gt;reported_lost);
+	  			ast_verbose(&quot;Highest sequence number: %ld\n&quot;, (long)(ntohl(rtcpheader[i+2]) &amp; 0xffff));
+	  			ast_verbose(&quot;Sequence number cycles: %ld\n&quot;, (long)(ntohl(rtcpheader[i+2]) &amp; 0xffff) &gt;&gt; 16);
+	  			ast_verbose(&quot;Interarrival jitter: %u\n&quot;, rtp-&gt;rtcp-&gt;reported_jitter);
+	  			ast_verbose(&quot;Last SR(our NTP): %lu.%010lu\n&quot;,(unsigned long)ntohl(rtcpheader[i+4])&gt;&gt;16,((unsigned long)ntohl(rtcpheader[i+4])&lt;&lt;16)*4096);
+	  			ast_verbose(&quot;DLSR: %4.4f (sec)\n&quot;,ntohl(rtcpheader[i+5])/65536.0);
+	  			if(rtt)
+	  				ast_verbose(&quot;RTT: %f(sec)\n&quot;, rtt);
+	  		}
+	  		break;
+	  	case RTCP_PT_FUR:
+	  		if(rtcp_debug_test_addr(&amp;sin))
+	  			ast_verbose(&quot;Received an RTCP Fast Update Request\n&quot;);
+	  		rtp-&gt;f.frametype = AST_FRAME_CONTROL;
+	  		rtp-&gt;f.subclass = AST_CONTROL_VIDUPDATE;
+	  		rtp-&gt;f.datalen = 0;
+	  		rtp-&gt;f.samples = 0;
+	  		rtp-&gt;f.mallocd = 0;
+	  		rtp-&gt;f.src = &quot;RTP&quot;;
+	  		f = &amp;rtp-&gt;f;
+	  		break;
+	  	case RTCP_PT_SDES:
+	  		if(rtcp_debug_test_addr(&amp;sin))
+	  			ast_verbose(&quot;Received an SDES from %s:%d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;rtcp-&gt;them.sin_addr), ntohs(rtp-&gt;rtcp-&gt;them.sin_port));
+			  break;
+	  	case RTCP_PT_BYE:
+	  		if(rtcp_debug_test_addr(&amp;sin))
+	  			ast_verbose(&quot;Received a BYE from %s:%d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;rtcp-&gt;them.sin_addr), ntohs(rtp-&gt;rtcp-&gt;them.sin_port));
+			  break;
+	  	default:
+	  		ast_log(LOG_NOTICE, &quot;Unknown RTCP packet (pt=%d) received from %s:%d\n&quot;, pt, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;rtcp-&gt;them.sin_addr), ntohs(rtp-&gt;rtcp-&gt;them.sin_port));
+	  		break;
+		}
+		position += (length + 1);
+	}
+			
+	return f;
 }
 
 static void calc_rxstamp(struct timeval *tv, struct ast_rtp *rtp, unsigned int timestamp, int mark)
 {
-	struct timeval ts = ast_samp2tv( timestamp, 8000);
-	if (ast_tvzero(rtp-&gt;rxcore) || mark) {
-		rtp-&gt;rxcore = ast_tvsub(ast_tvnow(), ts);
-		/* Round to 20ms for nice, pretty timestamps */
-		rtp-&gt;rxcore.tv_usec -= rtp-&gt;rxcore.tv_usec % 20000;
+	struct timeval now;
+	double transit;
+	double current_time;
+	double d;
+	double dtv;
+	double prog;
+	
+	if ((!rtp-&gt;rxcore.tv_sec &amp;&amp; !rtp-&gt;rxcore.tv_usec) || mark) {
+		gettimeofday(&amp;rtp-&gt;rxcore, NULL);
+		rtp-&gt;drxcore = (double)rtp-&gt;rxcore.tv_sec + (double)rtp-&gt;rxcore.tv_usec/1000000;
+		/* map timestamp to a real time */
+		rtp-&gt;seedrxts = timestamp; /* Their RTP timestamp started with this */
+		rtp-&gt;rxcore.tv_sec -= timestamp / 8000;
+		rtp-&gt;rxcore.tv_usec -= (timestamp % 8000) * 125;
+		/* Round to 0.1ms for nice, pretty timestamps */
+		rtp-&gt;rxcore.tv_usec -= rtp-&gt;rxcore.tv_usec % 100;
+		if (rtp-&gt;rxcore.tv_usec &lt; 0) {
+			/* Adjust appropriately if necessary */
+			rtp-&gt;rxcore.tv_usec += 1000000;
+			rtp-&gt;rxcore.tv_sec -= 1;
+		}
 	}
-	*tv = ast_tvadd(rtp-&gt;rxcore, ts);
+
+	gettimeofday(&amp;now,NULL);
+	/* rxcore is the mapping between the RTP timestamp and _our_ real time from gettimeofday() */
+	tv-&gt;tv_sec = rtp-&gt;rxcore.tv_sec + timestamp / 8000;
+	tv-&gt;tv_usec = rtp-&gt;rxcore.tv_usec + (timestamp % 8000) * 125;
+	if (tv-&gt;tv_usec &gt;= 1000000) {
+		tv-&gt;tv_usec -= 1000000;
+		tv-&gt;tv_sec += 1;
+	}
+	prog = (double)((timestamp-rtp-&gt;seedrxts)/8000.);
+	dtv = (double)rtp-&gt;drxcore + (double)(prog);
+	current_time = (double)now.tv_sec + (double)now.tv_usec/1000000;
+	transit = current_time - dtv;
+	d = transit - rtp-&gt;rxtransit;
+	rtp-&gt;rxtransit = transit;
+	if(d&lt;0)
+		d=-d;
+	rtp-&gt;rxjitter += (1./16.) * (d - rtp-&gt;rxjitter);
+	if(rtp-&gt;rxjitter &gt; rtp-&gt;rtcp-&gt;maxrxjitter)
+		rtp-&gt;rtcp-&gt;maxrxjitter = rtp-&gt;rxjitter;
+	if(rtp-&gt;rxjitter &lt; rtp-&gt;rtcp-&gt;minrxjitter)
+		rtp-&gt;rtcp-&gt;minrxjitter = rtp-&gt;rxjitter;
 }
 
 struct ast_frame *ast_rtp_read(struct ast_rtp *rtp)
@@ -692,6 +929,7 @@
 	unsigned int seqno;
 	int version;
 	int payloadtype;
+	int tseqno;
 	int hdrlen = 12;
 	int padding;
 	int mark;
@@ -716,6 +954,7 @@
 			CRASH;
 		return &amp;ast_null_frame;
 	}
+	
 	if (res &lt; hdrlen) {
 		ast_log(LOG_WARNING, &quot;RTP Read too short\n&quot;);
 		return &amp;ast_null_frame;
@@ -746,6 +985,10 @@
 		if ((rtp-&gt;them.sin_addr.s_addr != sin.sin_addr.s_addr) ||
 		    (rtp-&gt;them.sin_port != sin.sin_port)) {
 			rtp-&gt;them = sin;
+			if(rtp-&gt;rtcp) {
+				memcpy(&amp;rtp-&gt;rtcp-&gt;them, &amp;sin, sizeof(rtp-&gt;rtcp-&gt;them));
+				rtp-&gt;rtcp-&gt;them.sin_port = htons(ntohs(rtp-&gt;them.sin_port)+1);
+			}
 			rtp-&gt;rxseqno = 0;
 			ast_set_flag(rtp, FLAG_NAT_ACTIVE);
 			if (option_debug || rtpdebug)
@@ -785,11 +1028,35 @@
 		return &amp;ast_null_frame;
 	}
 
+	rtp-&gt;rxcount++; /* Only count reasonably valid packets, this'll make the rtcp stats more accurate */
+
+	tseqno = rtp-&gt;lastrxseqno +1;
+
+	if(rtp-&gt;rxcount==1){
+		/* This is the first RTP packet successfully received from source */
+		rtp-&gt;seedrxseqno = seqno;
+	}
+
+	if(rtp-&gt;rtcp-&gt;schedid&lt;1){
+		/* Schedule transmission of Receiver Report */
+		rtp-&gt;rtcp-&gt;schedid = ast_sched_add(rtp-&gt;sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
+	}
+
+	if(tseqno &gt; RTP_SEQ_MOD){ /* if tseqno is greater than RTP_SEQ_MOD it would indicate that the sender cycled */
+		rtp-&gt;cycles += RTP_SEQ_MOD;
+		ast_verbose(&quot;SEQNO cycled: %u\t%d\n&quot;, rtp-&gt;cycles, seqno);
+	}
+
+	rtp-&gt;lastrxseqno = seqno;
+	
+	if(rtp-&gt;themssrc==0)
+		rtp-&gt;themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
+	
 	if(rtp_debug_test_addr(&amp;sin))
 		ast_verbose(&quot;Got  RTP packet from %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n&quot;,
 			ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
 
-   	rtpPT = ast_rtp_lookup_pt(rtp, payloadtype);
+	rtpPT = ast_rtp_lookup_pt(rtp, payloadtype);
 	if (!rtpPT.isAstFormat) {
 		struct ast_frame *f = NULL;
 
@@ -1202,7 +1469,7 @@
 	if (pt &lt; 0 || pt &gt; MAX_RTP_PT) 
 		return result; /* bogus payload type */
 
-	/* Start with the negotiated codecs */
+	/* Start with negotiated codecs */
 	result = rtp-&gt;current_RTP_PT[pt];
 
 	/* If it doesn't exist, check our static RTP type list, just in case */
@@ -1225,7 +1492,7 @@
 
 	/* Check the dynamic list first */
 	for (pt = 0; pt &lt; MAX_RTP_PT; ++pt) {
-  		if (rtp-&gt;current_RTP_PT[pt].code == code &amp;&amp; rtp-&gt;current_RTP_PT[pt].isAstFormat == isAstFormat) {
+		if (rtp-&gt;current_RTP_PT[pt].code == code &amp;&amp; rtp-&gt;current_RTP_PT[pt].isAstFormat == isAstFormat) {
 			rtp-&gt;rtp_lookup_code_cache_isAstFormat = isAstFormat;
 			rtp-&gt;rtp_lookup_code_cache_code = code;
 			rtp-&gt;rtp_lookup_code_cache_result = pt;
@@ -1321,9 +1588,11 @@
 		return NULL;
 	rtcp-&gt;s = rtp_socket();
 	rtcp-&gt;us.sin_family = AF_INET;
+	rtcp-&gt;them.sin_family = AF_INET;
+
 	if (rtcp-&gt;s &lt; 0) {
 		free(rtcp);
-		ast_log(LOG_WARNING, &quot;Unable to allocate socket: %s\n&quot;, strerror(errno));
+		ast_log(LOG_WARNING, &quot;Unable to allocate RTCP socket: %s\n&quot;, strerror(errno));
 		return NULL;
 	}
 
@@ -1465,11 +1734,16 @@
 
 void ast_rtp_stop(struct ast_rtp *rtp)
 {
+	if(rtp-&gt;rtcp-&gt;schedid&gt;0){
+		ast_sched_del(rtp-&gt;sched, rtp-&gt;rtcp-&gt;schedid);
+		rtp-&gt;rtcp-&gt;schedid = -1;
+	}
+
 	memset(&amp;rtp-&gt;them.sin_addr, 0, sizeof(rtp-&gt;them.sin_addr));
 	memset(&amp;rtp-&gt;them.sin_port, 0, sizeof(rtp-&gt;them.sin_port));
 	if (rtp-&gt;rtcp) {
-		memset(&amp;rtp-&gt;rtcp-&gt;them.sin_addr, 0, sizeof(rtp-&gt;them.sin_addr));
-		memset(&amp;rtp-&gt;rtcp-&gt;them.sin_port, 0, sizeof(rtp-&gt;them.sin_port));
+		memset(&amp;rtp-&gt;rtcp-&gt;them.sin_addr, 0, sizeof(rtp-&gt;rtcp-&gt;them.sin_addr));
+		memset(&amp;rtp-&gt;rtcp-&gt;them.sin_port, 0, sizeof(rtp-&gt;rtcp-&gt;them.sin_port));
 	}
 }
 
@@ -1493,8 +1767,50 @@
 	rtp-&gt;rxseqno = 0;
 }
 
+char *ast_rtp_get_quality(struct ast_rtp *rtp)
+{
+	/*
+	*ssrc          our ssrc
+	*themssrc      their ssrc
+	*lp            lost packets
+	*rxjitter      our calculated jitter(rx)
+	*rxcount       no. received packets
+	*txjitter      reported jitter of the other end
+	*txcount       transmitted packets
+	*rlp           remote lost packets
+	*/
+	
+	snprintf(rtp-&gt;rtcp-&gt;quality, sizeof(rtp-&gt;rtcp-&gt;quality), &quot;ssrc=%u;themssrc=%u;lp=%u;rxjitter=%f;rxcount=%u;txjitter=%f;txcount=%u;rlp=%u;rtt=%f&quot;, rtp-&gt;ssrc, rtp-&gt;themssrc, rtp-&gt;rtcp-&gt;expected_prior - rtp-&gt;rtcp-&gt;received_prior, rtp-&gt;rxjitter, rtp-&gt;rxcount, (double)rtp-&gt;rtcp-&gt;reported_jitter/65536., rtp-&gt;txcount, rtp-&gt;rtcp-&gt;reported_lost, rtp-&gt;rtcp-&gt;rtt);
+	
+	return rtp-&gt;rtcp-&gt;quality;
+}
+
 void ast_rtp_destroy(struct ast_rtp *rtp)
 {
+	if(rtcp_debug_test_addr(&amp;rtp-&gt;them) || rtcpstats){
+		/*Print some info on the call here */
+		ast_verbose(&quot;  RTP-stats\n&quot;);
+		ast_verbose(&quot;* Our Receiver:\n&quot;);
+		ast_verbose(&quot;  SSRC:		 %u\n&quot;, rtp-&gt;themssrc);
+		ast_verbose(&quot;  Received packets: %u\n&quot;, rtp-&gt;rxcount);
+		ast_verbose(&quot;  Lost packets:	 %u\n&quot;, rtp-&gt;rtcp-&gt;expected_prior - rtp-&gt;rtcp-&gt;received_prior);
+		ast_verbose(&quot;  Jitter:		 %.4f\n&quot;, rtp-&gt;rxjitter);
+		ast_verbose(&quot;  Transit:		 %.4f\n&quot;, rtp-&gt;rxtransit);
+		ast_verbose(&quot;  RR-count:	 %u\n&quot;, rtp-&gt;rtcp-&gt;rr_count);
+		ast_verbose(&quot;* Our Sender:\n&quot;);
+		ast_verbose(&quot;  SSRC:		 %u\n&quot;, rtp-&gt;ssrc);
+		ast_verbose(&quot;  Sent packets:	 %u\n&quot;, rtp-&gt;txcount);
+		ast_verbose(&quot;  Lost packets:	 %u\n&quot;, rtp-&gt;rtcp-&gt;reported_lost);
+		ast_verbose(&quot;  Jitter:		 %u\n&quot;, rtp-&gt;rtcp-&gt;reported_jitter);
+		ast_verbose(&quot;  SR-count:	 %u\n&quot;, rtp-&gt;rtcp-&gt;sr_count);
+		ast_verbose(&quot;  RTT:		 %f\n&quot;, rtp-&gt;rtcp-&gt;rtt);
+	}
+
+	if(rtp-&gt;rtcp-&gt;schedid&gt;0){
+		ast_sched_del(rtp-&gt;sched, rtp-&gt;rtcp-&gt;schedid);
+		rtp-&gt;rtcp-&gt;schedid = -1;
+	}
+
 	if (rtp-&gt;smoother)
 		ast_smoother_free(rtp-&gt;smoother);
 	if (rtp-&gt;ioid)
@@ -1504,6 +1820,7 @@
 	if (rtp-&gt;rtcp) {
 		close(rtp-&gt;rtcp-&gt;s);
 		free(rtp-&gt;rtcp);
+		rtp-&gt;rtcp=NULL;
 	}
 	free(rtp);
 }
@@ -1596,7 +1913,7 @@
 			rtpheader[3] |= htonl((1 &lt;&lt; 23));
 		}
 	}
-	/* Increment the digit timestamp by 120ms, to ensure that digits
+	/*! \note Increment the digit timestamp by 120ms, to ensure that digits
 	   sent sequentially with no intervening non-digit packets do not
 	   get sent with the same timestamp, and that sequential digits
 	   have some 'dead air' in between them
@@ -1609,6 +1926,244 @@
 	return 0;
 }
 
+/* \brief Public function: Send an H.261 fast update request, some devices need this rather than SIP XML */
+int ast_rtcp_send_h261fur(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+
+	rtp-&gt;rtcp-&gt;sendfur = 1;
+	res = ast_rtcp_write(data);
+	
+	return res;
+}
+
+/*! \brief Send RTCP sender's report */
+static int ast_rtcp_write_sr(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+	int len = 0;
+	struct timeval now;
+	unsigned int now_lsw;
+	unsigned int now_msw;
+	unsigned int *rtcpheader;
+	unsigned int lost;
+	unsigned int extended;
+	unsigned int expected;
+	unsigned int expected_interval;
+	unsigned int received_interval;
+	int lost_interval;
+	int fraction;
+	struct timeval dlsr;
+	char bdata[512];
+	char iabuf[INET_ADDRSTRLEN];
+
+	if(!rtp || !rtp-&gt;rtcp || (&amp;rtp-&gt;rtcp-&gt;them.sin_addr == 0))
+		return 0;
+	
+	if(!rtp-&gt;rtcp-&gt;them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
+		ast_verbose(&quot;RTCP SR transmission error, rtcp halted %s\n&quot;,strerror(errno));
+		ast_sched_del(rtp-&gt;sched, rtp-&gt;rtcp-&gt;schedid);
+		rtp-&gt;rtcp-&gt;schedid = -1;
+		return 0;
+	}
+
+	gettimeofday(&amp;now, NULL);
+	timeval2ntp(now, &amp;now_msw, &amp;now_lsw); /* fill thses ones in from utils.c*/
+	rtcpheader = (unsigned int *)bdata;
+	rtcpheader[1] = htonl(rtp-&gt;ssrc);               /* Our SSRC */
+	rtcpheader[2] = htonl(now_msw);                 /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970*/
+	rtcpheader[3] = htonl(now_lsw);                 /* now, LSW */
+	rtcpheader[4] = htonl(rtp-&gt;lastts);             /* FIXME shouldn't be that, it should be now */
+	rtcpheader[5] = htonl(rtp-&gt;txcount);            /* No. packets sent */
+	rtcpheader[6] = htonl(rtp-&gt;txoctetcount);       /* No. bytes sent */
+	len += 28;
+	
+	extended = rtp-&gt;cycles + rtp-&gt;lastrxseqno;
+	expected = extended - rtp-&gt;seedrxseqno + 1;
+	if (rtp-&gt;rxcount &gt; expected) 
+		expected += rtp-&gt;rxcount - expected;
+	lost = expected - rtp-&gt;rxcount;
+	expected_interval = expected - rtp-&gt;rtcp-&gt;expected_prior;
+	rtp-&gt;rtcp-&gt;expected_prior = expected;
+	received_interval = rtp-&gt;rxcount - rtp-&gt;rtcp-&gt;received_prior;
+	rtp-&gt;rtcp-&gt;received_prior = rtp-&gt;rxcount;
+	lost_interval = expected_interval - received_interval;
+	if (expected_interval == 0 || lost_interval &lt;= 0)
+		fraction = 0;
+	else
+		fraction = (lost_interval &lt;&lt; 8) / expected_interval;
+	timersub(&amp;now, &amp;rtp-&gt;rtcp-&gt;rxlsr, &amp;dlsr);
+	rtcpheader[7] = htonl(rtp-&gt;themssrc);
+	rtcpheader[8] = htonl(((fraction &amp; 0xff) &lt;&lt; 24) | (lost &amp; 0xffffff));
+	rtcpheader[9] = htonl((rtp-&gt;cycles) | ((rtp-&gt;lastrxseqno &amp; 0xffff)));
+	rtcpheader[10] = htonl((unsigned int)rtp-&gt;rxjitter);
+	rtcpheader[11] = htonl(rtp-&gt;rtcp-&gt;themrxlsr);
+	rtcpheader[12] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
+	len += 24;
+	
+	rtcpheader[0] = htonl((2 &lt;&lt; 30) | (1 &lt;&lt; 24) | (RTCP_PT_SR &lt;&lt; 16) | ((len/4)-1));
+
+	if (rtp-&gt;rtcp-&gt;sendfur) {
+		rtcpheader[13] = htonl((2 &lt;&lt; 30) | (0 &lt;&lt; 24) | (RTCP_PT_FUR &lt;&lt; 16) | 1);
+		rtcpheader[14] = htonl(rtp-&gt;ssrc);               /* Our SSRC */
+		len += 8;
+		rtp-&gt;rtcp-&gt;sendfur = 0;
+	}
+	
+	/* Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos */ 
+	/* it can change mid call, and SDES can't) */
+	rtcpheader[len/4]     = htonl((2 &lt;&lt; 30) | (1 &lt;&lt; 24) | (RTCP_PT_SDES &lt;&lt; 16) | 2);
+	rtcpheader[(len/4)+1] = htonl(rtp-&gt;ssrc);               /* Our SSRC */
+	rtcpheader[(len/4)+2] = htonl(0x01 &lt;&lt; 24);                    /* Empty for the moment */
+	len += 12;
+	
+	res = sendto(rtp-&gt;rtcp-&gt;s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&amp;rtp-&gt;rtcp-&gt;them, sizeof(rtp-&gt;rtcp-&gt;them));
+	if (res &lt; 0) {
+		ast_log(LOG_ERROR, &quot;RTCP SR transmission error to %s:%d, rtcp halted %s\n&quot;,ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;rtcp-&gt;them.sin_addr), ntohs(rtp-&gt;rtcp-&gt;them.sin_port), strerror(errno));
+		ast_sched_del(rtp-&gt;sched, rtp-&gt;rtcp-&gt;schedid);
+		rtp-&gt;rtcp-&gt;schedid = -1;
+		return 0;
+	}
+	
+	/* FIXME Don't need to get a new one */
+	gettimeofday(&amp;rtp-&gt;rtcp-&gt;txlsr, NULL);
+	rtp-&gt;rtcp-&gt;sr_count++;
+
+	rtp-&gt;rtcp-&gt;lastsrtxcount = rtp-&gt;txcount;	
+	
+	if (rtcp_debug_test_addr(&amp;rtp-&gt;rtcp-&gt;them)) {
+		ast_verbose(&quot;* Sent RTCP SR to %s:%d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;rtcp-&gt;them.sin_addr), ntohs(rtp-&gt;rtcp-&gt;them.sin_port));
+		ast_verbose(&quot;  Our SSRC: %u\n&quot;, rtp-&gt;ssrc);
+		ast_verbose(&quot;  Sent(NTP): %u.%010u\n&quot;, (unsigned int)now.tv_sec, (unsigned int)now.tv_usec*4096);
+		ast_verbose(&quot;  Sent(RTP): %u\n&quot;, rtp-&gt;lastts);
+		ast_verbose(&quot;  Sent packets: %u\n&quot;, rtp-&gt;txcount);
+		ast_verbose(&quot;  Sent octets: %u\n&quot;, rtp-&gt;txoctetcount);
+		ast_verbose(&quot;  Report block:\n&quot;);
+		ast_verbose(&quot;  Fraction lost: %u\n&quot;, fraction);
+		ast_verbose(&quot;  Cumulative loss: %u\n&quot;, lost);
+		ast_verbose(&quot;  IA jitter: %.4f\n&quot;, rtp-&gt;rxjitter);
+		ast_verbose(&quot;  Their last SR: %u\n&quot;, rtp-&gt;rtcp-&gt;themrxlsr);
+		ast_verbose(&quot;  DLSR: %4.4f (sec)\n\n&quot;, (double)(ntohl(rtcpheader[12])/65536.0));
+	}
+	return res;
+}
+
+/*! \brief Send RTCP recepient's report */
+static int ast_rtcp_write_rr(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+	int len = 32;
+	unsigned int lost;
+	unsigned int extended;
+	unsigned int expected;
+	unsigned int expected_interval;
+	unsigned int received_interval;
+	int lost_interval;
+	struct timeval now;
+	unsigned int *rtcpheader;
+	char bdata[1024];
+	char iabuf[INET_ADDRSTRLEN];
+	struct timeval dlsr;
+	int fraction;
+
+	if (!rtp || !rtp-&gt;rtcp || (&amp;rtp-&gt;rtcp-&gt;them.sin_addr == 0))
+		return 0;
+	  
+	if (!rtp-&gt;rtcp-&gt;them.sin_addr.s_addr){
+		ast_log(LOG_ERROR, &quot;RTCP RR transmission error to, rtcp halted %s\n&quot;,strerror(errno));
+		ast_sched_del(rtp-&gt;sched, rtp-&gt;rtcp-&gt;schedid);
+		rtp-&gt;rtcp-&gt;schedid = -1;
+		return 0;
+	}
+
+	extended = rtp-&gt;cycles + rtp-&gt;lastrxseqno;
+	expected = extended - rtp-&gt;seedrxseqno + 1;
+	lost = expected - rtp-&gt;rxcount;
+	expected_interval = expected - rtp-&gt;rtcp-&gt;expected_prior;
+	rtp-&gt;rtcp-&gt;expected_prior = expected;
+	received_interval = rtp-&gt;rxcount - rtp-&gt;rtcp-&gt;received_prior;
+	rtp-&gt;rtcp-&gt;received_prior = rtp-&gt;rxcount;
+	lost_interval = expected_interval - received_interval;
+	if (expected_interval == 0 || lost_interval &lt;= 0)
+		fraction = 0;
+	else
+		fraction = (lost_interval &lt;&lt; 8) / expected_interval;
+	gettimeofday(&amp;now, NULL);
+	timersub(&amp;now, &amp;rtp-&gt;rtcp-&gt;rxlsr, &amp;dlsr);
+	rtcpheader = (unsigned int *)bdata;
+	rtcpheader[0] = htonl((2 &lt;&lt; 30) | (1 &lt;&lt; 24) | (RTCP_PT_RR &lt;&lt; 16) | ((len/4)-1));
+	rtcpheader[1] = htonl(rtp-&gt;ssrc);
+	rtcpheader[2] = htonl(rtp-&gt;themssrc);
+	rtcpheader[3] = htonl(((fraction &amp; 0xff) &lt;&lt; 24) | (lost &amp; 0xffffff));
+	rtcpheader[4] = htonl((rtp-&gt;cycles) | ((rtp-&gt;lastrxseqno &amp; 0xffff)));
+	rtcpheader[5] = htonl((unsigned int)rtp-&gt;rxjitter);
+	rtcpheader[6] = htonl(rtp-&gt;rtcp-&gt;themrxlsr);
+	rtcpheader[7] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
+
+	if (rtp-&gt;rtcp-&gt;sendfur) {
+		rtcpheader[8] = htonl((2 &lt;&lt; 30) | (0 &lt;&lt; 24) | (RTCP_PT_FUR &lt;&lt; 16) | 1); /* Header from page 36 in RFC 3550 */
+		rtcpheader[9] = htonl(rtp-&gt;ssrc);               /* Our SSRC */
+		len += 8;
+		rtp-&gt;rtcp-&gt;sendfur = 0;
+	}
+
+	/*! \note Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos 
+	it can change mid call, and SDES can't) */
+	rtcpheader[len/4]     = htonl((2 &lt;&lt; 30) | (1 &lt;&lt; 24) | (RTCP_PT_SDES &lt;&lt; 16) | 2);
+	rtcpheader[(len/4)+1] = htonl(rtp-&gt;ssrc);               /* Our SSRC */
+	rtcpheader[(len/4)+2] = htonl(0x01 &lt;&lt; 24);              /* Empty for the moment */
+	len += 12;
+	
+	res = sendto(rtp-&gt;rtcp-&gt;s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&amp;rtp-&gt;rtcp-&gt;them, sizeof(rtp-&gt;rtcp-&gt;them));
+
+	if (res &lt; 0) {
+		ast_log(LOG_ERROR, &quot;RTCP RR transmission error, rtcp halted: %s\n&quot;,strerror(errno));
+		/* Remove the scheduler */
+		ast_sched_del(rtp-&gt;sched, rtp-&gt;rtcp-&gt;schedid);
+		rtp-&gt;rtcp-&gt;schedid = -1;
+		return 0;
+	}
+
+	rtp-&gt;rtcp-&gt;rr_count++;
+
+	if (rtcp_debug_test_addr(&amp;rtp-&gt;rtcp-&gt;them)) {
+		ast_verbose(&quot;\n* Sending RTCP RR to %s:%d\n&quot;
+			&quot;  Our SSRC: %u\nTheir SSRC: %u\niFraction lost: %d\nCumulative loss: %u\n&quot; 
+			&quot;  IA jitter: %.4f\n&quot; 
+			&quot;  Their last SR: %u\n&quot; 
+			&quot;  DLSR: %4.4f (sec)\n\n&quot;,
+			ast_inet_ntoa(iabuf, sizeof(iabuf),
+			rtp-&gt;rtcp-&gt;them.sin_addr),
+			ntohs(rtp-&gt;rtcp-&gt;them.sin_port),
+			rtp-&gt;ssrc, rtp-&gt;themssrc, fraction, lost,
+			rtp-&gt;rxjitter,
+			rtp-&gt;rtcp-&gt;themrxlsr,
+			(double)(ntohl(rtcpheader[7])/65536.0));
+	}
+
+	return res;
+}
+
+/*! \brief Write and RTCP packet to the far end
+ * \note Decide if we are going to send an SR (with Reception Block) or RR 
+ * RR is sent if we have not sent any rtp packets in the previous interval */
+static int ast_rtcp_write(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+	
+	if (rtp-&gt;txcount &gt; rtp-&gt;rtcp-&gt;lastsrtxcount)
+		res = ast_rtcp_write_sr(data);
+	else
+		res = ast_rtcp_write_rr(data);
+	
+	return res;
+}
+
+/*! \brief generate comfort noice (CNG) */
 int ast_rtp_sendcng(struct ast_rtp *rtp, int level)
 {
 	unsigned int *rtpheader;
@@ -1637,7 +2192,7 @@
 		if (res &lt;0) 
 			ast_log(LOG_ERROR, &quot;RTP Comfort Noise Transmission error to %s:%d: %s\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;them.sin_addr), ntohs(rtp-&gt;them.sin_port), strerror(errno));
 		if(rtp_debug_test_addr(&amp;rtp-&gt;them))
-			ast_verbose(&quot;Sent Comfort Noise RTP packet to %s:%d (type %d, seq %d, ts %d, len %d)\n&quot;
+			ast_verbose(&quot;Sent Comfort Noise RTP packet to %s:%d (type %d, seq %d, ts %u, len %d)\n&quot;
 					, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;them.sin_addr), ntohs(rtp-&gt;them.sin_port), payload, rtp-&gt;seqno, rtp-&gt;lastts,res - hdrlen);		   
 		   
 	}
@@ -1716,11 +2271,17 @@
 					ast_log(LOG_DEBUG, &quot;RTP NAT: Can't write RTP to private address %s:%d, waiting for other end to send audio...\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;them.sin_addr), ntohs(rtp-&gt;them.sin_port));
 				ast_set_flag(rtp, FLAG_NAT_INACTIVE_NOWARN);
 			}
+		} else {
+			rtp-&gt;txcount++;
+			rtp-&gt;txoctetcount +=(res - hdrlen);
+			
+			if (rtp-&gt;rtcp-&gt;schedid &lt; 1) 
+			    rtp-&gt;rtcp-&gt;schedid = ast_sched_add(rtp-&gt;sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
 		}
 				
 		if(rtp_debug_test_addr(&amp;rtp-&gt;them))
-			ast_verbose(&quot;Sent RTP packet to   %s:%d (type %d, seq %u, ts %u, len %u)\n&quot;,
-				ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;them.sin_addr), ntohs(rtp-&gt;them.sin_port), codec, rtp-&gt;seqno, rtp-&gt;lastts,res - hdrlen);
+			ast_verbose(&quot;Sent RTP packet to %s:%d (type %d, seq %u, ts %u, len %u)\n&quot;,
+					ast_inet_ntoa(iabuf, sizeof(iabuf), rtp-&gt;them.sin_addr), ntohs(rtp-&gt;them.sin_port), codec, rtp-&gt;seqno, rtp-&gt;lastts,res - hdrlen);
 	}
 
 	rtp-&gt;seqno++;
@@ -2176,6 +2737,37 @@
 	return RESULT_SUCCESS;
 }
 
+static int rtcp_do_debug_ip(int fd, int argc, char *argv[])
+{
+	struct hostent *hp;
+	struct ast_hostent ahp;
+	char iabuf[INET_ADDRSTRLEN];
+	int port = 0;
+	char *p, *arg;
+	if (argc != 5)
+		return RESULT_SHOWUSAGE;
+
+	arg = argv[4];
+	p = strstr(arg, &quot;:&quot;);
+	if (p) {
+		*p = '\0';
+		p++;
+		port = atoi(p);
+	}
+	hp = ast_gethostbyname(arg, &amp;ahp);
+	if (hp == NULL)
+		return RESULT_SHOWUSAGE;
+	rtcpdebugaddr.sin_family = AF_INET;
+	memcpy(&amp;rtcpdebugaddr.sin_addr, hp-&gt;h_addr, sizeof(rtcpdebugaddr.sin_addr));
+	rtcpdebugaddr.sin_port = htons(port);
+	if (port == 0)
+		ast_cli(fd, &quot;RTCP Debugging Enabled for IP: %s\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtcpdebugaddr.sin_addr));
+	else
+		ast_cli(fd, &quot;RTCP Debugging Enabled for IP: %s:%d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), rtcpdebugaddr.sin_addr), port);
+	rtcpdebug = 1;
+	return RESULT_SUCCESS;
+}
+
 static int rtp_do_debug(int fd, int argc, char *argv[])
 {
 	if(argc != 2) {
@@ -2189,6 +2781,27 @@
 	return RESULT_SUCCESS;
 }
    
+static int rtcp_do_debug(int fd, int argc, char *argv[]){
+	if(argc != 3){
+		if(argc != 5)
+			return RESULT_SHOWUSAGE;
+		return rtcp_do_debug_ip(fd, argc, argv);
+	}
+	rtcpdebug = 1;
+	memset(&amp;rtcpdebugaddr,0,sizeof(rtcpdebugaddr));
+	ast_cli(fd, &quot;RTCP Debugging Enabled\n&quot;);
+	return RESULT_SUCCESS;
+}
+
+static int rtcp_do_stats(int fd, int argc, char *argv[]){
+	if(argc != 3){
+		return RESULT_SHOWUSAGE;
+	}
+	rtcpstats = 1;
+	ast_cli(fd, &quot;RTCP Stats Enabled\n&quot;);
+	return RESULT_SUCCESS;
+}
+
 static int rtp_no_debug(int fd, int argc, char *argv[])
 {
 	if(argc !=3)
@@ -2198,6 +2811,25 @@
 	return RESULT_SUCCESS;
 }
 
+static int rtcp_no_debug(int fd, int argc, char *argv[])
+{
+	if(argc !=4)
+		return RESULT_SHOWUSAGE;
+	rtcpdebug = 0;
+	ast_cli(fd,&quot;RTCP Debugging Disabled\n&quot;);
+	return RESULT_SUCCESS;
+}
+
+static int rtcp_no_stats(int fd, int argc, char *argv[])
+{
+	if(argc !=4)
+		return RESULT_SHOWUSAGE;
+	rtcpstats = 0;
+	ast_cli(fd,&quot;RTCP Stats Disabled\n&quot;);
+	return RESULT_SUCCESS;
+}
+
+
 static int stun_do_debug(int fd, int argc, char *argv[])
 {
 	if(argc != 2) {
@@ -2244,6 +2876,37 @@
 static struct ast_cli_entry  cli_no_debug =
 {{ &quot;rtp&quot;, &quot;no&quot;, &quot;debug&quot;, NULL } , rtp_no_debug, &quot;Disable RTP debugging&quot;, no_debug_usage };
 
+static char rtcp_debug_usage[] =
+  &quot;Usage: rtp rtcp debug [ip host[:port]]\n&quot;
+  &quot;       Enable dumping of all RTCP packets to and from host.\n&quot;;
+  
+static char rtcp_no_debug_usage[] =
+  &quot;Usage: rtp rtcp no debug\n&quot;
+  &quot;       Disable all RTCP debugging\n&quot;;
+
+static char rtcp_stats_usage[] =
+  &quot;Usage: rtp rtcp stats\n&quot;
+  &quot;       Enable dumping of RTCP stats.\n&quot;;
+  
+static char rtcp_no_stats_usage[] =
+  &quot;Usage: rtp rtcp no stats\n&quot;
+  &quot;       Disable all RTCP stats\n&quot;;
+
+static struct ast_cli_entry  cli_debug_ip_rtcp =
+{{ &quot;rtp&quot;, &quot;rtcp&quot;, &quot;debug&quot;, &quot;ip&quot;, NULL } , rtcp_do_debug, &quot;Enable RTCP debugging on IP&quot;, rtcp_debug_usage };
+
+static struct ast_cli_entry  cli_debug_rtcp =
+{{ &quot;rtp&quot;, &quot;rtcp&quot;, &quot;debug&quot;, NULL } , rtcp_do_debug, &quot;Enable RTCP debugging&quot;, rtcp_debug_usage };
+
+static struct ast_cli_entry  cli_no_debug_rtcp =
+{{ &quot;rtp&quot;, &quot;rtcp&quot;, &quot;no&quot;, &quot;debug&quot;, NULL } , rtcp_no_debug, &quot;Disable RTCP debugging&quot;, rtcp_no_debug_usage };
+
+static struct ast_cli_entry  cli_stats_rtcp =
+{{ &quot;rtp&quot;, &quot;rtcp&quot;, &quot;stats&quot;, NULL } , rtcp_do_stats, &quot;Enable RTCP stats&quot;, rtcp_stats_usage };
+
+static struct ast_cli_entry  cli_no_stats_rtcp =
+{{ &quot;rtp&quot;, &quot;rtcp&quot;, &quot;no&quot;, &quot;stats&quot;, NULL } , rtcp_no_stats, &quot;Disable RTCP stats&quot;, rtcp_no_stats_usage };
+
 static struct ast_cli_entry  cli_stun_debug =
 {{ &quot;stun&quot;, &quot;debug&quot;, NULL } , stun_do_debug, &quot;Enable STUN debugging&quot;, stun_debug_usage };
 
@@ -2274,6 +2937,15 @@
 			if (rtpend &gt; 65535)
 				rtpend = 65535;
 		}
+		if ((s = ast_variable_retrieve(cfg, &quot;general&quot;, &quot;rtcpinterval&quot;))) {
+			rtcpinterval = atoi(s);
+			if (rtcpinterval == 0)
+				rtcpinterval = 0; /* Just so we're clear... it's zero */
+			if (rtcpinterval &lt; RTCP_MIN_INTERVALMS)
+				rtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */
+			if (rtcpinterval &gt; RTCP_MAX_INTERVALMS)
+				rtcpinterval = RTCP_MAX_INTERVALMS;
+		}
 		if ((s = ast_variable_retrieve(cfg, &quot;general&quot;, &quot;rtpchecksums&quot;))) {
 #ifdef SO_NO_CHECK
 			if (ast_false(s))
@@ -2311,7 +2983,16 @@
 	ast_cli_register(&amp;cli_debug);
 	ast_cli_register(&amp;cli_debug_ip);
 	ast_cli_register(&amp;cli_no_debug);
+
+	ast_cli_register(&amp;cli_debug_rtcp);
+	ast_cli_register(&amp;cli_debug_ip_rtcp);
+	ast_cli_register(&amp;cli_no_debug_rtcp);
+
+	ast_cli_register(&amp;cli_stats_rtcp);
+	ast_cli_register(&amp;cli_no_stats_rtcp);
+	
 	ast_cli_register(&amp;cli_stun_debug);
 	ast_cli_register(&amp;cli_stun_no_debug);
 	ast_rtp_reload();
 }
+


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000249.html">[solid-pbx-svn] r254 - trunk/channels
</A></li>
	<LI>Next message: <A HREF="000251.html">[solid-pbx-svn] r256 - trunk/configs
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#250">[ date ]</a>
              <a href="thread.html#250">[ thread ]</a>
              <a href="subject.html#250">[ subject ]</a>
              <a href="author.html#250">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
