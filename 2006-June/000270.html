<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [solid-pbx-svn] r275 - in trunk: . channels include/asterisk
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r275%20-%20in%20trunk%3A%20.%20channels%20include/asterisk&In-Reply-To=%3C200606182111.k5ILBArK013069%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000269.html">
   <LINK REL="Next"  HREF="000271.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[solid-pbx-svn] r275 - in trunk: . channels include/asterisk</H1>
    <B>solid-pbx-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r275%20-%20in%20trunk%3A%20.%20channels%20include/asterisk&In-Reply-To=%3C200606182111.k5ILBArK013069%40sheep.berlios.de%3E"
       TITLE="[solid-pbx-svn] r275 - in trunk: . channels include/asterisk">solid-pbx-svn-admin at lists.berlios.de
       </A><BR>
    <I>Sun Jun 18 23:11:10 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000269.html">[solid-pbx-svn] r274 - trunk/channels
</A></li>
        <LI>Next message: <A HREF="000271.html">[solid-pbx-svn] r276 - trunk/apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#270">[ date ]</a>
              <a href="thread.html#270">[ thread ]</a>
              <a href="subject.html#270">[ subject ]</a>
              <a href="author.html#270">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-06-18 23:11:06 +0200 (Sun, 18 Jun 2006)
New Revision: 275

Modified:
   trunk/callerid.c
   trunk/channel.c
   trunk/channels/chan_sip.c
   trunk/frame.c
   trunk/include/asterisk/rtp.h
   trunk/include/asterisk/translate.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32603

------------------------------------------------------------------------
r32596 | tilghman | 2006-06-06 18:05:29 +0200 (Tue, 06 Jun 2006) | 10 lines

Merged revisions 32582 via svnmerge from 
<A HREF="https://origsvn.digium.com/svn/asterisk/branches/1.2">https://origsvn.digium.com/svn/asterisk/branches/1.2</A>

.......
r32582 | tilghman | 2006-06-06 11:02:43 -0500 (Tue, 06 Jun 2006) | 2 lines

Bug 7268 - Callerid leaks memory on error

.......

------------------------------------------------------------------------
r32597 | oej | 2006-06-06 18:09:33 +0200 (Tue, 06 Jun 2006) | 13 lines

Merge of the &quot;sdpcleanup&quot; branch. Thanks to John Martin for a lot of tests
and some patches (all disclaimed).

- Don't change RTP properties if we reject a re-INVITE
- Don't add video to an outbound channel if there's no video on the inbound channel
- Don't include video in the &quot;preferred codec&quot; list for codec selection
- Clean up and document code that parses and adds SDP attachments

Since we do not transcode video, we can't handle video the same way as audio. This is a
bug fix patch. In future releases, we need to work on a solution for video negotiation,
not codecs but formats and framerates instead.


------------------------------------------------------------------------


Modified: trunk/callerid.c
===================================================================
--- trunk/callerid.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/callerid.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -557,6 +557,7 @@
 		res = fsk_serie(&amp;cid-&gt;fskd, buf, &amp;mylen, &amp;b);
 		if (mylen &lt; 0) {
 			ast_log(LOG_ERROR, &quot;fsk_serie made mylen &lt; 0 (%d)\n&quot;, mylen);
+			free(obuf);
 			return -1;
 		}
 		buf += (olen - mylen);
@@ -590,6 +591,7 @@
 			case 4: /* Retrieve message */
 				if (cid-&gt;pos &gt;= 128) {
 					ast_log(LOG_WARNING, &quot;Caller ID too long???\n&quot;);
+					free(obuf);
 					return -1;
 				}
 				cid-&gt;rawdata[cid-&gt;pos++] = b;
@@ -675,6 +677,7 @@
 					strcpy(cid-&gt;name, &quot;&quot;);
 					cid-&gt;flags |= CID_UNKNOWN_NAME;
 				}
+				free(obuf);
 				return 1;
 				break;
 			default:

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/channel.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -539,7 +539,7 @@
 	}
 }
 
-/*! \brief Pick the best codec */
+/*! \brief Pick the best audio codec */
 int ast_best_codec(int fmts)
 {
 	/* This just our opinion, expressed in code.  We are asked to choose
@@ -572,8 +572,10 @@
 		/*! Down to G.723.1 which is proprietary but at least designed for voice */
 		AST_FORMAT_G723_1,
 	};
+
+	/* Strip out video */
+	fmts &amp;= AST_FORMAT_AUDIO_MASK;
 	
-	
 	/* Find the first preferred codec in the format given */
 	for (x=0; x &lt; (sizeof(prefs) / sizeof(prefs[0]) ); x++)
 		if (fmts &amp; prefs[x])
@@ -2614,6 +2616,7 @@
 	int fmt;
 	int res;
 	int foo;
+	int videoformat = format &amp; AST_FORMAT_VIDEO_MASK;
 
 	if (!cause)
 		cause = &foo;
@@ -2629,7 +2632,7 @@
 			continue;
 
 		capabilities = chan-&gt;tech-&gt;capabilities;
-		fmt = format;
+		fmt = format &amp; AST_FORMAT_AUDIO_MASK;
 		res = ast_translator_best_choice(&amp;fmt, &amp;capabilities);
 		if (res &lt; 0) {
 			ast_log(LOG_WARNING, &quot;No translator path exists for channel type %s (native %d) to %d\n&quot;, type, chan-&gt;tech-&gt;capabilities, format);
@@ -2640,7 +2643,7 @@
 		if (!chan-&gt;tech-&gt;requester)
 			return NULL;
 		
-		if (!(c = chan-&gt;tech-&gt;requester(type, capabilities, data, cause)))
+		if (!(c = chan-&gt;tech-&gt;requester(type, capabilities | videoformat, data, cause)))
 			return NULL;
 
 		if (c-&gt;_state == AST_STATE_DOWN) {

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/channels/chan_sip.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -1260,6 +1260,7 @@
 static int sip_get_codec(struct ast_channel *chan);
 static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p);
 
+
 /*! \brief Definition of this channel for PBX channel registration */
 static const struct ast_channel_tech sip_tech = {
 	.type = &quot;SIP&quot;,
@@ -3252,13 +3253,17 @@
 
 
 /*! \brief Initiate a call in the SIP channel
-	called from sip_request_call (calls from the pbx ) */
+	called from sip_request_call (calls from the pbx ) for outbound channels
+	and from handle_request_invite for inbound channels
+	
+*/
 static struct ast_channel *sip_new(struct sip_pvt *i, int state, const char *title)
 {
 	struct ast_channel *tmp;
 	struct ast_variable *v = NULL;
 	int fmt;
 	int what;
+	int needvideo = 0;
 	
 	ast_mutex_unlock(&amp;i-&gt;lock);
 	/* Don't hold a sip pvt lock while we allocate a channel */
@@ -3269,17 +3274,50 @@
 		return NULL;
 	}
 	tmp-&gt;tech = &amp;sip_tech;
+
 	/* Select our native format based on codec preference until we receive
 	   something from another device to the contrary. */
-	if (i-&gt;jointcapability)
+	if (i-&gt;jointcapability)	 	/* The joint capabilities of us and peer */
 		what = i-&gt;jointcapability;
-	else if (i-&gt;capability)
+	else if (i-&gt;capability)		/* Our configured capability for this peer */
 		what = i-&gt;capability;
 	else
-		what = global_capability;
+		what = global_capability;	/* Global codec support */
+
+	/* Set the native formats for audio  and merge in video */
 	tmp-&gt;nativeformats = ast_codec_choose(&amp;i-&gt;prefs, what, 1) | (i-&gt;jointcapability &amp; AST_FORMAT_VIDEO_MASK);
+	if (option_debug &gt; 2) {
+		char buf[BUFSIZ];
+		ast_log(LOG_DEBUG, &quot;*** Our native formats are %s \n&quot;, ast_getformatname_multiple(buf, BUFSIZ, tmp-&gt;nativeformats));
+		ast_log(LOG_DEBUG, &quot;*** Joint capabilities are %s \n&quot;, ast_getformatname_multiple(buf, BUFSIZ, i-&gt;jointcapability));
+		ast_log(LOG_DEBUG, &quot;*** Our capabilities are %s \n&quot;, ast_getformatname_multiple(buf, BUFSIZ, i-&gt;capability));
+		ast_log(LOG_DEBUG, &quot;*** AST_CODEC_CHOOSE formats are %s \n&quot;, ast_getformatname_multiple(buf, BUFSIZ, ast_codec_choose(&amp;i-&gt;prefs, what, 1)));
+		if (i-&gt;prefcodec)
+			ast_log(LOG_DEBUG, &quot;*** Our preferred formats from the incoming channel are %s \n&quot;, ast_getformatname_multiple(buf, BUFSIZ, i-&gt;prefcodec));
+	}
+
+	/* XXX Why are we choosing a codec from the native formats?? */
 	fmt = ast_best_codec(tmp-&gt;nativeformats);
 
+	/* If we have a prefcodec setting, we have an inbound channel that set a 
+	   preferred format for this call. Otherwise, we check the jointcapability
+	   We also check for vrtp. If it's not there, we are not allowed do any video anyway.
+	 */
+	if (i-&gt;vrtp) {
+		if (i-&gt;prefcodec)
+			needvideo = i-&gt;prefcodec &amp; AST_FORMAT_VIDEO_MASK;	/* Outbound call */
+ 		else
+			needvideo = i-&gt;jointcapability &amp; AST_FORMAT_VIDEO_MASK;	/* Inbound call */
+	}
+
+	if (option_debug &gt; 2) {
+		if (needvideo) 
+			ast_log(LOG_DEBUG, &quot;This channel can handle video! HOLLYWOOD next!\n&quot;);
+		else
+			ast_log(LOG_DEBUG, &quot;This channel will not be able to handle video.\n&quot;);
+	}
+
+
 	if (title)
 		ast_string_field_build(tmp, name, &quot;SIP/%s-%04lx&quot;, title, ast_random() &amp; 0xffff);
 	else if (strchr(i-&gt;fromdomain,':'))
@@ -3297,7 +3335,7 @@
 		tmp-&gt;fds[0] = ast_rtp_fd(i-&gt;rtp);
 		tmp-&gt;fds[1] = ast_rtcp_fd(i-&gt;rtp);
 	}
-	if (i-&gt;vrtp) {
+	if (needvideo &amp;&amp; i-&gt;vrtp) {
 		tmp-&gt;fds[2] = ast_rtp_fd(i-&gt;vrtp);
 		tmp-&gt;fds[3] = ast_rtcp_fd(i-&gt;vrtp);
 	}
@@ -4038,7 +4076,9 @@
 	return 0;
 }
 
-/*! \brief Process SIP SDP, select formats and activate RTP channels */
+/*! \brief Process SIP SDP offer, select formats and activate RTP channels
+	If offer is rejected, we will not change any properties of the call
+*/
 static int process_sdp(struct sip_pvt *p, struct sip_request *req)
 {
 	const char *m;		/* SDP media offer */
@@ -4047,33 +4087,49 @@
 	char host[258];
 	char iabuf[INET_ADDRSTRLEN];
 	int len = -1;
-	int portno = -1;	/* Audio port */
-	int vportno = -1;	/* Video port */
+	int portno = -1;		/*!&lt; RTP Audio port number */
+	int vportno = -1;		/*!&lt; RTP Video port number */
 
 	/* Peer capability is the capability in the SDP, non codec is RFC2833 DTMF (101) */	
 	int peercapability, peernoncodeccapability;
+	int vpeercapability = 0, vpeernoncodeccapability = 0;
+	struct sockaddr_in sin;		/*!&lt; media socket address */
+	struct sockaddr_in vsin;	/*!&lt; Video socket address */
 
-	int vpeercapability=0, vpeernoncodeccapability=0;	/* Peer's video capabilities */
-	struct sockaddr_in sin;
 	const char *codecs;
-	struct hostent *hp;
-	struct ast_hostent ahp;
+	struct hostent *hp;		/*!&lt; RTP Audio host IP */
+	struct hostent *vhp = NULL;	/*!&lt; RTP video host IP */
+	struct ast_hostent audiohp;
+	struct ast_hostent videohp;
 	int codec;
 	int destiterator = 0;
 	int iterator;
 	int sendonly = 0;
-	int x, y;
+	int numberofports;
+	struct ast_channel *bridgepeer = NULL;
+	struct ast_rtp newaudiortp, newvideortp;	/* Buffers for codec handling */
+	int newjointcapability;				/* Negotiated capability */
+	int newpeercapability;
+	int newnoncodeccapability;
+	int numberofmediastreams = 0;
 	int debug = sip_debug_test_pvt(p);
-	struct ast_channel *bridgepeer = NULL;
-
+		
 	if (!p-&gt;rtp) {
 		ast_log(LOG_ERROR, &quot;Got SDP but have no RTP session allocated.\n&quot;);
 		return -1;
 	}
 
+	/* Initialize the temporary RTP structures we use to evaluate the offer from the peer */
+	memset(&amp;newaudiortp, 0, sizeof(newaudiortp));
+	memset(&amp;newvideortp, 0, sizeof(newvideortp));
+	ast_rtp_pt_default(&amp;newaudiortp);
+	ast_rtp_pt_default(&amp;newvideortp);
+
 	/* Update our last rtprx when we receive an SDP, too */
 	p-&gt;lastrtprx = p-&gt;lastrtptx = time(NULL); /* XXX why both ? */
 
+
+	/* Try to find first media stream */
 	m = get_sdp(req, &quot;m&quot;);
 	destiterator = req-&gt;sdp_start;
 	c = get_sdp_iterate(&amp;destiterator, req, &quot;c&quot;);
@@ -4081,26 +4137,41 @@
 		ast_log(LOG_WARNING, &quot;Insufficient information for SDP (m = '%s', c = '%s')\n&quot;, m, c);
 		return -1;
 	}
+
+	/* Check for IPv4 address (not IPv6 yet) */
 	if (sscanf(c, &quot;IN IP4 %256s&quot;, host) != 1) {
 		ast_log(LOG_WARNING, &quot;Invalid host in c= line, '%s'\n&quot;, c);
 		return -1;
 	}
+
 	/* XXX This could block for a long time, and block the main thread! XXX */
-	hp = ast_gethostbyname(host, &amp;ahp);
+	hp = ast_gethostbyname(host, &amp;audiohp);
 	if (!hp) {
 		ast_log(LOG_WARNING, &quot;Unable to lookup host in c= line, '%s'\n&quot;, c);
 		return -1;
 	}
+	vhp = hp;	/* Copy to video address as default too */
+	
 	iterator = req-&gt;sdp_start;
 	ast_set_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO);	
+
+
+	/* Find media streams in this SDP offer */
 	while ((m = get_sdp_iterate(&amp;iterator, req, &quot;m&quot;))[0] != '\0') {
-		int found = 0;
-		if ((sscanf(m, &quot;audio %d/%d RTP/AVP %n&quot;, &amp;x, &amp;y, &amp;len) == 2) ||
+		int x;
+		int audio = FALSE;
+		numberofmediastreams++;
+
+		if (p-&gt;vrtp)
+			ast_rtp_pt_clear(&amp;newvideortp);  /* Must be cleared in case no m=video line exists */
+		numberofports = 1;
+		if ((sscanf(m, &quot;audio %d/%d RTP/AVP %n&quot;, &amp;x, &amp;numberofports, &amp;len) == 2) ||
 		    (sscanf(m, &quot;audio %d RTP/AVP %n&quot;, &amp;x, &amp;len) == 1)) {
-			found = 1;
+			audio = TRUE;
+			/* Found audio stream in this media definition */
 			portno = x;
 			/* Scan through the RTP payload types specified in a &quot;m=&quot; line: */
-			ast_rtp_pt_clear(p-&gt;rtp);
+			ast_rtp_pt_clear(&amp;newaudiortp);
 			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
 				if (sscanf(codecs, &quot;%d%n&quot;, &amp;codec, &amp;len) != 1) {
 					ast_log(LOG_WARNING, &quot;Error in codec string '%s'\n&quot;, codecs);
@@ -4108,14 +4179,11 @@
 				}
 				if (debug)
 					ast_verbose(&quot;Found RTP audio format %d\n&quot;, codec);
-				ast_rtp_set_m_type(p-&gt;rtp, codec);
+				ast_rtp_set_m_type(&amp;newaudiortp, codec);
 			}
-		}
-		if (p-&gt;vrtp)
-			ast_rtp_pt_clear(p-&gt;vrtp);  /* Must be cleared in case no m=video line exists */
-
-		if (p-&gt;vrtp &amp;&amp; (sscanf(m, &quot;video %d RTP/AVP %n&quot;, &amp;x, &amp;len) == 1)) {
-			found = 1;
+		} else if ((sscanf(m, &quot;video %d/%d RTP/AVP %n&quot;, &amp;x, &amp;numberofports, &amp;len) == 2) ||
+		    (sscanf(m, &quot;video %d RTP/AVP %n&quot;, &amp;x, &amp;len) == 1)) {
+			/* If it is not audio - is it video ? */
 			ast_clear_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO);	
 			vportno = x;
 			/* Scan through the RTP payload types specified in a &quot;m=&quot; line: */
@@ -4126,144 +4194,210 @@
 				}
 				if (debug)
 					ast_verbose(&quot;Found RTP video format %d\n&quot;, codec);
-				ast_rtp_set_m_type(p-&gt;vrtp, codec);
+				ast_rtp_set_m_type(&amp;newvideortp, codec);
 			}
-		}
-		if (!found )
-			ast_log(LOG_WARNING, &quot;Unknown SDP media type in offer: %s\n&quot;, m);
-	}
-	if (portno == -1 &amp;&amp; vportno == -1) {
-		/* No acceptable offer found in SDP */
-		return -2;
-	}
-	/* Check for Media-description-level-address for audio */
-	if (pedanticsipchecking) {
+		} else 
+			ast_log(LOG_WARNING, &quot;Unsupported SDP media type in offer: %s\n&quot;, m);
+		if (numberofports &gt; 1)
+			ast_log(LOG_WARNING, &quot;SDP offered %d ports for media, not supported by Asterisk. Will try anyway...\n&quot;, numberofports);
+		
+
+		/* Check for Media-description-level-address for audio */
 		c = get_sdp_iterate(&amp;destiterator, req, &quot;c&quot;);
 		if (!ast_strlen_zero(c)) {
 			if (sscanf(c, &quot;IN IP4 %256s&quot;, host) != 1) {
 				ast_log(LOG_WARNING, &quot;Invalid secondary host in c= line, '%s'\n&quot;, c);
 			} else {
 				/* XXX This could block for a long time, and block the main thread! XXX */
-				hp = ast_gethostbyname(host, &amp;ahp);
-				if (!hp) {
-					ast_log(LOG_WARNING, &quot;Unable to lookup host in secondary c= line, '%s'\n&quot;, c);
-				}
+				if (audio) {
+					if ( !(hp = ast_gethostbyname(host, &amp;audiohp)))
+						ast_log(LOG_WARNING, &quot;Unable to lookup RTP Audio host in secondary c= line, '%s'\n&quot;, c);
+				} else if (!(vhp = ast_gethostbyname(host, &amp;videohp)))
+					ast_log(LOG_WARNING, &quot;Unable to lookup RTP video host in secondary c= line, '%s'\n&quot;, c);
 			}
+
 		}
 	}
+	if (portno == -1 &amp;&amp; vportno == -1)
+		/* No acceptable offer found in SDP  - we have no ports */
+		/* Do not change RTP or VRTP if this is a re-invite */
+		return -2;
+
+	if (numberofmediastreams &gt; 2)
+		/* We have too many media streams, fail this offer */
+		return -3;
+
 	/* RTP addresses and ports for audio and video */
 	sin.sin_family = AF_INET;
+	vsin.sin_family = AF_INET;
 	memcpy(&amp;sin.sin_addr, hp-&gt;h_addr, sizeof(sin.sin_addr));
+	if (vhp)
+		memcpy(&amp;vsin.sin_addr, vhp-&gt;h_addr, sizeof(vsin.sin_addr));
+		
 
 	/* Setup audio port number */
 	sin.sin_port = htons(portno);
-	if (p-&gt;rtp &amp;&amp; sin.sin_port) {
-		ast_rtp_set_peer(p-&gt;rtp, &amp;sin);
-		if (debug) {
-			ast_verbose(&quot;Peer audio RTP is at port %s:%d\n&quot;, ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
-		}
-	}
-	/* Check for Media-description-level-address for video */
-	if (pedanticsipchecking) {
-		c = get_sdp_iterate(&amp;destiterator, req, &quot;c&quot;);
-		if (!ast_strlen_zero(c)) {
-			if (sscanf(c, &quot;IN IP4 %256s&quot;, host) != 1) {
-				ast_log(LOG_WARNING, &quot;Invalid secondary host in c= line, '%s'\n&quot;, c);
-			} else {
-				/* XXX This could block for a long time, and block the main thread! XXX */
-				hp = ast_gethostbyname(host, &amp;ahp);
-				if (!hp) {
-					ast_log(LOG_WARNING, &quot;Unable to lookup host in secondary c= line, '%s'\n&quot;, c);
-				}
-			}
-		}
-	}
 	/* Setup video port number */
-	sin.sin_port = htons(vportno);
-	if (p-&gt;vrtp &amp;&amp; sin.sin_port) {
-		ast_rtp_set_peer(p-&gt;vrtp, &amp;sin);
-		if (debug) {
-			ast_verbose(&quot;Peer video RTP is at port %s:%d\n&quot;, ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
-		}
-	}
+	if (vportno != -1)
+		vsin.sin_port = htons(vportno);
 
 	/* Next, scan through each &quot;a=rtpmap:&quot; line, noting each
 	 * specified RTP payload type (with corresponding MIME subtype):
 	 */
+	/* XXX This needs to be done per media stream, since it's media stream specific */
 	iterator = req-&gt;sdp_start;
 	while ((a = get_sdp_iterate(&amp;iterator, req, &quot;a&quot;))[0] != '\0') {
 		char* mimeSubtype = ast_strdupa(a); /* ensures we have enough space */
 		if (!strcasecmp(a, &quot;sendonly&quot;)) {
-			sendonly=1;
+			sendonly = 1;
 			continue;
-		}
-		if (!strcasecmp(a, &quot;sendrecv&quot;)) {
-		  	sendonly=0;
-		}
-		if (sscanf(a, &quot;rtpmap: %u %[^/]/&quot;, &amp;codec, mimeSubtype) != 2) continue;
+		}  else if (!strcasecmp(a, &quot;sendrecv&quot;)) {
+			sendonly = 0;
+			continue;
+		} else if (option_debug) {
+			/* If we're debugging, check for unsupported sdp options */
+			if (!strcasecmp(a, &quot;inactive&quot;)) {
+				/* Inactive media streams: Not supported */
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:inactive in SDP offer \n&quot;);
+				continue;
+			} else if (!strncasecmp(a, &quot;rtcp:&quot;, (size_t) 5)) {
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:rtcp in SDP offer \n&quot;);
+				continue;
+			} else if (!strncasecmp(a, &quot;fmtp:&quot;, (size_t) 5)) {
+				/* Format parameters:  Not supported */
+				/* Note: This is used for codec parameters, like bitrate for
+					G722 and video formats for H263 and H264 
+					See RFC2327 for an example */
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:fmtp in SDP offer \n&quot;);
+				continue;
+			} else if (!strncasecmp(a, &quot;framerate:&quot;, (size_t) 10)) {
+				/* Video stuff:  Not supported */
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:framerate in SDP offer \n&quot;);
+				continue;
+			} else if (!strncasecmp(a, &quot;maxprate:&quot;, (size_t) 9)) {
+				/* Video stuff:  Not supported */
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:maxprate in SDP offer \n&quot;);
+				continue;
+			} else if (!strncasecmp(a, &quot;crypto:&quot;, (size_t) 7)) {
+				/* SRTP stuff, not yet supported */
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:crypto in SDP offer \n&quot;);
+				continue;
+			} else if (!strncasecmp(a, &quot;ptime:&quot;, (size_t) 6)) {
+				if (debug)
+					ast_verbose(&quot;Got unsupported a:ptime in SDP offer \n&quot;);
+				continue;
+			}
+		} else if (sscanf(a, &quot;rtpmap: %u %[^/]/&quot;, &amp;codec, mimeSubtype) != 2) 
+			continue;
+		/* We have a rtpmap to handle */
 		if (debug)
-			ast_verbose(&quot;Found description format %s\n&quot;, mimeSubtype);
+			ast_verbose(&quot;Found description format %s for ID %d\n&quot;, mimeSubtype, codec);
+
 		/* Note: should really look at the 'freq' and '#chans' params too */
-		ast_rtp_set_rtpmap_type(p-&gt;rtp, codec, &quot;audio&quot;, mimeSubtype);
+		ast_rtp_set_rtpmap_type(&amp;newaudiortp, codec, &quot;audio&quot;, mimeSubtype);
 		if (p-&gt;vrtp)
-			ast_rtp_set_rtpmap_type(p-&gt;vrtp, codec, &quot;video&quot;, mimeSubtype);
+			ast_rtp_set_rtpmap_type(&amp;newvideortp, codec, &quot;video&quot;, mimeSubtype);
 	}
 
-	/* Now gather all of the codecs that were asked for: */
-	ast_rtp_get_current_formats(p-&gt;rtp,
-				&amp;peercapability, &amp;peernoncodeccapability);
-	if (p-&gt;vrtp)
-		ast_rtp_get_current_formats(p-&gt;vrtp,
-				&amp;vpeercapability, &amp;vpeernoncodeccapability);
-	p-&gt;jointcapability = p-&gt;capability &amp; (peercapability | vpeercapability);
-	p-&gt;peercapability = (peercapability | vpeercapability);
-	p-&gt;noncodeccapability = noncodeccapability &amp; peernoncodeccapability;
-	
+	/* Now gather all of the codecs that we are asked for: */
+	ast_rtp_get_current_formats(&amp;newaudiortp, &amp;peercapability, &amp;peernoncodeccapability);
+	ast_rtp_get_current_formats(&amp;newvideortp, &amp;vpeercapability, &amp;vpeernoncodeccapability);
+
+	newjointcapability = p-&gt;capability &amp; (peercapability | vpeercapability);
+	newpeercapability = (peercapability | vpeercapability);
+	newnoncodeccapability = noncodeccapability &amp; peernoncodeccapability;
+		
+		
+	if (debug) {
+		/* shame on whoever coded this.... */
+		char s1[BUFSIZ], s2[BUFSIZ], s3[BUFSIZ], s4[BUFSIZ];
+
+		ast_verbose(&quot;Capabilities: us - %s, peer - audio=%s/video=%s, combined - %s\n&quot;,
+			ast_getformatname_multiple(s1, BUFSIZ, p-&gt;capability),
+			ast_getformatname_multiple(s2, BUFSIZ, newpeercapability),
+			ast_getformatname_multiple(s3, BUFSIZ, vpeercapability),
+			ast_getformatname_multiple(s4, BUFSIZ, newjointcapability));
+
+		ast_verbose(&quot;Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n&quot;,
+			ast_rtp_lookup_mime_multiple(s1, BUFSIZ, noncodeccapability, 0),
+			ast_rtp_lookup_mime_multiple(s2, BUFSIZ, peernoncodeccapability, 0),
+			ast_rtp_lookup_mime_multiple(s3, BUFSIZ, newnoncodeccapability, 0));
+	}
+	if (!newjointcapability) {
+		ast_log(LOG_NOTICE, &quot;No compatible codecs, not accepting this offer!\n&quot;);
+		/* Do NOT Change current setting */
+		return -1;
+	}
+
+	/* We are now ready to change the sip session and p-&gt;rtp and p-&gt;vrtp with the offered codecs, since
+		they are acceptable */
+	p-&gt;jointcapability = newjointcapability;	/* Our joint codec profile for this call */
+	p-&gt;peercapability = newpeercapability;		/* The other sides capability in latest offer */
+	p-&gt;noncodeccapability = newnoncodeccapability;	/* DTMF capabilities */
+
+	{
+		int i;
+		/* Copy payload types from source to destination */
+		for (i=0; i &lt; MAX_RTP_PT; ++i) {
+			p-&gt;rtp-&gt;current_RTP_PT[i]= newaudiortp.current_RTP_PT[i];
+			if (p-&gt;vrtp) 
+				p-&gt;vrtp-&gt;current_RTP_PT[i]= newvideortp.current_RTP_PT[i];
+		}
+	}
+
 	if (ast_test_flag(&amp;p-&gt;flags[0], SIP_DTMF) == SIP_DTMF_AUTO) {
 		ast_clear_flag(&amp;p-&gt;flags[0], SIP_DTMF);
-		if (p-&gt;noncodeccapability &amp; AST_RTP_DTMF) {
+		if (newnoncodeccapability &amp; AST_RTP_DTMF) {
 			/* XXX Would it be reasonable to drop the DSP at this point? XXX */
 			ast_set_flag(&amp;p-&gt;flags[0], SIP_DTMF_RFC2833);
 		} else {
 			ast_set_flag(&amp;p-&gt;flags[0], SIP_DTMF_INBAND);
 		}
 	}
-	
-	if (debug) {
-		/* shame on whoever coded this.... */
-		const unsigned slen=512;
-		char s1[slen], s2[slen], s3[slen], s4[slen];
 
-		ast_verbose(&quot;Capabilities: us - %s, peer - audio=%s/video=%s, combined - %s\n&quot;,
-			ast_getformatname_multiple(s1, slen, p-&gt;capability),
-			ast_getformatname_multiple(s2, slen, peercapability),
-			ast_getformatname_multiple(s3, slen, vpeercapability),
-			ast_getformatname_multiple(s4, slen, p-&gt;jointcapability));
+	/* Setup audio port number */
+	if (p-&gt;rtp &amp;&amp; sin.sin_port) {
+		ast_rtp_set_peer(p-&gt;rtp, &amp;sin);
+		if (debug)
+			ast_verbose(&quot;Peer audio RTP is at port %s:%d\n&quot;, ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+	}
 
-		ast_verbose(&quot;Non-codec capabilities: us - %s, peer - %s, combined - %s\n&quot;,
-			ast_rtp_lookup_mime_multiple(s1, slen, noncodeccapability, 0),
-			ast_rtp_lookup_mime_multiple(s2, slen, peernoncodeccapability, 0),
-			ast_rtp_lookup_mime_multiple(s3, slen, p-&gt;noncodeccapability, 0));
+	/* Setup video port number */
+	if (p-&gt;vrtp &amp;&amp; vsin.sin_port) {
+		ast_rtp_set_peer(p-&gt;vrtp, &amp;vsin);
+		if (debug) 
+			ast_verbose(&quot;Peer video RTP is at port %s:%d\n&quot;, ast_inet_ntoa(iabuf,sizeof(iabuf), vsin.sin_addr), ntohs(vsin.sin_port));
 	}
-	if (!p-&gt;jointcapability) {
-		ast_log(LOG_NOTICE, &quot;No compatible codecs!\n&quot;);
-		return -1;
+
+	/* Ok, we're going with this offer */
+	if (option_debug &gt; 1) {
+		char buf[BUFSIZ];
+		ast_log(LOG_DEBUG, &quot;We're settling with these formats: %s\n&quot;, ast_getformatname_multiple(buf, BUFSIZ, p-&gt;jointcapability));
 	}
 
-	if (!p-&gt;owner) 	/* There's no open channel owning us */
+	if (!p-&gt;owner) 	/* There's no open channel owning us so we can return here. For a re-invite or so, we proceed */
 		return 0;
 
+
 	if (!(p-&gt;owner-&gt;nativeformats &amp; p-&gt;jointcapability &amp; AST_FORMAT_AUDIO_MASK)) {
-		const unsigned slen=512;
-		char s1[slen], s2[slen];
-		ast_log(LOG_DEBUG, &quot;Oooh, we need to change our formats since our peer supports only %s and not %s\n&quot;, 
-				ast_getformatname_multiple(s1, slen, p-&gt;jointcapability),
-				ast_getformatname_multiple(s2, slen, p-&gt;owner-&gt;nativeformats));
+		if (debug) {
+			char s1[BUFSIZ], s2[BUFSIZ];
+			ast_log(LOG_DEBUG, &quot;Oooh, we need to change our audio formats since our peer supports only %s and not %s\n&quot;, 
+				ast_getformatname_multiple(s1, BUFSIZ, p-&gt;jointcapability),
+				ast_getformatname_multiple(s2, BUFSIZ, p-&gt;owner-&gt;nativeformats));
+		}
 		p-&gt;owner-&gt;nativeformats = ast_codec_choose(&amp;p-&gt;prefs, p-&gt;jointcapability, 1) | (p-&gt;capability &amp; vpeercapability);
 		ast_set_read_format(p-&gt;owner, p-&gt;owner-&gt;readformat);
 		ast_set_write_format(p-&gt;owner, p-&gt;owner-&gt;writeformat);
 	}
-	if ((bridgepeer=ast_bridged_channel(p-&gt;owner))) {
+
+	if ((bridgepeer = ast_bridged_channel(p-&gt;owner))) {
 		/* We have a bridge */
 		/* Turn on/off music on hold if we are holding/unholding */
 		if (sin.sin_addr.s_addr &amp;&amp; !sendonly) {
@@ -4277,12 +4411,15 @@
 			ast_moh_start(bridgepeer, NULL);
 			if (sendonly)
 				ast_rtp_stop(p-&gt;rtp);
+			/* RTCP needs to go ahead, even if we're on hold!!! */
+
 			/* Activate a re-invite */
 			ast_queue_frame(p-&gt;owner, &amp;ast_null_frame);
 		}
 	}
 
 	/* Manager Hold and Unhold events must be generated, if necessary */
+	/* XXX Support for sendonly/recvonly needs to be fixed !!! */
 	if (sin.sin_addr.s_addr &amp;&amp; !sendonly) {
 		append_history(p, &quot;Unhold&quot;, &quot;%s&quot;, req-&gt;data);
 
@@ -4308,10 +4445,12 @@
 		}
 		ast_set_flag(&amp;p-&gt;flags[0], SIP_CALL_ONHOLD);
 	}
+	
 
 	return 0;
 }
 
+
 /*! \brief Add header to SIP message */
 static int add_header(struct sip_request *req, const char *var, const char *value)
 {
@@ -4885,6 +5024,7 @@
 	return 0;
 }
 
+/*! \brief Add codec offer to SDP offer/answer body in INVITE or 200 OK */
 static void add_codec_to_sdp(const struct sip_pvt *p, int codec, int sample_rate,
 			     char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
 			     int debug)
@@ -4905,6 +5045,7 @@
 		ast_build_string(a_buf, a_size, &quot;a=fmtp:%d annexb=no\r\n&quot;, rtp_code);
 }
 
+/*! \brief Add RFC 2833 DTMF offer to SDP */
 static void add_noncodec_to_sdp(const struct sip_pvt *p, int format, int sample_rate,
 				char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
 				int debug)
@@ -4929,21 +5070,25 @@
 static int add_sdp(struct sip_request *resp, struct sip_pvt *p)
 {
 	int len = 0;
-	int pref_codec;
 	int alreadysent = 0;
+
 	struct sockaddr_in sin;
 	struct sockaddr_in vsin;
-	char v[256];
-	char s[256];
-	char o[256];
-	char c[256];
-	char t[256];
-	char b[256];
+	struct sockaddr_in dest;
+	struct sockaddr_in vdest = { 0, };
+
+	/* SDP fields */
+	char *version = 	&quot;v=0\r\n&quot;;		/* Protocol version */
+	char *subject = 	&quot;s=session\r\n&quot;;	/* Subject of the session */
+	char owner[256];				/* Session owner/creator */
+	char connection[256];				/* Connection data */
+	char *stime = &quot;t=0 0\r\n&quot;; 			/* Time the session is active */
+	char bandwidth[256] = &quot;&quot;;			/* Max bitrate */
 	char *hold;
-	char m_audio[256];
-	char m_video[256];
-	char a_audio[1024];
-	char a_video[1024];
+	char m_audio[256];				/* Media declaration line for audio */
+	char m_video[256];				/* Media declaration line for video */
+	char a_audio[1024];				/* Attributes for audio */
+	char a_video[1024];				/* Attributes for video */
 	char *m_audio_next = m_audio;
 	char *m_video_next = m_video;
 	size_t m_audio_left = sizeof(m_audio);
@@ -4952,31 +5097,33 @@
 	char *a_video_next = a_video;
 	size_t a_audio_left = sizeof(a_audio);
 	size_t a_video_left = sizeof(a_video);
+
 	char iabuf[INET_ADDRSTRLEN];
 	int x;
 	int capability;
-	struct sockaddr_in dest;
-	struct sockaddr_in vdest = { 0, };
-	int debug;
-	
-	debug = sip_debug_test_pvt(p);
+	int needvideo = FALSE;
+	int debug = sip_debug_test_pvt(p);
 
-	len = 0;
+	m_video[0] = '\0';	/* Reset the video media string if it's not needed */
+
 	if (!p-&gt;rtp) {
 		ast_log(LOG_WARNING, &quot;No way to add SDP without an RTP structure\n&quot;);
 		return -1;
 	}
-	capability = p-&gt;jointcapability;
-		
+
+	/* Set RTP Session ID and version */
 	if (!p-&gt;sessionid) {
 		p-&gt;sessionid = getpid();
 		p-&gt;sessionversion = p-&gt;sessionid;
 	} else
 		p-&gt;sessionversion++;
+
+	/* Get our addresses */
 	ast_rtp_get_us(p-&gt;rtp, &amp;sin);
 	if (p-&gt;vrtp)
 		ast_rtp_get_us(p-&gt;vrtp, &amp;vsin);
 
+	/* Is this a re-invite to move the media out, then use the original offer from caller  */
 	if (p-&gt;redirip.sin_addr.s_addr) {
 		dest.sin_port = p-&gt;redirip.sin_port;
 		dest.sin_addr = p-&gt;redirip.sin_addr;
@@ -4987,60 +5134,109 @@
 		dest.sin_port = sin.sin_port;
 	}
 
-	/* Determine video destination */
-	if (p-&gt;vrtp) {
+	/* Ok, let's start working with codec selection here */
+	capability = p-&gt;jointcapability;
+
+	if (option_debug &gt; 1) {
+		char codecbuf[BUFSIZ];
+		ast_log(LOG_DEBUG, &quot;** Our capability: %s Video flag: %s\n&quot;, ast_getformatname_multiple(codecbuf, sizeof(codecbuf), capability), ast_test_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO) ? &quot;True&quot; : &quot;False&quot;);
+		ast_log(LOG_DEBUG, &quot;** Our prefcodec: %s \n&quot;, ast_getformatname_multiple(codecbuf, sizeof(codecbuf), p-&gt;prefcodec));
+	}
+
+	/* Check if we need video in this call */
+	if((capability &amp; AST_FORMAT_VIDEO_MASK) &amp;&amp; !ast_test_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO)) {
+		if (p-&gt;vrtp) {
+			needvideo = TRUE;
+			if (option_debug &gt; 1)
+				ast_log(LOG_DEBUG, &quot;This call needs video offers! \n&quot;);
+		} else if (option_debug &gt; 1)
+			ast_log(LOG_DEBUG, &quot;This call needs video offers, but there's no video support enabled ! \n&quot;);
+	}
+		
+
+	/* Ok, we need video. Let's add what we need for video and set codecs.
+	   Video is handled differently than audio since we can not transcode. */
+	if (needvideo) {
+
+		/* Determine video destination */
 		if (p-&gt;vredirip.sin_addr.s_addr) {
+			vdest.sin_addr = p-&gt;vredirip.sin_addr;
 			vdest.sin_port = p-&gt;vredirip.sin_port;
-			vdest.sin_addr = p-&gt;vredirip.sin_addr;
 		} else {
 			vdest.sin_addr = p-&gt;ourip;
 			vdest.sin_port = vsin.sin_port;
 		}
-	}
-	if (debug) {
-		ast_verbose(&quot;We're at %s port %d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), p-&gt;ourip), ntohs(sin.sin_port));	
-		if (p-&gt;vrtp)
+		ast_build_string(&amp;m_video_next, &amp;m_video_left, &quot;m=video %d RTP/AVP&quot;, ntohs(vdest.sin_port));
+
+		/* Build max bitrate string */
+		if (p-&gt;maxcallbitrate)
+			snprintf(bandwidth, sizeof(bandwidth), &quot;b=CT:%d\r\n&quot;, p-&gt;maxcallbitrate);
+		if (debug) 
 			ast_verbose(&quot;Video is at %s port %d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), p-&gt;ourip), ntohs(vsin.sin_port));	
+
+		/* For video, we can't negotiate video offers. Let's compare the incoming call with what we got. */
+		if (p-&gt;prefcodec) {
+			int videocapability = (capability &amp; p-&gt;prefcodec) &amp; AST_FORMAT_VIDEO_MASK; /* Outbound call */
+		
+			/*! \todo XXX We need to select one codec, not many, since there's no transcoding */
+
+			/* Now, merge this video capability into capability while removing unsupported codecs */
+			if (!videocapability) {
+				needvideo = FALSE;
+				if (option_debug &gt; 2)
+					ast_log(LOG_DEBUG, &quot;** No compatible video codecs... Disabling video.\n&quot;);
+			} 
+
+			/* Replace video capabilities with the new videocapability */
+			capability = (capability &amp; AST_FORMAT_AUDIO_MASK) | videocapability;
+
+			if (option_debug &gt; 4) {
+				char codecbuf[BUFSIZ];
+				if (videocapability)
+					ast_log(LOG_DEBUG, &quot;** Our video codec selection is: %s \n&quot;, ast_getformatname_multiple(codecbuf, sizeof(codecbuf), videocapability));
+				ast_log(LOG_DEBUG, &quot;** Capability now set to : %s \n&quot;, ast_getformatname_multiple(codecbuf, sizeof(codecbuf), capability));
+			}
+		}
 	}
+	if (debug) 
+		ast_verbose(&quot;Audio is at %s port %d\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), p-&gt;ourip), ntohs(sin.sin_port));	
 
+	/* Start building generic SDP headers */
+
 	/* We break with the &quot;recommendation&quot; and send our IP, in order that our
 	   peer doesn't have to ast_gethostbyname() us */
 
-	snprintf(v, sizeof(v), &quot;v=0\r\n&quot;);
-	snprintf(o, sizeof(o), &quot;o=root %d %d IN IP4 %s\r\n&quot;, p-&gt;sessionid, p-&gt;sessionversion, ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
-	snprintf(s, sizeof(s), &quot;s=session\r\n&quot;);
-	snprintf(c, sizeof(c), &quot;c=IN IP4 %s\r\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
-	if ((p-&gt;vrtp) &amp;&amp;
-	    (!ast_test_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO)) &amp;&amp;
-	    (capability &amp; VIDEO_CODEC_MASK)) /* only if video response is appropriate */
-		snprintf(b, sizeof(b), &quot;b=CT:%d\r\n&quot;, p-&gt;maxcallbitrate);	
-	snprintf(t, sizeof(t), &quot;t=0 0\r\n&quot;);
-
+	snprintf(owner, sizeof(owner), &quot;o=root %d %d IN IP4 %s\r\n&quot;, p-&gt;sessionid, p-&gt;sessionversion, ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
+	snprintf(connection, sizeof(connection), &quot;c=IN IP4 %s\r\n&quot;, ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
 	ast_build_string(&amp;m_audio_next, &amp;m_audio_left, &quot;m=audio %d RTP/AVP&quot;, ntohs(dest.sin_port));
-	ast_build_string(&amp;m_video_next, &amp;m_video_left, &quot;m=video %d RTP/AVP&quot;, ntohs(vdest.sin_port));
 
 	if (ast_test_flag(&amp;p-&gt;flags[0], SIP_CALL_ONHOLD))
 		hold = &quot;a=recvonly\r\n&quot;;
 	else
 		hold = &quot;a=sendrecv\r\n&quot;;
 
-	/* Prefer the codec we were requested to use, first, no matter what */
+	/* Now, start adding audio codecs. These are added in this order:
+		- First what was requested by the calling channel
+		- Then preferences in order from sip.conf device config for this peer/user
+		- Then other codecs in capabilities, including video
+	*/
+
+	/* Prefer the audio codec we were requested to use, first, no matter what 
+		Note that p-&gt;prefcodec can include video codecs, so mask them out
+	 */
 	if (capability &amp; p-&gt;prefcodec) {
-		if (p-&gt;prefcodec &lt;= AST_FORMAT_MAX_AUDIO)
-			add_codec_to_sdp(p, p-&gt;prefcodec, 8000,
-					 &amp;m_audio_next, &amp;m_audio_left,
-					 &amp;a_audio_next, &amp;a_audio_left,
-					 debug);
-		else
-			add_codec_to_sdp(p, p-&gt;prefcodec, 90000,
-					 &amp;m_video_next, &amp;m_video_left,
-					 &amp;a_video_next, &amp;a_video_left,
-					 debug);
-		alreadysent |= p-&gt;prefcodec;
+		add_codec_to_sdp(p, p-&gt;prefcodec &amp; AST_FORMAT_AUDIO_MASK, 8000,
+				 &amp;m_audio_next, &amp;m_audio_left,
+				 &amp;a_audio_next, &amp;a_audio_left,
+				 debug);
+		alreadysent |= p-&gt;prefcodec &amp; AST_FORMAT_AUDIO_MASK;
 	}
 
-	/* Start by sending our preferred codecs */
+
+	/* Start by sending our preferred audio codecs */
 	for (x = 0; x &lt; 32; x++) {
+		int pref_codec;
+
 		if (!(pref_codec = ast_codec_pref_index(&amp;p-&gt;prefs, x)))
 			break; 
 
@@ -5050,27 +5246,21 @@
 		if (alreadysent &amp; pref_codec)
 			continue;
 
-		if (pref_codec &lt;= AST_FORMAT_MAX_AUDIO)
-			add_codec_to_sdp(p, pref_codec, 8000,
-					 &amp;m_audio_next, &amp;m_audio_left,
-					 &amp;a_audio_next, &amp;a_audio_left,
-					 debug);
-		else
-			add_codec_to_sdp(p, pref_codec, 90000,
-					 &amp;m_video_next, &amp;m_video_left,
-					 &amp;a_video_next, &amp;a_video_left,
-					 debug);
+		add_codec_to_sdp(p, pref_codec, 8000,
+				 &amp;m_audio_next, &amp;m_audio_left,
+				 &amp;a_audio_next, &amp;a_audio_left,
+				 debug);
 		alreadysent |= pref_codec;
 	}
 
-	/* Now send any other common codecs, and non-codec formats: */
-	for (x = 1;
-	     x &lt;= ((ast_test_flag(&amp;p-&gt;flags[1], SIP_PAGE2_VIDEOSUPPORT) &amp;&amp; p-&gt;vrtp) ? AST_FORMAT_MAX_VIDEO : AST_FORMAT_MAX_AUDIO);
-	     x &lt;&lt;= 1) {
-		if (!(capability &amp; x))
+	/* Now send any other common audio and video codecs, and non-codec formats: */
+	for (x = 1; x &lt;= (needvideo ? AST_FORMAT_MAX_VIDEO : AST_FORMAT_MAX_AUDIO); x &lt;&lt;= 1) {
+		if (!(capability &amp; x))	/* Codec not requested */
 			continue;
 
-		if (alreadysent &amp; x)
+		ast_log(LOG_DEBUG, &quot;--- Checking codec ... %d\n&quot;, x);
+
+		if (alreadysent &amp; x)	/* Already added to SDP */
 			continue;
 
 		if (x &lt;= AST_FORMAT_MAX_AUDIO)
@@ -5078,13 +5268,14 @@
 					 &amp;m_audio_next, &amp;m_audio_left,
 					 &amp;a_audio_next, &amp;a_audio_left,
 					 debug);
-		else
+		else 
 			add_codec_to_sdp(p, x, 90000,
 					 &amp;m_video_next, &amp;m_video_left,
 					 &amp;a_video_next, &amp;a_video_left,
 					 debug);
 	}
 
+	/* Now add DTMF RFC2833 telephony-event as a codec */
 	for (x = 1; x &lt;= AST_RTP_MAX; x &lt;&lt;= 1) {
 		if (!(p-&gt;noncodeccapability &amp; x))
 			continue;
@@ -5095,6 +5286,9 @@
 				    debug);
 	}
 
+	if (option_debug &gt; 2)
+		ast_log(LOG_DEBUG, &quot;-- Done with adding codecs to SDP\n&quot;);
+
 	if(!ast_internal_timing_enabled(p-&gt;owner))
 		ast_build_string(&amp;a_audio_next, &amp;a_audio_left, &quot;a=silenceSupp:off - - - -\r\n&quot;);
 
@@ -5102,39 +5296,39 @@
 		ast_log(LOG_WARNING, &quot;SIP SDP may be truncated due to undersized buffer!!\n&quot;);
 
 	ast_build_string(&amp;m_audio_next, &amp;m_audio_left, &quot;\r\n&quot;);
-	ast_build_string(&amp;m_video_next, &amp;m_video_left, &quot;\r\n&quot;);
+	if (needvideo)
+		ast_build_string(&amp;m_video_next, &amp;m_video_left, &quot;\r\n&quot;);
 
-	len = strlen(v) + strlen(s) + strlen(o) + strlen(c) + strlen(t) + strlen(m_audio) + strlen(a_audio) + strlen(hold);
-	if ((p-&gt;vrtp) &amp;&amp;
-	    (!ast_test_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO)) &amp;&amp;
-	    (capability &amp; VIDEO_CODEC_MASK)) /* only if video response is appropriate */
-		len += strlen(m_video) + strlen(a_video) + strlen(b) + strlen(hold);
+	len = strlen(version) + strlen(subject) + strlen(owner) + strlen(connection) + strlen(stime) + strlen(m_audio) + strlen(a_audio) + strlen(hold);
+	if (needvideo) /* only if video response is appropriate */
+		len += strlen(m_video) + strlen(a_video) + strlen(bandwidth) + strlen(hold);
 
 	add_header(resp, &quot;Content-Type&quot;, &quot;application/sdp&quot;);
 	add_header_contentLength(resp, len);
-	add_line(resp, v);
-	add_line(resp, o);
-	add_line(resp, s);
-	add_line(resp, c);
-	if ((p-&gt;vrtp) &amp;&amp;
-	    (!ast_test_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO)) &amp;&amp;
-	    (capability &amp; VIDEO_CODEC_MASK)) /* only if video response is appropriate */
-		add_line(resp, b);
-	add_line(resp, t);
+	add_line(resp, version);
+	add_line(resp, owner);
+	add_line(resp, subject);
+	add_line(resp, connection);
+	if (needvideo)	 	/* only if video response is appropriate */
+		add_line(resp, bandwidth);
+	add_line(resp, stime);
 	add_line(resp, m_audio);
 	add_line(resp, a_audio);
 	add_line(resp, hold);
-	if ((p-&gt;vrtp) &amp;&amp;
-	    (!ast_test_flag(&amp;p-&gt;flags[0], SIP_NOVIDEO)) &amp;&amp;
-	    (capability &amp; VIDEO_CODEC_MASK)) { /* only if video response is appropriate */
+	if (needvideo) { /* only if video response is appropriate */
 		add_line(resp, m_video);
 		add_line(resp, a_video);
-		add_line(resp, hold);
+		add_line(resp, hold);	/* Repeat hold for the video stream */
 	}
 
 	/* Update lastrtprx when we send our SDP */
 	p-&gt;lastrtprx = p-&gt;lastrtptx = time(NULL); /* XXX why both ? */
 
+	if (option_debug &gt; 2) {
+		char buf[BUFSIZ];
+		ast_log(LOG_DEBUG, &quot;Done building SDP. Settling with this capability: %s\n&quot;, ast_getformatname_multiple(buf, BUFSIZ, capability));
+	}
+
 	return 0;
 }
 
@@ -7744,20 +7938,24 @@
 			p-&gt;pickupgroup = user-&gt;pickupgroup;
 			if (user-&gt;callingpres)	/* User callingpres setting will override RPID header */
 				p-&gt;callingpres = user-&gt;callingpres;
-			p-&gt;capability = user-&gt;capability;
-			p-&gt;jointcapability = user-&gt;capability;
-			p-&gt;maxcallbitrate = user-&gt;maxcallbitrate;
-			if (!ast_test_flag(&amp;p-&gt;flags[1], SIP_PAGE2_VIDEOSUPPORT) &amp;&amp; p-&gt;vrtp) {
-				ast_rtp_destroy(p-&gt;vrtp);
-				p-&gt;vrtp = NULL;
-			}
-			if (p-&gt;peercapability)
+			
+			/* Set default codec settings for this call */
+			p-&gt;capability = user-&gt;capability;		/* User codec choice */
+			p-&gt;jointcapability = user-&gt;capability;		/* Our codecs */
+			if (p-&gt;peercapability)				/* AND with peer's codecs */
 				p-&gt;jointcapability &amp;= p-&gt;peercapability;
 			if ((ast_test_flag(&amp;p-&gt;flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) ||
 			    (ast_test_flag(&amp;p-&gt;flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
 				p-&gt;noncodeccapability |= AST_RTP_DTMF;
 			else
 				p-&gt;noncodeccapability &amp;= ~AST_RTP_DTMF;
+
+			p-&gt;maxcallbitrate = user-&gt;maxcallbitrate;
+			/* If we do not support video, remove video from call structure */
+			if (!ast_test_flag(&amp;p-&gt;flags[1], SIP_PAGE2_VIDEOSUPPORT) &amp;&amp; p-&gt;vrtp) {
+				ast_rtp_destroy(p-&gt;vrtp);
+				p-&gt;vrtp = NULL;
+			}
 		}
 		if (user &amp;&amp; debug)
 			ast_verbose(&quot;Found user '%s'\n&quot;, user-&gt;name);
@@ -10197,13 +10395,14 @@
 	}
 }
 
-/*! \brief Handle SIP response in dialogue */
+/*! \brief Handle SIP response to INVITE dialogue */
 static void handle_response_invite(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int seqno)
 {
 	int outgoing = ast_test_flag(&amp;p-&gt;flags[0], SIP_OUTGOING);
+	int res = 0;
+	int reinvite = (p-&gt;owner &amp;&amp; p-&gt;owner-&gt;_state == AST_STATE_UP);
 	
 	if (option_debug &gt; 3) {
-		int reinvite = (p-&gt;owner &amp;&amp; p-&gt;owner-&gt;_state == AST_STATE_UP);
 		if (reinvite)
 			ast_log(LOG_DEBUG, &quot;SIP response %d to RE-invite on %s call %s\n&quot;, resp, outgoing ? &quot;outgoing&quot; : &quot;incoming&quot;, p-&gt;callid);
 		else
@@ -10241,7 +10440,7 @@
 			}
 		}
 		if (find_sdp(req)) {
-			process_sdp(p, req);
+			res = process_sdp(p, req);
 			if (!ast_test_flag(req, SIP_PKT_IGNORE) &amp;&amp; p-&gt;owner) {
 				/* Queue a progress frame only if we have SDP in 180 */
 				ast_queue_control(p-&gt;owner, AST_CONTROL_PROGRESS);
@@ -10257,7 +10456,7 @@
 			sip_cancel_destroy(p);
 		/* Ignore 183 Session progress without SDP */
 		if (find_sdp(req)) {
-			process_sdp(p, req);
+			res = process_sdp(p, req);
 			if (!ast_test_flag(req, SIP_PKT_IGNORE) &amp;&amp; p-&gt;owner) {
 				/* Queue a progress frame */
 				ast_queue_control(p-&gt;owner, AST_CONTROL_PROGRESS);
@@ -10272,8 +10471,13 @@
 		if (!ast_test_flag(req, SIP_PKT_IGNORE))
 			sip_cancel_destroy(p);
 		p-&gt;authtries = 0;
-		if (find_sdp(req))
-			process_sdp(p, req);
+		if (find_sdp(req)) {
+			if ((res = process_sdp(p, req)) &amp;&amp; !ast_test_flag(req, SIP_PKT_IGNORE))
+				if (!reinvite)
+					/* This 200 OK's SDP is not acceptable, so we need to ack, then hangup */
+					/* For re-invites, we try to recover */
+					ast_set_flag(&amp;p-&gt;flags[0], SIP_PENDINGBYE);	
+		}
 
 		/* Parse contact header for continued conversation */
 		/* When we get 200 OK, we know which device (and IP) to contact for this call */
@@ -10298,7 +10502,7 @@
 		}
 		
 		if (!ast_test_flag(req, SIP_PKT_IGNORE) &amp;&amp; p-&gt;owner) {
-			if (p-&gt;owner-&gt;_state != AST_STATE_UP) {
+			if (!reinvite) {
 				ast_queue_control(p-&gt;owner, AST_CONTROL_ANSWER);
 			} else {	/* RE-invite */
 				ast_queue_frame(p-&gt;owner, &amp;ast_null_frame);
@@ -13460,6 +13664,9 @@
 		*cause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;	/* Can't find codec to connect to host */
 		return NULL;
 	}
+	if (option_debug)
+		ast_log(LOG_DEBUG, &quot;Asked to create a SIP channel with formats: %s\n&quot;, ast_getformatname_multiple(tmp, sizeof(tmp), oldformat));
+
 	if (!(p = sip_alloc(NULL, NULL, 0, SIP_INVITE))) {
 		ast_log(LOG_ERROR, &quot;Unable to build sip pvt data for '%s' (Out of memory or socket error)\n&quot;, (char *)data);
 		*cause = AST_CAUSE_SWITCH_CONGESTION;
@@ -13509,7 +13716,7 @@
 #if 0
 	printf(&quot;Setting up to call extension '%s' at '%s'\n&quot;, ext ? ext : &quot;&lt;none&gt;&quot;, host);
 #endif
-	p-&gt;prefcodec = format;
+	p-&gt;prefcodec = oldformat;				/* Format for this call */
 	ast_mutex_lock(&amp;p-&gt;lock);
 	tmpc = sip_new(p, AST_STATE_DOWN, host);	/* Place the call */
 	ast_mutex_unlock(&amp;p-&gt;lock);
@@ -14744,10 +14951,13 @@
 		changed = 1;
 	}
 	if (changed &amp;&amp; !ast_test_flag(&amp;p-&gt;flags[0], SIP_GOTREFER)) {
-		if (chan-&gt;_state != AST_STATE_UP) {
+		if (chan-&gt;_state != AST_STATE_UP) {	/* We are in early state */
 			char iabuf[INET_ADDRSTRLEN];
-			ast_log(LOG_DEBUG, &quot;Early media setting SIP '%s' - Sending early media to %s\n&quot;, p-&gt;callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p-&gt;redirip.sin_addr : p-&gt;ourip));
-		} else if (!p-&gt;pendinginvite) {
+			if (recordhistory)
+				append_history(p, &quot;ExtInv&quot;, &quot;Initial invite sent with remote bridge proposal.&quot;);
+			if (option_debug)
+				ast_log(LOG_DEBUG, &quot;Early remote bridge setting SIP '%s' - Sending media to %s\n&quot;, p-&gt;callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p-&gt;redirip.sin_addr : p-&gt;ourip));
+		} else if (!p-&gt;pendinginvite) {		/* We are up, and have no outstanding invite */
 			if (option_debug &gt; 2) {
 				char iabuf[INET_ADDRSTRLEN];
 				ast_log(LOG_DEBUG, &quot;Sending reinvite on SIP '%s' - It's audio soon redirected to IP %s\n&quot;, p-&gt;callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p-&gt;redirip.sin_addr : p-&gt;ourip));
@@ -14758,6 +14968,7 @@
 				char iabuf[INET_ADDRSTRLEN];
 				ast_log(LOG_DEBUG, &quot;Deferring reinvite on SIP '%s' - It's audio will be redirected to IP %s\n&quot;, p-&gt;callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p-&gt;redirip.sin_addr : p-&gt;ourip));
 			}
+			/* We have a pending Invite. Send re-invite when we're done with the invite */
 			ast_set_flag(&amp;p-&gt;flags[0], SIP_NEEDREINVITE);	
 		}
 	}

Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/frame.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -1008,9 +1008,12 @@
 			break;
 		}
 	}
-	if(ret)
+	if(ret &amp; AST_FORMAT_AUDIO_MASK)
 		return ret;
 
+	if (option_debug &gt; 3)
+		ast_log(LOG_DEBUG, &quot;Could not find preferred codec - %s\n&quot;, find_best ? &quot;Going for the best codec&quot; : &quot;Returning zero codec&quot;);
+
    	return find_best ? ast_best_codec(formats) : 0;
 }
 
@@ -1034,7 +1037,10 @@
 				*mask &amp;= ~format;
 		}
 
-		if (pref) {
+		/* Set up a preference list for audio. Do not include video in preferences 
+		   since we can not transcode video and have to use whatever is offered
+		 */
+		if (pref &amp;&amp; (format &amp; AST_FORMAT_AUDIO_MASK)) {
 			if (strcasecmp(this, &quot;all&quot;)) {
 				if (allowing)
 					ast_codec_pref_append(pref, format);

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/include/asterisk/rtp.h	2006-06-18 21:11:06 UTC (rev 275)
@@ -40,13 +40,13 @@
 
 /* Codes for RTP-specific data - not defined by our AST_FORMAT codes */
 /*! DTMF (RFC2833) */
-#define AST_RTP_DTMF            (1 &lt;&lt; 0)
+#define AST_RTP_DTMF            	(1 &lt;&lt; 0)
 /*! 'Comfort Noise' (RFC3389) */
-#define AST_RTP_CN              (1 &lt;&lt; 1)
+#define AST_RTP_CN              	(1 &lt;&lt; 1)
 /*! DTMF (Cisco Proprietary) */
-#define AST_RTP_CISCO_DTMF      (1 &lt;&lt; 2)
+#define AST_RTP_CISCO_DTMF      	(1 &lt;&lt; 2)
 /*! Maximum RTP-specific code */
-#define AST_RTP_MAX             AST_RTP_CISCO_DTMF
+#define AST_RTP_MAX             	AST_RTP_CISCO_DTMF
 
 #define MAX_RTP_PT			256
 
@@ -62,6 +62,9 @@
 	AST_LIST_ENTRY(ast_rtp_protocol) list;
 };
 
+
+#define FLAG_3389_WARNING		(1 &lt;&lt; 0)
+
 typedef int (*ast_rtp_callback)(struct ast_rtp *rtp, struct ast_frame *f, void *data);
 
 
@@ -71,7 +74,6 @@
  * RTP session is defined on page 9 of RFC 3550: &quot;An association among a set of participants communicating with RTP.  A participant may be involved in multiple RTP sessions at the same time [...]&quot;
  *
  */
-
 /*! \brief The value of each payload format mapping: */
 struct rtpPayloadType {
 	int isAstFormat; 	/*!&lt; whether the following code is an AST_FORMAT */

Modified: trunk/include/asterisk/translate.h
===================================================================
--- trunk/include/asterisk/translate.h	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/include/asterisk/translate.h	2006-06-18 21:11:06 UTC (rev 275)
@@ -23,7 +23,8 @@
 #ifndef _ASTERISK_TRANSLATE_H
 #define _ASTERISK_TRANSLATE_H
 
-#define MAX_FORMAT 32
+//#define MAX_FORMAT 15	/* Do not include video here */
+#define MAX_FORMAT 32	/* Do include video here */
 
 #if defined(__cplusplus) || defined(c_plusplus)
 extern &quot;C&quot; {

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/rtp.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -1350,7 +1350,7 @@
 	return 1;
 }
 
-/*! \brief  Make a note of a RTP paymoad type that was seen in a SDP &quot;m=&quot; line.
+/*! \brief  Make a note of a RTP payload type that was seen in a SDP &quot;m=&quot; line.
  * By default, use the well-known value for this type (although it may 
  * still be set to a different value by a subsequent &quot;a=rtpmap:&quot; line)
  */
@@ -1359,9 +1359,8 @@
 	if (pt &lt; 0 || pt &gt; MAX_RTP_PT) 
 		return; /* bogus payload type */
 
-	if (static_RTP_PT[pt].code != 0) {
+	if (static_RTP_PT[pt].code != 0) 
 		rtp-&gt;current_RTP_PT[pt] = static_RTP_PT[pt];
-	}
 } 
 
 /*! \brief Make a note of a RTP payload type (with MIME type) that was seen in
@@ -2245,7 +2244,7 @@
 	
 	/* Make sure we have enough space for RTP header */
 	if ((_f-&gt;frametype != AST_FRAME_VOICE) &amp;&amp; (_f-&gt;frametype != AST_FRAME_VIDEO)) {
-		ast_log(LOG_WARNING, &quot;RTP can only send voice\n&quot;);
+		ast_log(LOG_WARNING, &quot;RTP can only send voice and video\n&quot;);
 		return -1;
 	}
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000269.html">[solid-pbx-svn] r274 - trunk/channels
</A></li>
	<LI>Next message: <A HREF="000271.html">[solid-pbx-svn] r276 - trunk/apps
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#270">[ date ]</a>
              <a href="thread.html#270">[ thread ]</a>
              <a href="subject.html#270">[ subject ]</a>
              <a href="author.html#270">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
