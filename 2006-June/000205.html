<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [solid-pbx-svn] r210 - in trunk: . channels
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r210%20-%20in%20trunk%3A%20.%20channels&In-Reply-To=%3C200606011425.k51EPhU8011540%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000204.html">
   <LINK REL="Next"  HREF="000206.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[solid-pbx-svn] r210 - in trunk: . channels</H1>
    <B>solid-pbx-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r210%20-%20in%20trunk%3A%20.%20channels&In-Reply-To=%3C200606011425.k51EPhU8011540%40sheep.berlios.de%3E"
       TITLE="[solid-pbx-svn] r210 - in trunk: . channels">solid-pbx-svn-admin at lists.berlios.de
       </A><BR>
    <I>Thu Jun  1 16:25:43 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000204.html">[solid-pbx-svn] r209 - in trunk: channels channels/misdn configs
</A></li>
        <LI>Next message: <A HREF="000206.html">[solid-pbx-svn] r211 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#205">[ date ]</a>
              <a href="thread.html#205">[ thread ]</a>
              <a href="subject.html#205">[ subject ]</a>
              <a href="author.html#205">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-06-01 16:25:36 +0200 (Thu, 01 Jun 2006)
New Revision: 210

Modified:
   trunk/CREDITS
   trunk/Makefile
   trunk/abstract_jb.c
   trunk/channels/chan_sip.c
   trunk/scx_jitterbuf.c
   trunk/scx_jitterbuf.h
Log:
Update to Asterisk SVN trunk r31359

------------------------------------------------------------------------
r31356 | russell | 2006-06-01 16:07:03 +0200 (Thu, 01 Jun 2006) | 4 lines

- add slav, zoa, and royk to the CREDITS for the generic jitterbuffer
- change references to the &quot;scx&quot; jitterbuffer to be called &quot;fixed&quot; and change
  references to the &quot;stevek&quot; jitterbuffer to be called &quot;adaptive&quot;, instead

------------------------------------------------------------------------
r31359 | russell | 2006-06-01 16:15:16 +0200 (Thu, 01 Jun 2006) | 3 lines

make a global variable static and remove an unused global variable
(issue #7258, tardieu)

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/CREDITS	2006-06-01 14:25:36 UTC (rev 210)
@@ -30,58 +30,94 @@
 === MISCELLANEOUS PATCHES ===
 Jim Dixon - Zapata Telephony and app_rpt
 	<A HREF="http://www.zapatatelephony.org/app_rpt.html">http://www.zapatatelephony.org/app_rpt.html</A>
+
 Russell Bryant - Asterisk 1.0 maintainer and misc. enhancements
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russelb at clemson.edu</A>
+
 Anthony Minessale II - Countless big and small fixes, and relentless forward push
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">anthmct at yahoo.com</A>              <A HREF="http://www.asterlink.com">http://www.asterlink.com</A>
+
 James Golovich - Innumerable contributions
 	You can find him and asterisk-perl at <A HREF="http://asterisk.gnuinter.net">http://asterisk.gnuinter.net</A>
+
 Andre Bierwirth - Extension hints and status
+
 Oliver Daudey - ISDN4Linux fixes
+
 Pauline Middelink - ISDN4Linux patches and some general patches.
 	She can be found at <A HREF="http://www.polyware.nl/~middelink/En/">http://www.polyware.nl/~middelink/En/</A>
+
 Jean-Denis Girard - Various contributions from the South Pacific Islands
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">jd-girard at esoft.pf</A>             <A HREF="http://www.esoft.pf">http://www.esoft.pf</A>
+
 William Jordan / Vonage - MySQL enhancements to Voicemail
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">wjordan at vonage.com</A>
+
 Jac Kersing - Various fixes
+
 Steven Critchfield - Seek and Trunc functions for playback and recording
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">critch at basesys.com</A>
+
 Jefferson Noxon - app_lookupcidname, app_db, and various other contributions
+
 Klaus-Peter Junghanns - in-band DTMF on SIP and MGCP
+
 Ross Finlayson - Dynamic RTP payload support
+
 Mahmut Fettahlioglu - Audio recording, music-on-hold changes, alaw file
 	format, and various fixes. Can be contacted at <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">mahmut at oa.com.au</A>
+
 James Dennis - Cisco SIP compatibility patches to work with SIP service
 	providers. Can be contacted at <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">asterisk at jdennis.net</A>
+
 Tilghman Lesher - ast_localtime(); ast_say_date_with_format(); 
 	GotoIfTime, Random, SayUnixTime, HasNewVoicemail applications;
 	CUT, SORT, EVAL, CURL, FIELDQTY, STRFTIME, QUEUEAGENT* functions;
 	and other innumerable bug fixes. <A HREF="http://asterisk.drunkcoder.com/">http://asterisk.drunkcoder.com/</A>
+
 Jayson Vantuyl - Manager protocol changes, various other bugs.
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">jvantuyl at computingedge.net</A>
+
 Thorsten Lockert - OpenBSD, FreeBSD ports, making MacOS X port run on 10.3,
 	dialplan include verification, route lookup on OpenBSD, SNMP agent
 	support (res_snmp), various other bugs. <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">tholo at sigmasoft.com</A>
+
 Brian West - ODBC support and Bug Marshaling  
+
 Josh Roberson - chan_zap reload support, Advanced Voicemail Features, other misc. patches,
 	and Bug Marshalling. - <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">josh at asteriasgi.com</A>, <A HREF="http://www.asteriasgi.com">http://www.asteriasgi.com</A>
+
 William Waites - syslog support, SIP NAT traversal for SIP-UA. <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">ww at styx.org</A>
+
 Rich Murphey - Porting to FreeBSD, NetBSD, OpenBSD, and Darwin.
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">rich at whiteoaklabs.com</A>  <A HREF="http://whiteoaklabs.com">http://whiteoaklabs.com</A>
+
 Simon Lockhart - Porting to Solaris (based on work of Logan ???)	
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">simon at slimey.org</A>
+
 Olle E. Johansson - SIP RFC compliance, documentation and testing, testing, testing
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">oej at edvina.net</A>, <A HREF="http://edvina.net">http://edvina.net</A>
+
 Steve Kann - new jitter buffer for IAX2
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">stevek at stevek.com</A>
+
 Constantine Filin - major contributions to the Asterisk Realtime Architecture
+
 Steve Murphy - privacy support, $[ ] parser upgrade, AEL2 parser upgrade
+
 Claude Patry - bug fixes, feature enhancements, and bug marshalling
 	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">cpatry at gmail.com</A>
+
 Miroslav Nachev, <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">miro at space-comm.com</A> COSMOS Software Enterprises, Ltd.
 	- for Variable for No Answer Timeout for Attended Transfer
 
+Slav Klenov &amp; Vanheuverzwijn Joachim - development of the generic jitterbuffer
+	Securax Ltd. <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">info at securax.be</A>
+
+Roy Sigurd Karlsbakk - providing funding for generic jitterbuffer development
+	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">roy at karlsbakk.net</A>, Briiz Telecom AS
+
+
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt
 Michael Jerris - bug marshaling

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/Makefile	2006-06-01 14:25:36 UTC (rev 210)
@@ -282,7 +282,7 @@
 	astmm.o enum.o srv.o dns.o aescrypt.o aestab.o aeskey.o \
 	utils.o plc.o jitterbuf.o dnsmgr.o devicestate.o \
 	netsock.o slinfactory.o ast_expr2.o ast_expr2f.o \
-	cryptostub.o sha1.o http.o scx_jitterbuf.o abstract_jb.o
+	cryptostub.o sha1.o http.o fixedjitterbuf.o abstract_jb.o
 
 # we need to link in the objects statically, not as a library, because
 # otherwise modules will not have them available if none of the static

Modified: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/abstract_jb.c	2006-06-01 14:25:36 UTC (rev 210)
@@ -42,7 +42,7 @@
 #include &quot;asterisk/utils.h&quot;
 
 #include &quot;asterisk/abstract_jb.h&quot;
-#include &quot;scx_jitterbuf.h&quot;
+#include &quot;fixedjitterbuf.h&quot;
 #include &quot;jitterbuf.h&quot;
 
 /*! Internal jb flags */
@@ -89,49 +89,49 @@
 };
 
 /* Implementation functions */
-/* scx */
-static void * jb_create_scx(struct ast_jb_conf *general_config, long resynch_threshold);
-static void jb_destroy_scx(void *jb);
-static int jb_put_first_scx(void *jb, struct ast_frame *fin, long now);
-static int jb_put_scx(void *jb, struct ast_frame *fin, long now);
-static int jb_get_scx(void *jb, struct ast_frame **fout, long now, long interpl);
-static long jb_next_scx(void *jb);
-static int jb_remove_scx(void *jb, struct ast_frame **fout);
-static void jb_force_resynch_scx(void *jb);
-/* stevek */
-static void * jb_create_stevek(struct ast_jb_conf *general_config, long resynch_threshold);
-static void jb_destroy_stevek(void *jb);
-static int jb_put_first_stevek(void *jb, struct ast_frame *fin, long now);
-static int jb_put_stevek(void *jb, struct ast_frame *fin, long now);
-static int jb_get_stevek(void *jb, struct ast_frame **fout, long now, long interpl);
-static long jb_next_stevek(void *jb);
-static int jb_remove_stevek(void *jb, struct ast_frame **fout);
-static void jb_force_resynch_stevek(void *jb);
+/* fixed */
+static void * jb_create_fixed(struct ast_jb_conf *general_config, long resynch_threshold);
+static void jb_destroy_fixed(void *jb);
+static int jb_put_first_fixed(void *jb, struct ast_frame *fin, long now);
+static int jb_put_fixed(void *jb, struct ast_frame *fin, long now);
+static int jb_get_fixed(void *jb, struct ast_frame **fout, long now, long interpl);
+static long jb_next_fixed(void *jb);
+static int jb_remove_fixed(void *jb, struct ast_frame **fout);
+static void jb_force_resynch_fixed(void *jb);
+/* adaptive */
+static void * jb_create_adaptive(struct ast_jb_conf *general_config, long resynch_threshold);
+static void jb_destroy_adaptive(void *jb);
+static int jb_put_first_adaptive(void *jb, struct ast_frame *fin, long now);
+static int jb_put_adaptive(void *jb, struct ast_frame *fin, long now);
+static int jb_get_adaptive(void *jb, struct ast_frame **fout, long now, long interpl);
+static long jb_next_adaptive(void *jb);
+static int jb_remove_adaptive(void *jb, struct ast_frame **fout);
+static void jb_force_resynch_adaptive(void *jb);
 
 /* Available jb implementations */
 static struct ast_jb_impl avail_impl[] = 
 {
 	{
 		.name = &quot;fixed&quot;,
-		.create = jb_create_scx,
-		.destroy = jb_destroy_scx,
-		.put_first = jb_put_first_scx,
-		.put = jb_put_scx,
-		.get = jb_get_scx,
-		.next = jb_next_scx,
-		.remove = jb_remove_scx,
-		.force_resync = jb_force_resynch_scx
+		.create = jb_create_fixed,
+		.destroy = jb_destroy_fixed,
+		.put_first = jb_put_first_fixed,
+		.put = jb_put_fixed,
+		.get = jb_get_fixed,
+		.next = jb_next_fixed,
+		.remove = jb_remove_fixed,
+		.force_resync = jb_force_resynch_fixed
 	},
 	{
 		.name = &quot;adaptive&quot;,
-		.create = jb_create_stevek,
-		.destroy = jb_destroy_stevek,
-		.put_first = jb_put_first_stevek,
-		.put = jb_put_stevek,
-		.get = jb_get_stevek,
-		.next = jb_next_stevek,
-		.remove = jb_remove_stevek,
-		.force_resync = jb_force_resynch_stevek
+		.create = jb_create_adaptive,
+		.destroy = jb_destroy_adaptive,
+		.put_first = jb_put_first_adaptive,
+		.put = jb_put_adaptive,
+		.get = jb_get_adaptive,
+		.next = jb_next_adaptive,
+		.remove = jb_remove_adaptive,
+		.force_resync = jb_force_resynch_adaptive
 	}
 };
 
@@ -147,9 +147,9 @@
 };
 
 /* Translations between impl and abstract return codes */
-static int scx_to_abstract_code[] =
+static int fixed_to_abstract_code[] =
 	{JB_IMPL_OK, JB_IMPL_DROP, JB_IMPL_INTERP, JB_IMPL_NOFRAME};
-static int stevek_to_abstract_code[] =
+static int adaptive_to_abstract_code[] =
 	{JB_IMPL_OK, JB_IMPL_NOFRAME, JB_IMPL_NOFRAME, JB_IMPL_INTERP, JB_IMPL_DROP, JB_IMPL_OK};
 
 /* JB_GET actions (used only for the frames log) */
@@ -467,7 +467,7 @@
 	res = jbimpl-&gt;put_first(jbobj, frr, now);
 	
 	/* The result of putting the first frame should not differ from OK. However, its possible
-	   some implementations (i.e. stevek's when resynch_threshold is specified) to drop it. */
+	   some implementations (i.e. adaptive's when resynch_threshold is specified) to drop it. */
 	if (res != JB_IMPL_OK) {
 		ast_log(LOG_WARNING, &quot;Failed to put first frame in the jitterbuffer on channel '%s'\n&quot;, chan-&gt;name);
 		/*
@@ -615,170 +615,170 @@
 
 /* Implementation functions */
 
-/* scx */
+/* fixed */
 
-static void * jb_create_scx(struct ast_jb_conf *general_config, long resynch_threshold)
+static void * jb_create_fixed(struct ast_jb_conf *general_config, long resynch_threshold)
 {
-	struct scx_jb_conf conf;
+	struct fixed_jb_conf conf;
 	
 	conf.jbsize = general_config-&gt;max_size;
 	conf.resync_threshold = resynch_threshold;
 	
-	return scx_jb_new(&amp;conf);
+	return fixed_jb_new(&amp;conf);
 }
 
 
-static void jb_destroy_scx(void *jb)
+static void jb_destroy_fixed(void *jb)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	
 	/* destroy the jb */
-	scx_jb_destroy(scxjb);
+	fixed_jb_destroy(fixedjb);
 }
 
 
-static int jb_put_first_scx(void *jb, struct ast_frame *fin, long now)
+static int jb_put_first_fixed(void *jb, struct ast_frame *fin, long now)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	int res;
 	
-	res = scx_jb_put_first(scxjb, fin, fin-&gt;len, fin-&gt;ts, now);
+	res = fixed_jb_put_first(fixedjb, fin, fin-&gt;len, fin-&gt;ts, now);
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static int jb_put_scx(void *jb, struct ast_frame *fin, long now)
+static int jb_put_fixed(void *jb, struct ast_frame *fin, long now)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	int res;
 	
-	res = scx_jb_put(scxjb, fin, fin-&gt;len, fin-&gt;ts, now);
+	res = fixed_jb_put(fixedjb, fin, fin-&gt;len, fin-&gt;ts, now);
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static int jb_get_scx(void *jb, struct ast_frame **fout, long now, long interpl)
+static int jb_get_fixed(void *jb, struct ast_frame **fout, long now, long interpl)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
-	struct scx_jb_frame frame;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
+	struct fixed_jb_frame frame;
 	int res;
 	
-	res = scx_jb_get(scxjb, &amp;frame, now, interpl);
+	res = fixed_jb_get(fixedjb, &amp;frame, now, interpl);
 	*fout = frame.data;
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static long jb_next_scx(void *jb)
+static long jb_next_fixed(void *jb)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	
-	return scx_jb_next(scxjb);
+	return fixed_jb_next(fixedjb);
 }
 
 
-static int jb_remove_scx(void *jb, struct ast_frame **fout)
+static int jb_remove_fixed(void *jb, struct ast_frame **fout)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
-	struct scx_jb_frame frame;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
+	struct fixed_jb_frame frame;
 	int res;
 	
-	res = scx_jb_remove(scxjb, &amp;frame);
+	res = fixed_jb_remove(fixedjb, &amp;frame);
 	*fout = frame.data;
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static void jb_force_resynch_scx(void *jb)
+static void jb_force_resynch_fixed(void *jb)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	
-	scx_jb_set_force_resynch(scxjb);
+	fixed_jb_set_force_resynch(fixedjb);
 }
 
 
-/* stevek */
+/* adaptive */
 
-static void *jb_create_stevek(struct ast_jb_conf *general_config, long resynch_threshold)
+static void *jb_create_adaptive(struct ast_jb_conf *general_config, long resynch_threshold)
 {
 	jb_conf jbconf;
-	jitterbuf *stevekjb;
+	jitterbuf *adaptivejb;
 
-	stevekjb = jb_new();
-	if (stevekjb) {
+	adaptivejb = jb_new();
+	if (adaptivejb) {
 		jbconf.max_jitterbuf = general_config-&gt;max_size;
 		jbconf.resync_threshold = general_config-&gt;resync_threshold;
 		jbconf.max_contig_interp = 10;
-		jb_setconf(stevekjb, &amp;jbconf);
+		jb_setconf(adaptivejb, &amp;jbconf);
 	}
 	
-	return stevekjb;
+	return adaptivejb;
 }
 
 
-static void jb_destroy_stevek(void *jb)
+static void jb_destroy_adaptive(void *jb)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	
-	jb_destroy(stevekjb);
+	jb_destroy(adaptivejb);
 }
 
 
-static int jb_put_first_stevek(void *jb, struct ast_frame *fin, long now)
+static int jb_put_first_adaptive(void *jb, struct ast_frame *fin, long now)
 {
-	return jb_put_stevek(jb, fin, now);
+	return jb_put_adaptive(jb, fin, now);
 }
 
 
-static int jb_put_stevek(void *jb, struct ast_frame *fin, long now)
+static int jb_put_adaptive(void *jb, struct ast_frame *fin, long now)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	int res;
 	
-	res = jb_put(stevekjb, fin, JB_TYPE_VOICE, fin-&gt;len, fin-&gt;ts, now);
+	res = jb_put(adaptivejb, fin, JB_TYPE_VOICE, fin-&gt;len, fin-&gt;ts, now);
 	
-	return stevek_to_abstract_code[res];
+	return adaptive_to_abstract_code[res];
 }
 
 
-static int jb_get_stevek(void *jb, struct ast_frame **fout, long now, long interpl)
+static int jb_get_adaptive(void *jb, struct ast_frame **fout, long now, long interpl)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	jb_frame frame;
 	int res;
 	
-	res = jb_get(stevekjb, &amp;frame, now, interpl);
+	res = jb_get(adaptivejb, &amp;frame, now, interpl);
 	*fout = frame.data;
 	
-	return stevek_to_abstract_code[res];
+	return adaptive_to_abstract_code[res];
 }
 
 
-static long jb_next_stevek(void *jb)
+static long jb_next_adaptive(void *jb)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	
-	return jb_next(stevekjb);
+	return jb_next(adaptivejb);
 }
 
 
-static int jb_remove_stevek(void *jb, struct ast_frame **fout)
+static int jb_remove_adaptive(void *jb, struct ast_frame **fout)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	jb_frame frame;
 	int res;
 	
-	res = jb_getall(stevekjb, &amp;frame);
+	res = jb_getall(adaptivejb, &amp;frame);
 	*fout = frame.data;
 	
-	return stevek_to_abstract_code[res];
+	return adaptive_to_abstract_code[res];
 }
 
 
-static void jb_force_resynch_stevek(void *jb)
+static void jb_force_resynch_adaptive(void *jb)
 {
 }

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/channels/chan_sip.c	2006-06-01 14:25:36 UTC (rev 210)
@@ -288,7 +288,7 @@
 	SIP_INFO,
 	SIP_CANCEL,
 	SIP_PUBLISH,
-} sip_method_list;
+};
 
 enum sip_auth_type {
 	PROXY_AUTH,
@@ -481,7 +481,7 @@
 static int allow_external_domains;	/*!&lt; Accept calls to external SIP domains? */
 static int global_callevents;		/*!&lt; Whether we send manager events or not */
 static int global_t1min;		/*!&lt; T1 roundtrip time minimum */
-enum transfermodes global_allowtransfer;	/*! SIP Refer restriction scheme */
+static enum transfermodes global_allowtransfer;	/*!&lt; SIP Refer restriction scheme */
 
 /*! \brief Codecs that we support by default: */
 static int global_capability = AST_FORMAT_ULAW | AST_FORMAT_ALAW | AST_FORMAT_GSM | AST_FORMAT_H263;

Modified: trunk/scx_jitterbuf.c
===================================================================
--- trunk/scx_jitterbuf.c	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/scx_jitterbuf.c	2006-06-01 14:25:36 UTC (rev 210)
@@ -1,351 +0,0 @@
-/*
- * scx_jitterbuf: jitterbuffering algorithm
- *
- * Copyright (C) 2005, Attractel OOD
- *
- * Contributors:
- * Slav Klenov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">slav at securax.org</A>&gt;
- *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
- * See <A HREF="http://www.asterisk.org">http://www.asterisk.org</A> for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*! \file 
- * 
- * \brief Jitterbuffering algorithm.
- * 
- * \author Slav Klenov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">slav at securax.org</A>&gt;
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;assert.h&gt;
-#include &lt;string.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &quot;asterisk.h&quot;
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision $&quot;)
-
-#include &quot;asterisk/utils.h&quot;
-#include &quot;scx_jitterbuf.h&quot;
-
-#undef SCX_JB_DEBUG
-
-#ifdef SCX_JB_DEBUG
-#define ASSERT(a)
-#else
-#define ASSERT(a) assert(a)
-#endif
-
-/*! \brief private scx_jb structure */
-struct scx_jb
-{
-	struct scx_jb_frame *frames;
-	struct scx_jb_frame *tail;
-	struct scx_jb_conf conf;
-	long rxcore;
-	long delay;
-	long next_delivery;
-	int force_resynch;
-};
-
-
-static struct scx_jb_frame *alloc_jb_frame(struct scx_jb *jb);
-static void release_jb_frame(struct scx_jb *jb, struct scx_jb_frame *frame);
-static void get_jb_head(struct scx_jb *jb, struct scx_jb_frame *frame);
-static int resynch_jb(struct scx_jb *jb, void *data, long ms, long ts, long now);
-
-static inline struct scx_jb_frame *alloc_jb_frame(struct scx_jb *jb)
-{
-	return ast_calloc(1, sizeof(struct scx_jb_frame));
-}
-
-static inline void release_jb_frame(struct scx_jb *jb, struct scx_jb_frame *frame)
-{
-	free(frame);
-}
-
-static void get_jb_head(struct scx_jb *jb, struct scx_jb_frame *frame)
-{
-	struct scx_jb_frame *fr;
-	
-	/* unlink the frame */
-	fr = jb-&gt;frames;
-	jb-&gt;frames = fr-&gt;next;
-	if (jb-&gt;frames) {
-		jb-&gt;frames-&gt;prev = NULL;
-	} else {
-		/* the jb is empty - update tail */
-		jb-&gt;tail = NULL;
-	}
-	
-	/* update next */
-	jb-&gt;next_delivery = fr-&gt;delivery + fr-&gt;ms;
-	
-	/* copy the destination */
-	memcpy(frame, fr, sizeof(struct scx_jb_frame));
-	
-	/* and release the frame */
-	release_jb_frame(jb, fr);
-}
-
-
-struct scx_jb *scx_jb_new(struct scx_jb_conf *conf)
-{
-	struct scx_jb *jb;
-	
-	if (!(jb = ast_calloc(1, sizeof(*jb))))
-		return NULL;
-	
-	/* First copy our config */
-	memcpy(&amp;jb-&gt;conf, conf, sizeof(struct scx_jb_conf));
-
-	/* we dont need the passed config anymore - continue working with the saved one */
-	conf = &amp;jb-&gt;conf;
-	
-	/* validate the configuration */
-	if (conf-&gt;jbsize &lt; 1)
-		conf-&gt;jbsize = SCX_JB_SIZE_DEFAULT;
-
-	if (conf-&gt;resync_threshold &lt; 1)
-		conf-&gt;resync_threshold = SCX_JB_RESYNCH_THRESHOLD_DEFAULT;
-	
-	/* Set the constant delay to the jitterbuf */
-	jb-&gt;delay = conf-&gt;jbsize;
-	
-	return jb;
-}
-
-
-void scx_jb_destroy(struct scx_jb *jb)
-{
-	/* jitterbuf MUST be empty before it can be destroyed */
-	ASSERT(jb-&gt;frames == NULL);
-	
-	free(jb);
-}
-
-
-static int resynch_jb(struct scx_jb *jb, void *data, long ms, long ts, long now)
-{
-	long diff, offset;
-	struct scx_jb_frame *frame;
-	
-	/* If jb is empty, just reinitialize the jb */
-	if (!jb-&gt;frames) {
-		/* debug check: tail should also be NULL */
-		ASSERT(jb-&gt;tail == NULL);
-		
-		return scx_jb_put_first(jb, data, ms, ts, now);
-	}
-	
-	/* Adjust all jb state just as the new frame is with delivery = the delivery of the last
-	   frame (e.g. this one with max delivery) + the length of the last frame. */
-	
-	/* Get the diff in timestamps */
-	diff = ts - jb-&gt;tail-&gt;ts;
-	
-	/* Ideally this should be just the length of the last frame. The deviation is the desired
-	   offset */
-	offset = diff - jb-&gt;tail-&gt;ms;
-	
-	/* Do we really need to resynch, or this is just a frame for dropping? */
-	if (!jb-&gt;force_resynch &amp;&amp; (offset &lt; jb-&gt;conf.resync_threshold &amp;&amp; offset &gt; -jb-&gt;conf.resync_threshold))
-		return SCX_JB_DROP;
-	
-	/* Reset the force resynch flag */
-	jb-&gt;force_resynch = 0;
-	
-	/* apply the offset to the jb state */
-	jb-&gt;rxcore -= offset;
-	frame = jb-&gt;frames;
-	while (frame) {
-		frame-&gt;ts += offset;
-		frame = frame-&gt;next;
-	}
-	
-	/* now jb_put() should add the frame at a last position */
-	return scx_jb_put(jb, data, ms, ts, now);
-}
-
-
-void scx_jb_set_force_resynch(struct scx_jb *jb)
-{
-	jb-&gt;force_resynch = 1;
-}
-
-
-int scx_jb_put_first(struct scx_jb *jb, void *data, long ms, long ts, long now)
-{
-	/* this is our first frame - set the base of the receivers time */
-	jb-&gt;rxcore = now - ts;
-	
-	/* init next for a first time - it should be the time the first frame should be played */
-	jb-&gt;next_delivery = now + jb-&gt;delay;
-	
-	/* put the frame */
-	return scx_jb_put(jb, data, ms, ts, now);
-}
-
-
-int scx_jb_put(struct scx_jb *jb, void *data, long ms, long ts, long now)
-{
-	struct scx_jb_frame *frame, *next, *newframe;
-	long delivery;
-	
-	/* debug check the validity of the input params */
-	ASSERT(data != NULL);
-	/* do not allow frames shorter than 2 ms */
-	ASSERT(ms &gt;= 2);
-	ASSERT(ts &gt;= 0);
-	ASSERT(now &gt;= 0);
-	
-	delivery = jb-&gt;rxcore + jb-&gt;delay + ts;
-	
-	/* check if the new frame is not too late */
-	if (delivery &lt; jb-&gt;next_delivery) {
-		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
-		   the force resynch flag was not set. */
-		return resynch_jb(jb, data, ms, ts, now);
-	}
-	
-	/* what if the delivery time is bigger than next + delay? Seems like a frame for the future.
-	   However, allow more resync_threshold ms in advance */
-	if (delivery &gt; jb-&gt;next_delivery + jb-&gt;delay + jb-&gt;conf.resync_threshold) {
-		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
-		   the force resynch flag was not set. */
-		return resynch_jb(jb, data, ms, ts, now);
-	}
-
-	/* find the right place in the frames list, sorted by delivery time */
-	frame = jb-&gt;tail;
-	while (frame &amp;&amp; frame-&gt;delivery &gt; delivery) {
-		frame = frame-&gt;prev;
-	}
-	
-	/* Check if the new delivery time is not covered already by the chosen frame */
-	if (frame &amp;&amp; (frame-&gt;delivery == delivery ||
-		         delivery &lt; frame-&gt;delivery + frame-&gt;ms ||
-		         (frame-&gt;next &amp;&amp; delivery + ms &gt; frame-&gt;next-&gt;delivery)))
-	{
-		/* TODO: Should we check for resynch here? Be careful to do not allow threshold smaller than
-		   the size of the jb */
-		
-		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
-		   the force resynch flag was not set. */
-		return resynch_jb(jb, data, ms, ts, now);
-	}
-	
-	/* Reset the force resynch flag */
-	jb-&gt;force_resynch = 0;
-	
-	/* Get a new frame */
-	newframe = alloc_jb_frame(jb);
-	newframe-&gt;data = data;
-	newframe-&gt;ts = ts;
-	newframe-&gt;ms = ms;
-	newframe-&gt;delivery = delivery;
-	
-	/* and insert it right on place */
-	if (frame) {
-		next = frame-&gt;next;
-		frame-&gt;next = newframe;
-		if (next) {
-			newframe-&gt;next = next;
-			next-&gt;prev = newframe;
-		} else {
-			/* insert after the last frame - should update tail */
-			jb-&gt;tail = newframe;
-			newframe-&gt;next = NULL;
-		}
-		newframe-&gt;prev = frame;
-		
-		return SCX_JB_OK;
-	} else if (!jb-&gt;frames) {
-		/* the frame list is empty or thats just the first frame ever */
-		/* tail should also be NULL is that case */
-		ASSERT(jb-&gt;tail == NULL);
-		jb-&gt;frames = jb-&gt;tail = newframe;
-		newframe-&gt;next = NULL;
-		newframe-&gt;prev = NULL;
-		
-		return SCX_JB_OK;
-	} else {
-		/* insert on a first position - should update frames head */
-		newframe-&gt;next = jb-&gt;frames;
-		newframe-&gt;prev = NULL;
-		jb-&gt;frames-&gt;prev = newframe;
-		jb-&gt;frames = newframe;
-		
-		return SCX_JB_OK;
-	}
-}
-
-
-int scx_jb_get(struct scx_jb *jb, struct scx_jb_frame *frame, long now, long interpl)
-{
-	ASSERT(now &gt;= 0);
-	ASSERT(interpl &gt;= 2);
-	
-	if (now &lt; jb-&gt;next_delivery) {
-		/* too early for the next frame */
-		return SCX_JB_NOFRAME;
-	}
-	
-	/* Is the jb empty? */
-	if (!jb-&gt;frames) {
-		/* should interpolate a frame */
-		/* update next */
-		jb-&gt;next_delivery += interpl;
-		
-		return SCX_JB_INTERP;
-	}
-	
-	/* Isn't it too late for the first frame available in the jb? */
-	if (now &gt; jb-&gt;frames-&gt;delivery + jb-&gt;frames-&gt;ms) {
-		/* yes - should drop this frame and update next to point the next frame (get_jb_head() does it) */
-		get_jb_head(jb, frame);
-		
-		return SCX_JB_DROP;
-	}
-	
-	/* isn't it too early to play the first frame available? */
-	if (now &lt; jb-&gt;frames-&gt;delivery) {
-		/* yes - should interpolate one frame */
-		/* update next */
-		jb-&gt;next_delivery += interpl;
-		
-		return SCX_JB_INTERP;
-	}
-	
-	/* we have a frame for playing now (get_jb_head() updates next) */
-	get_jb_head(jb, frame);
-	
-	return SCX_JB_OK;
-}
-
-
-long scx_jb_next(struct scx_jb *jb)
-{
-	return jb-&gt;next_delivery;
-}
-
-
-int scx_jb_remove(struct scx_jb *jb, struct scx_jb_frame *frameout)
-{
-	if (!jb-&gt;frames)
-		return SCX_JB_NOFRAME;
-	
-	get_jb_head(jb, frameout);
-	
-	return SCX_JB_OK;
-}

Modified: trunk/scx_jitterbuf.h
===================================================================
--- trunk/scx_jitterbuf.h	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/scx_jitterbuf.h	2006-06-01 14:25:36 UTC (rev 210)
@@ -1,95 +0,0 @@
-/*
- * scx_jitterbuf: jitterbuffering algorithm
- *
- * Copyright (C) 2005, Attractel OOD
- *
- * Contributors:
- * Slav Klenov &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">slav at securax.org</A>&gt;
- *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
- * See <A HREF="http://www.asterisk.org">http://www.asterisk.org</A> for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*! \file 
- * 
- * \brief Jitterbuffering algorithm.
- * 
- */
-
-#ifndef _SCX_JITTERBUF_H_
-#define _SCX_JITTERBUF_H_
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-
-/* return codes */
-enum {
-	SCX_JB_OK,
-	SCX_JB_DROP,
-	SCX_JB_INTERP,
-	SCX_JB_NOFRAME
-};
-
-
-/* defaults */
-#define SCX_JB_SIZE_DEFAULT 200
-#define SCX_JB_RESYNCH_THRESHOLD_DEFAULT 1000
-
-
-/* jb configuration properties */
-struct scx_jb_conf
-{
-	long jbsize;
- 	long resync_threshold;
-};
-
-
-struct scx_jb_frame
-{
-	void *data;
-	long ts;
-	long ms;
-	long delivery;
-	struct scx_jb_frame *next;
-	struct scx_jb_frame *prev;
-};
-
-
-struct scx_jb;
-
-
-/* jb interface */
-
-struct scx_jb * scx_jb_new(struct scx_jb_conf *conf);
-
-void scx_jb_destroy(struct scx_jb *jb);
-
-int scx_jb_put_first(struct scx_jb *jb, void *data, long ms, long ts, long now);
-
-int scx_jb_put(struct scx_jb *jb, void *data, long ms, long ts, long now);
-
-int scx_jb_get(struct scx_jb *jb, struct scx_jb_frame *frame, long now, long interpl);
-
-long scx_jb_next(struct scx_jb *jb);
-
-int scx_jb_remove(struct scx_jb *jb, struct scx_jb_frame *frameout);
-
-void scx_jb_set_force_resynch(struct scx_jb *jb);
-
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-#endif /* _SCX_JITTERBUF_H_ */


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000204.html">[solid-pbx-svn] r209 - in trunk: channels channels/misdn configs
</A></li>
	<LI>Next message: <A HREF="000206.html">[solid-pbx-svn] r211 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#205">[ date ]</a>
              <a href="thread.html#205">[ thread ]</a>
              <a href="subject.html#205">[ subject ]</a>
              <a href="author.html#205">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
