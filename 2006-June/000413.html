<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [solid-pbx-svn] r418 - in trunk: . apps codecs codecs/gsm codecs/gsm/inc codecs/gsm/src
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-June/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r418%20-%20in%20trunk%3A%20.%20apps%20codecs%20codecs/gsm%20codecs/gsm/inc%20codecs/gsm/src&In-Reply-To=%3C200606280626.k5S6QDBj032694%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000412.html">
   <LINK REL="Next"  HREF="000414.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[solid-pbx-svn] r418 - in trunk: . apps codecs codecs/gsm codecs/gsm/inc codecs/gsm/src</H1>
    <B>solid-pbx-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r418%20-%20in%20trunk%3A%20.%20apps%20codecs%20codecs/gsm%20codecs/gsm/inc%20codecs/gsm/src&In-Reply-To=%3C200606280626.k5S6QDBj032694%40sheep.berlios.de%3E"
       TITLE="[solid-pbx-svn] r418 - in trunk: . apps codecs codecs/gsm codecs/gsm/inc codecs/gsm/src">solid-pbx-svn-admin at lists.berlios.de
       </A><BR>
    <I>Wed Jun 28 08:26:13 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000412.html">[solid-pbx-svn] r417 - in trunk: . apps codecs include/asterisk pbx
</A></li>
        <LI>Next message: <A HREF="000414.html">[solid-pbx-svn] r419 - trunk/codecs/gsm/inc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#413">[ date ]</a>
              <a href="thread.html#413">[ thread ]</a>
              <a href="subject.html#413">[ subject ]</a>
              <a href="author.html#413">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-06-28 08:25:21 +0200 (Wed, 28 Jun 2006)
New Revision: 418

Modified:
   trunk/apps/app_mp3.c
   trunk/asterisk.c
   trunk/codecs/codec_gsm.c
   trunk/codecs/gsm/COPYRIGHT
   trunk/codecs/gsm/README
   trunk/codecs/gsm/inc/config.h
   trunk/codecs/gsm/inc/gsm.h
   trunk/codecs/gsm/inc/private.h
   trunk/codecs/gsm/inc/proto.h
   trunk/codecs/gsm/src/add.c
   trunk/codecs/gsm/src/code.c
   trunk/codecs/gsm/src/debug.c
   trunk/codecs/gsm/src/decode.c
   trunk/codecs/gsm/src/gsm_create.c
   trunk/codecs/gsm/src/gsm_decode.c
   trunk/codecs/gsm/src/gsm_destroy.c
   trunk/codecs/gsm/src/gsm_encode.c
   trunk/codecs/gsm/src/gsm_explode.c
   trunk/codecs/gsm/src/gsm_implode.c
   trunk/codecs/gsm/src/gsm_option.c
   trunk/codecs/gsm/src/gsm_print.c
   trunk/codecs/gsm/src/long_term.c
   trunk/codecs/gsm/src/lpc.c
   trunk/codecs/gsm/src/preprocess.c
   trunk/codecs/gsm/src/rpe.c
   trunk/codecs/gsm/src/short_term.c
   trunk/codecs/gsm/src/table.c
   trunk/codecs/slin_gsm_ex.h
Log:
Update to Asterisk SVN trunk r30

------------------------------------------------------------------------
r21 | markster | 1999-11-15 05:57:28 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r22 | markster | 1999-11-15 06:04:48 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r23 | markster | 1999-11-15 07:08:50 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r24 | markster | 1999-11-15 07:08:52 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.1 from FTP

------------------------------------------------------------------------
r25 | markster | 1999-11-15 07:08:53 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.2 from FTP

------------------------------------------------------------------------
r26 | markster | 1999-11-15 07:08:53 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------
r27 | markster | 1999-11-15 07:08:54 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------
r28 | markster | 1999-11-15 07:08:55 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.4 from FTP

------------------------------------------------------------------------
r29 | markster | 1999-11-15 07:08:56 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.5 from FTP

------------------------------------------------------------------------
r30 | markster | 1999-11-15 07:08:57 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.6 from FTP

------------------------------------------------------------------------


Modified: trunk/apps/app_mp3.c
===================================================================
--- trunk/apps/app_mp3.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/apps/app_mp3.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,4 +1,197 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Silly application to play an MP3 file -- uses mpg123
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include &lt;asterisk/file.h&gt;
+#include &lt;asterisk/logger.h&gt;
+#include &lt;asterisk/channel.h&gt;
+#include &lt;asterisk/frame.h&gt;
+#include &lt;asterisk/pbx.h&gt;
+#include &lt;asterisk/module.h&gt;
+#include &lt;asterisk/translate.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;signal.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;sys/time.h&gt;
+
+#define MPG_123 &quot;/usr/bin/mpg123&quot;
+
+static char *tdesc = &quot;Silly MP3 Application&quot;;
+
+static char *app = &quot;MP3Player&quot;;
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int mp3play(char *filename, int fd)
+{
+	int res;
+	res = fork();
+	if (res &lt; 0) 
+		ast_log(LOG_WARNING, &quot;Fork failed\n&quot;);
+	if (res)
+		return res;
+	dup2(fd, STDOUT_FILENO);
+	/* Execute mpg123, but buffer if it's a net connection */
+	if (strncmp(filename, &quot;<A HREF="http://">http://</A>&quot;, 7)) 
+	    execl(MPG_123, MPG_123, &quot;-q&quot;, &quot;-s&quot;, &quot;-b&quot;, &quot;1024&quot;, &quot;--mono&quot;, &quot;-r&quot;, &quot;8000&quot;, filename, NULL);
+	else
+	    execl(MPG_123, MPG_123, &quot;-q&quot;, &quot;-s&quot;, &quot;--mono&quot;, &quot;-r&quot;, &quot;8000&quot;, filename, NULL);
+	ast_log(LOG_WARNING, &quot;Execute of mpg123 failed\n&quot;);
+	return -1;
+}
+
+static int mp3_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+	struct ast_channel *trans;
+	int fds[2];
+	int rfds[2];
+	int ms = -1;
+	int pid;
+	int us;
+	struct timeval tv;
+	struct timeval last;
+	struct ast_frame *f;
+	struct myframe {
+		struct ast_frame f;
+		char offset[AST_FRIENDLY_OFFSET];
+		char frdata[160];
+	} myf;
+	last.tv_usec = 0;
+	last.tv_sec = 0;
+	if (!data) {
+		ast_log(LOG_WARNING, &quot;MP3 Playback requires an argument (filename)\n&quot;);
+		return -1;
+	}
+	if (pipe(fds)) {
+		ast_log(LOG_WARNING, &quot;Unable to create pipe\n&quot;);
+		return -1;
+	}
+	LOCAL_USER_ADD(u);
+	ast_stopstream(chan);
+	if (chan-&gt;format &amp; AST_FORMAT_SLINEAR)
+		trans = chan;
+	else
+		trans = ast_translator_create(chan, AST_FORMAT_SLINEAR, AST_DIRECTION_OUT);
+	if (trans) {
+		res = mp3play((char *)data, fds[1]);
+		if (res &gt;= 0) {
+			pid = res;
+			/* Order is important -- there's almost always going to be mp3...  we want to prioritize the
+			   user */
+			rfds[0] = trans-&gt;fd;
+			rfds[1] = fds[0];
+			for (;;) {
+				CHECK_BLOCKING(trans);
+				res = ast_waitfor_n_fd(rfds, 2, &amp;ms);
+				trans-&gt;blocking = 0;
+				if (res &lt; 1) {
+					ast_log(LOG_DEBUG, &quot;Hangup detected\n&quot;);
+					res = -1;
+					break;
+				} else if (res == trans-&gt;fd) {
+					f = ast_read(trans);
+					if (!f) {
+						ast_log(LOG_DEBUG, &quot;Null frame == hangup() detected\n&quot;);
+						res = -1;
+						break;
+					}
+					if (f-&gt;frametype == AST_FRAME_DTMF) {
+						ast_log(LOG_DEBUG, &quot;User pressed a key\n&quot;);
+						ast_frfree(f);
+						res = 0;
+						break;
+					}
+					ast_frfree(f);
+				} else if (res == fds[0]) {
+					gettimeofday(&amp;tv, NULL);
+					if (last.tv_sec || last.tv_usec) {
+						/* We should wait at least a frame length */
+						us = sizeof(myf.frdata) / 16 * 1000;
+						/* Subtract 1,000,000 us for each second late we've passed */
+						us -= (tv.tv_sec - last.tv_sec) * 1000000;
+						/* And one for each us late we've passed */
+						us -= (tv.tv_usec - last.tv_usec);
+						/* Sleep that long if needed */
+						if (us &gt; 0)
+							usleep(us);
+					}
+					last = tv;
+					res = read(fds[0], myf.frdata, sizeof(myf.frdata));
+					if (res &gt; 0) {
+						myf.f.frametype = AST_FRAME_VOICE;
+						myf.f.subclass = AST_FORMAT_SLINEAR;
+						myf.f.datalen = res;
+						myf.f.timelen = res / 16;
+						myf.f.mallocd = 0;
+						myf.f.offset = AST_FRIENDLY_OFFSET;
+						myf.f.src = __PRETTY_FUNCTION__;
+						myf.f.data = myf.frdata;
+						if (ast_write(trans, &amp;myf.f) &lt; 0) {
+							res = -1;
+							break;
+						}
+					} else {
+						ast_log(LOG_DEBUG, &quot;No more mp3\n&quot;);
+						res = 0;
+					}
+				} else {
+					ast_log(LOG_DEBUG, &quot;HuhHHH?\n&quot;);
+					res = -1;
+					break;
+				}
+			}
+			kill(pid, SIGTERM);
+		}
+		if (trans != chan) 
+			ast_translator_destroy(trans);
+	} else 
+		ast_log(LOG_WARNING, &quot;No translator channel available\n&quot;);
+	close(fds[0]);
+	close(fds[1]);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	return ast_register_application(app, mp3_exec);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/asterisk.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,4 +1,98 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Top level source file for asterisk
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include &lt;unistd.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;asterisk/logger.h&gt;
+#include &lt;asterisk/options.h&gt;
+#include &lt;stdio.h&gt;
+#include &lt;signal.h&gt;
+#include &quot;asterisk.h&quot;
+
+int option_verbose=0;
+int option_debug=0;
+int option_nofork=0;
+int option_quiet=0;
+
+static void urg_handler(int num)
+{
+	/* Called by soft_hangup to interrupt the select, read, or other
+	   system call.  We don't actually need to do anything though.  */
+	if (option_debug)
+		ast_log(LOG_DEBUG, &quot;Urgent handler\n&quot;);
+	return;
+}
+
+static void quit_handler(int num)
+{
+	/* Called on exit */
+	if (option_verbose)
+		ast_verbose(&quot;Asterisk ending (%d).\n&quot;, num);
+	else if (option_debug)
+		ast_log(LOG_DEBUG, &quot;Asterisk ending (%d).\n&quot;, num);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	char c;
+	/* Check if we're root */
+	if (geteuid()) {
+		ast_log(LOG_ERROR, &quot;Must be run as root\n&quot;);
+		exit(1);
+	}
+	/* Check for options */
+	while((c=getopt(argc, argv, &quot;dvq&quot;)) != EOF) {
+		switch(c) {
+		case 'd':
+			option_debug++;
+			option_nofork++;
+			option_verbose++;
+			break;
+		case 'v':
+			option_verbose++;
+			break;
+		case 'q':
+			option_quiet++;
+			break;
+		case '?':
+			exit(1);
+		}
+	}
+	/* Print a welcome message if desired */
+	if (option_verbose) {
+		ast_verbose( &quot;Asterisk, Copyright (C) 1999 Adtran, Inc. and Linux Support Services, LLC\n&quot;);
+		ast_verbose( &quot;Written by Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;\n&quot;);
+		ast_verbose( &quot;=========================================================================\n&quot;);
+	}
+	signal(SIGURG, urg_handler);
+	signal(SIGINT, quit_handler);
+	signal(SIGTERM, quit_handler);
+	signal(SIGHUP, quit_handler);
+	if (init_logger())
+		exit(1);
+	if (load_pbx())
+		exit(1);
+	if (load_modules())
+		exit(1);
+	/* We might have the option of showing a console, but for now just
+	   do nothing... */
+	if (option_verbose)
+		ast_verbose( &quot;Asterisk Ready.\n&quot;);
+	select(0,NULL,NULL,NULL,NULL);
+	return 0;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/codecs/codec_gsm.c
===================================================================
--- trunk/codecs/codec_gsm.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/codec_gsm.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,4 +1,266 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Translate between signed linear and Global System for Mobile Communications (GSM)
+ *
+ * The GSM code is from TOAST.  Copyright information for that package is available
+ * in  the GSM directory.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#define TYPE_SILENCE	 0x2
+#define TYPE_HIGH	 0x0
+#define TYPE_LOW	 0x1
+#define TYPE_MASK	 0x3
+
+#include &lt;asterisk/translate.h&gt;
+#include &lt;asterisk/module.h&gt;
+#include &lt;asterisk/logger.h&gt;
+#include &lt;pthread.h&gt;
+#include &lt;fcntl.h&gt;
+#include &lt;stdlib.h&gt;
+#include &lt;unistd.h&gt;
+#include &lt;netinet/in.h&gt;
+#include &lt;string.h&gt;
+#include &lt;stdio.h&gt;
+
+#include &quot;gsm/inc/gsm.h&quot;
+
+/* Sample frame data */
+#include &quot;slin_gsm_ex.h&quot;
+#include &quot;gsm_slin_ex.h&quot;
+
+static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER;
+static int localusecnt=0;
+
+static char *tdesc = &quot;GSM/PCM16 (signed linear) Codec Translator&quot;;
+
+struct ast_translator_pvt {
+	gsm gsm;
+	struct ast_frame f;
+	/* Space to build offset */
+	char offset[AST_FRIENDLY_OFFSET];
+	/* Buffer for our outgoing frame */
+	gsm_frame outbuf;
+	/* Enough to store a full second */
+	short buf[8000];
+	int tail;
+};
+
+#define gsm_coder_pvt ast_translator_pvt
+
+static struct ast_translator_pvt *gsm_new()
+{
+	struct gsm_coder_pvt *tmp;
+	tmp = malloc(sizeof(struct gsm_coder_pvt));
+	if (tmp) {
+		if (!(tmp-&gt;gsm = gsm_create())) {
+			free(tmp);
+			tmp = NULL;
+		}
+		tmp-&gt;tail = 0;
+	}
+	return tmp;
+}
+
+static struct ast_frame *lintogsm_sample()
+{
+	static struct ast_frame f;
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass = AST_FORMAT_SLINEAR;
+	f.datalen = sizeof(slin_gsm_ex);
+	/* Assume 8000 Hz */
+	f.timelen = sizeof(slin_gsm_ex)/16;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data = slin_gsm_ex;
+	return &f;
+}
+
+static struct ast_frame *gsmtolin_sample()
+{
+	static struct ast_frame f;
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass = AST_FORMAT_GSM;
+	f.datalen = sizeof(gsm_slin_ex);
+	/* All frames are 30 ms long */
+	f.timelen = 30;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data = gsm_slin_ex;
+	return &f;
+}
+
+static struct ast_frame *gsmtolin_frameout(struct ast_translator_pvt *tmp)
+{
+	if (!tmp-&gt;tail)
+		return NULL;
+	/* Signed linear is no particular frame size, so just send whatever
+	   we have in the buffer in one lump sum */
+	tmp-&gt;f.frametype = AST_FRAME_VOICE;
+	tmp-&gt;f.subclass = AST_FORMAT_SLINEAR;
+	tmp-&gt;f.datalen = tmp-&gt;tail * 2;
+	/* Assume 8000 Hz */
+	tmp-&gt;f.timelen = tmp-&gt;tail / 8;
+	tmp-&gt;f.mallocd = 0;
+	tmp-&gt;f.offset = AST_FRIENDLY_OFFSET;
+	tmp-&gt;f.src = __PRETTY_FUNCTION__;
+	tmp-&gt;f.data = tmp-&gt;buf;
+	/* Reset tail pointer */
+	tmp-&gt;tail = 0;
+
+#if 0
+	/* Save a sample frame */
+	{ static int samplefr = 0;
+	if (samplefr == 80) {
+		int fd;
+		fd = open(&quot;gsm.example&quot;, O_WRONLY | O_CREAT, 0644);
+		write(fd, tmp-&gt;f.data, tmp-&gt;f.datalen);
+		close(fd);
+	} 		
+	samplefr++;
+	}
+#endif
+	return &amp;tmp-&gt;f;	
+}
+
+static int gsmtolin_framein(struct ast_translator_pvt *tmp, struct ast_frame *f)
+{
+	/* Assuming there's space left, decode into the current buffer at
+	   the tail location */
+	if (tmp-&gt;tail + 160 &lt; sizeof(tmp-&gt;buf)/2) {	
+		if (gsm_decode(tmp-&gt;gsm, f-&gt;data, tmp-&gt;buf + tmp-&gt;tail)) {
+			ast_log(LOG_WARNING, &quot;Invalid GSM data\n&quot;);
+			return -1;
+		}
+		tmp-&gt;tail+=160;
+	} else {
+		ast_log(LOG_WARNING, &quot;Out of buffer space\n&quot;);
+		return -1;
+	}
+	return 0;
+}
+
+static int lintogsm_framein(struct ast_translator_pvt *tmp, struct ast_frame *f)
+{
+	/* Just add the frames to our stream */
+	/* XXX We should look at how old the rest of our stream is, and if it
+	   is too old, then we should overwrite it entirely, otherwise we can
+	   get artifacts of earlier talk that do not belong */
+	if (tmp-&gt;tail + f-&gt;datalen &lt; sizeof(tmp-&gt;buf) / 2) {
+		memcpy(tmp-&gt;buf + tmp-&gt;tail, f-&gt;data, f-&gt;datalen);
+		tmp-&gt;tail += f-&gt;datalen/2;
+	} else {
+		ast_log(LOG_WARNING, &quot;Out of buffer space\n&quot;);
+		return -1;
+	}
+	return 0;
+}
+
+static struct ast_frame *lintogsm_frameout(struct ast_translator_pvt *tmp)
+{
+	/* We can't work on anything less than a frame in size */
+	if (tmp-&gt;tail &lt; 160)
+		return NULL;
+	/* Encode a frame of data */
+	gsm_encode(tmp-&gt;gsm, tmp-&gt;buf, tmp-&gt;outbuf);
+	tmp-&gt;f.frametype = AST_FRAME_VOICE;
+	tmp-&gt;f.subclass = AST_FORMAT_GSM;
+	tmp-&gt;f.datalen = 33;
+	/* Assume 8000 Hz -- 20 ms */
+	tmp-&gt;f.timelen = 20;
+	tmp-&gt;f.mallocd = 0;
+	tmp-&gt;f.offset = AST_FRIENDLY_OFFSET;
+	tmp-&gt;f.src = __PRETTY_FUNCTION__;
+	tmp-&gt;f.data = tmp-&gt;outbuf;
+	tmp-&gt;tail -= 160;
+	/* Move the data at the end of the buffer to the front */
+	if (tmp-&gt;tail)
+		memmove(tmp-&gt;buf, tmp-&gt;buf + 160 * 2, tmp-&gt;tail * 2);
+#if 0
+	/* Save a sample frame */
+	{ static int samplefr = 0;
+	if (samplefr == 0) {
+		int fd;
+		fd = open(&quot;gsm.example&quot;, O_WRONLY | O_CREAT, 0644);
+		write(fd, tmp-&gt;f.data, tmp-&gt;f.datalen);
+		close(fd);
+	} 		
+	samplefr++;
+	}
+#endif
+	return &amp;tmp-&gt;f;	
+}
+
+static void gsm_destroy_stuff(struct ast_translator_pvt *pvt)
+{
+	free(pvt);
+}
+
+static struct ast_translator gsmtolin =
+	{ &quot;gsmtolin&quot;, 
+	   AST_FORMAT_GSM, AST_FORMAT_SLINEAR,
+	   gsm_new,
+	   gsmtolin_framein,
+	   gsmtolin_frameout,
+	   gsm_destroy_stuff,
+	   gsmtolin_sample
+	   };
+
+static struct ast_translator lintogsm =
+	{ &quot;lintogsm&quot;, 
+	   AST_FORMAT_SLINEAR, AST_FORMAT_GSM,
+	   gsm_new,
+	   lintogsm_framein,
+	   lintogsm_frameout,
+	   gsm_destroy_stuff,
+	   lintogsm_sample
+	   };
+
+int unload_module(void)
+{
+	int res;
+	pthread_mutex_lock(&amp;localuser_lock);
+	res = ast_unregister_translator(&amp;lintogsm);
+	if (!res)
+		res = ast_unregister_translator(&amp;gsmtolin);
+	if (localusecnt)
+		res = -1;
+	pthread_mutex_unlock(&amp;localuser_lock);
+	return res;
+}
+
+int load_module(void)
+{
+	int res;
+	res=ast_register_translator(&amp;gsmtolin);
+	if (!res) 
+		res=ast_register_translator(&amp;lintogsm);
+	else
+		ast_unregister_translator(&amp;gsmtolin);
+	return res;
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * The GSM code is from TOAST.  Copyright information for that package is available

Modified: trunk/codecs/gsm/COPYRIGHT
===================================================================
--- trunk/codecs/gsm/COPYRIGHT	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/COPYRIGHT	2006-06-28 06:25:21 UTC (rev 418)
@@ -14,3 +14,19 @@
 Berlin, 28.11.1994
 Jutta Degener
 Carsten Bormann
+Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
+Technische Universitaet Berlin
+
+Any use of this software is permitted provided that this notice is not
+removed and that neither the authors nor the Technische Universitaet Berlin
+are deemed to have made any representations as to the suitability of this
+software for any purpose nor are held responsible for any defects of
+this software.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+
+As a matter of courtesy, the authors request to be informed about uses
+this software has found, about bugs in this software, and about any
+improvements that may be of general interest.
+
+Berlin, 28.11.1994
+Jutta Degener
+Carsten Bormann

Modified: trunk/codecs/gsm/README
===================================================================
--- trunk/codecs/gsm/README	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/README	2006-06-28 06:25:21 UTC (rev 418)
@@ -35,3 +35,40 @@
 Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
 Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
 details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+
+GSM 06.10 13 kbit/s RPE/LTP speech compression available
+--------------------------------------------------------
+
+The Communications and Operating Systems Research Group (KBS) at the
+Technische Universitaet Berlin is currently working on a set of
+UNIX-based tools for computer-mediated telecooperation that will be
+made freely available.
+
+As part of this effort we are publishing an implementation of the
+European GSM 06.10 provisional standard for full-rate speech
+transcoding, prI-ETS 300 036, which uses RPE/LTP (residual pulse
+excitation/long term prediction) coding at 13 kbit/s.
+
+GSM 06.10 compresses frames of 160 13-bit samples (8 kHz sampling
+rate, i.e. a frame rate of 50 Hz) into 260 bits; for compatibility
+with typical UNIX applications, our implementation turns frames of 160
+16-bit linear samples into 33-byte frames (1650 Bytes/s).
+The quality of the algorithm is good enough for reliable speaker
+recognition; even music often survives transcoding in recognizable 
+form (given the bandwidth limitations of 8 kHz sampling rate).
+
+The interfaces offered are a front end modelled after compress(1), and
+a library API.  Compression and decompression run faster than realtime
+on most SPARCstations.  The implementation has been verified against the
+ETSI standard test patterns.
+
+Jutta Degener (<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">jutta at cs.tu-berlin.de</A>)
+Carsten Bormann (<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">cabo at cs.tu-berlin.de</A>)
+
+Communications and Operating Systems Research Group, TU Berlin
+Fax: +49.30.31425156, Phone: +49.30.31424315
+
+--
+Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.

Modified: trunk/codecs/gsm/inc/config.h
===================================================================
--- trunk/codecs/gsm/inc/config.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/config.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -9,6 +9,43 @@
 #ifndef	CONFIG_H
 #define	CONFIG_H
 
+/*efine	SIGHANDLER_T	int 		/* signal handlers are void	*/
+/*efine HAS_SYSV_SIGNAL	1		/* sigs not blocked/reset?	*/
+
+#define	HAS_STDLIB_H	1		/* /usr/include/stdlib.h	*/
+/*efine	HAS_LIMITS_H	1		/* /usr/include/limits.h	*/
+#define	HAS_FCNTL_H	1		/* /usr/include/fcntl.h		*/
+/*efine	HAS_ERRNO_DECL	1		/* errno.h declares errno	*/
+
+#define	HAS_FSTAT 	1		/* fstat syscall		*/
+#define	HAS_FCHMOD 	1		/* fchmod syscall		*/
+#define	HAS_CHMOD 	1		/* chmod syscall		*/
+#define	HAS_FCHOWN 	1		/* fchown syscall		*/
+#define	HAS_CHOWN 	1		/* chown syscall		*/
+/*efine	HAS__FSETMODE 	1		/* _fsetmode -- set file mode	*/
+
+#define	HAS_STRING_H 	1		/* /usr/include/string.h 	*/
+/*efine	HAS_STRINGS_H	1		/* /usr/include/strings.h 	*/
+
+#define	HAS_UNISTD_H	1		/* /usr/include/unistd.h	*/
+#define	HAS_UTIME	1		/* POSIX utime(path, times)	*/
+/*efine	HAS_UTIMES	1		/* use utimes()	syscall instead	*/
+#define	HAS_UTIME_H	1		/* UTIME header file		*/
+/*efine	HAS_UTIMBUF	1		/* struct utimbuf		*/
+/*efine	HAS_UTIMEUSEC   1		/* microseconds in utimbuf?	*/
+
+#endif	/* CONFIG_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	CONFIG_H
+#define	CONFIG_H
+
 #if 0
 efine	SIGHANDLER_T	int 		/* signal handlers are void	*/
 efine HAS_SYSV_SIGNAL	1		/* sigs not blocked/reset?	*/

Modified: trunk/codecs/gsm/inc/gsm.h
===================================================================
--- trunk/codecs/gsm/inc/gsm.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/gsm.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -69,3 +69,74 @@
 #undef	GSM_P
 
 #endif	/* GSM_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	GSM_H
+#define	GSM_H
+
+#ifdef __cplusplus
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#if __STDC__
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#ifdef _NO_PROTO
+#	undef	NeedFunctionPrototypes
+#endif
+
+#ifdef NeedFunctionPrototypes
+#   include	&lt;stdio.h&gt;		/* for FILE * 	*/
+#endif
+
+#undef GSM_P
+#if NeedFunctionPrototypes
+#	define	GSM_P( protos )	protos
+#else
+#	define  GSM_P( protos )	( /* protos */ )
+#endif
+
+/*
+ *	Interface
+ */
+
+typedef struct gsm_state * 	gsm;
+typedef short		   	gsm_signal;		/* signed 16 bit */
+typedef unsigned char		gsm_byte;
+typedef gsm_byte 		gsm_frame[33];		/* 33 * 8 bits	 */
+
+#define	GSM_MAGIC		0xD		  	/* 13 kbit/s RPE-LTP */
+
+#define	GSM_PATCHLEVEL		10
+#define	GSM_MINOR		0
+#define	GSM_MAJOR		1
+
+#define	GSM_OPT_VERBOSE		1
+#define	GSM_OPT_FAST		2
+#define	GSM_OPT_LTP_CUT		3
+#define	GSM_OPT_WAV49		4
+#define	GSM_OPT_FRAME_INDEX	5
+#define	GSM_OPT_FRAME_CHAIN	6
+
+extern gsm  gsm_create 	GSM_P((void));
+extern void gsm_destroy GSM_P((gsm));	
+
+extern int  gsm_print   GSM_P((FILE *, gsm, gsm_byte  *));
+extern int  gsm_option  GSM_P((gsm, int, int *));
+
+extern void gsm_encode  GSM_P((gsm, gsm_signal *, gsm_byte  *));
+extern int  gsm_decode  GSM_P((gsm, gsm_byte   *, gsm_signal *));
+
+extern int  gsm_explode GSM_P((gsm, gsm_byte   *, gsm_signal *));
+extern void gsm_implode GSM_P((gsm, gsm_signal *, gsm_byte   *));
+
+#undef	GSM_P
+
+#endif	/* GSM_H */

Modified: trunk/codecs/gsm/inc/private.h
===================================================================
--- trunk/codecs/gsm/inc/private.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/private.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -98,6 +98,274 @@
 # define GSM_L_MULT(a, b) /* word a, word b */	\
 	(((longword)(a) * (longword)(b)) &lt;&lt; 1)
 
+# define GSM_L_ADD(a, b)	\
+	( (a) &lt;  0 ? ( (b) &gt;= 0 ? (a) + (b)	\
+		 : (utmp = (ulongword)-((a) + 1) + (ulongword)-((b) + 1)) \
+		   &gt;= MAX_LONGWORD ? MIN_LONGWORD : -(longword)utmp-2 )   \
+	: ((b) &lt;= 0 ? (a) + (b)   \
+	          : (utmp = (ulongword)(a) + (ulongword)(b)) &gt;= MAX_LONGWORD \
+		    ? MAX_LONGWORD : utmp))
+
+/*
+ * # define GSM_ADD(a, b)	\
+ * 	((ltmp = (longword)(a) + (longword)(b)) &gt;= MAX_WORD \
+ * 	? MAX_WORD : ltmp &lt;= MIN_WORD ? MIN_WORD : ltmp)
+ */
+/* Nonportable, but faster: */
+
+#define	GSM_ADD(a, b)	\
+	((ulongword)((ltmp = (longword)(a) + (longword)(b)) - MIN_WORD) &gt; \
+		MAX_WORD - MIN_WORD ? (ltmp &gt; 0 ? MAX_WORD : MIN_WORD) : ltmp)
+
+# define GSM_SUB(a, b)	\
+	((ltmp = (longword)(a) - (longword)(b)) &gt;= MAX_WORD \
+	? MAX_WORD : ltmp &lt;= MIN_WORD ? MIN_WORD : ltmp)
+
+# define GSM_ABS(a)	((a) &lt; 0 ? ((a) == MIN_WORD ? MAX_WORD : -(a)) : (a))
+
+/* Use these if necessary:
+
+# define GSM_MULT_R(a, b)	gsm_mult_r(a, b)
+# define GSM_MULT(a, b)		gsm_mult(a, b)
+# define GSM_L_MULT(a, b)	gsm_L_mult(a, b)
+
+# define GSM_L_ADD(a, b)	gsm_L_add(a, b)
+# define GSM_ADD(a, b)		gsm_add(a, b)
+# define GSM_SUB(a, b)		gsm_sub(a, b)
+
+# define GSM_ABS(a)		gsm_abs(a)
+
+*/
+
+/*
+ *  More prototypes from implementations..
+ */
+extern void Gsm_Coder P((
+		struct gsm_state	* S,
+		word	* s,	/* [0..159] samples		IN	*/
+		word	* LARc,	/* [0..7] LAR coefficients	OUT	*/
+		word	* Nc,	/* [0..3] LTP lag		OUT 	*/
+		word	* bc,	/* [0..3] coded LTP gain	OUT 	*/
+		word	* Mc,	/* [0..3] RPE grid selection	OUT     */
+		word	* xmaxc,/* [0..3] Coded maximum amplitude OUT	*/
+		word	* xMc	/* [13*4] normalized RPE samples OUT	*/));
+
+extern void Gsm_Long_Term_Predictor P((		/* 4x for 160 samples */
+		struct gsm_state * S,
+		word	* d,	/* [0..39]   residual signal	IN	*/
+		word	* dp,	/* [-120..-1] d'		IN	*/
+		word	* e,	/* [0..40] 			OUT	*/
+		word	* dpp,	/* [0..40] 			OUT	*/
+		word	* Nc,	/* correlation lag		OUT	*/
+		word	* bc	/* gain factor			OUT	*/));
+
+extern void Gsm_LPC_Analysis P((
+		struct gsm_state * S,
+		word * s,	 /* 0..159 signals	IN/OUT	*/
+	        word * LARc));   /* 0..7   LARc's	OUT	*/
+
+extern void Gsm_Preprocess P((
+		struct gsm_state * S,
+		word * s, word * so));
+
+extern void Gsm_Encoding P((
+		struct gsm_state * S,
+		word	* e,	
+		word	* ep,	
+		word	* xmaxc,
+		word	* Mc,	
+		word	* xMc));
+
+extern void Gsm_Short_Term_Analysis_Filter P((
+		struct gsm_state * S,
+		word	* LARc,	/* coded log area ratio [0..7]  IN	*/
+		word	* d	/* st res. signal [0..159]	IN/OUT	*/));
+
+extern void Gsm_Decoder P((
+		struct gsm_state * S,
+		word	* LARcr,	/* [0..7]		IN	*/
+		word	* Ncr,		/* [0..3] 		IN 	*/
+		word	* bcr,		/* [0..3]		IN	*/
+		word	* Mcr,		/* [0..3] 		IN 	*/
+		word	* xmaxcr,	/* [0..3]		IN 	*/
+		word	* xMcr,		/* [0..13*4]		IN	*/
+		word	* s));		/* [0..159]		OUT 	*/
+
+extern void Gsm_Decoding P((
+		struct gsm_state * S,
+		word 	xmaxcr,
+		word	Mcr,
+		word	* xMcr,  	/* [0..12]		IN	*/
+		word	* erp)); 	/* [0..39]		OUT 	*/
+
+extern void Gsm_Long_Term_Synthesis_Filtering P((
+		struct gsm_state* S,
+		word	Ncr,
+		word	bcr,
+		word	* erp,		/* [0..39]		  IN 	*/
+		word	* drp)); 	/* [-120..-1] IN, [0..40] OUT 	*/
+
+void Gsm_RPE_Decoding P((
+	struct gsm_state *S,
+		word xmaxcr,
+		word Mcr,
+		word * xMcr,  /* [0..12], 3 bits             IN      */
+		word * erp)); /* [0..39]                     OUT     */
+
+void Gsm_RPE_Encoding P((
+		struct gsm_state * S,
+		word    * e,            /* -5..-1][0..39][40..44     IN/OUT  */
+		word    * xmaxc,        /*                              OUT */
+		word    * Mc,           /*                              OUT */
+		word    * xMc));        /* [0..12]                      OUT */
+
+extern void Gsm_Short_Term_Synthesis_Filter P((
+		struct gsm_state * S,
+		word	* LARcr, 	/* log area ratios [0..7]  IN	*/
+		word	* drp,		/* received d [0...39]	   IN	*/
+		word	* s));		/* signal   s [0..159]	  OUT	*/
+
+extern void Gsm_Update_of_reconstructed_short_time_residual_signal P((
+		word	* dpp,		/* [0...39]	IN	*/
+		word	* ep,		/* [0...39]	IN	*/
+		word	* dp));		/* [-120...-1]  IN/OUT 	*/
+
+/*
+ *  Tables from table.c
+ */
+#ifndef	GSM_TABLE_C
+
+extern word gsm_A[8], gsm_B[8], gsm_MIC[8], gsm_MAC[8];
+extern word gsm_INVA[8];
+extern word gsm_DLB[4], gsm_QLB[4];
+extern word gsm_H[11];
+extern word gsm_NRFAC[8];
+extern word gsm_FAC[8];
+
+#endif	/* GSM_TABLE_C */
+
+/*
+ *  Debugging
+ */
+#ifdef NDEBUG
+
+#	define	gsm_debug_words(a, b, c, d)		/* nil */
+#	define	gsm_debug_longwords(a, b, c, d)		/* nil */
+#	define	gsm_debug_word(a, b)			/* nil */
+#	define	gsm_debug_longword(a, b)		/* nil */
+
+#else	/* !NDEBUG =&gt; DEBUG */
+
+	extern void  gsm_debug_words     P((char * name, int, int, word *));
+	extern void  gsm_debug_longwords P((char * name, int, int, longword *));
+	extern void  gsm_debug_longword  P((char * name, longword));
+	extern void  gsm_debug_word      P((char * name, word));
+
+#endif /* !NDEBUG */
+
+#include &quot;unproto.h&quot;
+
+#endif	/* PRIVATE_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	PRIVATE_H
+#define	PRIVATE_H
+
+typedef short			word;		/* 16 bit signed int	*/
+typedef long			longword;	/* 32 bit signed int	*/
+
+typedef unsigned short		uword;		/* unsigned word	*/
+typedef unsigned long		ulongword;	/* unsigned longword	*/
+
+struct gsm_state {
+
+	word		dp0[ 280 ];
+
+	word		z1;		/* preprocessing.c, Offset_com. */
+	longword	L_z2;		/*                  Offset_com. */
+	int		mp;		/*                  Preemphasis	*/
+
+	word		u[8];		/* short_term_aly_filter.c	*/
+	word		LARpp[2][8]; 	/*                              */
+	word		j;		/*                              */
+
+	word            ltp_cut;        /* long_term.c, LTP crosscorr.  */
+	word		nrp; /* 40 */	/* long_term.c, synthesis	*/
+	word		v[9];		/* short_term.c, synthesis	*/
+	word		msr;		/* decoder.c,	Postprocessing	*/
+
+	char		verbose;	/* only used if !NDEBUG		*/
+	char		fast;		/* only used if FAST		*/
+
+	char		wav_fmt;	/* only used if WAV49 defined	*/
+	unsigned char	frame_index;	/*            odd/even chaining	*/
+	unsigned char	frame_chain;	/*   half-byte to carry forward	*/
+};
+
+
+#define	MIN_WORD	(-32767 - 1)
+#define	MAX_WORD	  32767
+
+#define	MIN_LONGWORD	(-2147483647 - 1)
+#define	MAX_LONGWORD	  2147483647
+
+#ifdef	SASR		/* flag: &gt;&gt; is a signed arithmetic shift right */
+#undef	SASR
+#define	SASR(x, by)	((x) &gt;&gt; (by))
+#else
+#define	SASR(x, by)	((x) &gt;= 0 ? (x) &gt;&gt; (by) : (~(-((x) + 1) &gt;&gt; (by))))
+#endif	/* SASR */
+
+#include &quot;proto.h&quot;
+
+/*
+ *	Prototypes from add.c
+ */
+extern word	gsm_mult 	P((word a, word b));
+extern longword gsm_L_mult 	P((word a, word b));
+extern word	gsm_mult_r	P((word a, word b));
+
+extern word	gsm_div  	P((word num, word denum));
+
+extern word	gsm_add 	P(( word a, word b ));
+extern longword gsm_L_add 	P(( longword a, longword b ));
+
+extern word	gsm_sub 	P((word a, word b));
+extern longword gsm_L_sub 	P((longword a, longword b));
+
+extern word	gsm_abs 	P((word a));
+
+extern word	gsm_norm 	P(( longword a ));
+
+extern longword gsm_L_asl  	P((longword a, int n));
+extern word	gsm_asl 	P((word a, int n));
+
+extern longword gsm_L_asr  	P((longword a, int n));
+extern word	gsm_asr  	P((word a, int n));
+
+/*
+ *  Inlined functions from add.h 
+ */
+
+/* 
+ * #define GSM_MULT_R(a, b) (* word a, word b, !(a == b == MIN_WORD) *)	\
+ *	(0x0FFFF &amp; SASR(((longword)(a) * (longword)(b) + 16384), 15))
+ */
+#define GSM_MULT_R(a, b) /* word a, word b, !(a == b == MIN_WORD) */	\
+	(SASR( ((longword)(a) * (longword)(b) + 16384), 15 ))
+
+# define GSM_MULT(a,b)	 /* word a, word b, !(a == b == MIN_WORD) */	\
+	(SASR( ((longword)(a) * (longword)(b)), 15 ))
+
+# define GSM_L_MULT(a, b) /* word a, word b */	\
+	(((longword)(a) * (longword)(b)) &lt;&lt; 1)
+
 #if defined(__GNUC__) &amp;&amp; defined(__i386__)
 
 static __inline__ int GSM_L_ADD(int a, int b)

Modified: trunk/codecs/gsm/inc/proto.h
===================================================================
--- trunk/codecs/gsm/inc/proto.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/proto.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -63,3 +63,68 @@
 #endif  /* !NeedFunctionPrototypes */
 
 #endif	/* PROTO_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	PROTO_H
+#define	PROTO_H
+
+#if __cplusplus
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#if __STDC__
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#ifdef	_NO_PROTO
+#	undef	NeedFunctionPrototypes
+#endif
+
+#undef	P	/* gnu stdio.h actually defines this... 	*/
+#undef	P0
+#undef	P1
+#undef	P2
+#undef	P3
+#undef	P4
+#undef	P5
+#undef	P6
+#undef	P7
+#undef	P8
+
+#if NeedFunctionPrototypes
+
+#	define	P( protos )	protos
+
+#	define	P0()				(void)
+#	define	P1(x, a)			(a)
+#	define	P2(x, a, b)			(a, b)
+#	define	P3(x, a, b, c)			(a, b, c)
+#	define	P4(x, a, b, c, d)		(a, b, c, d)	
+#	define	P5(x, a, b, c, d, e)		(a, b, c, d, e)
+#	define	P6(x, a, b, c, d, e, f)		(a, b, c, d, e, f)
+#	define	P7(x, a, b, c, d, e, f, g)	(a, b, c, d, e, f, g)
+#	define	P8(x, a, b, c, d, e, f, g, h)	(a, b, c, d, e, f, g, h)
+
+#else /* !NeedFunctionPrototypes */
+
+#	define	P( protos )	( /* protos */ )
+
+#	define	P0()				()
+#	define	P1(x, a)			x a;
+#	define	P2(x, a, b)			x a; b;
+#	define	P3(x, a, b, c)			x a; b; c;
+#	define	P4(x, a, b, c, d)		x a; b; c; d;
+#	define	P5(x, a, b, c, d, e)		x a; b; c; d; e;
+#	define	P6(x, a, b, c, d, e, f)		x a; b; c; d; e; f;
+#	define	P7(x, a, b, c, d, e, f, g)	x a; b; c; d; e; f; g;
+#	define	P8(x, a, b, c, d, e, f, g, h)	x a; b; c; d; e; f; g; h;
+
+#endif  /* !NeedFunctionPrototypes */
+
+#endif	/* PROTO_H */

Modified: trunk/codecs/gsm/src/add.c
===================================================================
--- trunk/codecs/gsm/src/add.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/add.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -23,6 +23,241 @@
 word gsm_add P2((a,b), word a, word b)
 {
 	longword sum = (longword)a + (longword)b;
+	return saturate(sum);
+}
+
+word gsm_sub P2((a,b), word a, word b)
+{
+	longword diff = (longword)a - (longword)b;
+	return saturate(diff);
+}
+
+word gsm_mult P2((a,b), word a, word b)
+{
+	if (a == MIN_WORD &amp;&amp; b == MIN_WORD) return MAX_WORD;
+	else return SASR( (longword)a * (longword)b, 15 );
+}
+
+word gsm_mult_r P2((a,b), word a, word b)
+{
+	if (b == MIN_WORD &amp;&amp; a == MIN_WORD) return MAX_WORD;
+	else {
+		longword prod = (longword)a * (longword)b + 16384;
+		prod &gt;&gt;= 15;
+		return prod &amp; 0xFFFF;
+	}
+}
+
+word gsm_abs P1((a), word a)
+{
+	return a &lt; 0 ? (a == MIN_WORD ? MAX_WORD : -a) : a;
+}
+
+longword gsm_L_mult P2((a,b),word a, word b)
+{
+	assert( a != MIN_WORD || b != MIN_WORD );
+	return ((longword)a * (longword)b) &lt;&lt; 1;
+}
+
+longword gsm_L_add P2((a,b), longword a, longword b)
+{
+	if (a &lt; 0) {
+		if (b &gt;= 0) return a + b;
+		else {
+			ulongword A = (ulongword)-(a + 1) + (ulongword)-(b + 1);
+			return A &gt;= MAX_LONGWORD ? MIN_LONGWORD :-(longword)A-2;
+		}
+	}
+	else if (b &lt;= 0) return a + b;
+	else {
+		ulongword A = (ulongword)a + (ulongword)b;
+		return A &gt; MAX_LONGWORD ? MAX_LONGWORD : A;
+	}
+}
+
+longword gsm_L_sub P2((a,b), longword a, longword b)
+{
+	if (a &gt;= 0) {
+		if (b &gt;= 0) return a - b;
+		else {
+			/* a&gt;=0, b&lt;0 */
+
+			ulongword A = (ulongword)a + -(b + 1);
+			return A &gt;= MAX_LONGWORD ? MAX_LONGWORD : (A + 1);
+		}
+	}
+	else if (b &lt;= 0) return a - b;
+	else {
+		/* a&lt;0, b&gt;0 */  
+
+		ulongword A = (ulongword)-(a + 1) + b;
+		return A &gt;= MAX_LONGWORD ? MIN_LONGWORD : -(longword)A - 1;
+	}
+}
+
+static unsigned char const bitoff[ 256 ] = {
+	 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+	 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+word gsm_norm P1((a), longword a )
+/*
+ * the number of left shifts needed to normalize the 32 bit
+ * variable L_var1 for positive values on the interval
+ *
+ * with minimum of
+ * minimum of 1073741824  (01000000000000000000000000000000) and 
+ * maximum of 2147483647  (01111111111111111111111111111111)
+ *
+ *
+ * and for negative values on the interval with
+ * minimum of -2147483648 (-10000000000000000000000000000000) and
+ * maximum of -1073741824 ( -1000000000000000000000000000000).
+ *
+ * in order to normalize the result, the following
+ * operation must be done: L_norm_var1 = L_var1 &lt;&lt; norm( L_var1 );
+ *
+ * (That's 'ffs', only from the left, not the right..)
+ */
+{
+	assert(a != 0);
+
+	if (a &lt; 0) {
+		if (a &lt;= -1073741824) return 0;
+		a = ~a;
+	}
+
+	return    a &amp; 0xffff0000 
+		? ( a &amp; 0xff000000
+		  ?  -1 + bitoff[ 0xFF &amp; (a &gt;&gt; 24) ]
+		  :   7 + bitoff[ 0xFF &amp; (a &gt;&gt; 16) ] )
+		: ( a &amp; 0xff00
+		  ?  15 + bitoff[ 0xFF &amp; (a &gt;&gt; 8) ]
+		  :  23 + bitoff[ 0xFF &amp; a ] );
+}
+
+longword gsm_L_asl P2((a,n), longword a, int n)
+{
+	if (n &gt;= 32) return 0;
+	if (n &lt;= -32) return -(a &lt; 0);
+	if (n &lt; 0) return gsm_L_asr(a, -n);
+	return a &lt;&lt; n;
+}
+
+word gsm_asl P2((a,n), word a, int n)
+{
+	if (n &gt;= 16) return 0;
+	if (n &lt;= -16) return -(a &lt; 0);
+	if (n &lt; 0) return gsm_asr(a, -n);
+	return a &lt;&lt; n;
+}
+
+longword gsm_L_asr P2((a,n), longword a, int n)
+{
+	if (n &gt;= 32) return -(a &lt; 0);
+	if (n &lt;= -32) return 0;
+	if (n &lt; 0) return a &lt;&lt; -n;
+
+#	ifdef	SASR
+		return a &gt;&gt; n;
+#	else
+		if (a &gt;= 0) return a &gt;&gt; n;
+		else return -(longword)( -(ulongword)a &gt;&gt; n );
+#	endif
+}
+
+word gsm_asr P2((a,n), word a, int n)
+{
+	if (n &gt;= 16) return -(a &lt; 0);
+	if (n &lt;= -16) return 0;
+	if (n &lt; 0) return a &lt;&lt; -n;
+
+#	ifdef	SASR
+		return a &gt;&gt; n;
+#	else
+		if (a &gt;= 0) return a &gt;&gt; n;
+		else return -(word)( -(uword)a &gt;&gt; n );
+#	endif
+}
+
+/* 
+ *  (From p. 46, end of section 4.2.5)
+ *
+ *  NOTE: The following lines gives [sic] one correct implementation
+ *  	  of the div(num, denum) arithmetic operation.  Compute div
+ *        which is the integer division of num by denum: with denum
+ *	  &gt;= num &gt; 0
+ */
+
+word gsm_div P2((num,denum), word num, word denum)
+{
+	longword	L_num   = num;
+	longword	L_denum = denum;
+	word		div 	= 0;
+	int		k 	= 15;
+
+	/* The parameter num sometimes becomes zero.
+	 * Although this is explicitly guarded against in 4.2.5,
+	 * we assume that the result should then be zero as well.
+	 */
+
+	/* assert(num != 0); */
+
+	assert(num &gt;= 0 &amp;&amp; denum &gt;= num);
+	if (num == 0)
+	    return 0;
+
+	while (k--) {
+		div   &lt;&lt;= 1;
+		L_num &lt;&lt;= 1;
+
+		if (L_num &gt;= L_denum) {
+			L_num -= L_denum;
+			div++;
+		}
+	}
+
+	return div;
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+/*
+ *  See private.h for the more commonly used macro versions.
+ */
+
+#include	&lt;stdio.h&gt;
+#include	&lt;assert.h&gt;
+
+#include	&quot;private.h&quot;
+#include	&quot;gsm.h&quot;
+#include	&quot;proto.h&quot;
+
+#define	saturate(x) 	\
+	((x) &lt; MIN_WORD ? MIN_WORD : (x) &gt; MAX_WORD ? MAX_WORD: (x))
+
+word gsm_add P2((a,b), word a, word b)
+{
+	longword sum = (longword)a + (longword)b;
 	return (word)saturate(sum);
 }
 

Modified: trunk/codecs/gsm/src/code.c
===================================================================
--- trunk/codecs/gsm/src/code.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/code.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -8,6 +8,105 @@
 
 #include	&quot;config.h&quot;
 
+
+#ifdef	HAS_STDLIB_H
+#include	&lt;stdlib.h&gt;
+#else
+#	include &quot;proto.h&quot;
+	extern char	* memcpy P((char *, char *, int));
+#endif
+
+#include	&quot;private.h&quot;
+#include	&quot;gsm.h&quot;
+#include	&quot;proto.h&quot;
+
+/* 
+ *  4.2 FIXED POINT IMPLEMENTATION OF THE RPE-LTP CODER 
+ */
+
+void Gsm_Coder P8((S,s,LARc,Nc,bc,Mc,xmaxc,xMc),
+
+	struct gsm_state	* S,
+
+	word	* s,	/* [0..159] samples		  	IN	*/
+
+/*
+ * The RPE-LTD coder works on a frame by frame basis.  The length of
+ * the frame is equal to 160 samples.  Some computations are done
+ * once per frame to produce at the output of the coder the
+ * LARc[1..8] parameters which are the coded LAR coefficients and 
+ * also to realize the inverse filtering operation for the entire
+ * frame (160 samples of signal d[0..159]).  These parts produce at
+ * the output of the coder:
+ */
+
+	word	* LARc,	/* [0..7] LAR coefficients		OUT	*/
+
+/*
+ * Procedure 4.2.11 to 4.2.18 are to be executed four times per
+ * frame.  That means once for each sub-segment RPE-LTP analysis of
+ * 40 samples.  These parts produce at the output of the coder:
+ */
+
+	word	* Nc,	/* [0..3] LTP lag			OUT 	*/
+	word	* bc,	/* [0..3] coded LTP gain		OUT 	*/
+	word	* Mc,	/* [0..3] RPE grid selection		OUT     */
+	word	* xmaxc,/* [0..3] Coded maximum amplitude	OUT	*/
+	word	* xMc	/* [13*4] normalized RPE samples	OUT	*/
+)
+{
+	int	k;
+	word	* dp  = S-&gt;dp0 + 120;	/* [ -120...-1 ] */
+	word	* dpp = dp;		/* [ 0...39 ]	 */
+
+	static word e[50];
+
+	word	so[160];
+
+	Gsm_Preprocess			(S, s, so);
+	Gsm_LPC_Analysis		(S, so, LARc);
+	Gsm_Short_Term_Analysis_Filter	(S, LARc, so);
+
+	for (k = 0; k &lt;= 3; k++, xMc += 13) {
+
+		Gsm_Long_Term_Predictor	( S,
+					 so+k*40, /* d      [0..39] IN	*/
+					 dp,	  /* dp  [-120..-1] IN	*/
+					e + 5,	  /* e      [0..39] OUT	*/
+					dpp,	  /* dpp    [0..39] OUT */
+					 Nc++,
+					 bc++);
+
+		Gsm_RPE_Encoding	( S,
+					e + 5,	/* e	  ][0..39][ IN/OUT */
+					  xmaxc++, Mc++, xMc );
+		/*
+		 * Gsm_Update_of_reconstructed_short_time_residual_signal
+		 *			( dpp, e + 5, dp );
+		 */
+
+		{ register int i;
+		  register longword ltmp;
+		  for (i = 0; i &lt;= 39; i++)
+			dp[ i ] = GSM_ADD( e[5 + i], dpp[i] );
+		}
+		dp  += 40;
+		dpp += 40;
+
+	}
+	(void)memcpy( (char *)S-&gt;dp0, (char *)(S-&gt;dp0 + 160),
+		120 * sizeof(*S-&gt;dp0) );
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include	&quot;config.h&quot;
+
 #ifdef	HAS_STRING_H
 #include	&lt;string.h&gt;
 #else

Modified: trunk/codecs/gsm/src/debug.c
===================================================================
--- trunk/codecs/gsm/src/debug.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/debug.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -74,3 +74,79 @@
 }
 
 #endif
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;private.h&quot;
+
+#ifndef	NDEBUG
+
+/* If NDEBUG _is_ defined and no debugging should be performed,
+ * calls to functions in this module are #defined to nothing
+ * in private.h.
+ */
+
+#include &lt;stdio.h&gt;
+#include &quot;proto.h&quot;
+
+void gsm_debug_words P4( (name, from, to, ptr), 
+	char 	      * name,
+	int		from,
+	int		to,
+	word		* ptr)
+{
+	int 	nprinted = 0;
+
+	fprintf( stderr, &quot;%s [%d .. %d]: &quot;, name, from, to );
+	while (from &lt;= to) {
+		fprintf(stderr, &quot;%d &quot;, ptr[ from ] );
+		from++;
+		if (nprinted++ &gt;= 7) {
+			nprinted = 0;
+			if (from &lt; to) putc('\n', stderr);
+		}
+	}
+	putc('\n', stderr);
+}
+
+void gsm_debug_longwords P4( (name, from, to, ptr),
+	char 	      * name,
+	int		from,
+	int		to,
+	longword      * ptr)
+{
+	int 	nprinted = 0;
+
+	fprintf( stderr, &quot;%s [%d .. %d]: &quot;, name, from, to );
+	while (from &lt;= to) {
+
+		fprintf(stderr, &quot;%d &quot;, ptr[ from ] );
+		from++;
+		if (nprinted++ &gt;= 7) {
+			nprinted = 0;
+			if (from &lt; to) putc('\n', stderr);
+		}
+	}
+	putc('\n', stderr);
+}
+
+void gsm_debug_longword P2(  (name, value),
+	char		* name,
+	longword	  value	)
+{
+	fprintf(stderr, &quot;%s: %d\n&quot;, name, (long)value );
+}
+
+void gsm_debug_word P2(  (name, value),
+	char	* name,
+	word	  value	)
+{
+	fprintf(stderr, &quot;%s: %d\n&quot;, name, (long)value);
+}
+
+#endif

Modified: trunk/codecs/gsm/src/decode.c
===================================================================
--- trunk/codecs/gsm/src/decode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/decode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -22,9 +22,72 @@
 {
 	register int		k;
 	register word		msr = S-&gt;msr;
+	register longword	ltmp;	/* for GSM_ADD */
 	register word		tmp;
 
 	for (k = 160; k--; s++) {
+		tmp = GSM_MULT_R( msr, 28180 );
+		msr = GSM_ADD(*s, tmp);  	   /* Deemphasis 	     */
+		*s  = GSM_ADD(msr, msr) &amp; 0xFFF8;  /* Truncation &amp; Upscaling */
+	}
+	S-&gt;msr = msr;
+}
+
+void Gsm_Decoder P8((S,LARcr, Ncr,bcr,Mcr,xmaxcr,xMcr,s),
+	struct gsm_state	* S,
+
+	word		* LARcr,	/* [0..7]		IN	*/
+
+	word		* Ncr,		/* [0..3] 		IN 	*/
+	word		* bcr,		/* [0..3]		IN	*/
+	word		* Mcr,		/* [0..3] 		IN 	*/
+	word		* xmaxcr,	/* [0..3]		IN 	*/
+	word		* xMcr,		/* [0..13*4]		IN	*/
+
+	word		* s)		/* [0..159]		OUT 	*/
+{
+	int		j, k;
+	word		erp[40], wt[160];
+	word		* drp = S-&gt;dp0 + 120;
+
+	for (j=0; j &lt;= 3; j++, xmaxcr++, bcr++, Ncr++, Mcr++, xMcr += 13) {
+
+		Gsm_RPE_Decoding( S, *xmaxcr, *Mcr, xMcr, erp );
+		Gsm_Long_Term_Synthesis_Filtering( S, *Ncr, *bcr, erp, drp );
+
+		for (k = 0; k &lt;= 39; k++) wt[ j * 40 + k ] =  drp[ k ];
+	}
+
+	Gsm_Short_Term_Synthesis_Filter( S, LARcr, wt, s );
+	Postprocessing(S, s);
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &lt;stdio.h&gt;
+
+#include	&quot;private.h&quot;
+#include	&quot;gsm.h&quot;
+#include	&quot;proto.h&quot;
+
+/*
+ *  4.3 FIXED POINT IMPLEMENTATION OF THE RPE-LTP DECODER
+ */
+
+static void Postprocessing P2((S,s),
+	struct gsm_state	* S,
+	register word 		* s)
+{
+	register int		k;
+	register word		msr = S-&gt;msr;
+	register word		tmp;
+
+	for (k = 160; k--; s++) {
 		tmp = (word)GSM_MULT_R( msr, 28180 );
 		msr = GSM_ADD(*s, tmp);  	   /* Deemphasis 	     */
 		*s  = GSM_ADD(msr, msr) &amp; 0xFFF8;  /* Truncation &amp; Upscaling */

Modified: trunk/codecs/gsm/src/gsm_create.c
===================================================================
--- trunk/codecs/gsm/src/gsm_create.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_create.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -43,3 +43,48 @@
 
 	return r;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+static char const	ident[] = &quot;$Header$&quot;;
+
+#include	&quot;config.h&quot;
+
+#ifdef	HAS_STRING_H
+#include	&lt;string.h&gt;
+#else
+#	include &quot;proto.h&quot;
+	extern char	* memset P((char *, int, int));
+#endif
+
+#ifdef	HAS_STDLIB_H
+#	include	&lt;stdlib.h&gt;
+#else
+#	ifdef	HAS_MALLOC_H
+#		include 	&lt;malloc.h&gt;
+#	else
+		extern char * malloc();
+#	endif
+#endif
+
+#include &lt;stdio.h&gt;
+
+#include &quot;gsm.h&quot;
+#include &quot;private.h&quot;
+#include &quot;proto.h&quot;
+
+gsm gsm_create P0()
+{
+	gsm  r;
+
+	r = (gsm)malloc(sizeof(struct gsm_state));
+	if (!r) return r;
+
+	memset((char *)r, 0, sizeof(*r));
+	r-&gt;nrp = 40;
+
+	return r;
+}

Modified: trunk/codecs/gsm/src/gsm_decode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_decode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_decode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -359,3 +359,364 @@
 
 	return 0;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+int gsm_decode P3((s, c, target), gsm s, gsm_byte * c, gsm_signal * target)
+{
+	word  	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
+
+#ifdef WAV49
+	if (s-&gt;wav_fmt) {
+
+		uword sr = 0;
+
+		s-&gt;frame_index = !s-&gt;frame_index;
+		if (s-&gt;frame_index) {
+
+			sr = *c++;
+			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 5 */
+			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 10 */
+			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 15 */
+			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;			/* 20 */
+			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 25 */
+			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 30 */
+			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+
+			s-&gt;frame_chain = sr &amp; 0xf;
+		}
+		else {
+			sr = s-&gt;frame_chain;
+			sr |= (uword)*c++ &lt;&lt; 4;			/* 1 */
+			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr = *c++;
+			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			sr |= (uword)*c++ &lt;&lt; 3;
+			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 5 */
+			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 10 */
+			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 15 */
+			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 20 */
+			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;	
+			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 25 */
+			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;		
+			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 30 */
+			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+		}
+	}
+	else
+#endif
+	{
+		/* GSM_MAGIC  = (*c &gt;&gt; 4) &amp; 0xF; */
+
+		if (((*c &gt;&gt; 4) &amp; 0x0F) != GSM_MAGIC) return -1;
+
+		LARc[0]  = (*c++ &amp; 0xF) &lt;&lt; 2;		/* 1 */
+		LARc[0] |= (*c &gt;&gt; 6) &amp; 0x3;
+		LARc[1]  = *c++ &amp; 0x3F;
+		LARc[2]  = (*c &gt;&gt; 3) &amp; 0x1F;
+		LARc[3]  = (*c++ &amp; 0x7) &lt;&lt; 2;
+		LARc[3] |= (*c &gt;&gt; 6) &amp; 0x3;
+		LARc[4]  = (*c &gt;&gt; 2) &amp; 0xF;
+		LARc[5]  = (*c++ &amp; 0x3) &lt;&lt; 2;
+		LARc[5] |= (*c &gt;&gt; 6) &amp; 0x3;
+		LARc[6]  = (*c &gt;&gt; 3) &amp; 0x7;
+		LARc[7]  = *c++ &amp; 0x7;
+		Nc[0]  = (*c &gt;&gt; 1) &amp; 0x7F;
+		bc[0]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+		bc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
+		Mc[0]  = (*c &gt;&gt; 5) &amp; 0x3;
+		xmaxc[0]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+		xmaxc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[0]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[1]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[2]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[2] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[3]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[4]  = *c++ &amp; 0x7;
+		xmc[5]  = (*c &gt;&gt; 5) &amp; 0x7;
+		xmc[6]  = (*c &gt;&gt; 2) &amp; 0x7;
+		xmc[7]  = (*c++ &amp; 0x3) &lt;&lt; 1;		/* 10 */
+		xmc[7] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[8]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[9]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[10]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[10] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[11]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[12]  = *c++ &amp; 0x7;
+		Nc[1]  = (*c &gt;&gt; 1) &amp; 0x7F;
+		bc[1]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+		bc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
+		Mc[1]  = (*c &gt;&gt; 5) &amp; 0x3;
+		xmaxc[1]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+		xmaxc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[13]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[14]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[15]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[15] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[16]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[17]  = *c++ &amp; 0x7;
+		xmc[18]  = (*c &gt;&gt; 5) &amp; 0x7;
+		xmc[19]  = (*c &gt;&gt; 2) &amp; 0x7;
+		xmc[20]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+		xmc[20] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[21]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[22]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[23]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[23] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[24]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[25]  = *c++ &amp; 0x7;
+		Nc[2]  = (*c &gt;&gt; 1) &amp; 0x7F;
+		bc[2]  = (*c++ &amp; 0x1) &lt;&lt; 1;		/* 20 */
+		bc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
+		Mc[2]  = (*c &gt;&gt; 5) &amp; 0x3;
+		xmaxc[2]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+		xmaxc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[26]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[27]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[28]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[28] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[29]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[30]  = *c++ &amp; 0x7;
+		xmc[31]  = (*c &gt;&gt; 5) &amp; 0x7;
+		xmc[32]  = (*c &gt;&gt; 2) &amp; 0x7;
+		xmc[33]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+		xmc[33] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[34]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[35]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[36]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[36] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[37]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[38]  = *c++ &amp; 0x7;
+		Nc[3]  = (*c &gt;&gt; 1) &amp; 0x7F;
+		bc[3]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+		bc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
+		Mc[3]  = (*c &gt;&gt; 5) &amp; 0x3;
+		xmaxc[3]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+		xmaxc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[39]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[40]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[41]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[41] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[42]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[43]  = *c++ &amp; 0x7;			/* 30  */
+		xmc[44]  = (*c &gt;&gt; 5) &amp; 0x7;
+		xmc[45]  = (*c &gt;&gt; 2) &amp; 0x7;
+		xmc[46]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+		xmc[46] |= (*c &gt;&gt; 7) &amp; 0x1;
+		xmc[47]  = (*c &gt;&gt; 4) &amp; 0x7;
+		xmc[48]  = (*c &gt;&gt; 1) &amp; 0x7;
+		xmc[49]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+		xmc[49] |= (*c &gt;&gt; 6) &amp; 0x3;
+		xmc[50]  = (*c &gt;&gt; 3) &amp; 0x7;
+		xmc[51]  = *c &amp; 0x7;			/* 33 */
+	}
+
+	Gsm_Decoder(s, LARc, Nc, bc, Mc, xmaxc, xmc, target);
+
+	return 0;
+}

Modified: trunk/codecs/gsm/src/gsm_destroy.c
===================================================================
--- trunk/codecs/gsm/src/gsm_destroy.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_destroy.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -24,3 +24,29 @@
 {
 	if (S) free((char *)S);
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;gsm.h&quot;
+#include &quot;config.h&quot;
+#include &quot;proto.h&quot;
+
+#ifdef	HAS_STDLIB_H
+#	include	&lt;stdlib.h&gt;
+#else
+#	ifdef	HAS_MALLOC_H
+#		include 	&lt;malloc.h&gt;
+#	else
+		extern void free();
+#	endif
+#endif
+
+void gsm_destroy P1((S), gsm S)
+{
+	if (S) free((char *)S);
+}

Modified: trunk/codecs/gsm/src/gsm_encode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_encode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_encode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -449,3 +449,454 @@
 
 	}
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;private.h&quot;
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+void gsm_encode P3((s, source, c), gsm s, gsm_signal * source, gsm_byte * c)
+{
+	word	 	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
+
+	Gsm_Coder(s, source, LARc, Nc, bc, Mc, xmaxc, xmc);
+
+
+	/*	variable	size
+
+		GSM_MAGIC	4
+
+		LARc[0]		6
+		LARc[1]		6
+		LARc[2]		5
+		LARc[3]		5
+		LARc[4]		4
+		LARc[5]		4
+		LARc[6]		3
+		LARc[7]		3
+
+		Nc[0]		7
+		bc[0]		2
+		Mc[0]		2
+		xmaxc[0]	6
+		xmc[0]		3
+		xmc[1]		3
+		xmc[2]		3
+		xmc[3]		3
+		xmc[4]		3
+		xmc[5]		3
+		xmc[6]		3
+		xmc[7]		3
+		xmc[8]		3
+		xmc[9]		3
+		xmc[10]		3
+		xmc[11]		3
+		xmc[12]		3
+
+		Nc[1]		7
+		bc[1]		2
+		Mc[1]		2
+		xmaxc[1]	6
+		xmc[13]		3
+		xmc[14]		3
+		xmc[15]		3
+		xmc[16]		3
+		xmc[17]		3
+		xmc[18]		3
+		xmc[19]		3
+		xmc[20]		3
+		xmc[21]		3
+		xmc[22]		3
+		xmc[23]		3
+		xmc[24]		3
+		xmc[25]		3
+
+		Nc[2]		7
+		bc[2]		2
+		Mc[2]		2
+		xmaxc[2]	6
+		xmc[26]		3
+		xmc[27]		3
+		xmc[28]		3
+		xmc[29]		3
+		xmc[30]		3
+		xmc[31]		3
+		xmc[32]		3
+		xmc[33]		3
+		xmc[34]		3
+		xmc[35]		3
+		xmc[36]		3
+		xmc[37]		3
+		xmc[38]		3
+
+		Nc[3]		7
+		bc[3]		2
+		Mc[3]		2
+		xmaxc[3]	6
+		xmc[39]		3
+		xmc[40]		3
+		xmc[41]		3
+		xmc[42]		3
+		xmc[43]		3
+		xmc[44]		3
+		xmc[45]		3
+		xmc[46]		3
+		xmc[47]		3
+		xmc[48]		3
+		xmc[49]		3
+		xmc[50]		3
+		xmc[51]		3
+	*/
+
+#ifdef WAV49
+
+	if (s-&gt;wav_fmt) {
+		s-&gt;frame_index = !s-&gt;frame_index;
+		if (s-&gt;frame_index) {
+
+			uword sr;
+
+			sr = 0;
+			sr = sr &gt;&gt; 6 | LARc[0] &lt;&lt; 10;
+			sr = sr &gt;&gt; 6 | LARc[1] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 4;
+			sr = sr &gt;&gt; 5 | LARc[2] &lt;&lt; 11;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 5 | LARc[3] &lt;&lt; 11;
+			sr = sr &gt;&gt; 4 | LARc[4] &lt;&lt; 12;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 4 | LARc[5] &lt;&lt; 12;
+			sr = sr &gt;&gt; 3 | LARc[6] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | LARc[7] &lt;&lt; 13;
+			sr = sr &gt;&gt; 7 | Nc[0] &lt;&lt; 9;
+			*c++ = sr &gt;&gt; 5;
+			sr = sr &gt;&gt; 2 | bc[0] &lt;&lt; 14;
+			sr = sr &gt;&gt; 2 | Mc[0] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[0] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 3;
+			sr = sr &gt;&gt; 3 | xmc[0] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[1] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[2] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[3] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[4] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[5] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[6] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[7] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[8] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[9] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[10] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[11] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[12] &lt;&lt; 13;
+			sr = sr &gt;&gt; 7 | Nc[1] &lt;&lt; 9;
+			*c++ = sr &gt;&gt; 5;
+			sr = sr &gt;&gt; 2 | bc[1] &lt;&lt; 14;
+			sr = sr &gt;&gt; 2 | Mc[1] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[1] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 3;
+			sr = sr &gt;&gt; 3 | xmc[13] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[14] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[15] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[16] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[17] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[18] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[19] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[20] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[21] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[22] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[23] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[24] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[25] &lt;&lt; 13;
+			sr = sr &gt;&gt; 7 | Nc[2] &lt;&lt; 9;
+			*c++ = sr &gt;&gt; 5;
+			sr = sr &gt;&gt; 2 | bc[2] &lt;&lt; 14;
+			sr = sr &gt;&gt; 2 | Mc[2] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[2] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 3;
+			sr = sr &gt;&gt; 3 | xmc[26] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[27] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[28] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[29] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[30] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[31] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[32] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[33] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[34] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[35] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[36] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[37] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[38] &lt;&lt; 13;
+			sr = sr &gt;&gt; 7 | Nc[3] &lt;&lt; 9;
+			*c++ = sr &gt;&gt; 5;
+			sr = sr &gt;&gt; 2 | bc[3] &lt;&lt; 14;
+			sr = sr &gt;&gt; 2 | Mc[3] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[3] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 3;
+			sr = sr &gt;&gt; 3 | xmc[39] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[40] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[41] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[42] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[43] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[44] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[45] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[46] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[47] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[48] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[49] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[50] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[51] &lt;&lt; 13;
+			sr = sr &gt;&gt; 4;
+			*c = sr &gt;&gt; 8;
+			s-&gt;frame_chain = *c;
+		}
+		else {
+			uword sr;
+
+			sr = 0;
+			sr = sr &gt;&gt; 4 | s-&gt;frame_chain &lt;&lt; 12;
+			sr = sr &gt;&gt; 6 | LARc[0] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 6 | LARc[1] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 5 | LARc[2] &lt;&lt; 11;
+			sr = sr &gt;&gt; 5 | LARc[3] &lt;&lt; 11;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 4 | LARc[4] &lt;&lt; 12;
+			sr = sr &gt;&gt; 4 | LARc[5] &lt;&lt; 12;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | LARc[6] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | LARc[7] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 7 | Nc[0] &lt;&lt; 9;
+			sr = sr &gt;&gt; 2 | bc[0] &lt;&lt; 14;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 2 | Mc[0] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[0] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[0] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[1] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[2] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[3] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[4] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[5] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[6] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[7] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[8] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[9] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[10] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[11] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[12] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 7 | Nc[1] &lt;&lt; 9;
+			sr = sr &gt;&gt; 2 | bc[1] &lt;&lt; 14;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 2 | Mc[1] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[1] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[13] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[14] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[15] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[16] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[17] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[18] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[19] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[20] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[21] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[22] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[23] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[24] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[25] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 7 | Nc[2] &lt;&lt; 9;
+			sr = sr &gt;&gt; 2 | bc[2] &lt;&lt; 14;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 2 | Mc[2] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[2] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[26] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[27] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[28] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[29] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[30] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[31] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[32] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[33] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[34] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[35] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[36] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[37] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[38] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 7 | Nc[3] &lt;&lt; 9;
+			sr = sr &gt;&gt; 2 | bc[3] &lt;&lt; 14;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 2 | Mc[3] &lt;&lt; 14;
+			sr = sr &gt;&gt; 6 | xmaxc[3] &lt;&lt; 10;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[39] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[40] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[41] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[42] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[43] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+			sr = sr &gt;&gt; 3 | xmc[44] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[45] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[46] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 7;
+			sr = sr &gt;&gt; 3 | xmc[47] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[48] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[49] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 6;
+			sr = sr &gt;&gt; 3 | xmc[50] &lt;&lt; 13;
+			sr = sr &gt;&gt; 3 | xmc[51] &lt;&lt; 13;
+			*c++ = sr &gt;&gt; 8;
+		}
+	}
+
+	else
+
+#endif	/* WAV49 */
+	{
+
+		*c++ =   ((GSM_MAGIC &amp; 0xF) &lt;&lt; 4)		/* 1 */
+		       | ((LARc[0] &gt;&gt; 2) &amp; 0xF);
+		*c++ =   ((LARc[0] &amp; 0x3) &lt;&lt; 6)
+		       | (LARc[1] &amp; 0x3F);
+		*c++ =   ((LARc[2] &amp; 0x1F) &lt;&lt; 3)
+		       | ((LARc[3] &gt;&gt; 2) &amp; 0x7);
+		*c++ =   ((LARc[3] &amp; 0x3) &lt;&lt; 6)
+		       | ((LARc[4] &amp; 0xF) &lt;&lt; 2)
+		       | ((LARc[5] &gt;&gt; 2) &amp; 0x3);
+		*c++ =   ((LARc[5] &amp; 0x3) &lt;&lt; 6)
+		       | ((LARc[6] &amp; 0x7) &lt;&lt; 3)
+		       | (LARc[7] &amp; 0x7);
+		*c++ =   ((Nc[0] &amp; 0x7F) &lt;&lt; 1)
+		       | ((bc[0] &gt;&gt; 1) &amp; 0x1);
+		*c++ =   ((bc[0] &amp; 0x1) &lt;&lt; 7)
+		       | ((Mc[0] &amp; 0x3) &lt;&lt; 5)
+		       | ((xmaxc[0] &gt;&gt; 1) &amp; 0x1F);
+		*c++ =   ((xmaxc[0] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[0] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[1] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[2] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[2] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[3] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[4] &amp; 0x7);
+		*c++ =   ((xmc[5] &amp; 0x7) &lt;&lt; 5)			/* 10 */
+		       | ((xmc[6] &amp; 0x7) &lt;&lt; 2)
+		       | ((xmc[7] &gt;&gt; 1) &amp; 0x3);
+		*c++ =   ((xmc[7] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[8] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[9] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[10] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[10] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[11] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[12] &amp; 0x7);
+		*c++ =   ((Nc[1] &amp; 0x7F) &lt;&lt; 1)
+		       | ((bc[1] &gt;&gt; 1) &amp; 0x1);
+		*c++ =   ((bc[1] &amp; 0x1) &lt;&lt; 7)
+		       | ((Mc[1] &amp; 0x3) &lt;&lt; 5)
+		       | ((xmaxc[1] &gt;&gt; 1) &amp; 0x1F);
+		*c++ =   ((xmaxc[1] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[13] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[14] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[15] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[15] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[16] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[17] &amp; 0x7);
+		*c++ =   ((xmc[18] &amp; 0x7) &lt;&lt; 5)
+		       | ((xmc[19] &amp; 0x7) &lt;&lt; 2)
+		       | ((xmc[20] &gt;&gt; 1) &amp; 0x3);
+		*c++ =   ((xmc[20] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[21] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[22] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[23] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[23] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[24] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[25] &amp; 0x7);
+		*c++ =   ((Nc[2] &amp; 0x7F) &lt;&lt; 1)			/* 20 */
+		       | ((bc[2] &gt;&gt; 1) &amp; 0x1);
+		*c++ =   ((bc[2] &amp; 0x1) &lt;&lt; 7)
+		       | ((Mc[2] &amp; 0x3) &lt;&lt; 5)
+		       | ((xmaxc[2] &gt;&gt; 1) &amp; 0x1F);
+		*c++ =   ((xmaxc[2] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[26] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[27] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[28] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[28] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[29] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[30] &amp; 0x7);
+		*c++ =   ((xmc[31] &amp; 0x7) &lt;&lt; 5)
+		       | ((xmc[32] &amp; 0x7) &lt;&lt; 2)
+		       | ((xmc[33] &gt;&gt; 1) &amp; 0x3);
+		*c++ =   ((xmc[33] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[34] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[35] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[36] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[36] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[37] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[38] &amp; 0x7);
+		*c++ =   ((Nc[3] &amp; 0x7F) &lt;&lt; 1)
+		       | ((bc[3] &gt;&gt; 1) &amp; 0x1);
+		*c++ =   ((bc[3] &amp; 0x1) &lt;&lt; 7)
+		       | ((Mc[3] &amp; 0x3) &lt;&lt; 5)
+		       | ((xmaxc[3] &gt;&gt; 1) &amp; 0x1F);
+		*c++ =   ((xmaxc[3] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[39] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[40] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[41] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[41] &amp; 0x3) &lt;&lt; 6)			/* 30 */
+		       | ((xmc[42] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[43] &amp; 0x7);
+		*c++ =   ((xmc[44] &amp; 0x7) &lt;&lt; 5)
+		       | ((xmc[45] &amp; 0x7) &lt;&lt; 2)
+		       | ((xmc[46] &gt;&gt; 1) &amp; 0x3);
+		*c++ =   ((xmc[46] &amp; 0x1) &lt;&lt; 7)
+		       | ((xmc[47] &amp; 0x7) &lt;&lt; 4)
+		       | ((xmc[48] &amp; 0x7) &lt;&lt; 1)
+		       | ((xmc[49] &gt;&gt; 2) &amp; 0x1);
+		*c++ =   ((xmc[49] &amp; 0x3) &lt;&lt; 6)
+		       | ((xmc[50] &amp; 0x7) &lt;&lt; 3)
+		       | (xmc[51] &amp; 0x7);
+
+	}
+}

Modified: trunk/codecs/gsm/src/gsm_explode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_explode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_explode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -415,3 +415,420 @@
 
 	return 0;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;private.h&quot;
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+int gsm_explode P3((s, c, target), gsm s, gsm_byte * c, gsm_signal * target)
+{
+#	define	LARc	target
+#	define	Nc	*((gsm_signal (*) [17])(target + 8))
+#	define	bc	*((gsm_signal (*) [17])(target + 9))
+#	define	Mc	*((gsm_signal (*) [17])(target + 10))
+#	define	xmaxc	*((gsm_signal (*) [17])(target + 11))
+
+
+#ifdef WAV49
+	if (s-&gt;wav_fmt) {
+
+		uword sr = 0;
+
+		if (s-&gt;frame_index == 1) {
+
+			sr = *c++;
+			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 5 */
+			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(target + 12)
+			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 10 */
+			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(target + 29 - 13)
+
+			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 15 */
+			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;			/* 20 */
+			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+
+#undef	xmc
+#define	xmc	(target + 46 - 26)
+
+			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 25 */
+			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(target + 63 - 39)
+
+			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 30 */
+			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+
+			s-&gt;frame_chain = sr &amp; 0xf;
+		}
+		else {
+			sr = s-&gt;frame_chain;
+			sr |= (uword)*c++ &lt;&lt; 4;			/* 1 */
+			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr = *c++;
+			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			sr |= (uword)*c++ &lt;&lt; 3;
+			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 5 */
+			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(target + 12)
+			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 10 */
+			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(target + 29 - 13)
+
+			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 15 */
+			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 20 */
+			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(target + 46 - 26)
+			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;	
+			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 25 */
+			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;		
+			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+
+#undef	xmc
+#define	xmc	(target + 63 - 39)
+
+			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 30 */
+			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+		}
+	}
+	else 
+#endif
+	{
+	/* GSM_MAGIC  = (*c &gt;&gt; 4) &amp; 0xF; */
+
+	if (((*c &gt;&gt; 4) &amp; 0x0F) != GSM_MAGIC) return -1;
+
+	LARc[0]  = (*c++ &amp; 0xF) &lt;&lt; 2;		/* 1 */
+	LARc[0] |= (*c &gt;&gt; 6) &amp; 0x3;
+	LARc[1]  = *c++ &amp; 0x3F;
+	LARc[2]  = (*c &gt;&gt; 3) &amp; 0x1F;
+	LARc[3]  = (*c++ &amp; 0x7) &lt;&lt; 2;
+	LARc[3] |= (*c &gt;&gt; 6) &amp; 0x3;
+	LARc[4]  = (*c &gt;&gt; 2) &amp; 0xF;
+	LARc[5]  = (*c++ &amp; 0x3) &lt;&lt; 2;
+	LARc[5] |= (*c &gt;&gt; 6) &amp; 0x3;
+	LARc[6]  = (*c &gt;&gt; 3) &amp; 0x7;
+	LARc[7]  = *c++ &amp; 0x7;
+
+	Nc[0]  = (*c &gt;&gt; 1) &amp; 0x7F;
+
+	bc[0]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+	bc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+	Mc[0]  = (*c &gt;&gt; 5) &amp; 0x3;
+
+	xmaxc[0]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+#undef	xmc
+#define	xmc	(target + 12)
+
+	xmc[0]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[1]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[2]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[2] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[3]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[4]  = *c++ &amp; 0x7;
+	xmc[5]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[6]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[7]  = (*c++ &amp; 0x3) &lt;&lt; 1;		/* 10 */
+	xmc[7] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[8]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[9]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[10]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[10] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[11]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[12]  = *c++ &amp; 0x7;
+
+	Nc[1]  = (*c &gt;&gt; 1) &amp; 0x7F;
+
+	bc[1]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+	bc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+	Mc[1]  = (*c &gt;&gt; 5) &amp; 0x3;
+
+	xmaxc[1]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+#undef	xmc
+#define	xmc	(target + 29 - 13)
+
+	xmc[13]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[14]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[15]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[15] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[16]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[17]  = *c++ &amp; 0x7;
+	xmc[18]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[19]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[20]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+	xmc[20] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[21]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[22]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[23]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[23] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[24]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[25]  = *c++ &amp; 0x7;
+
+	Nc[2]  = (*c &gt;&gt; 1) &amp; 0x7F;
+
+	bc[2]  = (*c++ &amp; 0x1) &lt;&lt; 1;		/* 20 */
+	bc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+	Mc[2]  = (*c &gt;&gt; 5) &amp; 0x3;
+
+	xmaxc[2]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+#undef	xmc
+#define	xmc	(target + 46 - 26)
+
+	xmc[26]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[27]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[28]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[28] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[29]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[30]  = *c++ &amp; 0x7;
+	xmc[31]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[32]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[33]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+	xmc[33] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[34]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[35]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[36]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[36] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[37]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[38]  = *c++ &amp; 0x7;
+
+	Nc[3]  = (*c &gt;&gt; 1) &amp; 0x7F;
+
+	bc[3]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+	bc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+	Mc[3]  = (*c &gt;&gt; 5) &amp; 0x3;
+
+	xmaxc[3]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+#undef	xmc
+#define	xmc	(target + 63 - 39)
+
+	xmc[39]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[40]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[41]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[41] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[42]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[43]  = *c++ &amp; 0x7;			/* 30  */
+	xmc[44]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[45]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[46]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+	xmc[46] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[47]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[48]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[49]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[49] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[50]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[51]  = *c &amp; 0x7;			/* 33 */
+	}
+
+	return 0;
+}

Modified: trunk/codecs/gsm/src/gsm_implode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_implode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_implode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -513,3 +513,518 @@
 	       | (xmc[51] &amp; 0x7);
 	}
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+void gsm_implode P3((s, source, c), gsm s, gsm_signal * source, gsm_byte * c)
+{
+	/*	variable	size	index
+
+		GSM_MAGIC	4	-
+
+		LARc[0]		6	0
+		LARc[1]		6	1
+		LARc[2]		5	2
+		LARc[3]		5	3
+		LARc[4]		4	4
+		LARc[5]		4	5
+		LARc[6]		3	6
+		LARc[7]		3	7
+
+		Nc[0]		7	8
+		bc[0]		2	9
+		Mc[0]		2	10
+		xmaxc[0]	6	11
+		xmc[0]		3	12
+		xmc[1]		3	13
+		xmc[2]		3	14
+		xmc[3]		3	15
+		xmc[4]		3	16
+		xmc[5]		3	17
+		xmc[6]		3	18
+		xmc[7]		3	19
+		xmc[8]		3	20
+		xmc[9]		3	21
+		xmc[10]		3	22
+		xmc[11]		3	23
+		xmc[12]		3	24
+
+		Nc[1]		7	25
+		bc[1]		2	26
+		Mc[1]		2	27
+		xmaxc[1]	6	28
+		xmc[13]		3	29
+		xmc[14]		3	30
+		xmc[15]		3	31
+		xmc[16]		3	32
+		xmc[17]		3	33
+		xmc[18]		3	34
+		xmc[19]		3	35
+		xmc[20]		3	36
+		xmc[21]		3	37
+		xmc[22]		3	38
+		xmc[23]		3	39
+		xmc[24]		3	40
+		xmc[25]		3	41
+
+		Nc[2]		7	42
+		bc[2]		2	43
+		Mc[2]		2	44
+		xmaxc[2]	6	45
+		xmc[26]		3	46
+		xmc[27]		3	47
+		xmc[28]		3	48
+		xmc[29]		3	49
+		xmc[30]		3	50
+		xmc[31]		3	51
+		xmc[32]		3	52
+		xmc[33]		3	53
+		xmc[34]		3	54
+		xmc[35]		3	55
+		xmc[36]		3	56
+		xmc[37]		3	57
+		xmc[38]		3	58
+
+		Nc[3]		7	59
+		bc[3]		2	60
+		Mc[3]		2	61
+		xmaxc[3]	6	62
+		xmc[39]		3	63
+		xmc[40]		3	64
+		xmc[41]		3	65
+		xmc[42]		3	66
+		xmc[43]		3	67
+		xmc[44]		3	68
+		xmc[45]		3	69
+		xmc[46]		3	70
+		xmc[47]		3	71
+		xmc[48]		3	72
+		xmc[49]		3	73
+		xmc[50]		3	74
+		xmc[51]		3	75
+	*/
+
+	/*	There are 76 parameters per frame.  The first eight are
+	 * 	unique.  The remaining 68 are four identical subframes of
+	 * 	17 parameters each.  gsm_implode converts from a representation
+	 * 	of these parameters as values in one array of signed words
+	 * 	to the &quot;packed&quot; version of a GSM frame.
+	 */
+
+#	define	LARc	source
+#	define	Nc	*((gsm_signal (*) [17])(source + 8))
+#	define	bc	*((gsm_signal (*) [17])(source + 9))
+#	define	Mc	*((gsm_signal (*) [17])(source + 10))
+#	define	xmaxc	*((gsm_signal (*) [17])(source + 11))
+
+#ifdef WAV49
+	if (s-&gt;wav_fmt) {
+
+		uword sr = 0;
+		if (s-&gt;frame_index == 0) {
+
+			sr = *c++;
+			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 5 */
+			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 12)
+			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 10 */
+			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 29 - 13)
+			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 15 */
+			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;			/* 20 */
+			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 46 - 26)
+			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 25 */
+			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 4;
+			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 63 - 39)
+
+			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 30 */
+			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+
+			s-&gt;frame_chain = sr &amp; 0xf;
+		}
+		else {
+			sr = s-&gt;frame_chain;
+			sr |= (uword)*c++ &lt;&lt; 4;			/* 1 */
+			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+			sr = *c++;
+			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			sr |= (uword)*c++ &lt;&lt; 3;
+			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
+			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
+			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 5 */
+			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 12)
+			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;			/* 10 */
+			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 29 - 13)
+			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 15 */
+			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 20 */
+			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 46 - 26)
+			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;	
+			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;			/* 25 */
+			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;
+			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
+			sr |= (uword)*c++ &lt;&lt; 1;		
+			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
+			sr |= (uword)*c++ &lt;&lt; 5;
+			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
+#undef	xmc
+#define	xmc	(source + 63 - 39)
+
+			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr = *c++;				/* 30 */
+			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 2;
+			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			sr |= (uword)*c++ &lt;&lt; 1;
+			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
+		}
+	}
+	else
+#endif 
+	{
+
+	*c++ =   ((GSM_MAGIC &amp; 0xF) &lt;&lt; 4)		/* 1 */
+	       | ((LARc[0] &gt;&gt; 2) &amp; 0xF);
+	*c++ =   ((LARc[0] &amp; 0x3) &lt;&lt; 6)
+	       | (LARc[1] &amp; 0x3F);
+	*c++ =   ((LARc[2] &amp; 0x1F) &lt;&lt; 3)
+	       | ((LARc[3] &gt;&gt; 2) &amp; 0x7);
+	*c++ =   ((LARc[3] &amp; 0x3) &lt;&lt; 6)
+	       | ((LARc[4] &amp; 0xF) &lt;&lt; 2)
+	       | ((LARc[5] &gt;&gt; 2) &amp; 0x3);
+	*c++ =   ((LARc[5] &amp; 0x3) &lt;&lt; 6)
+	       | ((LARc[6] &amp; 0x7) &lt;&lt; 3)
+	       | (LARc[7] &amp; 0x7);
+
+
+	*c++ =   ((Nc[0] &amp; 0x7F) &lt;&lt; 1)
+
+
+	       | ((bc[0] &gt;&gt; 1) &amp; 0x1);
+	*c++ =   ((bc[0] &amp; 0x1) &lt;&lt; 7)
+
+
+	       | ((Mc[0] &amp; 0x3) &lt;&lt; 5)
+
+	       | ((xmaxc[0] &gt;&gt; 1) &amp; 0x1F);
+	*c++ =   ((xmaxc[0] &amp; 0x1) &lt;&lt; 7)
+
+#undef xmc
+#define	xmc	(source + 12)
+
+	       | ((xmc[0] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[1] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[2] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[2] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[3] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[4] &amp; 0x7);
+	*c++ =   ((xmc[5] &amp; 0x7) &lt;&lt; 5)			/* 10 */
+	       | ((xmc[6] &amp; 0x7) &lt;&lt; 2)
+	       | ((xmc[7] &gt;&gt; 1) &amp; 0x3);
+	*c++ =   ((xmc[7] &amp; 0x1) &lt;&lt; 7)
+	       | ((xmc[8] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[9] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[10] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[10] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[11] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[12] &amp; 0x7);
+
+
+	*c++ =   ((Nc[1] &amp; 0x7F) &lt;&lt; 1)
+
+
+	       | ((bc[1] &gt;&gt; 1) &amp; 0x1);
+	*c++ =   ((bc[1] &amp; 0x1) &lt;&lt; 7)
+
+
+	       | ((Mc[1] &amp; 0x3) &lt;&lt; 5)
+
+
+	       | ((xmaxc[1] &gt;&gt; 1) &amp; 0x1F);
+	*c++ =   ((xmaxc[1] &amp; 0x1) &lt;&lt; 7)
+
+#undef	xmc
+#define	xmc	(source + 29 - 13)
+
+	       | ((xmc[13] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[14] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[15] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[15] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[16] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[17] &amp; 0x7);
+	*c++ =   ((xmc[18] &amp; 0x7) &lt;&lt; 5)
+	       | ((xmc[19] &amp; 0x7) &lt;&lt; 2)
+	       | ((xmc[20] &gt;&gt; 1) &amp; 0x3);
+	*c++ =   ((xmc[20] &amp; 0x1) &lt;&lt; 7)
+	       | ((xmc[21] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[22] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[23] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[23] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[24] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[25] &amp; 0x7);
+
+
+	*c++ =   ((Nc[2] &amp; 0x7F) &lt;&lt; 1)			/* 20 */
+
+
+	       | ((bc[2] &gt;&gt; 1) &amp; 0x1);
+	*c++ =   ((bc[2] &amp; 0x1) &lt;&lt; 7)
+
+
+	       | ((Mc[2] &amp; 0x3) &lt;&lt; 5)
+
+
+	       | ((xmaxc[2] &gt;&gt; 1) &amp; 0x1F);
+	*c++ =   ((xmaxc[2] &amp; 0x1) &lt;&lt; 7)
+
+#undef	xmc
+#define	xmc	(source + 46 - 26)
+
+	       | ((xmc[26] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[27] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[28] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[28] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[29] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[30] &amp; 0x7);
+	*c++ =   ((xmc[31] &amp; 0x7) &lt;&lt; 5)
+	       | ((xmc[32] &amp; 0x7) &lt;&lt; 2)
+	       | ((xmc[33] &gt;&gt; 1) &amp; 0x3);
+	*c++ =   ((xmc[33] &amp; 0x1) &lt;&lt; 7)
+	       | ((xmc[34] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[35] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[36] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[36] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[37] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[38] &amp; 0x7);
+
+
+	*c++ =   ((Nc[3] &amp; 0x7F) &lt;&lt; 1)
+
+
+	       | ((bc[3] &gt;&gt; 1) &amp; 0x1);
+	*c++ =   ((bc[3] &amp; 0x1) &lt;&lt; 7)
+
+
+	       | ((Mc[3] &amp; 0x3) &lt;&lt; 5)
+
+
+	       | ((xmaxc[3] &gt;&gt; 1) &amp; 0x1F);
+	*c++ =   ((xmaxc[3] &amp; 0x1) &lt;&lt; 7)
+
+#undef	xmc
+#define	xmc	(source + 63 - 39)
+
+	       | ((xmc[39] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[40] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[41] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[41] &amp; 0x3) &lt;&lt; 6)			/* 30 */
+	       | ((xmc[42] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[43] &amp; 0x7);
+	*c++ =   ((xmc[44] &amp; 0x7) &lt;&lt; 5)
+	       | ((xmc[45] &amp; 0x7) &lt;&lt; 2)
+	       | ((xmc[46] &gt;&gt; 1) &amp; 0x3);
+	*c++ =   ((xmc[46] &amp; 0x1) &lt;&lt; 7)
+	       | ((xmc[47] &amp; 0x7) &lt;&lt; 4)
+	       | ((xmc[48] &amp; 0x7) &lt;&lt; 1)
+	       | ((xmc[49] &gt;&gt; 2) &amp; 0x1);
+	*c++ =   ((xmc[49] &amp; 0x3) &lt;&lt; 6)
+	       | ((xmc[50] &amp; 0x7) &lt;&lt; 3)
+	       | (xmc[51] &amp; 0x7);
+	}
+}

Modified: trunk/codecs/gsm/src/gsm_option.c
===================================================================
--- trunk/codecs/gsm/src/gsm_option.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_option.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -67,3 +67,72 @@
 	}
 	return result;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+int gsm_option P3((r, opt, val), gsm r, int opt, int * val)
+{
+	int 	result = -1;
+
+	switch (opt) {
+	case GSM_OPT_LTP_CUT:
+#ifdef 	LTP_CUT
+		result = r-&gt;ltp_cut;
+		if (val) r-&gt;ltp_cut = *val;
+#endif
+		break;
+
+	case GSM_OPT_VERBOSE:
+#ifndef	NDEBUG
+		result = r-&gt;verbose;
+		if (val) r-&gt;verbose = *val;
+#endif
+		break;
+
+	case GSM_OPT_FAST:
+
+#if	defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
+		result = r-&gt;fast;
+		if (val) r-&gt;fast = !!*val;
+#endif
+		break;
+
+	case GSM_OPT_FRAME_CHAIN:
+
+#ifdef WAV49
+		result = r-&gt;frame_chain;
+		if (val) r-&gt;frame_chain = *val;
+#endif
+		break;
+
+	case GSM_OPT_FRAME_INDEX:
+
+#ifdef WAV49
+		result = r-&gt;frame_index;
+		if (val) r-&gt;frame_index = *val;
+#endif
+		break;
+
+	case GSM_OPT_WAV49:
+
+#ifdef WAV49 
+		result = r-&gt;wav_fmt;
+		if (val) r-&gt;wav_fmt = !!*val;
+#endif
+		break;
+
+	default:
+		break;
+	}
+	return result;
+}

Modified: trunk/codecs/gsm/src/gsm_print.c
===================================================================
--- trunk/codecs/gsm/src/gsm_print.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_print.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -165,3 +165,170 @@
 
 	return 0;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include	&lt;stdio.h&gt;
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+int gsm_print P3((f, s, c), FILE * f, gsm s, gsm_byte * c)
+{
+	word  	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
+
+	/* GSM_MAGIC  = (*c &gt;&gt; 4) &amp; 0xF; */
+
+	if (((*c &gt;&gt; 4) &amp; 0x0F) != GSM_MAGIC) return -1;
+
+	LARc[0]  = (*c++ &amp; 0xF) &lt;&lt; 2;		/* 1 */
+	LARc[0] |= (*c &gt;&gt; 6) &amp; 0x3;
+	LARc[1]  = *c++ &amp; 0x3F;
+	LARc[2]  = (*c &gt;&gt; 3) &amp; 0x1F;
+	LARc[3]  = (*c++ &amp; 0x7) &lt;&lt; 2;
+	LARc[3] |= (*c &gt;&gt; 6) &amp; 0x3;
+	LARc[4]  = (*c &gt;&gt; 2) &amp; 0xF;
+	LARc[5]  = (*c++ &amp; 0x3) &lt;&lt; 2;
+	LARc[5] |= (*c &gt;&gt; 6) &amp; 0x3;
+	LARc[6]  = (*c &gt;&gt; 3) &amp; 0x7;
+	LARc[7]  = *c++ &amp; 0x7;
+
+
+	Nc[0]  = (*c &gt;&gt; 1) &amp; 0x7F;
+	bc[0]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+	bc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
+	Mc[0]  = (*c &gt;&gt; 5) &amp; 0x3;
+	xmaxc[0]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[0]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[1]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[2]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[2] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[3]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[4]  = *c++ &amp; 0x7;
+	xmc[5]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[6]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[7]  = (*c++ &amp; 0x3) &lt;&lt; 1;		/* 10 */
+	xmc[7] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[8]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[9]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[10]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[10] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[11]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[12]  = *c++ &amp; 0x7;
+
+	Nc[1]  = (*c &gt;&gt; 1) &amp; 0x7F;
+	bc[1]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+	bc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
+	Mc[1]  = (*c &gt;&gt; 5) &amp; 0x3;
+	xmaxc[1]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[13]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[14]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[15]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[15] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[16]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[17]  = *c++ &amp; 0x7;
+	xmc[18]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[19]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[20]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+	xmc[20] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[21]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[22]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[23]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[23] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[24]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[25]  = *c++ &amp; 0x7;
+
+
+	Nc[2]  = (*c &gt;&gt; 1) &amp; 0x7F;
+	bc[2]  = (*c++ &amp; 0x1) &lt;&lt; 1;		/* 20 */
+	bc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
+	Mc[2]  = (*c &gt;&gt; 5) &amp; 0x3;
+	xmaxc[2]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[26]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[27]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[28]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[28] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[29]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[30]  = *c++ &amp; 0x7;
+	xmc[31]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[32]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[33]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+	xmc[33] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[34]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[35]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[36]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[36] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[37]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[38]  = *c++ &amp; 0x7;
+
+	Nc[3]  = (*c &gt;&gt; 1) &amp; 0x7F;
+	bc[3]  = (*c++ &amp; 0x1) &lt;&lt; 1;
+	bc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
+	Mc[3]  = (*c &gt;&gt; 5) &amp; 0x3;
+	xmaxc[3]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
+	xmaxc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
+
+	xmc[39]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[40]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[41]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[41] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[42]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[43]  = *c++ &amp; 0x7;			/* 30  */
+	xmc[44]  = (*c &gt;&gt; 5) &amp; 0x7;
+	xmc[45]  = (*c &gt;&gt; 2) &amp; 0x7;
+	xmc[46]  = (*c++ &amp; 0x3) &lt;&lt; 1;
+	xmc[46] |= (*c &gt;&gt; 7) &amp; 0x1;
+	xmc[47]  = (*c &gt;&gt; 4) &amp; 0x7;
+	xmc[48]  = (*c &gt;&gt; 1) &amp; 0x7;
+	xmc[49]  = (*c++ &amp; 0x1) &lt;&lt; 2;
+	xmc[49] |= (*c &gt;&gt; 6) &amp; 0x3;
+	xmc[50]  = (*c &gt;&gt; 3) &amp; 0x7;
+	xmc[51]  = *c &amp; 0x7;			/* 33 */
+
+	fprintf(f,
+	      &quot;LARc:\t%2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d\n&quot;,
+	       LARc[0],LARc[1],LARc[2],LARc[3],LARc[4],LARc[5],LARc[6],LARc[7]);
+
+	fprintf(f, &quot;#1: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
+		Nc[0], bc[0], Mc[0], xmaxc[0]);
+	fprintf(f,
+&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
+		xmc[0],xmc[1],xmc[2],xmc[3],xmc[4],xmc[5],xmc[6],
+		xmc[7],xmc[8],xmc[9],xmc[10],xmc[11],xmc[12] );
+
+	fprintf(f, &quot;#2: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
+		Nc[1], bc[1], Mc[1], xmaxc[1]);
+	fprintf(f,
+&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
+		xmc[13+0],xmc[13+1],xmc[13+2],xmc[13+3],xmc[13+4],xmc[13+5],
+		xmc[13+6], xmc[13+7],xmc[13+8],xmc[13+9],xmc[13+10],xmc[13+11],
+		xmc[13+12] );
+
+	fprintf(f, &quot;#3: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
+		Nc[2], bc[2], Mc[2], xmaxc[2]);
+	fprintf(f,
+&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
+		xmc[26+0],xmc[26+1],xmc[26+2],xmc[26+3],xmc[26+4],xmc[26+5],
+		xmc[26+6], xmc[26+7],xmc[26+8],xmc[26+9],xmc[26+10],xmc[26+11],
+		xmc[26+12] );
+
+	fprintf(f, &quot;#4: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
+		Nc[3], bc[3], Mc[3], xmaxc[3]);
+	fprintf(f,
+&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
+		xmc[39+0],xmc[39+1],xmc[39+2],xmc[39+3],xmc[39+4],xmc[39+5],
+		xmc[39+6], xmc[39+7],xmc[39+8],xmc[39+9],xmc[39+10],xmc[39+11],
+		xmc[39+12] );
+
+	return 0;
+}

Modified: trunk/codecs/gsm/src/long_term.c
===================================================================
--- trunk/codecs/gsm/src/long_term.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/long_term.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -13,6 +13,955 @@
 
 #include &quot;gsm.h&quot;
 #include &quot;proto.h&quot;
+
+/*
+ *  4.2.11 .. 4.2.12 LONG TERM PREDICTOR (LTP) SECTION
+ */
+
+
+/*
+ * This module computes the LTP gain (bc) and the LTP lag (Nc)
+ * for the long term analysis filter.   This is done by calculating a
+ * maximum of the cross-correlation function between the current
+ * sub-segment short term residual signal d[0..39] (output of
+ * the short term analysis filter; for simplification the index
+ * of this array begins at 0 and ends at 39 for each sub-segment of the
+ * RPE-LTP analysis) and the previous reconstructed short term
+ * residual signal dp[ -120 .. -1 ].  A dynamic scaling must be
+ * performed to avoid overflow.
+ */
+
+ /* The next procedure exists in six versions.  First two integer
+  * version (if USE_FLOAT_MUL is not defined); then four floating
+  * point versions, twice with proper scaling (USE_FLOAT_MUL defined),
+  * once without (USE_FLOAT_MUL and FAST defined, and fast run-time
+  * option used).  Every pair has first a Cut version (see the -C
+  * option to toast or the LTP_CUT option to gsm_option()), then the
+  * uncut one.  (For a detailed explanation of why this is altogether
+  * a bad idea, see Henry Spencer and Geoff Collyer, ``#ifdef Considered
+  * Harmful''.)
+  */
+
+#ifndef  USE_FLOAT_MUL
+
+#ifdef	LTP_CUT
+
+static void Cut_Calculation_of_the_LTP_parameters P5((st, d,dp,bc_out,Nc_out),
+
+	struct gsm_state * st,
+
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+	word		wt[40];
+
+	longword	L_result;
+	longword	L_max, L_power;
+	word		R, S, dmax, scal, best_k;
+	word		ltp_cut;
+
+	register word	temp, wt_k;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+	for (k = 0; k &lt;= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp &gt; dmax) {
+			dmax = temp;
+			best_k = k;
+		}
+	}
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax &gt; 0);
+		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
+	}
+	if (temp &gt; 6) scal = 0;
+	else scal = 6 - temp;
+	assert(scal &gt;= 0);
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+	wt_k  = SASR(d[best_k], scal);
+
+	for (lambda = 40; lambda &lt;= 120; lambda++) {
+		L_result = (longword)wt_k * dp[best_k - lambda];
+		if (L_result &gt; L_max) {
+			Nc    = lambda;
+			L_max = L_result;
+		}
+	}
+	*Nc_out = Nc;
+	L_max &lt;&lt;= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal &lt;= 100 &amp;&amp; scal &gt;= -100);
+	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k &lt;= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power &lt;&lt;= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max &lt;= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max &gt;= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   &lt;&lt; temp, 16 );
+	S = SASR( L_power &lt;&lt; temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#endif 	/* LTP_CUT */
+
+static void Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+	word		wt[40];
+
+	longword	L_max, L_power;
+	word		R, S, dmax, scal;
+	register word	temp;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+
+	for (k = 0; k &lt;= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp &gt; dmax) dmax = temp;
+	}
+
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax &gt; 0);
+		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
+	}
+
+	if (temp &gt; 6) scal = 0;
+	else scal = 6 - temp;
+
+	assert(scal &gt;= 0);
+
+	/*  Initialization of a working array wt
+	 */
+
+	for (k = 0; k &lt;= 39; k++) wt[k] = SASR( d[k], scal );
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda &lt;= 120; lambda++) {
+
+# undef STEP
+#		define STEP(k) 	(longword)wt[k] * dp[k - lambda]
+
+		register longword L_result;
+
+		L_result  = STEP(0)  ; L_result += STEP(1) ;
+		L_result += STEP(2)  ; L_result += STEP(3) ;
+		L_result += STEP(4)  ; L_result += STEP(5)  ;
+		L_result += STEP(6)  ; L_result += STEP(7)  ;
+		L_result += STEP(8)  ; L_result += STEP(9)  ;
+		L_result += STEP(10) ; L_result += STEP(11) ;
+		L_result += STEP(12) ; L_result += STEP(13) ;
+		L_result += STEP(14) ; L_result += STEP(15) ;
+		L_result += STEP(16) ; L_result += STEP(17) ;
+		L_result += STEP(18) ; L_result += STEP(19) ;
+		L_result += STEP(20) ; L_result += STEP(21) ;
+		L_result += STEP(22) ; L_result += STEP(23) ;
+		L_result += STEP(24) ; L_result += STEP(25) ;
+		L_result += STEP(26) ; L_result += STEP(27) ;
+		L_result += STEP(28) ; L_result += STEP(29) ;
+		L_result += STEP(30) ; L_result += STEP(31) ;
+		L_result += STEP(32) ; L_result += STEP(33) ;
+		L_result += STEP(34) ; L_result += STEP(35) ;
+		L_result += STEP(36) ; L_result += STEP(37) ;
+		L_result += STEP(38) ; L_result += STEP(39) ;
+
+		if (L_result &gt; L_max) {
+
+			Nc    = lambda;
+			L_max = L_result;
+		}
+	}
+
+	*Nc_out = Nc;
+
+	L_max &lt;&lt;= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal &lt;= 100 &amp;&amp; scal &gt;=  -100);
+	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k &lt;= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power &lt;&lt;= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max &lt;= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max &gt;= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   &lt;&lt; temp, 16 );
+	S = SASR( L_power &lt;&lt; temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#else	/* USE_FLOAT_MUL */
+
+#ifdef	LTP_CUT
+
+static void Cut_Calculation_of_the_LTP_parameters P5((st, d,dp,bc_out,Nc_out),
+	struct gsm_state * st,		/*              IN 	*/
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+	word		ltp_cut;
+
+	float		wt_float[40];
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	longword	L_max, L_power;
+	word		R, S, dmax, scal;
+	register word	temp;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+
+	for (k = 0; k &lt;= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp &gt; dmax) dmax = temp;
+	}
+
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax &gt; 0);
+		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
+	}
+
+	if (temp &gt; 6) scal = 0;
+	else scal = 6 - temp;
+
+	assert(scal &gt;= 0);
+	ltp_cut = (longword)SASR(dmax, scal) * st-&gt;ltp_cut / 100; 
+
+
+	/*  Initialization of a working array wt
+	 */
+
+	for (k = 0; k &lt; 40; k++) {
+		register word w = SASR( d[k], scal );
+		if (w &lt; 0 ? w &gt; -ltp_cut : w &lt; ltp_cut) {
+			wt_float[k] = 0.0;
+		}
+		else {
+			wt_float[k] =  w;
+		}
+	}
+	for (k = -120; k &lt;  0; k++) dp_float[k] =  dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda &lt;= 120; lambda += 9) {
+
+		/*  Calculate L_result for l = lambda .. lambda + 9.
+		 */
+		register float *lp = dp_float - lambda;
+
+		register float	W;
+		register float	a = lp[-8], b = lp[-7], c = lp[-6],
+				d = lp[-5], e = lp[-4], f = lp[-3],
+				g = lp[-2], h = lp[-1];
+		register float  E; 
+		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
+				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
+
+#		undef STEP
+#		define	STEP(K, a, b, c, d, e, f, g, h) \
+			if ((W = wt_float[K]) != 0.0) {	\
+			E = W * a; S8 += E;		\
+			E = W * b; S7 += E;		\
+			E = W * c; S6 += E;		\
+			E = W * d; S5 += E;		\
+			E = W * e; S4 += E;		\
+			E = W * f; S3 += E;		\
+			E = W * g; S2 += E;		\
+			E = W * h; S1 += E;		\
+			a  = lp[K];			\
+			E = W * a; S0 += E; } else (a = lp[K])
+
+#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
+#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
+#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
+#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
+#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
+#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
+#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
+#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
+
+		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
+		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
+
+		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
+		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
+
+		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
+		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
+
+		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
+		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
+
+		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
+		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
+
+		if (S0 &gt; L_max) { L_max = S0; Nc = lambda;     }
+		if (S1 &gt; L_max) { L_max = S1; Nc = lambda + 1; }
+		if (S2 &gt; L_max) { L_max = S2; Nc = lambda + 2; }
+		if (S3 &gt; L_max) { L_max = S3; Nc = lambda + 3; }
+		if (S4 &gt; L_max) { L_max = S4; Nc = lambda + 4; }
+		if (S5 &gt; L_max) { L_max = S5; Nc = lambda + 5; }
+		if (S6 &gt; L_max) { L_max = S6; Nc = lambda + 6; }
+		if (S7 &gt; L_max) { L_max = S7; Nc = lambda + 7; }
+		if (S8 &gt; L_max) { L_max = S8; Nc = lambda + 8; }
+
+	}
+	*Nc_out = Nc;
+
+	L_max &lt;&lt;= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal &lt;= 100 &amp;&amp; scal &gt;=  -100);
+	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k &lt;= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power &lt;&lt;= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max &lt;= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max &gt;= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   &lt;&lt; temp, 16 );
+	S = SASR( L_power &lt;&lt; temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#endif /* LTP_CUT */
+
+static void Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+
+	float		wt_float[40];
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	longword	L_max, L_power;
+	word		R, S, dmax, scal;
+	register word	temp;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+
+	for (k = 0; k &lt;= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp &gt; dmax) dmax = temp;
+	}
+
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax &gt; 0);
+		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
+	}
+
+	if (temp &gt; 6) scal = 0;
+	else scal = 6 - temp;
+
+	assert(scal &gt;= 0);
+
+	/*  Initialization of a working array wt
+	 */
+
+	for (k =    0; k &lt; 40; k++) wt_float[k] =  SASR( d[k], scal );
+	for (k = -120; k &lt;  0; k++) dp_float[k] =  dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda &lt;= 120; lambda += 9) {
+
+		/*  Calculate L_result for l = lambda .. lambda + 9.
+		 */
+		register float *lp = dp_float - lambda;
+
+		register float	W;
+		register float	a = lp[-8], b = lp[-7], c = lp[-6],
+				d = lp[-5], e = lp[-4], f = lp[-3],
+				g = lp[-2], h = lp[-1];
+		register float  E; 
+		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
+				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
+
+#		undef STEP
+#		define	STEP(K, a, b, c, d, e, f, g, h) \
+			W = wt_float[K];		\
+			E = W * a; S8 += E;		\
+			E = W * b; S7 += E;		\
+			E = W * c; S6 += E;		\
+			E = W * d; S5 += E;		\
+			E = W * e; S4 += E;		\
+			E = W * f; S3 += E;		\
+			E = W * g; S2 += E;		\
+			E = W * h; S1 += E;		\
+			a  = lp[K];			\
+			E = W * a; S0 += E
+
+#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
+#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
+#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
+#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
+#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
+#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
+#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
+#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
+
+		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
+		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
+
+		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
+		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
+
+		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
+		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
+
+		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
+		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
+
+		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
+		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
+
+		if (S0 &gt; L_max) { L_max = S0; Nc = lambda;     }
+		if (S1 &gt; L_max) { L_max = S1; Nc = lambda + 1; }
+		if (S2 &gt; L_max) { L_max = S2; Nc = lambda + 2; }
+		if (S3 &gt; L_max) { L_max = S3; Nc = lambda + 3; }
+		if (S4 &gt; L_max) { L_max = S4; Nc = lambda + 4; }
+		if (S5 &gt; L_max) { L_max = S5; Nc = lambda + 5; }
+		if (S6 &gt; L_max) { L_max = S6; Nc = lambda + 6; }
+		if (S7 &gt; L_max) { L_max = S7; Nc = lambda + 7; }
+		if (S8 &gt; L_max) { L_max = S8; Nc = lambda + 8; }
+	}
+	*Nc_out = Nc;
+
+	L_max &lt;&lt;= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal &lt;= 100 &amp;&amp; scal &gt;=  -100);
+	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k &lt;= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power &lt;&lt;= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max &lt;= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max &gt;= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   &lt;&lt; temp, 16 );
+	S = SASR( L_power &lt;&lt; temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#ifdef	FAST
+#ifdef	LTP_CUT
+
+static void Cut_Fast_Calculation_of_the_LTP_parameters P5((st,
+							d,dp,bc_out,Nc_out),
+	struct gsm_state * st,		/*              IN	*/
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	register float	wt_float;
+	word		Nc, bc;
+	word		wt_max, best_k, ltp_cut;
+
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	register float	L_result, L_max, L_power;
+
+	wt_max = 0;
+
+	for (k = 0; k &lt; 40; ++k) {
+		if      ( d[k] &gt; wt_max) wt_max =  d[best_k = k];
+		else if (-d[k] &gt; wt_max) wt_max = -d[best_k = k];
+	}
+
+	assert(wt_max &gt;= 0);
+	wt_float = (float)wt_max;
+
+	for (k = -120; k &lt; 0; ++k) dp_float[k] = (float)dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda &lt;= 120; lambda++) {
+		L_result = wt_float * dp_float[best_k - lambda];
+		if (L_result &gt; L_max) {
+			Nc    = lambda;
+			L_max = L_result;
+		}
+	}
+
+	*Nc_out = Nc;
+	if (L_max &lt;= 0.)  {
+		*bc_out = 0;
+		return;
+	}
+
+	/*  Compute the power of the reconstructed short term residual
+	 *  signal dp[..]
+	 */
+	dp_float -= Nc;
+	L_power = 0;
+	for (k = 0; k &lt; 40; ++k) {
+		register float f = dp_float[k];
+		L_power += f * f;
+	}
+
+	if (L_max &gt;= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	/*  Coding of the LTP gain
+	 *  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	lambda = L_max / L_power * 32768.;
+	for (bc = 0; bc &lt;= 2; ++bc) if (lambda &lt;= gsm_DLB[bc]) break;
+	*bc_out = bc;
+}
+
+#endif /* LTP_CUT */
+
+static void Fast_Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+
+	float		wt_float[40];
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	register float	L_max, L_power;
+
+	for (k = 0; k &lt; 40; ++k) wt_float[k] = (float)d[k];
+	for (k = -120; k &lt; 0; ++k) dp_float[k] = (float)dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda &lt;= 120; lambda += 9) {
+
+		/*  Calculate L_result for l = lambda .. lambda + 9.
+		 */
+		register float *lp = dp_float - lambda;
+
+		register float	W;
+		register float	a = lp[-8], b = lp[-7], c = lp[-6],
+				d = lp[-5], e = lp[-4], f = lp[-3],
+				g = lp[-2], h = lp[-1];
+		register float  E; 
+		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
+				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
+
+#		undef STEP
+#		define	STEP(K, a, b, c, d, e, f, g, h) \
+			W = wt_float[K];		\
+			E = W * a; S8 += E;		\
+			E = W * b; S7 += E;		\
+			E = W * c; S6 += E;		\
+			E = W * d; S5 += E;		\
+			E = W * e; S4 += E;		\
+			E = W * f; S3 += E;		\
+			E = W * g; S2 += E;		\
+			E = W * h; S1 += E;		\
+			a  = lp[K];			\
+			E = W * a; S0 += E
+
+#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
+#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
+#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
+#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
+#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
+#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
+#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
+#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
+
+		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
+		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
+
+		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
+		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
+
+		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
+		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
+
+		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
+		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
+
+		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
+		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
+
+		if (S0 &gt; L_max) { L_max = S0; Nc = lambda;     }
+		if (S1 &gt; L_max) { L_max = S1; Nc = lambda + 1; }
+		if (S2 &gt; L_max) { L_max = S2; Nc = lambda + 2; }
+		if (S3 &gt; L_max) { L_max = S3; Nc = lambda + 3; }
+		if (S4 &gt; L_max) { L_max = S4; Nc = lambda + 4; }
+		if (S5 &gt; L_max) { L_max = S5; Nc = lambda + 5; }
+		if (S6 &gt; L_max) { L_max = S6; Nc = lambda + 6; }
+		if (S7 &gt; L_max) { L_max = S7; Nc = lambda + 7; }
+		if (S8 &gt; L_max) { L_max = S8; Nc = lambda + 8; }
+	}
+	*Nc_out = Nc;
+
+	if (L_max &lt;= 0.)  {
+		*bc_out = 0;
+		return;
+	}
+
+	/*  Compute the power of the reconstructed short term residual
+	 *  signal dp[..]
+	 */
+	dp_float -= Nc;
+	L_power = 0;
+	for (k = 0; k &lt; 40; ++k) {
+		register float f = dp_float[k];
+		L_power += f * f;
+	}
+
+	if (L_max &gt;= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	/*  Coding of the LTP gain
+	 *  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	lambda = L_max / L_power * 32768.;
+	for (bc = 0; bc &lt;= 2; ++bc) if (lambda &lt;= gsm_DLB[bc]) break;
+	*bc_out = bc;
+}
+
+#endif	/* FAST 	 */
+#endif	/* USE_FLOAT_MUL */
+
+
+/* 4.2.12 */
+
+static void Long_term_analysis_filtering P6((bc,Nc,dp,d,dpp,e),
+	word		bc,	/* 					IN  */
+	word		Nc,	/* 					IN  */
+	register word	* dp,	/* previous d	[-120..-1]		IN  */
+	register word	* d,	/* d		[0..39]			IN  */
+	register word	* dpp,	/* estimate	[0..39]			OUT */
+	register word	* e	/* long term res. signal [0..39]	OUT */
+)
+/*
+ *  In this part, we have to decode the bc parameter to compute
+ *  the samples of the estimate dpp[0..39].  The decoding of bc needs the
+ *  use of table 4.3b.  The long term residual signal e[0..39]
+ *  is then calculated to be fed to the RPE encoding section.
+ */
+{
+	register int      k;
+	register longword ltmp;
+
+#	undef STEP
+#	define STEP(BP)					\
+	for (k = 0; k &lt;= 39; k++) {			\
+		dpp[k]  = GSM_MULT_R( BP, dp[k - Nc]);	\
+		e[k]	= GSM_SUB( d[k], dpp[k] );	\
+	}
+
+	switch (bc) {
+	case 0:	STEP(  3277 ); break;
+	case 1:	STEP( 11469 ); break;
+	case 2: STEP( 21299 ); break;
+	case 3: STEP( 32767 ); break; 
+	}
+}
+
+void Gsm_Long_Term_Predictor P7((S,d,dp,e,dpp,Nc,bc), 	/* 4x for 160 samples */
+
+	struct gsm_state	* S,
+
+	word	* d,	/* [0..39]   residual signal	IN	*/
+	word	* dp,	/* [-120..-1] d'		IN	*/
+
+	word	* e,	/* [0..39] 			OUT	*/
+	word	* dpp,	/* [0..39] 			OUT	*/
+	word	* Nc,	/* correlation lag		OUT	*/
+	word	* bc	/* gain factor			OUT	*/
+)
+{
+	assert( d  ); assert( dp ); assert( e  );
+	assert( dpp); assert( Nc ); assert( bc );
+
+#if defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
+	if (S-&gt;fast) 
+#if   defined (LTP_CUT)
+		if (S-&gt;ltp_cut)
+			Cut_Fast_Calculation_of_the_LTP_parameters(S,
+				d, dp, bc, Nc);
+		else
+#endif /* LTP_CUT */
+			Fast_Calculation_of_the_LTP_parameters(d, dp, bc, Nc );
+	else 
+#endif /* FAST &amp; USE_FLOAT_MUL */
+#ifdef LTP_CUT
+		if (S-&gt;ltp_cut)
+			Cut_Calculation_of_the_LTP_parameters(S, d, dp, bc, Nc);
+		else
+#endif
+			Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
+
+	Long_term_analysis_filtering( *bc, *Nc, dp, d, dpp, e );
+}
+
+/* 4.3.2 */
+void Gsm_Long_Term_Synthesis_Filtering P5((S,Ncr,bcr,erp,drp),
+	struct gsm_state	* S,
+
+	word			Ncr,
+	word			bcr,
+	register word		* erp,	   /* [0..39]		  	 IN */
+	register word		* drp	   /* [-120..-1] IN, [-120..40] OUT */
+)
+/*
+ *  This procedure uses the bcr and Ncr parameter to realize the
+ *  long term synthesis filtering.  The decoding of bcr needs
+ *  table 4.3b.
+ */
+{
+	register longword	ltmp;	/* for ADD */
+	register int 		k;
+	word			brp, drpp, Nr;
+
+	/*  Check the limits of Nr.
+	 */
+	Nr = Ncr &lt; 40 || Ncr &gt; 120 ? S-&gt;nrp : Ncr;
+	S-&gt;nrp = Nr;
+	assert(Nr &gt;= 40 &amp;&amp; Nr &lt;= 120);
+
+	/*  Decoding of the LTP gain bcr
+	 */
+	brp = gsm_QLB[ bcr ];
+
+	/*  Computation of the reconstructed short term residual 
+	 *  signal drp[0..39]
+	 */
+	assert(brp != MIN_WORD);
+
+	for (k = 0; k &lt;= 39; k++) {
+		drpp   = GSM_MULT_R( brp, drp[ k - Nr ] );
+		drp[k] = GSM_ADD( erp[k], drpp );
+	}
+
+	/*
+	 *  Update of the reconstructed short term residual signal
+	 *  drp[ -1..-120 ]
+	 */
+
+	for (k = 0; k &lt;= 119; k++) drp[ -120 + k ] = drp[ -80 + k ];
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 #endif

Modified: trunk/codecs/gsm/src/lpc.c
===================================================================
--- trunk/codecs/gsm/src/lpc.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/lpc.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -14,6 +14,347 @@
 #include &quot;gsm.h&quot;
 #include &quot;proto.h&quot;
 
+#undef	P
+
+/*
+ *  4.2.4 .. 4.2.7 LPC ANALYSIS SECTION
+ */
+
+/* 4.2.4 */
+
+
+static void Autocorrelation P2((s, L_ACF),
+	word     * s,		/* [0..159]	IN/OUT  */
+ 	longword * L_ACF)	/* [0..8]	OUT     */
+/*
+ *  The goal is to compute the array L_ACF[k].  The signal s[i] must
+ *  be scaled in order to avoid an overflow situation.
+ */
+{
+	register int	k, i;
+
+	word		temp, smax, scalauto;
+
+#ifdef	USE_FLOAT_MUL
+	float		float_s[160];
+#endif
+
+	/*  Dynamic scaling of the array  s[0..159]
+	 */
+
+	/*  Search for the maximum.
+	 */
+	smax = 0;
+	for (k = 0; k &lt;= 159; k++) {
+		temp = GSM_ABS( s[k] );
+		if (temp &gt; smax) smax = temp;
+	}
+
+	/*  Computation of the scaling factor.
+	 */
+	if (smax == 0) scalauto = 0;
+	else {
+		assert(smax &gt; 0);
+		scalauto = 4 - gsm_norm( (longword)smax &lt;&lt; 16 );/* sub(4,..) */
+	}
+
+	/*  Scaling of the array s[0...159]
+	 */
+
+	if (scalauto &gt; 0) {
+
+# ifdef USE_FLOAT_MUL
+#   define SCALE(n)	\
+	case n: for (k = 0; k &lt;= 159; k++) \
+			float_s[k] = (float)	\
+				(s[k] = GSM_MULT_R(s[k], 16384 &gt;&gt; (n-1)));\
+		break;
+# else 
+#   define SCALE(n)	\
+	case n: for (k = 0; k &lt;= 159; k++) \
+			s[k] = GSM_MULT_R( s[k], 16384 &gt;&gt; (n-1) );\
+		break;
+# endif /* USE_FLOAT_MUL */
+
+		switch (scalauto) {
+		SCALE(1)
+		SCALE(2)
+		SCALE(3)
+		SCALE(4)
+		}
+# undef	SCALE
+	}
+# ifdef	USE_FLOAT_MUL
+	else for (k = 0; k &lt;= 159; k++) float_s[k] = (float) s[k];
+# endif
+
+	/*  Compute the L_ACF[..].
+	 */
+	{
+# ifdef	USE_FLOAT_MUL
+		register float * sp = float_s;
+		register float   sl = *sp;
+
+#		define STEP(k)	 L_ACF[k] += (longword)(sl * sp[ -(k) ]);
+# else
+		word  * sp = s;
+		word    sl = *sp;
+
+#		define STEP(k)	 L_ACF[k] += ((longword)sl * sp[ -(k) ]);
+# endif
+
+#	define NEXTI	 sl = *++sp
+
+
+	for (k = 9; k--; L_ACF[k] = 0) ;
+
+	STEP (0);
+	NEXTI;
+	STEP(0); STEP(1);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5); STEP(6);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5); STEP(6); STEP(7);
+
+	for (i = 8; i &lt;= 159; i++) {
+
+		NEXTI;
+
+		STEP(0);
+		STEP(1); STEP(2); STEP(3); STEP(4);
+		STEP(5); STEP(6); STEP(7); STEP(8);
+	}
+
+	for (k = 9; k--; L_ACF[k] &lt;&lt;= 1) ; 
+
+	}
+	/*   Rescaling of the array s[0..159]
+	 */
+	if (scalauto &gt; 0) {
+		assert(scalauto &lt;= 4); 
+		for (k = 160; k--; *s++ &lt;&lt;= scalauto) ;
+	}
+}
+
+#if defined(USE_FLOAT_MUL) &amp;&amp; defined(FAST)
+
+static void Fast_Autocorrelation P2((s, L_ACF),
+	word * s,		/* [0..159]	IN/OUT  */
+ 	longword * L_ACF)	/* [0..8]	OUT     */
+{
+	register int	k, i;
+	float f_L_ACF[9];
+	float scale;
+
+	float          s_f[160];
+	register float *sf = s_f;
+
+	for (i = 0; i &lt; 160; ++i) sf[i] = s[i];
+	for (k = 0; k &lt;= 8; k++) {
+		register float L_temp2 = 0;
+		register float *sfl = sf - k;
+		for (i = k; i &lt; 160; ++i) L_temp2 += sf[i] * sfl[i];
+		f_L_ACF[k] = L_temp2;
+	}
+	scale = MAX_LONGWORD / f_L_ACF[0];
+
+	for (k = 0; k &lt;= 8; k++) {
+		L_ACF[k] = f_L_ACF[k] * scale;
+	}
+}
+#endif	/* defined (USE_FLOAT_MUL) &amp;&amp; defined (FAST) */
+
+/* 4.2.5 */
+
+static void Reflection_coefficients P2( (L_ACF, r),
+	longword	* L_ACF,		/* 0...8	IN	*/
+	register word	* r			/* 0...7	OUT 	*/
+)
+{
+	register int	i, m, n;
+	register word	temp;
+	register longword ltmp;
+	word		ACF[9];	/* 0..8 */
+	word		P[  9];	/* 0..8 */
+	word		K[  9]; /* 2..8 */
+
+	/*  Schur recursion with 16 bits arithmetic.
+	 */
+
+	if (L_ACF[0] == 0) {
+		for (i = 8; i--; *r++ = 0) ;
+		return;
+	}
+
+	assert( L_ACF[0] != 0 );
+	temp = gsm_norm( L_ACF[0] );
+
+	assert(temp &gt;= 0 &amp;&amp; temp &lt; 32);
+
+	/* ? overflow ? */
+	for (i = 0; i &lt;= 8; i++) ACF[i] = SASR( L_ACF[i] &lt;&lt; temp, 16 );
+
+	/*   Initialize array P[..] and K[..] for the recursion.
+	 */
+
+	for (i = 1; i &lt;= 7; i++) K[ i ] = ACF[ i ];
+	for (i = 0; i &lt;= 8; i++) P[ i ] = ACF[ i ];
+
+	/*   Compute reflection coefficients
+	 */
+	for (n = 1; n &lt;= 8; n++, r++) {
+
+		temp = P[1];
+		temp = GSM_ABS(temp);
+		if (P[0] &lt; temp) {
+			for (i = n; i &lt;= 8; i++) *r++ = 0;
+			return;
+		}
+
+		*r = gsm_div( temp, P[0] );
+
+		assert(*r &gt;= 0);
+		if (P[1] &gt; 0) *r = -*r;		/* r[n] = sub(0, r[n]) */
+		assert (*r != MIN_WORD);
+		if (n == 8) return; 
+
+		/*  Schur recursion
+		 */
+		temp = GSM_MULT_R( P[1], *r );
+		P[0] = GSM_ADD( P[0], temp );
+
+		for (m = 1; m &lt;= 8 - n; m++) {
+			temp     = GSM_MULT_R( K[ m   ],    *r );
+			P[m]     = GSM_ADD(    P[ m+1 ],  temp );
+
+			temp     = GSM_MULT_R( P[ m+1 ],    *r );
+			K[m]     = GSM_ADD(    K[ m   ],  temp );
+		}
+	}
+}
+
+/* 4.2.6 */
+
+static void Transformation_to_Log_Area_Ratios P1((r),
+	register word	* r 			/* 0..7	   IN/OUT */
+)
+/*
+ *  The following scaling for r[..] and LAR[..] has been used:
+ *
+ *  r[..]   = integer( real_r[..]*32768. ); -1 &lt;= real_r &lt; 1.
+ *  LAR[..] = integer( real_LAR[..] * 16384 );
+ *  with -1.625 &lt;= real_LAR &lt;= 1.625
+ */
+{
+	register word	temp;
+	register int	i;
+
+
+	/* Computation of the LAR[0..7] from the r[0..7]
+	 */
+	for (i = 1; i &lt;= 8; i++, r++) {
+
+		temp = *r;
+		temp = GSM_ABS(temp);
+		assert(temp &gt;= 0);
+
+		if (temp &lt; 22118) {
+			temp &gt;&gt;= 1;
+		} else if (temp &lt; 31130) {
+			assert( temp &gt;= 11059 );
+			temp -= 11059;
+		} else {
+			assert( temp &gt;= 26112 );
+			temp -= 26112;
+			temp &lt;&lt;= 2;
+		}
+
+		*r = *r &lt; 0 ? -temp : temp;
+		assert( *r != MIN_WORD );
+	}
+}
+
+/* 4.2.7 */
+
+static void Quantization_and_coding P1((LAR),
+	register word * LAR    	/* [0..7]	IN/OUT	*/
+)
+{
+	register word	temp;
+	longword	ltmp;
+
+
+	/*  This procedure needs four tables; the following equations
+	 *  give the optimum scaling for the constants:
+	 *  
+	 *  A[0..7] = integer( real_A[0..7] * 1024 )
+	 *  B[0..7] = integer( real_B[0..7] *  512 )
+	 *  MAC[0..7] = maximum of the LARc[0..7]
+	 *  MIC[0..7] = minimum of the LARc[0..7]
+	 */
+
+#	undef STEP
+#	define	STEP( A, B, MAC, MIC )		\
+		temp = GSM_MULT( A,   *LAR );	\
+		temp = GSM_ADD(  temp,   B );	\
+		temp = GSM_ADD(  temp, 256 );	\
+		temp = SASR(     temp,   9 );	\
+		*LAR  =  temp&gt;MAC ? MAC - MIC : (temp&lt;MIC ? 0 : temp - MIC); \
+		LAR++;
+
+	STEP(  20480,     0,  31, -32 );
+	STEP(  20480,     0,  31, -32 );
+	STEP(  20480,  2048,  15, -16 );
+	STEP(  20480, -2560,  15, -16 );
+
+	STEP(  13964,    94,   7,  -8 );
+	STEP(  15360, -1792,   7,  -8 );
+	STEP(   8534,  -341,   3,  -4 );
+	STEP(   9036, -1144,   3,  -4 );
+
+#	undef	STEP
+}
+
+void Gsm_LPC_Analysis P3((S, s,LARc),
+	struct gsm_state *S,
+	word 		 * s,		/* 0..159 signals	IN/OUT	*/
+        word 		 * LARc)	/* 0..7   LARc's	OUT	*/
+{
+	longword	L_ACF[9];
+
+#if defined(USE_FLOAT_MUL) &amp;&amp; defined(FAST)
+	if (S-&gt;fast) Fast_Autocorrelation (s,	  L_ACF );
+	else
+#endif
+	Autocorrelation			  (s,	  L_ACF	);
+	Reflection_coefficients		  (L_ACF, LARc	);
+	Transformation_to_Log_Area_Ratios (LARc);
+	Quantization_and_coding		  (LARc);
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 #endif

Modified: trunk/codecs/gsm/src/preprocess.c
===================================================================
--- trunk/codecs/gsm/src/preprocess.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/preprocess.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -36,6 +36,119 @@
 	word		 * s,
 	word 		 * so )		/* [0..159] 	IN/OUT	*/
 {
+
+	word       z1 = S-&gt;z1;
+	longword L_z2 = S-&gt;L_z2;
+	word 	   mp = S-&gt;mp;
+
+	word 	   	s1;
+	longword      L_s2;
+
+	longword      L_temp;
+
+	word		msp, lsp;
+	word		SO;
+
+	longword	ltmp;		/* for   ADD */
+	ulongword	utmp;		/* for L_ADD */
+
+	register int		k = 160;
+
+	while (k--) {
+
+	/*  4.2.1   Downscaling of the input signal
+	 */
+		SO = SASR( *s, 3 ) &lt;&lt; 2;
+		s++;
+
+		assert (SO &gt;= -0x4000);	/* downscaled by     */
+		assert (SO &lt;=  0x3FFC);	/* previous routine. */
+
+
+	/*  4.2.2   Offset compensation
+	 * 
+	 *  This part implements a high-pass filter and requires extended
+	 *  arithmetic precision for the recursive part of this filter.
+	 *  The input of this procedure is the array so[0...159] and the
+	 *  output the array sof[ 0...159 ].
+	 */
+		/*   Compute the non-recursive part
+		 */
+
+		s1 = SO - z1;			/* s1 = gsm_sub( *so, z1 ); */
+		z1 = SO;
+
+		assert(s1 != MIN_WORD);
+
+		/*   Compute the recursive part
+		 */
+		L_s2 = s1;
+		L_s2 &lt;&lt;= 15;
+
+		/*   Execution of a 31 bv 16 bits multiplication
+		 */
+
+		msp = SASR( L_z2, 15 );
+		lsp = L_z2-((longword)msp&lt;&lt;15); /* gsm_L_sub(L_z2,(msp&lt;&lt;15)); */
+
+		L_s2  += GSM_MULT_R( lsp, 32735 );
+		L_temp = (longword)msp * 32735; /* GSM_L_MULT(msp,32735) &gt;&gt; 1;*/
+		L_z2   = GSM_L_ADD( L_temp, L_s2 );
+
+		/*    Compute sof[k] with rounding
+		 */
+		L_temp = GSM_L_ADD( L_z2, 16384 );
+
+	/*   4.2.3  Preemphasis
+	 */
+
+		msp   = GSM_MULT_R( mp, -28180 );
+		mp    = SASR( L_temp, 15 );
+		*so++ = GSM_ADD( mp, msp );
+	}
+
+	S-&gt;z1   = z1;
+	S-&gt;L_z2 = L_z2;
+	S-&gt;mp   = mp;
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include	&lt;stdio.h&gt;
+#include	&lt;assert.h&gt;
+
+#include &quot;private.h&quot;
+
+#include	&quot;gsm.h&quot;
+#include 	&quot;proto.h&quot;
+
+/*	4.2.0 .. 4.2.3	PREPROCESSING SECTION
+ *  
+ *  	After A-law to linear conversion (or directly from the
+ *   	Ato D converter) the following scaling is assumed for
+ * 	input to the RPE-LTP algorithm:
+ *
+ *      in:  0.1.....................12
+ *	     S.v.v.v.v.v.v.v.v.v.v.v.v.*.*.*
+ *
+ *	Where S is the sign bit, v a valid bit, and * a &quot;don't care&quot; bit.
+ * 	The original signal is called sop[..]
+ *
+ *      out:   0.1................... 12 
+ *	     S.S.v.v.v.v.v.v.v.v.v.v.v.v.0.0
+ */
+
+
+void Gsm_Preprocess P3((S, s, so),
+	struct gsm_state * S,
+	word		 * s,
+	word 		 * so )		/* [0..159] 	IN/OUT	*/
+{
 	word       	z1 = S-&gt;z1;
 	longword 	L_z2 = S-&gt;L_z2;
 	word 	   	mp = S-&gt;mp;

Modified: trunk/codecs/gsm/src/rpe.c
===================================================================
--- trunk/codecs/gsm/src/rpe.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/rpe.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -18,6 +18,494 @@
  */
 
 /* 4.2.13 */
+
+static void Weighting_filter P2((e, x),
+	register word	* e,		/* signal [-5..0.39.44]	IN  */
+	word		* x		/* signal [0..39]	OUT */
+)
+/*
+ *  The coefficients of the weighting filter are stored in a table
+ *  (see table 4.4).  The following scaling is used:
+ *
+ *	H[0..10] = integer( real_H[ 0..10] * 8192 ); 
+ */
+{
+	/* word			wt[ 50 ]; */
+
+	register longword	L_result;
+	register int		k /* , i */ ;
+
+	/*  Initialization of a temporary working array wt[0...49]
+	 */
+
+	/* for (k =  0; k &lt;=  4; k++) wt[k] = 0;
+	 * for (k =  5; k &lt;= 44; k++) wt[k] = *e++;
+	 * for (k = 45; k &lt;= 49; k++) wt[k] = 0;
+	 *
+	 *  (e[-5..-1] and e[40..44] are allocated by the caller,
+	 *  are initially zero and are not written anywhere.)
+	 */
+	e -= 5;
+
+	/*  Compute the signal x[0..39]
+	 */ 
+	for (k = 0; k &lt;= 39; k++) {
+
+		L_result = 8192 &gt;&gt; 1;
+
+		/* for (i = 0; i &lt;= 10; i++) {
+		 *	L_temp   = GSM_L_MULT( wt[k+i], gsm_H[i] );
+		 *	L_result = GSM_L_ADD( L_result, L_temp );
+		 * }
+		 */
+
+#undef	STEP
+#define	STEP( i, H )	(e[ k + i ] * (longword)H)
+
+		/*  Every one of these multiplications is done twice --
+		 *  but I don't see an elegant way to optimize this. 
+		 *  Do you?
+		 */
+
+#ifdef	STUPID_COMPILER
+		L_result += STEP(	0, 	-134 ) ;
+		L_result += STEP(	1, 	-374 )  ;
+	               /* + STEP(	2, 	0    )  */
+		L_result += STEP(	3, 	2054 ) ;
+		L_result += STEP(	4, 	5741 ) ;
+		L_result += STEP(	5, 	8192 ) ;
+		L_result += STEP(	6, 	5741 ) ;
+		L_result += STEP(	7, 	2054 ) ;
+	 	       /* + STEP(	8, 	0    )  */
+		L_result += STEP(	9, 	-374 ) ;
+		L_result += STEP(	10, 	-134 ) ;
+#else
+		L_result +=
+		  STEP(	0, 	-134 ) 
+		+ STEP(	1, 	-374 ) 
+	     /* + STEP(	2, 	0    )  */
+		+ STEP(	3, 	2054 ) 
+		+ STEP(	4, 	5741 ) 
+		+ STEP(	5, 	8192 ) 
+		+ STEP(	6, 	5741 ) 
+		+ STEP(	7, 	2054 ) 
+	     /* + STEP(	8, 	0    )  */
+		+ STEP(	9, 	-374 ) 
+		+ STEP(10, 	-134 )
+		;
+#endif
+
+		/* L_result = GSM_L_ADD( L_result, L_result ); (* scaling(x2) *)
+		 * L_result = GSM_L_ADD( L_result, L_result ); (* scaling(x4) *)
+		 *
+		 * x[k] = SASR( L_result, 16 );
+		 */
+
+		/* 2 adds vs. &gt;&gt;16 =&gt; 14, minus one shift to compensate for
+		 * those we lost when replacing L_MULT by '*'.
+		 */
+
+		L_result = SASR( L_result, 13 );
+		x[k] =  (  L_result &lt; MIN_WORD ? MIN_WORD
+			: (L_result &gt; MAX_WORD ? MAX_WORD : L_result ));
+	}
+}
+
+/* 4.2.14 */
+
+static void RPE_grid_selection P3((x,xM,Mc_out),
+	word		* x,		/* [0..39]		IN  */ 
+	word		* xM,		/* [0..12]		OUT */
+	word		* Mc_out	/*			OUT */
+)
+/*
+ *  The signal x[0..39] is used to select the RPE grid which is
+ *  represented by Mc.
+ */
+{
+	/* register word	temp1;	*/
+	register int		/* m, */  i;
+	register longword	L_result, L_temp;
+	longword		EM;	/* xxx should be L_EM? */
+	word			Mc;
+
+	longword		L_common_0_3;
+
+	EM = 0;
+	Mc = 0;
+
+	/* for (m = 0; m &lt;= 3; m++) {
+	 *	L_result = 0;
+	 *
+	 *
+	 *	for (i = 0; i &lt;= 12; i++) {
+	 *
+	 *		temp1    = SASR( x[m + 3*i], 2 );
+	 *
+	 *		assert(temp1 != MIN_WORD);
+	 *
+	 *		L_temp   = GSM_L_MULT( temp1, temp1 );
+	 *		L_result = GSM_L_ADD( L_temp, L_result );
+	 *	}
+	 * 
+	 *	if (L_result &gt; EM) {
+	 *		Mc = m;
+	 *		EM = L_result;
+	 *	}
+	 * }
+	 */
+
+#undef	STEP
+#define	STEP( m, i )		L_temp = SASR( x[m + 3 * i], 2 );	\
+				L_result += L_temp * L_temp;
+
+	/* common part of 0 and 3 */
+
+	L_result = 0;
+	STEP( 0, 1 ); STEP( 0, 2 ); STEP( 0, 3 ); STEP( 0, 4 );
+	STEP( 0, 5 ); STEP( 0, 6 ); STEP( 0, 7 ); STEP( 0, 8 );
+	STEP( 0, 9 ); STEP( 0, 10); STEP( 0, 11); STEP( 0, 12);
+	L_common_0_3 = L_result;
+
+	/* i = 0 */
+
+	STEP( 0, 0 );
+	L_result &lt;&lt;= 1;	/* implicit in L_MULT */
+	EM = L_result;
+
+	/* i = 1 */
+
+	L_result = 0;
+	STEP( 1, 0 );
+	STEP( 1, 1 ); STEP( 1, 2 ); STEP( 1, 3 ); STEP( 1, 4 );
+	STEP( 1, 5 ); STEP( 1, 6 ); STEP( 1, 7 ); STEP( 1, 8 );
+	STEP( 1, 9 ); STEP( 1, 10); STEP( 1, 11); STEP( 1, 12);
+	L_result &lt;&lt;= 1;
+	if (L_result &gt; EM) {
+		Mc = 1;
+	 	EM = L_result;
+	}
+
+	/* i = 2 */
+
+	L_result = 0;
+	STEP( 2, 0 );
+	STEP( 2, 1 ); STEP( 2, 2 ); STEP( 2, 3 ); STEP( 2, 4 );
+	STEP( 2, 5 ); STEP( 2, 6 ); STEP( 2, 7 ); STEP( 2, 8 );
+	STEP( 2, 9 ); STEP( 2, 10); STEP( 2, 11); STEP( 2, 12);
+	L_result &lt;&lt;= 1;
+	if (L_result &gt; EM) {
+		Mc = 2;
+	 	EM = L_result;
+	}
+
+	/* i = 3 */
+
+	L_result = L_common_0_3;
+	STEP( 3, 12 );
+	L_result &lt;&lt;= 1;
+	if (L_result &gt; EM) {
+		Mc = 3;
+	 	EM = L_result;
+	}
+
+	/**/
+
+	/*  Down-sampling by a factor 3 to get the selected xM[0..12]
+	 *  RPE sequence.
+	 */
+	for (i = 0; i &lt;= 12; i ++) xM[i] = x[Mc + 3*i];
+	*Mc_out = Mc;
+}
+
+/* 4.12.15 */
+
+static void APCM_quantization_xmaxc_to_exp_mant P3((xmaxc,exp_out,mant_out),
+	word		xmaxc,		/* IN 	*/
+	word		* exp_out,	/* OUT	*/
+	word		* mant_out )	/* OUT  */
+{
+	word	exp, mant;
+
+	/* Compute exponent and mantissa of the decoded version of xmaxc
+	 */
+
+	exp = 0;
+	if (xmaxc &gt; 15) exp = SASR(xmaxc, 3) - 1;
+	mant = xmaxc - (exp &lt;&lt; 3);
+
+	if (mant == 0) {
+		exp  = -4;
+		mant = 7;
+	}
+	else {
+		while (mant &lt;= 7) {
+			mant = mant &lt;&lt; 1 | 1;
+			exp--;
+		}
+		mant -= 8;
+	}
+
+	assert( exp  &gt;= -4 &amp;&amp; exp &lt;= 6 );
+	assert( mant &gt;= 0 &amp;&amp; mant &lt;= 7 );
+
+	*exp_out  = exp;
+	*mant_out = mant;
+}
+
+static void APCM_quantization P5((xM,xMc,mant_out,exp_out,xmaxc_out),
+	word		* xM,		/* [0..12]		IN	*/
+
+	word		* xMc,		/* [0..12]		OUT	*/
+	word		* mant_out,	/* 			OUT	*/
+	word		* exp_out,	/*			OUT	*/
+	word		* xmaxc_out	/*			OUT	*/
+)
+{
+	int	i, itest;
+
+	word	xmax, xmaxc, temp, temp1, temp2;
+	word	exp, mant;
+
+
+	/*  Find the maximum absolute value xmax of xM[0..12].
+	 */
+
+	xmax = 0;
+	for (i = 0; i &lt;= 12; i++) {
+		temp = xM[i];
+		temp = GSM_ABS(temp);
+		if (temp &gt; xmax) xmax = temp;
+	}
+
+	/*  Qantizing and coding of xmax to get xmaxc.
+	 */
+
+	exp   = 0;
+	temp  = SASR( xmax, 9 );
+	itest = 0;
+
+	for (i = 0; i &lt;= 5; i++) {
+
+		itest |= (temp &lt;= 0);
+		temp = SASR( temp, 1 );
+
+		assert(exp &lt;= 5);
+		if (itest == 0) exp++;		/* exp = add (exp, 1) */
+	}
+
+	assert(exp &lt;= 6 &amp;&amp; exp &gt;= 0);
+	temp = exp + 5;
+
+	assert(temp &lt;= 11 &amp;&amp; temp &gt;= 0);
+	xmaxc = gsm_add( SASR(xmax, temp), exp &lt;&lt; 3 );
+
+	/*   Quantizing and coding of the xM[0..12] RPE sequence
+	 *   to get the xMc[0..12]
+	 */
+
+	APCM_quantization_xmaxc_to_exp_mant( xmaxc, &amp;exp, &amp;mant );
+
+	/*  This computation uses the fact that the decoded version of xmaxc
+	 *  can be calculated by using the exponent and the mantissa part of
+	 *  xmaxc (logarithmic table).
+	 *  So, this method avoids any division and uses only a scaling
+	 *  of the RPE samples by a function of the exponent.  A direct 
+	 *  multiplication by the inverse of the mantissa (NRFAC[0..7]
+	 *  found in table 4.5) gives the 3 bit coded version xMc[0..12]
+	 *  of the RPE samples.
+	 */
+
+
+	/* Direct computation of xMc[0..12] using table 4.5
+	 */
+
+	assert( exp &lt;= 4096 &amp;&amp; exp &gt;= -4096);
+	assert( mant &gt;= 0 &amp;&amp; mant &lt;= 7 ); 
+
+	temp1 = 6 - exp;		/* normalization by the exponent */
+	temp2 = gsm_NRFAC[ mant ];  	/* inverse mantissa 		 */
+
+	for (i = 0; i &lt;= 12; i++) {
+
+		assert(temp1 &gt;= 0 &amp;&amp; temp1 &lt; 16);
+
+		temp = xM[i] &lt;&lt; temp1;
+		temp = GSM_MULT( temp, temp2 );
+		temp = SASR(temp, 12);
+		xMc[i] = temp + 4;		/* see note below */
+	}
+
+	/*  NOTE: This equation is used to make all the xMc[i] positive.
+	 */
+
+	*mant_out  = mant;
+	*exp_out   = exp;
+	*xmaxc_out = xmaxc;
+}
+
+/* 4.2.16 */
+
+static void APCM_inverse_quantization P4((xMc,mant,exp,xMp),
+	register word	* xMc,	/* [0..12]			IN 	*/
+	word		mant,
+	word		exp,
+	register word	* xMp)	/* [0..12]			OUT 	*/
+/* 
+ *  This part is for decoding the RPE sequence of coded xMc[0..12]
+ *  samples to obtain the xMp[0..12] array.  Table 4.6 is used to get
+ *  the mantissa of xmaxc (FAC[0..7]).
+ */
+{
+	int	i;
+	word	temp, temp1, temp2, temp3;
+	longword	ltmp;
+
+	assert( mant &gt;= 0 &amp;&amp; mant &lt;= 7 ); 
+
+	temp1 = gsm_FAC[ mant ];	/* see 4.2-15 for mant */
+	temp2 = gsm_sub( 6, exp );	/* see 4.2-15 for exp  */
+	temp3 = gsm_asl( 1, gsm_sub( temp2, 1 ));
+
+	for (i = 13; i--;) {
+
+		assert( *xMc &lt;= 7 &amp;&amp; *xMc &gt;= 0 ); 	/* 3 bit unsigned */
+
+		/* temp = gsm_sub( *xMc++ &lt;&lt; 1, 7 ); */
+		temp = (*xMc++ &lt;&lt; 1) - 7;	        /* restore sign   */
+		assert( temp &lt;= 7 &amp;&amp; temp &gt;= -7 ); 	/* 4 bit signed   */
+
+		temp &lt;&lt;= 12;				/* 16 bit signed  */
+		temp = GSM_MULT_R( temp1, temp );
+		temp = GSM_ADD( temp, temp3 );
+		*xMp++ = gsm_asr( temp, temp2 );
+	}
+}
+
+/* 4.2.17 */
+
+static void RPE_grid_positioning P3((Mc,xMp,ep),
+	word		Mc,		/* grid position	IN	*/
+	register word	* xMp,		/* [0..12]		IN	*/
+	register word	* ep		/* [0..39]		OUT	*/
+)
+/*
+ *  This procedure computes the reconstructed long term residual signal
+ *  ep[0..39] for the LTP analysis filter.  The inputs are the Mc
+ *  which is the grid position selection and the xMp[0..12] decoded
+ *  RPE samples which are upsampled by a factor of 3 by inserting zero
+ *  values.
+ */
+{
+	int	i = 13;
+
+	assert(0 &lt;= Mc &amp;&amp; Mc &lt;= 3);
+
+        switch (Mc) {
+                case 3: *ep++ = 0;
+                case 2:  do {
+                                *ep++ = 0;
+                case 1:         *ep++ = 0;
+                case 0:         *ep++ = *xMp++;
+                         } while (--i);
+        }
+        while (++Mc &lt; 4) *ep++ = 0;
+
+	/*
+
+	int i, k;
+	for (k = 0; k &lt;= 39; k++) ep[k] = 0;
+	for (i = 0; i &lt;= 12; i++) {
+		ep[ Mc + (3*i) ] = xMp[i];
+	}
+	*/
+}
+
+/* 4.2.18 */
+
+/*  This procedure adds the reconstructed long term residual signal
+ *  ep[0..39] to the estimated signal dpp[0..39] from the long term
+ *  analysis filter to compute the reconstructed short term residual
+ *  signal dp[-40..-1]; also the reconstructed short term residual
+ *  array dp[-120..-41] is updated.
+ */
+
+#if 0	/* Has been inlined in code.c */
+void Gsm_Update_of_reconstructed_short_time_residual_signal P3((dpp, ep, dp),
+	word	* dpp,		/* [0...39]	IN	*/
+	word	* ep,		/* [0...39]	IN	*/
+	word	* dp)		/* [-120...-1]  IN/OUT 	*/
+{
+	int 		k;
+
+	for (k = 0; k &lt;= 79; k++) 
+		dp[ -120 + k ] = dp[ -80 + k ];
+
+	for (k = 0; k &lt;= 39; k++)
+		dp[ -40 + k ] = gsm_add( ep[k], dpp[k] );
+}
+#endif	/* Has been inlined in code.c */
+
+void Gsm_RPE_Encoding P5((S,e,xmaxc,Mc,xMc),
+
+	struct gsm_state * S,
+
+	word	* e,		/* -5..-1][0..39][40..44	IN/OUT  */
+	word	* xmaxc,	/* 				OUT */
+	word	* Mc,		/* 			  	OUT */
+	word	* xMc)		/* [0..12]			OUT */
+{
+	word	x[40];
+	word	xM[13], xMp[13];
+	word	mant, exp;
+
+	Weighting_filter(e, x);
+	RPE_grid_selection(x, xM, Mc);
+
+	APCM_quantization(	xM, xMc, &amp;mant, &amp;exp, xmaxc);
+	APCM_inverse_quantization(  xMc,  mant,  exp, xMp);
+
+	RPE_grid_positioning( *Mc, xMp, e );
+
+}
+
+void Gsm_RPE_Decoding P5((S, xmaxcr, Mcr, xMcr, erp),
+	struct gsm_state	* S,
+
+	word 		xmaxcr,
+	word		Mcr,
+	word		* xMcr,  /* [0..12], 3 bits 		IN	*/
+	word		* erp	 /* [0..39]			OUT 	*/
+)
+{
+	word	exp, mant;
+	word	xMp[ 13 ];
+
+	APCM_quantization_xmaxc_to_exp_mant( xmaxcr, &amp;exp, &amp;mant );
+	APCM_inverse_quantization( xMcr, mant, exp, xMp );
+	RPE_grid_positioning( Mcr, xMp, erp );
+
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
+
+/*  4.2.13 .. 4.2.17  RPE ENCODING SECTION
+ */
+
+/* 4.2.13 */
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 #else

Modified: trunk/codecs/gsm/src/short_term.c
===================================================================
--- trunk/codecs/gsm/src/short_term.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/short_term.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -13,6 +13,435 @@
 
 #include &quot;gsm.h&quot;
 #include &quot;proto.h&quot;
+
+/*
+ *  SHORT TERM ANALYSIS FILTERING SECTION
+ */
+
+/* 4.2.8 */
+
+static void Decoding_of_the_coded_Log_Area_Ratios P2((LARc,LARpp),
+	word 	* LARc,		/* coded log area ratio	[0..7] 	IN	*/
+	word	* LARpp)	/* out: decoded ..			*/
+{
+	register word	temp1 /* , temp2 */;
+	register long	ltmp;	/* for GSM_ADD */
+
+	/*  This procedure requires for efficient implementation
+	 *  two tables.
+ 	 *
+	 *  INVA[1..8] = integer( (32768 * 8) / real_A[1..8])
+	 *  MIC[1..8]  = minimum value of the LARc[1..8]
+	 */
+
+	/*  Compute the LARpp[1..8]
+	 */
+
+	/* 	for (i = 1; i &lt;= 8; i++, B++, MIC++, INVA++, LARc++, LARpp++) {
+	 *
+	 *		temp1  = GSM_ADD( *LARc, *MIC ) &lt;&lt; 10;
+	 *		temp2  = *B &lt;&lt; 1;
+	 *		temp1  = GSM_SUB( temp1, temp2 );
+	 *
+	 *		assert(*INVA != MIN_WORD);
+	 *
+	 *		temp1  = GSM_MULT_R( *INVA, temp1 );
+	 *		*LARpp = GSM_ADD( temp1, temp1 );
+	 *	}
+	 */
+
+#undef	STEP
+#define	STEP( B, MIC, INVA )	\
+		temp1    = GSM_ADD( *LARc++, MIC ) &lt;&lt; 10;	\
+		temp1    = GSM_SUB( temp1, B &lt;&lt; 1 );		\
+		temp1    = GSM_MULT_R( INVA, temp1 );		\
+		*LARpp++ = GSM_ADD( temp1, temp1 );
+
+	STEP(      0,  -32,  13107 );
+	STEP(      0,  -32,  13107 );
+	STEP(   2048,  -16,  13107 );
+	STEP(  -2560,  -16,  13107 );
+
+	STEP(     94,   -8,  19223 );
+	STEP(  -1792,   -8,  17476 );
+	STEP(   -341,   -4,  31454 );
+	STEP(  -1144,   -4,  29708 );
+
+	/* NOTE: the addition of *MIC is used to restore
+	 * 	 the sign of *LARc.
+	 */
+}
+
+/* 4.2.9 */
+/* Computation of the quantized reflection coefficients 
+ */
+
+/* 4.2.9.1  Interpolation of the LARpp[1..8] to get the LARp[1..8]
+ */
+
+/*
+ *  Within each frame of 160 analyzed speech samples the short term
+ *  analysis and synthesis filters operate with four different sets of
+ *  coefficients, derived from the previous set of decoded LARs(LARpp(j-1))
+ *  and the actual set of decoded LARs (LARpp(j))
+ *
+ * (Initial value: LARpp(j-1)[1..8] = 0.)
+ */
+
+static void Coefficients_0_12 P3((LARpp_j_1, LARpp_j, LARp),
+	register word * LARpp_j_1,
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int 	i;
+	register longword ltmp;
+
+	for (i = 1; i &lt;= 8; i++, LARp++, LARpp_j_1++, LARpp_j++) {
+		*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));
+		*LARp = GSM_ADD( *LARp,  SASR( *LARpp_j_1, 1));
+	}
+}
+
+static void Coefficients_13_26 P3((LARpp_j_1, LARpp_j, LARp),
+	register word * LARpp_j_1,
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int i;
+	register longword ltmp;
+	for (i = 1; i &lt;= 8; i++, LARpp_j_1++, LARpp_j++, LARp++) {
+		*LARp = GSM_ADD( SASR( *LARpp_j_1, 1), SASR( *LARpp_j, 1 ));
+	}
+}
+
+static void Coefficients_27_39 P3((LARpp_j_1, LARpp_j, LARp),
+	register word * LARpp_j_1,
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int i;
+	register longword ltmp;
+
+	for (i = 1; i &lt;= 8; i++, LARpp_j_1++, LARpp_j++, LARp++) {
+		*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));
+		*LARp = GSM_ADD( *LARp, SASR( *LARpp_j, 1 ));
+	}
+}
+
+
+static void Coefficients_40_159 P2((LARpp_j, LARp),
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int i;
+
+	for (i = 1; i &lt;= 8; i++, LARp++, LARpp_j++)
+		*LARp = *LARpp_j;
+}
+
+/* 4.2.9.2 */
+
+static void LARp_to_rp P1((LARp),
+	register word * LARp)	/* [0..7] IN/OUT  */
+/*
+ *  The input of this procedure is the interpolated LARp[0..7] array.
+ *  The reflection coefficients, rp[i], are used in the analysis
+ *  filter and in the synthesis filter.
+ */
+{
+	register int 		i;
+	register word		temp;
+	register longword	ltmp;
+
+	for (i = 1; i &lt;= 8; i++, LARp++) {
+
+		/* temp = GSM_ABS( *LARp );
+	         *
+		 * if (temp &lt; 11059) temp &lt;&lt;= 1;
+		 * else if (temp &lt; 20070) temp += 11059;
+		 * else temp = GSM_ADD( temp &gt;&gt; 2, 26112 );
+		 *
+		 * *LARp = *LARp &lt; 0 ? -temp : temp;
+		 */
+
+		if (*LARp &lt; 0) {
+			temp = *LARp == MIN_WORD ? MAX_WORD : -(*LARp);
+			*LARp = - ((temp &lt; 11059) ? temp &lt;&lt; 1
+				: ((temp &lt; 20070) ? temp + 11059
+				:  GSM_ADD( temp &gt;&gt; 2, 26112 )));
+		} else {
+			temp  = *LARp;
+			*LARp =    (temp &lt; 11059) ? temp &lt;&lt; 1
+				: ((temp &lt; 20070) ? temp + 11059
+				:  GSM_ADD( temp &gt;&gt; 2, 26112 ));
+		}
+	}
+}
+
+
+/* 4.2.10 */
+static void Short_term_analysis_filtering P4((S,rp,k_n,s),
+	struct gsm_state * S,
+	register word	* rp,	/* [0..7]	IN	*/
+	register int 	k_n, 	/*   k_end - k_start	*/
+	register word	* s	/* [0..n-1]	IN/OUT	*/
+)
+/*
+ *  This procedure computes the short term residual signal d[..] to be fed
+ *  to the RPE-LTP loop from the s[..] signal and from the local rp[..]
+ *  array (quantized reflection coefficients).  As the call of this
+ *  procedure can be done in many ways (see the interpolation of the LAR
+ *  coefficient), it is assumed that the computation begins with index
+ *  k_start (for arrays d[..] and s[..]) and stops with index k_end
+ *  (k_start and k_end are defined in 4.2.9.1).  This procedure also
+ *  needs to keep the array u[0..7] in memory for each call.
+ */
+{
+	register word		* u = S-&gt;u;
+	register int		i;
+	register word		di, zzz, ui, sav, rpi;
+	register longword 	ltmp;
+
+	for (; k_n--; s++) {
+
+		di = sav = *s;
+
+		for (i = 0; i &lt; 8; i++) {		/* YYY */
+
+			ui    = u[i];
+			rpi   = rp[i];
+			u[i]  = sav;
+
+			zzz   = GSM_MULT_R(rpi, di);
+			sav   = GSM_ADD(   ui,  zzz);
+
+			zzz   = GSM_MULT_R(rpi, ui);
+			di    = GSM_ADD(   di,  zzz );
+		}
+
+		*s = di;
+	}
+}
+
+#if defined(USE_FLOAT_MUL) &amp;&amp; defined(FAST)
+
+static void Fast_Short_term_analysis_filtering P4((S,rp,k_n,s),
+	struct gsm_state * S,
+	register word	* rp,	/* [0..7]	IN	*/
+	register int 	k_n, 	/*   k_end - k_start	*/
+	register word	* s	/* [0..n-1]	IN/OUT	*/
+)
+{
+	register word		* u = S-&gt;u;
+	register int		i;
+
+	float 	  uf[8],
+		 rpf[8];
+
+	register float scalef = 3.0517578125e-5;
+	register float		sav, di, temp;
+
+	for (i = 0; i &lt; 8; ++i) {
+		uf[i]  = u[i];
+		rpf[i] = rp[i] * scalef;
+	}
+	for (; k_n--; s++) {
+		sav = di = *s;
+		for (i = 0; i &lt; 8; ++i) {
+			register float rpfi = rpf[i];
+			register float ufi  = uf[i];
+
+			uf[i] = sav;
+			temp  = rpfi * di + ufi;
+			di   += rpfi * ufi;
+			sav   = temp;
+		}
+		*s = di;
+	}
+	for (i = 0; i &lt; 8; ++i) u[i] = uf[i];
+}
+#endif /* ! (defined (USE_FLOAT_MUL) &amp;&amp; defined (FAST)) */
+
+static void Short_term_synthesis_filtering P5((S,rrp,k,wt,sr),
+	struct gsm_state * S,
+	register word	* rrp,	/* [0..7]	IN	*/
+	register int	k,	/* k_end - k_start	*/
+	register word	* wt,	/* [0..k-1]	IN	*/
+	register word	* sr	/* [0..k-1]	OUT	*/
+)
+{
+	register word		* v = S-&gt;v;
+	register int		i;
+	register word		sri, tmp1, tmp2;
+	register longword	ltmp;	/* for GSM_ADD  &amp; GSM_SUB */
+
+	while (k--) {
+		sri = *wt++;
+		for (i = 8; i--;) {
+
+			/* sri = GSM_SUB( sri, gsm_mult_r( rrp[i], v[i] ) );
+			 */
+			tmp1 = rrp[i];
+			tmp2 = v[i];
+			tmp2 =  ( tmp1 == MIN_WORD &amp;&amp; tmp2 == MIN_WORD
+				? MAX_WORD
+				: 0x0FFFF &amp; (( (longword)tmp1 * (longword)tmp2
+					     + 16384) &gt;&gt; 15)) ;
+
+			sri  = GSM_SUB( sri, tmp2 );
+
+			/* v[i+1] = GSM_ADD( v[i], gsm_mult_r( rrp[i], sri ) );
+			 */
+			tmp1  = ( tmp1 == MIN_WORD &amp;&amp; sri == MIN_WORD
+				? MAX_WORD
+				: 0x0FFFF &amp; (( (longword)tmp1 * (longword)sri
+					     + 16384) &gt;&gt; 15)) ;
+
+			v[i+1] = GSM_ADD( v[i], tmp1);
+		}
+		*sr++ = v[0] = sri;
+	}
+}
+
+
+#if defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
+
+static void Fast_Short_term_synthesis_filtering P5((S,rrp,k,wt,sr),
+	struct gsm_state * S,
+	register word	* rrp,	/* [0..7]	IN	*/
+	register int	k,	/* k_end - k_start	*/
+	register word	* wt,	/* [0..k-1]	IN	*/
+	register word	* sr	/* [0..k-1]	OUT	*/
+)
+{
+	register word		* v = S-&gt;v;
+	register int		i;
+
+	float va[9], rrpa[8];
+	register float scalef = 3.0517578125e-5, temp;
+
+	for (i = 0; i &lt; 8; ++i) {
+		va[i]   = v[i];
+		rrpa[i] = (float)rrp[i] * scalef;
+	}
+	while (k--) {
+		register float sri = *wt++;
+		for (i = 8; i--;) {
+			sri -= rrpa[i] * va[i];
+			if     (sri &lt; -32768.) sri = -32768.;
+			else if (sri &gt; 32767.) sri =  32767.;
+
+			temp = va[i] + rrpa[i] * sri;
+			if     (temp &lt; -32768.) temp = -32768.;
+			else if (temp &gt; 32767.) temp =  32767.;
+			va[i+1] = temp;
+		}
+		*sr++ = va[0] = sri;
+	}
+	for (i = 0; i &lt; 9; ++i) v[i] = va[i];
+}
+
+#endif /* defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL) */
+
+void Gsm_Short_Term_Analysis_Filter P3((S,LARc,s),
+
+	struct gsm_state * S,
+
+	word	* LARc,		/* coded log area ratio [0..7]  IN	*/
+	word	* s		/* signal [0..159]		IN/OUT	*/
+)
+{
+	word		* LARpp_j	= S-&gt;LARpp[ S-&gt;j      ];
+	word		* LARpp_j_1	= S-&gt;LARpp[ S-&gt;j ^= 1 ];
+
+	word		LARp[8];
+
+#undef	FILTER
+#if 	defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
+# 	define	FILTER 	(* (S-&gt;fast			\
+			   ? Fast_Short_term_analysis_filtering	\
+		    	   : Short_term_analysis_filtering	))
+
+#else
+# 	define	FILTER	Short_term_analysis_filtering
+#endif
+
+	Decoding_of_the_coded_Log_Area_Ratios( LARc, LARpp_j );
+
+	Coefficients_0_12(  LARpp_j_1, LARpp_j, LARp );
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, s);
+
+	Coefficients_13_26( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 14, s + 13);
+
+	Coefficients_27_39( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, s + 27);
+
+	Coefficients_40_159( LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 120, s + 40);
+}
+
+void Gsm_Short_Term_Synthesis_Filter P4((S, LARcr, wt, s),
+	struct gsm_state * S,
+
+	word	* LARcr,	/* received log area ratios [0..7] IN  */
+	word	* wt,		/* received d [0..159]		   IN  */
+
+	word	* s		/* signal   s [0..159]		  OUT  */
+)
+{
+	word		* LARpp_j	= S-&gt;LARpp[ S-&gt;j     ];
+	word		* LARpp_j_1	= S-&gt;LARpp[ S-&gt;j ^=1 ];
+
+	word		LARp[8];
+
+#undef	FILTER
+#if 	defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
+
+# 	define	FILTER 	(* (S-&gt;fast			\
+			   ? Fast_Short_term_synthesis_filtering	\
+		    	   : Short_term_synthesis_filtering	))
+#else
+#	define	FILTER	Short_term_synthesis_filtering
+#endif
+
+	Decoding_of_the_coded_Log_Area_Ratios( LARcr, LARpp_j );
+
+	Coefficients_0_12( LARpp_j_1, LARpp_j, LARp );
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, wt, s );
+
+	Coefficients_13_26( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 14, wt + 13, s + 13 );
+
+	Coefficients_27_39( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, wt + 27, s + 27 );
+
+	Coefficients_40_159( LARpp_j, LARp );
+	LARp_to_rp( LARp );
+	FILTER(S, LARp, 120, wt + 40, s + 40);
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include &lt;stdio.h&gt;
+#include &lt;assert.h&gt;
+
+#include &quot;private.h&quot;
+
+#include &quot;gsm.h&quot;
+#include &quot;proto.h&quot;
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 

Modified: trunk/codecs/gsm/src/table.c
===================================================================
--- trunk/codecs/gsm/src/table.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/table.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -61,3 +61,66 @@
  */
 /* i                  0      1       2      3      4      5      6      7   */
 word gsm_FAC[8]	= { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+/*  Most of these tables are inlined at their point of use.
+ */
+
+/*  4.4 TABLES USED IN THE FIXED POINT IMPLEMENTATION OF THE RPE-LTP
+ *      CODER AND DECODER
+ *
+ *	(Most of them inlined, so watch out.)
+ */
+
+#define	GSM_TABLE_C
+#include &quot;private.h&quot;
+#include	&quot;gsm.h&quot;
+
+/*  Table 4.1  Quantization of the Log.-Area Ratios
+ */
+/* i 		     1      2      3        4      5      6        7       8 */
+word gsm_A[8]   = {20480, 20480, 20480,  20480,  13964,  15360,   8534,  9036};
+word gsm_B[8]   = {    0,     0,  2048,  -2560,     94,  -1792,   -341, -1144};
+word gsm_MIC[8] = { -32,   -32,   -16,    -16,     -8,     -8,     -4,    -4 };
+word gsm_MAC[8] = {  31,    31,    15,     15,      7,      7,      3,     3 };
+
+
+/*  Table 4.2  Tabulation  of 1/A[1..8]
+ */
+word gsm_INVA[8]={ 13107, 13107,  13107, 13107,  19223, 17476,  31454, 29708 };
+
+
+/*   Table 4.3a  Decision level of the LTP gain quantizer
+ */
+/*  bc		      0	        1	  2	     3			*/
+word gsm_DLB[4] = {  6554,    16384,	26214,	   32767	};
+
+
+/*   Table 4.3b   Quantization levels of the LTP gain quantizer
+ */
+/* bc		      0          1        2          3			*/
+word gsm_QLB[4] = {  3277,    11469,	21299,	   32767	};
+
+
+/*   Table 4.4	 Coefficients of the weighting filter
+ */
+/* i		    0      1   2    3   4      5      6     7   8   9    10  */
+word gsm_H[11] = {-134, -374, 0, 2054, 5741, 8192, 5741, 2054, 0, -374, -134 };
+
+
+/*   Table 4.5 	 Normalized inverse mantissa used to compute xM/xmax 
+ */
+/* i		 	0        1    2      3      4      5     6      7   */
+word gsm_NRFAC[8] = { 29128, 26215, 23832, 21846, 20165, 18725, 17476, 16384 };
+
+
+/*   Table 4.6	 Normalized direct mantissa used to compute xM/xmax
+ */
+/* i                  0      1       2      3      4      5      6      7   */
+word gsm_FAC[8]	= { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };

Modified: trunk/codecs/slin_gsm_ex.h
===================================================================
--- trunk/codecs/slin_gsm_ex.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/slin_gsm_ex.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,3 +1,31 @@
+/*
+  * Signed 16-bit audio data
+  *
+  * Source: gsm.example
+  *
+  * Copyright (C) 1999, Mark Spencer and Linux Support Services
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+static signed short slin_gsm_ex[] = {
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 0xfff8, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 0x0008, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+0x0008, 000000, 000000, 000000, 0xfff8, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 0x0008, 000000, 000000, 000000 };
 /*! \file
   * \brief Signed 16-bit audio data
   *


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000412.html">[solid-pbx-svn] r417 - in trunk: . apps codecs include/asterisk pbx
</A></li>
	<LI>Next message: <A HREF="000414.html">[solid-pbx-svn] r419 - trunk/codecs/gsm/inc
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#413">[ date ]</a>
              <a href="thread.html#413">[ thread ]</a>
              <a href="subject.html#413">[ subject ]</a>
              <a href="author.html#413">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
