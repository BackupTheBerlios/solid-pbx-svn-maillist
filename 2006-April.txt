From casper2 at berlios.de  Sat Apr 29 04:51:58 2006
From: casper2 at berlios.de (casper2 at berlios.de)
Date: Sat, 29 Apr 2006 04:51:58 +0200
Subject: [Solid-pbx-svn] r3 - in trunk: . apps build_tools channels configs include/asterisk pbx pbx/ael pbx/ael/ael-test utils
Message-ID: <200604290251.k3T2pw5q014322@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 04:51:28 +0200 (Sat, 29 Apr 2006)
New Revision: 3

Modified:
   trunk/Makefile
   trunk/acinclude.m4
   trunk/apps/app_directory.c
   trunk/apps/app_meetme.c
   trunk/apps/app_queue.c
   trunk/apps/app_voicemail.c
   trunk/apps/app_while.c
   trunk/ast_expr2.fl
   trunk/ast_expr2f.c
   trunk/asterisk.c
   trunk/build_tools/menuselect-deps.in
   trunk/build_tools/prep_moduledeps
   trunk/channel.c
   trunk/channels/chan_sip.c
   trunk/channels/chan_zap.c
   trunk/channels/misdn_config.c
   trunk/cli.c
   trunk/configs/mgcp.conf.sample
   trunk/configs/misdn.conf.sample
   trunk/configs/sip.conf.sample
   trunk/configs/zapata.conf.sample
   trunk/configure.ac
   trunk/http.c
   trunk/include/asterisk/ael_structs.h
   trunk/pbx/ael/ael-test/runtests
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael.tab.c
   trunk/pbx/ael/ael.tab.h
   trunk/pbx/ael/ael.y
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/pbx_ael.c
   trunk/rtp.c
   trunk/utils/Makefile
   trunk/utils/ael_main.c
Log:
Update to Asterisk SVN trunk r23270

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/Makefile	2006-04-29 02:51:28 UTC (rev 3)
@@ -564,6 +564,8 @@
 	$(MAKE) -C db1-ast clean
 	$(MAKE) -C stdtime clean
 
+distclean: dist-clean
+
 dist-clean: clean
 	rm -f menuselect.makeopts makeopts makeopts.xml
 	rm -f config.log config.status

Modified: trunk/acinclude.m4
===================================================================
--- trunk/acinclude.m4	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/acinclude.m4	2006-04-29 02:51:28 UTC (rev 3)
@@ -20,8 +20,7 @@
 PBX_LIB$1=0
 
 if test "${USE_$1}" != "no"; then	
-   AC_CHECK_LIB([$1], [$2], AC_DEFINE_UNQUOTED([HAVE_$4], 1,
-   [Define to indicate the $5 library]), [], -L${$1_DIR}/lib $6)
+   AC_CHECK_LIB([$1], [$2], [], [], -L${$1_DIR}/lib $6)
 
    if test "${ac_cv_lib_$1_$2}" = "yes"; then
       $1_LIB="-l$1 $6"
@@ -51,6 +50,7 @@
          PBX_LIB$1=0
       else
          PBX_LIB$1=1
+         AC_DEFINE_UNQUOTED([HAVE_$4], 1, [Define to indicate the $5 library])
       fi
    elif test ! -z "${$1_MANDATORY}";
    then

Modified: trunk/apps/app_directory.c
===================================================================
--- trunk/apps/app_directory.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_directory.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22082 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23067 $")
 
 #include "asterisk/lock.h"
 #include "asterisk/file.h"
@@ -153,19 +153,22 @@
  *           '1' for selected entry from directory
  *           '*' for skipped entry from directory
  */
-static int play_mailbox_owner(struct ast_channel *chan, char *context, char *dialcontext, char *ext, char *name, int readext) {
+static int play_mailbox_owner(struct ast_channel *chan, char *context,
+		char *dialcontext, char *ext, char *name, int readext)
+{
 	int res = 0;
-	int loop = 3;
+	int loop;
 	char fn[256];
-	char fn2[256];
 
 	/* Check for the VoiceMail2 greeting first */
 	snprintf(fn, sizeof(fn), "%s/voicemail/%s/%s/greet",
-		(char *)ast_config_AST_SPOOL_DIR, context, ext);
+		ast_config_AST_SPOOL_DIR, context, ext);
 
-	/* Otherwise, check for an old-style Voicemail greeting */
-	snprintf(fn2, sizeof(fn2), "%s/vm/%s/greet",
-		(char *)ast_config_AST_SPOOL_DIR, ext);
+	if (ast_fileexists(fn, NULL, chan->language) <= 0) {
+		/* no file, check for an old-style Voicemail greeting */
+		snprintf(fn, sizeof(fn), "%s/vm/%s/greet",
+			ast_config_AST_SPOOL_DIR, ext);
+	}
 
 	if (ast_fileexists(fn, NULL, chan->language) > 0) {
 		res = ast_stream_and_wait(chan, fn, chan->language, AST_DIGIT_ANY);
@@ -175,14 +178,6 @@
 			ast_stream_and_wait(chan, "vm-extension", chan->language, AST_DIGIT_ANY);
 			res = ast_say_character_str(chan, ext, AST_DIGIT_ANY, chan->language);
 		}
-	} else if (ast_fileexists(fn2, NULL, chan->language) > 0) {
-		res = ast_stream_and_wait(chan, fn2, chan->language, AST_DIGIT_ANY);
-		ast_stopstream(chan);
-		/* If Option 'e' was specified, also read the extension number with the name */
-		if (readext) {
-			ast_stream_and_wait(chan, "vm-extension", chan->language, AST_DIGIT_ANY);
-			res = ast_say_character_str(chan, ext, AST_DIGIT_ANY, chan->language);
-		}
 	} else {
 		res = ast_say_character_str(chan, S_OR(name, ext), AST_DIGIT_ANY, chan->language);
 		if (!ast_strlen_zero(name) && readext) {
@@ -191,45 +186,32 @@
 		}
 	}
 
-	while (loop) {
+	for (loop = 3 ; loop > 0; loop--) {
 		if (!res)
 			res = ast_stream_and_wait(chan, "dir-instr", chan->language, AST_DIGIT_ANY);
 		if (!res)
 			res = ast_waitfordigit(chan, 3000);
 		ast_stopstream(chan);
 	
-		if (res > -1) {
-			switch (res) {
-				case '1':
-					/* Name selected */
-					loop = 0;
-					if (ast_goto_if_exists(chan, dialcontext, ext, 1)) {
-						ast_log(LOG_WARNING,
-							"Can't find extension '%s' in context '%s'.  "
-							"Did you pass the wrong context to Directory?\n",
-							ext, dialcontext);
-						res = -1;
-					}
-					break;
-	
-				case '*':   
-					/* Skip to next match in list */
-					loop = 0;
-					break;
-	
-				default:
-					/* Not '1', or '*', so decrement number of tries */
-					res = 0;
-					loop--;
-					break;
-			} /* end switch */
-		} /* end if */
-		else {
-			/* User hungup, so jump out now */
-			loop = 0;
+		if (res < 0) /* User hungup, so jump out now */
+			break;
+		if (res == '1') {	/* Name selected */
+			if (ast_goto_if_exists(chan, dialcontext, ext, 1)) {
+				ast_log(LOG_WARNING,
+					"Can't find extension '%s' in context '%s'.  "
+					"Did you pass the wrong context to Directory?\n",
+					ext, dialcontext);
+				res = -1;
+			}
+			break;
 		}
-	} /* end while */
+		if (res == '*') /* Skip to next match in list */
+			break;
 
+		/* Not '1', or '*', so decrement number of tries */
+		res = 0;
+	}
+
 	return(res);
 }
 

Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_meetme.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -44,7 +44,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22267 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22931 $")
 
 #include "asterisk/lock.h"
 #include "asterisk/file.h"
@@ -92,7 +92,8 @@
 "      'D' -- dynamically add conference, prompting for a PIN\n"
 "      'e' -- select an empty conference\n"
 "      'E' -- select an empty pinless conference\n"
-"      'i' -- announce user join/leave\n"
+"      'i' -- announce user join/leave with review\n"
+"      'I' -- announce user join/leave without review\n"
 "      'm' -- set monitor only mode (Listen only, no talking)\n"
 "      'M' -- enable music on hold when the conference has a single caller\n"
 "      'o' -- set talker optimization - treats talkers who aren't speaking as\n"
@@ -253,8 +254,8 @@
 #define CONFFLAG_ANNOUNCEUSERCOUNT (1 << 22)	/* If set, when user joins the conference, they will be told the number of users that are already in */
 #define CONFFLAG_OPTIMIZETALKER (1 << 23)	/* If set, treats talking users as muted users */
 #define CONFFLAG_NOONLYPERSON (1 << 24)		/* If set, won't speak the extra prompt when the first person enters the conference */
+#define CONFFLAG_INTROUSERNOREVIEW (1 << 25) /* If set, user will be asked to record name on entry of conference without review */
 
-
 AST_APP_OPTIONS(meetme_opts, {
 	AST_APP_OPTION('A', CONFFLAG_MARKEDUSER ),
 	AST_APP_OPTION('a', CONFFLAG_ADMIN ),
@@ -265,6 +266,7 @@
 	AST_APP_OPTION('E', CONFFLAG_EMPTYNOPIN ),
 	AST_APP_OPTION('e', CONFFLAG_EMPTY ),
 	AST_APP_OPTION('i', CONFFLAG_INTROUSER ),
+	AST_APP_OPTION('I', CONFFLAG_INTROUSERNOREVIEW ),
 	AST_APP_OPTION('M', CONFFLAG_MOH ),
 	AST_APP_OPTION('m', CONFFLAG_MONITOR ),
 	AST_APP_OPTION('o', CONFFLAG_OPTIMIZETALKER ),
@@ -951,11 +953,14 @@
 			ast_copy_string(exitcontext, chan->context, sizeof(exitcontext));
 	}
 
-	if (!(confflags & CONFFLAG_QUIET) && (confflags & CONFFLAG_INTROUSER)) {
+	if (!(confflags & CONFFLAG_QUIET) && ((confflags & CONFFLAG_INTROUSER) || (confflags & CONFFLAG_INTROUSERNOREVIEW))) {
 		snprintf(user->namerecloc, sizeof(user->namerecloc),
 			 "%s/meetme/meetme-username-%s-%d", ast_config_AST_SPOOL_DIR,
 			 conf->confno, user->user_no);
-		res = ast_record_review(chan, "vm-rec-name", user->namerecloc, 10, "sln", &duration, NULL);
+		if (confflags & CONFFLAG_INTROUSERNOREVIEW)
+			res = ast_play_and_record(chan, "vm-rec-name", user->namerecloc, 10, "sln", &duration, 128, 0, NULL);
+		else
+			res = ast_record_review(chan, "vm-rec-name", user->namerecloc, 10, "sln", &duration, NULL);
 		if (res == -1)
 			goto outrun;
 	}
@@ -1088,7 +1093,7 @@
 
 	ast_mutex_lock(&conf->playlock);
 
-	if (!(confflags & CONFFLAG_QUIET) && (confflags & CONFFLAG_INTROUSER) && conf->users > 1) {
+	if (!(confflags & CONFFLAG_QUIET) && ((confflags & CONFFLAG_INTROUSER) || (confflags & CONFFLAG_INTROUSERNOREVIEW)) && conf->users > 1) {
 		if (conf->chan && ast_fileexists(user->namerecloc, NULL, NULL)) {
 			if (!ast_streamfile(conf->chan, user->namerecloc, chan->language))
 				ast_waitstream(conf->chan, "");
@@ -1646,7 +1651,7 @@
 	if (!(confflags & CONFFLAG_QUIET) && !(confflags & CONFFLAG_MONITOR) && !(confflags & CONFFLAG_ADMIN))
 		conf_play(chan, conf, LEAVE);
 
-	if (!(confflags & CONFFLAG_QUIET) && (confflags & CONFFLAG_INTROUSER)) {
+	if (!(confflags & CONFFLAG_QUIET) && ((confflags & CONFFLAG_INTROUSER) || (confflags & CONFFLAG_INTROUSERNOREVIEW))) {
 		if (ast_fileexists(user->namerecloc, NULL, NULL)) {
 			if ((conf->chan) && (conf->users > 1)) {
 				if (!ast_streamfile(conf->chan, user->namerecloc, chan->language))

Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_queue.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -68,7 +68,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 21821 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22655 $")
 
 #include "asterisk/lock.h"
 #include "asterisk/file.h"
@@ -3132,8 +3132,47 @@
 			}
 		}
 		ast_mutex_unlock(&q->lock);
+	} else
+		ast_log(LOG_WARNING, "queue %s was not found\n", data);
+
+	snprintf(buf, len, "%d", count);
+	LOCAL_USER_REMOVE(lu);
+	return 0;
+}
+
+static int queue_function_queuewaitingcount(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
+{
+	int count = 0;
+	struct ast_call_queue *q;
+	struct localuser *lu;
+
+	buf[0] = '\0';
+	
+	if (ast_strlen_zero(data)) {
+		ast_log(LOG_ERROR, "%s requires an argument: queuename\n", cmd);
+		return -1;
 	}
 
+	LOCAL_USER_ADD(lu);
+	
+	AST_LIST_LOCK(&queues);
+
+	/* Find the right queue */
+	AST_LIST_TRAVERSE(&queues, q, list) {
+		if (!strcasecmp(q->name, data)) {
+			ast_mutex_lock(&q->lock);
+			break;
+		}
+	}
+
+	AST_LIST_UNLOCK(&queues);
+
+	if (q) {
+		count = q->count;
+		ast_mutex_unlock(&q->lock);
+	} else
+		ast_log(LOG_WARNING, "queue %s was not found\n", data);
+
 	snprintf(buf, len, "%d", count);
 	LOCAL_USER_REMOVE(lu);
 	return 0;
@@ -3184,7 +3223,8 @@
 			}
 		}
 		ast_mutex_unlock(&q->lock);
-	}
+	} else
+		ast_log(LOG_WARNING, "queue %s was not found\n", data);
 
 	/* We should already be terminated, but let's make sure. */
 	buf[len - 1] = '\0';
@@ -3211,6 +3251,15 @@
 	.read = queue_function_qac,
 };
 
+static struct ast_custom_function queuewaitingcount_function = {
+	.name = "QUEUE_WAITING_COUNT",
+	.synopsis = "Count number of calls currently waiting in a queue",
+	.syntax = "QUEUE_WAITING_COUNT(<queuename>)",
+	.desc = 
+"Returns the number of callers currently waiting in the specified queue.\n",
+	.read = queue_function_queuewaitingcount,
+};
+
 static struct ast_custom_function queuememberlist_function = {
 	.name = "QUEUE_MEMBER_LIST",
 	.synopsis = "Returns a list of interfaces on a queue",
@@ -3870,6 +3919,7 @@
 	res |= ast_custom_function_unregister(&queueagentcount_function);
 	res |= ast_custom_function_unregister(&queuemembercount_function);
 	res |= ast_custom_function_unregister(&queuememberlist_function);
+	res |= ast_custom_function_unregister(&queuewaitingcount_function);
 	res |= ast_unregister_application(app);
 
 	STANDARD_HANGUP_LOCALUSERS;
@@ -3899,6 +3949,7 @@
 	res |= ast_custom_function_register(&queueagentcount_function);
 	res |= ast_custom_function_register(&queuemembercount_function);
 	res |= ast_custom_function_register(&queuememberlist_function);
+	res |= ast_custom_function_register(&queuewaitingcount_function);
 
 	if (!res) {	
 		reload_queues();

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_voicemail.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -54,7 +54,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22268 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23250 $")
 
 #include "asterisk/lock.h"
 #include "asterisk/file.h"
@@ -245,10 +245,10 @@
 };
 
 struct vm_zone {
+	AST_LIST_ENTRY(vm_zone) list;
 	char name[80];
 	char timezone[80];
 	char msg_format[512];
-	struct vm_zone *next;
 };
 
 struct vm_state {
@@ -388,8 +388,7 @@
 static char *app4 = "VMAuthenticate";
 
 static AST_LIST_HEAD_STATIC(users, ast_vm_user);
-struct vm_zone *zones = NULL;
-struct vm_zone *zonesl = NULL;
+static AST_LIST_HEAD_STATIC(zones, vm_zone);
 static int maxsilence;
 static int maxmsg;
 static int silencethreshold = 128;
@@ -1655,9 +1654,12 @@
 	/* Does this user have a timezone specified? */
 	if (!ast_strlen_zero(vmu->zonetag)) {
 		/* Find the zone in the list */
-		for (z = zones; z ; z = z->next)
+		AST_LIST_LOCK(&zones);
+		AST_LIST_TRAVERSE(&zones, z, list) {
 			if (!strcmp(z->name, vmu->zonetag))
 				break;
+		}
+		AST_LIST_UNLOCK(&zones);
 	}
 	ast_localtime(&t, tm, z ? z->timezone : NULL);
 	return tm;
@@ -3426,8 +3428,8 @@
 		/* start optimistic */
 		valid_extensions = 1;
 		while (s) {
-			/* find_user is going to ast_malloc since we have a NULL as first argument */
-			if ((receiver = find_user(NULL, context, s))) {
+			/* Don't forward to ourselves.  find_user is going to malloc since we have a NULL as first argument */
+			if (strcmp(s,sender->mailbox) && (receiver = find_user(NULL, context, s))) {
 				AST_LIST_INSERT_HEAD(&extensions, receiver, list);
 				found++;
 			} else {
@@ -3592,12 +3594,14 @@
 	if (!ast_strlen_zero(vmu->zonetag)) {
 		/* Find the zone in the list */
 		struct vm_zone *z;
-		for (z = zones; z; z = z->next) {
+		AST_LIST_LOCK(&zones);
+		AST_LIST_TRAVERSE(&zones, z, list) {
 			if (!strcmp(z->name, vmu->zonetag)) {
 				the_zone = z;
 				break;
 			}
 		}
+		AST_LIST_UNLOCK(&zones);
 	}
 
 /* No internal variable parsing for now, so we'll comment it out for the time being */
@@ -5858,22 +5862,26 @@
 
 static int handle_show_voicemail_zones(int fd, int argc, char *argv[])
 {
-	struct vm_zone *zone = zones;
+	struct vm_zone *zone;
 	char *output_format = "%-15s %-20s %-45s\n";
+	int res = RESULT_SUCCESS;
 
-	if (argc != 3) return RESULT_SHOWUSAGE;
+	if (argc != 3)
+		return RESULT_SHOWUSAGE;
 
-	if (zone) {
+	AST_LIST_LOCK(&zones);
+	if (!AST_LIST_EMPTY(&zones)) {
 		ast_cli(fd, output_format, "Zone", "Timezone", "Message Format");
-		while (zone) {
+		AST_LIST_TRAVERSE(&zones, zone, list) {
 			ast_cli(fd, output_format, zone->name, zone->timezone, zone->msg_format);
-			zone = zone->next;
 		}
 	} else {
 		ast_cli(fd, "There are no voicemail zones currently defined\n");
-		return RESULT_FAILURE;
+		res = RESULT_FAILURE;
 	}
-	return RESULT_SUCCESS;
+	AST_LIST_UNLOCK(&zones);
+
+	return res;
 }
 
 static char *complete_show_voicemail_users(const char *line, const char *word, int pos, int state)
@@ -5913,7 +5921,7 @@
 static int load_config(void)
 {
 	struct ast_vm_user *cur;
-	struct vm_zone *zcur, *zl;
+	struct vm_zone *zcur;
 	struct ast_config *cfg;
 	char *cat;
 	struct ast_variable *var;
@@ -5950,21 +5958,18 @@
 	int tmpadsi[4];
 
 	cfg = ast_config_load(VOICEMAIL_CONFIG);
+
 	AST_LIST_LOCK(&users);
-	AST_LIST_TRAVERSE_SAFE_BEGIN(&users, cur, list) {
-		AST_LIST_REMOVE_CURRENT(&users, list);
+	while ((cur = AST_LIST_REMOVE_HEAD(&users, list))) {
 		ast_set_flag(cur, VM_ALLOCED);	
 		free_user(cur);
 	}
-	AST_LIST_TRAVERSE_SAFE_END;
-	zcur = zones;
-	while (zcur) {
-		zl = zcur;
-		zcur = zcur->next;
-		free_zone(zl);
-	}
-	zones = NULL;
-	zonesl = NULL;
+
+	AST_LIST_LOCK(&zones);
+	while ((zcur = AST_LIST_REMOVE_HEAD(&zones, list))) 
+		free_zone(zcur);
+	AST_LIST_UNLOCK(&zones);
+
 	memset(ext_pass_cmd, 0, sizeof(ext_pass_cmd));
 
 	if (cfg) {
@@ -6232,14 +6237,9 @@
 									ast_copy_string(z->name, var->name, sizeof(z->name));
 									ast_copy_string(z->timezone, timezone, sizeof(z->timezone));
 									ast_copy_string(z->msg_format, msg_format, sizeof(z->msg_format));
-									z->next = NULL;
-									if (zones) {
-										zonesl->next = z;
-										zonesl = z;
-									} else {
-										zones = z;
-										zonesl = z;
-									}
+									AST_LIST_LOCK(&zones);
+									AST_LIST_INSERT_HEAD(&zones, z, list);
+									AST_LIST_UNLOCK(&zones);
 								} else {
 									ast_log(LOG_WARNING, "Invalid timezone definition at line %d\n", var->lineno);
 									free(z);

Modified: trunk/apps/app_while.c
===================================================================
--- trunk/apps/app_while.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_while.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -32,7 +32,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 20003 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22573 $")
 
 #include "asterisk/file.h"
 #include "asterisk/logger.h"
@@ -52,7 +52,7 @@
 "Usage:  ExecIF (<expr>|<app>|<data>)\n"
 "If <expr> is true, execute and return the result of <app>(<data>).\n"
 "If <expr> is true, but <app> is not found, then the application\n"
-"will return a non-zero value.";
+"will return a non-zero value.\n";
 static char *exec_synopsis = "Conditional exec";
 
 static char *start_app = "While";
@@ -61,16 +61,28 @@
 "Start a While Loop.  Execution will return to this point when\n"
 "EndWhile is called until expr is no longer true.\n";
 
-static char *start_synopsis = "Start A While Loop";
+static char *start_synopsis = "Start a while loop";
 
 
 static char *stop_app = "EndWhile";
 static char *stop_desc = 
 "Usage:  EndWhile()\n"
-"Return to the previous called While\n\n";
+"Return to the previous called While\n";
 
-static char *stop_synopsis = "End A While Loop";
+static char *stop_synopsis = "End a while loop";
 
+static char *exit_app = "ExitWhile";
+static char *exit_desc =
+"Usage:  ExitWhile()\n"
+"Exits a While loop, whether or not the conditional has been satisfied.\n";
+static char *exit_synopsis = "End a While loop";
+
+static char *continue_app = "ContinueWhile";
+static char *continue_desc =
+"Usage:  ContinueWhile()\n"
+"Returns to the top of the while loop and re-evaluates the conditional.\n";
+static char *continue_synopsis = "Restart a While loop";
+
 static char *tdesc = "While Loops and Conditional Execution";
 
 LOCAL_USER_DECL;
@@ -265,7 +277,7 @@
 	}
 	
 
-	if (!end && !ast_true(condition)) {
+	if ((!end && !ast_true(condition)) || (end == 2)) {
 		/* Condition Met (clean up helper vars) */
 		const char *goto_str;
 		pbx_builtin_setvar_helper(chan, varname, NULL);
@@ -324,7 +336,29 @@
 	return _while_exec(chan, data, 1);
 }
 
+static int while_exit_exec(struct ast_channel *chan, void *data) {
+	return _while_exec(chan, data, 2);
+}
 
+static int while_continue_exec(struct ast_channel *chan, void *data)
+{
+	int x;
+	const char *prefix = "WHILE", *while_pri=NULL;
+
+	for (x = 0; ; x++) {
+		const char *tmp = get_index(chan, prefix, x);
+		if (tmp)
+			while_pri = tmp;
+		else
+			break;
+	}
+
+	if (while_pri)
+		ast_parseable_goto(chan, while_pri);
+
+	return 0;
+}
+
 static int unload_module(void *mod)
 {
 	int res;
@@ -332,6 +366,8 @@
 	res = ast_unregister_application(start_app);
 	res |= ast_unregister_application(exec_app);
 	res |= ast_unregister_application(stop_app);
+	res |= ast_unregister_application(exit_app);
+	res |= ast_unregister_application(continue_app);
 
 	STANDARD_HANGUP_LOCALUSERS;
 
@@ -345,6 +381,8 @@
 	res = ast_register_application(start_app, while_start_exec, start_synopsis, start_desc);
 	res |= ast_register_application(exec_app, execif_exec, exec_synopsis, exec_desc);
 	res |= ast_register_application(stop_app, while_end_exec, stop_synopsis, stop_desc);
+	res |= ast_register_application(exit_app, while_exit_exec, exit_synopsis, exit_desc);
+	res |= ast_register_application(continue_app, while_continue_exec, continue_synopsis, continue_desc);
 
 	return res;
 }

Modified: trunk/ast_expr2.fl
===================================================================
--- trunk/ast_expr2.fl	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/ast_expr2.fl	2006-04-29 02:51:28 UTC (rev 3)
@@ -39,7 +39,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22273 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23175 $")
 
 #include "asterisk/ast_expr.h"
 #include "asterisk/logger.h"
@@ -59,10 +59,24 @@
 
 #include "ast_expr2.h" /* the o/p of the bison on ast_expr2.y */
 
-#define SET_COLUMNS yylloc_param->first_column = (int)(yyg->yytext_r - YY_CURRENT_BUFFER_LVALUE->yy_ch_buf);yylloc_param->last_column = yylloc_param->last_column + yyleng - 1; yylloc_param->first_line = yylloc_param->last_line = 1
-#define SET_STRING yylval_param->val = (struct val *)calloc(sizeof(struct val),1); yylval_param->val->type = AST_EXPR_string; yylval_param->val->u.s = strdup(yytext);
-#define SET_NUMERIC_STRING yylval_param->val = (struct val *)calloc(sizeof(struct val),1); yylval_param->val->type = AST_EXPR_numeric_string; yylval_param->val->u.s = strdup(yytext);
+#define SET_COLUMNS	do {		\
+	yylloc_param->first_column = (int)(yyg->yytext_r - YY_CURRENT_BUFFER_LVALUE->yy_ch_buf); \
+	yylloc_param->last_column += yyleng - 1; \
+	yylloc_param->first_line = yylloc_param->last_line = 1; \
+	} while (0)
 
+#define SET_STRING	do {		\
+	yylval_param->val = calloc(1, sizeof(struct val));	\
+	yylval_param->val->type = AST_EXPR_string;		\
+	yylval_param->val->u.s = strdup(yytext);		\
+	} while (0)
+
+#define SET_NUMERIC_STRING	do {	\
+	yylval_param->val = calloc(1, sizeof(struct val));	\
+	yylval_param->val->type = AST_EXPR_numeric_string;	\
+	yylval_param->val->u.s = strdup(yytext);	\
+	} while (0)
+
 struct parse_io
 {
 	char *string;
@@ -110,26 +124,82 @@
 \:\:	{ SET_COLUMNS; SET_STRING; return TOK_COLONCOLON;}
 \(	{ SET_COLUMNS; SET_STRING; return TOK_LP;}
 \)	{ SET_COLUMNS; SET_STRING; return TOK_RP;}
-\$\{   {/* gather the contents of ${} expressions, with trailing stuff, into a single TOKEN. They are much more complex now than they used to be */
-                       curlycount = 0; BEGIN(var); yymore();}
+\$\{	{
+		/* gather the contents of ${} expressions, with trailing stuff,
+		 * into a single TOKEN.
+		 * They are much more complex now than they used to be
+		 */
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
 
-[ 	\r]		{}
-\"[^"]*\"   {SET_COLUMNS; SET_STRING; return TOKEN;}
+[ \t\r]		{}
+\"[^"]*\"	{SET_COLUMNS; SET_STRING; return TOKEN;}
 
-[\n]	{/* what to do with eol */}
-[0-9]+		{   SET_COLUMNS;  /* the original behavior of the expression parser was to bring in numbers as a numeric string */
-				SET_NUMERIC_STRING;
-				return TOKEN;}
+[\n]		{/* what to do with eol */}
+[0-9]+		{
+		SET_COLUMNS;
+		/* the original behavior of the expression parser was
+		 * to bring in numbers as a numeric string
+		 */
+		SET_NUMERIC_STRING;
+		return TOKEN;
+	}
 
-[a-zA-Z0-9,.';\\_^$#@]+	{SET_COLUMNS; SET_STRING; return TOKEN;}
+[a-zA-Z0-9,.';\\_^$#@]+	{
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 
-<var>[^{}]*\}  {curlycount--; if(curlycount < 0){ BEGIN(trail);  yymore();} else {  yymore();}}
-<var>[^{}]*\{  {curlycount++; yymore();  }
-<trail>[^-\t\r \n$():?%/+=*<>!|&]* {BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN;}
-<trail>[-\t\r \n$():?%/+=*<>!|&]        {char c = yytext[yyleng-1]; BEGIN(0); unput(c); SET_COLUMNS; SET_STRING; return TOKEN;}
-<trail>\$\{            {curlycount = 0; BEGIN(var); yymore();  }
-<trail><<EOF>>		{BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN; /*actually, if an expr is only a variable ref, this could happen a LOT */}
 
+<var>[^{}]*\}	{
+		curlycount--;
+		if (curlycount < 0) {
+			BEGIN(trail);
+			yymore();
+		} else {
+			yymore();
+		}
+	}
+	
+<var>[^{}]*\{	{
+		curlycount++;
+		yymore();
+	}
+	
+
+<trail>[^-\t\r \n$():?%/+=*<>!|&]*	{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
+	
+<trail>[-\t\r \n$():?%/+=*<>!|&]	{
+		char c = yytext[yyleng-1];
+		BEGIN(0);
+		unput(c);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
+	
+<trail>\$\{	{
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
+	
+<trail><<EOF>>	{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+		/*actually, if an expr is only a variable ref, this could happen a LOT */
+	}
+
 %%
 
 /* I'm putting the interface routine to the whole parse here in the flexer input file

Modified: trunk/ast_expr2f.c
===================================================================
--- trunk/ast_expr2f.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/ast_expr2f.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -9,7 +9,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 31
+#define YY_FLEX_SUBMINOR_VERSION 33
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -31,7 +31,15 @@
 
 /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
 
-#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
+#if __STDC_VERSION__ >= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
 #include <inttypes.h>
 typedef int8_t flex_int8_t;
 typedef uint8_t flex_uint8_t;
@@ -154,6 +162,10 @@
 #define YY_BUF_SIZE 16384
 #endif
 
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
 #ifndef YY_TYPEDEF_YY_BUFFER_STATE
 #define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
@@ -1359,7 +1371,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22273 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23175 $")
 
 #include "asterisk/ast_expr.h"
 #include "asterisk/logger.h"
@@ -1379,10 +1391,24 @@
 
 #include "ast_expr2.h" /* the o/p of the bison on ast_expr2.y */
 
-#define SET_COLUMNS yylloc_param->first_column = (int)(yyg->yytext_r - YY_CURRENT_BUFFER_LVALUE->yy_ch_buf);yylloc_param->last_column = yylloc_param->last_column + yyleng - 1; yylloc_param->first_line = yylloc_param->last_line = 1
-#define SET_STRING yylval_param->val = (struct val *)calloc(sizeof(struct val),1); yylval_param->val->type = AST_EXPR_string; yylval_param->val->u.s = strdup(yytext);
-#define SET_NUMERIC_STRING yylval_param->val = (struct val *)calloc(sizeof(struct val),1); yylval_param->val->type = AST_EXPR_numeric_string; yylval_param->val->u.s = strdup(yytext);
+#define SET_COLUMNS	do {		\
+	yylloc_param->first_column = (int)(yyg->yytext_r - YY_CURRENT_BUFFER_LVALUE->yy_ch_buf); \
+	yylloc_param->last_column += yyleng - 1; \
+	yylloc_param->first_line = yylloc_param->last_line = 1; \
+	} while (0)
 
+#define SET_STRING	do {		\
+	yylval_param->val = calloc(1, sizeof(struct val));	\
+	yylval_param->val->type = AST_EXPR_string;		\
+	yylval_param->val->u.s = strdup(yytext);		\
+	} while (0)
+
+#define SET_NUMERIC_STRING	do {	\
+	yylval_param->val = calloc(1, sizeof(struct val));	\
+	yylval_param->val->type = AST_EXPR_numeric_string;	\
+	yylval_param->val->u.s = strdup(yytext);	\
+	} while (0)
+
 struct parse_io
 {
 	char *string;
@@ -1395,17 +1421,19 @@
 static int curlycount = 0;
 static char *expr2_token_subst(char *mess);
 
-#line 1394 "ast_expr2f.c"
+#line 1425 "ast_expr2f.c"
 
 #define INITIAL 0
 #define var 1
 #define trail 2
 
+#ifndef YY_NO_UNISTD_H
 /* Special case for "unistd.h", since it is non-ANSI. We include it way
  * down here because we want the user's section 1 to have been scanned first.
  * The user has a chance to override it with an option.
  */
 #include <unistd.h>
+#endif
 
 #ifndef YY_EXTRA_TYPE
 #define YY_EXTRA_TYPE void *
@@ -1449,6 +1477,8 @@
 
     }; /* end struct yyguts_t */
 
+static int yy_init_globals (yyscan_t yyscanner );
+
     /* This must go here because YYSTYPE and YYLTYPE are included
      * from bison output in section 1.*/
     #    define yylval yyg->yylval_r
@@ -1583,9 +1613,11 @@
 #ifndef YY_DECL
 #define YY_DECL_IS_OURS 1
 
-extern int ast_yylex (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
+extern int ast_yylex \
+               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
 
-#define YY_DECL int ast_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
+#define YY_DECL int ast_yylex \
+               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
 #endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
@@ -1612,18 +1644,18 @@
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 83 "ast_expr2.fl"
+#line 102 "ast_expr2.fl"
 
 
-#line 1614 "ast_expr2f.c"
+#line 1651 "ast_expr2f.c"
 
     yylval = yylval_param;
 
     yylloc = yylloc_param;
 
-	if ( yyg->yy_init )
+	if ( !yyg->yy_init )
 		{
-		yyg->yy_init = 0;
+		yyg->yy_init = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
@@ -1698,192 +1730,241 @@
 
 case 1:
 YY_RULE_SETUP
-#line 85 "ast_expr2.fl"
+#line 104 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_OR;}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 86 "ast_expr2.fl"
+#line 105 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_AND;}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 87 "ast_expr2.fl"
+#line 106 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_EQ;}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 88 "ast_expr2.fl"
+#line 107 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_OR;}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 89 "ast_expr2.fl"
+#line 108 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_AND;}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 90 "ast_expr2.fl"
+#line 109 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_EQ;}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 91 "ast_expr2.fl"
+#line 110 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_EQTILDE;}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 92 "ast_expr2.fl"
+#line 111 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_GT;}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 93 "ast_expr2.fl"
+#line 112 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_LT;}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 94 "ast_expr2.fl"
+#line 113 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_GE;}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 95 "ast_expr2.fl"
+#line 114 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_LE;}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 96 "ast_expr2.fl"
+#line 115 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_NE;}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 97 "ast_expr2.fl"
+#line 116 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_PLUS;}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 98 "ast_expr2.fl"
+#line 117 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_MINUS;}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 99 "ast_expr2.fl"
+#line 118 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_MULT;}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 100 "ast_expr2.fl"
+#line 119 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_DIV;}
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 101 "ast_expr2.fl"
+#line 120 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_MOD;}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 102 "ast_expr2.fl"
+#line 121 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COND;}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 103 "ast_expr2.fl"
+#line 122 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COMPL;}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 104 "ast_expr2.fl"
+#line 123 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COLON;}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 105 "ast_expr2.fl"
+#line 124 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COLONCOLON;}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 106 "ast_expr2.fl"
+#line 125 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_LP;}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 107 "ast_expr2.fl"
+#line 126 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_RP;}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 108 "ast_expr2.fl"
-{/* gather the contents of ${} expressions, with trailing stuff, into a single TOKEN. They are much more complex now than they used to be */
-                       curlycount = 0; BEGIN(var); yymore();}
+#line 127 "ast_expr2.fl"
+{
+		/* gather the contents of ${} expressions, with trailing stuff,
+		 * into a single TOKEN.
+		 * They are much more complex now than they used to be
+		 */
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 111 "ast_expr2.fl"
+#line 137 "ast_expr2.fl"
 {}
 	YY_BREAK
 case 26:
 /* rule 26 can match eol */
 YY_RULE_SETUP
-#line 112 "ast_expr2.fl"
+#line 138 "ast_expr2.fl"
 {SET_COLUMNS; SET_STRING; return TOKEN;}
 	YY_BREAK
 case 27:
 /* rule 27 can match eol */
 YY_RULE_SETUP
-#line 114 "ast_expr2.fl"
+#line 140 "ast_expr2.fl"
 {/* what to do with eol */}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 115 "ast_expr2.fl"
-{   SET_COLUMNS;  /* the original behavior of the expression parser was to bring in numbers as a numeric string */
-				SET_NUMERIC_STRING;
-				return TOKEN;}
+#line 141 "ast_expr2.fl"
+{
+		SET_COLUMNS;
+		/* the original behavior of the expression parser was
+		 * to bring in numbers as a numeric string
+		 */
+		SET_NUMERIC_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 119 "ast_expr2.fl"
-{SET_COLUMNS; SET_STRING; return TOKEN;}
+#line 150 "ast_expr2.fl"
+{
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 30:
 /* rule 30 can match eol */
 YY_RULE_SETUP
-#line 121 "ast_expr2.fl"
-{curlycount--; if(curlycount < 0){ BEGIN(trail);  yymore();} else {  yymore();}}
+#line 157 "ast_expr2.fl"
+{
+		curlycount--;
+		if (curlycount < 0) {
+			BEGIN(trail);
+			yymore();
+		} else {
+			yymore();
+		}
+	}
 	YY_BREAK
 case 31:
 /* rule 31 can match eol */
 YY_RULE_SETUP
-#line 122 "ast_expr2.fl"
-{curlycount++; yymore();  }
+#line 167 "ast_expr2.fl"
+{
+		curlycount++;
+		yymore();
+	}
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 123 "ast_expr2.fl"
-{BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN;}
+#line 173 "ast_expr2.fl"
+{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 33:
 /* rule 33 can match eol */
 YY_RULE_SETUP
-#line 124 "ast_expr2.fl"
-{char c = yytext[yyleng-1]; BEGIN(0); unput(c); SET_COLUMNS; SET_STRING; return TOKEN;}
+#line 180 "ast_expr2.fl"
+{
+		char c = yytext[yyleng-1];
+		BEGIN(0);
+		unput(c);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 125 "ast_expr2.fl"
-{curlycount = 0; BEGIN(var); yymore();  }
+#line 189 "ast_expr2.fl"
+{
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
 	YY_BREAK
 case YY_STATE_EOF(trail):
-#line 126 "ast_expr2.fl"
-{BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN; /*actually, if an expr is only a variable ref, this could happen a LOT */}
+#line 195 "ast_expr2.fl"
+{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+		/*actually, if an expr is only a variable ref, this could happen a LOT */
+	}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 128 "ast_expr2.fl"
+#line 203 "ast_expr2.fl"
 ECHO;
 	YY_BREAK
-#line 1882 "ast_expr2f.c"
+#line 1968 "ast_expr2f.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(var):
 	yyterminate();
@@ -2071,7 +2152,7 @@
 
 	else
 		{
-			size_t num_to_read =
+			int num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
@@ -2185,7 +2266,7 @@
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
 {
 	register int yy_is_jam;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
 	register char *yy_cp = yyg->yy_c_buf_p;
 
 	yy_current_state = yy_NUL_trans[yy_current_state];
@@ -2625,16 +2706,16 @@
 
 /** Setup the input buffer state to scan a string. The next call to ast_yylex() will
  * scan from a @e copy of @a str.
- * @param str a NUL-terminated string to scan
+ * @param yystr a NUL-terminated string to scan
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
  *       ast_yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE ast_yy_scan_string (yyconst char * str , yyscan_t yyscanner)
+YY_BUFFER_STATE ast_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
 {
     
-	return ast_yy_scan_bytes(str,strlen(str) ,yyscanner);
+	return ast_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to ast_yylex() will
@@ -2644,7 +2725,7 @@
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE ast_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
+YY_BUFFER_STATE ast_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
 	char *buf;
@@ -2652,15 +2733,15 @@
 	int i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
+	n = _yybytes_len + 2;
 	buf = (char *) ast_yyalloc(n ,yyscanner );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in ast_yy_scan_bytes()" );
 
-	for ( i = 0; i < len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i < _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
 	b = ast_yy_scan_buffer(buf,n ,yyscanner);
 	if ( ! b )
@@ -2871,21 +2952,51 @@
     yylloc = yylloc_param;
 }
     
+/* User-visible API */
+
+/* ast_yylex_init is special because it creates the scanner itself, so it is
+ * the ONLY reentrant function that doesn't take the scanner as the last argument.
+ * That's why we explicitly handle the declaration, instead of using our macros.
+ */
+
+int ast_yylex_init(yyscan_t* ptr_yy_globals)
+
+{
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+
+    *ptr_yy_globals = (yyscan_t) ast_yyalloc ( sizeof( struct yyguts_t ), NULL );
+
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+
+    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
 static int yy_init_globals (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
     /* Initialization is the same as for the non-reentrant scanner.
-       This function is called once per scanner lifetime. */
+     * This function is called from ast_yylex_destroy(), so don't allocate here.
+     */
 
     yyg->yy_buffer_stack = 0;
     yyg->yy_buffer_stack_top = 0;
     yyg->yy_buffer_stack_max = 0;
     yyg->yy_c_buf_p = (char *) 0;
-    yyg->yy_init = 1;
+    yyg->yy_init = 0;
     yyg->yy_start = 0;
+
     yyg->yy_start_stack_ptr = 0;
     yyg->yy_start_stack_depth = 0;
-    yyg->yy_start_stack = (int *) 0;
+    yyg->yy_start_stack =  NULL;
 
 /* Defined in main.c */
 #ifdef YY_STDINIT
@@ -2902,33 +3013,6 @@
     return 0;
 }
 
-/* User-visible API */
-
-/* ast_yylex_init is special because it creates the scanner itself, so it is
- * the ONLY reentrant function that doesn't take the scanner as the last argument.
- * That's why we explicitly handle the declaration, instead of using our macros.
- */
-
-int ast_yylex_init(yyscan_t* ptr_yy_globals)
-
-{
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) ast_yyalloc ( sizeof( struct yyguts_t ), NULL );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    memset(*ptr_yy_globals,0,sizeof(struct yyguts_t));
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
 /* ast_yylex_destroy is for both reentrant and non-reentrant scanners. */
 int ast_yylex_destroy  (yyscan_t yyscanner)
 {
@@ -2949,8 +3033,13 @@
         ast_yyfree(yyg->yy_start_stack ,yyscanner );
         yyg->yy_start_stack = NULL;
 
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ast_yylex() is called, initialization will occur. */
+    yy_init_globals( yyscanner);
+
     /* Destroy the main struct (reentrant only). */
     ast_yyfree ( yyscanner , yyscanner );
+    yyscanner = NULL;
     return 0;
 }
 
@@ -2962,7 +3051,6 @@
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
 {
 	register int i;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
@@ -2972,7 +3060,6 @@
 static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
 {
 	register int n;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -3004,22 +3091,10 @@
 
 #define YYTABLES_NAME "yytables"
 
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef yytext_ptr
-#undef YY_DO_BEFORE_ACTION
+#line 203 "ast_expr2.fl"
 
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
-#endif
-#line 128 "ast_expr2.fl"
 
 
-
 /* I'm putting the interface routine to the whole parse here in the flexer input file
    mainly because of all the flexer initialization that has to be done. Shouldn't matter
    where it is, as long as it's somewhere. I didn't want to define a prototype for the

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/asterisk.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -92,7 +92,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 21451 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23229 $")
 
 #include "asterisk/logger.h"
 #include "asterisk/options.h"
@@ -224,6 +224,13 @@
 char ast_config_AST_CTL[AST_CONFIG_MAX_PATH] = "asterisk.ctl";
 char ast_config_AST_SYSTEM_NAME[20] = "";
 
+extern const char *ast_build_hostname;
+extern const char *ast_build_kernel;
+extern const char *ast_build_machine;
+extern const char *ast_build_os;
+extern const char *ast_build_date;
+extern const char *ast_build_user;
+
 static char *_argv[256];
 static int shuttingdown = 0;
 static int restartnow = 0;
@@ -1271,6 +1278,20 @@
 "Usage: show license\n"
 "	Shows the license(s) for this copy of Asterisk.\n";
 
+static char version_help[] =
+"Usage: show version\n"
+"       Shows Asterisk version information.\n";
+
+static int handle_version(int fd, int argc, char *argv[])
+{
+	if (argc != 2)
+		return RESULT_SHOWUSAGE;
+	ast_cli(fd, "Asterisk %s built by %s @ %s on a %s running %s on %s\n",
+		ASTERISK_VERSION, ast_build_user, ast_build_hostname,
+		ast_build_machine, ast_build_os, ast_build_date);
+	return RESULT_SUCCESS;
+}
+
 #if 0
 static int handle_quit(int fd, int argc, char *argv[])
 {
@@ -1431,6 +1452,8 @@
 	  "Show the warranty (if any) for this copy of Asterisk", show_warranty_help },
 	{ { "show", "license", NULL }, show_license,
 	  "Show the license(s) for this copy of Asterisk", show_license_help },
+	{ { "show", "version", NULL }, handle_version, 
+	  "Display version info", version_help },
 	{ { "!", NULL }, handle_bang,
 	  "Execute a shell command", bang_help },
 #if !defined(LOW_MEMORY)

Modified: trunk/build_tools/menuselect-deps.in
===================================================================
--- trunk/build_tools/menuselect-deps.in	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/build_tools/menuselect-deps.in	2006-04-29 02:51:28 UTC (rev 3)
@@ -15,7 +15,6 @@
 OGG=@PBX_LIBogg@
 OSSAUDIO=@PBX_LIBossaudio@
 PGSQL=@PBX_LIBpq@
-PTLIB=@PBX_LIBPWLIB@
 QT=@PBX_QT@
 SQLITE=@PBX_LIBsqlite@
 SSL=@PBX_LIBssl@
@@ -25,3 +24,4 @@
 ZLIB=@PBX_LIBz@
 ZAPTEL=@PBX_LIBtonezone@
 LIBGSM=@PBX_LIBgsm@
+IXJUSER=@PBX_IXJUSER@

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/build_tools/prep_moduledeps	2006-04-29 02:51:28 UTC (rev 3)
@@ -25,7 +25,7 @@
 process_dir channels chan CHANNELS "Channel Drivers"
 process_dir codecs codec CODECS "Codec Translators"
 process_dir formats format FORMATS "Format Interpreters"
-process_dir funcs func FUNCS "Diaplan Functions"
+process_dir funcs func FUNCS "Dialplan Functions"
 process_dir pbx pbx PBX "PBX Modules"
 process_dir res res RES "Resource Modules"
 cat build_tools/cflags.xml

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channel.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -46,7 +46,7 @@
 #endif
 #endif
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22267 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22631 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/frame.h"
@@ -313,9 +313,9 @@
 static int ast_check_hangup_locked(struct ast_channel *chan)
 {
 	int res;
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 	res = ast_check_hangup(chan);
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -682,13 +682,13 @@
 		ast_log(LOG_WARNING, "Unable to duplicate frame\n");
 		return -1;
 	}
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 	prev = NULL;
 	for (cur = chan->readq; cur; cur = cur->next) {
 		if ((cur->frametype == AST_FRAME_CONTROL) && (cur->subclass == AST_CONTROL_HANGUP)) {
 			/* Don't bother actually queueing anything after a hangup */
 			ast_frfree(f);
-			ast_mutex_unlock(&chan->lock);
+			ast_channel_unlock(chan);
 			return 0;
 		}
 		prev = cur;
@@ -702,7 +702,7 @@
 		} else {
 			ast_log(LOG_DEBUG, "Dropping voice to exceptionally long queue on %s\n", chan->name);
 			ast_frfree(f);
-			ast_mutex_unlock(&chan->lock);
+			ast_channel_unlock(chan);
 			return 0;
 		}
 	}
@@ -721,7 +721,7 @@
 	} else if (ast_test_flag(chan, AST_FLAG_BLOCKING)) {
 		pthread_kill(chan->blocker, SIGURG);
 	}
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return 0;
 }
 
@@ -730,9 +730,9 @@
 {
 	struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_HANGUP };
 	/* Yeah, let's not change a lock-critical value without locking */
-	if (!ast_mutex_trylock(&chan->lock)) {
+	if (!ast_channel_trylock(chan)) {
 		chan->_softhangup |= AST_SOFTHANGUP_DEV;
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	}
 	return ast_queue_frame(chan, &f);
 }
@@ -821,7 +821,8 @@
 			break;
 		}
 		/* exit if chan not found or mutex acquired successfully */
-		done = c == NULL || ast_mutex_trylock(&c->lock) == 0;
+		/* this is slightly unsafe, as we _should_ hold the lock to access c->name */
+		done = c == NULL || ast_channel_trylock(c) == 0;
 		if (!done)
 			ast_log(LOG_DEBUG, "Avoiding %s for channel '%p'\n", msg, c);
 		AST_LIST_UNLOCK(&channels);
@@ -926,8 +927,8 @@
 	AST_LIST_REMOVE(&channels, chan, chan_list);
 	/* Lock and unlock the channel just to be sure nobody
 	   has it locked still */
-	ast_mutex_lock(&chan->lock);
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_lock(chan);
+	ast_channel_unlock(chan);
 	if (chan->tech_pvt) {
 		ast_log(LOG_WARNING, "Channel '%s' may not have been hung up properly\n", chan->name);
 		free(chan->tech_pvt);
@@ -1241,9 +1242,9 @@
 int ast_softhangup(struct ast_channel *chan, int cause)
 {
 	int res;
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 	res = ast_softhangup_nolock(chan, cause);
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -1474,7 +1475,7 @@
 	ast_channel_lock(chan);
 	/* Stop if we're a zombie or need a soft hangup */
 	if (ast_test_flag(chan, AST_FLAG_ZOMBIE) || ast_check_hangup(chan)) {
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 		return -1;
 	}
 	switch(chan->_state) {
@@ -1497,7 +1498,7 @@
 
 void ast_deactivate_generator(struct ast_channel *chan)
 {
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 	if (chan->generatordata) {
 		if (chan->generator && chan->generator->release)
 			chan->generator->release(chan, chan->generatordata);
@@ -1507,7 +1508,7 @@
 		ast_clear_flag(chan, AST_FLAG_WRITE_INT);
 		ast_settimeout(chan, 0, NULL, NULL);
 	}
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 }
 
 static int generator_force(void *data)
@@ -2054,7 +2055,7 @@
 	chan->fin = FRAMECOUNT_INC(chan->fin);
 
 done:
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return f;
 }
 
@@ -2625,11 +2626,11 @@
 	   return anyway.  */
 	int res = -1;
 	/* Stop if we're a zombie or need a soft hangup */
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 	if (!ast_test_flag(chan, AST_FLAG_ZOMBIE) && !ast_check_hangup(chan))
 		if (chan->tech->call)
 			res = chan->tech->call(chan, addr, timeout);
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -2645,7 +2646,7 @@
 	int res = -1;
 
 	/* Stop if we're a zombie or need a soft hangup */
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 	if (!ast_test_flag(chan, AST_FLAG_ZOMBIE) && !ast_check_hangup(chan)) {
 		if (chan->tech->transfer) {
 			res = chan->tech->transfer(chan, dest);
@@ -2654,7 +2655,7 @@
 		} else
 			res = 0;
 	}
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -2786,11 +2787,11 @@
 		ast_log(LOG_WARNING, "Can't masquerade channel '%s' into itself!\n", original->name);
 		return -1;
 	}
-	ast_mutex_lock(&original->lock);
-	while(ast_mutex_trylock(&clone->lock)) {
-		ast_mutex_unlock(&original->lock);
+	ast_channel_lock(original);
+	while(ast_channel_trylock(clone)) {
+		ast_channel_unlock(original);
 		usleep(1);
-		ast_mutex_lock(&original->lock);
+		ast_channel_lock(original);
 	}
 	ast_log(LOG_DEBUG, "Planning to masquerade channel %s into the structure of %s\n",
 		clone->name, original->name);
@@ -2808,8 +2809,8 @@
 		ast_log(LOG_DEBUG, "Done planning to masquerade channel %s into the structure of %s\n", clone->name, original->name);
 		res = 0;
 	}
-	ast_mutex_unlock(&clone->lock);
-	ast_mutex_unlock(&original->lock);
+	ast_channel_unlock(clone);
+	ast_channel_unlock(original);
 	return res;
 }
 

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channels/chan_sip.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -105,7 +105,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22267 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23178 $")
 
 #include "asterisk/lock.h"
 #include "asterisk/channel.h"
@@ -8384,6 +8384,7 @@
 		ast_cli(fd,"\n");
 		ASTOBJ_UNREF(peer,sip_destroy_peer);
 	} else  if (peer && type == 1) { /* manager listing */
+		char buf[256];
 		astman_append(s, "Channeltype: SIP\r\n");
 		astman_append(s, "ObjectName: %s\r\n", peer->name);
 		astman_append(s, "ChanObjectType: peer\r\n");
@@ -8400,9 +8401,9 @@
 		if (!ast_strlen_zero(peer->fromdomain))
 			astman_append(s, "SIP-FromDomain: %s\r\n", peer->fromdomain);
 		astman_append(s, "Callgroup: ");
-		print_group(fd, peer->callgroup, 1);
+		astman_append(s, "%s\r\n", ast_print_group(buf, sizeof(buf), peer->callgroup));
 		astman_append(s, "Pickupgroup: ");
-		print_group(fd, peer->pickupgroup, 1);
+		astman_append(s, "%s\r\n", ast_print_group(buf, sizeof(buf), peer->pickupgroup));
 		astman_append(s, "VoiceMailbox: %s\r\n", peer->mailbox);
 		astman_append(s, "TransferMode: %s\r\n", transfermode2str(peer->allowtransfer));
 		astman_append(s, "LastMsgsSent: %d\r\n", peer->lastmsgssent);

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channels/chan_zap.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -77,7 +77,7 @@
 #include <libmfcr2.h>
 #endif
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22267 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22932 $")
 
 #include "asterisk/lock.h"
 #include "asterisk/channel.h"
@@ -386,7 +386,7 @@
 	return j;
 }
 
-/*! Chunk size to read -- we use 20ms chunks to make things happy.  */   
+/*! Chunk size to read -- we use 20ms chunks to make things happy.  */
 #define READ_SIZE 160
 
 #define MASK_AVAIL		(1 << 0)	/*!< Channel available for PRI use */
@@ -9315,7 +9315,7 @@
 					ast_log(LOG_WARNING, "Received SETUP_ACKNOWLEDGE on unconfigured channel %d/%d span %d\n", 
 						PRI_SPAN(e->setup_ack.channel), PRI_CHANNEL(e->setup_ack.channel), pri->span);
 				} else {
-					chanpos = pri_fixup_principle(pri, chanpos, e->ring.call);
+					chanpos = pri_fixup_principle(pri, chanpos, e->setup_ack.call);
 					if (chanpos > -1) {
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
 						pri->pvts[chanpos]->setup_ack = 1;
@@ -9844,6 +9844,47 @@
 	return RESULT_FAILURE;
 }
 
+static int setup_zap(int reload);
+static int zap_restart(void)
+{
+	if (option_verbose > 0)
+		ast_verbose(VERBOSE_PREFIX_1 "Destroying channels and reloading zaptel configuration.\n");
+	while (iflist) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Destroying zaptel channel no. %d\n", iflist->channel);
+		/* Also updates iflist: */
+		destroy_channel(NULL, iflist, 1);
+	}
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Channels destroyed. Now re-reading config.\n");
+	if (setup_zap(0) != 0) {
+		ast_log(LOG_WARNING, "Reload channels from zap config failed!\n");
+		return 1;
+	}
+	return 0;
+}
+
+static int zap_restart_cmd(int fd, int argc, char **argv)
+{
+	if (argc != 2) {
+		return RESULT_SHOWUSAGE;
+	}
+
+	if (zap_restart() != 0)
+		return RESULT_FAILURE;
+	return RESULT_SUCCESS;
+}
+
+static int action_zaprestart(struct mansession *s, struct message *m)
+{
+	if (zap_restart() != 0) {
+		astman_send_error(s, m, "Failed rereading zaptel configuration");
+		return 1;
+	}
+	astman_send_ack(s, m, "ZapRestart: Success");
+	return 0;
+}
+
 static int zap_show_channels(int fd, int argc, char **argv)
 {
 #define FORMAT "%7s %-10.10s %-15.15s %-10.10s %-20.20s\n"
@@ -10153,6 +10194,13 @@
 	"Usage: zap destroy channel <chan num>\n"
 	"	DON'T USE THIS UNLESS YOU KNOW WHAT YOU ARE DOING.  Immediately removes a given channel, whether it is in use or not\n";
 
+static char zap_restart_usage[] =
+	"Usage: zap restart\n"
+	"	Restarts the zaptel channels: destroys them all and then\n"
+	"	re-reads them from zapata.conf.\n"
+	"	Note that this will STOP any running CALL on zaptel channels.\n"
+	"";
+
 static struct ast_cli_entry zap_cli[] = {
 	{ { "zap", "show", "cadences", NULL }, handle_zap_show_cadences,
 	  "List cadences", zap_show_cadences_help },
@@ -10162,6 +10210,8 @@
 	  "Show information on a channel", show_channel_usage },
 	{ {"zap", "destroy", "channel", NULL}, zap_destroy_channel,
 	  "Destroy a channel", destroy_channel_usage },
+	{ {"zap", "restart", NULL}, zap_restart_cmd,
+	  "Fully restart zaptel channels", zap_restart_usage },
 	{ {"zap", "show", "status", NULL}, zap_show_status,
 	  "Show all Zaptel cards status", zap_show_status_usage },
 };
@@ -11332,6 +11382,7 @@
 	ast_manager_register( "ZapDNDon", 0, action_zapdndon, "Toggle Zap channel Do Not Disturb status ON" );
 	ast_manager_register( "ZapDNDoff", 0, action_zapdndoff, "Toggle Zap channel Do Not Disturb status OFF" );
 	ast_manager_register("ZapShowChannels", 0, action_zapshowchannels, "Show status zapata channels");
+	ast_manager_register("ZapRestart", 0, action_zaprestart, "Fully Restart zaptel channels (terminates calls)");
 
 	return res;
 }

Modified: trunk/channels/misdn_config.c
===================================================================
--- trunk/channels/misdn_config.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channels/misdn_config.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -121,7 +121,7 @@
 static const struct misdn_cfg_spec gen_spec[] = {
 	{ "debug", MISDN_GEN_DEBUG, MISDN_CTYPE_INT, "0", NONE },
 	{ "misdn_init", MISDN_GEN_MISDN_INIT, MISDN_CTYPE_STR, "/etc/misdn-init.conf", NONE },
-	{ "tracefile", MISDN_GEN_TRACEFILE, MISDN_CTYPE_STR, "/var/log/misdn.trace", NONE },
+	{ "tracefile", MISDN_GEN_TRACEFILE, MISDN_CTYPE_STR, "/var/log/asterisk/misdn.log", NONE },
 	{ "bridging", MISDN_GEN_BRIDGING, MISDN_CTYPE_BOOL, "yes", NONE },
 	{ "stop_tone_after_first_digit", MISDN_GEN_STOP_TONE, MISDN_CTYPE_BOOL, "yes", NONE },
 	{ "append_digits2exten", MISDN_GEN_APPEND_DIGITS2EXTEN, MISDN_CTYPE_BOOL, "yes", NONE },

Modified: trunk/cli.c
===================================================================
--- trunk/cli.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/cli.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -34,7 +34,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 21933 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 23229 $")
 
 #include "asterisk/logger.h"
 #include "asterisk/options.h"
@@ -51,15 +51,7 @@
 /* For rl_filename_completion */
 #include "editline/readline/readline.h"
 /* For module directory */
-#include "asterisk/version.h"
 
-extern const char *ast_build_hostname;
-extern const char *ast_build_kernel;
-extern const char *ast_build_machine;
-extern const char *ast_build_os;
-extern const char *ast_build_date;
-extern const char *ast_build_user;
-
 extern unsigned long global_fin, global_fout;
 	
 void ast_cli(int fd, char *fmt, ...)
@@ -292,10 +284,6 @@
 "Usage: show modules [like keyword]\n"
 "       Shows Asterisk modules currently in use, and usage statistics.\n";
 
-static char version_help[] =
-"Usage: show version\n"
-"       Shows Asterisk version information.\n";
-
 static char uptime_help[] =
 "Usage: show uptime [seconds]\n"
 "       Shows Asterisk uptime information.\n"
@@ -390,16 +378,6 @@
 #undef MODLIST_FORMAT
 #undef MODLIST_FORMAT2
 
-static int handle_version(int fd, int argc, char *argv[])
-{
-	if (argc != 2)
-		return RESULT_SHOWUSAGE;
-	ast_cli(fd, "Asterisk %s built by %s @ %s on a %s running %s on %s\n",
-		ASTERISK_VERSION, ast_build_user, ast_build_hostname,
-		ast_build_machine, ast_build_os, ast_build_date);
-	return RESULT_SUCCESS;
-}
-
 static int handle_chanlist(int fd, int argc, char *argv[])
 {
 #define FORMAT_STRING  "%-20.20s %-20.20s %-7.7s %-30.30s\n"
@@ -941,7 +919,6 @@
 	{ { "show", "modules", NULL }, handle_modlist, "List modules and info", modlist_help },
 	{ { "show", "modules", "like", NULL }, handle_modlist, "List modules and info", modlist_help, complete_mod_4 },
  	{ { "show", "uptime", NULL }, handle_showuptime, "Show uptime information", uptime_help },
-	{ { "show", "version", NULL }, handle_version, "Display version info", version_help },
 	{ { "soft", "hangup", NULL }, handle_softhangup, "Request a hangup on a given channel", softhangup_help, complete_ch_3 },
 	{ { "unload", NULL }, handle_unload, "Unload a dynamic module by name", unload_help, complete_fn },
 	{ { NULL }, NULL, NULL, NULL }

Modified: trunk/configs/mgcp.conf.sample
===================================================================
--- trunk/configs/mgcp.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/mgcp.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -27,8 +27,8 @@
 ;context=local 
 ;host=192.168.1.20 
 ;callerid = "John Doe" <123> 
-;callgroup=0 
-;pickupgroup=0
+;callgroup=0      ; in the range from 0 to 63
+;pickupgroup=0    ; in the range from 0 to 63
 ;nat=no 
 ;threewaycalling=yes 
 ;transfer=yes     ; transfer requires threewaycalling=yes. Use FLASH to transfer

Modified: trunk/configs/misdn.conf.sample
===================================================================
--- trunk/configs/misdn.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/misdn.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -29,7 +29,7 @@
 ;
 ; default value: [not set]
 ;
-;tracefile=/var/log/misdn.trace
+;tracefile=/var/log/asterisk/misdn.log
 
 
 ; set to yes if you want mISDN_dsp to bridge the calls in HW
@@ -233,6 +233,7 @@
 ; Pickup and Callgroup
 ;
 ; deafult values: not set = 0
+; range: 0-63
 ;
 ;callgroup=1
 ;pickupgroup=1

Modified: trunk/configs/sip.conf.sample
===================================================================
--- trunk/configs/sip.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/sip.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -473,6 +473,9 @@
 ;qualify=1000			; Consider it down if it's 1 second to reply
 				; Helps with NAT session
 				; qualify=yes uses default value
+;
+; Call group and Pickup group should be in the range from 0 to 63
+;
 ;callgroup=1,3-4		; We are in caller groups 1,3,4
 ;pickupgroup=1,3-5		; We can do call pick-p for call group 1,3,4,5
 ;defaultip=192.168.0.60		; IP address to use if peer has not registred

Modified: trunk/configs/zapata.conf.sample
===================================================================
--- trunk/configs/zapata.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/zapata.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -354,7 +354,7 @@
 ; Ring groups (a.k.a. call groups) and pickup groups.  If a phone is ringing
 ; and it is a member of a group which is one of your pickup groups, then
 ; you can answer it by picking up and dialing *8#.  For simple offices, just
-; make these both the same
+; make these both the same.  Groups range from 0 to 63.
 ;
 callgroup=1
 pickupgroup=1

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configure.ac	2006-04-29 02:51:28 UTC (rev 3)
@@ -20,7 +20,7 @@
 AC_CONFIG_HEADER(include/autoconfig.h)
 
 AC_COPYRIGHT("Asterisk")
-AC_REVISION($Revision: 22346 $)
+AC_REVISION($Revision: 22990 $)
 
 AC_PREFIX_DEFAULT()
 
@@ -160,7 +160,7 @@
 AST_EXT_LIB([asound], [snd_spcm_init], [alsa/asoundlib.h], [ALSA], [Advanced Linux Sound Architecture], [-lm -ldl])
 AST_EXT_LIB([curses], [initscr], [curses.h], [CURSES], [curses], [])
 AST_EXT_LIB([mfcr2], [mfcr2_MakeCall], [libmfcr2.h], [MFCR2], [MFCR2])
-AST_EXT_LIB([nbs], [nbs_setup], [nbs.h], [NBS], [Network Broadcast Sound])
+AST_EXT_LIB([nbs], [nbs_connect], [nbs.h], [NBS], [Network Broadcast Sound])
 AST_EXT_LIB([ncurses], [initscr], [curses.h], [NCURSES], [ncurses], [])
 AST_EXT_LIB([newt], [newtBell], [newt.h], [NEWT], [newt])
 AST_EXT_LIB([odbc], [SQLConnect], [sql.h], [UNIXODBC], [unixODBC])
@@ -302,9 +302,11 @@
 AC_CHECK_HEADER([h323.h], [PBX_H323=1], [])
 AC_SUBST(PBX_H323)
 
-HAVE_QUICKNET=0
-AC_CHECK_HEADER([ixjuser.h], [HAVE_QUICKNET=1],[])
-AC_SUBST(HAVE_QUICKNET)
+PBX_IXJUSER=0
+AC_CHECK_HEADER([linux/ixjuser.h], [
+   AC_CHECK_HEADER([linux/telephony.h], [
+      AC_CHECK_HEADER([linux/version.h], [PBX_IXJUSER=1])])])
+AC_SUBST(PBX_IXJUSER)
 
 AC_ARG_WITH([vpb], AC_HELP_STRING([--with-vpb=PATH],[use vpb files in PATH]),[
 case ${withval} in

Modified: trunk/http.c
===================================================================
--- trunk/http.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/http.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -45,7 +45,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 20330 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22933 $")
 
 #include "asterisk/cli.h"
 #include "asterisk/http.h"
@@ -493,9 +493,6 @@
 				close(ser->fd);
 				free(ser);
 			}
-		} else {
-			close(ser->fd);
-			free(ser);
 		}
 	}
 	return NULL;

Modified: trunk/include/asterisk/ael_structs.h
===================================================================
--- trunk/include/asterisk/ael_structs.h	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/include/asterisk/ael_structs.h	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,3 +1,6 @@
+#ifndef _ASTERISK_AEL_STRUCTS_H
+#define _ASTERISK_AEL_STRUCTS_H
+
 #if !defined(SOLARIS) && !defined(__CYGWIN__)
 #include <err.h>
 #else
@@ -113,6 +116,7 @@
 
 typedef struct pval pval;
 
+#if 0
 pval *npval(pvaltype type, int first_line, int last_line, int first_column, int last_column);
 void linku1(pval *head, pval *tail);
 void print_pval_list(FILE *f, pval *item, int depth);
@@ -122,9 +126,13 @@
 struct pval *find_label_in_current_extension(char *label);
 int count_labels_in_current_context(char *label);
 struct pval *find_label_in_current_db(char *context, char *exten, char *label);
-struct pval *ael2_parse(char *fname, int *errs);
+void ael2_print(char *fname, pval *tree);
+#endif
+struct pval *ael2_parse(char *fname, int *errs);	/* in ael.flex */
 void destroy_pval(pval *item);
-void ael2_print(char *fname, pval *tree);
+
+extern char *prev_word;	/* in ael.flex */
+
 #ifndef YY_TYPEDEF_YY_SCANNER_T
 #define YY_TYPEDEF_YY_SCANNER_T
 typedef void* yyscan_t;
@@ -175,4 +183,4 @@
 	int return_needed;
 };
 
-
+#endif /* _ASTERISK_AEL_STRUCTS_H */

Modified: trunk/pbx/ael/ael-test/runtests
===================================================================
--- trunk/pbx/ael/ael-test/runtests	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael-test/runtests	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,14 +1,24 @@
 #!/bin/bash
+ORIG=`mktemp /tmp/mytest.XXXXXX`
+NEW=`mktemp /tmp/mytest.XXXXXX`
 
+do_filter() {
+	sed 's/line:[0-9]*//; /^Executed.*/d; s/column=[0-9]*/ /; s/Cols: [0-9]*-[0-9]*/___/'
+}
+
 for i in ael-test*; do
 	echo -n Test: $i..................
 	(cd $i; ../../../../utils/aelparse -n -d | grep -v -i 'seconds' > ../res.$i)
-	if (diff -q res.$i ref.$i > /dev/null 2>&1 ) then
+	do_filter < res.$i > $NEW
+	do_filter < ref.$i > $ORIG
+	if (diff -q $NEW $ORIG > /dev/null 2>&1 ) then
 		echo PASSED
 		rm res.$i
 	else
 		echo %%%%%%FAILED%%%%%%
-		diff -u ref.$i res.$i
+		# diff -u ref.$i res.$i
+		diff -u $ORIG $NEW
 	fi
 
 done
+rm $NEW $ORIG

Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.flex	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,4 +1,3 @@
-%{
 /*
  * Asterisk -- An open source telephony toolkit.
  *
@@ -19,8 +18,45 @@
 /*! \file
  *
  * \brief Flex scanner description of tokens used in AEL2 .
- * 
- */#include <sys/types.h>
+ *
+ */
+
+/*
+ * Start with flex options:
+ *
+ * %x describes the contexts we have: paren, semic and argg, plus INITIAL
+ */
+%x paren semic argg
+
+/* prefix used for various globally-visible functions and variables.
+ * This renames also yywrap, but since we do not use it, we just
+ * add option noyywrap to remove it.
+ */
+%option prefix="ael_yy"
+%option noyywrap
+
+/* batch gives a bit more performance if we are using it in
+ * a non-interactive mode. We probably don't care much.
+ */
+%option batch
+
+/* outfile is the filename to be used instead of lex.yy.c */
+%option outfile="ael_lex.c"
+
+/*
+ * These are not supported in flex 2.5.4, but we need them
+ * at the moment:
+ * reentrant produces a thread-safe parser. Not 100% sure that
+ * we require it, though.
+ * bison-bridge passes an additional yylval argument to yylex().
+ * bison-locations is probably not needed.
+ */
+%option reentrant
+%option bison-bridge
+%option bison-locations
+
+%{
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
@@ -29,475 +65,391 @@
 #include "ael/ael.tab.h"
 #include "asterisk/ael_structs.h"
 
-static char pbcstack[400];
+/*
+ * A stack to keep track of matching brackets ( [ { } ] )
+ */
+static char pbcstack[400];	/* XXX missing size checks */
 static int pbcpos = 0;
 
 static int parencount = 0;
 static int commaout = 0;
-int my_lineno = 1;
-int my_col = 0;
-char *my_file = 0;
-char *prev_word;
+
+/*
+ * current line, column and filename, updated as we read the input.
+ */
+static int my_lineno = 1;	/* current line in the source */
+static int my_col = 1;		/* current column in the source */
+char *my_file = 0;		/* used also in the bison code */
+char *prev_word;		/* XXX document it */
+
 #define MAX_INCLUDE_DEPTH 50
 
-void reset_parencount(yyscan_t yyscanner );
-void reset_semicount(yyscan_t yyscanner );
-void reset_argcount(yyscan_t yyscanner );
-struct pval *ael2_parse(char *filename, int *errors);
+/*
+ * flex is not too smart, and generates global functions
+ * without prototypes so the compiler may complain.
+ * To avoid that, we declare the prototypes here,
+ * even though these functions are not used.
+ */
 int ael_yyget_column  (yyscan_t yyscanner);
 void ael_yyset_column (int  column_no , yyscan_t yyscanner);
+
 int ael_yyparse (struct parse_io *);
 static void pbcpush(char x);
 static int pbcpop(char x);
-static void pbcwhere(char *text, int *line, int *col );
-static int c_prevword(void);
 
-struct stackelement
-{
-     char *fname;
-	 int lineno;
-     int colno;
-	 YY_BUFFER_STATE bufstate;
+/*
+ * A stack to process include files.
+ * As we switch into the new file we need to store the previous
+ * state to restore it later.
+ */
+struct stackelement {
+	char *fname;
+	int lineno;
+	int colno;
+	YY_BUFFER_STATE bufstate;
 };
-struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
-int include_stack_index = 0;
 
+static struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
+static int include_stack_index = 0;
+
+/*
+ * if we use the @n feature of bison, we must supply the start/end
+ * location of tokens in the structure pointed by yylloc.
+ * Simple tokens are just assumed to be on the same line, so
+ * the line number is constant, and the column is incremented
+ * by the length of the token.
+ */
+#ifdef FLEX_BETA	/* set for 2.5.33 */
+
+/* compute the total number of lines and columns in the text
+ * passed as argument.
+ */
+static void pbcwhere(const char *text, int *line, int *col )
+{
+	int loc_line = *line;
+	int loc_col = *col;
+	char c;
+	while ( (c = *text++) ) {
+		if ( c == '\t' ) {
+			loc_col += 8 - (loc_col % 8);
+		} else if ( c == '\n' ) {
+			loc_line++;
+			loc_col = 1;
+		} else
+			loc_col++;
+	}
+	*line = loc_line;
+	*col = loc_col;
+}
+
+#define	STORE_POS do {							\
+		yylloc->first_line = yylloc->last_line = my_lineno;	\
+		yylloc->first_column=my_col;				\
+		yylloc->last_column=my_col+yyleng-1;			\
+		my_col+=yyleng;						\
+	} while (0)
+
+#define	STORE_LOC do {					\
+		yylloc->first_line = my_lineno;		\
+		yylloc->first_column=my_col;		\
+		pbcwhere(yytext, &my_lineno, &my_col);	\
+		yylloc->last_line = my_lineno;		\
+		yylloc->last_column = my_col - 1;	\
+	} while (0)
+#else
+#define	STORE_POS
+#define	STORE_LOC
+#endif
 %}
 
-%x paren semic argg
-%option prefix="ael_yy"
-%option batch
-%option outfile="ael_lex.c"
-%option reentrant
-%option bison-bridge
-%option bison-locations
-/* %option yylineno I've tried hard, but haven't been able to use this */
-%option noyywrap
 
+NOPARENS	[^()\[\]\{\}]*
+
+NOARGG		[^(),\{\}\[\]]*
+
+NOSEMIC		[^;()\{\}\[\]]*
+
 %%
-\{	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return LC;}
-\}	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return RC;}
-\(	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return LP;}
-\)	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return RP;}
-\;	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return SEMI;}
-\=	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return EQ;}
-\,	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return COMMA;}
-\:	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return COLON;}
-\&	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return AMPER;}
-\|	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return BAR;}
-\=\>	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return EXTENMARK;}
-\@	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return AT;}
-\/\/[^\n]*  {/*comment*/}
-context	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CONTEXT;}
-abstract	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_ABSTRACT;}
-macro	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_MACRO;};
-globals	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_GLOBALS;}
-ignorepat	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_IGNOREPAT;}
-switch	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_SWITCH;}
-if	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_IF;}
-ifTime	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_IFTIME;}
-random	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_RANDOM;}
-regexten	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_REGEXTEN;}
-hint	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_HINT;}
-else	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_ELSE;}
-goto	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_GOTO;}
-jump	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_JUMP;}
-return	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_RETURN;}
-break	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_BREAK;}
-continue	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CONTINUE;}
-for	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_FOR;}
-while	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_WHILE;}
-case	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CASE;}
-default	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_DEFAULT;}
-pattern	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_PATTERN;}
-catch	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CATCH;}
-switches	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_SWITCHES;}
-eswitches	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_ESWITCHES;}
-includes	{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_INCLUDES;}
 
-\n		{my_lineno++;my_col=0;}
-[ ]+	{/* nothing */ my_col+=yyleng;}
-[	]+	{/* nothing */ int wid = 8-(my_col%8); my_col+=wid;}
+\{		{ STORE_POS; return LC;}
+\}		{ STORE_POS; return RC;}
+\(		{ STORE_POS; return LP;}
+\)		{ STORE_POS; return RP;}
+\;		{ STORE_POS; return SEMI;}
+\=		{ STORE_POS; return EQ;}
+\,		{ STORE_POS; return COMMA;}
+\:		{ STORE_POS; return COLON;}
+\&		{ STORE_POS; return AMPER;}
+\|		{ STORE_POS; return BAR;}
+\=\>		{ STORE_POS; return EXTENMARK;}
+\@		{ STORE_POS; return AT;}
+\/\/[^\n]*	{/*comment*/}
+context		{ STORE_POS; return KW_CONTEXT;}
+abstract	{ STORE_POS; return KW_ABSTRACT;}
+macro		{ STORE_POS; return KW_MACRO;};
+globals		{ STORE_POS; return KW_GLOBALS;}
+ignorepat	{ STORE_POS; return KW_IGNOREPAT;}
+switch		{ STORE_POS; return KW_SWITCH;}
+if		{ STORE_POS; return KW_IF;}
+ifTime		{ STORE_POS; return KW_IFTIME;}
+random		{ STORE_POS; return KW_RANDOM;}
+regexten	{ STORE_POS; return KW_REGEXTEN;}
+hint		{ STORE_POS; return KW_HINT;}
+else		{ STORE_POS; return KW_ELSE;}
+goto		{ STORE_POS; return KW_GOTO;}
+jump		{ STORE_POS; return KW_JUMP;}
+return		{ STORE_POS; return KW_RETURN;}
+break		{ STORE_POS; return KW_BREAK;}
+continue	{ STORE_POS; return KW_CONTINUE;}
+for		{ STORE_POS; return KW_FOR;}
+while		{ STORE_POS; return KW_WHILE;}
+case		{ STORE_POS; return KW_CASE;}
+default		{ STORE_POS; return KW_DEFAULT;}
+pattern		{ STORE_POS; return KW_PATTERN;}
+catch		{ STORE_POS; return KW_CATCH;}
+switches	{ STORE_POS; return KW_SWITCHES;}
+eswitches	{ STORE_POS; return KW_ESWITCHES;}
+includes	{ STORE_POS; return KW_INCLUDES;}
 
+\n		{ my_lineno++; my_col = 1; }
+[ ]+		{ my_col += yyleng; }
+[\t]+		{ my_col += (yyleng*8)-(my_col%8); }
+
 [-a-zA-Z0-9'"_/.\<\>\*\+!$#\[\]][-a-zA-Z0-9'"_/.!\*\+\<\>\{\}$#\[\]]*	{
-                                               yylloc->first_line = yylloc->last_line = my_lineno;yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col; /* set up the ptr */
-                                               yylval->str = strdup(yytext);  
-                                               /* printf("\nGot WORD %s[%d][%d:%d]\n", yylval->str, my_lineno ,yylloc->first_column,yylloc->last_column );  */
-                                               my_col+=yyleng; 
-                                               prev_word = yylval->str;
-                                               return word;
-                                        }
+		STORE_POS;
+		yylval->str = strdup(yytext);
+		prev_word = yylval->str;
+		return word;
+	}
 
-<paren>[^()\[\]\{\}]*\)	{yylloc->first_line = my_lineno; yylloc->first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n", my_file, my_lineno+l4, c4, yytext);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             prev_word = 0;
-                             return word;
-                         }
-                 parencount--;
-                 if ( parencount >= 0) {
-                   yymore();
-                 } else { 
-                   int l4,c4;
-                   pbcwhere(yytext, &l4, &c4);
-                   yylloc->last_line = my_lineno+l4;
-				   yylloc->last_column=c4; 
-                   yylval->str = strdup(yytext); 
-                   *(yylval->str+strlen(yylval->str)-1)=0;
-                   /* printf("Got paren word %s\n", yylval->str); */ 
-                   unput(')'); 
-	               my_col=c4;
-                   my_lineno += l4;
-                   BEGIN(0); 
-                   return word;
-                 } 
-                }
 
-<paren>[^()\[\]\{\}]*\(	{yylloc->first_line = my_lineno; yylloc->first_column=my_col; 
-                  parencount++; pbcpush('(');
-                  yymore();
-                 }
-<paren>[^()\[\]\{\}]*\[	{yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('['); }
-<paren>[^()\[\]\{\}]*\]	{yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ']' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
-<paren>[^()\[\]\{\}]*\{	{yylloc->first_line = my_lineno;yylloc->first_column=my_col;  yymore(); pbcpush('{'); }
-<paren>[^()\[\]\{\}]*\}	{yylloc->first_line = my_lineno;
-                         yylloc->first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '}' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
 
 
-<argg>[^(),\{\}\[\]]*\)	{/* printf("ARGG:%s\n",yytext); */
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
+<paren>{NOPARENS}\)	{
+		if ( pbcpop(')') ) {	/* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n", my_file, my_lineno, my_col, yytext);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			prev_word = 0;
+			return word;
+		}
+		parencount--;
+		if ( parencount >= 0) {
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval->str = strdup(yytext);
+			*(yylval->str+strlen(yylval->str)-1)=0;
+			/* printf("Got paren word %s\n", yylval->str); */
+			unput(')');
+			BEGIN(0);
+			return word;
+		}
+	}
 
-					yylloc->first_line = my_lineno;
-                    yylloc->first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                   
+<paren>{NOPARENS}[\(\[\{]	{
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 
-					while (*pt) {
-                       if (*pt == '\n') {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc->last_line = my_lineno+linecount;
-                    yylloc->last_column=colcount; 
-                    parencount--;
-                    if( parencount >= 0){ 
-                        yymore(); 
-                    } else { 
-                        yylval->str = strdup(yytext); 
-					   if(yyleng > 1 ) 
-                              *(yylval->str+yyleng-1)=0;
-                       /* printf("Got argg word '%s'\n", yylval->str);  */
-                       BEGIN(0); 
-                       if ( !strcmp(yylval->str,")") ) { 
-                             free(yylval->str); 
-                             yylval->str = 0; 
-                             my_col+=1;
-                             return RP;  
-                       } else {
-                             unput(')');
-                             my_col=colcount;
-							 my_lineno+=linecount;
-                             return word;
-                       }
-                    } 
-                }
-<argg>[^(),\{\}\[\]]*\(	  { /* printf("ARGG:%s\n",yytext); */
-                      /* printf("GOT AN LP!!!\n"); */
-                      yylloc->first_line = my_lineno;
-                      yylloc->first_column=my_col; 
-                      parencount++; 
-                      pbcpush('(');
-                      yymore();
-                  }
+<paren>{NOPARENS}[\]\}]	{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c))  { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n",
+				my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 
-<argg>[^(),\{\}\[\]]*\,	{  /* printf("ARGG:%s\n",yytext); */
-                  if( parencount != 0) { 
-					/* printf("Folding in a comma!\n"); */ 
-					yymore();
-				  } else  { 
-                     /* printf("got a comma!\n\n");  */
-					 int linecount = 0;
-                     int colcount = my_col;
-					 char *pt;
+<argg>{NOARGG}[\(\[\{]	  {
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 
-					 pt = yytext;
-					 while (*pt) {
-                        if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                        }
-                        pt++;
-                        colcount++;
-                     }
-                     yylloc->first_line = my_lineno; 
-                     yylloc->last_line = my_lineno+linecount; 
-                     yylloc->last_column=colcount; 
-                     yylloc->first_column=my_col;
-                     if( !commaout ) { 
-						if( !strcmp(yytext,"," ) ) 
-							{commaout = 0; my_col+=1; return COMMA;} 
-						yylval->str = strdup(yytext); /* printf("Got argg2 word %s\n", yylval->str); */ 
-						unput(','); 
-						commaout = 1; 
-						if(yyleng > 1 ) 
-							*(yylval->str+yyleng-1)=0;
-                        my_lineno+=linecount;
-						my_col=colcount;
-						return word;
-					 } else {
-                            commaout = 0;
-							my_col+=1;
-							return COMMA;
-						}
-                   }
-				}
+<argg>{NOARGG}\)	{
+		if ( pbcpop(')') ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno, my_col);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
 
-<argg>[^(),\{\}\[\]]*\{	{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; pbcpush('{'); yymore();  }
-<argg>[^(),\{\}\[\]]*\}	{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '}' in expression!\n", my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
+		parencount--;
+		if( parencount >= 0){
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval->str = strdup(yytext);
+			if(yyleng > 1 )
+				*(yylval->str+yyleng-1)=0;
+			BEGIN(0);
+			if ( !strcmp(yylval->str,")") ) {
+				free(yylval->str);
+				yylval->str = 0;
+				my_col++; /* XXX why ? */
+				return RP;
+			} else {
+				unput(')');
+				return word;
+			}
+		}
+	}
+
+<argg>{NOARGG}\,	{
+		if( parencount != 0) { /* printf("Folding in a comma!\n"); */
+			yymore();
+		} else  {
+			STORE_LOC;
+			if( !commaout ) {
+				if( !strcmp(yytext,"," ) ) {
+					commaout = 0;
+					my_col+=1;
+					return COMMA;
 				}
-<argg>[^(),\{\}\[\]]*\[	{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('['); }
-<argg>[^(),\{\}\[\]]*\]	{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ']' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-				}
+				yylval->str = strdup(yytext);
+				/* printf("Got argg2 word %s\n", yylval->str); */
+				unput(',');
+				commaout = 1;
+				if (yyleng > 1 )
+					*(yylval->str+yyleng-1)=0;
+				return word;
+			} else {
+				commaout = 0;
+				my_col+=1;
+				return COMMA;
+			}
+		}
+	}
 
+<argg>{NOARGG}[\]\}]	{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 
-<semic>[^;()\{\}\[\]]*\[	{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('['); }
-<semic>[^;()\{\}\[\]]*\]	{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ']' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-<semic>[^;()\{\}\[\]]*\{	{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('{');}
-<semic>[^;()\{\}\[\]]*\}	{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '}' in expression!\n", my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-<semic>[^;()\{\}\[\]]*\(	{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('(');}
-<semic>[^;()\{\}\[\]]*\)	{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-<semic>[^;()\{\}\[\]]*;	{
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
-					while (*pt) {
-                       if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc->first_line = my_lineno; 
-					yylloc->last_line = my_lineno+linecount; 
-					yylloc->last_column=colcount; 
-					yylloc->first_column=my_col;
-                    yylval->str = strdup(yytext);
-                    if(yyleng > 1)
-                      *(yylval->str+yyleng-1)=0;
-                    /* printf("Got semic word %s\n", yylval->str); */
-                    unput(';');
-                    BEGIN(0);
-                    my_col=colcount;
-                    my_lineno += linecount;
-                    return word;
-                }
 
-\#include[ \t]+\"[^\"]+\" {
-                     FILE *in1;
-					 char fnamebuf[1024],*p1,*p2;
-                     if ( include_stack_index >= MAX_INCLUDE_DEPTH ) {
-						ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n", my_file, my_lineno, my_col);
-                     } else {
-                         p1 = strchr(yytext,'"');
-                         p2 = strrchr(yytext,'"');
-                         if ( (int)(p2-p1) > 1023 ) {
-							ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n", my_file, my_lineno, my_col, yyleng - 10);
-        	             } else {
-								int i;
-								int found = 0;
-								strncpy(fnamebuf,p1,p2-p1);
-								fnamebuf[p2-p1] = 0;
-								for (i=0; i<include_stack_index; i++) {
-									if ( !strcmp(fnamebuf,include_stack[i].fname )) {
-										ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n", 
-												my_file, my_lineno, my_col, fnamebuf);
-										found=1;
-										break;
-									}
-								}
-								if( !found )
-								{
-                                	*p2 = 0;
-                                    /* relative vs. absolute */
-                                    if ( *(p1+1) != '/' )
-                                    {
-                                        strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
-										strcat(fnamebuf,"/");
-										strcat(fnamebuf,p1+1);
-                                    }
-                                    else
-                                	    strcpy(fnamebuf,p1+1);
-		                        	in1 = fopen( fnamebuf, "r" );
-                                	if ( ! in1 ) {
-						ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);
-                                	} else {
-						char *buffer;
-	                             	 	struct stat stats;
-	                            		stat(fnamebuf, &stats);
-	                             		buffer = (char*)malloc(stats.st_size+1);
-	                             		fread(buffer, 1, stats.st_size, in1);
-						buffer[stats.st_size] = 0;
-						ast_log(LOG_NOTICE,"  --Read in included file %s, %d chars\n",fnamebuf, (int)stats.st_size);
-	                                	fclose(in1);
 
-						include_stack[include_stack_index].fname = my_file;
-						my_file = strdup(fnamebuf);
-						include_stack[include_stack_index].lineno = my_lineno;
-						include_stack[include_stack_index].colno = my_col+yyleng;
-						include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
+<semic>{NOSEMIC}[\(\[\{]	{
+		char c = yytext[yyleng-1];
+		yymore();
+		pbcpush(c);
+	}
 
-	                                	yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
-                                    		free(buffer);
-                                  	  	my_lineno = 1;
-                                    		my_col = 1;
-                                    		BEGIN(INITIAL);
-                                	}
-                                }
-                         }
-                     }
-                 }
+<semic>{NOSEMIC}[\)\]\}]	{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 
-<<EOF>>  {
-                 if ( --include_stack_index < 0 ) {
-                 	    yyterminate();
-                     } else {
-						 free(my_file);
-                         yy_delete_buffer( YY_CURRENT_BUFFER, yyscanner );
-                         yy_switch_to_buffer(include_stack[include_stack_index].bufstate, yyscanner );
-                         my_lineno = include_stack[include_stack_index].lineno;
-                         my_col    = include_stack[include_stack_index].colno;
-                         my_file   = include_stack[include_stack_index].fname;
-                     }
-          }
+<semic>{NOSEMIC};	{
+		STORE_LOC;
+		yylval->str = strdup(yytext);
+		if(yyleng > 1)
+			*(yylval->str+yyleng-1)=0;
+		unput(';');
+		BEGIN(0);
+		return word;
+	}
 
+\#include[ \t]+\"[^\"]+\" {
+		FILE *in1;
+		char fnamebuf[1024],*p1,*p2;
+		int error = 1;	/* don't use the file if set */
+		p1 = strchr(yytext,'"');
+		p2 = strrchr(yytext,'"');
+		if ( include_stack_index >= MAX_INCLUDE_DEPTH ) {
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n", my_file, my_lineno, my_col);
+		} else if ( (int)(p2-p1) > sizeof(fnamebuf) - 1 ) {
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n", my_file, my_lineno, my_col, yyleng - 10);
+		} else {
+			int i;
+			strncpy(fnamebuf, p1, p2-p1);
+			fnamebuf[p2-p1] = 0;
+			for (i=0; i<include_stack_index; i++) {
+				if ( !strcmp(fnamebuf,include_stack[i].fname )) {
+					ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n",
+						my_file, my_lineno, my_col, fnamebuf);
+					break;
+				}
+			}
+			if (i == include_stack_index)
+				error = 0;	/* we can use this file */
+		}
+		if ( !error ) {	/* valid file name */
+			*p2 = 0;
+			/* relative vs. absolute */
+			if ( *(p1+1) != '/' ) {
+				/* XXX must check overflows */
+				strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
+				strcat(fnamebuf,"/");
+				strcat(fnamebuf,p1+1);
+			} else
+				strcpy(fnamebuf,p1+1);
+			in1 = fopen( fnamebuf, "r" );
+			if ( ! in1 ) {
+				ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);
+			} else {
+				char *buffer;
+				struct stat stats;
+				stat(fnamebuf, &stats);
+				buffer = (char*)malloc(stats.st_size+1);
+				fread(buffer, 1, stats.st_size, in1);
+				buffer[stats.st_size] = 0;
+				ast_log(LOG_NOTICE,"  --Read in included file %s, %d chars\n",fnamebuf, (int)stats.st_size);
+				fclose(in1);
 
+				include_stack[include_stack_index].fname = my_file;
+				my_file = strdup(fnamebuf);
+				include_stack[include_stack_index].lineno = my_lineno;
+				include_stack[include_stack_index].colno = my_col+yyleng;
+				include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
+
+				yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
+				free(buffer);
+				my_lineno = 1;
+				my_col = 1;
+				BEGIN(INITIAL);
+			}
+		}
+	}
+
+<<EOF>>		{
+		if ( --include_stack_index < 0 ) {
+			yyterminate();
+		} else {
+			free(my_file);
+			yy_delete_buffer( YY_CURRENT_BUFFER, yyscanner );
+			yy_switch_to_buffer(include_stack[include_stack_index].bufstate, yyscanner );
+			my_lineno = include_stack[include_stack_index].lineno;
+			my_col    = include_stack[include_stack_index].colno;
+			my_file   = include_stack[include_stack_index].fname;
+		}
+	}
+
 %%
 
 static void pbcpush(char x)
@@ -513,47 +465,36 @@
 		pbcpos--;
 		return 0;
 	}
-	else
-		return 1; /* error */
+	return 1; /* error */
 }
 
 static int c_prevword(void)
 {
-    char *c = prev_word;
-	int ret = 0;
-	while ( c && *c ) {
-        switch (*c) {
-            case '{': pbcpush('{');break;
-            case '}': ret = pbcpop('}');break;
-            case '[':pbcpush('[');break;
-            case ']':ret = pbcpop(']');break;
-            case '(':pbcpush('(');break;
-            case ')':ret = pbcpop(')'); break;
-        }
-        if( ret )
-            return 1;
+	char *c = prev_word;
+	if (c == NULL)
+		return 0;
+	while ( *c ) {
+		switch (*c) {
+		case '{':
+		case '[':
+		case '(':
+			pbcpush(*c);
+			break;
+		case '}':
+		case ']':
+		case ')':
+			if (pbcpop(*c))
+				return 1;
+			break;
+		}
 		c++;
 	}
 	return 0;
 }
 
-static void pbcwhere(char *text, int *line, int *col )
-{
-	int loc_line = 0;
-    int loc_col = 0;
-	while ( *text ) {
-       if ( *text == '\n' ) {
-             loc_line++;
-             loc_col = 1;
-       } else {
-             loc_col++;
-       }
-       text++;
-    }
-	*line = loc_line;
-    *col = loc_col;
-}
 
+/* used by the bison code */
+void reset_parencount(yyscan_t yyscanner );
 void reset_parencount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -564,6 +505,8 @@
 	BEGIN(paren);
 }
 
+/* used by the bison code */
+void reset_semicount(yyscan_t yyscanner );
 void reset_semicount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -571,6 +514,8 @@
 	BEGIN(semic);
 }
 
+/* used by the bison code */
+void reset_argcount(yyscan_t yyscanner );
 void reset_argcount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -582,7 +527,7 @@
 	BEGIN(argg);
 }
 
-
+/* used elsewhere, but some local vars */
 struct pval *ael2_parse(char *filename, int *errors)
 {
 	struct pval *pval;
@@ -613,7 +558,7 @@
 	fread(buffer, 1, stats.st_size, fin);
 	buffer[stats.st_size]=0;
 	fclose(fin);
-	
+
 	ael_yy_scan_string (buffer ,io->scanner);
 	ael_yyset_lineno(1 , io->scanner);
 

Modified: trunk/pbx/ael/ael.tab.c
===================================================================
--- trunk/pbx/ael/ael.tab.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.tab.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -153,7 +153,7 @@
 #line 1 "ael.y"
 
 /*
- * Asterisk -- An open source telephony toolkit. 
+ * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 2006, Digium, Inc.
  *
@@ -172,18 +172,25 @@
 /*! \file
  *
  * \brief Bison Grammar description of AEL2.
- * 
+ *
  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include "asterisk/logger.h"
+#include "asterisk/utils.h"		/* ast_calloc() */
 #include "asterisk/ael_structs.h"
 
-extern void reset_parencount(yyscan_t yyscanner);
-extern void reset_semicount(yyscan_t yyscanner);
-extern void reset_argcount(yyscan_t yyscanner );
+/* create a new object with start-end marker */
+static pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column);
 
+static pval * linku1(pval *head, pval *tail);
+
+void reset_parencount(yyscan_t yyscanner);
+void reset_semicount(yyscan_t yyscanner);
+void reset_argcount(yyscan_t yyscanner );
+
 #define YYLEX_PARAM ((struct parse_io *)parseio)->scanner
 #define YYERROR_VERBOSE 1
 
@@ -191,11 +198,10 @@
 #ifdef AAL_ARGCHECK
 int ael_is_funcname(char *name);
 #endif
- static char *ael_token_subst(char *mess);
- extern char *prev_word;
- 
+static char *ael_token_subst(char *mess);
 
 
+
 /* Enabling traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
@@ -215,13 +221,13 @@
 #endif
 
 #if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 47 "ael.y"
+#line 53 "ael.y"
 typedef union YYSTYPE {
 	char *str;
 	struct pval *pval;
 } YYSTYPE;
 /* Line 196 of yacc.c.  */
-#line 225 "ael.tab.c"
+#line 231 "ael.tab.c"
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -242,16 +248,20 @@
 
 
 /* Copy the second part of user declarations.  */
-#line 52 "ael.y"
+#line 58 "ael.y"
 
 	/* declaring these AFTER the union makes things a lot simpler! */
 void yyerror(YYLTYPE *locp, struct parse_io *parseio, char const *s);
 int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void * yyscanner);
-	
 
+/* create a new object with start-end marker, simplified interface.
+ * Must be declared here because YYLTYPE is not known before
+ */
+static pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last);
 
+
 /* Line 219 of yacc.c.  */
-#line 255 "ael.tab.c"
+#line 265 "ael.tab.c"
 
 #if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
 # define YYSIZE_T __SIZE_TYPE__
@@ -551,22 +561,22 @@
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const unsigned short int yyrline[] =
 {
-       0,   126,   126,   129,   130,   133,   136,   137,   138,   139,
-     142,   143,   144,   145,   146,   147,   148,   149,   152,   154,
-     155,   156,   159,   160,   163,   164,   165,   168,   168,   171,
-     172,   173,   176,   177,   178,   181,   184,   185,   186,   187,
-     188,   189,   189,   190,   191,   194,   197,   198,   199,   200,
-     204,   205,   208,   211,   211,   214,   214,   217,   236,   255,
-     256,   258,   259,   260,   263,   264,   265,   268,   268,   273,
-     274,   274,   277,   278,   279,   280,   281,   282,   280,   285,
-     285,   288,   289,   290,   291,   292,   294,   294,   327,   328,
-     329,   330,   331,   332,   333,   334,   335,   336,   339,   340,
-     343,   346,   351,   356,   361,   368,   371,   374,   379,   384,
-     389,   396,   396,   399,   402,   402,   411,   417,   420,   421,
-     422,   423,   426,   427,   432,   433,   434,   435,   436,   437,
-     440,   441,   446,   447,   450,   451,   454,   455,   458,   459,
-     460,   463,   464,   485,   498,   499,   519,   532,   535,   536,
-     539,   540
+       0,   157,   157,   160,   161,   172,   175,   176,   177,   178,
+     181,   185,   188,   192,   195,   200,   204,   209,   215,   218,
+     221,   225,   230,   233,   237,   238,   239,   242,   242,   248,
+     251,   256,   259,   260,   261,   264,   267,   268,   269,   270,
+     271,   272,   272,   276,   277,   280,   285,   289,   294,   299,
+     308,   309,   312,   315,   315,   320,   320,   325,   341,   361,
+     362,   369,   370,   375,   383,   384,   388,   394,   394,   402,
+     405,   405,   409,   412,   415,   418,   419,   420,   418,   426,
+     426,   430,   434,   439,   443,   447,   450,   450,   483,   484,
+     485,   486,   491,   497,   502,   508,   513,   519,   522,   524,
+     529,   534,   541,   548,   555,   564,   569,   574,   581,   588,
+     595,   604,   604,   609,   614,   614,   624,   630,   633,   636,
+     639,   644,   651,   652,   657,   661,   665,   669,   672,   675,
+     680,   681,   686,   687,   693,   696,   700,   703,   707,   710,
+     715,   718,   721,   738,   751,   756,   774,   788,   791,   792,
+     795,   798
 };
 #endif
 
@@ -1303,194 +1313,293 @@
   switch (yytype)
     {
       case 41: /* "word" */
-#line 121 "ael.y"
+#line 152 "ael.y"
         { free((yyvaluep->str));};
-#line 1309 "ael.tab.c"
+#line 1319 "ael.tab.c"
         break;
       case 44: /* "objects" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1314 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1327 "ael.tab.c"
         break;
       case 45: /* "object" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1319 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1335 "ael.tab.c"
         break;
       case 46: /* "context" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1324 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1343 "ael.tab.c"
         break;
       case 47: /* "macro" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1329 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1351 "ael.tab.c"
         break;
       case 48: /* "globals" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1334 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1359 "ael.tab.c"
         break;
       case 49: /* "global_statements" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1339 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1367 "ael.tab.c"
         break;
       case 50: /* "global_statement" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1344 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1375 "ael.tab.c"
         break;
       case 52: /* "arglist" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1349 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1383 "ael.tab.c"
         break;
       case 53: /* "elements" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1354 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1391 "ael.tab.c"
         break;
       case 54: /* "element" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1359 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1399 "ael.tab.c"
         break;
       case 56: /* "ignorepat" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1364 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1407 "ael.tab.c"
         break;
       case 57: /* "extension" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1369 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1415 "ael.tab.c"
         break;
       case 58: /* "statements" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1374 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1423 "ael.tab.c"
         break;
       case 59: /* "if_head" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1379 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1431 "ael.tab.c"
         break;
       case 61: /* "random_head" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1384 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1439 "ael.tab.c"
         break;
       case 63: /* "iftime_head" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1389 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1447 "ael.tab.c"
         break;
       case 64: /* "word_list" */
-#line 121 "ael.y"
+#line 152 "ael.y"
         { free((yyvaluep->str));};
-#line 1394 "ael.tab.c"
+#line 1452 "ael.tab.c"
         break;
       case 65: /* "word3_list" */
-#line 121 "ael.y"
+#line 152 "ael.y"
         { free((yyvaluep->str));};
-#line 1399 "ael.tab.c"
+#line 1457 "ael.tab.c"
         break;
       case 66: /* "goto_word" */
-#line 121 "ael.y"
+#line 152 "ael.y"
         { free((yyvaluep->str));};
-#line 1404 "ael.tab.c"
+#line 1462 "ael.tab.c"
         break;
       case 67: /* "switch_head" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1409 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1470 "ael.tab.c"
         break;
       case 69: /* "statement" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1414 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1478 "ael.tab.c"
         break;
       case 76: /* "target" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1419 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1486 "ael.tab.c"
         break;
       case 77: /* "jumptarget" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1424 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1494 "ael.tab.c"
         break;
       case 78: /* "macro_call" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1429 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1502 "ael.tab.c"
         break;
       case 80: /* "application_call_head" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1434 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1510 "ael.tab.c"
         break;
       case 82: /* "application_call" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1439 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1518 "ael.tab.c"
         break;
       case 83: /* "eval_arglist" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1444 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1526 "ael.tab.c"
         break;
       case 84: /* "case_statements" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1449 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1534 "ael.tab.c"
         break;
       case 85: /* "case_statement" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1454 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1542 "ael.tab.c"
         break;
       case 86: /* "macro_statements" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1459 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1550 "ael.tab.c"
         break;
       case 87: /* "macro_statement" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1464 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1558 "ael.tab.c"
         break;
       case 88: /* "switches" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1469 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1566 "ael.tab.c"
         break;
       case 89: /* "eswitches" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1474 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1574 "ael.tab.c"
         break;
       case 90: /* "switchlist" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1479 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1582 "ael.tab.c"
         break;
       case 91: /* "includeslist" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1484 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1590 "ael.tab.c"
         break;
       case 92: /* "includedname" */
-#line 121 "ael.y"
+#line 152 "ael.y"
         { free((yyvaluep->str));};
-#line 1489 "ael.tab.c"
+#line 1595 "ael.tab.c"
         break;
       case 93: /* "includes" */
-#line 118 "ael.y"
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep->pval)); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} };
-#line 1494 "ael.tab.c"
+#line 141 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1603 "ael.tab.c"
         break;
 
       default:
@@ -1807,696 +1916,877 @@
   switch (yyn)
     {
         case 2:
-#line 126 "ael.y"
+#line 157 "ael.y"
     { (yyval.pval) = parseio->pval = (yyvsp[0].pval); ;}
     break;
 
   case 3:
-#line 129 "ael.y"
+#line 160 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 4:
-#line 130 "ael.y"
-    {if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
-						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
-						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
+#line 162 "ael.y"
+    {
+			if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {
+				(yyval.pval)=(yyvsp[-1].pval);
+				linku1((yyval.pval),(yyvsp[0].pval));
+			} else if ( (yyvsp[-1].pval) ) {
+				(yyval.pval)=(yyvsp[-1].pval);
+			} else if ( (yyvsp[0].pval) ) {
+				(yyval.pval)=(yyvsp[0].pval);
+			}
+		;}
     break;
 
   case 5:
-#line 133 "ael.y"
+#line 172 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 6:
-#line 136 "ael.y"
+#line 175 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 7:
-#line 137 "ael.y"
+#line 176 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 8:
-#line 138 "ael.y"
+#line 177 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 9:
-#line 139 "ael.y"
+#line 178 "ael.y"
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
   case 10:
-#line 142 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-3].str); (yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
+#line 181 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
     break;
 
   case 11:
-#line 143 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+#line 185 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 12:
-#line 144 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = strdup("default"); (yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
+#line 188 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
     break;
 
   case 13:
-#line 145 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = strdup("default"); ;}
+#line 192 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.str = strdup("default"); ;}
     break;
 
   case 14:
-#line 146 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-3].str); (yyval.pval)->u2.statements = (yyvsp[-1].pval);  (yyval.pval)->u3.abstract = 1;;}
+#line 195 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-5]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->u3.abstract = 1; ;}
     break;
 
   case 15:
-#line 147 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u3.abstract = 1; ;}
+#line 200 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u3.abstract = 1; ;}
     break;
 
   case 16:
-#line 148 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = strdup("default"); (yyval.pval)->u2.statements = (yyvsp[-1].pval); (yyval.pval)->u3.abstract = 1; ;}
+#line 204 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-5]), &(yylsp[0]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->u3.abstract = 1; ;}
     break;
 
   case 17:
-#line 149 "ael.y"
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = strdup("default"); (yyval.pval)->u3.abstract = 1; ;}
+#line 209 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->u3.abstract = 1; ;}
     break;
 
   case 18:
-#line 152 "ael.y"
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-7]).first_line,(yylsp[0]).last_line, (yylsp[-7]).first_column, (yylsp[0]).last_column); 
-																	 (yyval.pval)->u1.str = (yyvsp[-6].str); (yyval.pval)->u2.arglist = (yyvsp[-4].pval); (yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
+#line 215 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-7]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-6].str); (yyval.pval)->u2.arglist = (yyvsp[-4].pval); (yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
   case 19:
-#line 154 "ael.y"
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-6]).first_line,(yylsp[0]).last_line, (yylsp[-6]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-5].str); (yyval.pval)->u2.arglist = (yyvsp[-3].pval); ;}
+#line 218 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-6]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-5].str); (yyval.pval)->u2.arglist = (yyvsp[-3].pval); ;}
     break;
 
   case 20:
-#line 155 "ael.y"
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-6]).first_line,(yylsp[0]).last_line, (yylsp[-6]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-5].str); (yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
+#line 221 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-6]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-5].str);
+		(yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
   case 21:
-#line 156 "ael.y"
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-4].str); /* pretty empty! */ ;}
+#line 225 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-5]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str); ;}
     break;
 
   case 22:
-#line 159 "ael.y"
-    {(yyval.pval)=npval(PV_GLOBALS,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.statements = (yyvsp[-1].pval);;}
+#line 230 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.statements = (yyvsp[-1].pval);;}
     break;
 
   case 23:
-#line 160 "ael.y"
-    {(yyval.pval)=npval(PV_GLOBALS,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); /* and that's all */ ;}
+#line 233 "ael.y"
+    { /* empty globals is OK */
+		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
   case 24:
-#line 163 "ael.y"
+#line 237 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 25:
-#line 164 "ael.y"
+#line 238 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));;}
     break;
 
   case 26:
-#line 165 "ael.y"
+#line 239 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 27:
-#line 168 "ael.y"
+#line 242 "ael.y"
     { reset_semicount(parseio->scanner); ;}
     break;
 
   case 28:
-#line 168 "ael.y"
-    {(yyval.pval)=npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-4].str);(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
+#line 242 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
   case 29:
-#line 171 "ael.y"
-    {(yyval.pval)= npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[0].str); ;}
+#line 248 "ael.y"
+    {
+		(yyval.pval)= npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[0].str); ;}
     break;
 
   case 30:
-#line 172 "ael.y"
-    {pval *z = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); z->u1.str = (yyvsp[0].str); (yyval.pval)=(yyvsp[-2].pval); linku1((yyval.pval),z); ;}
+#line 251 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[0]));
+		z->u1.str = (yyvsp[0].str);
+		(yyval.pval)=(yyvsp[-2].pval);
+		linku1((yyval.pval),z); ;}
     break;
 
   case 31:
-#line 173 "ael.y"
+#line 256 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 32:
-#line 176 "ael.y"
+#line 259 "ael.y"
     { (yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 33:
-#line 177 "ael.y"
+#line 260 "ael.y"
     {(yyval.pval)=0;;}
     break;
 
   case 34:
-#line 178 "ael.y"
-    { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
-						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
-						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
+#line 261 "ael.y"
+    { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
+				else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
+				else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 35:
-#line 181 "ael.y"
+#line 264 "ael.y"
     { (yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 36:
-#line 184 "ael.y"
+#line 267 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 37:
-#line 185 "ael.y"
+#line 268 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 38:
-#line 186 "ael.y"
+#line 269 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 39:
-#line 187 "ael.y"
+#line 270 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 40:
-#line 188 "ael.y"
+#line 271 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 41:
-#line 189 "ael.y"
+#line 272 "ael.y"
     { reset_semicount(parseio->scanner); ;}
     break;
 
   case 42:
-#line 189 "ael.y"
-    {(yyval.pval)=npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-4].str);(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
+#line 272 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
   case 43:
-#line 190 "ael.y"
+#line 276 "ael.y"
     {free((yyvsp[-1].str)); (yyval.pval)=0;;}
     break;
 
   case 44:
-#line 191 "ael.y"
+#line 277 "ael.y"
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
   case 45:
-#line 194 "ael.y"
-    { (yyval.pval)=npval(PV_IGNOREPAT,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str);;}
+#line 280 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_IGNOREPAT, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
   case 46:
-#line 197 "ael.y"
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
+#line 285 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
     break;
 
   case 47:
-#line 198 "ael.y"
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-3]).first_line,(yylsp[-1]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval); (yyval.pval)->u4.regexten=1;;}
+#line 289 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->u4.regexten=1;;}
     break;
 
   case 48:
-#line 199 "ael.y"
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-6]).first_line,(yylsp[0]).last_line, (yylsp[-6]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval); (yyval.pval)->u3.hints = (yyvsp[-4].str);;}
+#line 294 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-6]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
     break;
 
   case 49:
-#line 200 "ael.y"
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-7]).first_line,(yylsp[-4]).last_line, (yylsp[-7]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval); (yyval.pval)->u4.regexten=1;(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
+#line 299 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-7]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->u4.regexten=1;
+		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
     break;
 
   case 50:
-#line 204 "ael.y"
+#line 308 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 51:
-#line 205 "ael.y"
-    {if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
+#line 309 "ael.y"
+    {if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 52:
-#line 208 "ael.y"
+#line 312 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 53:
-#line 211 "ael.y"
+#line 315 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
   case 54:
-#line 211 "ael.y"
-    { (yyval.pval)= npval(PV_IF,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str); ;}
+#line 315 "ael.y"
+    {
+		(yyval.pval)= npval2(PV_IF, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
     break;
 
   case 55:
-#line 214 "ael.y"
+#line 320 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
   case 56:
-#line 214 "ael.y"
-    { (yyval.pval)= npval(PV_RANDOM,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str=(yyvsp[-1].str);;}
+#line 320 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_RANDOM, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str=(yyvsp[-1].str);;}
     break;
 
   case 57:
-#line 217 "ael.y"
-    { (yyval.pval)= npval(PV_IFTIME,(yylsp[-13]).first_line,(yylsp[-9]).last_line, (yylsp[-13]).first_column, (yylsp[-9]).last_column); 
-					(yyval.pval)->u1.list = npval(PV_WORD,(yylsp[-11]).first_line,(yylsp[-11]).last_line, (yylsp[-11]).first_column, (yylsp[-11]).last_column); 
-					(yyval.pval)->u1.list->u1.str = (char*)malloc(strlen((yyvsp[-11].str))+strlen((yyvsp[-9].str))+strlen((yyvsp[-7].str))+4);
-					strcpy((yyval.pval)->u1.list->u1.str,(yyvsp[-11].str));
-					strcat((yyval.pval)->u1.list->u1.str,":");
-					strcat((yyval.pval)->u1.list->u1.str,(yyvsp[-9].str));
-					strcat((yyval.pval)->u1.list->u1.str,":");
-					strcat((yyval.pval)->u1.list->u1.str,(yyvsp[-7].str));
-					free((yyvsp[-11].str));
-					free((yyvsp[-9].str));
-					free((yyvsp[-7].str));
-					(yyval.pval)->u1.list->next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)->u1.list->next->u1.str = (yyvsp[-5].str); 
-					(yyval.pval)->u1.list->next->next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)->u1.list->next->next->u1.str = (yyvsp[-3].str); 
-					(yyval.pval)->u1.list->next->next->next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)->u1.list->next->next->next->u1.str = (yyvsp[-1].str); 
-					prev_word = 0;
-		;}
+#line 326 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-13]), &(yylsp[-9])); /* XXX really @5 or more ? */
+		(yyval.pval)->u1.list = npval2(PV_WORD, &(yylsp[-11]), &(yylsp[-11]));
+		asprintf(&((yyval.pval)->u1.list->u1.str), "%s:%s:%s", (yyvsp[-11].str), (yyvsp[-9].str), (yyvsp[-7].str));
+		free((yyvsp[-11].str));
+		free((yyvsp[-9].str));
+		free((yyvsp[-7].str));
+		(yyval.pval)->u1.list->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
+		(yyval.pval)->u1.list->next->u1.str = (yyvsp[-5].str);
+		(yyval.pval)->u1.list->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
+		(yyval.pval)->u1.list->next->next->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u1.list->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
+		(yyval.pval)->u1.list->next->next->next->u1.str = (yyvsp[-1].str);
+		prev_word = 0;
+	;}
     break;
 
   case 58:
-#line 236 "ael.y"
-    { (yyval.pval)= npval(PV_IFTIME,(yylsp[-9]).first_line,(yylsp[-5]).last_line, (yylsp[-9]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)->u1.list = npval(PV_WORD,(yylsp[-7]).first_line,(yylsp[-7]).last_line, (yylsp[-7]).first_column, (yylsp[-7]).last_column); 
-					(yyval.pval)->u1.list->u1.str = (yyvsp[-7].str);
-					(yyval.pval)->u1.list->next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)->u1.list->next->u1.str = (yyvsp[-5].str); 
-					(yyval.pval)->u1.list->next->next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)->u1.list->next->next->u1.str = (yyvsp[-3].str); 
-					(yyval.pval)->u1.list->next->next->next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)->u1.list->next->next->next->u1.str = (yyvsp[-1].str); 
-					prev_word = 0;
-		;}
+#line 341 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-9]), &(yylsp[-5])); /* XXX @5 or greater ? */
+		(yyval.pval)->u1.list = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
+		(yyval.pval)->u1.list->u1.str = (yyvsp[-7].str);
+		(yyval.pval)->u1.list->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
+		(yyval.pval)->u1.list->next->u1.str = (yyvsp[-5].str);
+		(yyval.pval)->u1.list->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
+		(yyval.pval)->u1.list->next->next->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u1.list->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
+		(yyval.pval)->u1.list->next->next->next->u1.str = (yyvsp[-1].str);
+		prev_word = 0;
+	;}
     break;
 
   case 59:
-#line 255 "ael.y"
+#line 361 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 60:
-#line 256 "ael.y"
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-1].str)); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-1].str)); free((yyvsp[0].str));prev_word = (yyval.str);;}
+#line 362 "ael.y"
+    {
+		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));
+		prev_word = (yyval.str);;}
     break;
 
   case 61:
-#line 258 "ael.y"
+#line 369 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 62:
-#line 259 "ael.y"
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-1].str)); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-1].str)); free((yyvsp[0].str));prev_word = (yyval.str);;}
+#line 370 "ael.y"
+    {
+		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));
+		prev_word = (yyval.str);;}
     break;
 
   case 63:
-#line 260 "ael.y"
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-2].str))+strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-2].str)); strcat((yyval.str), (yyvsp[-1].str));  strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-2].str)); free((yyvsp[-1].str)); free((yyvsp[0].str));prev_word=(yyval.str);;}
+#line 375 "ael.y"
+    {
+		asprintf(&((yyval.str)), "%s%s%s", (yyvsp[-2].str), (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-2].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));
+		prev_word=(yyval.str);;}
     break;
 
   case 64:
-#line 263 "ael.y"
+#line 383 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 65:
-#line 264 "ael.y"
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-1].str)); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-1].str)); free((yyvsp[0].str));;}
+#line 384 "ael.y"
+    {
+		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));;}
     break;
 
   case 66:
-#line 265 "ael.y"
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-2].str))+strlen((yyvsp[0].str))+2); strcpy((yyval.str), (yyvsp[-2].str)); strcat((yyval.str),":"); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-2].str)); free((yyvsp[0].str));;}
+#line 388 "ael.y"
+    {
+		asprintf(&((yyval.str)), "%s:%s", (yyvsp[-2].str), (yyvsp[0].str));
+		free((yyvsp[-2].str));
+		free((yyvsp[0].str));;}
     break;
 
   case 67:
-#line 268 "ael.y"
+#line 394 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
   case 68:
-#line 269 "ael.y"
-    {(yyval.pval)=npval(PV_SWITCH,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column);
-						(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+#line 394 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_SWITCH, &(yylsp[-5]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 69:
-#line 273 "ael.y"
-    {(yyval.pval)=npval(PV_STATEMENTBLOCK,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+#line 402 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_STATEMENTBLOCK, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
   case 70:
-#line 274 "ael.y"
+#line 405 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
   case 71:
-#line 275 "ael.y"
-    {(yyval.pval)=npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); 
-				(yyval.pval)->u1.str = (yyvsp[-4].str); (yyval.pval)->u2.val = (yyvsp[-1].str); ;}
+#line 405 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
   case 72:
-#line 277 "ael.y"
-    {(yyval.pval)=npval(PV_GOTO,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.list = (yyvsp[-1].pval);;}
+#line 409 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
   case 73:
-#line 278 "ael.y"
-    {(yyval.pval)=npval(PV_GOTO,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.list = (yyvsp[-1].pval);;}
+#line 412 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
   case 74:
-#line 279 "ael.y"
-    {(yyval.pval)=npval(PV_LABEL,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str); ;}
+#line 415 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_LABEL, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
     break;
 
   case 75:
-#line 280 "ael.y"
+#line 418 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
   case 76:
-#line 281 "ael.y"
+#line 419 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
   case 77:
-#line 282 "ael.y"
+#line 420 "ael.y"
     {reset_parencount(parseio->scanner);;}
     break;
 
   case 78:
-#line 283 "ael.y"
-    { (yyval.pval)=npval(PV_FOR,(yylsp[-11]).first_line,(yylsp[0]).last_line, (yylsp[-11]).first_column, (yylsp[0]).last_column); 
-						(yyval.pval)->u1.for_init = (yyvsp[-8].str); (yyval.pval)->u2.for_test=(yyvsp[-5].str); (yyval.pval)->u3.for_inc = (yyvsp[-2].str); (yyval.pval)->u4.for_statements = (yyvsp[0].pval);;}
+#line 420 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_FOR, &(yylsp[-11]), &(yylsp[0]));
+		(yyval.pval)->u1.for_init = (yyvsp[-8].str);
+		(yyval.pval)->u2.for_test=(yyvsp[-5].str);
+		(yyval.pval)->u3.for_inc = (yyvsp[-2].str);
+		(yyval.pval)->u4.for_statements = (yyvsp[0].pval);;}
     break;
 
   case 79:
-#line 285 "ael.y"
+#line 426 "ael.y"
     {reset_parencount(parseio->scanner);;}
     break;
 
   case 80:
-#line 286 "ael.y"
-    {(yyval.pval)=npval(PV_WHILE,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
+#line 426 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WHILE, &(yylsp[-5]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
     break;
 
   case 81:
-#line 288 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+#line 430 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[0]).last_line;
+		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 82:
-#line 289 "ael.y"
-    {(yyval.pval)=(yyvsp[-2].pval); (yyval.pval)->u2.statements = (yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+#line 434 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[0]).last_line;
+		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 83:
-#line 290 "ael.y"
-    {(yyval.pval) = (yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[-1]).last_line; (yyval.pval)->endcol = (yylsp[-1]).last_column;;}
+#line 439 "ael.y"
+    {
+		(yyval.pval) = (yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[-1]).last_line;
+		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
     break;
 
   case 84:
-#line 291 "ael.y"
-    { (yyval.pval) = (yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+#line 443 "ael.y"
+    {
+		(yyval.pval) = (yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[0]).last_line;
+		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 85:
-#line 292 "ael.y"
-    { (yyval.pval)= npval(PV_APPLICATION_CALL,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); 
-																						(yyval.pval)->u1.str = (yyvsp[-1].str);;}
+#line 447 "ael.y"
+    {
+		(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
   case 86:
-#line 294 "ael.y"
+#line 450 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
   case 87:
-#line 294 "ael.y"
+#line 450 "ael.y"
     {
-                          char *bufx;
-						  int tot=0;
-						  pval *pptr;
-						  
-                          (yyval.pval) = npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column);
-						  (yyval.pval)->u2.val=(yyvsp[-1].str);
-						  /* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
-                          /* string to big to fit in the buffer? */
-						  tot+=strlen((yyvsp[-4].pval)->u1.str);
-						  for(pptr=(yyvsp[-4].pval)->u2.arglist;pptr;pptr=pptr->next) {
-							  tot+=strlen(pptr->u1.str);
-							  tot++; /* for a sep like a comma */
-						  }
-						  tot+=4; /* for safety */
-						  bufx = (char *)malloc(tot);
-						  strcpy(bufx,(yyvsp[-4].pval)->u1.str);
-						  strcat(bufx,"(");
-						  for (pptr=(yyvsp[-4].pval)->u2.arglist;pptr;pptr=pptr->next) {
-							  if ( pptr != (yyvsp[-4].pval)->u2.arglist )
-								  strcat(bufx,",");
-							  strcat(bufx,pptr->u1.str);
-						  }
-						  strcat(bufx,")");
+		char *bufx;
+		int tot=0;
+		pval *pptr;
+		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u2.val=(yyvsp[-1].str);
+		/* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
+		/* string to big to fit in the buffer? */
+		tot+=strlen((yyvsp[-4].pval)->u1.str);
+		for(pptr=(yyvsp[-4].pval)->u2.arglist;pptr;pptr=pptr->next) {
+			tot+=strlen(pptr->u1.str);
+			tot++; /* for a sep like a comma */
+		}
+		tot+=4; /* for safety */
+		bufx = ast_calloc(1, tot);
+		strcpy(bufx,(yyvsp[-4].pval)->u1.str);
+		strcat(bufx,"(");
+		/* XXX need to advance the pointer or the loop is very inefficient */
+		for (pptr=(yyvsp[-4].pval)->u2.arglist;pptr;pptr=pptr->next) {
+			if ( pptr != (yyvsp[-4].pval)->u2.arglist )
+				strcat(bufx,",");
+			strcat(bufx,pptr->u1.str);
+		}
+		strcat(bufx,")");
 #ifdef AAL_ARGCHECK
-						  if ( !ael_is_funcname((yyvsp[-4].pval)->u1.str) )
-                              ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n", 
-									  my_file, (yylsp[-4]).first_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column, (yyvsp[-4].pval)->u1.str);
+		if ( !ael_is_funcname((yyvsp[-4].pval)->u1.str) )
+			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n",
+				my_file, (yylsp[-4]).first_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column, (yyvsp[-4].pval)->u1.str);
 #endif
-						  (yyval.pval)->u1.str = bufx;
-						  destroy_pval((yyvsp[-4].pval)); /* the app call it is not, get rid of that chain */
-						  prev_word = 0;
-                       ;}
+		(yyval.pval)->u1.str = bufx;
+		destroy_pval((yyvsp[-4].pval)); /* the app call it is not, get rid of that chain */
+		prev_word = 0;
+	;}
     break;
 
   case 88:
-#line 327 "ael.y"
-    { (yyval.pval) = npval(PV_BREAK,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column);;}
+#line 483 "ael.y"
+    { (yyval.pval) = npval2(PV_BREAK, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
   case 89:
-#line 328 "ael.y"
-    {(yyval.pval) = npval(PV_RETURN,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column);;}
+#line 484 "ael.y"
+    { (yyval.pval) = npval2(PV_RETURN, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
   case 90:
-#line 329 "ael.y"
-    {(yyval.pval) = npval(PV_CONTINUE,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column);;}
+#line 485 "ael.y"
+    { (yyval.pval) = npval2(PV_CONTINUE, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
   case 91:
-#line 330 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval); (yyval.pval)->u2.statements = (yyvsp[0].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+#line 486 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->endline = (yylsp[0]).last_line;
+		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 92:
-#line 331 "ael.y"
-    {(yyval.pval)=(yyvsp[-3].pval); (yyval.pval)->u2.statements = (yyvsp[-2].pval);(yyval.pval)->endline = (yylsp[-2]).last_line; (yyval.pval)->endcol = (yylsp[-2]).last_column; (yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+#line 491 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-3].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-2].pval);
+		(yyval.pval)->endline = (yylsp[-2]).last_line;
+		(yyval.pval)->endcol = (yylsp[-2]).last_column;
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 93:
-#line 332 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval); (yyval.pval)->u2.statements = (yyvsp[0].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+#line 497 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->endline = (yylsp[0]).last_line;
+		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 94:
-#line 333 "ael.y"
-    {(yyval.pval)=(yyvsp[-3].pval); (yyval.pval)->u2.statements = (yyvsp[-2].pval);(yyval.pval)->endline = (yylsp[-2]).last_line; (yyval.pval)->endcol = (yylsp[-2]).last_column; (yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+#line 502 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-3].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-2].pval);
+		(yyval.pval)->endline = (yylsp[-2]).last_line;
+		(yyval.pval)->endcol = (yylsp[-2]).last_column;
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 95:
-#line 334 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval); (yyval.pval)->u2.statements = (yyvsp[0].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+#line 508 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->endline = (yylsp[0]).last_line;
+		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 96:
-#line 335 "ael.y"
-    {(yyval.pval)=(yyvsp[-3].pval); (yyval.pval)->u2.statements = (yyvsp[-2].pval);(yyval.pval)->endline = (yylsp[-2]).last_line; (yyval.pval)->endcol = (yylsp[-2]).last_column; (yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+#line 513 "ael.y"
+    {
+		(yyval.pval)=(yyvsp[-3].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-2].pval);
+		(yyval.pval)->endline = (yylsp[-2]).last_line;
+		(yyval.pval)->endcol = (yylsp[-2]).last_column;
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 97:
-#line 336 "ael.y"
+#line 519 "ael.y"
     { (yyval.pval)=0; ;}
     break;
 
   case 98:
-#line 339 "ael.y"
-    { (yyval.pval) = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[0].str);;}
+#line 522 "ael.y"
+    { (yyval.pval) = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[0].str);;}
     break;
 
   case 99:
-#line 340 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
+#line 524 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
     break;
 
   case 100:
-#line 343 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
+#line 529 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
     break;
 
   case 101:
-#line 346 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[-4].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-2].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+#line 534 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
   case 102:
-#line 351 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[-4].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-2].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+#line 541 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
   case 103:
-#line 356 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)->u1.str = strdup("default"); (yyval.pval)->next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-2].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+#line 548 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
   case 104:
-#line 361 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)->u1.str = strdup("default"); (yyval.pval)->next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-2].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+#line 555 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
   case 105:
-#line 368 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[0].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->u1.str = strdup("1");;}
+#line 564 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[0].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0])); /* XXX not really @1 */
+		(yyval.pval)->next->u1.str = strdup("1");;}
     break;
 
   case 106:
-#line 371 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
+#line 569 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
     break;
 
   case 107:
-#line 374 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[0].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-4].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
+#line 574 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
+		(yyval.pval)->u1.str = (yyvsp[0].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->next->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 108:
-#line 379 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->u1.str = (yyvsp[0].str); (yyval.pval)->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-2].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = strdup("1"); ;}
+#line 581 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->u1.str = (yyvsp[0].str);
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = strdup("1"); ;}
     break;
 
   case 109:
-#line 384 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)->u1.str = strdup("default"); (yyval.pval)->next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-4].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
+#line 588 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->next->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 110:
-#line 389 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)->u1.str = strdup("default"); (yyval.pval)->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->u1.str = (yyvsp[-2].str); 
-					(yyval.pval)->next->next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)->next->next->u1.str = strdup("1"); ;}
+#line 595 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
+		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->next->next->u1.str = strdup("1"); ;}
     break;
 
   case 111:
-#line 396 "ael.y"
+#line 604 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
   case 112:
-#line 397 "ael.y"
-    {(yyval.pval)= npval(PV_MACRO_CALL,(yylsp[-4]).first_line,(yylsp[-3]).last_line, (yylsp[-4]).first_column, (yylsp[-3]).last_column); 
-			(yyval.pval)->u1.str = (yyvsp[-4].str); (yyval.pval)->u2.arglist = (yyvsp[-1].pval);;}
+#line 604 "ael.y"
+    {
+		/* XXX original code had @2 but i think we need @5 */
+		(yyval.pval) = npval2(PV_MACRO_CALL, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-4].str);
+		(yyval.pval)->u2.arglist = (yyvsp[-1].pval);;}
     break;
 
   case 113:
-#line 399 "ael.y"
-    {(yyval.pval)= npval(PV_MACRO_CALL,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+#line 609 "ael.y"
+    {
+		(yyval.pval)= npval2(PV_MACRO_CALL, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 114:
-#line 402 "ael.y"
+#line 614 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
   case 115:
-#line 402 "ael.y"
-    {if (strcasecmp((yyvsp[-2].str),"goto") == 0) {
-																							(yyval.pval)= npval(PV_GOTO,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column);
-																							free((yyvsp[-2].str)); /* won't be using this */
-																							ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n", my_file, (yylsp[-2]).first_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column );
-																						} else
-																							(yyval.pval)= npval(PV_APPLICATION_CALL,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); 
-																						(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+#line 614 "ael.y"
+    {
+		if (strcasecmp((yyvsp[-2].str),"goto") == 0) {
+			(yyval.pval)= npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
+			free((yyvsp[-2].str)); /* won't be using this */
+			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n", my_file, (yylsp[-2]).first_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column );
+		} else
+			(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 116:
-#line 411 "ael.y"
+#line 624 "ael.y"
     {(yyval.pval) = (yyvsp[-2].pval);
  		if( (yyval.pval)->type == PV_GOTO )
 			(yyval.pval)->u1.list = (yyvsp[-1].pval);
@@ -2506,244 +2796,289 @@
     break;
 
   case 117:
-#line 417 "ael.y"
+#line 630 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
   case 118:
-#line 420 "ael.y"
-    { (yyval.pval)= npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[0].str);;}
+#line 633 "ael.y"
+    { 
+		(yyval.pval)= npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[0].str);;}
     break;
 
   case 119:
-#line 421 "ael.y"
-    { (yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/); (yyval.pval)->u1.str = strdup(""); ;}
+#line 636 "ael.y"
+    {
+		(yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
+		(yyval.pval)->u1.str = strdup(""); ;}
     break;
 
   case 120:
-#line 422 "ael.y"
-    { pval *z = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval) = (yyvsp[-2].pval); linku1((yyvsp[-2].pval),z); z->u1.str = (yyvsp[0].str);;}
+#line 639 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval) = (yyvsp[-2].pval);
+		linku1((yyvsp[-2].pval),z);
+		z->u1.str = (yyvsp[0].str);;}
     break;
 
   case 121:
-#line 423 "ael.y"
-    { pval *z = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval) = (yyvsp[-1].pval); linku1((yyvsp[-1].pval),z); z->u1.str = strdup("");;}
+#line 644 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		(yyval.pval) = (yyvsp[-1].pval);
+		linku1((yyvsp[-1].pval),z);
+		z->u1.str = strdup("");;}
     break;
 
   case 122:
-#line 426 "ael.y"
+#line 651 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 123:
-#line 427 "ael.y"
-    { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
+#line 652 "ael.y"
+    { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 124:
-#line 432 "ael.y"
-    {(yyval.pval) = npval(PV_CASE,(yylsp[-3]).first_line,(yylsp[-1]).last_line, (yylsp[-3]).first_column, (yylsp[-1]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval);;}
+#line 657 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CASE, &(yylsp[-3]), &(yylsp[-1])); /* XXX 3 or 4 ? */
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
   case 125:
-#line 433 "ael.y"
-    {(yyval.pval) = npval(PV_DEFAULT,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = 0; (yyval.pval)->u2.statements = (yyvsp[0].pval);;}
+#line 661 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.str = NULL;
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
   case 126:
-#line 434 "ael.y"
-    {(yyval.pval) = npval(PV_PATTERN,(yylsp[-3]).first_line,(yylsp[-1]).last_line, (yylsp[-3]).first_column, (yylsp[-1]).last_column); (yyval.pval)->u1.str = (yyvsp[-2].str); (yyval.pval)->u2.statements = (yyvsp[0].pval);;}
+#line 665 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-3]), &(yylsp[0])); /* XXX at 3 or @4 ? */
+		(yyval.pval)->u1.str = (yyvsp[-2].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
   case 127:
-#line 435 "ael.y"
-    {(yyval.pval) = npval(PV_CASE,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str);;}
+#line 669 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CASE, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
   case 128:
-#line 436 "ael.y"
-    {(yyval.pval) = npval(PV_DEFAULT,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = 0;;}
+#line 672 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.str = NULL;;}
     break;
 
   case 129:
-#line 437 "ael.y"
-    {(yyval.pval) = npval(PV_PATTERN,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str);;}
+#line 675 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
   case 130:
-#line 440 "ael.y"
+#line 680 "ael.y"
     {(yyval.pval) = (yyvsp[0].pval);;}
     break;
 
   case 131:
-#line 441 "ael.y"
-    { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
+#line 681 "ael.y"
+    { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 132:
-#line 446 "ael.y"
+#line 686 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 133:
-#line 447 "ael.y"
-    {(yyval.pval)=npval(PV_CATCH,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-3].str); (yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
+#line 687 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_CATCH, &(yylsp[-4]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
     break;
 
   case 134:
-#line 450 "ael.y"
-    {(yyval.pval)= npval(PV_SWITCHES,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+#line 693 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
   case 135:
-#line 451 "ael.y"
-    {(yyval.pval)= npval(PV_SWITCHES,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column);;}
+#line 696 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
   case 136:
-#line 454 "ael.y"
-    {(yyval.pval)= npval(PV_ESWITCHES,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+#line 700 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
   case 137:
-#line 455 "ael.y"
-    {(yyval.pval)= npval(PV_ESWITCHES,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); ;}
+#line 703 "ael.y"
+    { /* empty switch list OK */
+		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
   case 138:
-#line 458 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str);;}
+#line 707 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
   case 139:
-#line 459 "ael.y"
-    {pval *z = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)=(yyvsp[-2].pval); z->u1.str = (yyvsp[-1].str); linku1((yyval.pval),z); ;}
+#line 710 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
+		z->u1.str = (yyvsp[-1].str);
+		(yyval.pval)=(yyvsp[-2].pval);
+		linku1((yyval.pval),z); ;}
     break;
 
   case 140:
-#line 460 "ael.y"
+#line 715 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 141:
-#line 463 "ael.y"
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.str = (yyvsp[-1].str);;}
+#line 718 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
   case 142:
-#line 464 "ael.y"
+#line 722 "ael.y"
     {
-                    (yyval.pval)=npval(PV_WORD,(yylsp[-13]).first_line,(yylsp[-12]).last_line, (yylsp[-13]).first_column, (yylsp[-12]).last_column); 
-                    (yyval.pval)->u1.str = (yyvsp[-13].str);
-					(yyval.pval)->u2.arglist = npval(PV_WORD,(yylsp[-11]).first_line,(yylsp[-7]).last_line, (yylsp[-11]).first_column, (yylsp[-7]).last_column); 
-					(yyval.pval)->u2.arglist->u1.str = (char*)malloc(strlen((yyvsp[-11].str))+strlen((yyvsp[-9].str))+strlen((yyvsp[-7].str))+4);
-					strcpy((yyval.pval)->u2.arglist->u1.str,(yyvsp[-11].str));
-					strcat((yyval.pval)->u2.arglist->u1.str,":");
-					strcat((yyval.pval)->u2.arglist->u1.str,(yyvsp[-9].str));
-					strcat((yyval.pval)->u2.arglist->u1.str,":");
-					strcat((yyval.pval)->u2.arglist->u1.str,(yyvsp[-7].str));
-					free((yyvsp[-11].str));
-					free((yyvsp[-9].str));
-					free((yyvsp[-7].str));
-					(yyval.pval)->u2.arglist->next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)->u2.arglist->next->u1.str = (yyvsp[-5].str); 
-					(yyval.pval)->u2.arglist->next->next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)->u2.arglist->next->next->u1.str = (yyvsp[-3].str); 
-					(yyval.pval)->u2.arglist->next->next->next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str); 
-					prev_word=0;
-			;}
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-13]), &(yylsp[-12]));
+		(yyval.pval)->u1.str = (yyvsp[-13].str);
+		(yyval.pval)->u2.arglist = npval2(PV_WORD, &(yylsp[-11]), &(yylsp[-7]));
+		asprintf( &((yyval.pval)->u2.arglist->u1.str), "%s:%s:%s", (yyvsp[-11].str), (yyvsp[-9].str), (yyvsp[-7].str));
+		free((yyvsp[-11].str));
+		free((yyvsp[-9].str));
+		free((yyvsp[-7].str));
+		(yyval.pval)->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
+		(yyval.pval)->u2.arglist->next->u1.str = (yyvsp[-5].str);
+		(yyval.pval)->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
+		(yyval.pval)->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
+		(yyval.pval)->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 143:
-#line 485 "ael.y"
+#line 738 "ael.y"
     {
-                    (yyval.pval)=npval(PV_WORD,(yylsp[-9]).first_line,(yylsp[-8]).last_line, (yylsp[-9]).first_column, (yylsp[-8]).last_column); 
-                    (yyval.pval)->u1.str = (yyvsp[-9].str);
-					(yyval.pval)->u2.arglist = npval(PV_WORD,(yylsp[-7]).first_line,(yylsp[-7]).last_line, (yylsp[-7]).first_column, (yylsp[-7]).last_column); 
-					(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
-					(yyval.pval)->u2.arglist->next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)->u2.arglist->next->u1.str = (yyvsp[-5].str); 
-					(yyval.pval)->u2.arglist->next->next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)->u2.arglist->next->next->u1.str = (yyvsp[-3].str); 
-					(yyval.pval)->u2.arglist->next->next->next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str); 
-					prev_word=0;
-			;}
+		(yyval.pval) = npval2(PV_WORD, &(yylsp[-9]), &(yylsp[-8]));
+		(yyval.pval)->u1.str = (yyvsp[-9].str);
+		(yyval.pval)->u2.arglist = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
+		(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
+		(yyval.pval)->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
+		(yyval.pval)->u2.arglist->next->u1.str = (yyvsp[-5].str);
+		(yyval.pval)->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
+		(yyval.pval)->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
+		(yyval.pval)->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
+		(yyval.pval)->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 144:
-#line 498 "ael.y"
-    {pval *z = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)=(yyvsp[-2].pval); z->u1.str = (yyvsp[-1].str); linku1((yyval.pval),z); ;}
+#line 751 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0])); /* XXX don't we need @1- at 4 ?*/
+		(yyval.pval)=(yyvsp[-2].pval);
+		z->u1.str = (yyvsp[-1].str);
+		linku1((yyval.pval),z); ;}
     break;
 
   case 145:
-#line 499 "ael.y"
-    {pval *z = npval(PV_WORD,(yylsp[-13]).first_line,(yylsp[-12]).last_line, (yylsp[-13]).first_column, (yylsp[-12]).last_column); 
-					(yyval.pval)=(yyvsp[-14].pval); z->u1.str = (yyvsp[-13].str); linku1((yyval.pval),z);
-					z->u2.arglist = npval(PV_WORD,(yylsp[-11]).first_line,(yylsp[-11]).last_line, (yylsp[-11]).first_column, (yylsp[-11]).last_column); 
-					(yyval.pval)->u2.arglist->u1.str = (char*)malloc(strlen((yyvsp[-11].str))+strlen((yyvsp[-9].str))+strlen((yyvsp[-7].str))+4);
-					strcpy((yyval.pval)->u2.arglist->u1.str,(yyvsp[-11].str));
-					strcat((yyval.pval)->u2.arglist->u1.str,":");
-					strcat((yyval.pval)->u2.arglist->u1.str,(yyvsp[-9].str));
-					strcat((yyval.pval)->u2.arglist->u1.str,":");
-					strcat((yyval.pval)->u2.arglist->u1.str,(yyvsp[-7].str));
-					free((yyvsp[-11].str));
-					free((yyvsp[-9].str));
-					free((yyvsp[-7].str));
-					z->u2.arglist->next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					z->u2.arglist->next->u1.str = (yyvsp[-5].str); 
-					z->u2.arglist->next->next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					z->u2.arglist->next->next->u1.str = (yyvsp[-3].str); 
-					z->u2.arglist->next->next->next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					z->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str); 
-					prev_word=0;
-			;}
+#line 757 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[-13]), &(yylsp[-12]));
+		(yyval.pval)=(yyvsp[-14].pval); z->u1.str = (yyvsp[-13].str);
+		linku1((yyval.pval),z);
+		z->u2.arglist = npval2(PV_WORD, &(yylsp[-11]), &(yylsp[-11]));
+		asprintf( &((yyval.pval)->u2.arglist->u1.str), "%s:%s:%s", (yyvsp[-11].str), (yyvsp[-9].str), (yyvsp[-7].str));
+		free((yyvsp[-11].str));
+		free((yyvsp[-9].str));
+		free((yyvsp[-7].str));
+		z->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
+		z->u2.arglist->next->u1.str = (yyvsp[-5].str);
+		z->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
+		z->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
+		z->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
+		z->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 146:
-#line 520 "ael.y"
-    {pval *z = npval(PV_WORD,(yylsp[-9]).first_line,(yylsp[-9]).last_line, (yylsp[-9]).first_column, (yylsp[-8]).last_column);
-					(yyval.pval)=(yyvsp[-10].pval); z->u1.str = (yyvsp[-9].str); linku1((yyval.pval),z);
-					z->u2.arglist = npval(PV_WORD,(yylsp[-7]).first_line,(yylsp[-7]).last_line, (yylsp[-7]).first_column, (yylsp[-7]).last_column);
-					(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
-					z->u2.arglist->next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column);
-					z->u2.arglist->next->u1.str = (yyvsp[-5].str);
-					z->u2.arglist->next->next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column);
-					z->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
-					z->u2.arglist->next->next->next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column);
-					z->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
-					prev_word=0;
-			;}
+#line 774 "ael.y"
+    {
+		pval *z = npval2(PV_WORD, &(yylsp[-9]), &(yylsp[-8]));
+		(yyval.pval)=(yyvsp[-10].pval);
+		z->u1.str = (yyvsp[-9].str); linku1((yyval.pval),z);
+		z->u2.arglist = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
+		(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
+		z->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
+		z->u2.arglist->next->u1.str = (yyvsp[-5].str);
+		z->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
+		z->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
+		z->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
+		z->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 147:
-#line 532 "ael.y"
+#line 788 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 148:
-#line 535 "ael.y"
+#line 791 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 149:
-#line 536 "ael.y"
+#line 792 "ael.y"
     {(yyval.str)=strdup("default");;}
     break;
 
   case 150:
-#line 539 "ael.y"
-    {(yyval.pval)= npval(PV_INCLUDES,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)->u1.list = (yyvsp[-1].pval);;}
+#line 795 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
   case 151:
-#line 540 "ael.y"
-    {(yyval.pval)= npval(PV_INCLUDES,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column);;}
+#line 798 "ael.y"
+    {
+		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-2]), &(yylsp[0]));;}
     break;
 
 
@@ -2751,7 +3086,7 @@
     }
 
 /* Line 1126 of yacc.c.  */
-#line 2755 "ael.tab.c"
+#line 3090 "ael.tab.c"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -3026,10 +3361,10 @@
 }
 
 
-#line 544 "ael.y"
+#line 803 "ael.y"
 
 
-static char *token_equivs1[] = 
+static char *token_equivs1[] =
 {
 	"AMPER",
 	"AT",
@@ -3038,15 +3373,15 @@
 	"COMMA",
 	"EQ",
 	"EXTENMARK",
-	"KW_BREAK", 
-	"KW_CASE", 
-	"KW_CATCH", 
+	"KW_BREAK",
+	"KW_CASE",
+	"KW_CATCH",
 	"KW_CONTEXT",
-	"KW_CONTINUE", 
-	"KW_DEFAULT", 
+	"KW_CONTINUE",
+	"KW_DEFAULT",
 	"KW_ELSE",
 	"KW_ESWITCHES",
-	"KW_FOR", 
+	"KW_FOR",
 	"KW_GLOBALS",
 	"KW_GOTO",
 	"KW_HINT",
@@ -3056,12 +3391,12 @@
 	"KW_INCLUDES"
 	"KW_JUMP",
 	"KW_MACRO",
-	"KW_PATTERN", 
-	"KW_REGEXTEN", 
-	"KW_RETURN", 
-	"KW_SWITCHES", 
+	"KW_PATTERN",
+	"KW_REGEXTEN",
+	"KW_RETURN",
+	"KW_SWITCHES",
 	"KW_SWITCH",
-	"KW_WHILE", 
+	"KW_WHILE",
 	"LC",
 	"LP",
 	"RC",
@@ -3069,7 +3404,7 @@
 	"SEMI",
 };
 
-static char *token_equivs2[] = 
+static char *token_equivs2[] =
 {
 	"&",
 	"@",
@@ -3078,15 +3413,15 @@
 	",",
 	"=",
 	"=>",
-	"break", 
-	"case", 
-	"catch", 
+	"break",
+	"case",
+	"catch",
 	"context",
-	"continue", 
-	"default", 
+	"continue",
+	"default",
 	"else",
 	"eswitches",
-	"for", 
+	"for",
 	"globals",
 	"goto",
 	"hint",
@@ -3096,12 +3431,12 @@
 	"includes"
 	"jump",
 	"macro",
-	"pattern", 
-	"regexten", 
-	"return", 
-	"switches", 
+	"pattern",
+	"regexten",
+	"return",
+	"switches",
 	"switch",
-	"while", 
+	"while",
 	"{",
 	"(",
 	"}",
@@ -3129,7 +3464,7 @@
 		}
 		len++;
 	}
-	res = (char*)malloc(len+1);
+	res = ast_calloc(1, len+1);
 	res[0] = 0;
 	s = res;
 	for (p=mess; *p;) {
@@ -3165,10 +3500,11 @@
 	parseio->syntax_error_count++;
 }
 
-struct pval *npval(pvaltype type,int first_line, int last_line, int first_column, int last_column)
+static struct pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column)
 {
 	extern char *my_file;
-	pval *z = (pval *)calloc(sizeof(struct pval),1);
+	pval *z = ast_calloc(1, sizeof(struct pval));
 	z->type = type;
 	z->startline = first_line;
 	z->endline = last_line;
@@ -3178,15 +3514,24 @@
 	return z;
 }
 
-void linku1(pval *head, pval *tail)
+static struct pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last)
 {
+	return npval(type, first->first_line, last->last_line,
+			first->first_column, last->last_column);
+}
+
+/* append second element to the list in the first one */
+static pval * linku1(pval *head, pval *tail)
+{
+	if (!head)
+		return tail;
 	if (!head->next) {
 		head->next = tail;
-		head->u1_last = tail;
 	} else {
 		head->u1_last->next = tail;
-		head->u1_last = tail;
 	}
+	head->u1_last = tail;
+	return head;
 }
 
 

Modified: trunk/pbx/ael/ael.tab.h
===================================================================
--- trunk/pbx/ael/ael.tab.h	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.tab.h	2006-04-29 02:51:28 UTC (rev 3)
@@ -115,7 +115,7 @@
 
 
 #if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 47 "ael.y"
+#line 53 "ael.y"
 typedef union YYSTYPE {
 	char *str;
 	struct pval *pval;

Modified: trunk/pbx/ael/ael.y
===================================================================
--- trunk/pbx/ael/ael.y	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.y	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,6 +1,6 @@
 %{
 /*
- * Asterisk -- An open source telephony toolkit. 
+ * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 2006, Digium, Inc.
  *
@@ -19,18 +19,25 @@
 /*! \file
  *
  * \brief Bison Grammar description of AEL2.
- * 
+ *
  */
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include "asterisk/logger.h"
+#include "asterisk/utils.h"		/* ast_calloc() */
 #include "asterisk/ael_structs.h"
 
-extern void reset_parencount(yyscan_t yyscanner);
-extern void reset_semicount(yyscan_t yyscanner);
-extern void reset_argcount(yyscan_t yyscanner );
+/* create a new object with start-end marker */
+static pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column);
 
+static pval * linku1(pval *head, pval *tail);
+
+void reset_parencount(yyscan_t yyscanner);
+void reset_semicount(yyscan_t yyscanner);
+void reset_argcount(yyscan_t yyscanner );
+
 #define YYLEX_PARAM ((struct parse_io *)parseio)->scanner
 #define YYERROR_VERBOSE 1
 
@@ -38,9 +45,8 @@
 #ifdef AAL_ARGCHECK
 int ael_is_funcname(char *name);
 #endif
- static char *ael_token_subst(char *mess);
- extern char *prev_word;
- 
+static char *ael_token_subst(char *mess);
+
 %}
 
 
@@ -53,10 +59,14 @@
 	/* declaring these AFTER the union makes things a lot simpler! */
 void yyerror(YYLTYPE *locp, struct parse_io *parseio, char const *s);
 int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void * yyscanner);
-	
+
+/* create a new object with start-end marker, simplified interface.
+ * Must be declared here because YYLTYPE is not known before
+ */
+static pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last);
 %}
 
- 
+
 %token KW_CONTEXT LC RC LP RP SEMI EQ COMMA COLON AMPER BAR AT
 %token KW_MACRO KW_GLOBALS KW_IGNOREPAT KW_SWITCH KW_IF KW_IFTIME KW_ELSE KW_RANDOM KW_ABSTRACT
 %token EXTENMARK KW_GOTO KW_JUMP KW_RETURN KW_BREAK KW_CONTINUE KW_REGEXTEN KW_HINT
@@ -81,9 +91,7 @@
 %type <pval>target jumptarget
 %type <pval>statement
 %type <pval>switch_head
-%type <str>word_list goto_word
-%type <str>word3_list
-%type <str>includedname
+
 %type <pval>if_head
 %type <pval>random_head
 %type <pval>iftime_head
@@ -99,25 +107,48 @@
 %type <pval>macro
 %type <pval>context
 %type <pval>object
-%type <pval>objects 
-%type <pval>file 
+%type <pval>objects
+%type <pval>file
 
-/* OPTIONS */
-%locations
-%pure-parser
+%type <str>goto_word
+%type <str>word_list
+%type <str>word3_list
+%type <str>includedname
+
+/*
+ * OPTIONS
+ */
+
+%locations	/* track source location using @n variables (yylloc in flex) */
+%pure-parser	/* pass yylval and yylloc as arguments to yylex(). */
 %name-prefix="ael_yy"
-/* the following option does two things: 
-    it adds the locp arg to the yyerror
-    and it adds the NULL to the yyerrr arg list, and calls yyerror with NULL for that arg.
-    You can't get the locp arg without the NULL arg, don't ask me why. */
+/*
+ * add an additional argument, parseio, to yyparse(),
+ * which is then accessible in the grammar actions
+ */
 %parse-param {struct parse_io *parseio}
-/* there will be two shift/reduce conflicts, they involve the if statement, where a single statement occurs not wrapped in curlies in the "true" section 
+
+/* there will be two shift/reduce conflicts, they involve the if statement, where a single statement occurs not wrapped in curlies in the "true" section
    the default action to shift will attach the else to the preceeding if. */
 %expect 5
 %error-verbose
-%destructor { if (yymsg[0] != 'C') {destroy_pval($$); prev_word=0;} else {printf("Cleanup destructor called for pvals\n");} } includes includeslist switchlist eswitches switches macro_statement macro_statements case_statement case_statements eval_arglist application_call 
-                                application_call_head macro_call target jumptarget statement switch_head if_head random_head iftime_head statements extension ignorepat element
-                                elements arglist global_statement global_statements globals macro context object objects
+
+/*
+ * declare destructors for objects.
+ * The former is for pval, the latter for strings.
+ * NOTE: we must not have a destructor for a 'file' object.
+ */
+%destructor {
+		destroy_pval($$);
+		prev_word=0;
+	}	includes includeslist switchlist eswitches switches
+		macro_statement macro_statements case_statement case_statements
+		eval_arglist application_call application_call_head
+		macro_call target jumptarget statement switch_head
+		if_head random_head iftime_head statements extension
+		ignorepat element elements arglist global_statement
+		global_statements globals macro context object objects
+
 %destructor { free($$);}  word word_list goto_word word3_list includedname
 
 
@@ -127,9 +158,17 @@
 	;
 
 objects : object {$$=$1;}
-	| objects object {if ( $1 && $2 ) {$$=$1; linku1($$,$2);} 
-						 else if ( $1 ) {$$=$1;}
-						 else if ( $2 ) {$$=$2;} }
+	| objects object
+		{
+			if ( $1 && $2 ) {
+				$$=$1;
+				linku1($$,$2);
+			} else if ( $1 ) {
+				$$=$1;
+			} else if ( $2 ) {
+				$$=$2;
+			}
+		}
 	| objects error {$$=$1;}
 	;
 
@@ -139,25 +178,60 @@
 	| SEMI  {$$=0;/* allow older docs to be read */}
 	;
 
-context : KW_CONTEXT word LC elements RC {$$=npval(PV_CONTEXT, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = $2; $$->u2.statements = $4; }
-	| KW_CONTEXT word LC RC /* empty context OK */ {$$=npval(PV_CONTEXT, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.str = $2; }
-	| KW_CONTEXT KW_DEFAULT LC elements RC  {$$=npval(PV_CONTEXT, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = strdup("default"); $$->u2.statements = $4; }
-	| KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {$$=npval(PV_CONTEXT, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.str = strdup("default"); }
-    | KW_ABSTRACT KW_CONTEXT word LC elements RC {$$=npval(PV_CONTEXT, at 1.first_line, at 6.last_line, @1.first_column, @6.last_column); $$->u1.str = $3; $$->u2.statements = $5;  $$->u3.abstract = 1;}
-	| KW_ABSTRACT KW_CONTEXT word LC RC /* empty context OK */ {$$=npval(PV_CONTEXT, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = $3; $$->u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC elements RC  {$$=npval(PV_CONTEXT, at 1.first_line, at 6.last_line, @1.first_column, @6.last_column); $$->u1.str = strdup("default"); $$->u2.statements = $5; $$->u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {$$=npval(PV_CONTEXT, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = strdup("default"); $$->u3.abstract = 1; }
+context : KW_CONTEXT word LC elements RC {
+		$$ = npval2(PV_CONTEXT, &@1, &@5);
+		$$->u1.str = $2;
+		$$->u2.statements = $4; }
+	| KW_CONTEXT word LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &@1, &@4);
+		$$->u1.str = $2; }
+	| KW_CONTEXT KW_DEFAULT LC elements RC {
+		$$ = npval2(PV_CONTEXT, &@1, &@5);
+		$$->u1.str = strdup("default");
+		$$->u2.statements = $4; }
+	| KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &@1, &@4);
+		$$->u1.str = strdup("default"); }
+	| KW_ABSTRACT KW_CONTEXT word LC elements RC {
+		$$ = npval2(PV_CONTEXT, &@1, &@6);
+		$$->u1.str = $3;
+		$$->u2.statements = $5;
+		$$->u3.abstract = 1; }
+	| KW_ABSTRACT KW_CONTEXT word LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &@1, &@5);
+		$$->u1.str = $3;
+		$$->u3.abstract = 1; }
+	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC elements RC  {
+		$$ = npval2(PV_CONTEXT, &@1, &@6);
+		$$->u1.str = strdup("default");
+		$$->u2.statements = $5;
+		$$->u3.abstract = 1; }
+	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &@1, &@5);
+		$$->u1.str = strdup("default");
+		$$->u3.abstract = 1; }
 	;
 
-macro : KW_MACRO word LP arglist RP LC macro_statements RC {$$=npval(PV_MACRO, at 1.first_line, at 8.last_line, @1.first_column, @8.last_column); 
-																	 $$->u1.str = $2; $$->u2.arglist = $4; $$->u3.macro_statements = $7; }
-	| KW_MACRO word LP arglist RP LC  RC {$$=npval(PV_MACRO, at 1.first_line, at 7.last_line, @1.first_column, @7.last_column); $$->u1.str = $2; $$->u2.arglist = $4; }
-	| KW_MACRO word LP RP LC macro_statements RC {$$=npval(PV_MACRO, at 1.first_line, at 7.last_line, @1.first_column, @7.last_column); $$->u1.str = $2; $$->u3.macro_statements = $6; }
-	| KW_MACRO word LP RP LC  RC {$$=npval(PV_MACRO, at 1.first_line, at 6.last_line, @1.first_column, @6.last_column); $$->u1.str = $2; /* pretty empty! */ }
+macro : KW_MACRO word LP arglist RP LC macro_statements RC {
+		$$ = npval2(PV_MACRO, &@1, &@8);
+		$$->u1.str = $2; $$->u2.arglist = $4; $$->u3.macro_statements = $7; }
+	| KW_MACRO word LP arglist RP LC  RC {
+		$$ = npval2(PV_MACRO, &@1, &@7);
+		$$->u1.str = $2; $$->u2.arglist = $4; }
+	| KW_MACRO word LP RP LC macro_statements RC {
+		$$ = npval2(PV_MACRO, &@1, &@7);
+		$$->u1.str = $2;
+		$$->u3.macro_statements = $6; }
+	| KW_MACRO word LP RP LC  RC {
+		$$ = npval2(PV_MACRO, &@1, &@6);
+		$$->u1.str = $2; }
 	;
 
-globals : KW_GLOBALS LC global_statements RC {$$=npval(PV_GLOBALS, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.statements = $3;}
-	| KW_GLOBALS LC RC /* empty global is OK */ {$$=npval(PV_GLOBALS, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); /* and that's all */ }
+globals : KW_GLOBALS LC global_statements RC {
+		$$ = npval2(PV_GLOBALS, &@1, &@4);
+		$$->u1.statements = $3;}
+	| KW_GLOBALS LC RC { /* empty globals is OK */
+		$$ = npval2(PV_GLOBALS, &@1, &@3); }
 	;
 
 global_statements : global_statement {$$=$1;}
@@ -165,19 +239,28 @@
 	| global_statements error {$$=$1;}
 	;
 
-global_statement : word EQ { reset_semicount(parseio->scanner); }  word SEMI {$$=npval(PV_VARDEC, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = $1;$$->u2.val = $4; }
+global_statement : word EQ { reset_semicount(parseio->scanner); }  word SEMI {
+		$$ = npval2(PV_VARDEC, &@1, &@5);
+		$$->u1.str = $1;
+		$$->u2.val = $4; }
 	;
 
-arglist : word {$$= npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); $$->u1.str = $1; }
-	| arglist COMMA word {pval *z = npval(PV_WORD, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); z->u1.str = $3; $$=$1; linku1($$,z); }
+arglist : word {
+		$$= npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1; }
+	| arglist COMMA word {
+		pval *z = npval2(PV_WORD, &@1, &@3);
+		z->u1.str = $3;
+		$$=$1;
+		linku1($$,z); }
 	| arglist error {$$=$1;}
 	;
 
 elements : element { $$=$1;}
-    | error {$$=0;}
-	| elements element { if ( $1 && $2 ) {$$=$1; linku1($$,$2);} 
-						 else if ( $1 ) {$$=$1;}
-						 else if ( $2 ) {$$=$2;} }
+	| error {$$=0;}
+	| elements element { if ( $1 && $2 ) {$$=$1; linku1($$,$2);}
+				else if ( $1 ) {$$=$1;}
+				else if ( $2 ) {$$=$2;} }
 	| elements error   { $$=$1;}
 	;
 
@@ -186,226 +269,356 @@
 	| switches {$$=$1;}
 	| eswitches {$$=$1;}
 	| ignorepat {$$=$1;}
-	| word EQ { reset_semicount(parseio->scanner); } word SEMI {$$=npval(PV_VARDEC, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = $1;$$->u2.val = $4; }
-    | word error {free($1); $$=0;}
+	| word EQ { reset_semicount(parseio->scanner); } word SEMI {
+		$$ = npval2(PV_VARDEC, &@1, &@5);
+		$$->u1.str = $1;
+		$$->u2.val = $4; }
+	| word error {free($1); $$=0;}
 	| SEMI  {$$=0;/* allow older docs to be read */}
 	;
 
-ignorepat : KW_IGNOREPAT EXTENMARK word SEMI { $$=npval(PV_IGNOREPAT, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.str = $3;}
+ignorepat : KW_IGNOREPAT EXTENMARK word SEMI {
+		$$ = npval2(PV_IGNOREPAT, &@1, &@4);
+		$$->u1.str = $3;}
 	;
 
-extension : word EXTENMARK statement {$$ = npval(PV_EXTENSION, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = $1; $$->u2.statements = $3; }
-		  | KW_REGEXTEN word EXTENMARK statement {$$ = npval(PV_EXTENSION, at 1.first_line, at 3.last_line, @1.first_column, @4.last_column); $$->u1.str = $2; $$->u2.statements = $4; $$->u4.regexten=1;}
-		  | KW_HINT LP word3_list RP word EXTENMARK statement {$$ = npval(PV_EXTENSION, at 1.first_line, at 7.last_line, @1.first_column, @7.last_column); $$->u1.str = $5; $$->u2.statements = $7; $$->u3.hints = $3;}
-		  | KW_REGEXTEN KW_HINT LP word3_list RP word EXTENMARK statement {$$ = npval(PV_EXTENSION, at 1.first_line, at 4.last_line, @1.first_column, @8.last_column); $$->u1.str = $6; $$->u2.statements = $8; $$->u4.regexten=1;$$->u3.hints = $4;}
+extension : word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &@1, &@3);
+		$$->u1.str = $1;
+		$$->u2.statements = $3; }
+	| KW_REGEXTEN word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &@1, &@4);
+		$$->u1.str = $2;
+		$$->u2.statements = $4;
+		$$->u4.regexten=1;}
+	| KW_HINT LP word3_list RP word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &@1, &@7);
+		$$->u1.str = $5;
+		$$->u2.statements = $7;
+		$$->u3.hints = $3;}
+	| KW_REGEXTEN KW_HINT LP word3_list RP word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &@1, &@8);
+		$$->u1.str = $6;
+		$$->u2.statements = $8;
+		$$->u4.regexten=1;
+		$$->u3.hints = $4;}
 
 	;
 
 statements : statement {$$=$1;}
-	| statements statement {if ( $1 && $2 ) {$$=$1; linku1($$,$2);} 
+	| statements statement {if ( $1 && $2 ) {$$=$1; linku1($$,$2);}
 						 else if ( $1 ) {$$=$1;}
 						 else if ( $2 ) {$$=$2;} }
 	| statements error {$$=$1;}
 	;
 
-if_head : KW_IF LP { reset_parencount(parseio->scanner); }  word_list RP { $$= npval(PV_IF, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = $4; }
-		;
+if_head : KW_IF LP { reset_parencount(parseio->scanner); }  word_list RP {
+		$$= npval2(PV_IF, &@1, &@5);
+		$$->u1.str = $4; }
+	;
 
-random_head : KW_RANDOM LP { reset_parencount(parseio->scanner); } word_list RP { $$= npval(PV_RANDOM, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str=$4;}
-		;
+random_head : KW_RANDOM LP { reset_parencount(parseio->scanner); } word_list RP {
+		$$ = npval2(PV_RANDOM, &@1, &@5);
+		$$->u1.str=$4;}
+	;
 
-iftime_head : KW_IFTIME LP word3_list COLON word3_list COLON word3_list BAR word3_list BAR word3_list BAR word3_list RP { $$= npval(PV_IFTIME, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); 
-					$$->u1.list = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->u1.list->u1.str = (char*)malloc(strlen($3)+strlen($5)+strlen($7)+4);
-					strcpy($$->u1.list->u1.str,$3);
-					strcat($$->u1.list->u1.str,":");
-					strcat($$->u1.list->u1.str,$5);
-					strcat($$->u1.list->u1.str,":");
-					strcat($$->u1.list->u1.str,$7);
-					free($3);
-					free($5);
-					free($7);
-					$$->u1.list->next = npval(PV_WORD, at 9.first_line, at 9.last_line, @9.first_column, @9.last_column); 
-					$$->u1.list->next->u1.str = $9; 
-					$$->u1.list->next->next = npval(PV_WORD, at 11.first_line, at 11.last_line, @11.first_column, @11.last_column); 
-					$$->u1.list->next->next->u1.str = $11; 
-					$$->u1.list->next->next->next = npval(PV_WORD, at 13.first_line, at 13.last_line, @13.first_column, @13.last_column); 
-					$$->u1.list->next->next->next->u1.str = $13; 
-					prev_word = 0;
-		}
-		| KW_IFTIME LP word BAR word3_list BAR word3_list BAR word3_list RP { $$= npval(PV_IFTIME, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); 
-					$$->u1.list = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->u1.list->u1.str = $3;
-					$$->u1.list->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->u1.list->next->u1.str = $5; 
-					$$->u1.list->next->next = npval(PV_WORD, at 7.first_line, at 7.last_line, @7.first_column, @7.last_column); 
-					$$->u1.list->next->next->u1.str = $7; 
-					$$->u1.list->next->next->next = npval(PV_WORD, at 9.first_line, at 9.last_line, @9.first_column, @9.last_column); 
-					$$->u1.list->next->next->next->u1.str = $9; 
-					prev_word = 0;
-		}
+iftime_head : KW_IFTIME LP word3_list COLON word3_list COLON word3_list
+		BAR word3_list BAR word3_list BAR word3_list RP {
+		$$ = npval2(PV_IFTIME, &@1, &@5); /* XXX really @5 or more ? */
+		$$->u1.list = npval2(PV_WORD, &@3, &@3);
+		asprintf(&($$->u1.list->u1.str), "%s:%s:%s", $3, $5, $7);
+		free($3);
+		free($5);
+		free($7);
+		$$->u1.list->next = npval2(PV_WORD, &@9, &@9);
+		$$->u1.list->next->u1.str = $9;
+		$$->u1.list->next->next = npval2(PV_WORD, &@11, &@11);
+		$$->u1.list->next->next->u1.str = $11;
+		$$->u1.list->next->next->next = npval2(PV_WORD, &@13, &@13);
+		$$->u1.list->next->next->next->u1.str = $13;
+		prev_word = 0;
+	}
+	| KW_IFTIME LP word BAR word3_list BAR word3_list BAR word3_list RP {
+		$$ = npval2(PV_IFTIME, &@1, &@5); /* XXX @5 or greater ? */
+		$$->u1.list = npval2(PV_WORD, &@3, &@3);
+		$$->u1.list->u1.str = $3;
+		$$->u1.list->next = npval2(PV_WORD, &@5, &@5);
+		$$->u1.list->next->u1.str = $5;
+		$$->u1.list->next->next = npval2(PV_WORD, &@7, &@7);
+		$$->u1.list->next->next->u1.str = $7;
+		$$->u1.list->next->next->next = npval2(PV_WORD, &@9, &@9);
+		$$->u1.list->next->next->next->u1.str = $9;
+		prev_word = 0;
+	}
 
 	;
 
 /* word_list is a hack to fix a problem with context switching between bison and flex;
-   by the time you register a new context with flex, you've already got a look-ahead token 
+   by the time you register a new context with flex, you've already got a look-ahead token
    from the old context, with no way to put it back and start afresh. So, we kludge this
    and merge the words back together. */
 
-word_list : word { $$ = $1;}  
-	| word word { $$ = (char*)malloc(strlen($1)+strlen($2)+1); strcpy($$, $1); strcat($$, $2);  free($1); free($2);prev_word = $$;}
+word_list : word { $$ = $1;}
+	| word word {
+		asprintf(&($$), "%s%s", $1, $2);
+		free($1);
+		free($2);
+		prev_word = $$;}
 	;
-word3_list : word { $$ = $1;}  
-	| word word { $$ = (char*)malloc(strlen($1)+strlen($2)+1); strcpy($$, $1); strcat($$, $2);  free($1); free($2);prev_word = $$;}
-	| word word word { $$ = (char*)malloc(strlen($1)+strlen($2)+strlen($3)+1); strcpy($$, $1); strcat($$, $2);  strcat($$, $3);  free($1); free($2); free($3);prev_word=$$;}
+
+word3_list : word { $$ = $1;}
+	| word word {
+		asprintf(&($$), "%s%s", $1, $2);
+		free($1);
+		free($2);
+		prev_word = $$;}
+	| word word word {
+		asprintf(&($$), "%s%s%s", $1, $2, $3);
+		free($1);
+		free($2);
+		free($3);
+		prev_word=$$;}
 	;
 
 goto_word : word { $$ = $1;}
-	| word word { $$ = (char*)malloc(strlen($1)+strlen($2)+1); strcpy($$, $1); strcat($$, $2);  free($1); free($2);}
-	| word COLON word { $$ = (char*)malloc(strlen($1)+strlen($3)+2); strcpy($$, $1); strcat($$,":"); strcat($$, $3);  free($1); free($3);}
+	| word word {
+		asprintf(&($$), "%s%s", $1, $2);
+		free($1);
+		free($2);}
+	| word COLON word {
+		asprintf(&($$), "%s:%s", $1, $3);
+		free($1);
+		free($3);}
 	;
 
-switch_head : KW_SWITCH LP { reset_parencount(parseio->scanner); } word RP  LC 
-					{$$=npval(PV_SWITCH, at 1.first_line, at 6.last_line, @1.first_column, @6.last_column);
-						$$->u1.str = $4; }
+switch_head : KW_SWITCH LP { reset_parencount(parseio->scanner); } word RP  LC {
+		$$ = npval2(PV_SWITCH, &@1, &@6);
+		$$->u1.str = $4; }
 	;
 
-statement : LC statements RC {$$=npval(PV_STATEMENTBLOCK, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.list = $2; }
-	| word EQ {reset_semicount(parseio->scanner);} word SEMI 
-			{$$=npval(PV_VARDEC, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); 
-				$$->u1.str = $1; $$->u2.val = $4; }
-	| KW_GOTO target SEMI {$$=npval(PV_GOTO, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.list = $2;}
-    | KW_JUMP jumptarget SEMI {$$=npval(PV_GOTO, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.list = $2;}
-	| word COLON {$$=npval(PV_LABEL, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); $$->u1.str = $1; }
+/*
+ * Definition of a statememt in our language
+ */
+statement : LC statements RC {
+		$$ = npval2(PV_STATEMENTBLOCK, &@1, &@3);
+		$$->u1.list = $2; }
+	| word EQ {reset_semicount(parseio->scanner);} word SEMI {
+		$$ = npval2(PV_VARDEC, &@1, &@5);
+		$$->u1.str = $1;
+		$$->u2.val = $4; }
+	| KW_GOTO target SEMI {
+		$$ = npval2(PV_GOTO, &@1, &@3);
+		$$->u1.list = $2;}
+	| KW_JUMP jumptarget SEMI {
+		$$ = npval2(PV_GOTO, &@1, &@3);
+		$$->u1.list = $2;}
+	| word COLON {
+		$$ = npval2(PV_LABEL, &@1, &@2);
+		$$->u1.str = $1; }
 	| KW_FOR LP {reset_semicount(parseio->scanner);} word SEMI
 			{reset_semicount(parseio->scanner);} word SEMI
-			{reset_parencount(parseio->scanner);} word RP statement 
-				{ $$=npval(PV_FOR, at 1.first_line, at 12.last_line, @1.first_column, @12.last_column); 
-						$$->u1.for_init = $4; $$->u2.for_test=$7; $$->u3.for_inc = $10; $$->u4.for_statements = $12;}
-	| KW_WHILE LP {reset_parencount(parseio->scanner);} word RP statement 
-			{$$=npval(PV_WHILE, at 1.first_line, at 6.last_line, @1.first_column, @6.last_column); 
-					$$->u1.str = $4; $$->u2.statements = $6; }
-	| switch_head RC /* empty list OK */ {$$=$1;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
-	| switch_head case_statements RC {$$=$1; $$->u2.statements = $2;$$->endline = @3.last_line; $$->endcol = @3.last_column;}
-	| AMPER macro_call SEMI {$$ = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
-	| application_call SEMI { $$ = $1;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
-    | word SEMI { $$= npval(PV_APPLICATION_CALL, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); 
-																						$$->u1.str = $1;}
+			{reset_parencount(parseio->scanner);} word RP statement {
+		$$ = npval2(PV_FOR, &@1, &@12);
+		$$->u1.for_init = $4;
+		$$->u2.for_test=$7;
+		$$->u3.for_inc = $10;
+		$$->u4.for_statements = $12;}
+	| KW_WHILE LP {reset_parencount(parseio->scanner);} word RP statement {
+		$$ = npval2(PV_WHILE, &@1, &@6);
+		$$->u1.str = $4;
+		$$->u2.statements = $6; }
+	| switch_head RC /* empty list OK */ {
+		$$=$1;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;}
+	| switch_head case_statements RC {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @3.last_line;
+		$$->endcol = @3.last_column;}
+	| AMPER macro_call SEMI {
+		$$ = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;}
+	| application_call SEMI {
+		$$ = $1;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;}
+	| word SEMI {
+		$$= npval2(PV_APPLICATION_CALL, &@1, &@2);
+		$$->u1.str = $1;}
 	| application_call EQ {reset_semicount(parseio->scanner);} word SEMI {
-                          char *bufx;
-						  int tot=0;
-						  pval *pptr;
-						  
-                          $$ = npval(PV_VARDEC, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column);
-						  $$->u2.val=$4;
-						  /* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
-                          /* string to big to fit in the buffer? */
-						  tot+=strlen($1->u1.str);
-						  for(pptr=$1->u2.arglist;pptr;pptr=pptr->next) {
-							  tot+=strlen(pptr->u1.str);
-							  tot++; /* for a sep like a comma */
-						  }
-						  tot+=4; /* for safety */
-						  bufx = (char *)malloc(tot);
-						  strcpy(bufx,$1->u1.str);
-						  strcat(bufx,"(");
-						  for (pptr=$1->u2.arglist;pptr;pptr=pptr->next) {
-							  if ( pptr != $1->u2.arglist )
-								  strcat(bufx,",");
-							  strcat(bufx,pptr->u1.str);
-						  }
-						  strcat(bufx,")");
+		char *bufx;
+		int tot=0;
+		pval *pptr;
+		$$ = npval2(PV_VARDEC, &@1, &@5);
+		$$->u2.val=$4;
+		/* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
+		/* string to big to fit in the buffer? */
+		tot+=strlen($1->u1.str);
+		for(pptr=$1->u2.arglist;pptr;pptr=pptr->next) {
+			tot+=strlen(pptr->u1.str);
+			tot++; /* for a sep like a comma */
+		}
+		tot+=4; /* for safety */
+		bufx = ast_calloc(1, tot);
+		strcpy(bufx,$1->u1.str);
+		strcat(bufx,"(");
+		/* XXX need to advance the pointer or the loop is very inefficient */
+		for (pptr=$1->u2.arglist;pptr;pptr=pptr->next) {
+			if ( pptr != $1->u2.arglist )
+				strcat(bufx,",");
+			strcat(bufx,pptr->u1.str);
+		}
+		strcat(bufx,")");
 #ifdef AAL_ARGCHECK
-						  if ( !ael_is_funcname($1->u1.str) )
-                              ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n", 
-									  my_file, @1.first_line, @1.first_column, @1.last_column, $1->u1.str);
+		if ( !ael_is_funcname($1->u1.str) )
+			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n",
+				my_file, @1.first_line, @1.first_column, @1.last_column, $1->u1.str);
 #endif
-						  $$->u1.str = bufx;
-						  destroy_pval($1); /* the app call it is not, get rid of that chain */
-						  prev_word = 0;
-                       }
-	| KW_BREAK SEMI { $$ = npval(PV_BREAK, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column);}
-	| KW_RETURN SEMI {$$ = npval(PV_RETURN, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column);}
-	| KW_CONTINUE SEMI {$$ = npval(PV_CONTINUE, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column);}
-	| random_head statement {$$=$1; $$->u2.statements = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
-	| random_head statement KW_ELSE statement {$$=$1; $$->u2.statements = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column; $$->u3.else_statements = $4;}
-	| if_head statement {$$=$1; $$->u2.statements = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
-	| if_head statement KW_ELSE statement {$$=$1; $$->u2.statements = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column; $$->u3.else_statements = $4;}
-	| iftime_head statement {$$=$1; $$->u2.statements = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
-	| iftime_head statement KW_ELSE statement {$$=$1; $$->u2.statements = $2;$$->endline = @2.last_line; $$->endcol = @2.last_column; $$->u3.else_statements = $4;}
+		$$->u1.str = bufx;
+		destroy_pval($1); /* the app call it is not, get rid of that chain */
+		prev_word = 0;
+	}
+	| KW_BREAK SEMI { $$ = npval2(PV_BREAK, &@1, &@2); }
+	| KW_RETURN SEMI { $$ = npval2(PV_RETURN, &@1, &@2); }
+	| KW_CONTINUE SEMI { $$ = npval2(PV_CONTINUE, &@1, &@2); }
+	| random_head statement {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;}
+	| random_head statement KW_ELSE statement {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;
+		$$->u3.else_statements = $4;}
+	| if_head statement {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;}
+	| if_head statement KW_ELSE statement {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;
+		$$->u3.else_statements = $4;}
+	| iftime_head statement {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;}
+	| iftime_head statement KW_ELSE statement {
+		$$=$1;
+		$$->u2.statements = $2;
+		$$->endline = @2.last_line;
+		$$->endcol = @2.last_column;
+		$$->u3.else_statements = $4;}
 	| SEMI { $$=0; }
 	;
 
-target : goto_word { $$ = npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); $$->u1.str = $1;}
-	| goto_word BAR goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $1; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3;}
-	| goto_word COMMA goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $1; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3;}
-	| goto_word BAR goto_word BAR goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $1; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3; 
-					$$->next->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->next->next->u1.str = $5; }
-	| goto_word COMMA goto_word COMMA goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $1; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3; 
-					$$->next->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->next->next->u1.str = $5; }
-	| KW_DEFAULT BAR goto_word BAR goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = strdup("default"); $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3; 
-					$$->next->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->next->next->u1.str = $5; }
-	| KW_DEFAULT COMMA goto_word COMMA goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = strdup("default"); $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3; 
-					$$->next->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->next->next->u1.str = $5; }
+target : goto_word { $$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;}
+	| goto_word BAR goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;}
+	| goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;}
+	| goto_word BAR goto_word BAR goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;
+		$$->next->next = npval2(PV_WORD, &@5, &@5);
+		$$->next->next->u1.str = $5; }
+	| goto_word COMMA goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;
+		$$->next->next = npval2(PV_WORD, &@5, &@5);
+		$$->next->next->u1.str = $5; }
+	| KW_DEFAULT BAR goto_word BAR goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = strdup("default");
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;
+		$$->next->next = npval2(PV_WORD, &@5, &@5);
+		$$->next->next->u1.str = $5; }
+	| KW_DEFAULT COMMA goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = strdup("default");
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;
+		$$->next->next = npval2(PV_WORD, &@5, &@5);
+		$$->next->next->u1.str = $5; }
 	;
 
-jumptarget : goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $1; $$->next = npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->next->u1.str = strdup("1");}  /*  jump extension[,priority][@context] */
-		| goto_word COMMA goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $1; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $3;} 
-		| goto_word COMMA word AT word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $5; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $1; 
-					$$->next->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->next->next->u1.str = $3; } 
-		| goto_word AT goto_word {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = $3; $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $1; 
-					$$->next->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->next->u1.str = strdup("1"); } 
-		| goto_word COMMA word AT KW_DEFAULT {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = strdup("default"); $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $1; 
-					$$->next->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->next->next->u1.str = $3; } 
-		| goto_word AT KW_DEFAULT {$$=npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); 
-					$$->u1.str = strdup("default"); $$->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->u1.str = $1; 
-					$$->next->next = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->next->next->u1.str = strdup("1"); } 
-		;
+jumptarget : goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;
+		$$->next = npval2(PV_WORD, &@1, &@1); /* XXX not really @1 */
+		$$->next->u1.str = strdup("1");}  /*  jump extension[,priority][@context] */
+	| goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $3;}
+	| goto_word COMMA word AT word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $5;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $1;
+		$$->next->next = npval2(PV_WORD, &@5, &@5);
+		$$->next->next->u1.str = $3; }
+	| goto_word AT goto_word {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $3;
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $1;
+		$$->next->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->next->u1.str = strdup("1"); }
+	| goto_word COMMA word AT KW_DEFAULT {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = strdup("default");
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $1;
+		$$->next->next = npval2(PV_WORD, &@5, &@5);
+		$$->next->next->u1.str = $3; }
+	| goto_word AT KW_DEFAULT {
+		$$ = npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = strdup("default");
+		$$->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->u1.str = $1;
+		$$->next->next = npval2(PV_WORD, &@3, &@3);
+		$$->next->next->u1.str = strdup("1"); }
+	;
 
-macro_call : word LP {reset_argcount(parseio->scanner);} eval_arglist RP 
-			{$$= npval(PV_MACRO_CALL, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); 
-			$$->u1.str = $1; $$->u2.arglist = $4;}
-	| word LP RP {$$= npval(PV_MACRO_CALL, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = $1; }
+macro_call : word LP {reset_argcount(parseio->scanner);} eval_arglist RP {
+		/* XXX original code had @2 but i think we need @5 */
+		$$ = npval2(PV_MACRO_CALL, &@1, &@5);
+		$$->u1.str = $1;
+		$$->u2.arglist = $4;}
+	| word LP RP {
+		$$= npval2(PV_MACRO_CALL, &@1, &@3);
+		$$->u1.str = $1; }
 	;
 
-application_call_head: word {reset_argcount(parseio->scanner);} LP  {if (strcasecmp($1,"goto") == 0) {
-																							$$= npval(PV_GOTO, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column);
-																							free($1); /* won't be using this */
-																							ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n", my_file, @1.first_line, @1.first_column, @1.last_column );
-																						} else
-																							$$= npval(PV_APPLICATION_CALL, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); 
-																						$$->u1.str = $1; }
+application_call_head: word {reset_argcount(parseio->scanner);} LP  {
+		if (strcasecmp($1,"goto") == 0) {
+			$$= npval2(PV_GOTO, &@1, &@3);
+			free($1); /* won't be using this */
+			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n", my_file, @1.first_line, @1.first_column, @1.last_column );
+		} else
+			$$= npval2(PV_APPLICATION_CALL, &@1, &@3);
+		$$->u1.str = $1; }
 	;
 
 application_call : application_call_head eval_arglist RP {$$ = $1;
@@ -417,133 +630,179 @@
 	| application_call_head RP {$$=$1;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
 	;
 
-eval_arglist :  word_list { $$= npval(PV_WORD, at 1.first_line, at 1.last_line, @1.first_column, @1.last_column); $$->u1.str = $1;}
-	| /*nothing! */   { $$= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/); $$->u1.str = strdup(""); }
-	| eval_arglist COMMA  word { pval *z = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); $$ = $1; linku1($1,z); z->u1.str = $3;}
-	| eval_arglist COMMA { pval *z = npval(PV_WORD, at 2.first_line, at 2.last_line, @2.first_column, @2.last_column); $$ = $1; linku1($1,z); z->u1.str = strdup("");}
+eval_arglist :  word_list { 
+		$$= npval2(PV_WORD, &@1, &@1);
+		$$->u1.str = $1;}
+	| /*nothing! */   {
+		$$= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
+		$$->u1.str = strdup(""); }
+	| eval_arglist COMMA  word {
+		pval *z = npval2(PV_WORD, &@3, &@3);
+		$$ = $1;
+		linku1($1,z);
+		z->u1.str = $3;}
+	| eval_arglist COMMA {
+		pval *z = npval2(PV_WORD, &@2, &@2);
+		$$ = $1;
+		linku1($1,z);
+		z->u1.str = strdup("");}
 	;
 
 case_statements: case_statement {$$=$1;}
-	| case_statements case_statement { if ( $1 && $2 ) {$$=$1; linku1($$,$2);} 
+	| case_statements case_statement { if ( $1 && $2 ) {$$=$1; linku1($$,$2);}
 						 else if ( $1 ) {$$=$1;}
 						 else if ( $2 ) {$$=$2;} }
 	;
 
-case_statement: KW_CASE word COLON statements {$$ = npval(PV_CASE, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = $2; $$->u2.statements = $4;}
-	| KW_DEFAULT COLON statements {$$ = npval(PV_DEFAULT, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = 0; $$->u2.statements = $3;}
-	| KW_PATTERN word COLON statements {$$ = npval(PV_PATTERN, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = $2; $$->u2.statements = $4;}
-    | KW_CASE word COLON {$$ = npval(PV_CASE, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = $2;}
-	| KW_DEFAULT COLON {$$ = npval(PV_DEFAULT, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); $$->u1.str = 0;}
-	| KW_PATTERN word COLON  {$$ = npval(PV_PATTERN, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); $$->u1.str = $2;}
+case_statement: KW_CASE word COLON statements {
+		$$ = npval2(PV_CASE, &@1, &@3); /* XXX 3 or 4 ? */
+		$$->u1.str = $2;
+		$$->u2.statements = $4;}
+	| KW_DEFAULT COLON statements {
+		$$ = npval2(PV_DEFAULT, &@1, &@3);
+		$$->u1.str = NULL;
+		$$->u2.statements = $3;}
+	| KW_PATTERN word COLON statements {
+		$$ = npval2(PV_PATTERN, &@1, &@4); /* XXX at 3 or @4 ? */
+		$$->u1.str = $2;
+		$$->u2.statements = $4;}
+	| KW_CASE word COLON {
+		$$ = npval2(PV_CASE, &@1, &@3);
+		$$->u1.str = $2;}
+	| KW_DEFAULT COLON {
+		$$ = npval2(PV_DEFAULT, &@1, &@2);
+		$$->u1.str = NULL;}
+	| KW_PATTERN word COLON  {
+		$$ = npval2(PV_PATTERN, &@1, &@3);
+		$$->u1.str = $2;}
 	;
 
 macro_statements: macro_statement {$$ = $1;}
-	| macro_statements macro_statement { if ( $1 && $2 ) {$$=$1; linku1($$,$2);} 
+	| macro_statements macro_statement { if ( $1 && $2 ) {$$=$1; linku1($$,$2);}
 						 else if ( $1 ) {$$=$1;}
 						 else if ( $2 ) {$$=$2;} }
 	;
 
 macro_statement : statement {$$=$1;}
-	| KW_CATCH word LC statements RC {$$=npval(PV_CATCH, at 1.first_line, at 5.last_line, @1.first_column, @5.last_column); $$->u1.str = $2; $$->u2.statements = $4;}
+	| KW_CATCH word LC statements RC {
+		$$ = npval2(PV_CATCH, &@1, &@5);
+		$$->u1.str = $2;
+		$$->u2.statements = $4;}
 	;
 
-switches : KW_SWITCHES LC switchlist RC {$$= npval(PV_SWITCHES, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.list = $3; }
-	| KW_SWITCHES LC RC /* empty switch list OK */ {$$= npval(PV_SWITCHES, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column);}
+switches : KW_SWITCHES LC switchlist RC {
+		$$ = npval2(PV_SWITCHES, &@1, &@4);
+		$$->u1.list = $3; }
+	| KW_SWITCHES LC RC /* empty switch list OK */ {
+		$$ = npval2(PV_SWITCHES, &@1, &@3); }
 	;
 
-eswitches : KW_ESWITCHES LC switchlist RC {$$= npval(PV_ESWITCHES, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.list = $3; }
-	| KW_ESWITCHES LC  RC /* empty switch list OK */ {$$= npval(PV_ESWITCHES, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column); } /* if there's nothing to declare, why include it? */
+eswitches : KW_ESWITCHES LC switchlist RC {
+		$$ = npval2(PV_ESWITCHES, &@1, &@4);
+		$$->u1.list = $3; }
+	| KW_ESWITCHES LC  RC { /* empty switch list OK */
+		$$ = npval2(PV_ESWITCHES, &@1, &@3); } /* if there's nothing to declare, why include it? */
 	;
 
-switchlist : word SEMI {$$=npval(PV_WORD, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); $$->u1.str = $1;}
-	| switchlist word SEMI {pval *z = npval(PV_WORD, at 2.first_line, at 3.last_line, @2.first_column, @3.last_column); $$=$1; z->u1.str = $2; linku1($$,z); }
+switchlist : word SEMI {
+		$$ = npval2(PV_WORD, &@1, &@2);
+		$$->u1.str = $1;}
+	| switchlist word SEMI {
+		pval *z = npval2(PV_WORD, &@2, &@3);
+		z->u1.str = $2;
+		$$=$1;
+		linku1($$,z); }
 	| switchlist error {$$=$1;}
 	;
 
-includeslist : includedname SEMI {$$=npval(PV_WORD, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); $$->u1.str = $1;}
-	| includedname BAR word3_list COLON word3_list COLON word3_list BAR word3_list BAR word3_list BAR word3_list SEMI {
-                    $$=npval(PV_WORD, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); 
-                    $$->u1.str = $1;
-					$$->u2.arglist = npval(PV_WORD, at 3.first_line, at 7.last_line, @3.first_column, @7.last_column); 
-					$$->u2.arglist->u1.str = (char*)malloc(strlen($3)+strlen($5)+strlen($7)+4);
-					strcpy($$->u2.arglist->u1.str,$3);
-					strcat($$->u2.arglist->u1.str,":");
-					strcat($$->u2.arglist->u1.str,$5);
-					strcat($$->u2.arglist->u1.str,":");
-					strcat($$->u2.arglist->u1.str,$7);
-					free($3);
-					free($5);
-					free($7);
-					$$->u2.arglist->next = npval(PV_WORD, at 9.first_line, at 9.last_line, @9.first_column, @9.last_column); 
-					$$->u2.arglist->next->u1.str = $9; 
-					$$->u2.arglist->next->next = npval(PV_WORD, at 11.first_line, at 11.last_line, @11.first_column, @11.last_column); 
-					$$->u2.arglist->next->next->u1.str = $11; 
-					$$->u2.arglist->next->next->next = npval(PV_WORD, at 13.first_line, at 13.last_line, @13.first_column, @13.last_column); 
-					$$->u2.arglist->next->next->next->u1.str = $13; 
-					prev_word=0;
-			}
+includeslist : includedname SEMI {
+		$$ = npval2(PV_WORD, &@1, &@2);
+		$$->u1.str = $1;}
+	| includedname BAR word3_list COLON word3_list COLON word3_list
+			BAR word3_list BAR word3_list BAR word3_list SEMI {
+		$$ = npval2(PV_WORD, &@1, &@2);
+		$$->u1.str = $1;
+		$$->u2.arglist = npval2(PV_WORD, &@3, &@7);
+		asprintf( &($$->u2.arglist->u1.str), "%s:%s:%s", $3, $5, $7);
+		free($3);
+		free($5);
+		free($7);
+		$$->u2.arglist->next = npval2(PV_WORD, &@9, &@9);
+		$$->u2.arglist->next->u1.str = $9;
+		$$->u2.arglist->next->next = npval2(PV_WORD, &@11, &@11);
+		$$->u2.arglist->next->next->u1.str = $11;
+		$$->u2.arglist->next->next->next = npval2(PV_WORD, &@13, &@13);
+		$$->u2.arglist->next->next->next->u1.str = $13;
+		prev_word=0;
+	}
 	| includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
-                    $$=npval(PV_WORD, at 1.first_line, at 2.last_line, @1.first_column, @2.last_column); 
-                    $$->u1.str = $1;
-					$$->u2.arglist = npval(PV_WORD, at 3.first_line, at 3.last_line, @3.first_column, @3.last_column); 
-					$$->u2.arglist->u1.str = $3;
-					$$->u2.arglist->next = npval(PV_WORD, at 5.first_line, at 5.last_line, @5.first_column, @5.last_column); 
-					$$->u2.arglist->next->u1.str = $5; 
-					$$->u2.arglist->next->next = npval(PV_WORD, at 7.first_line, at 7.last_line, @7.first_column, @7.last_column); 
-					$$->u2.arglist->next->next->u1.str = $7; 
-					$$->u2.arglist->next->next->next = npval(PV_WORD, at 9.first_line, at 9.last_line, @9.first_column, @9.last_column); 
-					$$->u2.arglist->next->next->next->u1.str = $9; 
-					prev_word=0;
-			}
-	| includeslist includedname SEMI {pval *z = npval(PV_WORD, at 2.first_line, at 3.last_line, @2.first_column, @3.last_column); $$=$1; z->u1.str = $2; linku1($$,z); }
-	| includeslist includedname BAR word3_list COLON word3_list COLON word3_list BAR word3_list BAR word3_list BAR word3_list SEMI {pval *z = npval(PV_WORD, at 2.first_line, at 3.last_line, @2.first_column, @3.last_column); 
-					$$=$1; z->u1.str = $2; linku1($$,z);
-					z->u2.arglist = npval(PV_WORD, at 4.first_line, at 4.last_line, @4.first_column, @4.last_column); 
-					$$->u2.arglist->u1.str = (char*)malloc(strlen($4)+strlen($6)+strlen($8)+4);
-					strcpy($$->u2.arglist->u1.str,$4);
-					strcat($$->u2.arglist->u1.str,":");
-					strcat($$->u2.arglist->u1.str,$6);
-					strcat($$->u2.arglist->u1.str,":");
-					strcat($$->u2.arglist->u1.str,$8);
-					free($4);
-					free($6);
-					free($8);
-					z->u2.arglist->next = npval(PV_WORD, at 10.first_line, at 10.last_line, @10.first_column, @10.last_column); 
-					z->u2.arglist->next->u1.str = $10; 
-					z->u2.arglist->next->next = npval(PV_WORD, at 12.first_line, at 12.last_line, @12.first_column, @12.last_column); 
-					z->u2.arglist->next->next->u1.str = $12; 
-					z->u2.arglist->next->next->next = npval(PV_WORD, at 14.first_line, at 14.last_line, @14.first_column, @14.last_column); 
-					z->u2.arglist->next->next->next->u1.str = $14; 
-					prev_word=0;
-			}
-	| includeslist includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI
-                   {pval *z = npval(PV_WORD, at 2.first_line, at 2.last_line, @2.first_column, @3.last_column);
-					$$=$1; z->u1.str = $2; linku1($$,z);
-					z->u2.arglist = npval(PV_WORD, at 4.first_line, at 4.last_line, @4.first_column, @4.last_column);
-					$$->u2.arglist->u1.str = $4;
-					z->u2.arglist->next = npval(PV_WORD, at 6.first_line, at 6.last_line, @6.first_column, @6.last_column);
-					z->u2.arglist->next->u1.str = $6;
-					z->u2.arglist->next->next = npval(PV_WORD, at 8.first_line, at 8.last_line, @8.first_column, @8.last_column);
-					z->u2.arglist->next->next->u1.str = $8;
-					z->u2.arglist->next->next->next = npval(PV_WORD, at 10.first_line, at 10.last_line, @10.first_column, @10.last_column);
-					z->u2.arglist->next->next->next->u1.str = $10;
-					prev_word=0;
-			}
+		$$ = npval2(PV_WORD, &@1, &@2);
+		$$->u1.str = $1;
+		$$->u2.arglist = npval2(PV_WORD, &@3, &@3);
+		$$->u2.arglist->u1.str = $3;
+		$$->u2.arglist->next = npval2(PV_WORD, &@5, &@5);
+		$$->u2.arglist->next->u1.str = $5;
+		$$->u2.arglist->next->next = npval2(PV_WORD, &@7, &@7);
+		$$->u2.arglist->next->next->u1.str = $7;
+		$$->u2.arglist->next->next->next = npval2(PV_WORD, &@9, &@9);
+		$$->u2.arglist->next->next->next->u1.str = $9;
+		prev_word=0;
+	}
+	| includeslist includedname SEMI {
+		pval *z = npval2(PV_WORD, &@2, &@3); /* XXX don't we need @1- at 4 ?*/
+		$$=$1;
+		z->u1.str = $2;
+		linku1($$,z); }
+	| includeslist includedname BAR word3_list COLON word3_list COLON word3_list
+			BAR word3_list BAR word3_list BAR word3_list SEMI {
+		pval *z = npval2(PV_WORD, &@2, &@3);
+		$$=$1; z->u1.str = $2;
+		linku1($$,z);
+		z->u2.arglist = npval2(PV_WORD, &@4, &@4);
+		asprintf( &($$->u2.arglist->u1.str), "%s:%s:%s", $4, $6, $8);
+		free($4);
+		free($6);
+		free($8);
+		z->u2.arglist->next = npval2(PV_WORD, &@10, &@10);
+		z->u2.arglist->next->u1.str = $10;
+		z->u2.arglist->next->next = npval2(PV_WORD, &@12, &@12);
+		z->u2.arglist->next->next->u1.str = $12;
+		z->u2.arglist->next->next->next = npval2(PV_WORD, &@14, &@14);
+		z->u2.arglist->next->next->next->u1.str = $14;
+		prev_word=0;
+	}
+	| includeslist includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
+		pval *z = npval2(PV_WORD, &@2, &@3);
+		$$=$1;
+		z->u1.str = $2; linku1($$,z);
+		z->u2.arglist = npval2(PV_WORD, &@4, &@4);
+		$$->u2.arglist->u1.str = $4;
+		z->u2.arglist->next = npval2(PV_WORD, &@6, &@6);
+		z->u2.arglist->next->u1.str = $6;
+		z->u2.arglist->next->next = npval2(PV_WORD, &@8, &@8);
+		z->u2.arglist->next->next->u1.str = $8;
+		z->u2.arglist->next->next->next = npval2(PV_WORD, &@10, &@10);
+		z->u2.arglist->next->next->next->u1.str = $10;
+		prev_word=0;
+	}
 	| includeslist error {$$=$1;}
 	;
 
 includedname : word { $$ = $1;}
-			| KW_DEFAULT {$$=strdup("default");}
-			;
+	| KW_DEFAULT {$$=strdup("default");}
+	;
 
-includes : KW_INCLUDES LC includeslist RC {$$= npval(PV_INCLUDES, at 1.first_line, at 4.last_line, @1.first_column, @4.last_column); $$->u1.list = $3;}
-	| KW_INCLUDES LC RC  {$$= npval(PV_INCLUDES, at 1.first_line, at 3.last_line, @1.first_column, @3.last_column);}
+includes : KW_INCLUDES LC includeslist RC {
+		$$ = npval2(PV_INCLUDES, &@1, &@4);
+		$$->u1.list = $3;}
+	| KW_INCLUDES LC RC {
+		$$ = npval2(PV_INCLUDES, &@1, &@3);}
 	;
 
 
 %%
 
-static char *token_equivs1[] = 
+static char *token_equivs1[] =
 {
 	"AMPER",
 	"AT",
@@ -552,15 +811,15 @@
 	"COMMA",
 	"EQ",
 	"EXTENMARK",
-	"KW_BREAK", 
-	"KW_CASE", 
-	"KW_CATCH", 
+	"KW_BREAK",
+	"KW_CASE",
+	"KW_CATCH",
 	"KW_CONTEXT",
-	"KW_CONTINUE", 
-	"KW_DEFAULT", 
+	"KW_CONTINUE",
+	"KW_DEFAULT",
 	"KW_ELSE",
 	"KW_ESWITCHES",
-	"KW_FOR", 
+	"KW_FOR",
 	"KW_GLOBALS",
 	"KW_GOTO",
 	"KW_HINT",
@@ -570,12 +829,12 @@
 	"KW_INCLUDES"
 	"KW_JUMP",
 	"KW_MACRO",
-	"KW_PATTERN", 
-	"KW_REGEXTEN", 
-	"KW_RETURN", 
-	"KW_SWITCHES", 
+	"KW_PATTERN",
+	"KW_REGEXTEN",
+	"KW_RETURN",
+	"KW_SWITCHES",
 	"KW_SWITCH",
-	"KW_WHILE", 
+	"KW_WHILE",
 	"LC",
 	"LP",
 	"RC",
@@ -583,7 +842,7 @@
 	"SEMI",
 };
 
-static char *token_equivs2[] = 
+static char *token_equivs2[] =
 {
 	"&",
 	"@",
@@ -592,15 +851,15 @@
 	",",
 	"=",
 	"=>",
-	"break", 
-	"case", 
-	"catch", 
+	"break",
+	"case",
+	"catch",
 	"context",
-	"continue", 
-	"default", 
+	"continue",
+	"default",
 	"else",
 	"eswitches",
-	"for", 
+	"for",
 	"globals",
 	"goto",
 	"hint",
@@ -610,12 +869,12 @@
 	"includes"
 	"jump",
 	"macro",
-	"pattern", 
-	"regexten", 
-	"return", 
-	"switches", 
+	"pattern",
+	"regexten",
+	"return",
+	"switches",
 	"switch",
-	"while", 
+	"while",
 	"{",
 	"(",
 	"}",
@@ -643,7 +902,7 @@
 		}
 		len++;
 	}
-	res = (char*)malloc(len+1);
+	res = ast_calloc(1, len+1);
 	res[0] = 0;
 	s = res;
 	for (p=mess; *p;) {
@@ -679,10 +938,11 @@
 	parseio->syntax_error_count++;
 }
 
-struct pval *npval(pvaltype type,int first_line, int last_line, int first_column, int last_column)
+static struct pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column)
 {
 	extern char *my_file;
-	pval *z = (pval *)calloc(sizeof(struct pval),1);
+	pval *z = ast_calloc(1, sizeof(struct pval));
 	z->type = type;
 	z->startline = first_line;
 	z->endline = last_line;
@@ -692,14 +952,23 @@
 	return z;
 }
 
-void linku1(pval *head, pval *tail)
+static struct pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last)
 {
+	return npval(type, first->first_line, last->last_line,
+			first->first_column, last->last_column);
+}
+
+/* append second element to the list in the first one */
+static pval * linku1(pval *head, pval *tail)
+{
+	if (!head)
+		return tail;
 	if (!head->next) {
 		head->next = tail;
-		head->u1_last = tail;
 	} else {
 		head->u1_last->next = tail;
-		head->u1_last = tail;
 	}
+	head->u1_last = tail;
+	return head;
 }
 

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael_lex.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -356,8 +356,8 @@
 	*yy_cp = '\0'; \
 	yyg->yy_c_buf_p = yy_cp;
 
-#define YY_NUM_RULES 65
-#define YY_END_OF_BUFFER 66
+#define YY_NUM_RULES 55
+#define YY_END_OF_BUFFER 56
 /* This struct is not used in this scanner,
    but its presence is necessary. */
 struct yy_trans_info
@@ -365,21 +365,19 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[226] =
+static yyconst flex_int16_t yy_accept[206] =
     {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,   66,   65,
+        0,    0,    0,    0,    0,    0,    0,    0,   56,   55,
        42,   40,   41,   43,   43,    9,    3,    4,    7,   43,
         8,    5,    6,   12,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,    1,
-       10,    2,   65,   45,   44,   46,   47,   48,   49,   65,
-       61,   62,   63,   57,   58,   59,   60,   65,   51,   50,
-       52,   55,   56,   53,   54,   42,   41,   43,   43,   13,
+       10,    2,   55,   45,   44,   46,   55,   51,   52,   53,
+       55,   47,   48,   49,   50,   42,   41,   43,   43,   13,
        11,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   20,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,    0,   45,   44,   46,   47,   48,   49,    0,
+       43,   43,    0,   45,   44,   46,    0,   51,   52,   53,
+        0,   47,   48,   49,   50,   43,   13,   13,   43,   43,
 
-       61,   62,   63,   57,   58,   59,   60,    0,   51,   50,
-       52,   55,   56,   53,   54,   43,   13,   13,   43,   43,
        43,   43,   43,   43,   43,   43,   31,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   33,   43,   43,   43,   25,   43,
@@ -388,10 +386,10 @@
        43,   43,   43,   43,   43,   43,   16,   43,   43,   43,
        43,   43,   32,   43,   43,   43,   43,   43,   43,   43,
        21,   43,   43,   43,   22,   43,   28,   19,   43,   43,
-
        14,   43,   34,   43,   17,   43,   43,   35,   43,   43,
        43,   15,   30,   43,   43,   39,   23,   37,    0,   38,
-       18,    0,    0,   64,    0
+
+       18,    0,    0,   54,    0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
@@ -435,21 +433,19 @@
         3,    3,    3,    1,    3
     } ;
 
-static yyconst flex_int16_t yy_base[236] =
+static yyconst flex_int16_t yy_base[216] =
     {   0,
         0,    0,   37,   40,   77,  114,  151,  188,  237,  507,
       234,  507,  228,    0,  201,  507,  507,  507,  507,  217,
       507,  507,  212,  507,  205,  189,   27,  200,   20,  189,
        19,  194,   37,  182,  200,  199,   40,  178,  190,  507,
-      507,  507,   57,  507,  507,  507,  507,  507,  507,  225,
-      507,  507,  507,  507,  507,  507,  507,  262,  507,  507,
-      507,  507,  507,  507,  507,  215,  212,    0,  181,  307,
+      507,  507,   57,  507,  507,  507,  225,  507,  507,  507,
+      262,  507,  507,  507,  507,  215,  212,    0,  181,  307,
       507,  176,  188,   30,  178,  185,  172,  168,  169,  170,
       165,  169,  184,  167,  177,  162,  170,  153,  157,   45,
-      161,  160,   69,  507,  507,  507,  507,  507,  507,  343,
+      161,  160,   69,  507,  507,  507,  343,  507,  507,  507,
+      380,  507,  507,  507,  507,  165,    0,  425,  148,  165,
 
-      507,  507,  507,  507,  507,  507,  507,  380,  507,  507,
-      507,  507,  507,  507,  507,  165,    0,  425,  148,  165,
       160,  161,  144,  161,  156,  151,    0,  157,  143,  138,
       147,  140,  142,  137,  135,  130,  144,  142,  126,  126,
       132,  131,  121,  125,    0,  127,   45,  114,    0,  114,
@@ -458,41 +454,39 @@
       105,  113,  103,  107,  106,  106,    0,   92,   94,   87,
        91,   93,    0,   95,   95,   78,   76,   76,   85,   73,
         0,   74,   84,   74,    0,   82,    0,   81,   80,   65,
-
         0,   78,    0,   76,    0,   78,   60,    0,   61,   55,
        51,    0,    0,   43,   36,    0,    0,    0,   88,    0,
+
         0,    0,   67,  507,  507,  469,  473,  477,  479,  483,
       487,  491,  495,  499,  503
     } ;
 
-static yyconst flex_int16_t yy_def[236] =
+static yyconst flex_int16_t yy_def[216] =
     {   0,
-      225,    1,  226,  226,  227,  227,  228,  228,  225,  225,
-      225,  225,  225,  229,  229,  225,  225,  225,  225,  229,
-      225,  225,  225,  225,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  225,
-      225,  225,  230,  225,  225,  225,  225,  225,  225,  231,
-      225,  225,  225,  225,  225,  225,  225,  232,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  229,  229,  233,
-      225,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  230,  225,  225,  225,  225,  225,  225,  231,
+      205,    1,  206,  206,  207,  207,  208,  208,  205,  205,
+      205,  205,  205,  209,  209,  205,  205,  205,  205,  209,
+      205,  205,  205,  205,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  205,
+      205,  205,  210,  205,  205,  205,  211,  205,  205,  205,
+      212,  205,  205,  205,  205,  205,  205,  209,  209,  213,
+      205,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  210,  205,  205,  205,  211,  205,  205,  205,
+      212,  205,  205,  205,  205,  209,  214,  213,  209,  209,
 
-      225,  225,  225,  225,  225,  225,  225,  232,  225,  225,
-      225,  225,  225,  225,  225,  229,  234,  233,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  205,  209,
 
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  225,  229,
-      229,  235,  235,  225,    0,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225
+      209,  215,  215,  205,    0,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205
     } ;
 
 static yyconst flex_int16_t yy_nxt[553] =
@@ -501,63 +495,63 @@
        19,   20,   21,   22,   23,   14,   24,   14,   14,   14,
        25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
        14,   14,   35,   14,   14,   36,   37,   38,   14,   14,
-       39,   14,   40,   41,   42,   44,   45,   74,   44,   45,
-       80,   77,  219,   81,  219,   46,   47,   78,   46,   47,
-       89,   75,   83,   84,   90,   94,   95,  121,  122,  169,
-       85,  138,  224,  170,  221,   96,   97,   94,   95,   48,
-      220,   49,   48,  139,   49,   51,   52,   96,   97,  219,
-       53,  219,  218,  222,  217,   54,   55,  216,  215,   98,
+       39,   14,   40,   41,   42,   44,   45,   64,   44,   45,
+       70,   67,  199,   71,  199,   44,   46,   68,   44,   46,
+       79,   65,   73,   74,   80,   84,   85,  101,  102,  149,
+       75,  118,  204,  150,  201,   84,   86,   84,   85,   44,
+      200,   46,   44,  119,   46,   48,   49,   84,   86,  199,
+       50,  199,  198,  202,  197,   48,   49,  196,  195,   84,
 
-      214,   99,  213,  212,  211,  210,  209,  208,  207,  206,
-      205,   98,  204,   99,  203,  202,  201,  200,  199,   56,
-      198,   57,   51,   52,  197,  196,  195,   53,  194,  193,
-      192,  191,   54,   55,  190,  189,  188,  187,  186,  185,
-      184,  183,  182,  181,  180,  179,  178,  177,  176,  175,
-      174,  173,  172,  171,  168,  167,   56,  166,   57,   59,
-       60,   61,  165,  164,  163,  162,  161,  160,  159,   62,
-       63,  158,  157,  156,  155,  154,  153,  152,  151,  150,
-      149,  148,  147,  146,  145,  144,  143,  142,  141,  140,
-      137,  136,  135,   64,  134,   65,   59,   60,   61,  133,
+      194,   86,  193,  192,  191,  190,  189,  188,  187,  186,
+      185,   84,  184,   86,  183,  182,  181,  180,  179,   48,
+      178,   49,   48,   49,  177,  176,  175,   50,  174,  173,
+      172,  171,   48,   49,  170,  169,  168,  167,  166,  165,
+      164,  163,  162,  161,  160,  159,  158,  157,  156,  155,
+      154,  153,  152,  151,  148,  147,   48,  146,   49,   52,
+       53,   54,  145,  144,  143,  142,  141,  140,  139,   52,
+       55,  138,  137,  136,  135,  134,  133,  132,  131,  130,
+      129,  128,  127,  126,  125,  124,  123,  122,  121,  120,
+      117,  116,  115,   52,  114,   55,   52,   53,   54,  113,
 
-      132,  131,  130,  129,  128,  127,   62,   63,  126,  125,
-      124,  123,  120,  119,  116,   67,   66,   92,   91,   88,
-       87,   86,   82,   79,   76,   73,   72,   71,   70,   69,
-       64,   67,   65,  101,  102,   66,  225,  225,  103,  225,
-      225,  225,  225,  104,  105,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  106,  225,  107,
-      109,  110,  111,  225,  225,  225,  225,  225,  225,  225,
-      112,  113,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      112,  111,  110,  109,  108,  107,   52,   55,  106,  105,
+      104,  103,  100,   99,   96,   57,   56,   82,   81,   78,
+       77,   76,   72,   69,   66,   63,   62,   61,   60,   59,
+       52,   57,   55,   88,   89,   56,  205,  205,   90,  205,
+      205,  205,  205,   88,   89,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,   88,  205,   89,
+       92,   93,   94,  205,  205,  205,  205,  205,  205,  205,
+       92,   95,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
 
-      225,  225,  225,  225,  114,  225,  115,  117,  117,  225,
-      117,  225,  225,  225,  117,  117,  117,  117,  225,  117,
-      117,  117,  225,  117,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      117,  101,  102,  225,  225,  225,  103,  225,  225,  225,
-      225,  104,  105,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  106,  225,  107,  109,  110,
-      111,  225,  225,  225,  225,  225,  225,  225,  112,  113,
+      205,  205,  205,  205,   92,  205,   95,   97,   97,  205,
+       97,  205,  205,  205,   97,   97,   97,   97,  205,   97,
+       97,   97,  205,   97,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+       97,   88,   89,  205,  205,  205,   90,  205,  205,  205,
+      205,   88,   89,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,   88,  205,   89,   92,   93,
+       94,  205,  205,  205,  205,  205,  205,  205,   92,   95,
 
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  114,  225,  115,  117,  117,  225,  117,  225,
-      225,  225,  117,  117,  117,  117,  225,  117,  117,  117,
-      225,  117,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  117,   43,
-       43,   43,   43,   50,   50,   50,   50,   58,   58,   58,
-       58,   68,   68,   93,   93,   93,   93,  100,  100,  100,
-      100,  108,  108,  108,  108,  118,  225,  118,  118,  117,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,   92,  205,   95,   97,   97,  205,   97,  205,
+      205,  205,   97,   97,   97,   97,  205,   97,   97,   97,
+      205,   97,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,   97,   43,
+       43,   43,   43,   47,   47,   47,   47,   51,   51,   51,
+       51,   58,   58,   83,   83,   83,   83,   87,   87,   87,
+       87,   91,   91,   91,   91,   98,  205,   98,   98,   97,
 
-      225,  117,  117,  223,  223,  223,    9,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225
+      205,   97,   97,  203,  203,  203,    9,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205
     } ;
 
 static yyconst flex_int16_t yy_chk[553] =
@@ -567,62 +561,62 @@
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    3,    3,   27,    4,    4,
-       31,   29,  211,   31,  211,    3,    3,   29,    4,    4,
-       37,   27,   33,   33,   37,   43,   43,   74,   74,  147,
-       33,   90,  223,  147,  215,   43,   43,   93,   93,    3,
-      214,    3,    4,   90,    4,    5,    5,   93,   93,  219,
-        5,  219,  210,  219,  209,    5,    5,  207,  206,   43,
+       31,   29,  191,   31,  191,    3,    3,   29,    4,    4,
+       37,   27,   33,   33,   37,   43,   43,   64,   64,  127,
+       33,   80,  203,  127,  195,   43,   43,   83,   83,    3,
+      194,    3,    4,   80,    4,    5,    5,   83,   83,  199,
+        5,  199,  190,  199,  189,    5,    5,  187,  186,   43,
 
-      204,   43,  202,  200,  199,  198,  196,  194,  193,  192,
-      190,   93,  189,   93,  188,  187,  186,  185,  184,    5,
-      182,    5,    6,    6,  181,  180,  179,    6,  178,  176,
-      175,  174,    6,    6,  173,  172,  171,  170,  169,  166,
-      165,  164,  163,  162,  161,  160,  159,  158,  156,  155,
-      154,  151,  150,  148,  146,  144,    6,  143,    6,    7,
-        7,    7,  142,  141,  140,  139,  138,  137,  136,    7,
-        7,  135,  134,  133,  132,  131,  130,  129,  128,  126,
-      125,  124,  123,  122,  121,  120,  119,  116,   92,   91,
-       89,   88,   87,    7,   86,    7,    8,    8,    8,   85,
+      184,   43,  182,  180,  179,  178,  176,  174,  173,  172,
+      170,   83,  169,   83,  168,  167,  166,  165,  164,    5,
+      162,    5,    6,    6,  161,  160,  159,    6,  158,  156,
+      155,  154,    6,    6,  153,  152,  151,  150,  149,  146,
+      145,  144,  143,  142,  141,  140,  139,  138,  136,  135,
+      134,  131,  130,  128,  126,  124,    6,  123,    6,    7,
+        7,    7,  122,  121,  120,  119,  118,  117,  116,    7,
+        7,  115,  114,  113,  112,  111,  110,  109,  108,  106,
+      105,  104,  103,  102,  101,  100,   99,   96,   82,   81,
+       79,   78,   77,    7,   76,    7,    8,    8,    8,   75,
 
-       84,   83,   82,   81,   80,   79,    8,    8,   78,   77,
-       76,   75,   73,   72,   69,   67,   66,   39,   38,   36,
+       74,   73,   72,   71,   70,   69,    8,    8,   68,   67,
+       66,   65,   63,   62,   59,   57,   56,   39,   38,   36,
        35,   34,   32,   30,   28,   26,   25,   23,   20,   15,
-        8,   13,    8,   50,   50,   11,    9,    0,   50,    0,
-        0,    0,    0,   50,   50,    0,    0,    0,    0,    0,
+        8,   13,    8,   47,   47,   11,    9,    0,   47,    0,
+        0,    0,    0,   47,   47,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   50,    0,   50,
-       58,   58,   58,    0,    0,    0,    0,    0,    0,    0,
-       58,   58,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   47,    0,   47,
+       51,   51,   51,    0,    0,    0,    0,    0,    0,    0,
+       51,   51,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 
-        0,    0,    0,    0,   58,    0,   58,   70,   70,    0,
-       70,    0,    0,    0,   70,   70,   70,   70,    0,   70,
-       70,   70,    0,   70,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   51,    0,   51,   60,   60,    0,
+       60,    0,    0,    0,   60,   60,   60,   60,    0,   60,
+       60,   60,    0,   60,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       70,  100,  100,    0,    0,    0,  100,    0,    0,    0,
-        0,  100,  100,    0,    0,    0,    0,    0,    0,    0,
+       60,   87,   87,    0,    0,    0,   87,    0,    0,    0,
+        0,   87,   87,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,  100,    0,  100,  108,  108,
-      108,    0,    0,    0,    0,    0,    0,    0,  108,  108,
+        0,    0,    0,    0,    0,   87,    0,   87,   91,   91,
+       91,    0,    0,    0,    0,    0,    0,    0,   91,   91,
 
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,  108,    0,  108,  118,  118,    0,  118,    0,
-        0,    0,  118,  118,  118,  118,    0,  118,  118,  118,
-        0,  118,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   91,    0,   91,   98,   98,    0,   98,    0,
+        0,    0,   98,   98,   98,   98,    0,   98,   98,   98,
+        0,   98,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  118,  226,
-      226,  226,  226,  227,  227,  227,  227,  228,  228,  228,
-      228,  229,  229,  230,  230,  230,  230,  231,  231,  231,
-      231,  232,  232,  232,  232,  233,    0,  233,  233,  234,
+        0,    0,    0,    0,    0,    0,    0,    0,   98,  206,
+      206,  206,  206,  207,  207,  207,  207,  208,  208,  208,
+      208,  209,  209,  210,  210,  210,  210,  211,  211,  211,
+      211,  212,  212,  212,  212,  213,    0,  213,  213,  214,
 
-        0,  234,  234,  235,  235,  235,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225
+        0,  214,  214,  215,  215,  215,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205
     } ;
 
 /* The intent behind this definition is that it'll catch
@@ -633,7 +627,6 @@
 #define YY_MORE_ADJ yyg->yy_more_len
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 "ael.flex"
-#line 2 "ael.flex"
 /*
  * Asterisk -- An open source telephony toolkit.
  *
@@ -654,8 +647,32 @@
 /*! \file
  *
  * \brief Flex scanner description of tokens used in AEL2 .
- * 
- */#include <sys/types.h>
+ *
+ */
+/*
+ * Start with flex options:
+ *
+ * %x describes the contexts we have: paren, semic and argg, plus INITIAL
+ */
+
+/* prefix used for various globally-visible functions and variables.
+ * This renames also ael_yywrap, but since we do not use it, we just
+ * add option noyywrap to remove it.
+ */
+/* batch gives a bit more performance if we are using it in
+ * a non-interactive mode. We probably don't care much.
+ */
+/* outfile is the filename to be used instead of lex.yy.c */
+/*
+ * These are not supported in flex 2.5.4, but we need them
+ * at the moment:
+ * reentrant produces a thread-safe parser. Not 100% sure that
+ * we require it, though.
+ * bison-bridge passes an additional yylval argument to ael_yylex().
+ * bison-locations is probably not needed.
+ */
+#line 59 "ael.flex"
+#include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
@@ -664,43 +681,103 @@
 #include "ael/ael.tab.h"
 #include "asterisk/ael_structs.h"
 
-static char pbcstack[400];
+/*
+ * A stack to keep track of matching brackets ( [ { } ] )
+ */
+static char pbcstack[400];	/* XXX missing size checks */
 static int pbcpos = 0;
 
 static int parencount = 0;
 static int commaout = 0;
-int my_lineno = 1;
-int my_col = 0;
-char *my_file = 0;
-char *prev_word;
+
+/*
+ * current line, column and filename, updated as we read the input.
+ */
+static int my_lineno = 1;	/* current line in the source */
+static int my_col = 1;		/* current column in the source */
+char *my_file = 0;		/* used also in the bison code */
+char *prev_word;		/* XXX document it */
+
 #define MAX_INCLUDE_DEPTH 50
 
-void reset_parencount(yyscan_t yyscanner );
-void reset_semicount(yyscan_t yyscanner );
-void reset_argcount(yyscan_t yyscanner );
-struct pval *ael2_parse(char *filename, int *errors);
+/*
+ * flex is not too smart, and generates global functions
+ * without prototypes so the compiler may complain.
+ * To avoid that, we declare the prototypes here,
+ * even though these functions are not used.
+ */
 int ael_yyget_column  (yyscan_t yyscanner);
 void ael_yyset_column (int  column_no , yyscan_t yyscanner);
+
 int ael_yyparse (struct parse_io *);
 static void pbcpush(char x);
 static int pbcpop(char x);
-static void pbcwhere(char *text, int *line, int *col );
-static int c_prevword(void);
 
-struct stackelement
-{
-     char *fname;
-	 int lineno;
-     int colno;
-	 YY_BUFFER_STATE bufstate;
+/*
+ * A stack to process include files.
+ * As we switch into the new file we need to store the previous
+ * state to restore it later.
+ */
+struct stackelement {
+	char *fname;
+	int lineno;
+	int colno;
+	YY_BUFFER_STATE bufstate;
 };
-struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
-int include_stack_index = 0;
 
+static struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
+static int include_stack_index = 0;
 
-/* %option yylineno I've tried hard, but haven't been able to use this */
-#line 703 "ael_lex.c"
+/*
+ * if we use the @n feature of bison, we must supply the start/end
+ * location of tokens in the structure pointed by yylloc.
+ * Simple tokens are just assumed to be on the same line, so
+ * the line number is constant, and the column is incremented
+ * by the length of the token.
+ */
+#ifdef FLEX_BETA	/* set for 2.5.33 */
 
+/* compute the total number of lines and columns in the text
+ * passed as argument.
+ */
+static void pbcwhere(const char *text, int *line, int *col )
+{
+	int loc_line = *line;
+	int loc_col = *col;
+	char c;
+	while ( (c = *text++) ) {
+		if ( c == '\t' ) {
+			loc_col += 8 - (loc_col % 8);
+		} else if ( c == '\n' ) {
+			loc_line++;
+			loc_col = 1;
+		} else
+			loc_col++;
+	}
+	*line = loc_line;
+	*col = loc_col;
+}
+
+#define	STORE_POS do {							\
+		yylloc->first_line = yylloc->last_line = my_lineno;	\
+		yylloc->first_column=my_col;				\
+		yylloc->last_column=my_col+yyleng-1;			\
+		my_col+=yyleng;						\
+	} while (0)
+
+#define	STORE_LOC do {					\
+		yylloc->first_line = my_lineno;		\
+		yylloc->first_column=my_col;		\
+		pbcwhere(yytext, &my_lineno, &my_col);	\
+		yylloc->last_line = my_lineno;		\
+		yylloc->last_column = my_col - 1;	\
+	} while (0)
+#else
+#define	STORE_POS
+#define	STORE_LOC
+#endif
+#line 780 "ael_lex.c"
+
 #define INITIAL 0
 #define paren 1
 #define semic 2
@@ -939,10 +1016,11 @@
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 77 "ael.flex"
+#line 172 "ael.flex"
 
-#line 945 "ael_lex.c"
 
+#line 1023 "ael_lex.c"
+
     yylval = yylval_param;
 
     yylloc = yylloc_param;
@@ -1004,13 +1082,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 226 )
+				if ( yy_current_state >= 206 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_current_state != 225 );
+		while ( yy_current_state != 205 );
 		yy_cp = yyg->yy_last_accepting_cpos;
 		yy_current_state = yyg->yy_last_accepting_state;
 
@@ -1032,703 +1110,503 @@
 
 case 1:
 YY_RULE_SETUP
-#line 78 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return LC;}
+#line 174 "ael.flex"
+{ STORE_POS; return LC;}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 79 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return RC;}
+#line 175 "ael.flex"
+{ STORE_POS; return RC;}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 80 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return LP;}
+#line 176 "ael.flex"
+{ STORE_POS; return LP;}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 81 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return RP;}
+#line 177 "ael.flex"
+{ STORE_POS; return RP;}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 82 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return SEMI;}
+#line 178 "ael.flex"
+{ STORE_POS; return SEMI;}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 83 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return EQ;}
+#line 179 "ael.flex"
+{ STORE_POS; return EQ;}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 84 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return COMMA;}
+#line 180 "ael.flex"
+{ STORE_POS; return COMMA;}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 85 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return COLON;}
+#line 181 "ael.flex"
+{ STORE_POS; return COLON;}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 86 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return AMPER;}
+#line 182 "ael.flex"
+{ STORE_POS; return AMPER;}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 87 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return BAR;}
+#line 183 "ael.flex"
+{ STORE_POS; return BAR;}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 88 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return EXTENMARK;}
+#line 184 "ael.flex"
+{ STORE_POS; return EXTENMARK;}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 89 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return AT;}
+#line 185 "ael.flex"
+{ STORE_POS; return AT;}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 90 "ael.flex"
+#line 186 "ael.flex"
 {/*comment*/}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 91 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CONTEXT;}
+#line 187 "ael.flex"
+{ STORE_POS; return KW_CONTEXT;}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 92 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_ABSTRACT;}
+#line 188 "ael.flex"
+{ STORE_POS; return KW_ABSTRACT;}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 93 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_MACRO;};
+#line 189 "ael.flex"
+{ STORE_POS; return KW_MACRO;};
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 94 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_GLOBALS;}
+#line 190 "ael.flex"
+{ STORE_POS; return KW_GLOBALS;}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 95 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_IGNOREPAT;}
+#line 191 "ael.flex"
+{ STORE_POS; return KW_IGNOREPAT;}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 96 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_SWITCH;}
+#line 192 "ael.flex"
+{ STORE_POS; return KW_SWITCH;}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 97 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_IF;}
+#line 193 "ael.flex"
+{ STORE_POS; return KW_IF;}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 98 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_IFTIME;}
+#line 194 "ael.flex"
+{ STORE_POS; return KW_IFTIME;}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 99 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_RANDOM;}
+#line 195 "ael.flex"
+{ STORE_POS; return KW_RANDOM;}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 100 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_REGEXTEN;}
+#line 196 "ael.flex"
+{ STORE_POS; return KW_REGEXTEN;}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 101 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_HINT;}
+#line 197 "ael.flex"
+{ STORE_POS; return KW_HINT;}
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 102 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_ELSE;}
+#line 198 "ael.flex"
+{ STORE_POS; return KW_ELSE;}
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 103 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_GOTO;}
+#line 199 "ael.flex"
+{ STORE_POS; return KW_GOTO;}
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 104 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_JUMP;}
+#line 200 "ael.flex"
+{ STORE_POS; return KW_JUMP;}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 105 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_RETURN;}
+#line 201 "ael.flex"
+{ STORE_POS; return KW_RETURN;}
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 106 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_BREAK;}
+#line 202 "ael.flex"
+{ STORE_POS; return KW_BREAK;}
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 107 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CONTINUE;}
+#line 203 "ael.flex"
+{ STORE_POS; return KW_CONTINUE;}
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 108 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_FOR;}
+#line 204 "ael.flex"
+{ STORE_POS; return KW_FOR;}
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 109 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_WHILE;}
+#line 205 "ael.flex"
+{ STORE_POS; return KW_WHILE;}
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 110 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CASE;}
+#line 206 "ael.flex"
+{ STORE_POS; return KW_CASE;}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 111 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_DEFAULT;}
+#line 207 "ael.flex"
+{ STORE_POS; return KW_DEFAULT;}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 112 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_PATTERN;}
+#line 208 "ael.flex"
+{ STORE_POS; return KW_PATTERN;}
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 113 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_CATCH;}
+#line 209 "ael.flex"
+{ STORE_POS; return KW_CATCH;}
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 114 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_SWITCHES;}
+#line 210 "ael.flex"
+{ STORE_POS; return KW_SWITCHES;}
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 115 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_ESWITCHES;}
+#line 211 "ael.flex"
+{ STORE_POS; return KW_ESWITCHES;}
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 116 "ael.flex"
-{yylloc->first_line = yylloc->last_line = my_lineno; yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col;my_col+=yyleng;return KW_INCLUDES;}
+#line 212 "ael.flex"
+{ STORE_POS; return KW_INCLUDES;}
 	YY_BREAK
 case 40:
 /* rule 40 can match eol */
 YY_RULE_SETUP
-#line 118 "ael.flex"
-{my_lineno++;my_col=0;}
+#line 214 "ael.flex"
+{ my_lineno++; my_col = 1; }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 119 "ael.flex"
-{/* nothing */ my_col+=yyleng;}
+#line 215 "ael.flex"
+{ my_col += yyleng; }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 120 "ael.flex"
-{/* nothing */ int wid = 8-(my_col%8); my_col+=wid;}
+#line 216 "ael.flex"
+{ my_col += (yyleng*8)-(my_col%8); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 122 "ael.flex"
+#line 218 "ael.flex"
 {
-                                               yylloc->first_line = yylloc->last_line = my_lineno;yylloc->last_column=my_col+yyleng-1; yylloc->first_column=my_col; /* set up the ptr */
-                                               yylval->str = strdup(yytext);  
-                                               /* printf("\nGot WORD %s[%d][%d:%d]\n", yylval->str, my_lineno ,yylloc->first_column,yylloc->last_column );  */
-                                               my_col+=yyleng; 
-                                               prev_word = yylval->str;
-                                               return word;
-                                        }
+		STORE_POS;
+		yylval->str = strdup(yytext);
+		prev_word = yylval->str;
+		return word;
+	}
 	YY_BREAK
 case 44:
 /* rule 44 can match eol */
 YY_RULE_SETUP
-#line 131 "ael.flex"
-{yylloc->first_line = my_lineno; yylloc->first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n", my_file, my_lineno+l4, c4, yytext);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             prev_word = 0;
-                             return word;
-                         }
-                 parencount--;
-                 if ( parencount >= 0) {
-                   yymore();
-                 } else { 
-                   int l4,c4;
-                   pbcwhere(yytext, &l4, &c4);
-                   yylloc->last_line = my_lineno+l4;
-				   yylloc->last_column=c4; 
-                   yylval->str = strdup(yytext); 
-                   *(yylval->str+strlen(yylval->str)-1)=0;
-                   /* printf("Got paren word %s\n", yylval->str); */ 
-                   unput(')'); 
-	               my_col=c4;
-                   my_lineno += l4;
-                   BEGIN(0); 
-                   return word;
-                 } 
-                }
+#line 228 "ael.flex"
+{
+		if ( pbcpop(')') ) {	/* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n", my_file, my_lineno, my_col, yytext);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			prev_word = 0;
+			return word;
+		}
+		parencount--;
+		if ( parencount >= 0) {
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval->str = strdup(yytext);
+			*(yylval->str+strlen(yylval->str)-1)=0;
+			/* printf("Got paren word %s\n", yylval->str); */
+			unput(')');
+			BEGIN(0);
+			return word;
+		}
+	}
 	YY_BREAK
 case 45:
 /* rule 45 can match eol */
 YY_RULE_SETUP
-#line 165 "ael.flex"
-{yylloc->first_line = my_lineno; yylloc->first_column=my_col; 
-                  parencount++; pbcpush('(');
-                  yymore();
-                 }
+#line 251 "ael.flex"
+{
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 	YY_BREAK
 case 46:
 /* rule 46 can match eol */
 YY_RULE_SETUP
-#line 169 "ael.flex"
-{yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('['); }
+#line 259 "ael.flex"
+{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c))  { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n",
+				my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 	YY_BREAK
 case 47:
 /* rule 47 can match eol */
 YY_RULE_SETUP
-#line 170 "ael.flex"
-{yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ']' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
+#line 272 "ael.flex"
+{
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 	YY_BREAK
 case 48:
 /* rule 48 can match eol */
 YY_RULE_SETUP
-#line 186 "ael.flex"
-{yylloc->first_line = my_lineno;yylloc->first_column=my_col;  yymore(); pbcpush('{'); }
+#line 280 "ael.flex"
+{
+		if ( pbcpop(')') ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno, my_col);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+
+		parencount--;
+		if( parencount >= 0){
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval->str = strdup(yytext);
+			if(yyleng > 1 )
+				*(yylval->str+yyleng-1)=0;
+			BEGIN(0);
+			if ( !strcmp(yylval->str,")") ) {
+				free(yylval->str);
+				yylval->str = 0;
+				my_col++; /* XXX why ? */
+				return RP;
+			} else {
+				unput(')');
+				return word;
+			}
+		}
+	}
 	YY_BREAK
 case 49:
 /* rule 49 can match eol */
 YY_RULE_SETUP
-#line 187 "ael.flex"
-{yylloc->first_line = my_lineno;
-                         yylloc->first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '}' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
+#line 310 "ael.flex"
+{
+		if( parencount != 0) { /* printf("Folding in a comma!\n"); */
+			yymore();
+		} else  {
+			STORE_LOC;
+			if( !commaout ) {
+				if( !strcmp(yytext,"," ) ) {
+					commaout = 0;
+					my_col+=1;
+					return COMMA;
+				}
+				yylval->str = strdup(yytext);
+				/* printf("Got argg2 word %s\n", yylval->str); */
+				unput(',');
+				commaout = 1;
+				if (yyleng > 1 )
+					*(yylval->str+yyleng-1)=0;
+				return word;
+			} else {
+				commaout = 0;
+				my_col+=1;
+				return COMMA;
+			}
+		}
+	}
 	YY_BREAK
 case 50:
 /* rule 50 can match eol */
 YY_RULE_SETUP
-#line 206 "ael.flex"
-{/* printf("ARGG:%s\n",yytext); */
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
-
-					yylloc->first_line = my_lineno;
-                    yylloc->first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                   
-
-					while (*pt) {
-                       if (*pt == '\n') {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc->last_line = my_lineno+linecount;
-                    yylloc->last_column=colcount; 
-                    parencount--;
-                    if( parencount >= 0){ 
-                        yymore(); 
-                    } else { 
-                        yylval->str = strdup(yytext); 
-					   if(yyleng > 1 ) 
-                              *(yylval->str+yyleng-1)=0;
-                       /* printf("Got argg word '%s'\n", yylval->str);  */
-                       BEGIN(0); 
-                       if ( !strcmp(yylval->str,")") ) { 
-                             free(yylval->str); 
-                             yylval->str = 0; 
-                             my_col+=1;
-                             return RP;  
-                       } else {
-                             unput(')');
-                             my_col=colcount;
-							 my_lineno+=linecount;
-                             return word;
-                       }
-                    } 
-                }
+#line 336 "ael.flex"
+{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 	YY_BREAK
 case 51:
 /* rule 51 can match eol */
 YY_RULE_SETUP
-#line 260 "ael.flex"
-{ /* printf("ARGG:%s\n",yytext); */
-                      /* printf("GOT AN LP!!!\n"); */
-                      yylloc->first_line = my_lineno;
-                      yylloc->first_column=my_col; 
-                      parencount++; 
-                      pbcpush('(');
-                      yymore();
-                  }
+#line 350 "ael.flex"
+{
+		char c = yytext[yyleng-1];
+		yymore();
+		pbcpush(c);
+	}
 	YY_BREAK
 case 52:
 /* rule 52 can match eol */
 YY_RULE_SETUP
-#line 269 "ael.flex"
-{  /* printf("ARGG:%s\n",yytext); */
-                  if( parencount != 0) { 
-					/* printf("Folding in a comma!\n"); */ 
-					yymore();
-				  } else  { 
-                     /* printf("got a comma!\n\n");  */
-					 int linecount = 0;
-                     int colcount = my_col;
-					 char *pt;
-
-					 pt = yytext;
-					 while (*pt) {
-                        if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                        }
-                        pt++;
-                        colcount++;
-                     }
-                     yylloc->first_line = my_lineno; 
-                     yylloc->last_line = my_lineno+linecount; 
-                     yylloc->last_column=colcount; 
-                     yylloc->first_column=my_col;
-                     if( !commaout ) { 
-						if( !strcmp(yytext,"," ) ) 
-							{commaout = 0; my_col+=1; return COMMA;} 
-						yylval->str = strdup(yytext); /* printf("Got argg2 word %s\n", yylval->str); */ 
-						unput(','); 
-						commaout = 1; 
-						if(yyleng > 1 ) 
-							*(yylval->str+yyleng-1)=0;
-                        my_lineno+=linecount;
-						my_col=colcount;
-						return word;
-					 } else {
-                            commaout = 0;
-							my_col+=1;
-							return COMMA;
-						}
-                   }
-				}
+#line 356 "ael.flex"
+{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n", my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval->str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 	YY_BREAK
 case 53:
 /* rule 53 can match eol */
 YY_RULE_SETUP
-#line 311 "ael.flex"
-{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; pbcpush('{'); yymore();  }
+#line 368 "ael.flex"
+{
+		STORE_LOC;
+		yylval->str = strdup(yytext);
+		if(yyleng > 1)
+			*(yylval->str+yyleng-1)=0;
+		unput(';');
+		BEGIN(0);
+		return word;
+	}
 	YY_BREAK
 case 54:
 /* rule 54 can match eol */
 YY_RULE_SETUP
-#line 312 "ael.flex"
-{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '}' in expression!\n", my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-				}
-	YY_BREAK
-case 55:
-/* rule 55 can match eol */
-YY_RULE_SETUP
-#line 328 "ael.flex"
-{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('['); }
-	YY_BREAK
-case 56:
-/* rule 56 can match eol */
-YY_RULE_SETUP
-#line 329 "ael.flex"
-{/*printf("ARGG:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ']' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-				}
-	YY_BREAK
-case 57:
-/* rule 57 can match eol */
-YY_RULE_SETUP
-#line 347 "ael.flex"
-{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('['); }
-	YY_BREAK
-case 58:
-/* rule 58 can match eol */
-YY_RULE_SETUP
-#line 348 "ael.flex"
-{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ']' in expression!\n", my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-	YY_BREAK
-case 59:
-/* rule 59 can match eol */
-YY_RULE_SETUP
-#line 363 "ael.flex"
-{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('{');}
-	YY_BREAK
-case 60:
-/* rule 60 can match eol */
-YY_RULE_SETUP
-#line 364 "ael.flex"
-{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched '}' in expression!\n", my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-	YY_BREAK
-case 61:
-/* rule 61 can match eol */
-YY_RULE_SETUP
-#line 379 "ael.flex"
-{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; yymore(); pbcpush('(');}
-	YY_BREAK
-case 62:
-/* rule 62 can match eol */
-YY_RULE_SETUP
-#line 380 "ael.flex"
-{/*printf("SEMIC:%s\n",yytext);*/yylloc->first_line = my_lineno;yylloc->first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &l4, &c4);
-                             ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Mismatched ')' in expression!\n", my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc->last_line = my_lineno+l4;
-                             yylloc->last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval->str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-	YY_BREAK
-case 63:
-/* rule 63 can match eol */
-YY_RULE_SETUP
-#line 395 "ael.flex"
+#line 378 "ael.flex"
 {
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
-					while (*pt) {
-                       if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc->first_line = my_lineno; 
-					yylloc->last_line = my_lineno+linecount; 
-					yylloc->last_column=colcount; 
-					yylloc->first_column=my_col;
-                    yylval->str = strdup(yytext);
-                    if(yyleng > 1)
-                      *(yylval->str+yyleng-1)=0;
-                    /* printf("Got semic word %s\n", yylval->str); */
-                    unput(';');
-                    BEGIN(0);
-                    my_col=colcount;
-                    my_lineno += linecount;
-                    return word;
-                }
-	YY_BREAK
-case 64:
-/* rule 64 can match eol */
-YY_RULE_SETUP
-#line 422 "ael.flex"
-{
-                     FILE *in1;
-					 char fnamebuf[1024],*p1,*p2;
-                     if ( include_stack_index >= MAX_INCLUDE_DEPTH ) {
-						ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n", my_file, my_lineno, my_col);
-                     } else {
-                         p1 = strchr(yytext,'"');
-                         p2 = strrchr(yytext,'"');
-                         if ( (int)(p2-p1) > 1023 ) {
-							ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n", my_file, my_lineno, my_col, yyleng - 10);
-        	             } else {
-								int i;
-								int found = 0;
-								strncpy(fnamebuf,p1,p2-p1);
-								fnamebuf[p2-p1] = 0;
-								for (i=0; i<include_stack_index; i++) {
-									if ( !strcmp(fnamebuf,include_stack[i].fname )) {
-										ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n", 
-												my_file, my_lineno, my_col, fnamebuf);
-										found=1;
-										break;
-									}
-								}
-								if( !found )
-								{
-                                	*p2 = 0;
-                                    /* relative vs. absolute */
-                                    if ( *(p1+1) != '/' )
-                                    {
-                                        strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
-										strcat(fnamebuf,"/");
-										strcat(fnamebuf,p1+1);
-                                    }
-                                    else
-                                	    strcpy(fnamebuf,p1+1);
-		                        	in1 = fopen( fnamebuf, "r" );
-                                	if ( ! in1 ) {
-						ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);
-                                	} else {
-						char *buffer;
-	                             	 	struct stat stats;
-	                            		stat(fnamebuf, &stats);
-	                             		buffer = (char*)malloc(stats.st_size+1);
-	                             		fread(buffer, 1, stats.st_size, in1);
-						buffer[stats.st_size] = 0;
-						ast_log(LOG_NOTICE,"  --Read in included file %s, %d chars\n",fnamebuf, (int)stats.st_size);
-	                                	fclose(in1);
+		FILE *in1;
+		char fnamebuf[1024],*p1,*p2;
+		int error = 1;	/* don't use the file if set */
+		p1 = strchr(yytext,'"');
+		p2 = strrchr(yytext,'"');
+		if ( include_stack_index >= MAX_INCLUDE_DEPTH ) {
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n", my_file, my_lineno, my_col);
+		} else if ( (int)(p2-p1) > sizeof(fnamebuf) - 1 ) {
+			ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n", my_file, my_lineno, my_col, yyleng - 10);
+		} else {
+			int i;
+			strncpy(fnamebuf, p1, p2-p1);
+			fnamebuf[p2-p1] = 0;
+			for (i=0; i<include_stack_index; i++) {
+				if ( !strcmp(fnamebuf,include_stack[i].fname )) {
+					ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n",
+						my_file, my_lineno, my_col, fnamebuf);
+					break;
+				}
+			}
+			if (i == include_stack_index)
+				error = 0;	/* we can use this file */
+		}
+		if ( !error ) {	/* valid file name */
+			*p2 = 0;
+			/* relative vs. absolute */
+			if ( *(p1+1) != '/' ) {
+				/* XXX must check overflows */
+				strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
+				strcat(fnamebuf,"/");
+				strcat(fnamebuf,p1+1);
+			} else
+				strcpy(fnamebuf,p1+1);
+			in1 = fopen( fnamebuf, "r" );
+			if ( ! in1 ) {
+				ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);
+			} else {
+				char *buffer;
+				struct stat stats;
+				stat(fnamebuf, &stats);
+				buffer = (char*)malloc(stats.st_size+1);
+				fread(buffer, 1, stats.st_size, in1);
+				buffer[stats.st_size] = 0;
+				ast_log(LOG_NOTICE,"  --Read in included file %s, %d chars\n",fnamebuf, (int)stats.st_size);
+				fclose(in1);
 
-						include_stack[include_stack_index].fname = my_file;
-						my_file = strdup(fnamebuf);
-						include_stack[include_stack_index].lineno = my_lineno;
-						include_stack[include_stack_index].colno = my_col+yyleng;
-						include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
+				include_stack[include_stack_index].fname = my_file;
+				my_file = strdup(fnamebuf);
+				include_stack[include_stack_index].lineno = my_lineno;
+				include_stack[include_stack_index].colno = my_col+yyleng;
+				include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
 
-	                                	ael_yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
-                                    		free(buffer);
-                                  	  	my_lineno = 1;
-                                    		my_col = 1;
-                                    		BEGIN(INITIAL);
-                                	}
-                                }
-                         }
-                     }
-                 }
+				ael_yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
+				free(buffer);
+				my_lineno = 1;
+				my_col = 1;
+				BEGIN(INITIAL);
+			}
+		}
+	}
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(paren):
 case YY_STATE_EOF(semic):
 case YY_STATE_EOF(argg):
-#line 487 "ael.flex"
+#line 440 "ael.flex"
 {
-                 if ( --include_stack_index < 0 ) {
-                 	    yyterminate();
-                     } else {
-						 free(my_file);
-                         ael_yy_delete_buffer(YY_CURRENT_BUFFER,yyscanner );
-                         ael_yy_switch_to_buffer(include_stack[include_stack_index].bufstate,yyscanner );
-                         my_lineno = include_stack[include_stack_index].lineno;
-                         my_col    = include_stack[include_stack_index].colno;
-                         my_file   = include_stack[include_stack_index].fname;
-                     }
-          }
+		if ( --include_stack_index < 0 ) {
+			yyterminate();
+		} else {
+			free(my_file);
+			ael_yy_delete_buffer(YY_CURRENT_BUFFER,yyscanner );
+			ael_yy_switch_to_buffer(include_stack[include_stack_index].bufstate,yyscanner );
+			my_lineno = include_stack[include_stack_index].lineno;
+			my_col    = include_stack[include_stack_index].colno;
+			my_file   = include_stack[include_stack_index].fname;
+		}
+	}
 	YY_BREAK
-case 65:
+case 55:
 YY_RULE_SETUP
-#line 501 "ael.flex"
+#line 453 "ael.flex"
 ECHO;
 	YY_BREAK
-#line 1732 "ael_lex.c"
+#line 1610 "ael_lex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -2013,7 +1891,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 226 )
+			if ( yy_current_state >= 206 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -2042,11 +1920,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 226 )
+		if ( yy_current_state >= 206 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 225);
+	yy_is_jam = (yy_current_state == 205);
 
 	return yy_is_jam ? 0 : yy_current_state;
 }
@@ -2858,7 +2736,7 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 501 "ael.flex"
+#line 453 "ael.flex"
 
 
 
@@ -2875,47 +2753,36 @@
 		pbcpos--;
 		return 0;
 	}
-	else
-		return 1; /* error */
+	return 1; /* error */
 }
 
 static int c_prevword(void)
 {
-    char *c = prev_word;
-	int ret = 0;
-	while ( c && *c ) {
-        switch (*c) {
-            case '{': pbcpush('{');break;
-            case '}': ret = pbcpop('}');break;
-            case '[':pbcpush('[');break;
-            case ']':ret = pbcpop(']');break;
-            case '(':pbcpush('(');break;
-            case ')':ret = pbcpop(')'); break;
-        }
-        if( ret )
-            return 1;
+	char *c = prev_word;
+	if (c == NULL)
+		return 0;
+	while ( *c ) {
+		switch (*c) {
+		case '{':
+		case '[':
+		case '(':
+			pbcpush(*c);
+			break;
+		case '}':
+		case ']':
+		case ')':
+			if (pbcpop(*c))
+				return 1;
+			break;
+		}
 		c++;
 	}
 	return 0;
 }
 
-static void pbcwhere(char *text, int *line, int *col )
-{
-	int loc_line = 0;
-    int loc_col = 0;
-	while ( *text ) {
-       if ( *text == '\n' ) {
-             loc_line++;
-             loc_col = 1;
-       } else {
-             loc_col++;
-       }
-       text++;
-    }
-	*line = loc_line;
-    *col = loc_col;
-}
 
+/* used by the bison code */
+void reset_parencount(yyscan_t yyscanner );
 void reset_parencount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2926,6 +2793,8 @@
 	BEGIN(paren);
 }
 
+/* used by the bison code */
+void reset_semicount(yyscan_t yyscanner );
 void reset_semicount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2933,6 +2802,8 @@
 	BEGIN(semic);
 }
 
+/* used by the bison code */
+void reset_argcount(yyscan_t yyscanner );
 void reset_argcount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2944,7 +2815,7 @@
 	BEGIN(argg);
 }
 
-
+/* used elsewhere, but some local vars */
 struct pval *ael2_parse(char *filename, int *errors)
 {
 	struct pval *pval;
@@ -2975,7 +2846,7 @@
 	fread(buffer, 1, stats.st_size, fin);
 	buffer[stats.st_size]=0;
 	fclose(fin);
-	
+
 	ael_yy_scan_string (buffer ,io->scanner);
 	ael_yyset_lineno(1 , io->scanner);
 

Modified: trunk/pbx/pbx_ael.c
===================================================================
--- trunk/pbx/pbx_ael.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/pbx_ael.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -29,10 +29,11 @@
 #include <ctype.h>
 #include <errno.h>
 #include <regex.h>
+#include <sys/stat.h>
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22413 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22654 $")
 
 #include "asterisk/pbx.h"
 #include "asterisk/config.h"
@@ -124,9 +125,9 @@
 static const char *description(void);
 static const char *key(void);
 
-static char *match_context;
-static char *match_exten;
-static char *match_label;
+static const char *match_context;
+static const char *match_exten;
+static const char *match_label;
 static int in_abstract_context;
 static int count_labels; /* true, put matcher in label counting mode */
 static int label_count;  /* labels are only meant to be counted in a context or exten */
@@ -138,15 +139,20 @@
 static void check_day(pval *DAY);
 static void check_month(pval *MON);
 static void check_expr2_input(pval *expr, char *str);
-static int extension_matches(pval *here, char *exten, char *pattern);
+static int extension_matches(pval *here, const char *exten, const char *pattern);
 static void check_goto(pval *item);
 static void find_pval_goto_item(pval *item, int lev);
 static void find_pval_gotos(pval *item, int lev);
 
+static struct pval *find_label_in_current_context(char *exten, char *label);
+static void print_pval_list(FILE *fin, pval *item, int depth);
 
+static struct pval *find_label_in_current_extension(const char *label);
+static struct pval *find_label_in_current_db(const char *context, const char *exten, const char *label);
+
 /* PRETTY PRINTER FOR AEL:  ============================================================================= */
 
-void print_pval(FILE *fin, pval *item, int depth)
+static void print_pval(FILE *fin, pval *item, int depth)
 {
 	int i;
 	pval *lp;
@@ -400,7 +406,7 @@
 	}
 }
 
-void print_pval_list(FILE *fin, pval *item, int depth)
+static void print_pval_list(FILE *fin, pval *item, int depth)
 {
 	pval *i;
 	
@@ -409,7 +415,8 @@
 	}
 }
 
-void ael2_print(char *fname, pval *tree)
+#if 0
+static void ael2_print(char *fname, pval *tree)
 {
 	FILE *fin = fopen(fname,"w");
 	if ( !fin ) {
@@ -419,6 +426,7 @@
 	print_pval_list(fin, tree, 0);
 	fclose(fin);
 }
+#endif
 
 
 /* EMPTY TEMPLATE FUNCS FOR AEL TRAVERSAL:  ============================================================================= */
@@ -677,7 +685,7 @@
 
 
 
-static int extension_matches(pval *here, char *exten, char *pattern)
+static int extension_matches(pval *here, const char *exten, const char *pattern)
 {
 	int err1;
 	regex_t preg;
@@ -688,7 +696,8 @@
 	
 	if ( pattern[0] == '_' ) {
 		char reg1[2000];
-		char *p,*r=reg1;
+		const char *p;
+		char *r = reg1;
 		
 		if ( strlen(pattern)*5 >= 2000 ) /* safety valve */ {
 			ast_log(LOG_ERROR,"Error: The pattern %s is way too big. Pattern matching cancelled.\n",
@@ -1511,7 +1520,7 @@
 	return 0;
 }
 
-
+#if 0
 int count_labels_in_current_context(char *label)
 {
 	label_count = 0;
@@ -1521,6 +1530,7 @@
 	
 	return label_count;
 }
+#endif
 
 struct pval *find_label_in_current_context(char *exten, char *label)
 {
@@ -1564,7 +1574,7 @@
 	return 0;
 }
 
-struct pval *find_label_in_current_extension(char *label)
+static struct pval *find_label_in_current_extension(const char *label)
 {
 	/* printf("  --- Got args %s\n", label); */
 	count_labels = 0;
@@ -1577,7 +1587,7 @@
 	return match_pval(current_extension->u2.statements);
 }
 
-struct pval *find_label_in_current_db(char *context, char *exten, char *label)
+static struct pval *find_label_in_current_db(const char *context, const char *exten, const char *label)
 {
 	/* printf("  --- Got args %s, %s, %s\n", context, exten, label); */
 	count_labels = 0;
@@ -2408,7 +2418,7 @@
 	}
 }
 
-void ael2_semantic_check(pval *item, int *arg_errs, int *arg_warns, int *arg_notes)
+static void ael2_semantic_check(pval *item, int *arg_errs, int *arg_warns, int *arg_notes)
 {
 	
 #ifdef AAL_ARGCHECK

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/rtp.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -41,7 +41,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision: 20224 $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22905 $")
 
 #include "asterisk/rtp.h"
 #include "asterisk/frame.h"
@@ -739,11 +739,11 @@
 	struct ast_rtp *vdestp, *vsrcp;		/* Video RTP channels */
 	struct ast_rtp_protocol *destpr, *srcpr;
 	/* Lock channels */
-	ast_mutex_lock(&dest->lock);
-	while(ast_mutex_trylock(&src->lock)) {
-		ast_mutex_unlock(&dest->lock);
+	ast_channel_lock(dest);
+	while(ast_channel_trylock(src)) {
+		ast_channel_unlock(dest);
 		usleep(1);
-		ast_mutex_lock(&dest->lock);
+		ast_channel_lock(dest);
 	}
 
 	/* Find channel driver interfaces */
@@ -752,15 +752,15 @@
 	if (!destpr) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Channel '%s' has no RTP, not doing anything\n", dest->name);
-		ast_mutex_unlock(&dest->lock);
-		ast_mutex_unlock(&src->lock);
+		ast_channel_unlock(dest);
+		ast_channel_unlock(src);
 		return 0;
 	}
 	if (!srcpr) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Channel '%s' has no RTP, not doing anything\n", src->name);
-		ast_mutex_unlock(&dest->lock);
-		ast_mutex_unlock(&src->lock);
+		ast_channel_unlock(dest);
+		ast_channel_unlock(src);
 		return 0;
 	}
 
@@ -773,15 +773,15 @@
 	/* Check if bridge is still possible (In SIP canreinvite=no stops this, like NAT) */
 	if (!destp || !srcp) {
 		/* Somebody doesn't want to play... */
-		ast_mutex_unlock(&dest->lock);
-		ast_mutex_unlock(&src->lock);
+		ast_channel_unlock(dest);
+		ast_channel_unlock(src);
 		return 0;
 	}
 	ast_rtp_pt_copy(destp, srcp);
 	if (vdestp && vsrcp)
 		ast_rtp_pt_copy(vdestp, vsrcp);
-	ast_mutex_unlock(&dest->lock);
-	ast_mutex_unlock(&src->lock);
+	ast_channel_unlock(dest);
+	ast_channel_unlock(src);
 	if (option_debug)
 		ast_log(LOG_DEBUG, "Seeded SDP of '%s' with that of '%s'\n", dest->name, src->name);
 	return 1;
@@ -1562,11 +1562,11 @@
 		return AST_BRIDGE_FAILED_NOWARN;
 
 	/* Lock channels */
-	ast_mutex_lock(&c0->lock);
-	while(ast_mutex_trylock(&c1->lock)) {
-		ast_mutex_unlock(&c0->lock);
+	ast_channel_lock(c0);
+	while(ast_channel_trylock(c1)) {
+		ast_channel_unlock(c0);
 		usleep(1);
-		ast_mutex_lock(&c0->lock);
+		ast_channel_lock(c0);
 	}
 
 	/* Find channel driver interfaces */
@@ -1574,14 +1574,14 @@
 	pr1 = get_proto(c1);
 	if (!pr0) {
 		ast_log(LOG_WARNING, "Can't find native functions for channel '%s'\n", c0->name);
-		ast_mutex_unlock(&c0->lock);
-		ast_mutex_unlock(&c1->lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return AST_BRIDGE_FAILED;
 	}
 	if (!pr1) {
 		ast_log(LOG_WARNING, "Can't find native functions for channel '%s'\n", c1->name);
-		ast_mutex_unlock(&c0->lock);
-		ast_mutex_unlock(&c1->lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return AST_BRIDGE_FAILED;
 	}
 
@@ -1598,8 +1598,8 @@
 	/* Check if bridge is still possible (In SIP canreinvite=no stops this, like NAT) */
 	if (!p0 || !p1) {
 		/* Somebody doesn't want to play... */
-		ast_mutex_unlock(&c0->lock);
-		ast_mutex_unlock(&c1->lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return AST_BRIDGE_FAILED_NOWARN;
 	}
 	/* Get codecs from both sides */
@@ -1610,8 +1610,8 @@
 		if (!(codec0 & codec1)) {
 			if (option_debug)
 				ast_log(LOG_DEBUG, "Channel codec0 = %d is not codec1 = %d, cannot native bridge in RTP.\n", codec0, codec1);
-			ast_mutex_unlock(&c0->lock);
-			ast_mutex_unlock(&c1->lock);
+			ast_channel_unlock(c0);
+			ast_channel_unlock(c1);
 			return AST_BRIDGE_FAILED_NOWARN;
 		}
 	}
@@ -1637,8 +1637,8 @@
 		if (vp0)
 			ast_rtp_get_peer(vp0, &vac0);
 	}
-	ast_mutex_unlock(&c0->lock);
-	ast_mutex_unlock(&c1->lock);
+	ast_channel_unlock(c0);
+	ast_channel_unlock(c1);
 	/* External RTP Bridge up, now loop and see if something happes that force us to take the
 		media back to Asterisk */
 	cs[0] = c0;

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/utils/Makefile	2006-04-29 02:51:28 UTC (rev 3)
@@ -14,7 +14,7 @@
 #
 # Don't use ast mm routines
 #
-UTILS:=astman smsq stereorize streamplayer
+UTILS:=astman smsq stereorize streamplayer aelparse
 
 ifeq (${OSARCH},SunOS)
   SOL=../strcompat.o
@@ -70,7 +70,7 @@
 	$(CC) $(CFLAGS) -g -o aelparse ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ael_main.o ../pbx/pbx_ael.o ../ast_expr2f.o ../ast_expr2.o
 
 ael_main.o : ael_main.c ../include/asterisk/ael_structs.h
-	$(CC) $(CFLAGS) -c -g -o ael_main.o ael_main.c
+	$(CC) $(CFLAGS) -include ../include/autoconfig.h -c -g -o ael_main.o ael_main.c
 
 ael_main1.o : ael_main.c ../include/asterisk/ael_structs.h
 	$(CC) $(CFLAGS) -c -g  -o ael_main1.o ael_main.c

Modified: trunk/utils/ael_main.c
===================================================================
--- trunk/utils/ael_main.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/utils/ael_main.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -6,17 +6,15 @@
 #include <ctype.h>
 #if !defined(SOLARIS) && !defined(__CYGWIN__)
 #include <err.h>
-#else
-#define quad_t int64_t
 #endif
 #include <errno.h>
 #include <regex.h>
 #include <limits.h>
-#include <asterisk/ast_expr.h>
-#include <asterisk/logger.h>
-#include <asterisk/module.h>
-#include <asterisk/channel.h>
-#include <asterisk/app.h>
+#include "asterisk/ast_expr.h"
+#include "asterisk/logger.h"
+#include "asterisk/module.h"
+#include "asterisk/channel.h"
+#include "asterisk/app.h"
 #include "asterisk/ael_structs.h"
 #define AST_CONFIG_MAX_PATH 255
 



From casper2 at berlios.de  Sat Apr 29 05:20:58 2006
From: casper2 at berlios.de (casper2 at berlios.de)
Date: Sat, 29 Apr 2006 05:20:58 +0200
Subject: [Solid-pbx-svn] r4 - trunk
Message-ID: <200604290320.k3T3Kw9Q010183@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 05:20:55 +0200 (Sat, 29 Apr 2006)
New Revision: 4

Modified:
   trunk/README
Log:
Update README

Modified: trunk/README
===================================================================
--- trunk/README	2006-04-29 02:51:28 UTC (rev 3)
+++ trunk/README	2006-04-29 03:20:55 UTC (rev 4)
@@ -1,7 +1,11 @@
-The Asterisk Open Source PBX
-by Mark Spencer <markster at digium.com>
+The Solid PBX Soft Switch Class 5
+by the Solid PBX community
+
+Our thanks to:
+Mark Spencer <markster at digium.com>
 and the Asterisk.org developer community
 
+Copyright (C) 2006 The Solid PBX project
 Copyright (C) 2001-2006 Digium, Inc.
 and other copyright holders.
 ================================================================
@@ -9,18 +13,18 @@
 * SECURITY
   It is imperative that you read and fully understand the contents of
 the security information file (doc/security.txt) before you attempt 
-to configure and run an Asterisk server.
+to configure and run a Solid PBX server.
 
-* WHAT IS ASTERISK ?
-  Asterisk is an Open Source PBX and telephony toolkit.  It is, in a
+* WHAT IS SOLID PBX ?
+  Solid PBX is an Open Source PBX and telephony toolkit.  It is, in a
 sense, middleware between Internet and telephony channels on the bottom,
 and Internet and telephony applications at the top.  For more information
-on the project itself, please visit the Asterisk home page at:
+on the project itself, please visit the Solid PBX home page at:
 
-           http://www.asterisk.org
+           http://solid-pbx.berlios.de
 
-In addition you'll find lots of information compiled by the Asterisk
-community on this Wiki:
+In addition you'll find lots of information compiled by the community on
+this Wiki:
 
            http://www.voip-info.org/wiki-Asterisk
 
@@ -32,19 +36,19 @@
 * SUPPORTED OPERATING SYSTEMS
 
 == Linux ==
-  The Asterisk Open Source PBX is developed and tested primarily on the
+  The Solid Open Source PBX is developed and tested primarily on the
 GNU/Linux operating system, and is supported on every major GNU/Linux
 distribution.
 
 == Others ==
-  Asterisk has also been 'ported' and reportedly runs properly on other
+  Solid PBX has also been 'ported' and reportedly runs properly on other
 operating systems as well, including Sun Solaris, Apple's Mac OS X, and
 the BSD variants.
 
 * GETTING STARTED
 
   First, be sure you've got supported hardware (but note that you don't need
-ANY special hardware, not even a soundcard) to install and run Asterisk.
+ANY special hardware, not even a soundcard) to install and run Solid PBX.
 
   Supported telephony hardware includes:
 
@@ -68,8 +72,6 @@
 
   In order to discover new features to use, please check the configuration
 examples in the /configs directory of the source code distribution. 
-To discover the major new features of Asterisk 1.2, please visit 
-http://edvina.net/asterisk1-2/
 
 * NEW INSTALLATIONS
 



From casper2 at berlios.de  Sat Apr 29 05:32:43 2006
From: casper2 at berlios.de (casper2 at berlios.de)
Date: Sat, 29 Apr 2006 05:32:43 +0200
Subject: [Solid-pbx-svn] r5 - trunk
Message-ID: <200604290332.k3T3WhUB012045@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 05:32:39 +0200 (Sat, 29 Apr 2006)
New Revision: 5

Modified:
   trunk/BUGS
Log:
Update information about the bug tracker

Modified: trunk/BUGS
===================================================================
--- trunk/BUGS	2006-04-29 03:20:55 UTC (rev 4)
+++ trunk/BUGS	2006-04-29 03:32:39 UTC (rev 5)
@@ -1,10 +1,10 @@
-Asterisk Bug Tracking Information
+Solid PBX Bug Tracking Information
 =================================
 
-To learn about and report Asterisk bugs, please visit 
-the official Asterisk Bug Tracker at:
+To learn about and report Solid PBX bugs, please visit 
+the official Solid PBX Bug Tracker at:
 
-	http://bugs.digium.com
+	http://developer.berlios.de/bugs/?group_id=6533
 
 For more information on using the bug tracker, or to 
 learn how you can contribute by acting as a bug marshall
@@ -14,9 +14,9 @@
 
 If you would like to submit a feature request, please
 resist the temptation to post it to the bug tracker.
-Feature requests should be posted to the asterisk-dev
+Feature requests should be posted to the solid-pbx-dev
 mailing list, located at:
 
-	http://lists.digium.com 
+	http://lists.berlios.de
 
 Thank you!



From casper2 at berlios.de  Sat Apr 29 05:58:50 2006
From: casper2 at berlios.de (casper2 at berlios.de)
Date: Sat, 29 Apr 2006 05:58:50 +0200
Subject: [Solid-pbx-svn] r6 - trunk
Message-ID: <200604290358.k3T3wogv023016@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 05:58:47 +0200 (Sat, 29 Apr 2006)
New Revision: 6

Modified:
   trunk/Makefile
Log:


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-29 03:32:39 UTC (rev 5)
+++ trunk/Makefile	2006-04-29 03:58:47 UTC (rev 6)
@@ -990,3 +990,4 @@
 makeopts.xml: $(foreach dir,$(MOD_SUBDIRS),$(dir)/*.c) build_tools/cflags.xml
 	@echo "Generating list of available modules ..."
 	@build_tools/prep_moduledeps > $@
+



From solid-pbx-svn-admin at lists.berlios.de  Sat Apr 29 06:44:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 29 Apr 2006 06:44:31 +0200
Subject: [solid-pbx-svn] r7 - trunk
Message-ID: <200604290444.k3T4iVqC030611@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 06:44:16 +0200 (Sat, 29 Apr 2006)
New Revision: 7

Modified:
   trunk/makeopts.in
Log:


Modified: trunk/makeopts.in
===================================================================
--- trunk/makeopts.in	2006-04-29 03:58:47 UTC (rev 6)
+++ trunk/makeopts.in	2006-04-29 04:44:16 UTC (rev 7)
@@ -104,3 +104,4 @@
 
 NCURSES_LIB=@ncurses_LIB@
 NCURSES_INCLUDE=@ncurses_INCLUDE@
+



From solid-pbx-svn-admin at lists.berlios.de  Sat Apr 29 07:19:40 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 29 Apr 2006 07:19:40 +0200
Subject: [solid-pbx-svn] r8 - in trunk: channels pbx res
Message-ID: <200604290519.k3T5JeMZ013709@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 07:19:26 +0200 (Sat, 29 Apr 2006)
New Revision: 8

Modified:
   trunk/channels/chan_h323.c
   trunk/pbx/pbx_dundi.c
   trunk/res/res_clioriginate.c
   trunk/res/res_config_pgsql.c
Log:
Update to Asterisk SVN trunk r23294

Modified: trunk/channels/chan_h323.c
===================================================================
--- trunk/channels/chan_h323.c	2006-04-29 04:44:16 UTC (rev 7)
+++ trunk/channels/chan_h323.c	2006-04-29 05:19:26 UTC (rev 8)
@@ -180,10 +180,6 @@
 /** Protect the interface list (oh323_pvt) */
 AST_MUTEX_DEFINE_STATIC(iflock);
 
-/** Usage counter and associated lock */
-static int usecnt = 0;
-AST_MUTEX_DEFINE_STATIC(usecnt_lock);
-
 /* Protect the monitoring thread, so only one process can kill or start it, and not
    when it's doing something critical. */
 AST_MUTEX_DEFINE_STATIC(monlock);
@@ -534,13 +530,8 @@
 	pvt->needdestroy = 1;
 
 	/* Update usage counter */
-	ast_mutex_lock(&usecnt_lock);
-	usecnt--;
-	if (usecnt < 0) {
-		ast_log(LOG_WARNING, "Usecnt < 0\n");
-	}
-	ast_mutex_unlock(&usecnt_lock);
 	ast_mutex_unlock(&pvt->lock);
+	ast_atomic_fetchadd_int(&__mod_desc->usecnt, -1);
 	ast_update_use_count();
 	return 0;
 }
@@ -734,9 +725,7 @@
 	ast_mutex_unlock(&pvt->lock);
 	ch = ast_channel_alloc(1);
 	/* Update usage counter */
-	ast_mutex_lock(&usecnt_lock);
-	usecnt++;
-	ast_mutex_unlock(&usecnt_lock);
+	ast_atomic_fetchadd_int(&__mod_desc->usecnt, +1);
 	ast_update_use_count();
 	ast_mutex_lock(&pvt->lock);
 	if (ch) {
@@ -2237,7 +2226,7 @@
 	return 0;
 }
 
-int reload(void)
+static int reload(void *mod)
 {
 	return h323_reload(0, 0, NULL);
 }
@@ -2317,7 +2306,7 @@
 	.set_rtp_peer=  oh323_set_rtp_peer,
 };
 
-int load_module()
+static int load_module(void *mod)
 {
 	int res;
 	ast_mutex_init(&userl.lock);
@@ -2385,7 +2374,7 @@
 	return res;
 }
 
-int unload_module() 
+static int unload_module(void *mod)
 {
 	struct oh323_pvt *p, *pl;
 
@@ -2459,18 +2448,14 @@
 	return 0; 
 } 
 
-int usecount()
+static const char *description(void)
 {
-	return usecnt;
+	return desc;
 }
 
-const char *description()
+static const char *key(void)
 {
-	return (char *) desc;
-}
-
-const char *key()
-{
 	return ASTERISK_GPL_KEY;
 }
 
+STD_MOD(MOD_1, reload, NULL, NULL);

Modified: trunk/pbx/pbx_dundi.c
===================================================================
--- trunk/pbx/pbx_dundi.c	2006-04-29 04:44:16 UTC (rev 7)
+++ trunk/pbx/pbx_dundi.c	2006-04-29 05:19:26 UTC (rev 8)
@@ -559,10 +559,8 @@
 				newvariable = ast_var_assign("IPADDR", ipaddr);
 				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
 				pbx_substitute_variables_varshead(&headp, map->dest, dr[anscnt].dest, sizeof(dr[anscnt].dest));
-				while (!AST_LIST_EMPTY(&headp)) {           /* List Deletion. */
-					newvariable = AST_LIST_REMOVE_HEAD(&headp, entries);
+				while ((newvariable = AST_LIST_REMOVE_HEAD(&headp, entries)))
 					ast_var_delete(newvariable);
-				}
 			} else
 				dr[anscnt].dest[0] = '\0';
 			anscnt++;

Modified: trunk/res/res_clioriginate.c
===================================================================
--- trunk/res/res_clioriginate.c	2006-04-29 04:44:16 UTC (rev 7)
+++ trunk/res/res_clioriginate.c	2006-04-29 05:19:26 UTC (rev 8)
@@ -1,7 +1,7 @@
 /*
  * Asterisk -- An open source telephony toolkit.
  *
- * Copyright (C) 2005, Digium, Inc.
+ * Copyright (C) 2005 - 2006, Digium, Inc.
  *
  * Russell Bryant <russell at digium.com>
  *
@@ -18,6 +18,7 @@
 
 /*! 
  * \file
+ * \author Russell Bryant <russell at digium.com>
  *
  * \brief Originate calls via the CLI
  * 
@@ -66,7 +67,7 @@
 
 struct ast_cli_entry cli_orig = { { "originate", NULL }, handle_orig, "Originate a call", orig_help, complete_orig };
 
-static int orig_app(const char *chan, const char *app, const char *appdata)
+static int orig_app(int fd, const char *chan, const char *app, const char *appdata)
 {
 	char *chantech;
 	char *chandata;
@@ -75,14 +76,12 @@
 	if (ast_strlen_zero(app))
 		return RESULT_SHOWUSAGE;
 
-	chandata = ast_strdupa(chan);
-	if (!chandata) {
-		ast_log(LOG_ERROR, "Out of Memory!\n");
+	if (!(chandata = ast_strdupa(chan)))
 		return RESULT_FAILURE;
-	}
+	
 	chantech = strsep(&chandata, "/");
 	if (!chandata) {
-		ast_log(LOG_ERROR, "No dial string.\n");
+		ast_cli(fd, "*** No data provided after channel type! ***\n");
 		return RESULT_SHOWUSAGE;
 	}
 
@@ -91,7 +90,7 @@
 	return RESULT_SUCCESS;
 }
 
-static int orig_exten(const char *chan, const char *data)
+static int orig_exten(int fd, const char *chan, const char *data)
 {
 	char *chantech;
 	char *chandata;
@@ -99,19 +98,18 @@
 	char *context = NULL;
 	int reason = 0;
 
-	chandata = ast_strdupa(chan);
-	if (!chandata) {
-		ast_log(LOG_ERROR, "Out of Memory!\n");
+	if (!(chandata = ast_strdupa(chan)))
 		return RESULT_FAILURE;
-	}
+	
 	chantech = strsep(&chandata, "/");
+	if (!chandata) {
+		ast_cli(fd, "*** No data provided after channel type! ***\n");
+		return RESULT_SHOWUSAGE;
+	}
 
 	if (!ast_strlen_zero(data)) {
-		context = ast_strdupa(data);
-		if (!context) {
-			ast_log(LOG_ERROR, "Out of Memory!\n");
+		if (!(context = ast_strdupa(data)))
 			return RESULT_FAILURE;
-		}
 		exten = strsep(&context, "@");
 	}
 
@@ -135,9 +133,9 @@
 	ast_atomic_fetchadd_int(&me->usecnt, +1);
 
 	if (!strcasecmp("application", argv[2])) {
-		res = orig_app(argv[1], argv[3], argv[4]);	
+		res = orig_app(fd, argv[1], argv[3], argv[4]);	
 	} else if (!strcasecmp("extension", argv[2])) {
-		res = orig_exten(argv[1], argv[3]);
+		res = orig_exten(fd, argv[1], argv[3]);
 	} else
 		res = RESULT_SHOWUSAGE;
 

Modified: trunk/res/res_config_pgsql.c
===================================================================
--- trunk/res/res_config_pgsql.c	2006-04-29 04:44:16 UTC (rev 7)
+++ trunk/res/res_config_pgsql.c	2006-04-29 05:19:26 UTC (rev 8)
@@ -718,7 +718,7 @@
 	return ASTERISK_GPL_KEY;
 }
 
-STD_MOD(MOD_0, NULL, NULL, NULL);
+STD_MOD(MOD_0, reload, NULL, NULL);
 
 static int pgsql_reconnect(const char *database)
 {



From solid-pbx-svn-admin at lists.berlios.de  Sat Apr 29 08:51:18 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 29 Apr 2006 08:51:18 +0200
Subject: [solid-pbx-svn] r9 - in trunk: channels pbx res
Message-ID: <200604290651.k3T6pIir014893@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 08:51:12 +0200 (Sat, 29 Apr 2006)
New Revision: 9

Modified:
   trunk/channels/chan_h323.c
   trunk/pbx/pbx_dundi.c
   trunk/res/res_clioriginate.c
   trunk/res/res_config_pgsql.c
Log:
Revert r8 commit

Modified: trunk/channels/chan_h323.c
===================================================================
--- trunk/channels/chan_h323.c	2006-04-29 05:19:26 UTC (rev 8)
+++ trunk/channels/chan_h323.c	2006-04-29 06:51:12 UTC (rev 9)
@@ -180,6 +180,10 @@
 /** Protect the interface list (oh323_pvt) */
 AST_MUTEX_DEFINE_STATIC(iflock);
 
+/** Usage counter and associated lock */
+static int usecnt = 0;
+AST_MUTEX_DEFINE_STATIC(usecnt_lock);
+
 /* Protect the monitoring thread, so only one process can kill or start it, and not
    when it's doing something critical. */
 AST_MUTEX_DEFINE_STATIC(monlock);
@@ -530,8 +534,13 @@
 	pvt->needdestroy = 1;
 
 	/* Update usage counter */
+	ast_mutex_lock(&usecnt_lock);
+	usecnt--;
+	if (usecnt < 0) {
+		ast_log(LOG_WARNING, "Usecnt < 0\n");
+	}
+	ast_mutex_unlock(&usecnt_lock);
 	ast_mutex_unlock(&pvt->lock);
-	ast_atomic_fetchadd_int(&__mod_desc->usecnt, -1);
 	ast_update_use_count();
 	return 0;
 }
@@ -725,7 +734,9 @@
 	ast_mutex_unlock(&pvt->lock);
 	ch = ast_channel_alloc(1);
 	/* Update usage counter */
-	ast_atomic_fetchadd_int(&__mod_desc->usecnt, +1);
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
 	ast_update_use_count();
 	ast_mutex_lock(&pvt->lock);
 	if (ch) {
@@ -2226,7 +2237,7 @@
 	return 0;
 }
 
-static int reload(void *mod)
+int reload(void)
 {
 	return h323_reload(0, 0, NULL);
 }
@@ -2306,7 +2317,7 @@
 	.set_rtp_peer=  oh323_set_rtp_peer,
 };
 
-static int load_module(void *mod)
+int load_module()
 {
 	int res;
 	ast_mutex_init(&userl.lock);
@@ -2374,7 +2385,7 @@
 	return res;
 }
 
-static int unload_module(void *mod)
+int unload_module() 
 {
 	struct oh323_pvt *p, *pl;
 
@@ -2448,14 +2459,18 @@
 	return 0; 
 } 
 
-static const char *description(void)
+int usecount()
 {
-	return desc;
+	return usecnt;
 }
 
-static const char *key(void)
+const char *description()
 {
+	return (char *) desc;
+}
+
+const char *key()
+{
 	return ASTERISK_GPL_KEY;
 }
 
-STD_MOD(MOD_1, reload, NULL, NULL);

Modified: trunk/pbx/pbx_dundi.c
===================================================================
--- trunk/pbx/pbx_dundi.c	2006-04-29 05:19:26 UTC (rev 8)
+++ trunk/pbx/pbx_dundi.c	2006-04-29 06:51:12 UTC (rev 9)
@@ -559,8 +559,10 @@
 				newvariable = ast_var_assign("IPADDR", ipaddr);
 				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
 				pbx_substitute_variables_varshead(&headp, map->dest, dr[anscnt].dest, sizeof(dr[anscnt].dest));
-				while ((newvariable = AST_LIST_REMOVE_HEAD(&headp, entries)))
+				while (!AST_LIST_EMPTY(&headp)) {           /* List Deletion. */
+					newvariable = AST_LIST_REMOVE_HEAD(&headp, entries);
 					ast_var_delete(newvariable);
+				}
 			} else
 				dr[anscnt].dest[0] = '\0';
 			anscnt++;

Modified: trunk/res/res_clioriginate.c
===================================================================
--- trunk/res/res_clioriginate.c	2006-04-29 05:19:26 UTC (rev 8)
+++ trunk/res/res_clioriginate.c	2006-04-29 06:51:12 UTC (rev 9)
@@ -1,7 +1,7 @@
 /*
  * Asterisk -- An open source telephony toolkit.
  *
- * Copyright (C) 2005 - 2006, Digium, Inc.
+ * Copyright (C) 2005, Digium, Inc.
  *
  * Russell Bryant <russell at digium.com>
  *
@@ -18,7 +18,6 @@
 
 /*! 
  * \file
- * \author Russell Bryant <russell at digium.com>
  *
  * \brief Originate calls via the CLI
  * 
@@ -67,7 +66,7 @@
 
 struct ast_cli_entry cli_orig = { { "originate", NULL }, handle_orig, "Originate a call", orig_help, complete_orig };
 
-static int orig_app(int fd, const char *chan, const char *app, const char *appdata)
+static int orig_app(const char *chan, const char *app, const char *appdata)
 {
 	char *chantech;
 	char *chandata;
@@ -76,12 +75,14 @@
 	if (ast_strlen_zero(app))
 		return RESULT_SHOWUSAGE;
 
-	if (!(chandata = ast_strdupa(chan)))
+	chandata = ast_strdupa(chan);
+	if (!chandata) {
+		ast_log(LOG_ERROR, "Out of Memory!\n");
 		return RESULT_FAILURE;
-	
+	}
 	chantech = strsep(&chandata, "/");
 	if (!chandata) {
-		ast_cli(fd, "*** No data provided after channel type! ***\n");
+		ast_log(LOG_ERROR, "No dial string.\n");
 		return RESULT_SHOWUSAGE;
 	}
 
@@ -90,7 +91,7 @@
 	return RESULT_SUCCESS;
 }
 
-static int orig_exten(int fd, const char *chan, const char *data)
+static int orig_exten(const char *chan, const char *data)
 {
 	char *chantech;
 	char *chandata;
@@ -98,18 +99,19 @@
 	char *context = NULL;
 	int reason = 0;
 
-	if (!(chandata = ast_strdupa(chan)))
+	chandata = ast_strdupa(chan);
+	if (!chandata) {
+		ast_log(LOG_ERROR, "Out of Memory!\n");
 		return RESULT_FAILURE;
-	
+	}
 	chantech = strsep(&chandata, "/");
-	if (!chandata) {
-		ast_cli(fd, "*** No data provided after channel type! ***\n");
-		return RESULT_SHOWUSAGE;
-	}
 
 	if (!ast_strlen_zero(data)) {
-		if (!(context = ast_strdupa(data)))
+		context = ast_strdupa(data);
+		if (!context) {
+			ast_log(LOG_ERROR, "Out of Memory!\n");
 			return RESULT_FAILURE;
+		}
 		exten = strsep(&context, "@");
 	}
 
@@ -133,9 +135,9 @@
 	ast_atomic_fetchadd_int(&me->usecnt, +1);
 
 	if (!strcasecmp("application", argv[2])) {
-		res = orig_app(fd, argv[1], argv[3], argv[4]);	
+		res = orig_app(argv[1], argv[3], argv[4]);	
 	} else if (!strcasecmp("extension", argv[2])) {
-		res = orig_exten(fd, argv[1], argv[3]);
+		res = orig_exten(argv[1], argv[3]);
 	} else
 		res = RESULT_SHOWUSAGE;
 

Modified: trunk/res/res_config_pgsql.c
===================================================================
--- trunk/res/res_config_pgsql.c	2006-04-29 05:19:26 UTC (rev 8)
+++ trunk/res/res_config_pgsql.c	2006-04-29 06:51:12 UTC (rev 9)
@@ -718,7 +718,7 @@
 	return ASTERISK_GPL_KEY;
 }
 
-STD_MOD(MOD_0, reload, NULL, NULL);
+STD_MOD(MOD_0, NULL, NULL, NULL);
 
 static int pgsql_reconnect(const char *database)
 {



From solid-pbx-svn-admin at lists.berlios.de  Sat Apr 29 09:44:24 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 29 Apr 2006 09:44:24 +0200
Subject: [solid-pbx-svn] r10 - in trunk: channels pbx res
Message-ID: <200604290744.k3T7iO1S032652@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 09:44:17 +0200 (Sat, 29 Apr 2006)
New Revision: 10

Modified:
   trunk/channels/chan_h323.c
   trunk/pbx/pbx_dundi.c
   trunk/res/res_clioriginate.c
   trunk/res/res_config_pgsql.c
Log:
------------------------------------------------------------------------
r23271 | russell | 2006-04-29 06:13:07 +0200 (Sat, 29 Apr 2006) | 2 lines

add a small optimization for deleting all the members of a list

------------------------------------------------------------------------
r23272 | rizzo | 2006-04-29 06:54:05 +0200 (Sat, 29 Apr 2006) | 5 lines

partial adaptation to the new module loading
(not sure if it compiles, partly inspired by #9981 but
with adaptations)


------------------------------------------------------------------------
r23273 | rizzo | 2006-04-29 06:55:47 +0200 (Sat, 29 Apr 2006) | 3 lines

add reload() (bug 9981)


------------------------------------------------------------------------
r23284 | russell | 2006-04-29 07:02:17 +0200 (Sat, 29 Apr 2006) | 5 lines

- don't create duplicate log messages
- note when the data part of the tech/data pair is missing not only when using
  the app version, but the exten version as well
- instead of logging syntax errors, just output them to the CLI

------------------------------------------------------------------------


Modified: trunk/channels/chan_h323.c
===================================================================
--- trunk/channels/chan_h323.c	2006-04-29 06:51:12 UTC (rev 9)
+++ trunk/channels/chan_h323.c	2006-04-29 07:44:17 UTC (rev 10)
@@ -180,10 +180,6 @@
 /** Protect the interface list (oh323_pvt) */
 AST_MUTEX_DEFINE_STATIC(iflock);
 
-/** Usage counter and associated lock */
-static int usecnt = 0;
-AST_MUTEX_DEFINE_STATIC(usecnt_lock);
-
 /* Protect the monitoring thread, so only one process can kill or start it, and not
    when it's doing something critical. */
 AST_MUTEX_DEFINE_STATIC(monlock);
@@ -534,13 +530,8 @@
 	pvt->needdestroy = 1;
 
 	/* Update usage counter */
-	ast_mutex_lock(&usecnt_lock);
-	usecnt--;
-	if (usecnt < 0) {
-		ast_log(LOG_WARNING, "Usecnt < 0\n");
-	}
-	ast_mutex_unlock(&usecnt_lock);
 	ast_mutex_unlock(&pvt->lock);
+	ast_atomic_fetchadd_int(&__mod_desc->usecnt, -1);
 	ast_update_use_count();
 	return 0;
 }
@@ -734,9 +725,7 @@
 	ast_mutex_unlock(&pvt->lock);
 	ch = ast_channel_alloc(1);
 	/* Update usage counter */
-	ast_mutex_lock(&usecnt_lock);
-	usecnt++;
-	ast_mutex_unlock(&usecnt_lock);
+	ast_atomic_fetchadd_int(&__mod_desc->usecnt, +1);
 	ast_update_use_count();
 	ast_mutex_lock(&pvt->lock);
 	if (ch) {
@@ -2237,7 +2226,7 @@
 	return 0;
 }
 
-int reload(void)
+static int reload(void *mod)
 {
 	return h323_reload(0, 0, NULL);
 }
@@ -2317,7 +2306,7 @@
 	.set_rtp_peer=  oh323_set_rtp_peer,
 };
 
-int load_module()
+static int load_module(void *mod)
 {
 	int res;
 	ast_mutex_init(&userl.lock);
@@ -2385,7 +2374,7 @@
 	return res;
 }
 
-int unload_module() 
+static int unload_module(void *mod)
 {
 	struct oh323_pvt *p, *pl;
 
@@ -2459,18 +2448,14 @@
 	return 0; 
 } 
 
-int usecount()
+static const char *description(void)
 {
-	return usecnt;
+	return desc;
 }
 
-const char *description()
+static const char *key(void)
 {
-	return (char *) desc;
-}
-
-const char *key()
-{
 	return ASTERISK_GPL_KEY;
 }
 
+STD_MOD(MOD_1, reload, NULL, NULL);

Modified: trunk/pbx/pbx_dundi.c
===================================================================
--- trunk/pbx/pbx_dundi.c	2006-04-29 06:51:12 UTC (rev 9)
+++ trunk/pbx/pbx_dundi.c	2006-04-29 07:44:17 UTC (rev 10)
@@ -559,10 +559,8 @@
 				newvariable = ast_var_assign("IPADDR", ipaddr);
 				AST_LIST_INSERT_HEAD(&headp, newvariable, entries);
 				pbx_substitute_variables_varshead(&headp, map->dest, dr[anscnt].dest, sizeof(dr[anscnt].dest));
-				while (!AST_LIST_EMPTY(&headp)) {           /* List Deletion. */
-					newvariable = AST_LIST_REMOVE_HEAD(&headp, entries);
+				while ((newvariable = AST_LIST_REMOVE_HEAD(&headp, entries)))
 					ast_var_delete(newvariable);
-				}
 			} else
 				dr[anscnt].dest[0] = '\0';
 			anscnt++;

Modified: trunk/res/res_clioriginate.c
===================================================================
--- trunk/res/res_clioriginate.c	2006-04-29 06:51:12 UTC (rev 9)
+++ trunk/res/res_clioriginate.c	2006-04-29 07:44:17 UTC (rev 10)
@@ -1,7 +1,7 @@
 /*
  * Asterisk -- An open source telephony toolkit.
  *
- * Copyright (C) 2005, Digium, Inc.
+ * Copyright (C) 2005 - 2006, Digium, Inc.
  *
  * Russell Bryant <russell at digium.com>
  *
@@ -18,6 +18,7 @@
 
 /*! 
  * \file
+ * \author Russell Bryant <russell at digium.com>
  *
  * \brief Originate calls via the CLI
  * 
@@ -66,7 +67,7 @@
 
 struct ast_cli_entry cli_orig = { { "originate", NULL }, handle_orig, "Originate a call", orig_help, complete_orig };
 
-static int orig_app(const char *chan, const char *app, const char *appdata)
+static int orig_app(int fd, const char *chan, const char *app, const char *appdata)
 {
 	char *chantech;
 	char *chandata;
@@ -75,14 +76,12 @@
 	if (ast_strlen_zero(app))
 		return RESULT_SHOWUSAGE;
 
-	chandata = ast_strdupa(chan);
-	if (!chandata) {
-		ast_log(LOG_ERROR, "Out of Memory!\n");
+	if (!(chandata = ast_strdupa(chan)))
 		return RESULT_FAILURE;
-	}
+	
 	chantech = strsep(&chandata, "/");
 	if (!chandata) {
-		ast_log(LOG_ERROR, "No dial string.\n");
+		ast_cli(fd, "*** No data provided after channel type! ***\n");
 		return RESULT_SHOWUSAGE;
 	}
 
@@ -91,7 +90,7 @@
 	return RESULT_SUCCESS;
 }
 
-static int orig_exten(const char *chan, const char *data)
+static int orig_exten(int fd, const char *chan, const char *data)
 {
 	char *chantech;
 	char *chandata;
@@ -99,19 +98,18 @@
 	char *context = NULL;
 	int reason = 0;
 
-	chandata = ast_strdupa(chan);
-	if (!chandata) {
-		ast_log(LOG_ERROR, "Out of Memory!\n");
+	if (!(chandata = ast_strdupa(chan)))
 		return RESULT_FAILURE;
-	}
+	
 	chantech = strsep(&chandata, "/");
+	if (!chandata) {
+		ast_cli(fd, "*** No data provided after channel type! ***\n");
+		return RESULT_SHOWUSAGE;
+	}
 
 	if (!ast_strlen_zero(data)) {
-		context = ast_strdupa(data);
-		if (!context) {
-			ast_log(LOG_ERROR, "Out of Memory!\n");
+		if (!(context = ast_strdupa(data)))
 			return RESULT_FAILURE;
-		}
 		exten = strsep(&context, "@");
 	}
 
@@ -135,9 +133,9 @@
 	ast_atomic_fetchadd_int(&me->usecnt, +1);
 
 	if (!strcasecmp("application", argv[2])) {
-		res = orig_app(argv[1], argv[3], argv[4]);	
+		res = orig_app(fd, argv[1], argv[3], argv[4]);	
 	} else if (!strcasecmp("extension", argv[2])) {
-		res = orig_exten(argv[1], argv[3]);
+		res = orig_exten(fd, argv[1], argv[3]);
 	} else
 		res = RESULT_SHOWUSAGE;
 

Modified: trunk/res/res_config_pgsql.c
===================================================================
--- trunk/res/res_config_pgsql.c	2006-04-29 06:51:12 UTC (rev 9)
+++ trunk/res/res_config_pgsql.c	2006-04-29 07:44:17 UTC (rev 10)
@@ -718,7 +718,7 @@
 	return ASTERISK_GPL_KEY;
 }
 
-STD_MOD(MOD_0, NULL, NULL, NULL);
+STD_MOD(MOD_0, reload, NULL, NULL);
 
 static int pgsql_reconnect(const char *database)
 {



From solid-pbx-svn-admin at lists.berlios.de  Sat Apr 29 14:34:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 29 Apr 2006 14:34:31 +0200
Subject: [solid-pbx-svn] r11 - trunk
Message-ID: <200604291234.k3TCYV8a014002@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 14:33:55 +0200 (Sat, 29 Apr 2006)
New Revision: 11

Modified:
   trunk/Makefile
Log:
Update to Asterisk SVN trunk r23333
------------------------------------------------------------------------
r23306 | kpfleming | 2006-04-29 13:42:31 +0200 (Sat, 29 Apr 2006) | 11 lines

Merged revisions 23305 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r23305 | kpfleming | 2006-04-29 06:40:04 -0500 (Sat, 29 Apr 2006) | 3 lines

do installation in subdirs as a separate target (so external modules can use the Makefile more easily)
generate final messages -after- running any post-install script that may be present

.......

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-29 07:44:17 UTC (rev 10)
+++ trunk/Makefile	2006-04-29 12:33:55 UTC (rev 11)
@@ -683,7 +683,6 @@
 		cat contrib/scripts/safe_asterisk | sed 's|__ASTERISK_SBIN_DIR__|$(ASTSBINDIR)|;' > $(DESTDIR)$(ASTSBINDIR)/safe_asterisk ;\
 		chmod 755 $(DESTDIR)$(ASTSBINDIR)/safe_asterisk;\
 	fi
-	for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
 	$(INSTALL) -d $(DESTDIR)$(ASTHEADERDIR)
 	$(INSTALL) -m 644 include/asterisk/*.h $(DESTDIR)$(ASTHEADERDIR)
 	if [ -n "$(OLDHEADERS)" ]; then \
@@ -708,29 +707,10 @@
 		echo "You need to do cvs update -d not just cvs update" ; \
 	fi 
 	if [ -f mpg123-0.59r/mpg123 ]; then $(MAKE) -C mpg123-0.59r install; fi
-	@echo " +---- Asterisk Installation Complete -------+"  
-	@echo " +                                           +"
-	@echo " +    YOU MUST READ THE SECURITY DOCUMENT    +"
-	@echo " +                                           +"
-	@echo " + Asterisk has successfully been installed. +"  
-	@echo " + If you would like to install the sample   +"  
-	@echo " + configuration files (overwriting any      +"
-	@echo " + existing config files), run:              +"  
-	@echo " +                                           +"
-	@echo " +               $(MAKE) samples                +"
-	@echo " +                                           +"
-	@echo " +-----------------  or ---------------------+"
-	@echo " +                                           +"
-	@echo " + You can go ahead and install the asterisk +"
-	@echo " + program documentation now or later run:   +"
-	@echo " +                                           +"
-	@echo " +              $(MAKE) progdocs                +"
-	@echo " +                                           +"
-	@echo " + **Note** This requires that you have      +"
-	@echo " + doxygen installed on your local system    +"
-	@echo " +-------------------------------------------+"
-	@$(MAKE) -s oldmodcheck
 
+install-subdirs:
+	for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
+
 NEWMODS=$(notdir $(wildcard */*.so))
 OLDMODS=$(filter-out $(NEWMODS),$(notdir $(wildcard $(DESTDIR)$(MODULES_DIR)/*.so)))
 
@@ -752,10 +732,32 @@
 		echo " WARNING WARNING WARNING" ;\
 	fi
 
-install: all datafiles bininstall
+install: all datafiles bininstall install-subdirs
 	@if [ -x /usr/sbin/asterisk-post-install ]; then \
 		/usr/sbin/asterisk-post-install $(DESTDIR) . ; \
 	fi
+	@echo " +---- Asterisk Installation Complete -------+"  
+	@echo " +                                           +"
+	@echo " +    YOU MUST READ THE SECURITY DOCUMENT    +"
+	@echo " +                                           +"
+	@echo " + Asterisk has successfully been installed. +"  
+	@echo " + If you would like to install the sample   +"  
+	@echo " + configuration files (overwriting any      +"
+	@echo " + existing config files), run:              +"  
+	@echo " +                                           +"
+	@echo " +               $(MAKE) samples                +"
+	@echo " +                                           +"
+	@echo " +-----------------  or ---------------------+"
+	@echo " +                                           +"
+	@echo " + You can go ahead and install the asterisk +"
+	@echo " + program documentation now or later run:   +"
+	@echo " +                                           +"
+	@echo " +              $(MAKE) progdocs                +"
+	@echo " +                                           +"
+	@echo " + **Note** This requires that you have      +"
+	@echo " + doxygen installed on your local system    +"
+	@echo " +-------------------------------------------+"
+	@$(MAKE) -s oldmodcheck
 
 upgrade: all bininstall
 



From solid-pbx-svn-admin at lists.berlios.de  Sat Apr 29 16:18:07 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 29 Apr 2006 16:18:07 +0200
Subject: [solid-pbx-svn] r12 - in trunk: . res
Message-ID: <200604291418.k3TEI7Nu010421@sheep.berlios.de>

Author: casper2
Date: 2006-04-29 16:18:03 +0200 (Sat, 29 Apr 2006)
New Revision: 12

Modified:
   trunk/acinclude.m4
   trunk/res/res_musiconhold.c
Log:
Update to Asterisk SVN trunk r23353
------------------------------------------------------------------------
r23334 | russell | 2006-04-29 15:15:05 +0200 (Sat, 29 Apr 2006) | 6 lines

- convert lists to use linked list macros
- instead of allocating a frame on the stack every time the music on hold
  generator is called, put a frame in the mohdata structure.  Also, initialize
  the parts of the frame that will never change when the mohdata struct is
  allocatted and only change the necessary parts in the generator function.

------------------------------------------------------------------------
r23335 | russell | 2006-04-29 15:32:38 +0200 (Sat, 29 Apr 2006) | 3 lines

if the "action-if-found" is left empty, AC_CHECK_LIB will add a default result
instead which can break things in the rest of the script (issue #7043)

------------------------------------------------------------------------


Modified: trunk/acinclude.m4
===================================================================
--- trunk/acinclude.m4	2006-04-29 12:33:55 UTC (rev 11)
+++ trunk/acinclude.m4	2006-04-29 14:18:03 UTC (rev 12)
@@ -20,7 +20,7 @@
 PBX_LIB$1=0
 
 if test "${USE_$1}" != "no"; then	
-   AC_CHECK_LIB([$1], [$2], [], [], -L${$1_DIR}/lib $6)
+   AC_CHECK_LIB([$1], [$2], [:], [], -L${$1_DIR}/lib $6)
 
    if test "${ac_cv_lib_$1_$2}" = "yes"; then
       $1_LIB="-l$1 $6"

Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-04-29 12:33:55 UTC (rev 11)
+++ trunk/res/res_musiconhold.c	2006-04-29 14:18:03 UTC (rev 12)
@@ -70,6 +70,7 @@
 #include "asterisk/utils.h"
 #include "asterisk/cli.h"
 #include "asterisk/stringfields.h"
+#include "asterisk/linkedlists.h"
 
 #define MAX_MOHFILES 512
 #define MAX_MOHFILE_LEN 128
@@ -139,25 +140,24 @@
 	int pid;		/* PID of mpg123 */
 	time_t start;
 	pthread_t thread;
-	struct mohdata *members;
 	/* Source of audio */
 	int srcfd;
 	/* FD for timing source */
 	int pseudofd;
-	struct mohclass *next;
+	AST_LIST_HEAD_NOLOCK(, mohdata) members;
+	AST_LIST_ENTRY(mohclass) list;
 };
 
 struct mohdata {
 	int pipe[2];
 	int origwfmt;
 	struct mohclass *parent;
-	struct mohdata *next;
+	struct ast_frame f;
+	AST_LIST_ENTRY(mohdata) list;
 };
 
-static struct mohclass *mohclasses;
+AST_LIST_HEAD_STATIC(mohclasses, mohclass);
 
-AST_MUTEX_DEFINE_STATIC(moh_lock);
-
 #define LOCAL_MPG_123 "/usr/local/bin/mpg123"
 #define MPG_123 "/usr/bin/mpg123"
 #define MAX_MP3S 256
@@ -165,18 +165,16 @@
 
 static void ast_moh_free_class(struct mohclass **class) 
 {
-	struct mohdata *members, *mtmp;
+	struct mohdata *member;
 	
-	members = (*class)->members;
-	while(members) {
-		mtmp = members;
-		members = members->next;
-		free(mtmp);
-	}
+	while ((member = AST_LIST_REMOVE_HEAD(&((*class)->members), list)))
+		free(member);
+	
 	if ((*class)->thread) {
 		pthread_cancel((*class)->thread);
 		(*class)->thread = 0;
 	}
+
 	free(*class);
 	*class = NULL;
 }
@@ -515,7 +513,7 @@
 			}
 			res = 8 * MOH_MS_INTERVAL;	/* 8 samples per millisecond */
 		}
-		if (!class->members)
+		if (AST_LIST_EMPTY(&class->members))
 			continue;
 		/* Read mp3 audio */
 		len = ast_codec_get_len(class->format, res);
@@ -538,16 +536,15 @@
 			continue;
 		}
 		pthread_testcancel();
-		ast_mutex_lock(&moh_lock);
-		moh = class->members;
-		while (moh) {
+		AST_LIST_LOCK(&mohclasses);
+		AST_LIST_TRAVERSE(&class->members, moh, list) {
 			/* Write data */
-			if ((res = write(moh->pipe[1], sbuf, res2)) != res2) 
+			if ((res = write(moh->pipe[1], sbuf, res2)) != res2) {
 				if (option_debug)
 					ast_log(LOG_DEBUG, "Only wrote %d of %d bytes to pipe\n", res, res2);
-			moh = moh->next;
+			}
 		}
-		ast_mutex_unlock(&moh_lock);
+		AST_LIST_UNLOCK(&mohclasses);
 	}
 	return NULL;
 }
@@ -607,60 +604,58 @@
 	return 0;
 }
 
+/*! \note This function should be called with the mohclasses list locked */
 static struct mohclass *get_mohbyname(const char *name)
 {
-	struct mohclass *moh;
-	moh = mohclasses;
-	while (moh) {
+	struct mohclass *moh = NULL;
+
+	AST_LIST_TRAVERSE(&mohclasses, moh, list) {
 		if (!strcasecmp(name, moh->name))
-			return moh;
-		moh = moh->next;
+			break;
 	}
-	return NULL;
+
+	return moh;
 }
 
 static struct mohdata *mohalloc(struct mohclass *cl)
 {
 	struct mohdata *moh;
 	long flags;	
+	
 	if (!(moh = ast_calloc(1, sizeof(*moh))))
 		return NULL;
+	
 	if (pipe(moh->pipe)) {
 		ast_log(LOG_WARNING, "Failed to create pipe: %s\n", strerror(errno));
 		free(moh);
 		return NULL;
 	}
+
 	/* Make entirely non-blocking */
 	flags = fcntl(moh->pipe[0], F_GETFL);
 	fcntl(moh->pipe[0], F_SETFL, flags | O_NONBLOCK);
 	flags = fcntl(moh->pipe[1], F_GETFL);
 	fcntl(moh->pipe[1], F_SETFL, flags | O_NONBLOCK);
+
+	moh->f.frametype = AST_FRAME_VOICE;
+	moh->f.subclass = cl->format;
+	moh->f.offset = AST_FRIENDLY_OFFSET;
+
 	moh->parent = cl;
-	moh->next = cl->members;
-	cl->members = moh;
+	AST_LIST_INSERT_HEAD(&cl->members, moh, list);
+	
 	return moh;
 }
 
 static void moh_release(struct ast_channel *chan, void *data)
 {
-	struct mohdata *moh = data, *prev, *cur;
+	struct mohdata *moh = data;
 	int oldwfmt;
-	ast_mutex_lock(&moh_lock);
-	/* Unlink */
-	prev = NULL;
-	cur = moh->parent->members;
-	while (cur) {
-		if (cur == moh) {
-			if (prev)
-				prev->next = cur->next;
-			else
-				moh->parent->members = cur->next;
-			break;
-		}
-		prev = cur;
-		cur = cur->next;
-	}
-	ast_mutex_unlock(&moh_lock);
+
+	AST_LIST_LOCK(&mohclasses);
+	AST_LIST_REMOVE(&moh->parent->members, moh, list);	
+	AST_LIST_UNLOCK(&mohclasses);
+	
 	close(moh->pipe[0]);
 	close(moh->pipe[1]);
 	oldwfmt = moh->origwfmt;
@@ -693,7 +688,6 @@
 
 static int moh_generate(struct ast_channel *chan, void *data, int len, int samples)
 {
-	struct ast_frame f;
 	struct mohdata *moh = data;
 	short buf[1280 + AST_FRIENDLY_OFFSET / 2];
 	int res;
@@ -708,25 +702,14 @@
 		len = sizeof(buf) - AST_FRIENDLY_OFFSET;
 	}
 	res = read(moh->pipe[0], buf + AST_FRIENDLY_OFFSET/2, len);
-#if 0
-	if (res != len) {
-		ast_log(LOG_WARNING, "Read only %d of %d bytes: %s\n", res, len, strerror(errno));
-	}
-#endif
 	if (res <= 0)
 		return 0;
 
-	memset(&f, 0, sizeof(f));
-	
-	f.frametype = AST_FRAME_VOICE;
-	f.subclass = moh->parent->format;
-	f.mallocd = 0;
-	f.datalen = res;
-	f.data = buf + AST_FRIENDLY_OFFSET / 2;
-	f.offset = AST_FRIENDLY_OFFSET;
-	f.samples = ast_codec_get_samples(&f);
+	moh->f.datalen = res;
+	moh->f.data = buf + AST_FRIENDLY_OFFSET / 2;
+	moh->f.samples = ast_codec_get_samples(&moh->f);
 
-	if (ast_write(chan, &f) < 0) {
+	if (ast_write(chan, &moh->f) < 0) {
 		ast_log(LOG_WARNING, "Failed to write frame to '%s': %s\n", chan->name, strerror(errno));
 		return -1;
 	}
@@ -804,7 +787,7 @@
 #ifdef HAVE_ZAPTEL
 	int x;
 #endif
-	ast_mutex_lock(&moh_lock);
+	AST_LIST_LOCK(&mohclasses);
 	if (get_mohbyname(moh->name)) {
 		if (reload) {
 			ast_log(LOG_DEBUG, "Music on Hold class '%s' left alone from initial load.\n", moh->name);
@@ -812,10 +795,10 @@
 			ast_log(LOG_WARNING, "Music on Hold class '%s' already exists\n", moh->name);
 		}
 		free(moh);	
-		ast_mutex_unlock(&moh_lock);
+		AST_LIST_UNLOCK(&mohclasses);
 		return -1;
 	}
-	ast_mutex_unlock(&moh_lock);
+	AST_LIST_UNLOCK(&mohclasses);
 
 	time(&moh->start);
 	moh->start -= respawn_time;
@@ -864,10 +847,11 @@
 		ast_moh_free_class(&moh);
 		return -1;
 	}
-	ast_mutex_lock(&moh_lock);
-	moh->next = mohclasses;
-	mohclasses = moh;
-	ast_mutex_unlock(&moh_lock);
+
+	AST_LIST_LOCK(&mohclasses);
+	AST_LIST_INSERT_HEAD(&mohclasses, moh, list);
+	AST_LIST_UNLOCK(&mohclasses);
+	
 	return 0;
 }
 
@@ -887,9 +871,9 @@
 		class = chan->musicclass;
 	if (ast_strlen_zero(class))
 		class = "default";
-	ast_mutex_lock(&moh_lock);
+	AST_LIST_LOCK(&mohclasses);
 	mohclass = get_mohbyname(class);
-	ast_mutex_unlock(&moh_lock);
+	AST_LIST_UNLOCK(&mohclasses);
 
 	if (!mohclass) {
 		ast_log(LOG_WARNING, "No class: %s\n", (char *)class);
@@ -1060,16 +1044,15 @@
 
 static void ast_moh_destroy(void)
 {
-	struct mohclass *moh, *tmp;
+	struct mohclass *moh;
 	char buff[8192];
-	int bytes, tbytes=0, stime = 0, pid = 0;
+	int bytes, tbytes = 0, stime = 0, pid = 0;
 
 	if (option_verbose > 1)
 		ast_verbose(VERBOSE_PREFIX_2 "Destroying musiconhold processes\n");
-	ast_mutex_lock(&moh_lock);
-	moh = mohclasses;
 
-	while (moh) {
+	AST_LIST_LOCK(&mohclasses);
+	while ((moh = AST_LIST_REMOVE_HEAD(&mohclasses, list))) {
 		if (moh->pid) {
 			ast_log(LOG_DEBUG, "killing %d!\n", moh->pid);
 			stime = time(NULL) + 2;
@@ -1083,18 +1066,14 @@
 			kill(pid, SIGTERM);
 			usleep(100000);
 			kill(pid, SIGKILL);
-			while ((ast_wait_for_input(moh->srcfd, 100) > 0) && (bytes = read(moh->srcfd, buff, 8192)) && time(NULL) < stime) {
+			while ((ast_wait_for_input(moh->srcfd, 100) > 0) && (bytes = read(moh->srcfd, buff, 8192)) && time(NULL) < stime)
 				tbytes = tbytes + bytes;
-			}
 			ast_log(LOG_DEBUG, "mpg123 pid %d and child died after %d bytes read\n", pid, tbytes);
 			close(moh->srcfd);
 		}
-		tmp = moh;
-		moh = moh->next;
-		ast_moh_free_class(&tmp);
+		ast_moh_free_class(&moh);
 	}
-	mohclasses = NULL;
-	ast_mutex_unlock(&moh_lock);
+	AST_LIST_UNLOCK(&mohclasses);
 }
 
 static void moh_on_off(int on)
@@ -1108,7 +1087,7 @@
 			else
 				ast_deactivate_generator(chan);
 		}
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	}
 }
 
@@ -1129,8 +1108,8 @@
 	int i;
 	struct mohclass *class;
 
-	ast_mutex_lock(&moh_lock);
-	for (class = mohclasses; class; class = class->next) {
+	AST_LIST_LOCK(&mohclasses);
+	AST_LIST_TRAVERSE(&mohclasses, class, list) {
 		if (!class->total_files)
 			continue;
 
@@ -1138,7 +1117,7 @@
 		for (i = 0; i < class->total_files; i++)
 			ast_cli(fd, "\tFile: %s\n", class->filearray[i]);
 	}
-	ast_mutex_unlock(&moh_lock);
+	AST_LIST_UNLOCK(&mohclasses);
 
 	return 0;
 }
@@ -1147,8 +1126,8 @@
 {
 	struct mohclass *class;
 
-	ast_mutex_lock(&moh_lock);
-	for (class = mohclasses; class; class = class->next) {
+	AST_LIST_LOCK(&mohclasses);
+	AST_LIST_TRAVERSE(&mohclasses, class, list) {
 		ast_cli(fd, "Class: %s\n", class->name);
 		ast_cli(fd, "\tMode: %s\n", S_OR(class->mode,"<none>"));
 		ast_cli(fd, "\tDirectory: %s\n", S_OR(class->dir, "<none>"));
@@ -1156,7 +1135,7 @@
 			ast_cli(fd, "\tApplication: %s\n", S_OR(class->args, "<none>"));
 		ast_cli(fd, "\tFormat: %s\n", ast_getformatname(class->format));
 	}
-	ast_mutex_unlock(&moh_lock);
+	AST_LIST_UNLOCK(&mohclasses);
 
 	return 0;
 }
@@ -1173,12 +1152,14 @@
     
 	if (!load_moh_classes(reload)) 		/* Load classes from config */
 		return 0;			/* Return if nothing is found */
-	moh = mohclasses;
-	while (moh) {
+
+	AST_LIST_LOCK(&mohclasses);
+	AST_LIST_TRAVERSE(&mohclasses, moh, list) {
 		if (moh->total_files)
 			moh_scan_files(moh);
-		moh = moh->next;
 	}
+	AST_LIST_UNLOCK(&mohclasses);
+
 	return 1;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Sun Apr 30 16:54:27 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 30 Apr 2006 16:54:27 +0200
Subject: [solid-pbx-svn] r14 - trunk/mxml
Message-ID: <200604301454.k3UEsRu8027786@sheep.berlios.de>

Author: casper2
Date: 2006-04-30 16:54:24 +0200 (Sun, 30 Apr 2006)
New Revision: 14

Removed:
   trunk/mxml/.cvsignore
   trunk/mxml/configure.in
Log:
Remove unused files

Deleted: trunk/mxml/.cvsignore
===================================================================

Deleted: trunk/mxml/configure.in
===================================================================
--- trunk/mxml/configure.in	2006-04-30 14:53:08 UTC (rev 13)
+++ trunk/mxml/configure.in	2006-04-30 14:54:24 UTC (rev 14)
@@ -1,293 +0,0 @@
-dnl
-dnl "$Id: configure.in 22267 2006-04-24 17:11:45Z kpfleming $"
-dnl
-dnl Configuration script for Mini-XML, a small XML-like file parsing library.
-dnl
-dnl Copyright 2003-2005 by Michael Sweet.
-dnl
-dnl This program is free software; you can redistribute it and/or
-dnl modify it under the terms of the GNU Library General Public
-dnl License as published by the Free Software Foundation; either
-dnl version 2, or (at your option) any later version.
-dnl
-dnl This program is distributed in the hope that it will be useful,
-dnl but WITHOUT ANY WARRANTY; without even the implied warranty of
-dnl MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-dnl GNU General Public License for more details.
-dnl
-
-dnl Specify a source file from the distribution...
-AC_INIT(mxml.h)
-
-dnl Set the name of the config header file...
-AC_CONFIG_HEADER(config.h)
-
-dnl Version number...
-VERSION=2.2.2
-AC_SUBST(VERSION)
-AC_DEFINE_UNQUOTED(MXML_VERSION, "Mini-XML v$VERSION")
-
-dnl Clear default debugging options and set normal optimization by
-dnl default unless the user asks for debugging specifically.
-CFLAGS="${CFLAGS:=}"
-CXXFLAGS="${CXXFLAGS:=}"
-LDFLAGS="${LDFLAGS:=}"
-AC_SUBST(LDFLAGS)
-OPTIM="-O"
-AC_SUBST(OPTIM)
-
-AC_ARG_WITH(ansi, [  --with-ansi             set full ANSI C mode, default=no],
-	use_ansi="$withval",
-	use_ansi="no")
-
-AC_ARG_ENABLE(debug, [  --enable-debug          turn on debugging, default=no],
-if eval "test x$enable_debug = xyes"; then
- 	OPTIM="-g"
-else
-	LDFLAGS="$LDFLAGS -s"
-fi)
-
-AC_ARG_WITH(docdir, [  --with-docdir           set directory for documentation, default=${prefix}/share/doc/mxml],
-	docdir="$withval",
-	docdir="NONE")
-
-AC_SUBST(docdir)
-
-AC_ARG_WITH(vsnprintf, [  --with-vsnprintf        use vsnprintf emulation functions, default=auto],
-	use_vsnprintf="$withval",
-	use_vsnprintf="no")
-
-dnl Get the operating system and version number...
-uname=`uname`
-uversion=`uname -r | sed -e '1,$s/[[^0-9]]//g'`
-if test x$uname = xIRIX64; then
-	uname="IRIX"
-fi
-
-dnl Checks for programs...
-AC_PROG_CC
-AC_PROG_CXX
-AC_PROG_INSTALL
-if test "$INSTALL" = "$ac_install_sh"; then
-	# Use full path to install-sh script...
-	INSTALL="`pwd`/install-sh -c"
-fi
-AC_PROG_RANLIB
-AC_PATH_PROG(AR,ar)
-AC_PATH_PROG(CP,cp)
-AC_PATH_PROG(LN,ln)
-AC_PATH_PROG(MKDIR,mkdir)
-AC_PATH_PROG(NROFF,nroff)
-if test x$NROFF = x; then
-	AC_PATH_PROG(GROFF,groff)
-	if test x$GROFF = x; then
-        	NROFF="echo"
-	else
-        	NROFF="$GROFF -T ascii"
-	fi
-fi
-AC_PATH_PROG(RM,rm)
-
-dnl Flags for "ar" command...
-case "$uname" in
-        Darwin* | *BSD*)
-                ARFLAGS="-rcv"
-                ;;
-        *)
-                ARFLAGS="crvs"
-                ;;
-esac
-
-AC_SUBST(ARFLAGS)
-
-dnl Checks for string functions.
-if test "x$use_ansi" != xyes; then
-	AC_CHECK_FUNCS(strdup)
-fi
-
-if test "x$use_vsnprintf" != xyes; then
-	AC_CHECK_FUNCS(vsnprintf)
-fi
-
-dnl Shared library support...
-DSO="${DSO:=:}"
-DSOFLAGS="${DSOFLAGS:=}"
-
-AC_ARG_ENABLE(shared, [  --enable-shared         turn on shared libraries, default=no])
-
-if test x$enable_shared = xyes; then
-	AC_MSG_CHECKING(for shared library support)
-	PICFLAG=1
-
-	case "$uname" in
-		SunOS* | UNIX_S*)
-			AC_MSG_RESULT(yes)
-			LIBMXML="libmxml.so.1.0"
-			DSO="\$(CC)"
-			DSOFLAGS="$DSOFLAGS -Wl,-h,libmxml.so.1 -G -R\$(libdir) \$(OPTIM)"
-			LDFLAGS="$LDFLAGS -R\$(libdir)"
-                	;;
-
-		HP-UX*)
-			AC_MSG_RESULT(yes)
-			LIBMXML="libmxml.sl.1"
-			DSO="ld"
-			DSOFLAGS="$DSOFLAGS -b -z +h libmxml.sl.1 +s +b \$(libdir)"
-			LDFLAGS="$LDFLAGS -Wl,+s,+b,\$(libdir)"
-			;;
-
-		IRIX)
-			AC_MSG_RESULT(yes)
-			LIBMXML="libmxml.so.1.0"
-			DSO="\$(CC)"
-			DSOFLAGS="$DSOFLAGS -Wl,-rpath,\$(libdir),-set_version,sgi1.0,-soname,libmxml.so.1 -shared \$(OPTIM)"
-			;;
-
-		OSF1* | Linux | GNU)
-			AC_MSG_RESULT(yes)
-			LIBMXML="libmxml.so.1.0"
-			DSO="\$(CC)"
-			DSOFLAGS="$DSOFLAGS -Wl,-soname,libmxml.so.1,-rpath,\$(libdir) -shared \$(OPTIM)"
-                        LDFLAGS="$LDFLAGS -Wl,-rpath,\$(libdir)"
-			;;
-
-		*BSD*)
-			AC_MSG_RESULT(yes)
-			LIBMXML="libmxml.so.1.0"
-			DSO="\$(CC)"
-			DSOFLAGS="$DSOFLAGS -Wl,-soname,libmxml.so.1,-R\$(libdir) -shared \$(OPTIM)"
-			LDFLAGS="$LDFLAGS -Wl,-R\$(libdir)"
-                        ;;
-
-		Darwin*)
-			AC_MSG_RESULT(yes)
-			LIBMXML="libmxml.1.dylib"
-			DSO="\$(CC)"
-			DSOFLAGS="$DSOFLAGS \$(RC_CFLAGS) -dynamiclib -lc"
-			;;
-
-		*)
-			AC_MSG_RESULT(no)
-			AC_MSG_WARN(shared libraries not supported on this platform.)
-			PICFLAG=0
-			LIBMXML="libmxml.a"
-			;;
-	esac
-else
-	PICFLAG=0
-	LIBMXML="libmxml.a"
-fi
-
-AC_SUBST(DSO)
-AC_SUBST(DSOFLAGS)
-AC_SUBST(LIBMXML)
-AC_SUBST(PICFLAG)
-
-dnl Add -Wall for GCC...
-if test -n "$GCC"; then
-	CFLAGS="-Wall $CFLAGS"
-
-	if test "x$use_ansi" = xyes; then
-		CFLAGS="-ansi -pedantic $CFLAGS"
-	fi
-
-	if test $PICFLAG = 1 -a $uname != AIX; then
-    		OPTIM="-fPIC $OPTIM"
-	fi
-else
-	case $uname in
-		HP-UX*)
-			CFLAGS="-Ae $CFLAGS"
-			OPTIM="+DAportable $OPTIM"
-
-			if test $PICFLAG = 1; then
-				OPTIM="+z $OPTIM"
-			fi
-			;;
-
-		UNIX_SVR* | SunOS*)
-			if test $PICFLAG = 1; then
-				OPTIM="-KPIC $OPTIM"
-			fi
-			;;
-	esac
-fi
-
-dnl Fix "prefix" variable if it hasn't been specified...
-if test "$prefix" = "NONE"; then
-	prefix="/usr/local"
-fi
-
-dnl Fix "exec_prefix" variable if it hasn't been specified...
-if test "$exec_prefix" = "NONE"; then
-	exec_prefix="$prefix"
-fi
-
-dnl Fix "docdir" variable if it hasn't been specified...
-if test "$docdir" = "NONE"; then
-	docdir="$datadir/doc/mxml"
-fi
-
-dnl Fix "mandir" variable if it hasn't been specified...
-if test "$mandir" = "\${prefix}/man" -a "$prefix" = "/usr"; then
-	case "$uname" in
-        	*BSD* | Darwin* | Linux*)
-        		# BSD, Darwin (MacOS X), and Linux
-        		mandir="/usr/share/man"
-        		;;
-        	IRIX*)
-        		# SGI IRIX
-        		mandir="/usr/share/catman/u_man"
-        		;;
-        	*)
-        		# All others
-        		mandir="/usr/man"
-        		;;
-	esac
-fi
-
-dnl More manpage stuff...
-case "$uname" in
-        *BSD* | Darwin*)
-        	# *BSD
-        	CAT1EXT="0"
-        	MAN1EXT="1"
-        	CAT3EXT="0"
-        	MAN3EXT="3"
-        	;;
-        *)
-        	# All others
-        	CAT1EXT="1"
-        	MAN1EXT="1"
-        	CAT3EXT="3"
-        	MAN3EXT="3"
-        	;;
-esac
-
-AC_SUBST(CAT1EXT)
-AC_SUBST(CAT3EXT)
-AC_SUBST(MAN1EXT)
-AC_SUBST(MAN3EXT)
-
-dnl pkg-config stuff...
-if test "$includedir" != /usr/include; then
-	PC_CFLAGS="-I$includedir"
-else
-	PC_CFLAGS=""
-fi
-
-if test "$libdir" != /usr/lib; then
-	PC_LIBS="-L$libdir -lmxml"
-else
-	PC_LIBS="-lmxml"
-fi
-
-AC_SUBST(PC_CFLAGS)
-AC_SUBST(PC_LIBS)
-
-dnl Output the makefile, etc...
-AC_OUTPUT(Makefile mxml.list mxml.pc)
-
-dnl
-dnl End of "$Id: configure.in 22267 2006-04-24 17:11:45Z kpfleming $".
-dnl



From solid-pbx-svn-admin at lists.berlios.de  Sun Apr 30 16:53:28 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 30 Apr 2006 16:53:28 +0200
Subject: [solid-pbx-svn] r13 - in trunk: . apps build_tools channels channels/misdn include/asterisk mxml pbx pbx/ael res res/snmp utils
Message-ID: <200604301453.k3UErScD027688@sheep.berlios.de>

Author: casper2
Date: 2006-04-30 16:53:08 +0200 (Sun, 30 Apr 2006)
New Revision: 13

Modified:
   trunk/Makefile
   trunk/acinclude.m4
   trunk/app.c
   trunk/apps/Makefile
   trunk/asterisk.c
   trunk/build_tools/cflags.xml
   trunk/channel.c
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
   trunk/channels/misdn/isdn_lib_intern.h
   trunk/cli.c
   trunk/devicestate.c
   trunk/include/asterisk/frame.h
   trunk/manager.c
   trunk/mxml/.cvsignore
   trunk/mxml/Makefile.in
   trunk/pbx.c
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael.tab.c
   trunk/pbx/ael/ael.y
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/pbx_dundi.c
   trunk/res/res_agi.c
   trunk/res/res_features.c
   trunk/res/res_monitor.c
   trunk/res/snmp/agent.c
   trunk/udptl.c
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r23556
------------------------------------------------------------------------
r23354 | kpfleming | 2006-04-29 16:48:32 +0200 (Sat, 29 Apr 2006) | 2 lines

fix up dependencies for aelparse so that bison/flex will not be run to rebuild source files (that should _only_ be done manually)

------------------------------------------------------------------------
r23355 | russell | 2006-04-29 16:50:18 +0200 (Sat, 29 Apr 2006) | 2 lines

a bunch of conversion to ast_channel_*lock (issue #7058)

------------------------------------------------------------------------
r23376 | russell | 2006-04-29 17:07:16 +0200 (Sat, 29 Apr 2006) | 2 lines

add aelparse to svn:ignore

------------------------------------------------------------------------
r23378 | kpfleming | 2006-04-29 17:15:21 +0200 (Sat, 29 Apr 2006) | 2 lines

add the other two files that should have been on this target... oops

------------------------------------------------------------------------
r23380 | kpfleming | 2006-04-29 17:31:45 +0200 (Sat, 29 Apr 2006) | 3 lines

and now with the correct filenames
add basic support for checking for C compiler attribute support

------------------------------------------------------------------------
r23381 | russell | 2006-04-29 17:34:33 +0200 (Sat, 29 Apr 2006) | 3 lines

- the configure script should never be regenerated for mxml
- also remove an unneeded .cvsignore

------------------------------------------------------------------------
r23382 | russell | 2006-04-29 17:44:02 +0200 (Sat, 29 Apr 2006) | 2 lines

oops, i modified the Makefile isntead of Makefile.in

------------------------------------------------------------------------
r23402 | rizzo | 2006-04-29 20:22:08 +0200 (Sat, 29 Apr 2006) | 2 lines

remove now useless rule for app_rpt (bug 7059)

------------------------------------------------------------------------
r23422 | russell | 2006-04-29 21:26:53 +0200 (Sat, 29 Apr 2006) | 6 lines

revert the last change to this Makefile which removed the rules to build
app_apt.  These rules *are* needed beacause this module uses libtonezone,
so it needs this information from autoconf in case it is located in a
non-standard location.  Also, without it, app_rpt.so would not be linked
with libtonezone at all.

------------------------------------------------------------------------
r23443 | crichter | 2006-04-30 00:56:00 +0200 (Sun, 30 Apr 2006) | 1 line

added an up-queue message mechanism to avoid buffer fillups in the kernel, also changed some strdups to ast_strdupa
------------------------------------------------------------------------
r23463 | russell | 2006-04-30 06:20:20 +0200 (Sun, 30 Apr 2006) | 4 lines

- convert some comments to doxygen format
- convert the list of dundi peers to use the list macros
- convert a use of malloc+memset to use ast_calloc

------------------------------------------------------------------------
r23464 | russell | 2006-04-30 06:23:09 +0200 (Sun, 30 Apr 2006) | 3 lines

immediately handle a memory allocation failure so the rest of the function
doesn't have to be indented (indentation still to be fixed)

------------------------------------------------------------------------
r23465 | russell | 2006-04-30 06:26:11 +0200 (Sun, 30 Apr 2006) | 2 lines

fix the indentation of a large block of code

------------------------------------------------------------------------
r23466 | russell | 2006-04-30 06:28:47 +0200 (Sun, 30 Apr 2006) | 2 lines

change a list traversal to use a for loop

------------------------------------------------------------------------
r23467 | russell | 2006-04-30 06:34:04 +0200 (Sun, 30 Apr 2006) | 2 lines

use the INSTALL variable instead of "install" directly

------------------------------------------------------------------------
r23468 | russell | 2006-04-30 06:59:36 +0200 (Sun, 30 Apr 2006) | 3 lines

- convert the list of dundi mappings to use the list macros
- change an instance of malloc+memset to use ast_calloc, instead

------------------------------------------------------------------------
r23480 | russell | 2006-04-30 07:02:07 +0200 (Sun, 30 Apr 2006) | 3 lines

handle a memory allocation failure immediately so the following large block
does not have to be indented

------------------------------------------------------------------------
r23489 | russell | 2006-04-30 07:06:14 +0200 (Sun, 30 Apr 2006) | 2 lines

fix the indentation of a large block

------------------------------------------------------------------------
r23490 | russell | 2006-04-30 07:07:52 +0200 (Sun, 30 Apr 2006) | 3 lines

immediately handle ast_strdupa result so that one more level of indentation
can be removed from this function

------------------------------------------------------------------------
r23491 | russell | 2006-04-30 07:09:34 +0200 (Sun, 30 Apr 2006) | 2 lines

fix indentation for this function

------------------------------------------------------------------------
r23492 | russell | 2006-04-30 07:15:53 +0200 (Sun, 30 Apr 2006) | 2 lines

convert existing comments to doxygen format

------------------------------------------------------------------------
r23493 | russell | 2006-04-30 07:24:10 +0200 (Sun, 30 Apr 2006) | 2 lines

convert the dundi_request list to use the list macros

------------------------------------------------------------------------
r23494 | russell | 2006-04-30 07:27:57 +0200 (Sun, 30 Apr 2006) | 2 lines

remove unneeded define - it is already in asterisk.h

------------------------------------------------------------------------
r23514 | kpfleming | 2006-04-30 08:50:53 +0200 (Sun, 30 Apr 2006) | 2 lines

remove attribute checking... it was an attempt to support older GCC compilers but is not worth the effort :-)

------------------------------------------------------------------------
r23534 | rizzo | 2006-04-30 10:21:46 +0200 (Sun, 30 Apr 2006) | 5 lines

more simplifications in the bison sources,
more annotation with XXX of dubious code.
(The code still passes tests)


------------------------------------------------------------------------
r23535 | rizzo | 2006-04-30 10:35:49 +0200 (Sun, 30 Apr 2006) | 10 lines

when compiling ast_expr2 from utils/ the current directory
is utils/ so the compiler fails to find the header which is in ../
(at least on FreeBSD; this works on linux but it may be due to
differences in gmake).
For the time being, fix it by adding -I.. to the includes.
However i think a proper fix is to make sure that ast_expr2
is built using the rules in the top-level makefile instead
of those in the subdirectory.


------------------------------------------------------------------------
r23536 | kpfleming | 2006-04-30 10:47:47 +0200 (Sun, 30 Apr 2006) | 2 lines

remove T38_SUPPORT define that is no longer needed

------------------------------------------------------------------------
r23550 | rizzo | 2006-04-30 11:06:28 +0200 (Sun, 30 Apr 2006) | 3 lines

comment some code


------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/Makefile	2006-04-30 14:53:08 UTC (rev 13)
@@ -252,7 +252,7 @@
   ID=/usr/xpg4/bin/id
 endif
 
-INCLUDE+=-Iinclude -I../include
+INCLUDE+=-Iinclude -I../include -I..
 ASTCFLAGS+=-pipe  -Wall -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations $(DEBUG) $(INCLUDE) #-DMAKE_VALGRIND_HAPPY
 ASTCFLAGS+=$(OPTIMIZE)
 
@@ -580,7 +580,7 @@
 # improved a lot.  I'll put it here for now.
 	mkdir -p $(DESTDIR)$(ASTDATADIR)/static-http
 	for x in static-http/*; do \
-		install -m 644 $$x $(DESTDIR)$(ASTDATADIR)/static-http ; \
+		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/static-http ; \
 	done
 	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/digits
 	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/priv-callerintros

Modified: trunk/acinclude.m4
===================================================================
--- trunk/acinclude.m4	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/acinclude.m4	2006-04-30 14:53:08 UTC (rev 13)
@@ -68,7 +68,7 @@
 
 
 AC_DEFUN(
-[AST_CHECK_GNU_MAKE], [ AC_CACHE_CHECK( for GNU make, GNU_MAKE,
+[AST_CHECK_GNU_MAKE], [AC_CACHE_CHECK(for GNU make, GNU_MAKE,
    GNU_MAKE='Not Found' ;
    for a in make gmake gnumake ; do
       if test -z "$a" ; then continue ; fi ;
@@ -83,4 +83,4 @@
    exit 1
 fi
 AC_SUBST([GNU_MAKE])
-] )
+])

Modified: trunk/app.c
===================================================================
--- trunk/app.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/app.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -1042,7 +1042,7 @@
  		test = pbx_builtin_getvar_helper(chan, cat);
 		if (test && !strcasecmp(test, group))
  			count++;
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	}
 
 	return count;
@@ -1072,7 +1072,7 @@
 		test = pbx_builtin_getvar_helper(chan, cat);
 		if (test && !regexec(&regexbuf, test, 0, NULL, 0))
 			count++;
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	}
 
 	regfree(&regexbuf);

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/apps/Makefile	2006-04-30 14:53:08 UTC (rev 13)
@@ -41,7 +41,7 @@
 	$(CC) $(SOLINK) -o $@ $< $(ZAPTEL_LIB)
 
 app_rpt.o: app_rpt.c
-	$(CC) $(SOLINK) -o $@ $< $(ZAPTEL_INCLUDE) 
+	$(CC) $(SOLINK) -o $@ $< $(ZAPTEL_INCLUDE)
 
 install: all
 	for x in $(MODS); do $(INSTALL) -m 755 $$x $(DESTDIR)$(MODULES_DIR) ; done

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/asterisk.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -111,9 +111,7 @@
 #include "asterisk/enum.h"
 #include "asterisk/rtp.h"
 #include "asterisk/http.h"
-#if defined(T38_SUPPORT)
 #include "asterisk/udptl.h"
-#endif
 #include "asterisk/app.h"
 #include "asterisk/lock.h"
 #include "asterisk/utils.h"
@@ -2582,9 +2580,7 @@
 		exit(1);
 	}
 	ast_rtp_init();
-#if defined(T38_SUPPORT)
 	ast_udptl_init();
-#endif
 	if (ast_image_init()) {
 		printf(term_quit());
 		exit(1);

Modified: trunk/build_tools/cflags.xml
===================================================================
--- trunk/build_tools/cflags.xml	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/build_tools/cflags.xml	2006-04-30 14:53:08 UTC (rev 13)
@@ -17,7 +17,4 @@
 		</member>
 		<member name="-DMTX_PROFILE">
 		</member>
-		<member name="-DT38_SUPPORT">
-			<defaultenabled>yes</defaultenabled>
-		</member>
 	</category>

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/channel.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -3330,9 +3330,7 @@
 		    (f->frametype == AST_FRAME_VIDEO) ||
 		    (f->frametype == AST_FRAME_IMAGE) ||
 		    (f->frametype == AST_FRAME_HTML) ||
-#if defined(T38_SUPPORT)
 		    (f->frametype == AST_FRAME_MODEM) ||
-#endif
 		    (f->frametype == AST_FRAME_TEXT)) {
 			/* monitored dtmf causes exit from bridge */
 			int monitored_source = (who == c0) ? watch_c0_dtmf : watch_c1_dtmf;

Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/channels/chan_misdn.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -183,6 +183,9 @@
 
 	char context[BUFFERSIZE];
 
+	int zero_read_cnt;
+	int dropped_frame_cnt;
+
 	const struct tone_zone_sound *ts;
 	
 	struct chan_list *peer;
@@ -749,7 +752,7 @@
 static int misdn_show_stacks (int fd, int argc, char *argv[])
 {
 	int port;
-	
+
 	ast_cli(fd, "BEGIN STACK_LIST:\n");
 
 	for (port=misdn_cfg_get_next_port(0); port > 0;
@@ -927,7 +930,7 @@
 		c = ast_channel_walk_locked(c);
 	}
 	if (c) {
-		ret = strdup(c->name);
+		ret = ast_strdupa(c->name);
 		ast_mutex_unlock(&c->lock);
 	} else
 		ret = NULL;
@@ -946,12 +949,12 @@
 
 	switch (pos) {
 	case 4: if (*word == 'p')
-				return strdup("port");
+				return ast_strdupa("port");
 			else if (*word == 'o')
-				return strdup("only");
+				return ast_strdupa("only");
 			break;
 	case 6: if (*word == 'o')
-				return strdup("only");
+				return ast_strdupa("only");
 			break;
 	}
 	return NULL;
@@ -1504,17 +1507,13 @@
 		if ( strcmp(bc->dad,ast->exten)) {
 			ast_copy_string(ast->exten, bc->dad, sizeof(ast->exten));
 		}
-		if ( ast->cid.cid_num && strcmp(ast->cid.cid_num, bc->oad)) {
-			free(ast->cid.cid_num);
-			ast->cid.cid_num=NULL;
-			
-		}
+		
 		if ( !ast->cid.cid_num) {
-			ast->cid.cid_num=strdup(bc->oad);
+			ast_set_callerid(ast, bc->oad, NULL, bc->oad);
 		}
 		
 		if ( !ast_strlen_zero(bc->rad) ) 
-			ast->cid.cid_rdnis=strdup(bc->rad);
+			ast->cid.cid_rdnis=ast_strdupa(bc->rad);
 	}
 	return 0;
 }
@@ -2062,10 +2061,20 @@
 	len = misdn_ibuf_usedcount(tmp->bc->astbuf);
 
 	if (!len) {
-		chan_misdn_log(4,tmp->bc->port,"misdn_read: ZERO READ\n");
+		struct ast_frame *frame;
+		if(!tmp->zero_read_cnt)
+			chan_misdn_log(4,tmp->bc->port,"misdn_read: ZERO READ\n");
+		tmp->zero_read_cnt++;
+
+		if (tmp->zero_read_cnt > 5000) {
+			chan_misdn_log(4,tmp->bc->port,"misdn_read: ZERO READ counted > 5000 times\n");
+			tmp->zero_read_cnt=0;
+
+		}
 		tmp->frame.frametype = AST_FRAME_NULL;
 		tmp->frame.subclass = 0;
-		return &tmp->frame;
+		frame=ast_frisolate(&tmp->frame);
+		return frame;
 	}
 
 	/*shrinken len if necessary, we transmit at maximum 4k*/
@@ -2154,7 +2163,16 @@
 		case BCHAN_BRIDGED:
 			break;
 		default:
-		chan_misdn_log(5, ch->bc->port, "BC not active (nor bridged) droping: %d frames addr:%x exten:%s cid:%s ch->state:%s\n",frame->samples,ch->bc->addr, ast->exten, ast->cid.cid_num,misdn_get_ch_state( ch));
+		if (!ch->dropped_frame_cnt)
+			chan_misdn_log(5, ch->bc->port, "BC not active (nor bridged) droping: %d frames addr:%x exten:%s cid:%s ch->state:%s bc_state:%d\n",frame->samples,ch->bc->addr, ast->exten, ast->cid.cid_num,misdn_get_ch_state( ch), ch->bc->bc_state);
+		
+		ch->dropped_frame_cnt++;
+		if (ch->dropped_frame_cnt > 100) {
+			ch->dropped_frame_cnt=0;
+			chan_misdn_log(5, ch->bc->port, "BC not active (nor bridged) droping: %d frames addr:%x  dropped > 100 frames!\n",frame->samples,ch->bc->addr);
+
+		}
+
 		return 0;
 	}
 	
@@ -2264,10 +2282,6 @@
     
 	}
   
-	if (bridging) {
-		misdn_lib_split_bridge(ch1->bc,ch2->bc);
-	}
-  
 	return 0;
 }
 
@@ -2612,10 +2626,9 @@
 			char *cid_name, *cid_num;
       
 			ast_callerid_parse(callerid, &cid_name, &cid_num);
-			if (cid_name)
-				tmp->cid.cid_name=strdup(cid_name);
-			if (cid_num)
-				tmp->cid.cid_num=strdup(cid_num);
+			ast_set_callerid(tmp, cid_num,cid_name,cid_num);
+		} else {
+			ast_set_callerid(tmp, NULL,NULL,NULL);
 		}
 
 		{

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/channels/misdn/isdn_lib.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -802,6 +802,8 @@
 		free_chan = find_free_chan_in_stack(stack, bc->channel_preselected?bc->channel:0);
 		if (!free_chan) return -1;
 		bc->channel=free_chan;
+		
+		cb_log(0,stack->port, " -->  found channel: %d\n",free_chan);
     
 		for (i=0; i <= MAXPROCS; i++)
 			if (stack->procids[i]==0) break;
@@ -833,6 +835,7 @@
 			free_chan = find_free_chan_in_stack(stack, bc->channel_preselected?bc->channel:0);
 			if (!free_chan) return -1;
 			bc->channel=free_chan;
+			cb_log(0,stack->port, " -->  found channel: %d\n",free_chan);
 		} else {
 			/* other phones could have made a call also on this port (ptmp) */
 			bc->channel=0xff;
@@ -1107,6 +1110,7 @@
 	stack->pri=0;
   
 	msg_queue_init(&stack->downqueue);
+	msg_queue_init(&stack->upqueue);
   
 	/* query port's requirements */
 	ret = mISDN_get_stack_info(midev, port, buff, sizeof(buff));
@@ -2072,11 +2076,18 @@
 		
 	case MGR_SETSTACK| INDICATION:
 		cb_log(2, stack->port, "BCHAN: MGR_SETSTACK|IND \n");
-		
+
+	AGAIN:
 		bc->addr = mISDN_get_layerid(stack->midev, bc->b_stid, bc->layer);
 		if (!bc->addr) {
+
+			if (errno == EAGAIN) {
+				usleep(1000);
+				goto AGAIN;
+			}
+			
 			cb_log(0,stack->port,"$$$ Get Layer (%d) Id Error: %s\n",bc->layer,strerror(errno));
-
+			
 			/* we kill the channel later, when we received some
 			   data. */
 			bc->addr= frm->addr;
@@ -2587,10 +2598,12 @@
 	FD_SET(midev,&rdfs);
   
 	mISDN_select(FD_SETSIZE, &rdfs, NULL, NULL, NULL);
+	//select(FD_SETSIZE, &rdfs, NULL, NULL, NULL);
   
 	if (FD_ISSET(midev, &rdfs)) {
-    
-		r=mISDN_read(midev,msg->data,MAX_MSG_SIZE,0);
+
+	AGAIN:
+		r=mISDN_read(midev,msg->data,MAX_MSG_SIZE, 5000);
 		msg->len=r;
     
 		if (r==0) {
@@ -2599,6 +2612,17 @@
 			return NULL;
 		}
 
+		if (r<0) {
+			if (errno == EAGAIN) {
+				/*we wait for mISDN here*/
+				cb_log(-1,0,"mISDN_read wants us to wait\n");
+				usleep(5000);
+				goto AGAIN;
+			}
+			
+			cb_log(-1,0,"mISDN_read returned :%d error:%s (%d)\n",r,strerror(errno),errno); 
+		}
+
 		return msg;
 	} else {
 		printf ("Select timeout\n");
@@ -2976,6 +3000,22 @@
 int handle_err(msg_t *msg)
 {
 	iframe_t *frm = (iframe_t*) msg->data;
+
+
+	if (!frm->addr) {
+		static int cnt=0;
+		if (!cnt)
+			cb_log(0,0,"mISDN Msg without Address pr:%x dinfo:%x\n",frm->prim,frm->dinfo);
+		cnt++;
+		if (cnt>100) {
+			cb_log(0,0,"mISDN Msg without Address pr:%x dinfo:%x (already more than 100 of them)\n",frm->prim,frm->dinfo);
+			cnt=0;
+		}
+		
+		free_msg(msg);
+		return 1;
+		
+	}
 	
 	switch (frm->prim) {
 		case DL_DATA|INDICATION:
@@ -2983,8 +3023,14 @@
 			int port=(frm->addr&MASTER_ID_MASK) >> 8;
 			int channel=(frm->addr&CHILD_ID_MASK) >> 16;
 
-			cb_log(3,0,"BCHAN DATA without BC: addr:%x port:%d channel:%d\n",frm->addr, port,channel);
+			/*we flush the read buffer here*/
 			
+			cb_log(9,0,"BCHAN DATA without BC: addr:%x port:%d channel:%d\n",frm->addr, port,channel);
+			
+			free_msg(msg) ; 
+			return 1;
+			
+			
 			struct misdn_bchannel *bc=find_bc_by_channel( port , channel);
 
 			if (!bc) {
@@ -3015,11 +3061,28 @@
 }
 
 
+int queue_l2l3(msg_t *msg) {
+	iframe_t *frm= (iframe_t*)msg->data;
+	struct misdn_stack *stack;
+	int err=0;
+
+	stack=find_stack_by_addr( frm->addr );
+
+	
+	if (!stack) {
+		return 0;
+	}
+
+	msg_queue_tail(&stack->upqueue, msg);
+	sem_post(&glob_mgr->new_msg);
+	return 1;
+}
+
 int manager_isdn_handler(iframe_t *frm ,msg_t *msg)
 {  
 
 	if (frm->dinfo==(signed long)0xffffffff && frm->prim==(PH_DATA|CONFIRM)) {
-		printf("SERIOUS BUG, dinfo == 0xffffffff, prim == PH_DATA | CONFIRM !!!!\n");
+		cb_log(0,0,"SERIOUS BUG, dinfo == 0xffffffff, prim == PH_DATA | CONFIRM !!!!\n");
 	}
 
 	if ( ((frm->addr | ISDN_PID_BCHANNEL_BIT )>> 28 ) == 0x5) {
@@ -3039,21 +3102,17 @@
 	/* Its important to handle l1 AFTER l2  */
 	if (handle_l1(msg)) 
 		return 0 ;
-	
-	
-	/** Handle L2/3 Signalling after bchans **/ 
-	if (handle_frm_nt(msg)) 
-		return 0 ;
-	
-	if (handle_frm(msg)) 
-		return 0 ;
 
+	/* The L2/L3 will be queued */
+	if (queue_l2l3(msg))
+		return 0;
+
 	if (handle_err(msg)) 
 		return 0 ;
-	
+
 	cb_log(-1, 0, "Unhandled Message: prim %x len %d from addr %x, dinfo %x on this port.\n",frm->prim, frm->len, frm->addr, frm->dinfo);		
-   
 	free_msg(msg);
+	
 
 	return 0;
 }
@@ -3200,6 +3259,24 @@
 		for (stack=glob_mgr->stack_list;
 		     stack;
 		     stack=stack->next ) { 
+
+			while ( (msg=msg_dequeue(&stack->upqueue)) ) {
+				int res=0;
+				/** Handle L2/3 Signalling after bchans **/ 
+				if (!handle_frm_nt(msg)) {
+					/* Maybe it's TE */
+					if (!handle_frm(msg)) {
+						/* wow none! */
+						cb_log(-1,stack->port,"Wow we've got a strange issue while dequeueing a Frame\n");
+					}
+				}
+			}
+
+			/* Here we should check if we really want to 
+				send all the messages we've queued, lets 
+				assume we've queued a Disconnect, but 
+				received it already from the other side!*/
+		     
 			while ( (msg=msg_dequeue(&stack->downqueue)) ) {
 				if (stack->nt ) {
 					if (stack->nst.manager_l3(&stack->nst, msg))
@@ -3208,6 +3285,7 @@
 				} else {
 					iframe_t *frm = (iframe_t *)msg->data;
 					struct misdn_bchannel *bc = find_bc_by_l3id(stack, frm->dinfo);
+					cb_log(0,stack->port,"Sending msg, prim:%x addr:%x dinfo:%x\n",frm->prim,frm->addr,frm->dinfo);
 					if (bc) send_msg(glob_mgr->midev, bc, msg);
 				}
 			}

Modified: trunk/channels/misdn/isdn_lib_intern.h
===================================================================
--- trunk/channels/misdn/isdn_lib_intern.h	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/channels/misdn/isdn_lib_intern.h	2006-04-30 14:53:08 UTC (rev 13)
@@ -74,6 +74,7 @@
 	int procids[0x100+1];
 
 	msg_queue_t downqueue;
+	msg_queue_t upqueue;
 	int busy;
   
 	int port;

Modified: trunk/cli.c
===================================================================
--- trunk/cli.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/cli.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -444,7 +444,7 @@
 			ast_cli(fd, FORMAT_STRING, c->name, locbuf, ast_state2str(c->_state), appdata);
 		}
 		numchans++;
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 	}
 	if (!concise) {
 		ast_cli(fd, "%d active channel%s\n", numchans, ESS(numchans));
@@ -505,7 +505,7 @@
 	if (c) {
 		ast_cli(fd, "Requested Hangup on channel '%s'\n", c->name);
 		ast_softhangup(c, AST_SOFTHANGUP_EXPLICIT);
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 	} else
 		ast_cli(fd, "%s is not a known channel\n", argv[2]);
 	return RESULT_SUCCESS;
@@ -630,7 +630,7 @@
 			c->fout |= DEBUGCHAN_FLAG;
 			ast_cli(fd, "Debugging enabled on channel %s\n", c->name);
 		}
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 		if (!is_all)
 			break;
 		c = ast_channel_walk_locked(c);
@@ -662,7 +662,7 @@
 			c->fout &= ~DEBUGCHAN_FLAG;
 			ast_cli(fd, "Debugging disabled on channel %s\n", c->name);
 		}
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 		if (!is_all)
 			break;
 		c = ast_channel_walk_locked(c);
@@ -747,7 +747,7 @@
 	if(c->cdr && ast_cdr_serialize_variables(c->cdr,buf, sizeof(buf), '=', '\n', 1))
 		ast_cli(fd,"  CDR Variables:\n%s\n",buf);
 	
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	return RESULT_SUCCESS;
 }
 
@@ -790,7 +790,7 @@
 	while (ret == &notfound && (c = ast_channel_walk_locked(c))) {
 		if (!strncasecmp(word, c->name, wordlen) && ++which > state)
 			ret = ast_strdup(c->name);
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 	}
 	return ret == &notfound ? NULL : ret;
 }
@@ -874,7 +874,7 @@
 			}
 		}
 		numchans++;
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 	}
 
 	if (havepattern)

Modified: trunk/devicestate.c
===================================================================
--- trunk/devicestate.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/devicestate.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -101,7 +101,7 @@
 	else
 		res = AST_DEVICE_INUSE;
 	
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 
 	return res;
 }

Modified: trunk/include/asterisk/frame.h
===================================================================
--- trunk/include/asterisk/frame.h	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/include/asterisk/frame.h	2006-04-30 14:53:08 UTC (rev 13)
@@ -164,22 +164,18 @@
 /*! Comfort Noise frame (subclass is level of CNG in -dBov), 
     body may include zero or more 8-bit quantization coefficients */
 #define AST_FRAME_CNG		10
-#if defined(T38_SUPPORT)
 /*! Modem-over-IP data streams */
 #define AST_FRAME_MODEM		11
-#endif /* T38_SUPPORT */
 /*! DTMF begin event, subclass is the digit */
 #define AST_FRAME_DTMF_BEGIN	12
 /*! DTMF end event, subclass is the digit */
 #define AST_FRAME_DTMF_END	13
 
-#if defined(T38_SUPPORT)
 /* MODEM subclasses */
 /*! T.38 Fax-over-IP */
 #define AST_MODEM_T38		1
 /*! V.150 Modem-over-IP */
 #define AST_MODEM_V150		2
-#endif /* T38_SUPPORT */
 
 /* HTML subclasses */
 /*! Sending a URL */

Modified: trunk/manager.c
===================================================================
--- trunk/manager.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/manager.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -1053,7 +1053,7 @@
 		return 0;
 	}
 	ast_softhangup(c, AST_SOFTHANGUP_EXPLICIT);
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	astman_send_ack(s, m, "Channel Hungup");
 	return 0;
 }
@@ -1093,7 +1093,7 @@
 	pbx_builtin_setvar_helper(c, varname, varval);
 	  
 	if (c)
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 
 	astman_send_ack(s, m, "Variable Set");	
 
@@ -1136,7 +1136,7 @@
 	}
 
 	if (c)
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 	astman_append(s, "Response: Success\r\n"
 		"Variable: %s\r\nValue: %s\r\n", varname, varval);
 	if (!ast_strlen_zero(id))
@@ -1227,7 +1227,7 @@
 			c->accountcode,
 			ast_state2str(c->_state), bridge, c->uniqueid, idText);
 		}
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 		if (!all)
 			break;
 		c = ast_channel_walk_locked(c);
@@ -1297,9 +1297,9 @@
 	} else
 		astman_send_error(s, m, "Redirect failed");
 	if (chan)
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	if (chan2)
-		ast_mutex_unlock(&chan2->lock);
+		ast_channel_unlock(chan2);
 	return 0;
 }
 
@@ -1363,7 +1363,7 @@
 
 	/* Locked by ast_pbx_outgoing_exten or ast_pbx_outgoing_app */
 	if (chan)
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	free(in);
 	return NULL;
 }
@@ -1626,7 +1626,7 @@
 		return 0;
 	}
 	ast_channel_setwhentohangup(c, timeout);
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	astman_send_ack(s, m, "Timeout Set");
 	return 0;
 }

Modified: trunk/mxml/.cvsignore
===================================================================
--- trunk/mxml/.cvsignore	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/mxml/.cvsignore	2006-04-30 14:53:08 UTC (rev 13)
@@ -1,12 +0,0 @@
-*.bck
-*.bak
-Makefile
-autom4te*.cache
-config.cache
-config.h
-config.log
-config.status
-libmxml.a
-mxml.list
-mxmldoc
-testmxml

Modified: trunk/mxml/Makefile.in
===================================================================
--- trunk/mxml/Makefile.in	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/mxml/Makefile.in	2006-04-30 14:53:08 UTC (rev 13)
@@ -213,7 +213,7 @@
 # autoconf stuff...
 #
 
-Makefile:	configure Makefile.in
+Makefile:	Makefile.in
 	if test -f config.status; then \
 		./config.status --recheck; \
 		./config.status; \
@@ -223,17 +223,6 @@
 	touch config.h
 
 
-configure:	configure.in
-	autoconf
-	if test -f config.status; then \
-		./config.status --recheck; \
-		./config.status; \
-	else \
-		./configure; \
-	fi
-	touch config.h
-
-
 config.h:	configure config.h.in
 	autoconf
 	if test -f config.status; then \

Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/pbx/ael/ael.flex	2006-04-30 14:53:08 UTC (rev 13)
@@ -493,7 +493,19 @@
 }
 
 
-/* used by the bison code */
+/*
+ * The following three functions, reset_*, are used in the bison
+ * code to switch context. As a consequence, we need to
+ * declare them global and add a prototype so that the
+ * compiler does not complain.
+ *
+ * NOTE: yyg is declared because it is used in the BEGIN macros,
+ * though that should be hidden as the macro changes
+ * depending on the flex options that we use - in particular,
+ * %reentrant changes the way the macro is declared;
+ * without %reentrant, BEGIN uses yystart instead of yyg
+ */
+
 void reset_parencount(yyscan_t yyscanner );
 void reset_parencount(yyscan_t yyscanner )
 {
@@ -505,7 +517,6 @@
 	BEGIN(paren);
 }
 
-/* used by the bison code */
 void reset_semicount(yyscan_t yyscanner );
 void reset_semicount(yyscan_t yyscanner )
 {
@@ -514,7 +525,6 @@
 	BEGIN(semic);
 }
 
-/* used by the bison code */
 void reset_argcount(yyscan_t yyscanner );
 void reset_argcount(yyscan_t yyscanner )
 {

Modified: trunk/pbx/ael/ael.tab.c
===================================================================
--- trunk/pbx/ael/ael.tab.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/pbx/ael/ael.tab.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -412,18 +412,18 @@
 #endif
 
 /* YYFINAL -- State number of the termination state. */
-#define YYFINAL  17
+#define YYFINAL  18
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   584
+#define YYLAST   505
 
 /* YYNTOKENS -- Number of terminals. */
 #define YYNTOKENS  42
 /* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  52
+#define YYNNTS  55
 /* YYNRULES -- Number of rules. */
-#define YYNRULES  151
+#define YYNRULES  149
 /* YYNRULES -- Number of states. */
-#define YYNSTATES  354
+#define YYNSTATES  346
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
@@ -473,110 +473,105 @@
 static const unsigned short int yyprhs[] =
 {
        0,     0,     3,     5,     7,    10,    13,    15,    17,    19,
-      21,    27,    32,    38,    43,    50,    56,    63,    69,    78,
-      86,    94,   101,   106,   110,   112,   115,   118,   119,   125,
-     127,   131,   134,   136,   138,   141,   144,   146,   148,   150,
-     152,   154,   155,   161,   164,   166,   171,   175,   180,   188,
-     197,   199,   202,   205,   206,   212,   213,   219,   234,   245,
-     247,   250,   252,   255,   259,   261,   264,   268,   269,   276,
-     280,   281,   287,   291,   295,   298,   299,   300,   301,   314,
-     315,   322,   325,   329,   333,   336,   339,   340,   346,   349,
-     352,   355,   358,   363,   366,   371,   374,   379,   381,   383,
-     387,   391,   397,   403,   409,   415,   417,   421,   427,   431,
-     437,   441,   442,   448,   452,   453,   457,   461,   464,   466,
-     467,   471,   474,   476,   479,   484,   488,   493,   497,   500,
-     504,   506,   509,   511,   517,   522,   526,   531,   535,   538,
-     542,   545,   548,   563,   574,   578,   594,   606,   609,   611,
-     613,   618
+      21,    23,    25,    31,    36,    43,    49,    58,    66,    74,
+      81,    86,    90,    92,    95,    98,    99,   105,   107,   111,
+     114,   116,   118,   121,   124,   126,   128,   130,   132,   134,
+     135,   141,   144,   146,   151,   155,   160,   168,   177,   179,
+     182,   185,   186,   192,   193,   199,   214,   225,   227,   230,
+     232,   235,   239,   241,   244,   248,   249,   256,   260,   261,
+     267,   271,   275,   278,   279,   280,   281,   294,   295,   302,
+     305,   309,   313,   316,   319,   320,   326,   329,   332,   335,
+     339,   343,   347,   349,   352,   353,   355,   359,   363,   369,
+     375,   381,   387,   389,   393,   399,   403,   409,   413,   414,
+     420,   424,   425,   429,   433,   436,   438,   439,   441,   442,
+     446,   448,   451,   456,   460,   465,   469,   472,   476,   478,
+     481,   483,   489,   494,   498,   503,   507,   510,   514,   517,
+     520,   535,   546,   550,   566,   578,   581,   583,   585,   590
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS. */
 static const yysigned_char yyrhs[] =
 {
       43,     0,    -1,    44,    -1,    45,    -1,    44,    45,    -1,
-      44,     1,    -1,    46,    -1,    47,    -1,    48,    -1,     8,
-      -1,     3,    41,     4,    53,     5,    -1,     3,    41,     4,
-       5,    -1,     3,    36,     4,    53,     5,    -1,     3,    36,
-       4,     5,    -1,    23,     3,    41,     4,    53,     5,    -1,
-      23,     3,    41,     4,     5,    -1,    23,     3,    36,     4,
-      53,     5,    -1,    23,     3,    36,     4,     5,    -1,    15,
-      41,     6,    52,     7,     4,    86,     5,    -1,    15,    41,
-       6,    52,     7,     4,     5,    -1,    15,    41,     6,     7,
-       4,    86,     5,    -1,    15,    41,     6,     7,     4,     5,
-      -1,    16,     4,    49,     5,    -1,    16,     4,     5,    -1,
-      50,    -1,    49,    50,    -1,    49,     1,    -1,    -1,    41,
-       9,    51,    41,     8,    -1,    41,    -1,    52,    10,    41,
-      -1,    52,     1,    -1,    54,    -1,     1,    -1,    53,    54,
-      -1,    53,     1,    -1,    57,    -1,    93,    -1,    88,    -1,
-      89,    -1,    56,    -1,    -1,    41,     9,    55,    41,     8,
+      44,     1,    -1,    47,    -1,    48,    -1,    49,    -1,     8,
+      -1,    41,    -1,    36,    -1,     3,    46,     4,    54,     5,
+      -1,     3,    46,     4,     5,    -1,    23,     3,    46,     4,
+      54,     5,    -1,    23,     3,    46,     4,     5,    -1,    15,
+      41,     6,    53,     7,     4,    89,     5,    -1,    15,    41,
+       6,    53,     7,     4,     5,    -1,    15,    41,     6,     7,
+       4,    89,     5,    -1,    15,    41,     6,     7,     4,     5,
+      -1,    16,     4,    50,     5,    -1,    16,     4,     5,    -1,
+      51,    -1,    50,    51,    -1,    50,     1,    -1,    -1,    41,
+       9,    52,    41,     8,    -1,    41,    -1,    53,    10,    41,
+      -1,    53,     1,    -1,    55,    -1,     1,    -1,    54,    55,
+      -1,    54,     1,    -1,    58,    -1,    96,    -1,    91,    -1,
+      92,    -1,    57,    -1,    -1,    41,     9,    56,    41,     8,
       -1,    41,     1,    -1,     8,    -1,    17,    24,    41,     8,
-      -1,    41,    24,    69,    -1,    30,    41,    24,    69,    -1,
-      31,     6,    65,     7,    41,    24,    69,    -1,    30,    31,
-       6,    65,     7,    41,    24,    69,    -1,    69,    -1,    58,
-      69,    -1,    58,     1,    -1,    -1,    19,     6,    60,    64,
-       7,    -1,    -1,    22,     6,    62,    64,     7,    -1,    20,
-       6,    65,    11,    65,    11,    65,    13,    65,    13,    65,
-      13,    65,     7,    -1,    20,     6,    41,    13,    65,    13,
-      65,    13,    65,     7,    -1,    41,    -1,    41,    41,    -1,
+      -1,    41,    24,    70,    -1,    30,    41,    24,    70,    -1,
+      31,     6,    66,     7,    41,    24,    70,    -1,    30,    31,
+       6,    66,     7,    41,    24,    70,    -1,    70,    -1,    59,
+      70,    -1,    59,     1,    -1,    -1,    19,     6,    61,    65,
+       7,    -1,    -1,    22,     6,    63,    65,     7,    -1,    20,
+       6,    66,    11,    66,    11,    66,    13,    66,    13,    66,
+      13,    66,     7,    -1,    20,     6,    41,    13,    66,    13,
+      66,    13,    66,     7,    -1,    41,    -1,    41,    41,    -1,
       41,    -1,    41,    41,    -1,    41,    41,    41,    -1,    41,
       -1,    41,    41,    -1,    41,    11,    41,    -1,    -1,    18,
-       6,    68,    41,     7,     4,    -1,     4,    58,     5,    -1,
-      -1,    41,     9,    70,    41,     8,    -1,    25,    76,     8,
-      -1,    26,    77,     8,    -1,    41,    11,    -1,    -1,    -1,
-      -1,    32,     6,    71,    41,     8,    72,    41,     8,    73,
-      41,     7,    69,    -1,    -1,    33,     6,    74,    41,     7,
-      69,    -1,    67,     5,    -1,    67,    84,     5,    -1,    12,
-      78,     8,    -1,    82,     8,    -1,    41,     8,    -1,    -1,
-      82,     9,    75,    41,     8,    -1,    28,     8,    -1,    27,
-       8,    -1,    29,     8,    -1,    61,    69,    -1,    61,    69,
-      21,    69,    -1,    59,    69,    -1,    59,    69,    21,    69,
-      -1,    63,    69,    -1,    63,    69,    21,    69,    -1,     8,
-      -1,    66,    -1,    66,    13,    66,    -1,    66,    10,    66,
-      -1,    66,    13,    66,    13,    66,    -1,    66,    10,    66,
-      10,    66,    -1,    36,    13,    66,    13,    66,    -1,    36,
-      10,    66,    10,    66,    -1,    66,    -1,    66,    10,    66,
-      -1,    66,    10,    41,    14,    41,    -1,    66,    14,    66,
-      -1,    66,    10,    41,    14,    36,    -1,    66,    14,    36,
-      -1,    -1,    41,     6,    79,    83,     7,    -1,    41,     6,
-       7,    -1,    -1,    41,    81,     6,    -1,    80,    83,     7,
-      -1,    80,     7,    -1,    64,    -1,    -1,    83,    10,    41,
-      -1,    83,    10,    -1,    85,    -1,    84,    85,    -1,    34,
-      41,    11,    58,    -1,    36,    11,    58,    -1,    35,    41,
-      11,    58,    -1,    34,    41,    11,    -1,    36,    11,    -1,
-      35,    41,    11,    -1,    87,    -1,    86,    87,    -1,    69,
-      -1,    37,    41,     4,    58,     5,    -1,    38,     4,    90,
-       5,    -1,    38,     4,     5,    -1,    39,     4,    90,     5,
-      -1,    39,     4,     5,    -1,    41,     8,    -1,    90,    41,
-       8,    -1,    90,     1,    -1,    92,     8,    -1,    92,    13,
-      65,    11,    65,    11,    65,    13,    65,    13,    65,    13,
-      65,     8,    -1,    92,    13,    41,    13,    65,    13,    65,
-      13,    65,     8,    -1,    91,    92,     8,    -1,    91,    92,
-      13,    65,    11,    65,    11,    65,    13,    65,    13,    65,
-      13,    65,     8,    -1,    91,    92,    13,    41,    13,    65,
-      13,    65,    13,    65,     8,    -1,    91,     1,    -1,    41,
-      -1,    36,    -1,    40,     4,    91,     5,    -1,    40,     4,
-       5,    -1
+       6,    69,    41,     7,     4,    -1,     4,    59,     5,    -1,
+      -1,    41,     9,    71,    41,     8,    -1,    25,    78,     8,
+      -1,    26,    79,     8,    -1,    41,    11,    -1,    -1,    -1,
+      -1,    32,     6,    72,    41,     8,    73,    41,     8,    74,
+      41,     7,    70,    -1,    -1,    33,     6,    75,    41,     7,
+      70,    -1,    68,     5,    -1,    68,    87,     5,    -1,    12,
+      80,     8,    -1,    84,     8,    -1,    41,     8,    -1,    -1,
+      84,     9,    76,    41,     8,    -1,    28,     8,    -1,    27,
+       8,    -1,    29,     8,    -1,    62,    70,    77,    -1,    60,
+      70,    77,    -1,    64,    70,    77,    -1,     8,    -1,    21,
+      70,    -1,    -1,    67,    -1,    67,    13,    67,    -1,    67,
+      10,    67,    -1,    67,    13,    67,    13,    67,    -1,    67,
+      10,    67,    10,    67,    -1,    36,    13,    67,    13,    67,
+      -1,    36,    10,    67,    10,    67,    -1,    67,    -1,    67,
+      10,    67,    -1,    67,    10,    41,    14,    41,    -1,    67,
+      14,    67,    -1,    67,    10,    41,    14,    36,    -1,    67,
+      14,    36,    -1,    -1,    41,     6,    81,    86,     7,    -1,
+      41,     6,     7,    -1,    -1,    41,    83,     6,    -1,    82,
+      86,     7,    -1,    82,     7,    -1,    41,    -1,    -1,    65,
+      -1,    -1,    86,    10,    85,    -1,    88,    -1,    87,    88,
+      -1,    34,    41,    11,    59,    -1,    36,    11,    59,    -1,
+      35,    41,    11,    59,    -1,    34,    41,    11,    -1,    36,
+      11,    -1,    35,    41,    11,    -1,    90,    -1,    89,    90,
+      -1,    70,    -1,    37,    41,     4,    59,     5,    -1,    38,
+       4,    93,     5,    -1,    38,     4,     5,    -1,    39,     4,
+      93,     5,    -1,    39,     4,     5,    -1,    41,     8,    -1,
+      93,    41,     8,    -1,    93,     1,    -1,    95,     8,    -1,
+      95,    13,    66,    11,    66,    11,    66,    13,    66,    13,
+      66,    13,    66,     8,    -1,    95,    13,    41,    13,    66,
+      13,    66,    13,    66,     8,    -1,    94,    95,     8,    -1,
+      94,    95,    13,    66,    11,    66,    11,    66,    13,    66,
+      13,    66,    13,    66,     8,    -1,    94,    95,    13,    41,
+      13,    66,    13,    66,    13,    66,     8,    -1,    94,     1,
+      -1,    41,    -1,    36,    -1,    40,     4,    94,     5,    -1,
+      40,     4,     5,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const unsigned short int yyrline[] =
 {
-       0,   157,   157,   160,   161,   172,   175,   176,   177,   178,
-     181,   185,   188,   192,   195,   200,   204,   209,   215,   218,
-     221,   225,   230,   233,   237,   238,   239,   242,   242,   248,
-     251,   256,   259,   260,   261,   264,   267,   268,   269,   270,
-     271,   272,   272,   276,   277,   280,   285,   289,   294,   299,
-     308,   309,   312,   315,   315,   320,   320,   325,   341,   361,
-     362,   369,   370,   375,   383,   384,   388,   394,   394,   402,
-     405,   405,   409,   412,   415,   418,   419,   420,   418,   426,
-     426,   430,   434,   439,   443,   447,   450,   450,   483,   484,
-     485,   486,   491,   497,   502,   508,   513,   519,   522,   524,
-     529,   534,   541,   548,   555,   564,   569,   574,   581,   588,
-     595,   604,   604,   609,   614,   614,   624,   630,   633,   636,
-     639,   644,   651,   652,   657,   661,   665,   669,   672,   675,
-     680,   681,   686,   687,   693,   696,   700,   703,   707,   710,
-     715,   718,   721,   738,   751,   756,   774,   788,   791,   792,
-     795,   798
+       0,   165,   165,   168,   169,   180,   183,   184,   185,   186,
+     189,   190,   193,   197,   200,   205,   229,   232,   235,   239,
+     244,   247,   251,   252,   253,   256,   256,   262,   265,   269,
+     272,   273,   274,   277,   280,   281,   282,   283,   284,   285,
+     285,   289,   290,   293,   298,   302,   307,   312,   321,   322,
+     325,   328,   328,   333,   333,   338,   354,   374,   375,   382,
+     383,   388,   396,   397,   401,   407,   407,   415,   418,   418,
+     422,   425,   428,   431,   432,   433,   431,   439,   439,   443,
+     447,   452,   456,   460,   463,   463,   496,   497,   498,   499,
+     513,   527,   541,   544,   545,   550,   552,   557,   562,   569,
+     576,   583,   592,   597,   602,   609,   616,   623,   632,   632,
+     637,   642,   642,   652,   658,   661,   662,   665,   668,   671,
+     685,   686,   691,   695,   699,   703,   706,   709,   714,   715,
+     720,   721,   727,   730,   734,   737,   741,   744,   749,   752,
+     755,   772,   785,   790,   808,   823,   826,   827,   830,   833
 };
 #endif
 
@@ -592,15 +587,16 @@
   "KW_RETURN", "KW_BREAK", "KW_CONTINUE", "KW_REGEXTEN", "KW_HINT",
   "KW_FOR", "KW_WHILE", "KW_CASE", "KW_PATTERN", "KW_DEFAULT", "KW_CATCH",
   "KW_SWITCHES", "KW_ESWITCHES", "KW_INCLUDES", "word", "$accept", "file",
-  "objects", "object", "context", "macro", "globals", "global_statements",
-  "global_statement", "@1", "arglist", "elements", "element", "@2",
-  "ignorepat", "extension", "statements", "if_head", "@3", "random_head",
-  "@4", "iftime_head", "word_list", "word3_list", "goto_word",
-  "switch_head", "@5", "statement", "@6", "@7", "@8", "@9", "@10", "@11",
-  "target", "jumptarget", "macro_call", "@12", "application_call_head",
-  "@13", "application_call", "eval_arglist", "case_statements",
-  "case_statement", "macro_statements", "macro_statement", "switches",
-  "eswitches", "switchlist", "includeslist", "includedname", "includes", 0
+  "objects", "object", "word_or_default", "context", "macro", "globals",
+  "global_statements", "global_statement", "@1", "arglist", "elements",
+  "element", "@2", "ignorepat", "extension", "statements", "if_head", "@3",
+  "random_head", "@4", "iftime_head", "word_list", "word3_list",
+  "goto_word", "switch_head", "@5", "statement", "@6", "@7", "@8", "@9",
+  "@10", "@11", "opt_else", "target", "jumptarget", "macro_call", "@12",
+  "application_call_head", "@13", "application_call", "opt_word",
+  "eval_arglist", "case_statements", "case_statement", "macro_statements",
+  "macro_statement", "switches", "eswitches", "switchlist", "includeslist",
+  "includedname", "includes", 0
 };
 #endif
 
@@ -621,42 +617,40 @@
 static const unsigned char yyr1[] =
 {
        0,    42,    43,    44,    44,    44,    45,    45,    45,    45,
-      46,    46,    46,    46,    46,    46,    46,    46,    47,    47,
-      47,    47,    48,    48,    49,    49,    49,    51,    50,    52,
-      52,    52,    53,    53,    53,    53,    54,    54,    54,    54,
-      54,    55,    54,    54,    54,    56,    57,    57,    57,    57,
-      58,    58,    58,    60,    59,    62,    61,    63,    63,    64,
-      64,    65,    65,    65,    66,    66,    66,    68,    67,    69,
-      70,    69,    69,    69,    69,    71,    72,    73,    69,    74,
-      69,    69,    69,    69,    69,    69,    75,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    76,    76,
-      76,    76,    76,    76,    76,    77,    77,    77,    77,    77,
-      77,    79,    78,    78,    81,    80,    82,    82,    83,    83,
-      83,    83,    84,    84,    85,    85,    85,    85,    85,    85,
-      86,    86,    87,    87,    88,    88,    89,    89,    90,    90,
-      90,    91,    91,    91,    91,    91,    91,    91,    92,    92,
-      93,    93
+      46,    46,    47,    47,    47,    47,    48,    48,    48,    48,
+      49,    49,    50,    50,    50,    52,    51,    53,    53,    53,
+      54,    54,    54,    54,    55,    55,    55,    55,    55,    56,
+      55,    55,    55,    57,    58,    58,    58,    58,    59,    59,
+      59,    61,    60,    63,    62,    64,    64,    65,    65,    66,
+      66,    66,    67,    67,    67,    69,    68,    70,    71,    70,
+      70,    70,    70,    72,    73,    74,    70,    75,    70,    70,
+      70,    70,    70,    70,    76,    70,    70,    70,    70,    70,
+      70,    70,    70,    77,    77,    78,    78,    78,    78,    78,
+      78,    78,    79,    79,    79,    79,    79,    79,    81,    80,
+      80,    83,    82,    84,    84,    85,    85,    86,    86,    86,
+      87,    87,    88,    88,    88,    88,    88,    88,    89,    89,
+      90,    90,    91,    91,    92,    92,    93,    93,    93,    94,
+      94,    94,    94,    94,    94,    94,    95,    95,    96,    96
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
 static const unsigned char yyr2[] =
 {
        0,     2,     1,     1,     2,     2,     1,     1,     1,     1,
-       5,     4,     5,     4,     6,     5,     6,     5,     8,     7,
-       7,     6,     4,     3,     1,     2,     2,     0,     5,     1,
-       3,     2,     1,     1,     2,     2,     1,     1,     1,     1,
-       1,     0,     5,     2,     1,     4,     3,     4,     7,     8,
-       1,     2,     2,     0,     5,     0,     5,    14,    10,     1,
-       2,     1,     2,     3,     1,     2,     3,     0,     6,     3,
-       0,     5,     3,     3,     2,     0,     0,     0,    12,     0,
-       6,     2,     3,     3,     2,     2,     0,     5,     2,     2,
-       2,     2,     4,     2,     4,     2,     4,     1,     1,     3,
-       3,     5,     5,     5,     5,     1,     3,     5,     3,     5,
-       3,     0,     5,     3,     0,     3,     3,     2,     1,     0,
-       3,     2,     1,     2,     4,     3,     4,     3,     2,     3,
-       1,     2,     1,     5,     4,     3,     4,     3,     2,     3,
-       2,     2,    14,    10,     3,    15,    11,     2,     1,     1,
-       4,     3
+       1,     1,     5,     4,     6,     5,     8,     7,     7,     6,
+       4,     3,     1,     2,     2,     0,     5,     1,     3,     2,
+       1,     1,     2,     2,     1,     1,     1,     1,     1,     0,
+       5,     2,     1,     4,     3,     4,     7,     8,     1,     2,
+       2,     0,     5,     0,     5,    14,    10,     1,     2,     1,
+       2,     3,     1,     2,     3,     0,     6,     3,     0,     5,
+       3,     3,     2,     0,     0,     0,    12,     0,     6,     2,
+       3,     3,     2,     2,     0,     5,     2,     2,     2,     3,
+       3,     3,     1,     2,     0,     1,     3,     3,     5,     5,
+       5,     5,     1,     3,     5,     3,     5,     3,     0,     5,
+       3,     0,     3,     3,     2,     1,     0,     1,     0,     3,
+       1,     2,     4,     3,     4,     3,     2,     3,     1,     2,
+       1,     5,     4,     3,     4,     3,     2,     3,     2,     2,
+      14,    10,     3,    15,    11,     2,     1,     1,     4,     3
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
@@ -665,279 +659,260 @@
 static const unsigned char yydefact[] =
 {
        0,     0,     9,     0,     0,     0,     0,     0,     3,     6,
-       7,     8,     0,     0,     0,     0,     0,     1,     5,     4,
-       0,     0,     0,    23,     0,     0,    24,     0,     0,    33,
-      13,    44,     0,     0,     0,     0,     0,     0,     0,     0,
-      32,    40,    36,    38,    39,    37,    11,     0,     0,    29,
-       0,    27,    26,    22,    25,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,    43,    41,     0,    35,    12,    34,
-      10,     0,    31,     0,     0,     0,    17,     0,    15,     0,
-       0,     0,     0,    61,     0,   135,     0,     0,   137,     0,
-     151,   149,   148,     0,     0,     0,     0,    97,     0,     0,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-     114,     0,     0,     0,     0,    46,   119,     0,    21,     0,
-     132,     0,   130,     0,    30,     0,    16,    14,    45,     0,
-      47,    62,     0,   138,   140,   134,     0,   136,   147,   150,
-       0,   141,     0,     0,     0,    50,     0,     0,    67,    53,
-       0,    55,     0,    64,    98,     0,   105,     0,    89,    88,
-      90,    75,    79,    85,    70,    74,     0,    93,    91,    95,
-      81,     0,     0,     0,     0,   122,   117,    59,   118,     0,
-      84,    86,     0,    20,   131,    19,     0,    28,     0,    63,
-       0,   139,   144,     0,    61,     0,    42,    52,    69,    51,
-     111,    83,     0,     0,    61,     0,     0,     0,     0,     0,
-      65,     0,     0,    72,     0,     0,    73,     0,     0,     0,
-     115,     0,     0,     0,     0,     0,   128,    82,   123,    60,
-     116,   121,     0,     0,    18,     0,     0,    61,     0,     0,
-       0,   113,   119,     0,     0,     0,     0,     0,     0,     0,
-      66,   100,    99,    64,   106,   110,   108,     0,     0,     0,
-      94,    92,    96,   127,   129,     0,   120,     0,     0,     0,
-      48,     0,     0,     0,     0,     0,     0,    54,     0,     0,
-      56,     0,     0,     0,     0,     0,    76,     0,    71,     0,
-       0,    87,   133,    49,     0,     0,     0,     0,   112,    68,
-       0,     0,   104,   103,   102,   101,   109,   107,     0,    80,
-       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,    77,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,   143,     0,    58,     0,     0,   146,     0,
-       0,     0,     0,     0,     0,     0,    78,     0,     0,     0,
-       0,   142,    57,   145
+       7,     8,    11,    10,     0,     0,     0,     0,     1,     5,
+       4,     0,     0,    21,     0,     0,    22,     0,    31,    13,
+      42,     0,     0,     0,     0,     0,     0,     0,     0,    30,
+      38,    34,    36,    37,    35,     0,    27,     0,    25,    24,
+      20,    23,     0,     0,     0,     0,     0,     0,     0,     0,
+      41,    39,     0,    33,    12,    32,     0,    29,     0,     0,
+       0,    15,     0,     0,     0,     0,    59,     0,   133,     0,
+       0,   135,     0,   149,   147,   146,     0,     0,     0,     0,
+      92,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   111,     0,     0,     0,     0,    44,   118,
+       0,    19,     0,   130,     0,   128,     0,    28,     0,    14,
+      43,     0,    45,    60,     0,   136,   138,   132,     0,   134,
+     145,   148,     0,   139,     0,     0,     0,    48,     0,     0,
+      65,    51,     0,    53,     0,    62,    95,     0,   102,     0,
+      87,    86,    88,    73,    77,    83,    68,    72,     0,    94,
+      94,    94,    79,     0,     0,     0,     0,   120,   114,    57,
+     117,     0,    82,    84,     0,    18,   129,    17,     0,    26,
+       0,    61,     0,   137,   142,     0,    59,     0,    40,    50,
+      67,    49,   108,    81,     0,     0,    59,     0,     0,     0,
+       0,     0,    63,     0,     0,    70,     0,     0,    71,     0,
+       0,     0,   112,     0,    90,    89,    91,     0,     0,   126,
+      80,   121,    58,   113,   116,     0,     0,    16,     0,     0,
+      59,     0,     0,     0,   110,   118,     0,     0,     0,     0,
+       0,     0,     0,    64,    97,    96,    62,   103,   107,   105,
+       0,     0,     0,    93,   125,   127,     0,   115,   119,     0,
+       0,     0,    46,     0,     0,     0,     0,     0,     0,    52,
+       0,     0,    54,     0,     0,     0,     0,     0,    74,     0,
+      69,     0,     0,    85,   131,    47,     0,     0,     0,     0,
+     109,    66,     0,     0,   101,   100,    99,    98,   106,   104,
+       0,    78,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,    75,     0,     0,     0,     0,
+       0,     0,     0,     0,     0,   141,     0,    56,     0,     0,
+     144,     0,     0,     0,     0,     0,     0,     0,    76,     0,
+       0,     0,     0,   140,    55,   143
 };
 
 /* YYDEFGOTO[NTERM-NUM]. */
 static const short int yydefgoto[] =
 {
-      -1,     6,     7,     8,     9,    10,    11,    25,    26,    75,
-      50,    39,    40,    95,    41,    42,   144,   111,   203,   112,
-     206,   113,   178,    84,   154,   114,   202,   145,   219,   217,
-     308,   330,   218,   232,   155,   157,   147,   242,   116,   166,
-     117,   179,   174,   175,   121,   122,    43,    44,    87,    93,
-      94,    45
+      -1,     6,     7,     8,    14,     9,    10,    11,    25,    26,
+      70,    47,    38,    39,    88,    40,    41,   136,   104,   195,
+     105,   198,   106,   170,    77,   146,   107,   194,   137,   211,
+     209,   300,   322,   210,   225,   214,   147,   149,   139,   235,
+     109,   158,   110,   258,   171,   166,   167,   114,   115,    42,
+      43,    80,    86,    87,    44
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -215
+#define YYPACT_NINF -193
 static const short int yypact[] =
 {
-     212,   127,  -215,   -35,    55,    23,    85,   561,  -215,  -215,
-    -215,  -215,    64,   118,   112,    13,   128,  -215,  -215,  -215,
-     157,   208,     2,  -215,   123,    19,  -215,   130,   137,  -215,
-    -215,  -215,   143,    43,   169,   181,   182,   189,   126,   284,
-    -215,  -215,  -215,  -215,  -215,  -215,  -215,   337,   196,  -215,
-     141,  -215,  -215,  -215,  -215,   342,   357,   135,   188,   177,
-     170,    22,    36,    29,  -215,  -215,   527,  -215,  -215,  -215,
-    -215,   423,  -215,   206,   191,   195,  -215,   384,  -215,   399,
-     210,   170,   527,   200,   215,  -215,   242,    51,  -215,    57,
-    -215,  -215,  -215,    12,   158,   220,   527,  -215,   223,   245,
-     250,   259,   262,   148,   229,   263,   265,   266,   269,   275,
-     251,   527,   527,   527,   156,  -215,    26,   145,  -215,   243,
-    -215,   449,  -215,   475,  -215,   279,  -215,  -215,  -215,   281,
-    -215,   252,   253,  -215,  -215,  -215,   283,  -215,  -215,  -215,
-     204,  -215,   254,   291,   278,  -215,   296,   300,  -215,  -215,
-     276,  -215,    69,    40,    95,   310,   114,   313,  -215,  -215,
-    -215,  -215,  -215,  -215,  -215,  -215,   323,   311,   318,   325,
-    -215,   290,   303,   340,   172,  -215,  -215,   307,  -215,   230,
-    -215,  -215,   348,  -215,  -215,  -215,   501,  -215,   312,  -215,
-     331,  -215,  -215,   315,    58,   346,  -215,  -215,  -215,  -215,
-     353,  -215,   320,   322,    76,   355,   322,   229,   229,   328,
-    -215,   229,   229,  -215,   329,   178,  -215,   330,   338,   343,
-    -215,   527,   527,   527,   375,   379,   527,  -215,  -215,  -215,
-    -215,   350,   352,   527,  -215,   370,   527,   108,   388,   170,
-     170,  -215,   322,   395,   396,   170,   170,   398,   354,   393,
-    -215,   400,   404,    50,  -215,  -215,  -215,   401,   405,   403,
-    -215,  -215,  -215,   527,   527,     3,  -215,   410,   308,   527,
-    -215,   170,   170,   406,   397,   235,   409,  -215,   407,   415,
-    -215,   229,   229,   229,   229,   190,  -215,   527,  -215,    68,
-     111,  -215,  -215,  -215,   408,   421,   170,   170,  -215,  -215,
-     170,   170,  -215,  -215,  -215,  -215,  -215,  -215,   392,  -215,
-     170,   170,   431,   433,   434,   445,   426,   446,   450,   170,
-     170,   170,   170,  -215,   170,   170,   428,   452,   455,   453,
-     429,   464,   460,  -215,   170,  -215,   170,   477,  -215,   170,
-     472,   476,   527,   478,   170,   170,  -215,   170,   480,   485,
-     488,  -215,  -215,  -215
+     121,   117,  -193,   -38,    84,    17,    95,   343,  -193,  -193,
+    -193,  -193,  -193,  -193,    98,   122,     9,   117,  -193,  -193,
+    -193,   151,    53,  -193,   110,    14,  -193,   167,  -193,  -193,
+    -193,   102,    39,   182,   200,   214,   218,   184,   204,  -193,
+    -193,  -193,  -193,  -193,  -193,   219,  -193,   196,  -193,  -193,
+    -193,  -193,   280,   183,   221,   207,   187,    23,    44,    20,
+    -193,  -193,   461,  -193,  -193,  -193,   357,  -193,   228,   192,
+     195,  -193,   333,   229,   187,   461,   197,   234,  -193,   238,
+      16,  -193,    46,  -193,  -193,  -193,     5,   147,   206,   461,
+    -193,   211,   249,   250,   251,   252,   125,   220,   254,   256,
+     258,   253,   261,   104,   461,   461,   461,   129,  -193,    60,
+      50,  -193,   230,  -193,   383,  -193,   409,  -193,   262,  -193,
+    -193,   270,  -193,   239,   242,  -193,  -193,  -193,   276,  -193,
+    -193,  -193,   149,  -193,   246,   281,   274,  -193,   263,   282,
+    -193,  -193,   257,  -193,   173,     7,   201,   283,    63,   287,
+    -193,  -193,  -193,  -193,  -193,  -193,  -193,  -193,   298,   292,
+     292,   292,  -193,   273,   284,   306,   138,  -193,  -193,   286,
+    -193,   120,  -193,  -193,   324,  -193,  -193,  -193,   435,  -193,
+     294,  -193,   236,  -193,  -193,   299,    -6,   328,  -193,  -193,
+    -193,  -193,   335,  -193,   307,   308,    40,   336,   308,   220,
+     220,   311,  -193,   220,   220,  -193,   312,   166,  -193,   313,
+     314,   315,  -193,   461,  -193,  -193,  -193,   346,   349,   461,
+    -193,  -193,  -193,  -193,   326,   327,   461,  -193,   354,   461,
+      65,   359,   187,   187,  -193,   308,   373,   374,   187,   187,
+     385,   386,   380,  -193,   387,   391,   109,  -193,  -193,  -193,
+     392,   399,   410,  -193,   461,   461,     4,  -193,  -193,   411,
+     304,   461,  -193,   187,   187,   394,   388,   177,   418,  -193,
+     412,   415,  -193,   220,   220,   220,   220,   174,  -193,   461,
+    -193,    64,   113,  -193,  -193,  -193,   417,   421,   187,   187,
+    -193,  -193,   187,   187,  -193,  -193,  -193,  -193,  -193,  -193,
+     382,  -193,   187,   187,   420,   431,   432,   436,   440,   438,
+     439,   187,   187,   187,   187,  -193,   187,   187,   448,   445,
+     452,   453,   429,   463,   462,  -193,   187,  -193,   187,   467,
+    -193,   187,   464,   465,   461,   469,   187,   187,  -193,   187,
+     476,   478,   483,  -193,  -193,  -193
 };
 
 /* YYPGOTO[NTERM-NUM].  */
 static const short int yypgoto[] =
 {
-    -215,  -215,  -215,   491,  -215,  -215,  -215,  -215,   474,  -215,
-    -215,   104,   -37,  -215,  -215,  -215,  -214,  -215,  -215,  -215,
-    -215,  -215,    60,   -67,  -101,  -215,  -215,   -66,  -215,  -215,
-    -215,  -215,  -215,  -215,  -215,  -215,  -215,  -215,  -215,  -215,
-    -215,   268,  -215,   341,   391,  -120,  -215,  -215,   456,  -215,
-     418,  -215
+    -193,  -193,  -193,   485,   479,  -193,  -193,  -193,  -193,   470,
+    -193,  -193,   446,    37,  -193,  -193,  -193,  -192,  -193,  -193,
+    -193,  -193,  -193,    18,   -63,   -96,  -193,  -193,   -62,  -193,
+    -193,  -193,  -193,  -193,  -193,    35,  -193,  -193,  -193,  -193,
+    -193,  -193,  -193,  -193,   264,  -193,   331,   384,  -112,  -193,
+    -193,   443,  -193,   419,  -193
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -127
+#define YYTABLE_NINF -125
 static const short int yytable[] =
 {
-     115,   184,    69,   156,   197,   120,    14,    96,  -125,    48,
-      69,    97,   265,   138,   129,    98,   130,   139,    23,   268,
-      52,    99,   100,   101,    53,   102,    16,    85,   103,   104,
-     105,   106,   107,   176,    90,   108,   109,  -125,  -125,  -125,
-      69,    88,    69,    49,   110,   167,   168,   169,    91,   289,
-     290,   209,   134,    92,    24,   120,   135,   120,   134,    15,
-      24,   209,   137,    86,   285,    91,   184,   177,    20,   197,
-      92,   239,    96,  -124,    58,   195,    97,    86,   199,   207,
-      98,   210,   208,   205,    59,    17,    99,   100,   101,   245,
-     102,   210,   136,   103,   104,   105,   106,   107,   136,   131,
-     108,   109,  -124,  -124,  -124,   211,   248,   249,   212,   110,
-     251,   252,   197,   254,   256,    96,  -126,   131,    22,    97,
-     120,   271,    21,    98,   214,    47,   238,    64,   215,    99,
-     100,   101,    51,   102,    55,    65,   103,   104,   105,   106,
-     107,    56,    72,   108,   109,  -126,  -126,  -126,    73,   131,
-      66,    74,   110,   180,   181,   260,   261,   262,    29,    77,
-      79,   170,    30,    12,    27,    31,   141,    57,    13,    28,
-     270,   142,   273,   274,    32,    60,    80,   227,   278,   279,
-     302,   303,   304,   305,   152,    61,    62,    33,    34,   153,
-     171,   172,   173,    63,    81,    35,    36,    37,    38,   199,
-      71,    82,   199,   293,   294,   295,   171,   172,   173,    29,
-     123,    83,   192,    46,   255,     1,    31,   193,   128,   153,
-       2,   309,   132,   199,   199,    32,   306,     3,     4,   312,
-     313,   307,   124,   314,   315,     5,   125,   230,    33,    34,
-     231,   131,   298,   317,   318,   231,    35,    36,    37,    38,
-     133,   148,   326,   327,   328,   329,   149,   331,   332,   163,
-     164,   143,   165,   244,   146,   150,   247,   340,   151,   341,
-     153,   158,   343,   159,   160,   161,   346,   348,   349,   197,
-     350,   162,    96,   198,   182,    67,    97,   187,   188,    68,
-      98,   191,    31,   189,   190,   194,    99,   100,   101,   196,
-     102,    32,   200,   103,   104,   105,   106,   107,   201,   197,
-     108,   109,    96,   292,    33,    34,    97,   204,   213,   110,
-      98,   216,    35,    36,    37,    38,    99,   100,   101,   220,
-     102,   224,   221,   103,   104,   105,   106,   107,    67,   222,
-     108,   109,    70,    29,   225,    31,   223,    76,   229,   110,
-      31,   226,   233,   235,    32,   236,   237,   240,    29,    32,
-     241,   243,    78,   177,   281,    31,   246,    33,    34,   250,
-     253,   257,    33,    34,    32,    35,    36,    37,    38,   258,
-      35,    36,    37,    38,   259,    67,   263,    33,    34,   126,
-     264,   266,    31,   267,   269,    35,    36,    37,    38,   272,
-      67,    32,   276,   277,   127,   280,   282,    31,   297,   286,
-     283,   288,   287,   299,    33,    34,    32,   284,   291,   296,
-     300,   310,    35,    36,    37,    38,   301,    96,   118,    33,
-      34,    97,   311,   316,   323,    98,   333,    35,    36,    37,
-      38,    99,   100,   101,   319,   102,   320,   321,   103,   104,
-     105,   106,   107,    96,   183,   108,   109,    97,   322,   324,
-     119,    98,   335,   325,   110,   334,   336,    99,   100,   101,
-     337,   102,   338,   339,   103,   104,   105,   106,   107,    96,
-     185,   108,   109,    97,   342,   344,   119,    98,   351,   345,
-     110,   347,   352,    99,   100,   101,   353,   102,    19,    54,
-     103,   104,   105,   106,   107,    96,   234,   108,   109,    97,
-     275,   140,   119,    98,   186,   228,   110,     0,    89,    99,
-     100,   101,     0,   102,     0,     0,   103,   104,   105,   106,
-     107,    96,     0,   108,   109,    97,     0,     0,   119,    98,
-       0,     0,   110,     0,     0,    99,   100,   101,     0,   102,
-       0,     0,   103,   104,   105,   106,   107,     0,     0,   108,
-     109,    -2,    18,     0,     1,     0,     0,     0,   110,     2,
-       0,     0,     0,     0,     0,     0,     3,     4,     0,     0,
-       0,     0,     0,     0,     5
+     108,   148,   176,    15,   113,   189,   130,   232,    89,  -123,
+     131,   121,    90,   122,    23,    49,    91,   126,   201,    50,
+      17,   127,    92,    93,    94,    83,    95,   256,    78,    96,
+      97,    98,    99,   100,   260,   123,   101,   102,  -123,  -123,
+    -123,    84,   159,   160,   161,   103,    85,   126,   202,    81,
+      24,   129,   113,   238,   113,    24,    84,   128,   172,   173,
+      45,    85,   281,   282,    79,   189,   176,   168,    89,  -122,
+      54,   187,    90,   206,   191,    65,    91,   207,   263,   197,
+      55,   123,    92,    93,    94,    79,    95,   128,    16,    96,
+      97,    98,    99,   100,    46,    18,   101,   102,  -122,  -122,
+    -122,   169,    21,   241,   242,   103,   123,   244,   245,    65,
+     247,   249,   155,   156,   189,   157,   113,    89,  -124,    48,
+     201,    90,   231,   277,     1,    91,    53,   223,    22,     2,
+     224,    92,    93,    94,   162,    95,     3,     4,    96,    97,
+      98,    99,   100,   220,     5,   101,   102,  -124,  -124,  -124,
+     202,   253,    28,    12,   103,   133,    29,   184,    13,    30,
+     134,   144,   185,   163,   164,   165,   145,   262,    31,   265,
+     266,    52,   163,   164,   165,   270,   271,   294,   295,   296,
+     297,    32,    33,   199,   290,    60,   200,   224,    56,    34,
+      35,    36,    37,    61,   191,   215,   216,    67,   191,   285,
+     286,   287,   248,    68,    57,    63,    69,   145,    62,    64,
+     298,   203,    30,   237,   204,   299,   240,   301,    58,   191,
+     191,    31,    59,    66,    73,   304,   305,    74,    76,   306,
+     307,    75,   116,   117,    32,    33,   118,   120,   123,   309,
+     310,   124,    34,    35,    36,    37,   125,   135,   318,   319,
+     320,   321,   138,   323,   324,   140,   141,   142,   143,   153,
+     229,   145,   150,   332,   151,   333,   152,   154,   335,   192,
+     179,   174,   338,   340,   341,   189,   342,   180,    89,   190,
+     181,    28,    90,   182,   183,    71,    91,   186,    30,   188,
+     193,   205,    92,    93,    94,   208,    95,    31,   196,    96,
+      97,    98,    99,   100,   212,   189,   101,   102,    89,   284,
+      32,    33,    90,   213,   217,   103,    91,   219,    34,    35,
+      36,    37,    92,    93,    94,   218,    95,   222,   226,    96,
+      97,    98,    99,   100,    63,   228,   101,   102,   119,   233,
+     230,    30,   234,    -2,    19,   103,     1,   239,   236,   169,
+      31,     2,   243,   246,   250,   251,   252,   254,     3,     4,
+     255,    89,   111,    32,    33,    90,     5,   257,   259,    91,
+     264,    34,    35,    36,    37,    92,    93,    94,   261,    95,
+     268,   269,    96,    97,    98,    99,   100,    89,   175,   101,
+     102,    90,   272,   274,   112,    91,   273,   275,   103,   289,
+     278,    92,    93,    94,   276,    95,   279,   288,    96,    97,
+      98,    99,   100,    89,   177,   101,   102,    90,   280,   283,
+     112,    91,   291,   308,   103,   292,   293,    92,    93,    94,
+     302,    95,   303,   311,    96,    97,    98,    99,   100,    89,
+     227,   101,   102,    90,   312,   313,   112,    91,   315,   314,
+     103,   316,   317,    92,    93,    94,   325,    95,   326,   327,
+      96,    97,    98,    99,   100,    89,   328,   101,   102,    90,
+     329,   330,   112,    91,   334,   331,   103,   336,   337,    92,
+      93,    94,   339,    95,   343,   344,    96,    97,    98,    99,
+     100,   345,    20,   101,   102,    51,    27,   221,    72,   267,
+     178,    82,   103,     0,     0,   132
 };
 
 static const short int yycheck[] =
 {
-      66,   121,    39,   104,     1,    71,    41,     4,     5,     7,
-      47,     8,   226,     1,    81,    12,    82,     5,     5,   233,
-       1,    18,    19,    20,     5,    22,     3,     5,    25,    26,
-      27,    28,    29,     7,     5,    32,    33,    34,    35,    36,
-      77,     5,    79,    41,    41,   111,   112,   113,    36,   263,
-     264,    11,     1,    41,    41,   121,     5,   123,     1,     4,
-      41,    11,     5,    41,    14,    36,   186,    41,     4,     1,
-      41,    13,     4,     5,    31,   142,     8,    41,   144,    10,
-      12,    41,    13,   150,    41,     0,    18,    19,    20,    13,
-      22,    41,    41,    25,    26,    27,    28,    29,    41,    41,
-      32,    33,    34,    35,    36,    10,   207,   208,    13,    41,
-     211,   212,     1,   214,   215,     4,     5,    41,     6,     8,
-     186,    13,     4,    12,    10,    21,   193,     1,    14,    18,
-      19,    20,     9,    22,     4,     9,    25,    26,    27,    28,
-      29,     4,     1,    32,    33,    34,    35,    36,     7,    41,
-      24,    10,    41,     8,     9,   221,   222,   223,     1,    55,
-      56,     5,     5,    36,    36,     8,     8,    24,    41,    41,
-     236,    13,   239,   240,    17,     6,    41,     5,   245,   246,
-     281,   282,   283,   284,    36,     4,     4,    30,    31,    41,
-      34,    35,    36,     4,     6,    38,    39,    40,    41,   265,
-       4,    24,   268,   269,   271,   272,    34,    35,    36,     1,
-       4,    41,     8,     5,    36,     3,     8,    13,     8,    41,
-       8,   287,     7,   289,   290,    17,    36,    15,    16,   296,
-     297,    41,    41,   300,   301,    23,    41,     7,    30,    31,
-      10,    41,     7,   310,   311,    10,    38,    39,    40,    41,
-       8,     6,   319,   320,   321,   322,     6,   324,   325,     8,
-       9,    41,    11,   203,    41,     6,   206,   334,     6,   336,
-      41,     8,   339,     8,     8,     6,   342,   344,   345,     1,
-     347,     6,     4,     5,    41,     1,     8,     8,     7,     5,
-      12,     8,     8,    41,    41,    41,    18,    19,    20,     8,
-      22,    17,     6,    25,    26,    27,    28,    29,     8,     1,
-      32,    33,     4,     5,    30,    31,     8,    41,     8,    41,
-      12,     8,    38,    39,    40,    41,    18,    19,    20,     6,
-      22,    41,    21,    25,    26,    27,    28,    29,     1,    21,
-      32,    33,     5,     1,    41,     8,    21,     5,    41,    41,
-       8,    11,     4,    41,    17,    24,    41,    11,     1,    17,
-       7,    41,     5,    41,    10,     8,    11,    30,    31,    41,
-      41,    41,    30,    31,    17,    38,    39,    40,    41,    41,
-      38,    39,    40,    41,    41,     1,    11,    30,    31,     5,
-      11,    41,     8,    41,    24,    38,    39,    40,    41,    11,
-       1,    17,     7,     7,     5,     7,    13,     8,    11,     8,
-      10,     8,     7,     4,    30,    31,    17,    13,     8,    13,
-      13,    13,    38,    39,    40,    41,    11,     4,     5,    30,
-      31,     8,    11,    41,     8,    12,     8,    38,    39,    40,
-      41,    18,    19,    20,    13,    22,    13,    13,    25,    26,
-      27,    28,    29,     4,     5,    32,    33,     8,    13,    13,
-      37,    12,     7,    13,    41,    13,    13,    18,    19,    20,
-      41,    22,     8,    13,    25,    26,    27,    28,    29,     4,
-       5,    32,    33,     8,     7,    13,    37,    12,     8,    13,
-      41,    13,     7,    18,    19,    20,     8,    22,     7,    25,
-      25,    26,    27,    28,    29,     4,     5,    32,    33,     8,
-     242,    93,    37,    12,   123,   174,    41,    -1,    62,    18,
-      19,    20,    -1,    22,    -1,    -1,    25,    26,    27,    28,
-      29,     4,    -1,    32,    33,     8,    -1,    -1,    37,    12,
-      -1,    -1,    41,    -1,    -1,    18,    19,    20,    -1,    22,
-      -1,    -1,    25,    26,    27,    28,    29,    -1,    -1,    32,
-      33,     0,     1,    -1,     3,    -1,    -1,    -1,    41,     8,
-      -1,    -1,    -1,    -1,    -1,    -1,    15,    16,    -1,    -1,
-      -1,    -1,    -1,    -1,    23
+      62,    97,   114,    41,    66,     1,     1,    13,     4,     5,
+       5,    74,     8,    75,     5,     1,    12,     1,    11,     5,
+       3,     5,    18,    19,    20,     5,    22,   219,     5,    25,
+      26,    27,    28,    29,   226,    41,    32,    33,    34,    35,
+      36,    36,   104,   105,   106,    41,    41,     1,    41,     5,
+      41,     5,   114,    13,   116,    41,    36,    41,     8,     9,
+       7,    41,   254,   255,    41,     1,   178,     7,     4,     5,
+      31,   134,     8,    10,   136,    38,    12,    14,    13,   142,
+      41,    41,    18,    19,    20,    41,    22,    41,     4,    25,
+      26,    27,    28,    29,    41,     0,    32,    33,    34,    35,
+      36,    41,     4,   199,   200,    41,    41,   203,   204,    72,
+     206,   207,     8,     9,     1,    11,   178,     4,     5,     9,
+      11,     8,   185,    14,     3,    12,    24,     7,     6,     8,
+      10,    18,    19,    20,     5,    22,    15,    16,    25,    26,
+      27,    28,    29,     5,    23,    32,    33,    34,    35,    36,
+      41,   213,     1,    36,    41,     8,     5,     8,    41,     8,
+      13,    36,    13,    34,    35,    36,    41,   229,    17,   232,
+     233,     4,    34,    35,    36,   238,   239,   273,   274,   275,
+     276,    30,    31,    10,     7,     1,    13,    10,     6,    38,
+      39,    40,    41,     9,   256,   160,   161,     1,   260,   261,
+     263,   264,    36,     7,     4,     1,    10,    41,    24,     5,
+      36,    10,     8,   195,    13,    41,   198,   279,     4,   281,
+     282,    17,     4,     4,    41,   288,   289,     6,    41,   292,
+     293,    24,     4,    41,    30,    31,    41,     8,    41,   302,
+     303,     7,    38,    39,    40,    41,     8,    41,   311,   312,
+     313,   314,    41,   316,   317,     6,     6,     6,     6,     6,
+      24,    41,     8,   326,     8,   328,     8,     6,   331,     6,
+       8,    41,   334,   336,   337,     1,   339,     7,     4,     5,
+      41,     1,     8,    41,     8,     5,    12,    41,     8,     8,
+       8,     8,    18,    19,    20,     8,    22,    17,    41,    25,
+      26,    27,    28,    29,     6,     1,    32,    33,     4,     5,
+      30,    31,     8,    21,    41,    41,    12,    11,    38,    39,
+      40,    41,    18,    19,    20,    41,    22,    41,     4,    25,
+      26,    27,    28,    29,     1,    41,    32,    33,     5,    11,
+      41,     8,     7,     0,     1,    41,     3,    11,    41,    41,
+      17,     8,    41,    41,    41,    41,    41,    11,    15,    16,
+      11,     4,     5,    30,    31,     8,    23,    41,    41,    12,
+      11,    38,    39,    40,    41,    18,    19,    20,    24,    22,
+       7,     7,    25,    26,    27,    28,    29,     4,     5,    32,
+      33,     8,     7,    13,    37,    12,    10,    10,    41,    11,
+       8,    18,    19,    20,    13,    22,     7,    13,    25,    26,
+      27,    28,    29,     4,     5,    32,    33,     8,     8,     8,
+      37,    12,     4,    41,    41,    13,    11,    18,    19,    20,
+      13,    22,    11,    13,    25,    26,    27,    28,    29,     4,
+       5,    32,    33,     8,    13,    13,    37,    12,     8,    13,
+      41,    13,    13,    18,    19,    20,     8,    22,    13,     7,
+      25,    26,    27,    28,    29,     4,    13,    32,    33,     8,
+      41,     8,    37,    12,     7,    13,    41,    13,    13,    18,
+      19,    20,    13,    22,     8,     7,    25,    26,    27,    28,
+      29,     8,     7,    32,    33,    25,    17,   166,    52,   235,
+     116,    58,    41,    -1,    -1,    86
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
 static const unsigned char yystos[] =
 {
-       0,     3,     8,    15,    16,    23,    43,    44,    45,    46,
-      47,    48,    36,    41,    41,     4,     3,     0,     1,    45,
-       4,     4,     6,     5,    41,    49,    50,    36,    41,     1,
-       5,     8,    17,    30,    31,    38,    39,    40,    41,    53,
-      54,    56,    57,    88,    89,    93,     5,    53,     7,    41,
-      52,     9,     1,     5,    50,     4,     4,    24,    31,    41,
-       6,     4,     4,     4,     1,     9,    24,     1,     5,    54,
-       5,     4,     1,     7,    10,    51,     5,    53,     5,    53,
-      41,     6,    24,    41,    65,     5,    41,    90,     5,    90,
-       5,    36,    41,    91,    92,    55,     4,     8,    12,    18,
-      19,    20,    22,    25,    26,    27,    28,    29,    32,    33,
-      41,    59,    61,    63,    67,    69,    80,    82,     5,    37,
-      69,    86,    87,     4,    41,    41,     5,     5,     8,    65,
-      69,    41,     7,     8,     1,     5,    41,     5,     1,     5,
-      92,     8,    13,    41,    58,    69,    41,    78,     6,     6,
-       6,     6,    36,    41,    66,    76,    66,    77,     8,     8,
-       8,     6,     6,     8,     9,    11,    81,    69,    69,    69,
-       5,    34,    35,    36,    84,    85,     7,    41,    64,    83,
-       8,     9,    41,     5,    87,     5,    86,     8,     7,    41,
-      41,     8,     8,    13,    41,    65,     8,     1,     5,    69,
-       6,     8,    68,    60,    41,    65,    62,    10,    13,    11,
-      41,    10,    13,     8,    10,    14,     8,    71,    74,    70,
-       6,    21,    21,    21,    41,    41,    11,     5,    85,    41,
-       7,    10,    75,     4,     5,    41,    24,    41,    65,    13,
-      11,     7,    79,    41,    64,    13,    11,    64,    66,    66,
-      41,    66,    66,    41,    66,    36,    66,    41,    41,    41,
-      69,    69,    69,    11,    11,    58,    41,    41,    58,    24,
-      69,    13,    11,    65,    65,    83,     7,     7,    65,    65,
-       7,    10,    13,    10,    13,    14,     8,     7,     8,    58,
-      58,     8,     5,    69,    65,    65,    13,    11,     7,     4,
-      13,    11,    66,    66,    66,    66,    36,    41,    72,    69,
-      13,    11,    65,    65,    65,    65,    41,    65,    65,    13,
-      13,    13,    13,     8,    13,    13,    65,    65,    65,    65,
-      73,    65,    65,     8,    13,     7,    13,    41,     8,    13,
-      65,    65,     7,    65,    13,    13,    69,    13,    65,    65,
-      65,     8,     7,     8
+       0,     3,     8,    15,    16,    23,    43,    44,    45,    47,
+      48,    49,    36,    41,    46,    41,     4,     3,     0,     1,
+      45,     4,     6,     5,    41,    50,    51,    46,     1,     5,
+       8,    17,    30,    31,    38,    39,    40,    41,    54,    55,
+      57,    58,    91,    92,    96,     7,    41,    53,     9,     1,
+       5,    51,     4,    24,    31,    41,     6,     4,     4,     4,
+       1,     9,    24,     1,     5,    55,     4,     1,     7,    10,
+      52,     5,    54,    41,     6,    24,    41,    66,     5,    41,
+      93,     5,    93,     5,    36,    41,    94,    95,    56,     4,
+       8,    12,    18,    19,    20,    22,    25,    26,    27,    28,
+      29,    32,    33,    41,    60,    62,    64,    68,    70,    82,
+      84,     5,    37,    70,    89,    90,     4,    41,    41,     5,
+       8,    66,    70,    41,     7,     8,     1,     5,    41,     5,
+       1,     5,    95,     8,    13,    41,    59,    70,    41,    80,
+       6,     6,     6,     6,    36,    41,    67,    78,    67,    79,
+       8,     8,     8,     6,     6,     8,     9,    11,    83,    70,
+      70,    70,     5,    34,    35,    36,    87,    88,     7,    41,
+      65,    86,     8,     9,    41,     5,    90,     5,    89,     8,
+       7,    41,    41,     8,     8,    13,    41,    66,     8,     1,
+       5,    70,     6,     8,    69,    61,    41,    66,    63,    10,
+      13,    11,    41,    10,    13,     8,    10,    14,     8,    72,
+      75,    71,     6,    21,    77,    77,    77,    41,    41,    11,
+       5,    88,    41,     7,    10,    76,     4,     5,    41,    24,
+      41,    66,    13,    11,     7,    81,    41,    65,    13,    11,
+      65,    67,    67,    41,    67,    67,    41,    67,    36,    67,
+      41,    41,    41,    70,    11,    11,    59,    41,    85,    41,
+      59,    24,    70,    13,    11,    66,    66,    86,     7,     7,
+      66,    66,     7,    10,    13,    10,    13,    14,     8,     7,
+       8,    59,    59,     8,     5,    70,    66,    66,    13,    11,
+       7,     4,    13,    11,    67,    67,    67,    67,    36,    41,
+      73,    70,    13,    11,    66,    66,    66,    66,    41,    66,
+      66,    13,    13,    13,    13,     8,    13,    13,    66,    66,
+      66,    66,    74,    66,    66,     8,    13,     7,    13,    41,
+       8,    13,    66,    66,     7,    66,    13,    13,    70,    13,
+      66,    66,    66,     8,     7,     8
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -1313,293 +1288,311 @@
   switch (yytype)
     {
       case 41: /* "word" */
-#line 152 "ael.y"
+#line 160 "ael.y"
         { free((yyvaluep->str));};
-#line 1319 "ael.tab.c"
+#line 1294 "ael.tab.c"
         break;
       case 44: /* "objects" */
-#line 141 "ael.y"
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1327 "ael.tab.c"
+#line 1302 "ael.tab.c"
         break;
       case 45: /* "object" */
-#line 141 "ael.y"
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1335 "ael.tab.c"
+#line 1310 "ael.tab.c"
         break;
-      case 46: /* "context" */
-#line 141 "ael.y"
+      case 46: /* "word_or_default" */
+#line 160 "ael.y"
+        { free((yyvaluep->str));};
+#line 1315 "ael.tab.c"
+        break;
+      case 47: /* "context" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1343 "ael.tab.c"
+#line 1323 "ael.tab.c"
         break;
-      case 47: /* "macro" */
-#line 141 "ael.y"
+      case 48: /* "macro" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1351 "ael.tab.c"
+#line 1331 "ael.tab.c"
         break;
-      case 48: /* "globals" */
-#line 141 "ael.y"
+      case 49: /* "globals" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1359 "ael.tab.c"
+#line 1339 "ael.tab.c"
         break;
-      case 49: /* "global_statements" */
-#line 141 "ael.y"
+      case 50: /* "global_statements" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1367 "ael.tab.c"
+#line 1347 "ael.tab.c"
         break;
-      case 50: /* "global_statement" */
-#line 141 "ael.y"
+      case 51: /* "global_statement" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1375 "ael.tab.c"
+#line 1355 "ael.tab.c"
         break;
-      case 52: /* "arglist" */
-#line 141 "ael.y"
+      case 53: /* "arglist" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1383 "ael.tab.c"
+#line 1363 "ael.tab.c"
         break;
-      case 53: /* "elements" */
-#line 141 "ael.y"
+      case 54: /* "elements" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1391 "ael.tab.c"
+#line 1371 "ael.tab.c"
         break;
-      case 54: /* "element" */
-#line 141 "ael.y"
+      case 55: /* "element" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1399 "ael.tab.c"
+#line 1379 "ael.tab.c"
         break;
-      case 56: /* "ignorepat" */
-#line 141 "ael.y"
+      case 57: /* "ignorepat" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1407 "ael.tab.c"
+#line 1387 "ael.tab.c"
         break;
-      case 57: /* "extension" */
-#line 141 "ael.y"
+      case 58: /* "extension" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1415 "ael.tab.c"
+#line 1395 "ael.tab.c"
         break;
-      case 58: /* "statements" */
-#line 141 "ael.y"
+      case 59: /* "statements" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1423 "ael.tab.c"
+#line 1403 "ael.tab.c"
         break;
-      case 59: /* "if_head" */
-#line 141 "ael.y"
+      case 60: /* "if_head" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1431 "ael.tab.c"
+#line 1411 "ael.tab.c"
         break;
-      case 61: /* "random_head" */
-#line 141 "ael.y"
+      case 62: /* "random_head" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1439 "ael.tab.c"
+#line 1419 "ael.tab.c"
         break;
-      case 63: /* "iftime_head" */
-#line 141 "ael.y"
+      case 64: /* "iftime_head" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1447 "ael.tab.c"
+#line 1427 "ael.tab.c"
         break;
-      case 64: /* "word_list" */
-#line 152 "ael.y"
+      case 65: /* "word_list" */
+#line 160 "ael.y"
         { free((yyvaluep->str));};
-#line 1452 "ael.tab.c"
+#line 1432 "ael.tab.c"
         break;
-      case 65: /* "word3_list" */
-#line 152 "ael.y"
+      case 66: /* "word3_list" */
+#line 160 "ael.y"
         { free((yyvaluep->str));};
-#line 1457 "ael.tab.c"
+#line 1437 "ael.tab.c"
         break;
-      case 66: /* "goto_word" */
-#line 152 "ael.y"
+      case 67: /* "goto_word" */
+#line 160 "ael.y"
         { free((yyvaluep->str));};
-#line 1462 "ael.tab.c"
+#line 1442 "ael.tab.c"
         break;
-      case 67: /* "switch_head" */
-#line 141 "ael.y"
+      case 68: /* "switch_head" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1470 "ael.tab.c"
+#line 1450 "ael.tab.c"
         break;
-      case 69: /* "statement" */
-#line 141 "ael.y"
+      case 70: /* "statement" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1478 "ael.tab.c"
+#line 1458 "ael.tab.c"
         break;
-      case 76: /* "target" */
-#line 141 "ael.y"
+      case 77: /* "opt_else" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1486 "ael.tab.c"
+#line 1466 "ael.tab.c"
         break;
-      case 77: /* "jumptarget" */
-#line 141 "ael.y"
+      case 78: /* "target" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1494 "ael.tab.c"
+#line 1474 "ael.tab.c"
         break;
-      case 78: /* "macro_call" */
-#line 141 "ael.y"
+      case 79: /* "jumptarget" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1502 "ael.tab.c"
+#line 1482 "ael.tab.c"
         break;
-      case 80: /* "application_call_head" */
-#line 141 "ael.y"
+      case 80: /* "macro_call" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1510 "ael.tab.c"
+#line 1490 "ael.tab.c"
         break;
-      case 82: /* "application_call" */
-#line 141 "ael.y"
+      case 82: /* "application_call_head" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1518 "ael.tab.c"
+#line 1498 "ael.tab.c"
         break;
-      case 83: /* "eval_arglist" */
-#line 141 "ael.y"
+      case 84: /* "application_call" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1526 "ael.tab.c"
+#line 1506 "ael.tab.c"
         break;
-      case 84: /* "case_statements" */
-#line 141 "ael.y"
+      case 85: /* "opt_word" */
+#line 160 "ael.y"
+        { free((yyvaluep->str));};
+#line 1511 "ael.tab.c"
+        break;
+      case 86: /* "eval_arglist" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1534 "ael.tab.c"
+#line 1519 "ael.tab.c"
         break;
-      case 85: /* "case_statement" */
-#line 141 "ael.y"
+      case 87: /* "case_statements" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1542 "ael.tab.c"
+#line 1527 "ael.tab.c"
         break;
-      case 86: /* "macro_statements" */
-#line 141 "ael.y"
+      case 88: /* "case_statement" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1550 "ael.tab.c"
+#line 1535 "ael.tab.c"
         break;
-      case 87: /* "macro_statement" */
-#line 141 "ael.y"
+      case 89: /* "macro_statements" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1558 "ael.tab.c"
+#line 1543 "ael.tab.c"
         break;
-      case 88: /* "switches" */
-#line 141 "ael.y"
+      case 90: /* "macro_statement" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1566 "ael.tab.c"
+#line 1551 "ael.tab.c"
         break;
-      case 89: /* "eswitches" */
-#line 141 "ael.y"
+      case 91: /* "switches" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1574 "ael.tab.c"
+#line 1559 "ael.tab.c"
         break;
-      case 90: /* "switchlist" */
-#line 141 "ael.y"
+      case 92: /* "eswitches" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1582 "ael.tab.c"
+#line 1567 "ael.tab.c"
         break;
-      case 91: /* "includeslist" */
-#line 141 "ael.y"
+      case 93: /* "switchlist" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1590 "ael.tab.c"
+#line 1575 "ael.tab.c"
         break;
-      case 92: /* "includedname" */
-#line 152 "ael.y"
+      case 94: /* "includeslist" */
+#line 148 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1583 "ael.tab.c"
+        break;
+      case 95: /* "includedname" */
+#line 160 "ael.y"
         { free((yyvaluep->str));};
-#line 1595 "ael.tab.c"
+#line 1588 "ael.tab.c"
         break;
-      case 93: /* "includes" */
-#line 141 "ael.y"
+      case 96: /* "includes" */
+#line 148 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1603 "ael.tab.c"
+#line 1596 "ael.tab.c"
         break;
 
       default:
@@ -1916,17 +1909,17 @@
   switch (yyn)
     {
         case 2:
-#line 157 "ael.y"
+#line 165 "ael.y"
     { (yyval.pval) = parseio->pval = (yyvsp[0].pval); ;}
     break;
 
   case 3:
-#line 160 "ael.y"
+#line 168 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 4:
-#line 162 "ael.y"
+#line 170 "ael.y"
     {
 			if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {
 				(yyval.pval)=(yyvsp[-1].pval);
@@ -1940,62 +1933,57 @@
     break;
 
   case 5:
-#line 172 "ael.y"
+#line 180 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 6:
-#line 175 "ael.y"
+#line 183 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 7:
-#line 176 "ael.y"
+#line 184 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 8:
-#line 177 "ael.y"
+#line 185 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 9:
-#line 178 "ael.y"
+#line 186 "ael.y"
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
   case 10:
-#line 181 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
+#line 189 "ael.y"
+    { (yyval.str) = (yyvsp[0].str); ;}
     break;
 
   case 11:
-#line 185 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+#line 190 "ael.y"
+    { (yyval.str) = strdup("default"); ;}
     break;
 
   case 12:
-#line 188 "ael.y"
+#line 193 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = strdup("default");
+		(yyval.pval)->u1.str = (yyvsp[-3].str);
 		(yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
     break;
 
   case 13:
-#line 192 "ael.y"
+#line 197 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.str = strdup("default"); ;}
+		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 14:
-#line 195 "ael.y"
+#line 200 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-3].str);
@@ -2004,7 +1992,7 @@
     break;
 
   case 15:
-#line 200 "ael.y"
+#line 205 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2012,200 +2000,182 @@
     break;
 
   case 16:
-#line 204 "ael.y"
+#line 229 "ael.y"
     {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-5]), &(yylsp[0]));
-		(yyval.pval)->u1.str = strdup("default");
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->u3.abstract = 1; ;}
-    break;
-
-  case 17:
-#line 209 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = strdup("default");
-		(yyval.pval)->u3.abstract = 1; ;}
-    break;
-
-  case 18:
-#line 215 "ael.y"
-    {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-7]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-6].str); (yyval.pval)->u2.arglist = (yyvsp[-4].pval); (yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
-  case 19:
-#line 218 "ael.y"
+  case 17:
+#line 232 "ael.y"
     {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-6]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-5].str); (yyval.pval)->u2.arglist = (yyvsp[-3].pval); ;}
     break;
 
-  case 20:
-#line 221 "ael.y"
+  case 18:
+#line 235 "ael.y"
     {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-6]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-5].str);
 		(yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
-  case 21:
-#line 225 "ael.y"
+  case 19:
+#line 239 "ael.y"
     {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str); ;}
     break;
 
-  case 22:
-#line 230 "ael.y"
+  case 20:
+#line 244 "ael.y"
     {
 		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.statements = (yyvsp[-1].pval);;}
     break;
 
-  case 23:
-#line 233 "ael.y"
+  case 21:
+#line 247 "ael.y"
     { /* empty globals is OK */
 		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
-  case 24:
-#line 237 "ael.y"
+  case 22:
+#line 251 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 25:
-#line 238 "ael.y"
+  case 23:
+#line 252 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));;}
     break;
 
-  case 26:
-#line 239 "ael.y"
+  case 24:
+#line 253 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 27:
-#line 242 "ael.y"
+  case 25:
+#line 256 "ael.y"
     { reset_semicount(parseio->scanner); ;}
     break;
 
-  case 28:
-#line 242 "ael.y"
+  case 26:
+#line 256 "ael.y"
     {
 		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
-  case 29:
-#line 248 "ael.y"
+  case 27:
+#line 262 "ael.y"
     {
 		(yyval.pval)= npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[0].str); ;}
     break;
 
-  case 30:
-#line 251 "ael.y"
+  case 28:
+#line 265 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[0]));
 		z->u1.str = (yyvsp[0].str);
-		(yyval.pval)=(yyvsp[-2].pval);
-		linku1((yyval.pval),z); ;}
+		(yyval.pval) = linku1((yyvsp[-2].pval),z); ;}
     break;
 
-  case 31:
-#line 256 "ael.y"
+  case 29:
+#line 269 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 32:
-#line 259 "ael.y"
+  case 30:
+#line 272 "ael.y"
     { (yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 33:
-#line 260 "ael.y"
+  case 31:
+#line 273 "ael.y"
     {(yyval.pval)=0;;}
     break;
 
-  case 34:
-#line 261 "ael.y"
+  case 32:
+#line 274 "ael.y"
     { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 				else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 				else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 35:
-#line 264 "ael.y"
+  case 33:
+#line 277 "ael.y"
     { (yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 36:
-#line 267 "ael.y"
+  case 34:
+#line 280 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 37:
-#line 268 "ael.y"
+  case 35:
+#line 281 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 38:
-#line 269 "ael.y"
+  case 36:
+#line 282 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 39:
-#line 270 "ael.y"
+  case 37:
+#line 283 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 40:
-#line 271 "ael.y"
+  case 38:
+#line 284 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 41:
-#line 272 "ael.y"
+  case 39:
+#line 285 "ael.y"
     { reset_semicount(parseio->scanner); ;}
     break;
 
-  case 42:
-#line 272 "ael.y"
+  case 40:
+#line 285 "ael.y"
     {
 		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
-  case 43:
-#line 276 "ael.y"
+  case 41:
+#line 289 "ael.y"
     {free((yyvsp[-1].str)); (yyval.pval)=0;;}
     break;
 
-  case 44:
-#line 277 "ael.y"
+  case 42:
+#line 290 "ael.y"
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
-  case 45:
-#line 280 "ael.y"
+  case 43:
+#line 293 "ael.y"
     {
 		(yyval.pval) = npval2(PV_IGNOREPAT, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 46:
-#line 285 "ael.y"
+  case 44:
+#line 298 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
     break;
 
-  case 47:
-#line 289 "ael.y"
+  case 45:
+#line 302 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2213,8 +2183,8 @@
 		(yyval.pval)->u4.regexten=1;;}
     break;
 
-  case 48:
-#line 294 "ael.y"
+  case 46:
+#line 307 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-6]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2222,8 +2192,8 @@
 		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
     break;
 
-  case 49:
-#line 299 "ael.y"
+  case 47:
+#line 312 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-7]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2232,49 +2202,49 @@
 		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
     break;
 
-  case 50:
-#line 308 "ael.y"
+  case 48:
+#line 321 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 51:
-#line 309 "ael.y"
+  case 49:
+#line 322 "ael.y"
     {if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 52:
-#line 312 "ael.y"
+  case 50:
+#line 325 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 53:
-#line 315 "ael.y"
+  case 51:
+#line 328 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
-  case 54:
-#line 315 "ael.y"
+  case 52:
+#line 328 "ael.y"
     {
 		(yyval.pval)= npval2(PV_IF, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
     break;
 
-  case 55:
-#line 320 "ael.y"
+  case 53:
+#line 333 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
-  case 56:
-#line 320 "ael.y"
+  case 54:
+#line 333 "ael.y"
     {
 		(yyval.pval) = npval2(PV_RANDOM, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str=(yyvsp[-1].str);;}
     break;
 
-  case 57:
-#line 326 "ael.y"
+  case 55:
+#line 339 "ael.y"
     {
 		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-13]), &(yylsp[-9])); /* XXX really @5 or more ? */
 		(yyval.pval)->u1.list = npval2(PV_WORD, &(yylsp[-11]), &(yylsp[-11]));
@@ -2292,8 +2262,8 @@
 	;}
     break;
 
-  case 58:
-#line 341 "ael.y"
+  case 56:
+#line 354 "ael.y"
     {
 		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-9]), &(yylsp[-5])); /* XXX @5 or greater ? */
 		(yyval.pval)->u1.list = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
@@ -2308,13 +2278,13 @@
 	;}
     break;
 
-  case 59:
-#line 361 "ael.y"
+  case 57:
+#line 374 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 60:
-#line 362 "ael.y"
+  case 58:
+#line 375 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-1].str));
@@ -2322,13 +2292,13 @@
 		prev_word = (yyval.str);;}
     break;
 
-  case 61:
-#line 369 "ael.y"
+  case 59:
+#line 382 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 62:
-#line 370 "ael.y"
+  case 60:
+#line 383 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-1].str));
@@ -2336,8 +2306,8 @@
 		prev_word = (yyval.str);;}
     break;
 
-  case 63:
-#line 375 "ael.y"
+  case 61:
+#line 388 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s%s", (yyvsp[-2].str), (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-2].str));
@@ -2346,97 +2316,97 @@
 		prev_word=(yyval.str);;}
     break;
 
-  case 64:
-#line 383 "ael.y"
+  case 62:
+#line 396 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 65:
-#line 384 "ael.y"
+  case 63:
+#line 397 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-1].str));
 		free((yyvsp[0].str));;}
     break;
 
-  case 66:
-#line 388 "ael.y"
+  case 64:
+#line 401 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s:%s", (yyvsp[-2].str), (yyvsp[0].str));
 		free((yyvsp[-2].str));
 		free((yyvsp[0].str));;}
     break;
 
-  case 67:
-#line 394 "ael.y"
+  case 65:
+#line 407 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
-  case 68:
-#line 394 "ael.y"
+  case 66:
+#line 407 "ael.y"
     {
 		(yyval.pval) = npval2(PV_SWITCH, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 69:
-#line 402 "ael.y"
+  case 67:
+#line 415 "ael.y"
     {
 		(yyval.pval) = npval2(PV_STATEMENTBLOCK, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
-  case 70:
-#line 405 "ael.y"
+  case 68:
+#line 418 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 71:
-#line 405 "ael.y"
+  case 69:
+#line 418 "ael.y"
     {
 		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
-  case 72:
-#line 409 "ael.y"
+  case 70:
+#line 422 "ael.y"
     {
 		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
-  case 73:
-#line 412 "ael.y"
+  case 71:
+#line 425 "ael.y"
     {
 		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
-  case 74:
-#line 415 "ael.y"
+  case 72:
+#line 428 "ael.y"
     {
 		(yyval.pval) = npval2(PV_LABEL, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
     break;
 
-  case 75:
-#line 418 "ael.y"
+  case 73:
+#line 431 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 76:
-#line 419 "ael.y"
+  case 74:
+#line 432 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 77:
-#line 420 "ael.y"
+  case 75:
+#line 433 "ael.y"
     {reset_parencount(parseio->scanner);;}
     break;
 
-  case 78:
-#line 420 "ael.y"
+  case 76:
+#line 433 "ael.y"
     {
 		(yyval.pval) = npval2(PV_FOR, &(yylsp[-11]), &(yylsp[0]));
 		(yyval.pval)->u1.for_init = (yyvsp[-8].str);
@@ -2445,29 +2415,29 @@
 		(yyval.pval)->u4.for_statements = (yyvsp[0].pval);;}
     break;
 
-  case 79:
-#line 426 "ael.y"
+  case 77:
+#line 439 "ael.y"
     {reset_parencount(parseio->scanner);;}
     break;
 
-  case 80:
-#line 426 "ael.y"
+  case 78:
+#line 439 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WHILE, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
     break;
 
-  case 81:
-#line 430 "ael.y"
+  case 79:
+#line 443 "ael.y"
     {
 		(yyval.pval)=(yyvsp[-1].pval);
 		(yyval.pval)->endline = (yylsp[0]).last_line;
 		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
-  case 82:
-#line 434 "ael.y"
+  case 80:
+#line 447 "ael.y"
     {
 		(yyval.pval)=(yyvsp[-2].pval);
 		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
@@ -2475,36 +2445,36 @@
 		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
-  case 83:
-#line 439 "ael.y"
+  case 81:
+#line 452 "ael.y"
     {
 		(yyval.pval) = (yyvsp[-1].pval);
 		(yyval.pval)->endline = (yylsp[-1]).last_line;
 		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
     break;
 
-  case 84:
-#line 443 "ael.y"
+  case 82:
+#line 456 "ael.y"
     {
 		(yyval.pval) = (yyvsp[-1].pval);
 		(yyval.pval)->endline = (yylsp[0]).last_line;
 		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
-  case 85:
-#line 447 "ael.y"
+  case 83:
+#line 460 "ael.y"
     {
 		(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 86:
-#line 450 "ael.y"
+  case 84:
+#line 463 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 87:
-#line 450 "ael.y"
+  case 85:
+#line 463 "ael.y"
     {
 		char *bufx;
 		int tot=0;
@@ -2540,91 +2510,74 @@
 	;}
     break;
 
-  case 88:
-#line 483 "ael.y"
+  case 86:
+#line 496 "ael.y"
     { (yyval.pval) = npval2(PV_BREAK, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
-  case 89:
-#line 484 "ael.y"
+  case 87:
+#line 497 "ael.y"
     { (yyval.pval) = npval2(PV_RETURN, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
-  case 90:
-#line 485 "ael.y"
+  case 88:
+#line 498 "ael.y"
     { (yyval.pval) = npval2(PV_CONTINUE, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
-  case 91:
-#line 486 "ael.y"
+  case 89:
+#line 499 "ael.y"
     {
-		(yyval.pval)=(yyvsp[-1].pval);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);
-		(yyval.pval)->endline = (yylsp[0]).last_line;
-		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
+		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[-1]).last_line;
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);
+		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
     break;
 
-  case 92:
-#line 491 "ael.y"
+  case 90:
+#line 513 "ael.y"
     {
-		(yyval.pval)=(yyvsp[-3].pval);
-		(yyval.pval)->u2.statements = (yyvsp[-2].pval);
-		(yyval.pval)->endline = (yylsp[-2]).last_line;
-		(yyval.pval)->endcol = (yylsp[-2]).last_column;
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[-1]).last_line;
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);
+		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
     break;
 
-  case 93:
-#line 497 "ael.y"
+  case 91:
+#line 527 "ael.y"
     {
-		(yyval.pval)=(yyvsp[-1].pval);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);
-		(yyval.pval)->endline = (yylsp[0]).last_line;
-		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
+		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->endline = (yylsp[-1]).last_line;
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);
+		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
     break;
 
-  case 94:
-#line 502 "ael.y"
-    {
-		(yyval.pval)=(yyvsp[-3].pval);
-		(yyval.pval)->u2.statements = (yyvsp[-2].pval);
-		(yyval.pval)->endline = (yylsp[-2]).last_line;
-		(yyval.pval)->endcol = (yylsp[-2]).last_column;
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+  case 92:
+#line 541 "ael.y"
+    { (yyval.pval)=0; ;}
     break;
 
-  case 95:
-#line 508 "ael.y"
-    {
-		(yyval.pval)=(yyvsp[-1].pval);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);
-		(yyval.pval)->endline = (yylsp[0]).last_line;
-		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
+  case 93:
+#line 544 "ael.y"
+    { (yyval.pval) = (yyvsp[0].pval); ;}
     break;
 
-  case 96:
-#line 513 "ael.y"
-    {
-		(yyval.pval)=(yyvsp[-3].pval);
-		(yyval.pval)->u2.statements = (yyvsp[-2].pval);
-		(yyval.pval)->endline = (yylsp[-2]).last_line;
-		(yyval.pval)->endcol = (yylsp[-2]).last_column;
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+  case 94:
+#line 545 "ael.y"
+    { (yyval.pval) = NULL ; ;}
     break;
 
-  case 97:
-#line 519 "ael.y"
-    { (yyval.pval)=0; ;}
-    break;
-
-  case 98:
-#line 522 "ael.y"
+  case 95:
+#line 550 "ael.y"
     { (yyval.pval) = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[0].str);;}
     break;
 
-  case 99:
-#line 524 "ael.y"
+  case 96:
+#line 552 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2632,8 +2585,8 @@
 		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
     break;
 
-  case 100:
-#line 529 "ael.y"
+  case 97:
+#line 557 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2641,8 +2594,8 @@
 		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
     break;
 
-  case 101:
-#line 534 "ael.y"
+  case 98:
+#line 562 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
@@ -2652,8 +2605,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
-  case 102:
-#line 541 "ael.y"
+  case 99:
+#line 569 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
@@ -2663,8 +2616,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
-  case 103:
-#line 548 "ael.y"
+  case 100:
+#line 576 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = strdup("default");
@@ -2674,8 +2627,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
-  case 104:
-#line 555 "ael.y"
+  case 101:
+#line 583 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = strdup("default");
@@ -2685,8 +2638,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
     break;
 
-  case 105:
-#line 564 "ael.y"
+  case 102:
+#line 592 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[0].str);
@@ -2694,8 +2647,8 @@
 		(yyval.pval)->next->u1.str = strdup("1");;}
     break;
 
-  case 106:
-#line 569 "ael.y"
+  case 103:
+#line 597 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2703,8 +2656,8 @@
 		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
     break;
 
-  case 107:
-#line 574 "ael.y"
+  case 104:
+#line 602 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = (yyvsp[0].str);
@@ -2714,8 +2667,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 108:
-#line 581 "ael.y"
+  case 105:
+#line 609 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = (yyvsp[0].str);
@@ -2725,8 +2678,8 @@
 		(yyval.pval)->next->next->u1.str = strdup("1"); ;}
     break;
 
-  case 109:
-#line 588 "ael.y"
+  case 106:
+#line 616 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = strdup("default");
@@ -2736,8 +2689,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 110:
-#line 595 "ael.y"
+  case 107:
+#line 623 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = strdup("default");
@@ -2747,13 +2700,13 @@
 		(yyval.pval)->next->next->u1.str = strdup("1"); ;}
     break;
 
-  case 111:
-#line 604 "ael.y"
+  case 108:
+#line 632 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
-  case 112:
-#line 604 "ael.y"
+  case 109:
+#line 632 "ael.y"
     {
 		/* XXX original code had @2 but i think we need @5 */
 		(yyval.pval) = npval2(PV_MACRO_CALL, &(yylsp[-4]), &(yylsp[0]));
@@ -2761,20 +2714,20 @@
 		(yyval.pval)->u2.arglist = (yyvsp[-1].pval);;}
     break;
 
-  case 113:
-#line 609 "ael.y"
+  case 110:
+#line 637 "ael.y"
     {
 		(yyval.pval)= npval2(PV_MACRO_CALL, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 114:
-#line 614 "ael.y"
+  case 111:
+#line 642 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
-  case 115:
-#line 614 "ael.y"
+  case 112:
+#line 642 "ael.y"
     {
 		if (strcasecmp((yyvsp[-2].str),"goto") == 0) {
 			(yyval.pval)= npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
@@ -2785,8 +2738,8 @@
 		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 116:
-#line 624 "ael.y"
+  case 113:
+#line 652 "ael.y"
     {(yyval.pval) = (yyvsp[-2].pval);
  		if( (yyval.pval)->type == PV_GOTO )
 			(yyval.pval)->u1.list = (yyvsp[-1].pval);
@@ -2795,27 +2748,37 @@
  		(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
-  case 117:
-#line 630 "ael.y"
+  case 114:
+#line 658 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
     break;
 
-  case 118:
-#line 633 "ael.y"
+  case 115:
+#line 661 "ael.y"
+    { (yyval.str) = (yyvsp[0].str) ;}
+    break;
+
+  case 116:
+#line 662 "ael.y"
+    { (yyval.str) = strdup(""); ;}
+    break;
+
+  case 117:
+#line 665 "ael.y"
     { 
 		(yyval.pval)= npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[0].str);;}
     break;
 
-  case 119:
-#line 636 "ael.y"
+  case 118:
+#line 668 "ael.y"
     {
 		(yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
 		(yyval.pval)->u1.str = strdup(""); ;}
     break;
 
-  case 120:
-#line 639 "ael.y"
+  case 119:
+#line 671 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
 		(yyval.pval) = (yyvsp[-2].pval);
@@ -2823,132 +2786,123 @@
 		z->u1.str = (yyvsp[0].str);;}
     break;
 
-  case 121:
-#line 644 "ael.y"
-    {
-		pval *z = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval) = (yyvsp[-1].pval);
-		linku1((yyvsp[-1].pval),z);
-		z->u1.str = strdup("");;}
-    break;
-
-  case 122:
-#line 651 "ael.y"
+  case 120:
+#line 685 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 123:
-#line 652 "ael.y"
+  case 121:
+#line 686 "ael.y"
     { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 124:
-#line 657 "ael.y"
+  case 122:
+#line 691 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CASE, &(yylsp[-3]), &(yylsp[-1])); /* XXX 3 or 4 ? */
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
-  case 125:
-#line 661 "ael.y"
+  case 123:
+#line 695 "ael.y"
     {
 		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = NULL;
 		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
-  case 126:
-#line 665 "ael.y"
+  case 124:
+#line 699 "ael.y"
     {
 		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-3]), &(yylsp[0])); /* XXX at 3 or @4 ? */
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
-  case 127:
-#line 669 "ael.y"
+  case 125:
+#line 703 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CASE, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 128:
-#line 672 "ael.y"
+  case 126:
+#line 706 "ael.y"
     {
 		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = NULL;;}
     break;
 
-  case 129:
-#line 675 "ael.y"
+  case 127:
+#line 709 "ael.y"
     {
 		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 130:
-#line 680 "ael.y"
+  case 128:
+#line 714 "ael.y"
     {(yyval.pval) = (yyvsp[0].pval);;}
     break;
 
-  case 131:
-#line 681 "ael.y"
+  case 129:
+#line 715 "ael.y"
     { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 132:
-#line 686 "ael.y"
+  case 130:
+#line 720 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 133:
-#line 687 "ael.y"
+  case 131:
+#line 721 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CATCH, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-3].str);
 		(yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
     break;
 
-  case 134:
-#line 693 "ael.y"
+  case 132:
+#line 727 "ael.y"
     {
 		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
-  case 135:
-#line 696 "ael.y"
+  case 133:
+#line 730 "ael.y"
     {
 		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
-  case 136:
-#line 700 "ael.y"
+  case 134:
+#line 734 "ael.y"
     {
 		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
-  case 137:
-#line 703 "ael.y"
+  case 135:
+#line 737 "ael.y"
     { /* empty switch list OK */
 		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
-  case 138:
-#line 707 "ael.y"
+  case 136:
+#line 741 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 139:
-#line 710 "ael.y"
+  case 137:
+#line 744 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
 		z->u1.str = (yyvsp[-1].str);
@@ -2956,20 +2910,20 @@
 		linku1((yyval.pval),z); ;}
     break;
 
-  case 140:
-#line 715 "ael.y"
+  case 138:
+#line 749 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 141:
-#line 718 "ael.y"
+  case 139:
+#line 752 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 142:
-#line 722 "ael.y"
+  case 140:
+#line 756 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-13]), &(yylsp[-12]));
 		(yyval.pval)->u1.str = (yyvsp[-13].str);
@@ -2988,8 +2942,8 @@
 	;}
     break;
 
-  case 143:
-#line 738 "ael.y"
+  case 141:
+#line 772 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-9]), &(yylsp[-8]));
 		(yyval.pval)->u1.str = (yyvsp[-9].str);
@@ -3005,17 +2959,17 @@
 	;}
     break;
 
-  case 144:
-#line 751 "ael.y"
+  case 142:
+#line 785 "ael.y"
     {
-		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0])); /* XXX don't we need @1- at 4 ?*/
+		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0])); /* XXX don't we need @1- at 3 ?*/
 		(yyval.pval)=(yyvsp[-2].pval);
 		z->u1.str = (yyvsp[-1].str);
 		linku1((yyval.pval),z); ;}
     break;
 
-  case 145:
-#line 757 "ael.y"
+  case 143:
+#line 791 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-13]), &(yylsp[-12]));
 		(yyval.pval)=(yyvsp[-14].pval); z->u1.str = (yyvsp[-13].str);
@@ -3035,14 +2989,15 @@
 	;}
     break;
 
-  case 146:
-#line 774 "ael.y"
+  case 144:
+#line 808 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-9]), &(yylsp[-8]));
 		(yyval.pval)=(yyvsp[-10].pval);
-		z->u1.str = (yyvsp[-9].str); linku1((yyval.pval),z);
-		z->u2.arglist = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
+		linku1((yyval.pval),z);
 		(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
+		z->u1.str = (yyvsp[-9].str);
+		z->u2.arglist = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));	/* XXX is this correct ? */
 		z->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
 		z->u2.arglist->next->u1.str = (yyvsp[-5].str);
 		z->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
@@ -3053,30 +3008,30 @@
 	;}
     break;
 
-  case 147:
-#line 788 "ael.y"
+  case 145:
+#line 823 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 148:
-#line 791 "ael.y"
+  case 146:
+#line 826 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 149:
-#line 792 "ael.y"
+  case 147:
+#line 827 "ael.y"
     {(yyval.str)=strdup("default");;}
     break;
 
-  case 150:
-#line 795 "ael.y"
+  case 148:
+#line 830 "ael.y"
     {
 		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
-  case 151:
-#line 798 "ael.y"
+  case 149:
+#line 833 "ael.y"
     {
 		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-2]), &(yylsp[0]));;}
     break;
@@ -3086,7 +3041,7 @@
     }
 
 /* Line 1126 of yacc.c.  */
-#line 3090 "ael.tab.c"
+#line 3045 "ael.tab.c"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -3361,7 +3316,7 @@
 }
 
 
-#line 803 "ael.y"
+#line 838 "ael.y"
 
 
 static char *token_equivs1[] =

Modified: trunk/pbx/ael/ael.y
===================================================================
--- trunk/pbx/ael/ael.y	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/pbx/ael/ael.y	2006-04-30 14:53:08 UTC (rev 13)
@@ -73,6 +73,8 @@
 %token KW_FOR KW_WHILE KW_CASE KW_PATTERN KW_DEFAULT KW_CATCH KW_SWITCHES KW_ESWITCHES
 %token KW_INCLUDES
 
+%right BAR COMMA
+
 %token <str> word
 
 %type <pval>includes
@@ -109,7 +111,12 @@
 %type <pval>object
 %type <pval>objects
 %type <pval>file
+/* XXX lr changes */
+%type <pval>opt_else
 
+%type <str>opt_word
+%type <str>word_or_default
+
 %type <str>goto_word
 %type <str>word_list
 %type <str>word3_list
@@ -148,8 +155,9 @@
 		if_head random_head iftime_head statements extension
 		ignorepat element elements arglist global_statement
 		global_statements globals macro context object objects
+		opt_else
 
-%destructor { free($$);}  word word_list goto_word word3_list includedname
+%destructor { free($$);}  word word_list goto_word word3_list includedname opt_word word_or_default
 
 
 %%
@@ -178,38 +186,44 @@
 	| SEMI  {$$=0;/* allow older docs to be read */}
 	;
 
-context : KW_CONTEXT word LC elements RC {
+word_or_default : word { $$ = $1; }
+	| KW_DEFAULT { $$ = strdup("default"); }
+	;
+
+context : KW_CONTEXT word_or_default LC elements RC {
 		$$ = npval2(PV_CONTEXT, &@1, &@5);
 		$$->u1.str = $2;
 		$$->u2.statements = $4; }
-	| KW_CONTEXT word LC RC /* empty context OK */ {
+	| KW_CONTEXT word_or_default LC RC /* empty context OK */ {
 		$$ = npval2(PV_CONTEXT, &@1, &@4);
 		$$->u1.str = $2; }
-	| KW_CONTEXT KW_DEFAULT LC elements RC {
-		$$ = npval2(PV_CONTEXT, &@1, &@5);
-		$$->u1.str = strdup("default");
-		$$->u2.statements = $4; }
-	| KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {
-		$$ = npval2(PV_CONTEXT, &@1, &@4);
-		$$->u1.str = strdup("default"); }
-	| KW_ABSTRACT KW_CONTEXT word LC elements RC {
+	| KW_ABSTRACT KW_CONTEXT word_or_default LC elements RC {
 		$$ = npval2(PV_CONTEXT, &@1, &@6);
 		$$->u1.str = $3;
 		$$->u2.statements = $5;
 		$$->u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT word LC RC /* empty context OK */ {
+	| KW_ABSTRACT KW_CONTEXT word_or_default LC RC /* empty context OK */ {
 		$$ = npval2(PV_CONTEXT, &@1, &@5);
 		$$->u1.str = $3;
 		$$->u3.abstract = 1; }
+/*
+	| KW_CONTEXT KW_DEFAULT LC elements RC {
+		$$ = npval2(PV_CONTEXT, &@1, &@5);
+		$$->u1.str = strdup("default");
+		$$->u2.statements = $4; }
+	| KW_CONTEXT KW_DEFAULT LC RC {
+		$$ = npval2(PV_CONTEXT, &@1, &@4);
+		$$->u1.str = strdup("default"); }
 	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC elements RC  {
 		$$ = npval2(PV_CONTEXT, &@1, &@6);
 		$$->u1.str = strdup("default");
 		$$->u2.statements = $5;
 		$$->u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {
+	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC {
 		$$ = npval2(PV_CONTEXT, &@1, &@5);
 		$$->u1.str = strdup("default");
 		$$->u3.abstract = 1; }
+*/
 	;
 
 macro : KW_MACRO word LP arglist RP LC macro_statements RC {
@@ -251,8 +265,7 @@
 	| arglist COMMA word {
 		pval *z = npval2(PV_WORD, &@1, &@3);
 		z->u1.str = $3;
-		$$=$1;
-		linku1($$,z); }
+		$$ = linku1($1,z); }
 	| arglist error {$$=$1;}
 	;
 
@@ -483,42 +496,57 @@
 	| KW_BREAK SEMI { $$ = npval2(PV_BREAK, &@1, &@2); }
 	| KW_RETURN SEMI { $$ = npval2(PV_RETURN, &@1, &@2); }
 	| KW_CONTINUE SEMI { $$ = npval2(PV_CONTINUE, &@1, &@2); }
-	| random_head statement {
+	| random_head statement opt_else {
 		$$=$1;
 		$$->u2.statements = $2;
 		$$->endline = @2.last_line;
+		$$->u3.else_statements = $3;
 		$$->endcol = @2.last_column;}
+/*
 	| random_head statement KW_ELSE statement {
 		$$=$1;
 		$$->u2.statements = $2;
 		$$->endline = @2.last_line;
 		$$->endcol = @2.last_column;
 		$$->u3.else_statements = $4;}
-	| if_head statement {
+*/
+	| if_head statement opt_else {
 		$$=$1;
 		$$->u2.statements = $2;
 		$$->endline = @2.last_line;
+		$$->u3.else_statements = $3;
 		$$->endcol = @2.last_column;}
+/*
 	| if_head statement KW_ELSE statement {
 		$$=$1;
 		$$->u2.statements = $2;
 		$$->endline = @2.last_line;
 		$$->endcol = @2.last_column;
-		$$->u3.else_statements = $4;}
-	| iftime_head statement {
+	$$->u3.else_statements = $4;}
+*/
+	| iftime_head statement opt_else {
 		$$=$1;
 		$$->u2.statements = $2;
 		$$->endline = @2.last_line;
+		$$->u3.else_statements = $3;
 		$$->endcol = @2.last_column;}
+/*
 	| iftime_head statement KW_ELSE statement {
 		$$=$1;
 		$$->u2.statements = $2;
 		$$->endline = @2.last_line;
 		$$->endcol = @2.last_column;
 		$$->u3.else_statements = $4;}
+*/
 	| SEMI { $$=0; }
 	;
 
+opt_else : KW_ELSE statement { $$ = $2; }
+	| { $$ = NULL ; }
+
+/* XXX unused */
+bar_or_comma: BAR | COMMA ;
+
 target : goto_word { $$ = npval2(PV_WORD, &@1, &@1);
 		$$->u1.str = $1;}
 	| goto_word BAR goto_word {
@@ -630,22 +658,28 @@
 	| application_call_head RP {$$=$1;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
 	;
 
+opt_word : word { $$ = $1 }
+	| { $$ = strdup(""); }
+	;
+
 eval_arglist :  word_list { 
 		$$= npval2(PV_WORD, &@1, &@1);
 		$$->u1.str = $1;}
 	| /*nothing! */   {
 		$$= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
 		$$->u1.str = strdup(""); }
-	| eval_arglist COMMA  word {
+	| eval_arglist COMMA  opt_word {
 		pval *z = npval2(PV_WORD, &@3, &@3);
 		$$ = $1;
 		linku1($1,z);
 		z->u1.str = $3;}
+/*
 	| eval_arglist COMMA {
 		pval *z = npval2(PV_WORD, &@2, &@2);
 		$$ = $1;
 		linku1($1,z);
 		z->u1.str = strdup("");}
+*/
 	;
 
 case_statements: case_statement {$$=$1;}
@@ -749,7 +783,7 @@
 		prev_word=0;
 	}
 	| includeslist includedname SEMI {
-		pval *z = npval2(PV_WORD, &@2, &@3); /* XXX don't we need @1- at 4 ?*/
+		pval *z = npval2(PV_WORD, &@2, &@3); /* XXX don't we need @1- at 3 ?*/
 		$$=$1;
 		z->u1.str = $2;
 		linku1($$,z); }
@@ -774,9 +808,10 @@
 	| includeslist includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
 		pval *z = npval2(PV_WORD, &@2, &@3);
 		$$=$1;
-		z->u1.str = $2; linku1($$,z);
-		z->u2.arglist = npval2(PV_WORD, &@4, &@4);
+		linku1($$,z);
 		$$->u2.arglist->u1.str = $4;
+		z->u1.str = $2;
+		z->u2.arglist = npval2(PV_WORD, &@4, &@4);	/* XXX is this correct ? */
 		z->u2.arglist->next = npval2(PV_WORD, &@6, &@6);
 		z->u2.arglist->next->u1.str = $6;
 		z->u2.arglist->next->next = npval2(PV_WORD, &@8, &@8);

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/pbx/ael/ael_lex.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -2781,7 +2781,19 @@
 }
 
 
-/* used by the bison code */
+/*
+ * The following three functions, reset_*, are used in the bison
+ * code to switch context. As a consequence, we need to
+ * declare them global and add a prototype so that the
+ * compiler does not complain.
+ *
+ * NOTE: yyg is declared because it is used in the BEGIN macros,
+ * though that should be hidden as the macro changes
+ * depending on the flex options that we use - in particular,
+ * %reentrant changes the way the macro is declared;
+ * without %reentrant, BEGIN uses yystart instead of yyg
+ */
+
 void reset_parencount(yyscan_t yyscanner );
 void reset_parencount(yyscan_t yyscanner )
 {
@@ -2793,7 +2805,6 @@
 	BEGIN(paren);
 }
 
-/* used by the bison code */
 void reset_semicount(yyscan_t yyscanner );
 void reset_semicount(yyscan_t yyscanner )
 {
@@ -2802,7 +2813,6 @@
 	BEGIN(semic);
 }
 
-/* used by the bison code */
 void reset_argcount(yyscan_t yyscanner );
 void reset_argcount(yyscan_t yyscanner )
 {

Modified: trunk/pbx/pbx_dundi.c
===================================================================
--- trunk/pbx/pbx_dundi.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/pbx/pbx_dundi.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -79,23 +79,20 @@
 
 #define MAX_PACKET_SIZE 8192
 
-extern char ast_config_AST_KEY_DIR[];
-
-
 #define DUNDI_MODEL_INBOUND		(1 << 0)
 #define DUNDI_MODEL_OUTBOUND	(1 << 1)
 #define DUNDI_MODEL_SYMMETRIC	(DUNDI_MODEL_INBOUND | DUNDI_MODEL_OUTBOUND)
 
-/* Keep times of last 10 lookups */
+/*! Keep times of last 10 lookups */
 #define DUNDI_TIMING_HISTORY	10
 
-#define FLAG_ISREG		(1 << 0)		/* Transaction is register request */
-#define FLAG_DEAD		(1 << 1)		/* Transaction is dead */
-#define FLAG_FINAL		(1 << 2)		/* Transaction has final message sent */
-#define FLAG_ISQUAL		(1 << 3)		/* Transaction is a qualification */
-#define FLAG_ENCRYPT	(1 << 4)		/* Transaction is encrypted wiht ECX/DCX */
-#define FLAG_SENDFULLKEY	(1 << 5)		/* Send full key on transaction */
-#define FLAG_STOREHIST	(1 << 6)		/* Record historic performance */
+#define FLAG_ISREG       (1 << 0)   /*!< Transaction is register request */
+#define FLAG_DEAD        (1 << 1)   /*!< Transaction is dead */
+#define FLAG_FINAL       (1 << 2)   /*!< Transaction has final message sent */
+#define FLAG_ISQUAL      (1 << 3)   /*!< Transaction is a qualification */
+#define FLAG_ENCRYPT     (1 << 4)   /*!< Transaction is encrypted wiht ECX/DCX */
+#define FLAG_SENDFULLKEY (1 << 5)   /*!< Send full key on transaction */
+#define FLAG_STOREHIST   (1 << 6)   /*!< Record historic performance */
 
 #define DUNDI_FLAG_INTERNAL_NOPARTIAL (1 << 17)
 
@@ -166,31 +163,31 @@
 struct dundi_request;
 
 struct dundi_transaction {
-	struct sockaddr_in addr;	/* Other end of transaction */
-	struct timeval start;		/* When this transaction was created */
+	struct sockaddr_in addr;               /*!< Other end of transaction */
+	struct timeval start;                  /*!< When this transaction was created */
 	dundi_eid eids[DUNDI_MAX_STACK + 1];
-	int eidcount;				/* Number of eids in eids */
-	dundi_eid us_eid;			/* Our EID, to them */
-	dundi_eid them_eid;			/* Their EID, to us */
-	aes_encrypt_ctx	ecx;		/* AES 128 Encryption context */
-	aes_decrypt_ctx	dcx;		/* AES 128 Decryption context */
-	unsigned int flags;				/* Has final packet been sent */
-	int ttl;					/* Remaining TTL for queries on this one */
-	int thread;					/* We have a calling thread */
-	int retranstimer;			/* How long to wait before retransmissions */
-	int autokillid;				/* ID to kill connection if answer doesn't come back fast enough */
-	int autokilltimeout;		/* Recommended timeout for autokill */
-	unsigned short strans;		/* Our transaction identifier */
-	unsigned short dtrans;		/* Their transaction identifer */
-	unsigned char iseqno;		/* Next expected received seqno */
-	unsigned char oiseqno;		/* Last received incoming seqno */
-	unsigned char oseqno;		/* Next transmitted seqno */
-	unsigned char aseqno;		/* Last acknowledge seqno */
-	struct dundi_packet *packets;	/* Packets to be retransmitted */
-	struct dundi_packet *lasttrans;	/* Last transmitted / ACK'd packet */
-	struct dundi_transaction *next;	/* Next with respect to the parent */
-	struct dundi_request *parent;	/* Parent request (if there is one) */
-	struct dundi_transaction *allnext; /* Next with respect to all DUNDi transactions */
+	int eidcount;                          /*!< Number of eids in eids */
+	dundi_eid us_eid;                      /*!< Our EID, to them */
+	dundi_eid them_eid;                    /*!< Their EID, to us */
+	aes_encrypt_ctx	ecx;                   /*!< AES 128 Encryption context */
+	aes_decrypt_ctx	dcx;                   /*!< AES 128 Decryption context */
+	unsigned int flags;                    /*!< Has final packet been sent */
+	int ttl;                               /*!< Remaining TTL for queries on this one */
+	int thread;                            /*!< We have a calling thread */
+	int retranstimer;                      /*!< How long to wait before retransmissions */
+	int autokillid;                        /*!< ID to kill connection if answer doesn't come back fast enough */
+	int autokilltimeout;                   /*!< Recommended timeout for autokill */
+	unsigned short strans;                 /*!< Our transaction identifier */
+	unsigned short dtrans;                 /*!< Their transaction identifer */
+	unsigned char iseqno;                  /*!< Next expected received seqno */
+	unsigned char oiseqno;                 /*!< Last received incoming seqno */
+	unsigned char oseqno;                  /*!< Next transmitted seqno */
+	unsigned char aseqno;                  /*!< Last acknowledge seqno */
+	struct dundi_packet *packets;          /*!< Packets to be retransmitted */
+	struct dundi_packet *lasttrans;        /*!< Last transmitted / ACK'd packet */
+	struct dundi_transaction *next;        /*!< Next with respect to the parent */
+	struct dundi_request *parent;          /*!< Parent request (if there is one) */
+	struct dundi_transaction *allnext;     /*!< Next with respect to all DUNDi transactions */
 } *alltrans;
 
 struct dundi_request {
@@ -206,12 +203,12 @@
 	int expiration;
 	int cbypass;
 	int pfds[2];
-	unsigned long crc32;							/* CRC-32 of all but root EID's in avoid list */
-	struct dundi_transaction *trans;	/* Transactions */
-	struct dundi_request *next;
-} *requests;
+	unsigned long crc32;                   /*!< CRC-32 of all but root EID's in avoid list */
+	struct dundi_transaction *trans;       /*!< Transactions */
+	AST_LIST_ENTRY(dundi_request) list;
+};
 
-static struct dundi_mapping {
+struct dundi_mapping {
 	char dcontext[AST_MAX_EXTENSION];
 	char lcontext[AST_MAX_EXTENSION];
 	int weight;
@@ -219,12 +216,12 @@
 	int tech;
 	int dead;
 	char dest[AST_MAX_EXTENSION];
-	struct dundi_mapping *next;
-} *mappings = NULL;
+	AST_LIST_ENTRY(dundi_mapping) list;
+};
 
-static struct dundi_peer {
+struct dundi_peer {
 	dundi_eid eid;
-	struct sockaddr_in addr;	/* Address of DUNDi peer */
+	struct sockaddr_in addr;               /*!< Address of DUNDi peer */
 	struct permission *permit;
 	struct permission *include;
 	struct permission *precachesend;
@@ -237,34 +234,37 @@
 	int qualifyid;
 	int sentfullkey;
 	int order;
-	unsigned char txenckey[256]; /* Transmitted encrypted key + sig */
-	unsigned char rxenckey[256]; /* Cache received encrypted key + sig */
-	unsigned long us_keycrc32;	/* CRC-32 of our key */
-	aes_encrypt_ctx	us_ecx;		/* Cached AES 128 Encryption context */
-	aes_decrypt_ctx	us_dcx;		/* Cached AES 128 Decryption context */
-	unsigned long them_keycrc32;/* CRC-32 of our key */
-	aes_encrypt_ctx	them_ecx;	/* Cached AES 128 Encryption context */
-	aes_decrypt_ctx	them_dcx;	/* Cached AES 128 Decryption context */
-	time_t keyexpire;			/* When to expire/recreate key */
+	unsigned char txenckey[256];           /*!< Transmitted encrypted key + sig */
+	unsigned char rxenckey[256];           /*!< Cache received encrypted key + sig */
+	unsigned long us_keycrc32;             /*!< CRC-32 of our key */
+	aes_encrypt_ctx	us_ecx;                /*!< Cached AES 128 Encryption context */
+	aes_decrypt_ctx	us_dcx;	               /*!< Cached AES 128 Decryption context */
+	unsigned long them_keycrc32;           /*!< CRC-32 of our key */
+	aes_encrypt_ctx	them_ecx;              /*!< Cached AES 128 Encryption context */
+	aes_decrypt_ctx	them_dcx;              /*!< Cached AES 128 Decryption context */
+	time_t keyexpire;                      /*!< When to expire/recreate key */
 	int registerexpire;
 	int lookuptimes[DUNDI_TIMING_HISTORY];
 	char *lookups[DUNDI_TIMING_HISTORY];
 	int avgms;
-	struct dundi_transaction *regtrans;	/* Registration transaction */
-	struct dundi_transaction *qualtrans;	/* Qualify transaction */
+	struct dundi_transaction *regtrans;    /*!< Registration transaction */
+	struct dundi_transaction *qualtrans;   /*!< Qualify transaction */
 	struct dundi_transaction *keypending;
-	int model;					/* Pull model */
-	int pcmodel;				/* Push/precache model */
-	int dynamic;				/* Are we dynamic? */
-	int lastms;					/* Last measured latency */
-	int maxms;					/* Max permissible latency */
-	struct timeval qualtx;		/* Time of transmit */
-	struct dundi_peer *next;
-} *peers;
+	int model;                             /*!< Pull model */
+	int pcmodel;                           /*!< Push/precache model */
+	int dynamic;                           /*!< Are we dynamic? */
+	int lastms;                            /*!< Last measured latency */
+	int maxms;                             /*!< Max permissible latency */
+	struct timeval qualtx;                 /*!< Time of transmit */
+	AST_LIST_ENTRY(dundi_peer) list;
+};
 
+AST_LIST_HEAD_STATIC(peers, dundi_peer);
+AST_LIST_HEAD_NOLOCK_STATIC(mappings, dundi_mapping);
+AST_LIST_HEAD_NOLOCK_STATIC(requests, dundi_request);
+
 static struct dundi_precache_queue *pcq;
 
-AST_MUTEX_DEFINE_STATIC(peerlock);
 AST_MUTEX_DEFINE_STATIC(pclock);
 
 static int dundi_xmit(struct dundi_packet *pack);
@@ -477,16 +477,17 @@
 
 static struct dundi_peer *find_peer(dundi_eid *eid)
 {
-	struct dundi_peer *cur;
+	struct dundi_peer *cur = NULL;
+
 	if (!eid)
 		eid = &empty_eid;
-	cur = peers;
-	while(cur) {
+	
+	AST_LIST_TRAVERSE(&peers, cur, list) {
 		if (!dundi_eid_cmp(&cur->eid,eid))
-			return cur;
-		cur = cur->next;
+			break;
 	}
-	return NULL;
+
+	return cur;
 }
 
 static void build_iv(unsigned char *iv)
@@ -627,7 +628,7 @@
 				dundi_ie_append_cause(&ied, DUNDI_IE_CAUSE, DUNDI_CAUSE_DUPLICATE, "Duplicate Request Pending");
 		}
 	}
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	/* Truncate if "don't ask" isn't present */
 	if (!ast_test_flag_nonstd(&hmd, DUNDI_HINT_DONT_ASK))
 		hmd.exten[0] = '\0';
@@ -647,7 +648,7 @@
 		dundi_send(st->trans, DUNDI_COMMAND_DPRESPONSE, 0, 1, &ied);
 		st->trans->thread = 0;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	free(st);
 	return NULL;	
 }
@@ -666,7 +667,7 @@
 	/* Now produce precache */
 	dundi_precache_internal(st->called_context, st->called_number, st->ttl, st->eids);
 
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	/* Truncate if "don't ask" isn't present */
 	if (!ast_test_flag_nonstd(&hmd, DUNDI_HINT_DONT_ASK))
 		hmd.exten[0] = '\0';
@@ -678,7 +679,7 @@
 		dundi_send(st->trans, DUNDI_COMMAND_PRECACHERP, 0, 1, &ied);
 		st->trans->thread = 0;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	free(st);
 	return NULL;	
 }
@@ -713,7 +714,7 @@
 		/* If we do not have a canonical result, keep looking */
 		res = dundi_query_eid_internal(&dei, st->called_context, &st->reqeid, &hmd, st->ttl, 1, st->eids);
 	}
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	if (ast_test_flag(st->trans, FLAG_DEAD)) {
 		ast_log(LOG_DEBUG, "Our transaction went away!\n");
 		st->trans->thread = 0;
@@ -734,7 +735,7 @@
 		dundi_send(st->trans, DUNDI_COMMAND_EIDRESPONSE, 0, 1, &ied);
 		st->trans->thread = 0;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	free(st);
 	return NULL;	
 }
@@ -951,11 +952,9 @@
 	totallen = sizeof(struct dundi_query_state);
 	/* Count matching map entries */
 	mapcount = 0;
-	cur = mappings;
-	while(cur) {
+	AST_LIST_TRAVERSE(&mappings, cur, list) {
 		if (!strcasecmp(cur->dcontext, ccontext))
 			mapcount++;
-		cur = cur->next;
 	}
 	
 	/* If no maps, return -1 immediately */
@@ -994,16 +993,14 @@
 		/* Append mappings */
 		x = 0;
 		st->maps = (struct dundi_mapping *)s;
-		cur = mappings;
-		while(cur) {
+		AST_LIST_TRAVERSE(&mappings, cur, list) {
 			if (!strcasecmp(cur->dcontext, ccontext)) {
 				if (x < mapcount) {
 					st->maps[x] = *cur;
-					st->maps[x].next = NULL;
+					st->maps[x].list.next = NULL;
 					x++;
 				}
 			}
-			cur = cur->next;
 		}
 		st->nummaps = mapcount;
 		ast_log(LOG_DEBUG, "Forwarding precache for '%s@%s'!\n", ies->called_number, ies->called_context);
@@ -1037,19 +1034,16 @@
 	struct dundi_ie_data ied;
 	char *s;
 	struct dundi_mapping *cur;
-	int mapcount;
+	int mapcount = 0;
 	int skipfirst = 0;
 	
 	pthread_t lookupthread;
 	pthread_attr_t attr;
 	totallen = sizeof(struct dundi_query_state);
 	/* Count matching map entries */
-	mapcount = 0;
-	cur = mappings;
-	while(cur) {
+	AST_LIST_TRAVERSE(&mappings, cur, list) {
 		if (!strcasecmp(cur->dcontext, ccontext))
 			mapcount++;
-		cur = cur->next;
 	}
 	/* If no maps, return -1 immediately */
 	if (!mapcount)
@@ -1086,16 +1080,14 @@
 		/* Append mappings */
 		x = 0;
 		st->maps = (struct dundi_mapping *)s;
-		cur = mappings;
-		while(cur) {
+		AST_LIST_TRAVERSE(&mappings, cur, list) {
 			if (!strcasecmp(cur->dcontext, ccontext)) {
 				if (x < mapcount) {
 					st->maps[x] = *cur;
-					st->maps[x].next = NULL;
+					st->maps[x].list.next = NULL;
 					x++;
 				}
 			}
-			cur = cur->next;
 		}
 		st->nummaps = mapcount;
 		ast_log(LOG_DEBUG, "Answering query for '%s@%s'!\n", ies->called_number, ies->called_context);
@@ -1269,11 +1261,11 @@
 		trans->autokilltimeout = global_autokilltimeout;
 }
 
+/*! \note Called with the peers list already locked */
 static int do_register_expire(void *data)
 {
 	struct dundi_peer *peer = data;
 	char eid_str[20];
-	/* Called with peerlock already held */
 	ast_log(LOG_DEBUG, "Register expired for '%s'\n", dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
 	peer->registerexpire = -1;
 	peer->lastms = 0;
@@ -1989,9 +1981,9 @@
 	h = (struct dundi_hdr *)buf;
 	if (dundidebug)
 		dundi_showframe(h, 1, &sin, res - sizeof(struct dundi_hdr));
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	handle_frame(h, &sin, res - sizeof(struct dundi_hdr));
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return 1;
 }
 
@@ -2092,9 +2084,9 @@
 			res = 1000;
 		res = ast_io_wait(io, res);
 		if (res >= 0) {
-			ast_mutex_lock(&peerlock);
+			AST_LIST_LOCK(&peers);
 			ast_sched_runq(sched);
-			ast_mutex_unlock(&peerlock);
+			AST_LIST_UNLOCK(&peers);
 		}
 		check_password();
 	}
@@ -2162,7 +2154,7 @@
 
 static int dundi_flush(int fd, int argc, char *argv[])
 {
-	int stats=0;
+	int stats = 0;
 	if ((argc < 2) || (argc > 3))
 		return RESULT_SHOWUSAGE;
 	if (argc > 2) {
@@ -2175,19 +2167,17 @@
 		/* Flush statistics */
 		struct dundi_peer *p;
 		int x;
-		ast_mutex_lock(&peerlock);
-		p = peers;
-		while(p) {
-			for (x=0;x<DUNDI_TIMING_HISTORY;x++) {
+		AST_LIST_LOCK(&peers);
+		AST_LIST_TRAVERSE(&peers, p, list) {
+			for (x = 0;x < DUNDI_TIMING_HISTORY; x++) {
 				if (p->lookups[x])
 					free(p->lookups[x]);
 				p->lookups[x] = NULL;
 				p->lookuptimes[x] = 0;
 			}
 			p->avgms = 0;
-			p = p->next;
 		}
-		ast_mutex_unlock(&peerlock);
+		AST_LIST_UNLOCK(&peers);
 	} else {
 		ast_db_deltree("dundi/cache", NULL);
 		ast_cli(fd, "DUNDi Cache Flushed\n");
@@ -2236,14 +2226,14 @@
 
 	if (pos != rpos)
 		return NULL;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	len = strlen(word);
-	for (p = peers; !ret && p; p = p->next) {
+	AST_LIST_TRAVERSE(&peers, p, list) {
 		const char *s = dundi_eid_to_str(eid_str, sizeof(eid_str), &p->eid);
 		if (!strncasecmp(word, s, len) && ++which > state)
 			ret = ast_strdup(s);
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return ret;
 }
 
@@ -2384,12 +2374,10 @@
 	
 	if (argc != 4)
 		return RESULT_SHOWUSAGE;
-	ast_mutex_lock(&peerlock);
-	peer = peers;
-	while(peer) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&peers, peer, list) {
 		if (!strcasecmp(dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid), argv[3]))
 			break;
-		peer = peer->next;
 	}
 	if (peer) {
 		switch(peer->order) {
@@ -2445,7 +2433,7 @@
 			ast_cli(fd, "Average query time: %d ms\n", peer->avgms);
 	} else
 		ast_cli(fd, "No such peer '%s'\n", argv[3]);
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return RESULT_SUCCESS;
 }
 
@@ -2471,9 +2459,9 @@
 		} else
 			return RESULT_SHOWUSAGE;
  	}
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	ast_cli(fd, FORMAT2, "EID", "Host", "Model", "AvgTime", "Status");
-	for (peer = peers;peer;peer = peer->next) {
+	AST_LIST_TRAVERSE(&peers, peer, list) {
 		char status[20];
 		int print_line = -1;
 		char srch[2000];
@@ -2528,7 +2516,7 @@
 		}
 	}
 	ast_cli(fd, "%d dundi peers [%d online, %d offline, %d unmonitored]\n", total_peers, online_peers, offline_peers, unmonitored_peers);
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return RESULT_SUCCESS;
 #undef FORMAT
 #undef FORMAT2
@@ -2542,13 +2530,13 @@
 	char iabuf[INET_ADDRSTRLEN];
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	ast_cli(fd, FORMAT2, "Remote", "Src", "Dst", "Tx", "Rx", "Ack");
 	for (trans = alltrans;trans;trans = trans->allnext) {
 			ast_cli(fd, FORMAT, ast_inet_ntoa(iabuf, sizeof(iabuf), trans->addr.sin_addr), 
 					ntohs(trans->addr.sin_port), trans->strans, trans->dtrans, trans->oseqno, trans->iseqno, trans->aseqno);
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return RESULT_SUCCESS;
 #undef FORMAT
 #undef FORMAT2
@@ -2559,9 +2547,9 @@
 	char eid_str[20];
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	dundi_eid_to_str(eid_str, sizeof(eid_str), &global_eid);
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	ast_cli(fd, "Global EID for this system is '%s'\n", eid_str);
 	return RESULT_SUCCESS;
 }
@@ -2574,13 +2562,13 @@
 	char eidstr[20];
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	ast_cli(fd, FORMAT2, "Number", "Context", "Root", "Max", "Rsp");
-	for (req = requests;req;req = req->next) {
-			ast_cli(fd, FORMAT, req->number, req->dcontext,
-						dundi_eid_zero(&req->root_eid) ? "<unspecified>" : dundi_eid_to_str(eidstr, sizeof(eidstr), &req->root_eid), req->maxcount, req->respcount);
+	AST_LIST_TRAVERSE(&requests, req, list) {
+		ast_cli(fd, FORMAT, req->number, req->dcontext,
+			dundi_eid_zero(&req->root_eid) ? "<unspecified>" : dundi_eid_to_str(eidstr, sizeof(eidstr), &req->root_eid), req->maxcount, req->respcount);
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return RESULT_SUCCESS;
 #undef FORMAT
 #undef FORMAT2
@@ -2596,14 +2584,14 @@
 	char fs[256];
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	ast_cli(fd, FORMAT2, "DUNDi Cntxt", "Weight", "Local Cntxt", "Options", "Tech", "Destination");
-	for (map = mappings;map;map = map->next) {
-			ast_cli(fd, FORMAT, map->dcontext, map->weight, 
-			                    ast_strlen_zero(map->lcontext) ? "<none>" : map->lcontext, 
-								dundi_flags2str(fs, sizeof(fs), map->options), tech2str(map->tech), map->dest);
+	AST_LIST_TRAVERSE(&mappings, map, list) {
+		ast_cli(fd, FORMAT, map->dcontext, map->weight, 
+			ast_strlen_zero(map->lcontext) ? "<none>" : map->lcontext, 
+			dundi_flags2str(fs, sizeof(fs), map->options), tech2str(map->tech), map->dest);
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return RESULT_SUCCESS;
 #undef FORMAT
 #undef FORMAT2
@@ -2839,8 +2827,7 @@
 	int cnt;
 	char eid_str[20];
 	if (ast_test_flag(trans, FLAG_ISREG | FLAG_ISQUAL | FLAG_STOREHIST)) {
-		peer = peers;
-		while (peer) {
+		AST_LIST_TRAVERSE(&peers, peer, list) {
 			if (peer->regtrans == trans)
 				peer->regtrans = NULL;
 			if (peer->keypending == trans)
@@ -2891,7 +2878,6 @@
 					}
 				}
 			}
-			peer = peer->next;
 		}
 	}
 	if (trans->parent) {
@@ -2949,7 +2935,7 @@
 	struct dundi_packet *pack;
 	char iabuf[INET_ADDRSTRLEN];
 	int res;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	pack = data;
 	if (pack->retrans < 1) {
 		pack->retransid = -1;
@@ -2965,7 +2951,7 @@
 		dundi_xmit(pack);
 		res = 1;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return res;
 }
 
@@ -3060,9 +3046,8 @@
 		dundi_ie_append_eid(ied, DUNDI_IE_EID_DIRECT, eid);
 		return;
 	}
-	ast_mutex_lock(&peerlock);
-	p = peers;
-	while(p) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&peers, p, list) {
 		if (!dundi_eid_cmp(&p->eid, eid)) {
 			if (has_permission(p->include, context))
 				dundi_ie_append_eid(ied, DUNDI_IE_EID_DIRECT, eid);
@@ -3070,11 +3055,10 @@
 				dundi_ie_append_eid(ied, DUNDI_IE_EID, eid);
 			break;
 		}
-		p = p->next;
 	}
 	if (!p)
 		dundi_ie_append_eid(ied, DUNDI_IE_EID, eid);
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static int dundi_discover(struct dundi_transaction *trans)
@@ -3192,13 +3176,13 @@
 static int discover_transactions(struct dundi_request *dr)
 {
 	struct dundi_transaction *trans;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	trans = dr->trans;
 	while(trans) {
 		dundi_discover(trans);
 		trans = trans->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return 0;
 }
 
@@ -3206,7 +3190,7 @@
 {
 	struct dundi_transaction *trans, *transn;
 	/* Mark all as "in thread" so they don't disappear */
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	trans = dr->trans;
 	while(trans) {
 		if (trans->thread)
@@ -3214,7 +3198,7 @@
 		trans->thread = 1;
 		trans = trans->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 
 	trans = dr->trans;
 	while(trans) {
@@ -3224,7 +3208,7 @@
 	}
 
 	/* Cleanup any that got destroyed in the mean time */
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	trans = dr->trans;
 	while(trans) {
 		transn = trans->next;
@@ -3235,20 +3219,20 @@
 		}
 		trans = transn;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return 0;
 }
 
 static int query_transactions(struct dundi_request *dr)
 {
 	struct dundi_transaction *trans;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	trans = dr->trans;
 	while(trans) {
 		dundi_query(trans);
 		trans = trans->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return 0;
 }
 
@@ -3261,7 +3245,7 @@
 	dundi_eid tmp;
 	int x;
 	int needpush;
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	trans = dr->trans;
 	while(trans) {
 		/* Pop off the true root */
@@ -3273,8 +3257,7 @@
 			needpush = 0;
 		}
 
-		peer = peers;
-		while(peer) {
+		AST_LIST_TRAVERSE(&peers, peer, list) {
 			if (has_permission(peer->include, dr->dcontext) && 
 			    dundi_eid_cmp(&peer->eid, &trans->them_eid) &&
 				(peer->order <= order)) {
@@ -3299,14 +3282,13 @@
 					}
 				}
 			}
-			peer = peer->next;
 		}
 		/* If necessary, push the true root back on the end */
 		if (needpush)
 			trans->eids[trans->eidcount++] = tmp;
 		trans = trans->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return 0;
 }
 
@@ -3342,7 +3324,7 @@
 {
 	struct dundi_transaction *trans, *next;
 
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	trans = dr->trans;
 	
 	while(trans) {
@@ -3354,15 +3336,15 @@
 		dundi_send(trans, DUNDI_COMMAND_CANCEL, 0, 1, NULL);
 		trans = next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static void abort_request(struct dundi_request *dr)
 {
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	while(dr->trans) 
 		destroy_trans(dr->trans, 0);
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static void build_transactions(struct dundi_request *dr, int ttl, int order, int *foundcache, int *skipped, int blockempty, int nocache, int modeselect, dundi_eid *skip, dundi_eid *avoid[], int directs[])
@@ -3373,9 +3355,8 @@
 	int pass;
 	int allowconnect;
 	char eid_str[20];
-	ast_mutex_lock(&peerlock);
-	p = peers;
-	while(p) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&peers, p, list) {
 		if (modeselect == 1) {
 			/* Send the precache to push upstreams only! */
 			pass = has_permission(p->permit, dr->dcontext) && (p->pcmodel & DUNDI_MODEL_OUTBOUND);
@@ -3419,9 +3400,8 @@
 			} else if (!*skipped || (p->order < *skipped))
 				*skipped = p->order;
 		}
-		p = p->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static int register_request(struct dundi_request *dr, struct dundi_request **pending)
@@ -3429,70 +3409,51 @@
 	struct dundi_request *cur;
 	int res=0;
 	char eid_str[20];
-	ast_mutex_lock(&peerlock);
-	cur = requests;
-	while(cur) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&requests, cur, list) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Checking '%s@%s' vs '%s@%s'\n", cur->dcontext, cur->number,
 				dr->dcontext, dr->number);
 		if (!strcasecmp(cur->dcontext, dr->dcontext) &&
 		    !strcasecmp(cur->number, dr->number) &&
-			(!dundi_eid_cmp(&cur->root_eid, &dr->root_eid) || (cur->crc32 == dr->crc32))) {
-				ast_log(LOG_DEBUG, "Found existing query for '%s@%s' for '%s' crc '%08lx'\n", 
-					cur->dcontext, cur->number, dundi_eid_to_str(eid_str, sizeof(eid_str), &cur->root_eid), cur->crc32);
-				*pending = cur;
+		    (!dundi_eid_cmp(&cur->root_eid, &dr->root_eid) || (cur->crc32 == dr->crc32))) {
+			ast_log(LOG_DEBUG, "Found existing query for '%s@%s' for '%s' crc '%08lx'\n", 
+				cur->dcontext, cur->number, dundi_eid_to_str(eid_str, sizeof(eid_str), &cur->root_eid), cur->crc32);
+			*pending = cur;
 			res = 1;
 			break;
 		}
-		cur = cur->next;
 	}
 	if (!res) {
 		ast_log(LOG_DEBUG, "Registering request for '%s@%s' on behalf of '%s' crc '%08lx'\n", 
 				dr->number, dr->dcontext, dundi_eid_to_str(eid_str, sizeof(eid_str), &dr->root_eid), dr->crc32);
 		/* Go ahead and link us in since nobody else is searching for this */
-		dr->next = requests;
-		requests = dr;
+		AST_LIST_INSERT_HEAD(&requests, dr, list);
 		*pending = NULL;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	return res;
 }
 
 static void unregister_request(struct dundi_request *dr)
 {
-	struct dundi_request *cur, *prev;
-	ast_mutex_lock(&peerlock);
-	prev = NULL;
-	cur = requests;
-	while(cur) {
-		if (cur == dr) {
-			if (prev)
-				prev->next = cur->next;
-			else
-				requests = cur->next;
-			break;
-		}
-		prev = cur;
-		cur = cur->next;
-	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_LOCK(&peers);
+	AST_LIST_REMOVE(&requests, dr, list);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static int check_request(struct dundi_request *dr)
 {
 	struct dundi_request *cur;
-	int res = 0;
-	ast_mutex_lock(&peerlock);
-	cur = requests;
-	while(cur) {
-		if (cur == dr) {
-			res = 1;
+
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&requests, cur, list) {
+		if (cur == dr)
 			break;
-		}
-		cur = cur->next;
 	}
-	ast_mutex_unlock(&peerlock);
-	return res;
+	AST_LIST_UNLOCK(&peers);
+	
+	return cur ? 1 : 0;
 }
 
 static unsigned long avoid_crc32(dundi_eid *avoid[])
@@ -3672,17 +3633,17 @@
 	struct dundi_mapping *cur;
 	struct ast_context *con;
 	struct ast_exten *e;
-	cur = mappings;
-	while(cur) {
+
+	AST_LIST_TRAVERSE(&mappings, cur, list) {
 		ast_log(LOG_NOTICE, "Should precache context '%s'\n", cur->dcontext);
 		ast_lock_contexts();
 		con = ast_walk_contexts(NULL);
-		while(con) {
+		while (con) {
 			if (!strcasecmp(cur->lcontext, ast_get_context_name(con))) {
 				/* Found the match, now queue them all up */
 				ast_lock_context(con);
 				e = ast_walk_context_extensions(con, NULL);
-				while(e) {
+				while (e) {
 					reschedule_precache(ast_get_extension_name(e), cur->dcontext, 0);
 					e = ast_walk_context_extensions(con, e);
 				}
@@ -3691,7 +3652,6 @@
 			con = ast_walk_contexts(con);
 		}
 		ast_unlock_contexts();
-		cur = cur->next;
 	}
 }
 
@@ -3701,35 +3661,30 @@
 	struct dundi_hint_metadata hmd;
 	struct dundi_result dr2[MAX_RESULTS];
 	struct timeval start;
-	struct dundi_mapping *maps=NULL, *cur;
-	int nummaps;
+	struct dundi_mapping *maps = NULL, *cur;
+	int nummaps = 0;
 	int foundanswers;
 	int foundcache, skipped, ttlms, ms;
 	if (!context)
 		context = "e164";
 	ast_log(LOG_DEBUG, "Precache internal (%s@%s)!\n", number, context);
 
-	ast_mutex_lock(&peerlock);
-	nummaps = 0;
-	cur = mappings;
-	while(cur) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&mappings, cur, list) {
 		if (!strcasecmp(cur->dcontext, context))
 			nummaps++;
-		cur = cur->next;
 	}
 	if (nummaps) {
-		maps = alloca(nummaps * sizeof(struct dundi_mapping));
+		maps = alloca(nummaps * sizeof(*maps));
 		nummaps = 0;
 		if (maps) {
-			cur = mappings;
-			while(cur) {
+			AST_LIST_TRAVERSE(&mappings, cur, list) {
 				if (!strcasecmp(cur->dcontext, context))
 					maps[nummaps++] = *cur;
-				cur = cur->next;
 			}
 		}
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	if (!nummaps || !maps)
 		return -1;
 	ttlms = DUNDI_FLUFF_TIME + ttl * DUNDI_TTL_TIME;
@@ -3900,25 +3855,22 @@
 static void mark_peers(void)
 {
 	struct dundi_peer *peer;
-	ast_mutex_lock(&peerlock);
-	peer = peers;
-	while(peer) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&peers, peer, list) {
 		peer->dead = 1;
-		peer = peer->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static void mark_mappings(void)
 {
 	struct dundi_mapping *map;
-	ast_mutex_lock(&peerlock);
-	map = mappings;
-	while(map) {
+	
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&mappings, map, list) {
 		map->dead = 1;
-		map = map->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 }
 
 static void destroy_permissions(struct permission *p)
@@ -3953,44 +3905,32 @@
 
 static void prune_peers(void)
 {
-	struct dundi_peer *peer, *prev, *next;
-	ast_mutex_lock(&peerlock);
-	peer = peers;
-	prev = NULL;
-	while(peer) {
-		next = peer->next;
+	struct dundi_peer *peer;
+
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&peers, peer, list) {
 		if (peer->dead) {
-			if (prev)
-				prev->next = peer->next;
-			else
-				peers = peer->next;
+			AST_LIST_REMOVE_CURRENT(&peers, list);
 			destroy_peer(peer);
-		} else
-			prev = peer;
-		peer = next;
+		}
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_TRAVERSE_SAFE_END
+	AST_LIST_UNLOCK(&peers);
 }
 
 static void prune_mappings(void)
 {
-	struct dundi_mapping *map, *prev, *next;
-	ast_mutex_lock(&peerlock);
-	map = mappings;
-	prev = NULL;
-	while(map) {
-		next = map->next;
+	struct dundi_mapping *map;
+
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&mappings, map, list) {
 		if (map->dead) {
-			if (prev)
-				prev->next = map->next;
-			else
-				mappings = map->next;
+			AST_LIST_REMOVE_CURRENT(&mappings, list);
 			destroy_map(map);
-		} else
-			prev = map;
-		map = next;
+		}
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_TRAVERSE_SAFE_END
+	AST_LIST_UNLOCK(&peers);
 }
 
 static struct permission *append_permission(struct permission *p, char *s, int allow)
@@ -4023,83 +3963,77 @@
 	struct dundi_mapping *map;
 	int x;
 	int y;
-	t = ast_strdupa(value);
-	if (t) {
-		map = mappings;
-		while(map) {
-			/* Find a double match */
-			if (!strcasecmp(map->dcontext, name) && 
-				(!strncasecmp(map->lcontext, value, strlen(map->lcontext)) && 
-				  (!value[strlen(map->lcontext)] || 
-				   (value[strlen(map->lcontext)] == ','))))
-				break;
-			map = map->next;
+
+	if (!(t = ast_strdupa(value)))
+		return;
+		
+	AST_LIST_TRAVERSE(&mappings, map, list) {
+		/* Find a double match */
+		if (!strcasecmp(map->dcontext, name) && 
+			(!strncasecmp(map->lcontext, value, strlen(map->lcontext)) && 
+			  (!value[strlen(map->lcontext)] || 
+			   (value[strlen(map->lcontext)] == ','))))
+			break;
+	}
+	if (!map) {
+		if (!(map = ast_calloc(1, sizeof(*map))))
+			return;
+		AST_LIST_INSERT_HEAD(&mappings, map, list);
+		map->dead = 1;
+	}
+	map->options = 0;
+	memset(fields, 0, sizeof(fields));
+	x = 0;
+	while (t && x < MAX_OPTS) {
+		fields[x++] = t;
+		t = strchr(t, ',');
+		if (t) {
+			*t = '\0';
+			t++;
 		}
-		if (!map) {
-			map = malloc(sizeof(struct dundi_mapping));
-			if (map) {
-				memset(map, 0, sizeof(struct dundi_mapping));
-				map->next = mappings;
-				mappings = map;
-				map->dead = 1;
+	} /* Russell was here, arrrr! */
+	if ((x == 1) && ast_strlen_zero(fields[0])) {
+		/* Placeholder mapping */
+		ast_copy_string(map->dcontext, name, sizeof(map->dcontext));
+		map->dead = 0;
+	} else if (x >= 4) {
+		ast_copy_string(map->dcontext, name, sizeof(map->dcontext));
+		ast_copy_string(map->lcontext, fields[0], sizeof(map->lcontext));
+		if ((sscanf(fields[1], "%d", &map->weight) == 1) && (map->weight >= 0) && (map->weight < 60000)) {
+			ast_copy_string(map->dest, fields[3], sizeof(map->dest));
+			if ((map->tech = str2tech(fields[2]))) {
+				map->dead = 0;
 			}
+		} else {
+			ast_log(LOG_WARNING, "Invalid weight '%s' specified, deleting entry '%s/%s'\n", fields[1], map->dcontext, map->lcontext);
 		}
-		if (map) {
-			map->options = 0;
-			memset(fields, 0, sizeof(fields));
-			x = 0;
-			while(t && x < MAX_OPTS) {
-				fields[x++] = t;
-				t = strchr(t, ',');
-				if (t) {
-					*t = '\0';
-					t++;
-				}
-			} /* Russell was here, arrrr! */
-			if ((x == 1) && ast_strlen_zero(fields[0])) {
-				/* Placeholder mapping */
-				ast_copy_string(map->dcontext, name, sizeof(map->dcontext));
-				map->dead = 0;
-			} else if (x >= 4) {
-				ast_copy_string(map->dcontext, name, sizeof(map->dcontext));
-				ast_copy_string(map->lcontext, fields[0], sizeof(map->lcontext));
-				if ((sscanf(fields[1], "%d", &map->weight) == 1) && (map->weight >= 0) && (map->weight < 60000)) {
-					ast_copy_string(map->dest, fields[3], sizeof(map->dest));
-					if ((map->tech = str2tech(fields[2]))) {
-						map->dead = 0;
-					}
-				} else {
-					ast_log(LOG_WARNING, "Invalid weight '%s' specified, deleting entry '%s/%s'\n", fields[1], map->dcontext, map->lcontext);
-				}
-				for (y=4;y<x;y++) {
-					if (!strcasecmp(fields[y], "nounsolicited"))
-						map->options |= DUNDI_FLAG_NOUNSOLICITED;
-					else if (!strcasecmp(fields[y], "nocomunsolicit"))
-						map->options |= DUNDI_FLAG_NOCOMUNSOLICIT;
-					else if (!strcasecmp(fields[y], "residential"))
-						map->options |= DUNDI_FLAG_RESIDENTIAL;
-					else if (!strcasecmp(fields[y], "commercial"))
-						map->options |= DUNDI_FLAG_COMMERCIAL;
-					else if (!strcasecmp(fields[y], "mobile"))
-						map->options |= DUNDI_FLAG_MOBILE;
-					else if (!strcasecmp(fields[y], "nopartial"))
-						map->options |= DUNDI_FLAG_INTERNAL_NOPARTIAL;
-					else
-						ast_log(LOG_WARNING, "Don't know anything about option '%s'\n", fields[y]);
-				}
-			} else 
-				ast_log(LOG_WARNING, "Expected at least %d arguments in map, but got only %d\n", 4, x);
+		for (y = 4;y < x; y++) {
+			if (!strcasecmp(fields[y], "nounsolicited"))
+				map->options |= DUNDI_FLAG_NOUNSOLICITED;
+			else if (!strcasecmp(fields[y], "nocomunsolicit"))
+				map->options |= DUNDI_FLAG_NOCOMUNSOLICIT;
+			else if (!strcasecmp(fields[y], "residential"))
+				map->options |= DUNDI_FLAG_RESIDENTIAL;
+			else if (!strcasecmp(fields[y], "commercial"))
+				map->options |= DUNDI_FLAG_COMMERCIAL;
+			else if (!strcasecmp(fields[y], "mobile"))
+				map->options |= DUNDI_FLAG_MOBILE;
+			else if (!strcasecmp(fields[y], "nopartial"))
+				map->options |= DUNDI_FLAG_INTERNAL_NOPARTIAL;
+			else
+				ast_log(LOG_WARNING, "Don't know anything about option '%s'\n", fields[y]);
 		}
-	}
+	} else 
+		ast_log(LOG_WARNING, "Expected at least %d arguments in map, but got only %d\n", 4, x);
 }
 
+/* \note Called with the peers list already locked */
 static int do_register(void *data)
 {
 	struct dundi_ie_data ied;
 	struct dundi_peer *peer = data;
 	char eid_str[20];
 	char eid_str2[20];
-	/* Called with peerlock already held */
 	ast_log(LOG_DEBUG, "Register us as '%s' to '%s'\n", dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->us_eid), dundi_eid_to_str(eid_str2, sizeof(eid_str2), &peer->eid));
 	peer->registerid = ast_sched_add(sched, default_expiration * 1000, do_register, data);
 	/* Destroy old transaction if there is one */
@@ -4187,151 +4121,145 @@
 	int needregister=0;
 	char eid_str[20];
 
-	ast_mutex_lock(&peerlock);
-	peer = peers;
-	while(peer) {
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE(&peers, peer, list) {
 		if (!dundi_eid_cmp(&peer->eid, eid)) {	
 			break;
 		}
-		peer = peer->next;
 	}
 	if (!peer) {
 		/* Add us into the list */
-		peer = malloc(sizeof(struct dundi_peer));
-		if (peer) {
-			memset(peer, 0, sizeof(struct dundi_peer));
-			peer->registerid = -1;
-			peer->registerexpire = -1;
-			peer->qualifyid = -1;
-			peer->addr.sin_family = AF_INET;
-			peer->addr.sin_port = htons(DUNDI_PORT);
-			populate_addr(peer, eid);
-			peer->next = peers;
-			peers = peer;
+		if (!(peer = ast_calloc(1, sizeof(*peer)))) {
+			AST_LIST_UNLOCK(&peers);
+			return;
 		}
-	}
-	if (peer) {
-		peer->dead = 0;
-		peer->eid = *eid;
-		peer->us_eid = global_eid;
-		destroy_permissions(peer->permit);
-		destroy_permissions(peer->include);
-		peer->permit = NULL;
-		peer->include = NULL;
-		if (peer->registerid > -1)
-			ast_sched_del(sched, peer->registerid);
 		peer->registerid = -1;
-		while(v) {
-			if (!strcasecmp(v->name, "inkey")) {
-				ast_copy_string(peer->inkey, v->value, sizeof(peer->inkey));
-			} else if (!strcasecmp(v->name, "outkey")) {
-				ast_copy_string(peer->outkey, v->value, sizeof(peer->outkey));
-			} else if (!strcasecmp(v->name, "host")) {
-				if (!strcasecmp(v->value, "dynamic")) {
-					peer->dynamic = 1;
+		peer->registerexpire = -1;
+		peer->qualifyid = -1;
+		peer->addr.sin_family = AF_INET;
+		peer->addr.sin_port = htons(DUNDI_PORT);
+		populate_addr(peer, eid);
+		AST_LIST_INSERT_HEAD(&peers, peer, list);
+	}
+	peer->dead = 0;
+	peer->eid = *eid;
+	peer->us_eid = global_eid;
+	destroy_permissions(peer->permit);
+	destroy_permissions(peer->include);
+	peer->permit = NULL;
+	peer->include = NULL;
+	if (peer->registerid > -1)
+		ast_sched_del(sched, peer->registerid);
+	peer->registerid = -1;
+	for (; v; v = v->next) {
+		if (!strcasecmp(v->name, "inkey")) {
+			ast_copy_string(peer->inkey, v->value, sizeof(peer->inkey));
+		} else if (!strcasecmp(v->name, "outkey")) {
+			ast_copy_string(peer->outkey, v->value, sizeof(peer->outkey));
+		} else if (!strcasecmp(v->name, "host")) {
+			if (!strcasecmp(v->value, "dynamic")) {
+				peer->dynamic = 1;
+			} else {
+				hp = ast_gethostbyname(v->value, &he);
+				if (hp) {
+					memcpy(&peer->addr.sin_addr, hp->h_addr, sizeof(peer->addr.sin_addr));
+					peer->dynamic = 0;
 				} else {
-					hp = ast_gethostbyname(v->value, &he);
-					if (hp) {
-						memcpy(&peer->addr.sin_addr, hp->h_addr, sizeof(peer->addr.sin_addr));
-						peer->dynamic = 0;
-					} else {
-						ast_log(LOG_WARNING, "Unable to find host '%s' at line %d\n", v->value, v->lineno);
-						peer->dead = 1;
-					}
+					ast_log(LOG_WARNING, "Unable to find host '%s' at line %d\n", v->value, v->lineno);
+					peer->dead = 1;
 				}
-			} else if (!strcasecmp(v->name, "ustothem")) {
-				if (!dundi_str_to_eid(&testeid, v->value))
-					peer->us_eid = testeid;
-				else
-					ast_log(LOG_WARNING, "'%s' is not a valid DUNDi Entity Identifier at line %d\n", v->value, v->lineno);
-			} else if (!strcasecmp(v->name, "include")) {
-				peer->include = append_permission(peer->include, v->value, 1);
-			} else if (!strcasecmp(v->name, "permit")) {
-				peer->permit = append_permission(peer->permit, v->value, 1);
-			} else if (!strcasecmp(v->name, "noinclude")) {
-				peer->include = append_permission(peer->include, v->value, 0);
-			} else if (!strcasecmp(v->name, "deny")) {
-				peer->permit = append_permission(peer->permit, v->value, 0);
-			} else if (!strcasecmp(v->name, "register")) {
-				needregister = ast_true(v->value);
-			} else if (!strcasecmp(v->name, "order")) {
-				if (!strcasecmp(v->value, "primary"))
-					peer->order = 0;
-				else if (!strcasecmp(v->value, "secondary"))
-					peer->order = 1;
-				else if (!strcasecmp(v->value, "tertiary"))
-					peer->order = 2;
-				else if (!strcasecmp(v->value, "quartiary"))
-					peer->order = 3;
-				else {
-					ast_log(LOG_WARNING, "'%s' is not a valid order, should be primary, secondary, tertiary or quartiary at line %d\n", v->value, v->lineno);
-				}
-			} else if (!strcasecmp(v->name, "qualify")) {
-				if (!strcasecmp(v->value, "no")) {
-					peer->maxms = 0;
-				} else if (!strcasecmp(v->value, "yes")) {
-					peer->maxms = DEFAULT_MAXMS;
-				} else if (sscanf(v->value, "%d", &peer->maxms) != 1) {
-					ast_log(LOG_WARNING, "Qualification of peer '%s' should be 'yes', 'no', or a number of milliseconds at line %d of dundi.conf\n", 
-						dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid), v->lineno);
-					peer->maxms = 0;
-				}
-			} else if (!strcasecmp(v->name, "model")) {
-				if (!strcasecmp(v->value, "inbound"))
-					peer->model = DUNDI_MODEL_INBOUND;
-				else if (!strcasecmp(v->value, "outbound")) 
-					peer->model = DUNDI_MODEL_OUTBOUND;
-				else if (!strcasecmp(v->value, "symmetric"))
-					peer->model = DUNDI_MODEL_SYMMETRIC;
-				else if (!strcasecmp(v->value, "none"))
-					peer->model = 0;
-				else {
-					ast_log(LOG_WARNING, "Unknown model '%s', should be 'none', 'outbound', 'inbound', or 'symmetric' at line %d\n", 
-						v->value, v->lineno);
-				}
-			} else if (!strcasecmp(v->name, "precache")) {
-				if (!strcasecmp(v->value, "inbound"))
-					peer->pcmodel = DUNDI_MODEL_INBOUND;
-				else if (!strcasecmp(v->value, "outbound")) 
-					peer->pcmodel = DUNDI_MODEL_OUTBOUND;
-				else if (!strcasecmp(v->value, "symmetric"))
-					peer->pcmodel = DUNDI_MODEL_SYMMETRIC;
-				else if (!strcasecmp(v->value, "none"))
-					peer->pcmodel = 0;
-				else {
-					ast_log(LOG_WARNING, "Unknown pcmodel '%s', should be 'none', 'outbound', 'inbound', or 'symmetric' at line %d\n", 
-						v->value, v->lineno);
-				}
 			}
-			v = v->next;
-		}
-		(*globalpcmode) |= peer->pcmodel;
-		if (!peer->model && !peer->pcmodel) {
-			ast_log(LOG_WARNING, "Peer '%s' lacks a model or pcmodel, discarding!\n", 
-				dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
-			peer->dead = 1;
-		} else if ((peer->model & DUNDI_MODEL_INBOUND) && (peer->pcmodel & DUNDI_MODEL_OUTBOUND)) {
-			ast_log(LOG_WARNING, "Peer '%s' may not be both inbound/symmetric model and outbound/symmetric precache model, discarding!\n", 
-				dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
-			peer->dead = 1;
-		} else if ((peer->model & DUNDI_MODEL_OUTBOUND) && (peer->pcmodel & DUNDI_MODEL_INBOUND)) {
-			ast_log(LOG_WARNING, "Peer '%s' may not be both outbound/symmetric model and inbound/symmetric precache model, discarding!\n", 
-				dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
-			peer->dead = 1;
-		} else if (peer->include && !(peer->model & DUNDI_MODEL_OUTBOUND) && !(peer->pcmodel & DUNDI_MODEL_INBOUND)) {
-			ast_log(LOG_WARNING, "Peer '%s' is supposed to be included in outbound searches but isn't an outbound peer or inbound precache!\n", 
-				dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
-		} else if (peer->permit && !(peer->model & DUNDI_MODEL_INBOUND) && !(peer->pcmodel & DUNDI_MODEL_OUTBOUND)) {
-			ast_log(LOG_WARNING, "Peer '%s' is supposed to have permission for some inbound searches but isn't an inbound peer or outbound precache!\n", 
-				dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
-		} else { 
-			if (needregister) {
-				peer->registerid = ast_sched_add(sched, 2000, do_register, peer);
+		} else if (!strcasecmp(v->name, "ustothem")) {
+			if (!dundi_str_to_eid(&testeid, v->value))
+				peer->us_eid = testeid;
+			else
+				ast_log(LOG_WARNING, "'%s' is not a valid DUNDi Entity Identifier at line %d\n", v->value, v->lineno);
+		} else if (!strcasecmp(v->name, "include")) {
+			peer->include = append_permission(peer->include, v->value, 1);
+		} else if (!strcasecmp(v->name, "permit")) {
+			peer->permit = append_permission(peer->permit, v->value, 1);
+		} else if (!strcasecmp(v->name, "noinclude")) {
+			peer->include = append_permission(peer->include, v->value, 0);
+		} else if (!strcasecmp(v->name, "deny")) {
+			peer->permit = append_permission(peer->permit, v->value, 0);
+		} else if (!strcasecmp(v->name, "register")) {
+			needregister = ast_true(v->value);
+		} else if (!strcasecmp(v->name, "order")) {
+			if (!strcasecmp(v->value, "primary"))
+				peer->order = 0;
+			else if (!strcasecmp(v->value, "secondary"))
+				peer->order = 1;
+			else if (!strcasecmp(v->value, "tertiary"))
+				peer->order = 2;
+			else if (!strcasecmp(v->value, "quartiary"))
+				peer->order = 3;
+			else {
+				ast_log(LOG_WARNING, "'%s' is not a valid order, should be primary, secondary, tertiary or quartiary at line %d\n", v->value, v->lineno);
 			}
-			qualify_peer(peer, 1);
+		} else if (!strcasecmp(v->name, "qualify")) {
+			if (!strcasecmp(v->value, "no")) {
+				peer->maxms = 0;
+			} else if (!strcasecmp(v->value, "yes")) {
+				peer->maxms = DEFAULT_MAXMS;
+			} else if (sscanf(v->value, "%d", &peer->maxms) != 1) {
+				ast_log(LOG_WARNING, "Qualification of peer '%s' should be 'yes', 'no', or a number of milliseconds at line %d of dundi.conf\n", 
+					dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid), v->lineno);
+				peer->maxms = 0;
+			}
+		} else if (!strcasecmp(v->name, "model")) {
+			if (!strcasecmp(v->value, "inbound"))
+				peer->model = DUNDI_MODEL_INBOUND;
+			else if (!strcasecmp(v->value, "outbound")) 
+				peer->model = DUNDI_MODEL_OUTBOUND;
+			else if (!strcasecmp(v->value, "symmetric"))
+				peer->model = DUNDI_MODEL_SYMMETRIC;
+			else if (!strcasecmp(v->value, "none"))
+				peer->model = 0;
+			else {
+				ast_log(LOG_WARNING, "Unknown model '%s', should be 'none', 'outbound', 'inbound', or 'symmetric' at line %d\n", 
+					v->value, v->lineno);
+			}
+		} else if (!strcasecmp(v->name, "precache")) {
+			if (!strcasecmp(v->value, "inbound"))
+				peer->pcmodel = DUNDI_MODEL_INBOUND;
+			else if (!strcasecmp(v->value, "outbound")) 
+				peer->pcmodel = DUNDI_MODEL_OUTBOUND;
+			else if (!strcasecmp(v->value, "symmetric"))
+				peer->pcmodel = DUNDI_MODEL_SYMMETRIC;
+			else if (!strcasecmp(v->value, "none"))
+				peer->pcmodel = 0;
+			else {
+				ast_log(LOG_WARNING, "Unknown pcmodel '%s', should be 'none', 'outbound', 'inbound', or 'symmetric' at line %d\n", 
+					v->value, v->lineno);
+			}
 		}
 	}
-	ast_mutex_unlock(&peerlock);
+	(*globalpcmode) |= peer->pcmodel;
+	if (!peer->model && !peer->pcmodel) {
+		ast_log(LOG_WARNING, "Peer '%s' lacks a model or pcmodel, discarding!\n", 
+			dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
+		peer->dead = 1;
+	} else if ((peer->model & DUNDI_MODEL_INBOUND) && (peer->pcmodel & DUNDI_MODEL_OUTBOUND)) {
+		ast_log(LOG_WARNING, "Peer '%s' may not be both inbound/symmetric model and outbound/symmetric precache model, discarding!\n", 
+			dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
+		peer->dead = 1;
+	} else if ((peer->model & DUNDI_MODEL_OUTBOUND) && (peer->pcmodel & DUNDI_MODEL_INBOUND)) {
+		ast_log(LOG_WARNING, "Peer '%s' may not be both outbound/symmetric model and inbound/symmetric precache model, discarding!\n", 
+			dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
+		peer->dead = 1;
+	} else if (peer->include && !(peer->model & DUNDI_MODEL_OUTBOUND) && !(peer->pcmodel & DUNDI_MODEL_INBOUND)) {
+		ast_log(LOG_WARNING, "Peer '%s' is supposed to be included in outbound searches but isn't an outbound peer or inbound precache!\n", 
+			dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
+	} else if (peer->permit && !(peer->model & DUNDI_MODEL_INBOUND) && !(peer->pcmodel & DUNDI_MODEL_OUTBOUND)) {
+		ast_log(LOG_WARNING, "Peer '%s' is supposed to have permission for some inbound searches but isn't an inbound peer or outbound precache!\n", 
+			dundi_eid_to_str(eid_str, sizeof(eid_str), &peer->eid));
+	} else { 
+		if (needregister) {
+			peer->registerid = ast_sched_add(sched, 2000, do_register, peer);
+		}
+		qualify_peer(peer, 1);
+	}
+	AST_LIST_UNLOCK(&peers);
 }
 
 static int dundi_helper(struct ast_channel *chan, const char *context, const char *exten, int priority, const char *data, int flag)
@@ -4484,7 +4412,7 @@
 			ast_log(LOG_WARNING, "Unable to look up host '%s'\n", hn);
 	} else
 		ast_log(LOG_WARNING, "Unable to get host name!\n");
-	ast_mutex_lock(&peerlock);
+	AST_LIST_LOCK(&peers);
 	reset_global_eid();
 	global_storehistory = 0;
 	ast_copy_string(secretpath, "dundi", sizeof(secretpath));
@@ -4576,7 +4504,7 @@
 		}
 		v = v->next;
 	}
-	ast_mutex_unlock(&peerlock);
+	AST_LIST_UNLOCK(&peers);
 	mark_mappings();
 	v = ast_variable_browse(cfg, "mappings");
 	while(v) {

Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/pbx.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -4147,7 +4147,7 @@
 {
 	int res = 0;
 
-	ast_mutex_lock(&chan->lock);
+	ast_channel_lock(chan);
 
 	if (chan->pbx) {
 		/* This channel is currently in the PBX */
@@ -4174,9 +4174,9 @@
 			ast_channel_masquerade(tmpchan, chan);
 		
 			/* Grab the locks and get going */
-			ast_mutex_lock(&tmpchan->lock);
+			ast_channel_lock(tmpchan);
 			ast_do_masquerade(tmpchan);
-			ast_mutex_unlock(&tmpchan->lock);
+			ast_channel_unlock(tmpchan);
 			/* Start the PBX going on our stolen channel */
 			if (ast_pbx_start(tmpchan)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmpchan->name);
@@ -4185,7 +4185,7 @@
 			}
 		}
 	}
-	ast_mutex_unlock(&chan->lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -4197,7 +4197,7 @@
 	chan = ast_get_channel_by_name_locked(channame);
 	if (chan) {
 		res = ast_async_goto(chan, context, exten, priority);
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
 	}
 	return res;
 }
@@ -4576,7 +4576,7 @@
 		if (channel) {
 			*channel = chan;
 			if (chan)
-				ast_mutex_lock(&chan->lock);
+				ast_channel_lock(chan);
 		}
 		if (chan) {
 			if (chan->cdr) { /* check if the channel already has a cdr record, if not give it one */
@@ -4600,7 +4600,7 @@
 
 				if (sync > 1) {
 					if (channel)
-						ast_mutex_unlock(&chan->lock);
+						ast_channel_unlock(chan);
 					if (ast_pbx_run(chan)) {
 						ast_log(LOG_ERROR, "Unable to run PBX on %s\n", chan->name);
 						if (channel)
@@ -4613,7 +4613,7 @@
 						ast_log(LOG_ERROR, "Unable to start PBX on %s\n", chan->name);
 						if (channel) {
 							*channel = NULL;
-							ast_mutex_unlock(&chan->lock);
+							ast_channel_unlock(chan);
 						}
 						ast_hangup(chan);
 						res = -1;
@@ -4632,7 +4632,7 @@
 			
 				if (channel) {
 					*channel = NULL;
-					ast_mutex_unlock(&chan->lock);
+					ast_channel_unlock(chan);
 				}
 				ast_hangup(chan);
 			}
@@ -4673,7 +4673,7 @@
 		if (channel) {
 			*channel = chan;
 			if (chan)
-				ast_mutex_lock(&chan->lock);
+				ast_channel_lock(chan);
 		}
 		if (!chan) {
 			free(as);
@@ -4694,7 +4694,7 @@
 			free(as);
 			if (channel) {
 				*channel = NULL;
-				ast_mutex_unlock(&chan->lock);
+				ast_channel_unlock(chan);
 			}
 			ast_hangup(chan);
 			res = -1;
@@ -4783,18 +4783,18 @@
 					tmp->chan = chan;
 					if (sync > 1) {
 						if (locked_channel)
-							ast_mutex_unlock(&chan->lock);
+							ast_channel_unlock(chan);
 						ast_pbx_run_app(tmp);
 					} else {
 						pthread_attr_init(&attr);
 						pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 						if (locked_channel) 
-							ast_mutex_lock(&chan->lock);
+							ast_channel_lock(chan);
 						if (ast_pthread_create(&tmp->t, &attr, ast_pbx_run_app, tmp)) {
 							ast_log(LOG_WARNING, "Unable to spawn execute thread on %s: %s\n", chan->name, strerror(errno));
 							free(tmp);
 							if (locked_channel) 
-								ast_mutex_unlock(&chan->lock);
+								ast_channel_unlock(chan);
 							ast_hangup(chan);
 							res = -1;
 						} else {
@@ -4851,12 +4851,12 @@
 		pthread_attr_init(&attr);
 		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 		if (locked_channel) 
-			ast_mutex_lock(&chan->lock);
+			ast_channel_lock(chan);
 		if (ast_pthread_create(&as->p, &attr, async_wait, as)) {
 			ast_log(LOG_WARNING, "Failed to start async wait\n");
 			free(as);
 			if (locked_channel) 
-				ast_mutex_unlock(&chan->lock);
+				ast_channel_unlock(chan);
 			ast_hangup(chan);
 			res = -1;
 			goto outgoing_app_cleanup;
@@ -5505,7 +5505,7 @@
 				sprintf(s, "${%s}", value);
 				pbx_substitute_variables_helper(chan2, s, tmp, sizeof(tmp) - 1);
 			}
-			ast_mutex_unlock(&chan2->lock);
+			ast_channel_unlock(chan2);
 		}
 		pbx_builtin_setvar_helper(chan, name, tmp);
 	}

Modified: trunk/res/res_agi.c
===================================================================
--- trunk/res/res_agi.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/res/res_agi.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -1025,7 +1025,7 @@
 			/* we have a matching channel */
 			ast_softhangup(c,AST_SOFTHANGUP_EXPLICIT);
 			fdprintf(agi->fd, "200 result=1\n");
-			ast_mutex_unlock(&c->lock);
+			ast_channel_unlock(c);
 			return RESULT_SUCCESS;
 		}
 		/* if we get this far no channel name matched the argument given */
@@ -1093,7 +1093,7 @@
 		c = ast_get_channel_by_name_locked(argv[2]);
 		if (c) {
 			fdprintf(agi->fd, "200 result=%d\n", c->_state);
-			ast_mutex_unlock(&c->lock);
+			ast_channel_unlock(c);
 			return RESULT_SUCCESS;
 		}
 		/* if we get this far no channel name matched the argument given */
@@ -1155,7 +1155,7 @@
 		fdprintf(agi->fd, "200 result=0\n");
 	}
 	if (chan2 && (chan2 != chan))
-		ast_mutex_unlock(&chan2->lock);
+		ast_channel_unlock(chan2);
 	return RESULT_SUCCESS;
 }
 

Modified: trunk/res/res_features.c
===================================================================
--- trunk/res/res_features.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/res/res_features.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -1859,7 +1859,7 @@
 	if (!ch2) {
 		snprintf(buf, sizeof(buf), "Channel does not exist: %s", channel2);
 		astman_send_error(s, m, buf);
-		ast_mutex_unlock(&ch1->lock);
+		ast_channel_unlock(ch1);
 		return 0;
 	}
 
@@ -1875,8 +1875,8 @@
 		astman_send_error(s, m, "Park failure");
 	}
 
-	ast_mutex_unlock(&ch1->lock);
-	ast_mutex_unlock(&ch2->lock);
+	ast_channel_unlock(ch1);
+	ast_channel_unlock(ch2);
 
 	return 0;
 }
@@ -1895,7 +1895,7 @@
 			 (cur->_state == AST_STATE_RING))) {
 			 	break;
 		}
-		ast_mutex_unlock(&cur->lock);
+		ast_channel_unlock(cur);
 	}
 	if (cur) {
 		if (option_debug)
@@ -1909,7 +1909,7 @@
 		res = ast_channel_masquerade(cur, chan);
 		if (res)
 			ast_log(LOG_WARNING, "Unable to masquerade '%s' into '%s'\n", chan->name, cur->name);		/* Done */
-		ast_mutex_unlock(&cur->lock);
+		ast_channel_unlock(cur);
 	} else	{
 		if (option_debug)
 			ast_log(LOG_DEBUG, "No call pickup possible...\n");

Modified: trunk/res/res_monitor.c
===================================================================
--- trunk/res/res_monitor.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/res/res_monitor.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -211,7 +211,7 @@
 			ast_log(LOG_WARNING, "Could not create file %s\n",
 						monitor->read_filename);
 			free(monitor);
-			ast_mutex_unlock(&chan->lock);
+			ast_channel_unlock(chan);
 			return -1;
 		}
 		if (ast_fileexists(monitor->write_filename, NULL, NULL) > 0) {
@@ -224,7 +224,7 @@
 						monitor->write_filename);
 			ast_closestream(monitor->read_stream);
 			free(monitor);
-			ast_mutex_unlock(&chan->lock);
+			ast_channel_unlock(chan);
 			return -1;
 		}
 		chan->monitor = monitor;
@@ -492,7 +492,7 @@
 		/* No filename base specified, default to channel name as per CLI */		
 		if (!(fname = ast_strdup(c->name))) {
 			astman_send_error(s, m, "Could not start monitoring channel");
-			ast_mutex_unlock(&c->lock);
+			ast_channel_unlock(c);
 			return 0;
 		}
 		/* Channels have the format technology/channel_name - have to replace that /  */
@@ -503,7 +503,7 @@
 	if (ast_monitor_start(c, format, fname, 1)) {
 		if (ast_monitor_change_fname(c, fname, 1)) {
 			astman_send_error(s, m, "Could not start monitoring channel");
-			ast_mutex_unlock(&c->lock);
+			ast_channel_unlock(c);
 			return 0;
 		}
 	}
@@ -512,7 +512,7 @@
 		ast_monitor_setjoinfiles(c, 1);
 	}
 
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	astman_send_ack(s, m, "Started monitoring channel");
 	return 0;
 }
@@ -537,7 +537,7 @@
 		return 0;
 	}
 	res = ast_monitor_stop(c, 1);
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	if (res) {
 		astman_send_error(s, m, "Could not stop monitoring channel");
 		return 0;
@@ -574,10 +574,10 @@
 	}
 	if (ast_monitor_change_fname(c, fname, 1)) {
 		astman_send_error(s, m, "Could not change monitored filename of channel");
-		ast_mutex_unlock(&c->lock);
+		ast_channel_unlock(c);
 		return 0;
 	}
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	astman_send_ack(s, m, "Changed monitor filename");
 	return 0;
 }
@@ -617,7 +617,7 @@
 	else
 		ast_monitor_unpause(c);
 	
-	ast_mutex_unlock(&c->lock);
+	ast_channel_unlock(c);
 	astman_send_ack(s, m, "Paused monitoring of the channel");
 	return 0;	
 }

Modified: trunk/res/snmp/agent.c
===================================================================
--- trunk/res/snmp/agent.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/res/snmp/agent.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -216,7 +216,7 @@
     for (chan = ast_channel_walk_locked(NULL);
 		 chan && i;
 		 chan = ast_channel_walk_locked(chan), i--)
-		ast_mutex_unlock(&chan->lock);
+		ast_channel_unlock(chan);
     if (chan == NULL)
 		return NULL;
 	*var_len = sizeof(long_ret);
@@ -513,7 +513,7 @@
 		ret = NULL;
 		break;
     }
-    ast_mutex_unlock(&chan->lock);
+    ast_channel_unlock(chan);
     return ret;
 }
 
@@ -583,7 +583,7 @@
 	case ASTCHANTYPECHANNELS:
 		long_ret = 0;
 		for (chan = ast_channel_walk_locked(NULL); chan; chan = ast_channel_walk_locked(chan)) {
-			ast_mutex_unlock(&chan->lock);
+			ast_channel_unlock(chan);
 			if (chan->tech == tech)
 				long_ret++;
 		}

Modified: trunk/udptl.c
===================================================================
--- trunk/udptl.c	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/udptl.c	2006-04-30 14:53:08 UTC (rev 13)
@@ -996,24 +996,24 @@
 	void *pvt1;
 	int to;
 	
-	ast_mutex_lock(&c0->lock);
-	while (ast_mutex_trylock(&c1->lock)) {
-		ast_mutex_unlock(&c0->lock);
+	ast_channel_lock(c0);
+	while (ast_channel_trylock(c1)) {
+		ast_channel_unlock(c0);
 		usleep(1);
-		ast_mutex_lock(&c0->lock);
+		ast_channel_lock(c0);
 	}
 	pr0 = get_proto(c0);
 	pr1 = get_proto(c1);
 	if (!pr0) {
 		ast_log(LOG_WARNING, "Can't find native functions for channel '%s'\n", c0->name);
-		ast_mutex_unlock(&c0->lock);
-		ast_mutex_unlock(&c1->lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return -1;
 	}
 	if (!pr1) {
 		ast_log(LOG_WARNING, "Can't find native functions for channel '%s'\n", c1->name);
-		ast_mutex_unlock(&c0->lock);
-		ast_mutex_unlock(&c1->lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return -1;
 	}
 	pvt0 = c0->tech_pvt;
@@ -1022,8 +1022,8 @@
 	p1 = pr1->get_udptl_info(c1);
 	if (!p0 || !p1) {
 		/* Somebody doesn't want to play... */
-		ast_mutex_unlock(&c0->lock);
-		ast_mutex_unlock(&c1->lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return -2;
 	}
 	if (pr0->set_udptl_peer(c0, p1)) {
@@ -1038,8 +1038,8 @@
 		/* Store UDPTL peer */
 		ast_udptl_get_peer(p0, &ac0);
 	}
-	ast_mutex_unlock(&c0->lock);
-	ast_mutex_unlock(&c1->lock);
+	ast_channel_unlock(c0);
+	ast_channel_unlock(c1);
 	cs[0] = c0;
 	cs[1] = c1;
 	cs[2] = NULL;

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-04-29 14:18:03 UTC (rev 12)
+++ trunk/utils/Makefile	2006-04-30 14:53:08 UTC (rev 13)
@@ -57,16 +57,18 @@
 stereorize: stereorize.o frame.o
 	$(CC) $(CFLAGS) -o stereorize stereorize.o frame.o -lm
 
+.PHONY: ../ast_expr2.c ../ast_expr2f.c ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ../pbx/pbx_ael.o
+
 ast_expr2.o: ../ast_expr2.c
-	gcc -g -c -o $@ $<
+	gcc  $(CFLAGS) -include ../include/autoconfig.h -c -o $@ $<
 
 ast_expr2f.o: ../ast_expr2f.c
-	gcc -g -c -DSTANDALONE -o $@ $<
+	gcc  $(CFLAGS) -include ../include/autoconfig.h -c -DSTANDALONE -o $@ $<
 
 check_expr: check_expr.c ast_expr2.o ast_expr2f.o
 	$(CC) $(CFLAGS) -o $@ $^
 
-aelparse : ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ../pbx/pbx_ael.o ael_main.o ../ast_expr2f.o ../ast_expr2.o
+aelparse : ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ../pbx/pbx_ael.o ael_main.o ast_expr2f.o ast_expr2.o
 	$(CC) $(CFLAGS) -g -o aelparse ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ael_main.o ../pbx/pbx_ael.o ../ast_expr2f.o ../ast_expr2.o
 
 ael_main.o : ael_main.c ../include/asterisk/ael_structs.h



From solid-pbx-svn-admin at lists.berlios.de  Sun Apr 30 17:43:08 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 30 Apr 2006 17:43:08 +0200
Subject: [solid-pbx-svn] r15 - in trunk: . apps cdr channels db1-ast doc editline include/asterisk pbx pbx/ael utils
Message-ID: <200604301543.k3UFh8Qs032286@sheep.berlios.de>

Author: casper2
Date: 2006-04-30 17:42:56 +0200 (Sun, 30 Apr 2006)
New Revision: 15

Modified:
   trunk/Makefile
   trunk/UPGRADE.txt
   trunk/apps/Makefile
   trunk/asterisk.c
   trunk/cdr.c
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/channels/chan_zap.c
   trunk/configure.ac
   trunk/db1-ast/Makefile
   trunk/doc/asterisk-conf.txt
   trunk/editline/configure
   trunk/editline/makelist
   trunk/include/asterisk/options.h
   trunk/pbx/Makefile
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael.tab.c
   trunk/pbx/ael/ael.tab.h
   trunk/pbx/ael/ael.y
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/pbx_ael.c
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r23704
------------------------------------------------------------------------
r23557 | rizzo | 2006-04-30 11:24:04 +0200 (Sun, 30 Apr 2006) | 2 lines

more comments

------------------------------------------------------------------------
r23581 | kpfleming | 2006-04-30 13:20:09 +0200 (Sun, 30 Apr 2006) | 10 lines

Merged revisions 23580 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r23580 | kpfleming | 2006-04-30 06:19:04 -0500 (Sun, 30 Apr 2006) | 2 lines

ensure that the script output is correctly generated when the system's character set does not use the English lowercase/uppercase character groups

.......

------------------------------------------------------------------------
r23582 | kpfleming | 2006-04-30 13:40:06 +0200 (Sun, 30 Apr 2006) | 4 lines

simplify CFLAGS handling for subdirectories
don't put paths into the include search path when they are not needed
don't auto-rebuild the AEL bison/flex output based on make dependencies (the generated files are already checked in, and the timestamps generated by a checkout will usually cause them to be overwritten)

------------------------------------------------------------------------
r23611 | rizzo | 2006-04-30 14:12:39 +0200 (Sun, 30 Apr 2006) | 2 lines

simplify updating the token position markers

------------------------------------------------------------------------
r23612 | rizzo | 2006-04-30 14:14:33 +0200 (Sun, 30 Apr 2006) | 3 lines

remove some commented-out code


------------------------------------------------------------------------
r23613 | rizzo | 2006-04-30 14:30:08 +0200 (Sun, 30 Apr 2006) | 6 lines

make destroy_pval able to handle a NULL value
(the warning should be removed);
define a 'elements_block' rule to simplify some other rules
removing duplicated code - runtests seems happy with this.


------------------------------------------------------------------------
r23614 | rizzo | 2006-04-30 14:44:54 +0200 (Sun, 30 Apr 2006) | 3 lines

more merge of common blocks through intermediate rules.


------------------------------------------------------------------------
r23615 | rizzo | 2006-04-30 14:46:15 +0200 (Sun, 30 Apr 2006) | 2 lines

another client for switchlist_block

------------------------------------------------------------------------
r23637 | kpfleming | 2006-04-30 15:39:49 +0200 (Sun, 30 Apr 2006) | 11 lines

Merged revisions 23636 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r23636 | kpfleming | 2006-04-30 08:38:22 -0500 (Sun, 30 Apr 2006) | 4 lines

remove extraneous -m64 flag that is not needed
(these are coming from Debian patches <G>)

.......

------------------------------------------------------------------------
r23639 | kpfleming | 2006-04-30 15:56:37 +0200 (Sun, 30 Apr 2006) | 10 lines

Merged revisions 23638 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r23638 | kpfleming | 2006-04-30 08:55:59 -0500 (Sun, 30 Apr 2006) | 2 lines

let the compiler determine whether hardware or software floating point should be used (like we do in the editline subdirectory)

.......

------------------------------------------------------------------------
r23640 | rizzo | 2006-04-30 15:57:08 +0200 (Sun, 30 Apr 2006) | 5 lines

introduce a new frontend to npval for the very common case
of creating an object for a tring value PV_WORD.
Start using it.


------------------------------------------------------------------------
r23669 | rizzo | 2006-04-30 16:06:04 +0200 (Sun, 30 Apr 2006) | 3 lines

more nword() usages, and mark some dubious places.


------------------------------------------------------------------------
r23670 | kpfleming | 2006-04-30 16:09:13 +0200 (Sun, 30 Apr 2006) | 2 lines

remove unusable MFC/R2 support

------------------------------------------------------------------------
r23671 | kpfleming | 2006-04-30 16:10:48 +0200 (Sun, 30 Apr 2006) | 2 lines

document the removal of MFC/R2 support

------------------------------------------------------------------------
r23672 | russell | 2006-04-30 16:12:14 +0200 (Sun, 30 Apr 2006) | 2 lines

fix up the app_rpt.o target.  oops!  (Thanks to Denis Smirnov on the -dev list)

------------------------------------------------------------------------
r23674 | kpfleming | 2006-04-30 16:28:25 +0200 (Sun, 30 Apr 2006) | 10 lines

Merged revisions 23673 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r23673 | kpfleming | 2006-04-30 09:27:56 -0500 (Sun, 30 Apr 2006) | 2 lines

allow top-level OPTIMIZE setting to affect builds in these subdirectories too

.......

------------------------------------------------------------------------
r23675 | kpfleming | 2006-04-30 16:55:05 +0200 (Sun, 30 Apr 2006) | 3 lines

add a command-line flag and option to force forking, even with -v or -d
rename a flag to have the proper name

------------------------------------------------------------------------
r23704 | russell | 2006-04-30 17:29:38 +0200 (Sun, 30 Apr 2006) | 2 lines

fix a libtonezone detection issue on FreeBSD

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -196,8 +196,9 @@
 endif
 
 ASTCFLAGS+=$(MENUSELECT_CFLAGS)
-TOPDIR_CFLAGS=-include include/autoconfig.h
-MOD_SUBDIR_CFLAGS=-include ../include/autoconfig.h
+TOPDIR_CFLAGS=-include include/autoconfig.h -Iinclude
+MOD_SUBDIR_CFLAGS=-include ../include/autoconfig.h -I../include -I..
+OTHER_SUBDIR_CFLAGS=-include ../include/autoconfig.h -I../include -I..
 
 #   *CLI> show memory allocations [filename]
 #   *CLI> show memory summary [filename]
@@ -213,7 +214,6 @@
     # You must have GCC 3.4 to use k8, otherwise use athlon
     PROC=k8
     #PROC=athlon
-    OPTIONS+=-m64
   endif
 
   ifeq ($(PROC),sparc64)
@@ -234,9 +234,9 @@
       OPTIONS+=-fsigned-char -mcpu=ep9312
     else
       ifeq ($(SUB_PROC),xscale)
-        OPTIONS+=-fsigned-char -msoft-float -mcpu=xscale
+        OPTIONS+=-fsigned-char -mcpu=xscale
       else
-        OPTIONS+=-fsigned-char -msoft-float 
+        OPTIONS+=-fsigned-char 
       endif
     endif
   endif
@@ -252,7 +252,6 @@
   ID=/usr/xpg4/bin/id
 endif
 
-INCLUDE+=-Iinclude -I../include -I..
 ASTCFLAGS+=-pipe  -Wall -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations $(DEBUG) $(INCLUDE) #-DMAKE_VALGRIND_HAPPY
 ASTCFLAGS+=$(OPTIMIZE)
 
@@ -465,10 +464,10 @@
 endif
 
 editline/config.h:
-	cd editline && unset CFLAGS LIBS && ./configure ; \
+	cd editline && unset CFLAGS LIBS && CFLAGS="$(OPTIMIZE)" ./configure ; \
 
 editline/libedit.a:
-	cd editline && unset CFLAGS LIBS && test -f config.h || ./configure
+	cd editline && unset CFLAGS LIBS && test -f config.h || CFLAGS="$(OPTIMIZE)" ./configure
 	$(MAKE) -C editline libedit.a
 
 db1-ast/libdb1.a:
@@ -545,8 +544,8 @@
 
 subdirs: 
 	for x in $(MOD_SUBDIRS); do CFLAGS="$(ASTCFLAGS) $(MOD_SUBDIR_CFLAGS)" $(MAKE) -C $$x || exit 1 ; done
-	CFLAGS="$(ASTCFLAGS)" $(MAKE) -C utils
-	CFLAGS="$(ASTCFLAGS) -include ../include/autoconfig.h" $(MAKE) -C agi
+	CFLAGS="$(ASTCFLAGS) $(OTHER_SUBDIR_CFLAGS)" $(MAKE) -C utils
+	CFLAGS="$(ASTCFLAGS) $(OTHER_SUBDIR_CFLAGS)" $(MAKE) -C agi
 
 clean-depend:
 	for x in $(SUBDIRS); do $(MAKE) -C $$x clean-depend || exit 1 ; done

Modified: trunk/UPGRADE.txt
===================================================================
--- trunk/UPGRADE.txt	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/UPGRADE.txt	2006-04-30 15:42:56 UTC (rev 15)
@@ -122,6 +122,11 @@
   option in sip.conf is removed to osp.conf as authpolicy. allowguest option
   in sip.conf cannot be set as osp anymore. 
 
+The Zap channel:
+
+* Support for MFC/R2 has been removed, as it has not been functional for some time
+  and it has no maintainer.
+
 Installation:
 
 * On BSD systems, the installation directories have changed to more "FreeBSDish" directories. On startup, Asterisk will look for the main configuration in /usr/local/etc/asterisk/asterisk.conf

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/apps/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -41,7 +41,7 @@
 	$(CC) $(SOLINK) -o $@ $< $(ZAPTEL_LIB)
 
 app_rpt.o: app_rpt.c
-	$(CC) $(SOLINK) -o $@ $< $(ZAPTEL_INCLUDE)
+	$(CC) -c -o $@ $(CFLAGS) $(ZAPTEL_INCLUDE) $<
 
 install: all
 	for x in $(MODS); do $(INSTALL) -m 755 $$x $(DESTDIR)$(MODULES_DIR) ; done

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/asterisk.c	2006-04-30 15:42:56 UTC (rev 15)
@@ -2179,6 +2179,9 @@
 		/* Disable forking (-f at startup) */
 		} else if (!strcasecmp(v->name, "nofork")) {
 			ast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_NO_FORK);
+		/* Always fork, even if verbose or debug are enabled (-F at startup) */
+		} else if (!strcasecmp(v->name, "alwaysfork")) {
+			ast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_ALWAYS_FORK);
 		/* Run quietly (-q at startup ) */
 		} else if (!strcasecmp(v->name, "quiet")) {
 			ast_set2_flag(&ast_options, ast_true(v->value), AST_OPT_FLAG_QUIET);
@@ -2289,6 +2292,9 @@
 	/* Check for options */
 	while ((c = getopt(argc, argv, "tThfdvVqprRgciInx:U:G:C:L:M:")) != -1) {
 		switch (c) {
+		case 'F':
+			ast_set_flag(&ast_options, AST_OPT_FLAG_ALWAYS_FORK);
+			break;
 		case 'd':
 			option_debug++;
 			ast_set_flag(&ast_options, AST_OPT_FLAG_NO_FORK);
@@ -2366,6 +2372,11 @@
 		}
 	}
 
+	if (ast_opt_always_fork && (ast_opt_remote || ast_opt_console)) {
+		ast_log(LOG_WARNING, "'alwaysfork' is not compatible with console or remote console mode; ignored\n");
+		ast_clear_flag(&ast_options, AST_OPT_FLAG_ALWAYS_FORK);
+	}
+
 	/* For remote connections, change the name of the remote connection.
 	 * We do this for the benefit of init scripts (which need to know if/when
 	 * the main asterisk process has died yet). */
@@ -2506,7 +2517,7 @@
 	} else
 		ast_log(LOG_WARNING, "Unable to open pid file '%s': %s\n", ast_config_AST_PID, strerror(errno));
 
-	if (!option_verbose && !option_debug && !ast_opt_no_fork && !ast_opt_console) {
+	if (ast_opt_always_fork || !ast_opt_no_fork) {
 		daemon(0, 0);
 		/* Blindly re-write pid file since we are forking */
 		unlink(ast_config_AST_PID);

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/cdr/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -20,7 +20,7 @@
 #the default as we now have a better instruction set to work with. - Belgarath
 ifeq ($(PROC),sparc64)
   PROC=ultrasparc
-  CFLAGS += -mtune=$(PROC) -O3 -pipe -fomit-frame-pointer -mcpu=v8
+  CFLAGS += -mtune=$(PROC) -pipe -fomit-frame-pointer -mcpu=v8
 endif
 
 ifneq ($(TDS_LIB),)

Modified: trunk/cdr.c
===================================================================
--- trunk/cdr.c	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/cdr.c	2006-04-30 15:42:56 UTC (rev 15)
@@ -1087,7 +1087,7 @@
 				batchtime = cfg_time;
 		}
 		if ((end_before_h_value = ast_variable_retrieve(config, "general", "endbeforehexten")))
-			ast_set2_flag(&ast_options, ast_true(end_before_h_value), AST_OPT_END_CDR_BEFORE_H_EXTEN);
+			ast_set2_flag(&ast_options, ast_true(end_before_h_value), AST_OPT_FLAG_END_CDR_BEFORE_H_EXTEN);
 	}
 
 	if (enabled && !batchmode) {

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/channels/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -26,7 +26,7 @@
 
 ifeq ($(PROC),sparc64)
   PROC=ultrasparc
-  CFLAGS += -mtune=$(PROC) -O3 -pipe -fomit-frame-pointer -mcpu=v8
+  CFLAGS += -mtune=$(PROC) -pipe -fomit-frame-pointer -mcpu=v8
 endif
 
 ifeq ($(OSARCH),FreeBSD)
@@ -117,7 +117,7 @@
 	$(CC) $(SOLINK) -o $@ $< iax2-parser.o iax2-provision.o
 
 chan_zap.so: chan_zap.o
-	$(CC) $(SOLINK) -o $@ $< $(PRI_LIB) $(MFCR2_LIB) $(ZAPTEL_LIB)
+	$(CC) $(SOLINK) -o $@ $< $(PRI_LIB) $(ZAPTEL_LIB)
 
 chan_zap.o: chan_zap.c
 	$(CC) -c -o $@ $(CFLAGS) $(ZAPTEL_INCLUDE) $<

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/channels/chan_zap.c	2006-04-30 15:42:56 UTC (rev 15)
@@ -73,9 +73,6 @@
 #error "You need newer libpri"
 #endif
 #endif
-#ifdef HAVE_MFCR2
-#include <libmfcr2.h>
-#endif
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision: 22932 $")
 
@@ -157,9 +154,6 @@
 #ifdef HAVE_LIBPRI
                " w/PRI"
 #endif
-#ifdef HAVE_MFCR2
-               " w/R2"
-#endif
 ;
 
 static const char config[] = "zapata.conf";
@@ -180,7 +174,6 @@
 #define SIG_FXOGS	ZT_SIG_FXOGS
 #define SIG_FXOKS	ZT_SIG_FXOKS
 #define SIG_PRI		ZT_SIG_CLEAR
-#define SIG_R2		ZT_SIG_CAS
 #define	SIG_SF		ZT_SIG_SF
 #define SIG_SFWINK 	(0x0100000 | ZT_SIG_SF)
 #define SIG_SF_FEATD	(0x0200000 | ZT_SIG_SF)
@@ -400,11 +393,6 @@
 
 struct zt_pvt;
 
-
-#ifdef HAVE_MFCR2
-static int r2prot = -1;
-#endif
-
 static int ringt_base = DEFAULT_RINGT;
 
 #ifdef HAVE_LIBPRI
@@ -608,11 +596,6 @@
 	unsigned int resetting:1;
 	unsigned int setup_ack:1;
 #endif
-#if defined(HAVE_MFCR2)
-	unsigned int hasr2call:1;
-	unsigned int r2blocked:1;
-	unsigned int sigchecked:1;
-#endif
 #ifdef WITH_SMDI
 	unsigned int use_smdi:1;		/* Whether to use SMDI on this channel */
 	struct ast_smdi_interface *smdi_iface;	/* The serial port to listen for SMDI data on */
@@ -698,10 +681,6 @@
 	int prioffset;
 	int logicalspan;
 #endif	
-#ifdef HAVE_MFCR2
-	int r2prot;
-	mfcr2_t *r2;
-#endif	
 	int polarity;
 	int dsp_features;
 
@@ -1132,22 +1111,6 @@
 }
 #endif
 
-#ifdef HAVE_MFCR2
-static int str2r2prot(char *swtype)
-{
-	 if (!strcasecmp(swtype, "ar"))
-		  return MFCR2_PROT_ARGENTINA;
-	 /*endif*/
-	 if (!strcasecmp(swtype, "cn"))
-		  return MFCR2_PROT_CHINA;
-	 /*endif*/
-	 if (!strcasecmp(swtype, "kr"))
-		  return MFCR2_PROT_KOREA;
-	 /*endif*/
-	 return -1;
-}
-#endif
-
 static char *zap_sig2str(int sig)
 {
 	static char buf[256];
@@ -1186,8 +1149,6 @@
 		return "FXO Kewlstart";
 	case SIG_PRI:
 		return "PRI Signalling";
-	case SIG_R2:
-		return "R2 Signalling";
 	case SIG_SF:
 		return "SF (Tone) Signalling Immediate";
 	case SIG_SFWINK:
@@ -2596,18 +2557,7 @@
 			}
 		}
 #endif
-#ifdef HAVE_MFCR2
-		if (p->sig == SIG_R2) {
-			if (p->hasr2call) {
-				mfcr2_DropCall(p->r2, NULL, UC_NORMAL_CLEARING);
-				p->hasr2call = 0;
-				res = 0;
-			} else
-				res = 0;
-
-		}
-#endif
-		if (p->sig && (p->sig != SIG_PRI) && (p->sig != SIG_R2))
+		if (p->sig && (p->sig != SIG_PRI))
 			res = zt_set_hook(p->subs[SUB_REAL].zfd, ZT_ONHOOK);
 		if (res < 0) {
 			ast_log(LOG_WARNING, "Unable to hangup line %s\n", ast->name);
@@ -2786,13 +2736,6 @@
 		}
 		break;
 #endif
-#ifdef HAVE_MFCR2
-	case SIG_R2:
-		res = mfcr2_AnswerCall(p->r2, NULL);
-		if (res)
-			ast_log(LOG_WARNING, "R2 Answer call failed :( on %s\n", ast->name);
-		break;
-#endif			
 	case 0:
 		ast_mutex_unlock(&p->lock);
 		return 0;
@@ -3499,78 +3442,6 @@
 	return 0;
 }
 
-#ifdef HAVE_MFCR2
-static struct ast_frame *handle_r2_event(struct zt_pvt *p, mfcr2_event_t *e, int index)
-{
-	struct ast_frame *f;
-	f = &p->subs[index].f;
-	if (!p->r2) {
-		ast_log(LOG_WARNING, "Huh?  No R2 structure :(\n");
-		return NULL;
-	}
-	switch(e->e) {
-	case MFCR2_EVENT_BLOCKED:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Channel %d blocked\n", p->channel);
-		break;
-	case MFCR2_EVENT_UNBLOCKED:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Channel %d unblocked\n", p->channel);
-		break;
-	case MFCR2_EVENT_CONFIG_ERR:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Config error on channel %d\n", p->channel);
-		break;
-	case MFCR2_EVENT_RING:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Ring on channel %d\n", p->channel);
-		break;
-	case MFCR2_EVENT_HANGUP:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Hangup on channel %d\n", p->channel);
-		break;
-	case MFCR2_EVENT_RINGING:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Ringing on channel %d\n", p->channel);
-		break;
-	case MFCR2_EVENT_ANSWER:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Answer on channel %d\n", p->channel);
-		break;
-	case MFCR2_EVENT_HANGUP_ACK:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Hangup ACK on channel %d\n", p->channel);
-		break;
-	case MFCR2_EVENT_IDLE:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Idle on channel %d\n", p->channel);
-		break;
-	default:
-		ast_log(LOG_WARNING, "Unknown MFC/R2 event %d\n", e->e);
-		break;
-	}
-	return f;
-}
-
-static mfcr2_event_t *r2_get_event_bits(struct zt_pvt *p)
-{
-	int x;
-	int res;
-	mfcr2_event_t *e;
-	res = ioctl(p->subs[SUB_REAL].zfd, ZT_GETRXBITS, &x);
-	if (res) {
-		ast_log(LOG_WARNING, "Unable to check received bits\n");
-		return NULL;
-	}
-	if (!p->r2) {
-		ast_log(LOG_WARNING, "Odd, no R2 structure on channel %d\n", p->channel);
-		return NULL;
-	}
-	e = mfcr2_cas_signaling_event(p->r2, x);
-	return e;
-}
-#endif
-
 static int check_for_conference(struct zt_pvt *p)
 {
 	ZT_CONFINFO ci;
@@ -3690,18 +3561,6 @@
 			break;
 #endif
 		case ZT_EVENT_BITSCHANGED:
-			if (p->sig == SIG_R2) {
-#ifdef HAVE_MFCR2
-				struct ast_frame  *f = &p->subs[index].f;
-				mfcr2_event_t *e;
-				e = r2_get_event_bits(p);
-				if (e)
-					f = handle_r2_event(p, e, index);
-				return f;
-#else				
-				break;
-#endif
-			}
 			ast_log(LOG_WARNING, "Recieved bits changed on %s signalling?\n", sig2str(p->sig));
 		case ZT_EVENT_PULSE_START:
 			/* Stop tone if there's a pulse start and the PBX isn't started */
@@ -6450,50 +6309,6 @@
 	return NULL;
 }
 
-#ifdef HAVE_MFCR2
-static int handle_init_r2_event(struct zt_pvt *i, mfcr2_event_t *e)
-{
-	struct ast_channel *chan;
-	
-	switch(e->e) {
-	case MFCR2_EVENT_UNBLOCKED:
-		i->r2blocked = 0;
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "R2 Channel %d unblocked\n", i->channel);
-		break;
-	case MFCR2_EVENT_BLOCKED:
-		i->r2blocked = 1;
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "R2 Channel %d unblocked\n", i->channel);
-		break;
-	case MFCR2_EVENT_IDLE:
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "R2 Channel %d idle\n", i->channel);
-		break;
-	case MFCR2_EVENT_RINGING:
-			/* This is what Asterisk refers to as a "RING" event. For some reason they're reversed in
-			   Steve's code */
-			/* Check for callerid, digits, etc */
-			i->hasr2call = 1;
-			chan = zt_new(i, AST_STATE_RING, 0, SUB_REAL, 0, 0);
-			if (!chan) {
-				ast_log(LOG_WARNING, "Unable to create channel for channel %d\n", i->channel);
-				mfcr2_DropCall(i->r2, NULL, UC_NETWORK_CONGESTION);
-				i->hasr2call = 0;
-			}
-			if (ast_pbx_start(chan)) {
-				ast_log(LOG_WARNING, "Unable to start PBX on channel %s\n", chan->name);
-				ast_hangup(chan);
-			}
-			break;
-	default:
-		ast_log(LOG_WARNING, "Don't know how to handle initial R2 event %s on channel %d\n", mfcr2_event2str(e->e), i->channel);	
-		return -1;
-	}
-	return 0;
-}
-#endif
-
 static int handle_init_event(struct zt_pvt *i, int event)
 {
 	int res;
@@ -6506,16 +6321,6 @@
 	switch(event) {
 	case ZT_EVENT_NONE:
 	case ZT_EVENT_BITSCHANGED:
-		if (i->radio) break;
-#ifdef HAVE_MFCR2
-		if (i->r2) {
-			mfcr2_event_t *e;
-			e = r2_get_event_bits(i);
-			i->sigchecked = 1;
-			if (e)
-				handle_init_r2_event(i, e);
-		}
-#endif		
 		break;
 	case ZT_EVENT_WINKFLASH:
 	case ZT_EVENT_RINGOFFHOOK:
@@ -6743,11 +6548,7 @@
 					pfds[count].events = POLLPRI;
 					pfds[count].revents = 0;
 					/* Message waiting or r2 channels also get watched for reading */
-#ifdef HAVE_MFCR2
-					if (i->cidspill || i->r2)
-#else					
 					if (i->cidspill)
-#endif					
 						pfds[count].events |= POLLIN;
 					count++;
 				}
@@ -6844,22 +6645,6 @@
 						i = i->next;
 						continue;
 					}
-#ifdef HAVE_MFCR2
-					if (i->r2) {
-						/* If it's R2 signalled, we always have to check for events */
-						mfcr2_event_t *e;
-						e = mfcr2_check_event(i->r2);
-						if (e)
-							handle_init_r2_event(i, e);
-						else {
-							e = mfcr2_schedule_run(i->r2);
-							if (e)
-								handle_init_r2_event(i, e);
-						}
-						i = i->next;
-						continue;
-					}
-#endif
 					if (!i->cidspill) {
 						ast_log(LOG_WARNING, "Whoa....  I'm reading but have no cidspill (%d)...\n", i->subs[SUB_REAL].zfd);
 						i = i->next;
@@ -6893,12 +6678,7 @@
 					handle_init_event(i, res);
 					ast_mutex_lock(&iflock);	
 				}
-#ifdef HAVE_MFCR2
-				if ((pollres & POLLPRI) || (i->r2 && !i->sigchecked)) 
-#else				
-				if (pollres & POLLPRI) 
-#endif				
-				{
+				if (pollres & POLLPRI) {
 					if (i->owner || i->subs[SUB_REAL].owner) {
 #ifdef HAVE_LIBPRI
 						if (!i->pri)
@@ -7293,26 +7073,6 @@
 				tmp->prioffset = 0;
 			}
 #endif
-#ifdef HAVE_MFCR2
-			if (signalling == SIG_R2) {
-				if (r2prot < 0) {
-					ast_log(LOG_WARNING, "R2 Country not specified for channel %d -- Assuming China\n", tmp->channel);
-					tmp->r2prot = MFCR2_PROT_CHINA;
-				} else
-					tmp->r2prot = r2prot;
-				tmp->r2 = mfcr2_new(tmp->subs[SUB_REAL].zfd, tmp->r2prot, 1);
-				if (!tmp->r2) {
-					ast_log(LOG_WARNING, "Unable to create r2 call :(\n");
-					zt_close(tmp->subs[SUB_REAL].zfd);
-					destroy_zt_pvt(&tmp);
-					return NULL;
-				}
-			} else {
-				if (tmp->r2) 
-					mfcr2_free(tmp->r2);
-				tmp->r2 = NULL;
-			}
-#endif
 		} else {
 			signalling = tmp->sig;
 			radio = tmp->radio;
@@ -7484,7 +7244,7 @@
 				ast_dsp_digitmode(tmp->dsp, DSP_DIGITMODE_DTMF | tmp->dtmfrelax);
 			update_conf(tmp);
 			if (!here) {
-				if ((signalling != SIG_PRI) && (signalling != SIG_R2))
+				if (signalling != SIG_PRI)
 					/* Hang it up to be sure it's good */
 					zt_set_hook(tmp->subs[SUB_REAL].zfd, ZT_ONHOOK);
 			}
@@ -7598,15 +7358,6 @@
 				return 1;
 		}
 #endif
-#ifdef HAVE_MFCR2
-		/* Trust R2 as well */
-		if (p->r2) {
-			if (p->hasr2call || p->r2blocked)
-				return 0;
-			else
-				return 1;
-		}
-#endif
 		if (!(p->radio || (p->oprmode < 0)))
 		{
 			if (!p->sig || (p->sig == SIG_FXSLS))
@@ -9742,85 +9493,6 @@
 
 #endif /* HAVE_LIBPRI */
 
-
-#ifdef HAVE_MFCR2
-static int handle_r2_no_debug(int fd, int argc, char *argv[])
-{
-	int chan;
-	struct zt_pvt *tmp = NULL;;
-	if (argc < 5)
-		return RESULT_SHOWUSAGE;
-	chan = atoi(argv[4]);
-	if ((chan < 1) || (chan > NUM_SPANS)) {
-		ast_cli(fd, "Invalid channel %s.  Should be a number greater than 0\n", argv[4]);
-		return RESULT_SUCCESS;
-	}
-	tmp = iflist;
-	while(tmp) {
-		if (tmp->channel == chan) {
-			if (tmp->r2) {
-				mfcr2_set_debug(tmp->r2, 0);
-				ast_cli(fd, "Disabled R2 debugging on channel %d\n", chan);
-				return RESULT_SUCCESS;
-			}
-			break;
-		}
-		tmp = tmp->next;
-	}
-	if (tmp) 
-		ast_cli(fd, "No R2 running on channel %d\n", chan);
-	else
-		ast_cli(fd, "No such zap channel %d\n", chan);
-	return RESULT_SUCCESS;
-}
-
-static int handle_r2_debug(int fd, int argc, char *argv[])
-{
-	int chan;
-	struct zt_pvt *tmp = NULL;;
-	if (argc < 4) {
-		return RESULT_SHOWUSAGE;
-	}
-	chan = atoi(argv[3]);
-	if ((chan < 1) || (chan > NUM_SPANS)) {
-		ast_cli(fd, "Invalid channel %s.  Should be a number greater than 0\n", argv[3]);
-		return RESULT_SUCCESS;
-	}
-	tmp = iflist;
-	while(tmp) {
-		if (tmp->channel == chan) {
-			if (tmp->r2) {
-				mfcr2_set_debug(tmp->r2, 0xFFFFFFFF);
-				ast_cli(fd, "Enabled R2 debugging on channel %d\n", chan);
-				return RESULT_SUCCESS;
-			}
-			break;
-		}
-		tmp = tmp->next;
-	}
-	if (tmp) 
-		ast_cli(fd, "No R2 running on channel %d\n", chan);
-	else
-		ast_cli(fd, "No such zap channel %d\n", chan);
-	return RESULT_SUCCESS;
-}
-static char r2_debug_help[] = 
-	"Usage: r2 debug channel <channel>\n"
-	"       Enables R2 protocol level debugging on a given channel\n";
-	
-static char r2_no_debug_help[] = 
-	"Usage: r2 no debug channel <channel>\n"
-	"       Enables R2 protocol level debugging on a given channel\n";
-
-static struct ast_cli_entry zap_r2_cli[] = {
-	{ { "r2", "debug", "channel", NULL }, handle_r2_debug,
-	  "Enables R2 debugging on a channel", r2_debug_help },
-	{ { "r2", "no", "debug", "channel", NULL }, handle_r2_no_debug,
-	  "Disables R2 debugging on a channel", r2_no_debug_help },
-};
-
-#endif
-
 static int zap_destroy_channel(int fd, int argc, char **argv)
 {
 	int channel = 0;
@@ -10048,16 +9720,6 @@
 			}
 				
 #endif
-#ifdef HAVE_MFCR2
-			if (tmp->r2) {
-				ast_cli(fd, "R2 Flags: ");
-				if (tmp->r2blocked)
-					ast_cli(fd, "Blocked ");
-				if (tmp->hasr2call)
-					ast_cli(fd, "Call ");
-				ast_cli(fd, "\n");
-			}
-#endif
 			memset(&ci, 0, sizeof(ci));
 			ps.channo = tmp->channel;
 			if (tmp->subs[SUB_REAL].zfd > -1) {
@@ -10406,9 +10068,6 @@
 	ast_cli_unregister_multiple(zap_pri_cli, sizeof(zap_pri_cli) / sizeof(zap_pri_cli[0]));
 	ast_unregister_application(zap_send_keypad_facility_app);
 #endif
-#ifdef HAVE_MFCR2
-	ast_cli_unregister_multiple(zap_r2_cli, sizeof(zap_r2_cli) / sizeof(zap_r2_cli[0]));
-#endif
 	ast_cli_unregister_multiple(zap_cli, sizeof(zap_cli) / sizeof(zap_cli[0]));
 	ast_manager_unregister( "ZapDialOffhook" );
 	ast_manager_unregister( "ZapHangup" );
@@ -10982,11 +10641,6 @@
 					cur_radio = 0;
 					pritype = PRI_CPE;
 #endif
-#ifdef HAVE_MFCR2
-				} else if (!strcasecmp(v->value, "r2")) {
-					cur_signalling = SIG_R2;
-					cur_radio = 0;
-#endif			
 				} else {
 					ast_log(LOG_ERROR, "Unknown signalling method '%s'\n", v->value);
 				}
@@ -11026,13 +10680,6 @@
 				} else {
 					ast_log(LOG_ERROR, "Unknown signalling method '%s'\n", v->value);
 				}
-#ifdef HAVE_MFCR2
-			} else if (!strcasecmp(v->name, "r2country")) {
-				r2prot = str2r2prot(v->value);
-				if (r2prot < 0) {
-					ast_log(LOG_WARNING, "Unknown R2 Country '%s' at line %d.\n", v->value, v->lineno);
-				}
-#endif
 #ifdef HAVE_LIBPRI
 			} else if (!strcasecmp(v->name, "pridialplan")) {
 				if (!strcasecmp(v->value, "national")) {
@@ -11370,9 +11017,6 @@
 	ast_string_field_set(&inuse, name, "GR-303InUse");
 	ast_cli_register_multiple(zap_pri_cli, sizeof(zap_pri_cli) / sizeof(zap_pri_cli[0]));
 #endif	
-#ifdef HAVE_MFCR2
-	ast_cli_register_multiple(zap_r2_cli, sizeof(zap_r2_cli) / sizeof(zap_r2_cli[0]));
-#endif	
 	ast_cli_register_multiple(zap_cli, sizeof(zap_cli) / sizeof(zap_cli[0]));
 	
 	memset(round_robin, 0, sizeof(round_robin));
@@ -11504,9 +11148,6 @@
 #ifdef ZAPATA_PRI
                " w/PRI"
 #endif
-#ifdef ZAPATA_R2
-               " w/R2"
-#endif
 	;
 }
 

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/configure.ac	2006-04-30 15:42:56 UTC (rev 15)
@@ -159,7 +159,6 @@
 
 AST_EXT_LIB([asound], [snd_spcm_init], [alsa/asoundlib.h], [ALSA], [Advanced Linux Sound Architecture], [-lm -ldl])
 AST_EXT_LIB([curses], [initscr], [curses.h], [CURSES], [curses], [])
-AST_EXT_LIB([mfcr2], [mfcr2_MakeCall], [libmfcr2.h], [MFCR2], [MFCR2])
 AST_EXT_LIB([nbs], [nbs_connect], [nbs.h], [NBS], [Network Broadcast Sound])
 AST_EXT_LIB([ncurses], [initscr], [curses.h], [NCURSES], [ncurses], [])
 AST_EXT_LIB([newt], [newtBell], [newt.h], [NEWT], [newt])
@@ -186,7 +185,7 @@
 if test "x${PBX_OSTYPE}" = "xLinux" ; then
    AST_EXT_LIB([tonezone], [tone_zone_find], [linux/zaptel.h], [ZAPTEL], [Zaptel])
 else
-   AST_EXT_LIB([tonezone], [tone_zone_find], [zaptel.h], [ZAPTEL], [Zaptel])
+   AST_EXT_LIB([tonezone], [tone_zone_find], [zaptel.h], [ZAPTEL], [Zaptel], [-lm])
 fi
 
 GSM_INTERNAL="yes"

Modified: trunk/db1-ast/Makefile
===================================================================
--- trunk/db1-ast/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/db1-ast/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -10,7 +10,7 @@
 #Added support for UltraSparc - Belgarath
 ifeq ($(ARCH),sparc64)
 PROC=ultrasparc
-CFLAGS += -mtune=$(PROC) -O3 -pipe -fomit-frame-pointer -mcpu=v8
+CFLAGS += -mtune=$(PROC) -pipe -fomit-frame-pointer -mcpu=v8
 endif
 
 ifeq ($(OSARCH),Darwin)

Modified: trunk/doc/asterisk-conf.txt
===================================================================
--- trunk/doc/asterisk-conf.txt	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/doc/asterisk-conf.txt	2006-04-30 15:42:56 UTC (rev 15)
@@ -42,6 +42,7 @@
 verbose = 0					; Verbosity level for logging (-v)
 debug = 3					; Debug: "No" or value (1-4)
 nofork=yes | no					; Background execution disabled (-f)
+alwaysfork=yes | no				; Always background, even with -v or -d (-F)
 console= yes | no				; Console mode (-c)
 highpriority = yes | no				; Execute with high priority (-p)
 initcrypto = yes | no				; Initialize crypto at startup (-i)

Modified: trunk/editline/configure
===================================================================
--- trunk/editline/configure	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/editline/configure	2006-04-30 15:42:56 UTC (rev 15)
@@ -1923,8 +1923,6 @@
 if test "x$enable_debug" = "xyes" ; then
   CPPFLAGS="$CPPFLAGS -DDEBUG_TTY -DDEBUG_KEY -DDEBUG_READ -DDEBUG"
   CPPFLAGS="$CPPFLAGS -DDEBUG_REFRESH -DDEBUG_PASTE"
-else
-  CFLAGS="$CFLAGS -O"
 fi
 
 

Modified: trunk/editline/makelist
===================================================================
--- trunk/editline/makelist	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/editline/makelist	2006-04-30 15:42:56 UTC (rev 15)
@@ -145,7 +145,7 @@
 #
 -fh)
     cat $FILES | $AWK '/el_action_t/ { print $3 }' | \
-    sort | tr '[a-z]' '[A-Z]' | $AWK '
+    sort | tr '[:lower:]' '[:upper:]' | $AWK '
 	BEGIN {
 	    printf("/* Automatically generated file, do not edit */\n");
 	    printf("#ifndef _h_fcns_c\n#define _h_fcns_c\n");

Modified: trunk/include/asterisk/options.h
===================================================================
--- trunk/include/asterisk/options.h	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/include/asterisk/options.h	2006-04-30 15:42:56 UTC (rev 15)
@@ -71,9 +71,11 @@
 	/*! Suppress some warnings */
 	AST_OPT_FLAG_DONT_WARN = (1 << 18),
 	/*! End CDRs before the 'h' extension */
-	AST_OPT_END_CDR_BEFORE_H_EXTEN = (1 << 19),
+	AST_OPT_FLAG_END_CDR_BEFORE_H_EXTEN = (1 << 19),
 	/*! Use Zaptel Timing for generators if available */
-	AST_OPT_FLAG_INTERNAL_TIMING = (1 << 20)
+	AST_OPT_FLAG_INTERNAL_TIMING = (1 << 20),
+	/*! Always fork, even if verbose or debug settings are non-zero */
+	AST_OPT_FLAG_ALWAYS_FORK = (1 << 21),
 };
 
 /*! These are the options that set by default when Asterisk starts */
@@ -98,8 +100,9 @@
 #define ast_opt_reconnect		ast_test_flag(&ast_options, AST_OPT_FLAG_RECONNECT)
 #define ast_opt_transmit_silence	ast_test_flag(&ast_options, AST_OPT_FLAG_TRANSMIT_SILENCE)
 #define ast_opt_dont_warn		ast_test_flag(&ast_options, AST_OPT_FLAG_DONT_WARN)
-#define ast_opt_end_cdr_before_h_exten	ast_test_flag(&ast_options, AST_OPT_END_CDR_BEFORE_H_EXTEN)
+#define ast_opt_end_cdr_before_h_exten	ast_test_flag(&ast_options, AST_OPT_FLAG_END_CDR_BEFORE_H_EXTEN)
 #define ast_opt_internal_timing		ast_test_flag(&ast_options, AST_OPT_FLAG_INTERNAL_TIMING)
+#define ast_opt_always_fork		ast_test_flag(&ast_options, AST_OPT_FLAG_ALWAYS_FORK)
 
 extern struct ast_flags ast_options;
 

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -59,10 +59,10 @@
 ael/aelbison.o: ael/ael.tab.c ael/ael.tab.h ../include/asterisk/ael_structs.h
 	$(CC) $(CFLAGS) -I. -c -o ael/aelbison.o ael/ael.tab.c
 
-ael/ael_lex.c: ael/ael.flex
+ael/ael_lex.c:
 	(cd ael; flex ael.flex)
 
-ael/ael.tab.c ael/ael.tab.h: ael/ael.y
+ael/ael.tab.c ael/ael.tab.h:
 	(cd ael; bison -v -d ael.y)
 
 %.moc : %.h

Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/ael/ael.flex	2006-04-30 15:42:56 UTC (rev 15)
@@ -70,6 +70,8 @@
  */
 static char pbcstack[400];	/* XXX missing size checks */
 static int pbcpos = 0;
+static void pbcpush(char x);
+static int pbcpop(char x);
 
 static int parencount = 0;
 static int commaout = 0;
@@ -94,8 +96,6 @@
 void ael_yyset_column (int  column_no , yyscan_t yyscanner);
 
 int ael_yyparse (struct parse_io *);
-static void pbcpush(char x);
-static int pbcpop(char x);
 
 /*
  * A stack to process include files.
@@ -240,8 +240,7 @@
 		} else {
 			STORE_LOC;
 			yylval->str = strdup(yytext);
-			*(yylval->str+strlen(yylval->str)-1)=0;
-			/* printf("Got paren word %s\n", yylval->str); */
+			yylval->str[strlen(yylval->str)-1] = '\0'; /* trim trailing ')' */
 			unput(')');
 			BEGIN(0);
 			return word;
@@ -293,7 +292,7 @@
 			STORE_LOC;
 			yylval->str = strdup(yytext);
 			if(yyleng > 1 )
-				*(yylval->str+yyleng-1)=0;
+				yylval->str[yyleng-1] = '\0'; /* trim trailing ')' */
 			BEGIN(0);
 			if ( !strcmp(yylval->str,")") ) {
 				free(yylval->str);

Modified: trunk/pbx/ael/ael.tab.c
===================================================================
--- trunk/pbx/ael/ael.tab.c	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/ael/ael.tab.c	2006-04-30 15:42:56 UTC (rev 15)
@@ -181,10 +181,6 @@
 #include "asterisk/utils.h"		/* ast_calloc() */
 #include "asterisk/ael_structs.h"
 
-/* create a new object with start-end marker */
-static pval *npval(pvaltype type, int first_line, int last_line,
-	int first_column, int last_column);
-
 static pval * linku1(pval *head, pval *tail);
 
 void reset_parencount(yyscan_t yyscanner);
@@ -221,13 +217,14 @@
 #endif
 
 #if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 53 "ael.y"
+#line 49 "ael.y"
 typedef union YYSTYPE {
-	char *str;
-	struct pval *pval;
+	int	intval;		/* integer value, typically flags */
+	char	*str;		/* strings */
+	struct pval *pval;	/* full objects */
 } YYSTYPE;
 /* Line 196 of yacc.c.  */
-#line 231 "ael.tab.c"
+#line 228 "ael.tab.c"
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -248,20 +245,30 @@
 
 
 /* Copy the second part of user declarations.  */
-#line 58 "ael.y"
+#line 55 "ael.y"
 
 	/* declaring these AFTER the union makes things a lot simpler! */
 void yyerror(YYLTYPE *locp, struct parse_io *parseio, char const *s);
 int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void * yyscanner);
 
+/* create a new object with start-end marker */
+static pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column);
+
 /* create a new object with start-end marker, simplified interface.
  * Must be declared here because YYLTYPE is not known before
  */
 static pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last);
 
+/* another frontend for npval, this time for a string */
+static pval *nword(char *string, YYLTYPE *pos);
 
+/* update end position of an object, return the object */
+static pval *update_last(pval *, YYLTYPE *);
+
+
 /* Line 219 of yacc.c.  */
-#line 265 "ael.tab.c"
+#line 272 "ael.tab.c"
 
 #if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
 # define YYSIZE_T __SIZE_TYPE__
@@ -412,18 +419,18 @@
 #endif
 
 /* YYFINAL -- State number of the termination state. */
-#define YYFINAL  18
+#define YYFINAL  14
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   505
 
 /* YYNTOKENS -- Number of terminals. */
 #define YYNTOKENS  42
 /* YYNNTS -- Number of nonterminals. */
-#define YYNNTS  55
+#define YYNNTS  58
 /* YYNRULES -- Number of rules. */
-#define YYNRULES  149
+#define YYNRULES  150
 /* YYNRULES -- Number of states. */
-#define YYNSTATES  346
+#define YYNSTATES  340
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
 #define YYUNDEFTOK  2
@@ -473,105 +480,105 @@
 static const unsigned short int yyprhs[] =
 {
        0,     0,     3,     5,     7,    10,    13,    15,    17,    19,
-      21,    23,    25,    31,    36,    43,    49,    58,    66,    74,
-      81,    86,    90,    92,    95,    98,    99,   105,   107,   111,
-     114,   116,   118,   121,   124,   126,   128,   130,   132,   134,
-     135,   141,   144,   146,   151,   155,   160,   168,   177,   179,
-     182,   185,   186,   192,   193,   199,   214,   225,   227,   230,
-     232,   235,   239,   241,   244,   248,   249,   256,   260,   261,
-     267,   271,   275,   278,   279,   280,   281,   294,   295,   302,
-     305,   309,   313,   316,   319,   320,   326,   329,   332,   335,
-     339,   343,   347,   349,   352,   353,   355,   359,   363,   369,
-     375,   381,   387,   389,   393,   399,   403,   409,   413,   414,
-     420,   424,   425,   429,   433,   436,   438,   439,   441,   442,
-     446,   448,   451,   456,   460,   465,   469,   472,   476,   478,
-     481,   483,   489,   494,   498,   503,   507,   510,   514,   517,
-     520,   535,   546,   550,   566,   578,   581,   583,   585,   590
+      21,    23,    25,    30,    32,    33,    42,    50,    58,    65,
+      70,    74,    76,    79,    82,    83,    89,    91,    95,    98,
+     101,   105,   107,   109,   112,   115,   117,   119,   121,   123,
+     125,   126,   132,   135,   137,   142,   146,   151,   159,   168,
+     170,   173,   176,   177,   183,   184,   190,   205,   216,   218,
+     221,   223,   226,   230,   232,   235,   239,   240,   247,   251,
+     252,   258,   262,   266,   269,   270,   271,   272,   285,   286,
+     293,   296,   300,   304,   307,   310,   311,   317,   320,   323,
+     326,   330,   334,   338,   340,   343,   344,   346,   350,   354,
+     360,   366,   372,   378,   380,   384,   390,   394,   400,   404,
+     405,   411,   415,   416,   420,   424,   427,   429,   430,   432,
+     433,   437,   439,   442,   447,   451,   456,   460,   463,   467,
+     469,   472,   474,   480,   483,   486,   490,   493,   496,   500,
+     503,   506,   521,   532,   536,   552,   564,   567,   569,   571,
+     576
 };
 
 /* YYRHS -- A `-1'-separated list of the rules' RHS. */
 static const yysigned_char yyrhs[] =
 {
       43,     0,    -1,    44,    -1,    45,    -1,    44,    45,    -1,
-      44,     1,    -1,    47,    -1,    48,    -1,    49,    -1,     8,
-      -1,    41,    -1,    36,    -1,     3,    46,     4,    54,     5,
-      -1,     3,    46,     4,     5,    -1,    23,     3,    46,     4,
-      54,     5,    -1,    23,     3,    46,     4,     5,    -1,    15,
-      41,     6,    53,     7,     4,    89,     5,    -1,    15,    41,
-       6,    53,     7,     4,     5,    -1,    15,    41,     6,     7,
-       4,    89,     5,    -1,    15,    41,     6,     7,     4,     5,
-      -1,    16,     4,    50,     5,    -1,    16,     4,     5,    -1,
-      51,    -1,    50,    51,    -1,    50,     1,    -1,    -1,    41,
-       9,    52,    41,     8,    -1,    41,    -1,    53,    10,    41,
-      -1,    53,     1,    -1,    55,    -1,     1,    -1,    54,    55,
-      -1,    54,     1,    -1,    58,    -1,    96,    -1,    91,    -1,
-      92,    -1,    57,    -1,    -1,    41,     9,    56,    41,     8,
-      -1,    41,     1,    -1,     8,    -1,    17,    24,    41,     8,
-      -1,    41,    24,    70,    -1,    30,    41,    24,    70,    -1,
-      31,     6,    66,     7,    41,    24,    70,    -1,    30,    31,
-       6,    66,     7,    41,    24,    70,    -1,    70,    -1,    59,
-      70,    -1,    59,     1,    -1,    -1,    19,     6,    61,    65,
-       7,    -1,    -1,    22,     6,    63,    65,     7,    -1,    20,
-       6,    66,    11,    66,    11,    66,    13,    66,    13,    66,
-      13,    66,     7,    -1,    20,     6,    41,    13,    66,    13,
-      66,    13,    66,     7,    -1,    41,    -1,    41,    41,    -1,
-      41,    -1,    41,    41,    -1,    41,    41,    41,    -1,    41,
-      -1,    41,    41,    -1,    41,    11,    41,    -1,    -1,    18,
-       6,    69,    41,     7,     4,    -1,     4,    59,     5,    -1,
-      -1,    41,     9,    71,    41,     8,    -1,    25,    78,     8,
-      -1,    26,    79,     8,    -1,    41,    11,    -1,    -1,    -1,
-      -1,    32,     6,    72,    41,     8,    73,    41,     8,    74,
-      41,     7,    70,    -1,    -1,    33,     6,    75,    41,     7,
-      70,    -1,    68,     5,    -1,    68,    87,     5,    -1,    12,
-      80,     8,    -1,    84,     8,    -1,    41,     8,    -1,    -1,
-      84,     9,    76,    41,     8,    -1,    28,     8,    -1,    27,
-       8,    -1,    29,     8,    -1,    62,    70,    77,    -1,    60,
-      70,    77,    -1,    64,    70,    77,    -1,     8,    -1,    21,
-      70,    -1,    -1,    67,    -1,    67,    13,    67,    -1,    67,
-      10,    67,    -1,    67,    13,    67,    13,    67,    -1,    67,
-      10,    67,    10,    67,    -1,    36,    13,    67,    13,    67,
-      -1,    36,    10,    67,    10,    67,    -1,    67,    -1,    67,
-      10,    67,    -1,    67,    10,    41,    14,    41,    -1,    67,
-      14,    67,    -1,    67,    10,    41,    14,    36,    -1,    67,
-      14,    36,    -1,    -1,    41,     6,    81,    86,     7,    -1,
-      41,     6,     7,    -1,    -1,    41,    83,     6,    -1,    82,
-      86,     7,    -1,    82,     7,    -1,    41,    -1,    -1,    65,
-      -1,    -1,    86,    10,    85,    -1,    88,    -1,    87,    88,
-      -1,    34,    41,    11,    59,    -1,    36,    11,    59,    -1,
-      35,    41,    11,    59,    -1,    34,    41,    11,    -1,    36,
-      11,    -1,    35,    41,    11,    -1,    90,    -1,    89,    90,
-      -1,    70,    -1,    37,    41,     4,    59,     5,    -1,    38,
-       4,    93,     5,    -1,    38,     4,     5,    -1,    39,     4,
-      93,     5,    -1,    39,     4,     5,    -1,    41,     8,    -1,
-      93,    41,     8,    -1,    93,     1,    -1,    95,     8,    -1,
-      95,    13,    66,    11,    66,    11,    66,    13,    66,    13,
-      66,    13,    66,     8,    -1,    95,    13,    41,    13,    66,
-      13,    66,    13,    66,     8,    -1,    94,    95,     8,    -1,
-      94,    95,    13,    66,    11,    66,    11,    66,    13,    66,
-      13,    66,    13,    66,     8,    -1,    94,    95,    13,    41,
-      13,    66,    13,    66,    13,    66,     8,    -1,    94,     1,
-      -1,    41,    -1,    36,    -1,    40,     4,    94,     5,    -1,
-      40,     4,     5,    -1
+      44,     1,    -1,    47,    -1,    49,    -1,    50,    -1,     8,
+      -1,    41,    -1,    36,    -1,    48,     3,    46,    55,    -1,
+      23,    -1,    -1,    15,    41,     6,    54,     7,     4,    91,
+       5,    -1,    15,    41,     6,    54,     7,     4,     5,    -1,
+      15,    41,     6,     7,     4,    91,     5,    -1,    15,    41,
+       6,     7,     4,     5,    -1,    16,     4,    51,     5,    -1,
+      16,     4,     5,    -1,    52,    -1,    51,    52,    -1,    51,
+       1,    -1,    -1,    41,     9,    53,    41,     8,    -1,    41,
+      -1,    54,    10,    41,    -1,    54,     1,    -1,     4,     5,
+      -1,     4,    56,     5,    -1,    57,    -1,     1,    -1,    56,
+      57,    -1,    56,     1,    -1,    60,    -1,    99,    -1,    93,
+      -1,    94,    -1,    59,    -1,    -1,    41,     9,    58,    41,
+       8,    -1,    41,     1,    -1,     8,    -1,    17,    24,    41,
+       8,    -1,    41,    24,    72,    -1,    30,    41,    24,    72,
+      -1,    31,     6,    68,     7,    41,    24,    72,    -1,    30,
+      31,     6,    68,     7,    41,    24,    72,    -1,    72,    -1,
+      61,    72,    -1,    61,     1,    -1,    -1,    19,     6,    63,
+      67,     7,    -1,    -1,    22,     6,    65,    67,     7,    -1,
+      20,     6,    68,    11,    68,    11,    68,    13,    68,    13,
+      68,    13,    68,     7,    -1,    20,     6,    41,    13,    68,
+      13,    68,    13,    68,     7,    -1,    41,    -1,    41,    41,
+      -1,    41,    -1,    41,    41,    -1,    41,    41,    41,    -1,
+      41,    -1,    41,    41,    -1,    41,    11,    41,    -1,    -1,
+      18,     6,    71,    41,     7,     4,    -1,     4,    61,     5,
+      -1,    -1,    41,     9,    73,    41,     8,    -1,    25,    80,
+       8,    -1,    26,    81,     8,    -1,    41,    11,    -1,    -1,
+      -1,    -1,    32,     6,    74,    41,     8,    75,    41,     8,
+      76,    41,     7,    72,    -1,    -1,    33,     6,    77,    41,
+       7,    72,    -1,    70,     5,    -1,    70,    89,     5,    -1,
+      12,    82,     8,    -1,    86,     8,    -1,    41,     8,    -1,
+      -1,    86,     9,    78,    41,     8,    -1,    28,     8,    -1,
+      27,     8,    -1,    29,     8,    -1,    64,    72,    79,    -1,
+      62,    72,    79,    -1,    66,    72,    79,    -1,     8,    -1,
+      21,    72,    -1,    -1,    69,    -1,    69,    13,    69,    -1,
+      69,    10,    69,    -1,    69,    13,    69,    13,    69,    -1,
+      69,    10,    69,    10,    69,    -1,    36,    13,    69,    13,
+      69,    -1,    36,    10,    69,    10,    69,    -1,    69,    -1,
+      69,    10,    69,    -1,    69,    10,    41,    14,    41,    -1,
+      69,    14,    69,    -1,    69,    10,    41,    14,    36,    -1,
+      69,    14,    36,    -1,    -1,    41,     6,    83,    88,     7,
+      -1,    41,     6,     7,    -1,    -1,    41,    85,     6,    -1,
+      84,    88,     7,    -1,    84,     7,    -1,    41,    -1,    -1,
+      67,    -1,    -1,    88,    10,    87,    -1,    90,    -1,    89,
+      90,    -1,    34,    41,    11,    61,    -1,    36,    11,    61,
+      -1,    35,    41,    11,    61,    -1,    34,    41,    11,    -1,
+      36,    11,    -1,    35,    41,    11,    -1,    92,    -1,    91,
+      92,    -1,    72,    -1,    37,    41,     4,    61,     5,    -1,
+      38,    95,    -1,    39,    95,    -1,     4,    96,     5,    -1,
+       4,     5,    -1,    41,     8,    -1,    96,    41,     8,    -1,
+      96,     1,    -1,    98,     8,    -1,    98,    13,    68,    11,
+      68,    11,    68,    13,    68,    13,    68,    13,    68,     8,
+      -1,    98,    13,    41,    13,    68,    13,    68,    13,    68,
+       8,    -1,    97,    98,     8,    -1,    97,    98,    13,    68,
+      11,    68,    11,    68,    13,    68,    13,    68,    13,    68,
+       8,    -1,    97,    98,    13,    41,    13,    68,    13,    68,
+      13,    68,     8,    -1,    97,     1,    -1,    41,    -1,    36,
+      -1,    40,     4,    97,     5,    -1,    40,     4,     5,    -1
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const unsigned short int yyrline[] =
 {
-       0,   165,   165,   168,   169,   180,   183,   184,   185,   186,
-     189,   190,   193,   197,   200,   205,   229,   232,   235,   239,
-     244,   247,   251,   252,   253,   256,   256,   262,   265,   269,
-     272,   273,   274,   277,   280,   281,   282,   283,   284,   285,
-     285,   289,   290,   293,   298,   302,   307,   312,   321,   322,
-     325,   328,   328,   333,   333,   338,   354,   374,   375,   382,
-     383,   388,   396,   397,   401,   407,   407,   415,   418,   418,
-     422,   425,   428,   431,   432,   433,   431,   439,   439,   443,
-     447,   452,   456,   460,   463,   463,   496,   497,   498,   499,
-     513,   527,   541,   544,   545,   550,   552,   557,   562,   569,
-     576,   583,   592,   597,   602,   609,   616,   623,   632,   632,
-     637,   642,   642,   652,   658,   661,   662,   665,   668,   671,
-     685,   686,   691,   695,   699,   703,   706,   709,   714,   715,
-     720,   721,   727,   730,   734,   737,   741,   744,   749,   752,
-     755,   772,   785,   790,   808,   823,   826,   827,   830,   833
+       0,   177,   177,   180,   181,   192,   195,   196,   197,   198,
+     201,   202,   205,   213,   214,   217,   220,   223,   227,   232,
+     235,   239,   240,   241,   244,   244,   250,   251,   255,   258,
+     259,   262,   263,   264,   267,   270,   271,   272,   273,   274,
+     275,   275,   279,   280,   283,   288,   292,   297,   302,   311,
+     312,   315,   318,   318,   323,   323,   328,   341,   357,   358,
+     365,   366,   371,   379,   380,   384,   390,   390,   398,   401,
+     401,   405,   408,   411,   414,   415,   416,   414,   422,   422,
+     426,   428,   431,   433,   435,   438,   438,   471,   472,   473,
+     474,   478,   482,   486,   489,   490,   495,   496,   499,   502,
+     506,   510,   514,   521,   524,   527,   534,   541,   548,   557,
+     557,   562,   567,   567,   577,   584,   587,   588,   591,   592,
+     595,   601,   602,   607,   611,   615,   619,   622,   625,   630,
+     631,   636,   637,   643,   648,   653,   654,   657,   660,   665,
+     668,   671,   685,   694,   699,   714,   726,   729,   730,   733,
+     736
 };
 #endif
 
@@ -587,15 +594,16 @@
   "KW_RETURN", "KW_BREAK", "KW_CONTINUE", "KW_REGEXTEN", "KW_HINT",
   "KW_FOR", "KW_WHILE", "KW_CASE", "KW_PATTERN", "KW_DEFAULT", "KW_CATCH",
   "KW_SWITCHES", "KW_ESWITCHES", "KW_INCLUDES", "word", "$accept", "file",
-  "objects", "object", "word_or_default", "context", "macro", "globals",
-  "global_statements", "global_statement", "@1", "arglist", "elements",
-  "element", "@2", "ignorepat", "extension", "statements", "if_head", "@3",
-  "random_head", "@4", "iftime_head", "word_list", "word3_list",
-  "goto_word", "switch_head", "@5", "statement", "@6", "@7", "@8", "@9",
-  "@10", "@11", "opt_else", "target", "jumptarget", "macro_call", "@12",
-  "application_call_head", "@13", "application_call", "opt_word",
-  "eval_arglist", "case_statements", "case_statement", "macro_statements",
-  "macro_statement", "switches", "eswitches", "switchlist", "includeslist",
+  "objects", "object", "word_or_default", "context", "opt_abstract",
+  "macro", "globals", "global_statements", "global_statement", "@1",
+  "arglist", "elements_block", "elements", "element", "@2", "ignorepat",
+  "extension", "statements", "if_head", "@3", "random_head", "@4",
+  "iftime_head", "word_list", "word3_list", "goto_word", "switch_head",
+  "@5", "statement", "@6", "@7", "@8", "@9", "@10", "@11", "opt_else",
+  "target", "jumptarget", "macro_call", "@12", "application_call_head",
+  "@13", "application_call", "opt_word", "eval_arglist", "case_statements",
+  "case_statement", "macro_statements", "macro_statement", "switches",
+  "eswitches", "switchlist_block", "switchlist", "includeslist",
   "includedname", "includes", 0
 };
 #endif
@@ -617,40 +625,42 @@
 static const unsigned char yyr1[] =
 {
        0,    42,    43,    44,    44,    44,    45,    45,    45,    45,
-      46,    46,    47,    47,    47,    47,    48,    48,    48,    48,
-      49,    49,    50,    50,    50,    52,    51,    53,    53,    53,
-      54,    54,    54,    54,    55,    55,    55,    55,    55,    56,
-      55,    55,    55,    57,    58,    58,    58,    58,    59,    59,
-      59,    61,    60,    63,    62,    64,    64,    65,    65,    66,
-      66,    66,    67,    67,    67,    69,    68,    70,    71,    70,
-      70,    70,    70,    72,    73,    74,    70,    75,    70,    70,
-      70,    70,    70,    70,    76,    70,    70,    70,    70,    70,
-      70,    70,    70,    77,    77,    78,    78,    78,    78,    78,
-      78,    78,    79,    79,    79,    79,    79,    79,    81,    80,
-      80,    83,    82,    84,    84,    85,    85,    86,    86,    86,
-      87,    87,    88,    88,    88,    88,    88,    88,    89,    89,
-      90,    90,    91,    91,    92,    92,    93,    93,    93,    94,
-      94,    94,    94,    94,    94,    94,    95,    95,    96,    96
+      46,    46,    47,    48,    48,    49,    49,    49,    49,    50,
+      50,    51,    51,    51,    53,    52,    54,    54,    54,    55,
+      55,    56,    56,    56,    56,    57,    57,    57,    57,    57,
+      58,    57,    57,    57,    59,    60,    60,    60,    60,    61,
+      61,    61,    63,    62,    65,    64,    66,    66,    67,    67,
+      68,    68,    68,    69,    69,    69,    71,    70,    72,    73,
+      72,    72,    72,    72,    74,    75,    76,    72,    77,    72,
+      72,    72,    72,    72,    72,    78,    72,    72,    72,    72,
+      72,    72,    72,    72,    79,    79,    80,    80,    80,    80,
+      80,    80,    80,    81,    81,    81,    81,    81,    81,    83,
+      82,    82,    85,    84,    86,    86,    87,    87,    88,    88,
+      88,    89,    89,    90,    90,    90,    90,    90,    90,    91,
+      91,    92,    92,    93,    94,    95,    95,    96,    96,    96,
+      97,    97,    97,    97,    97,    97,    97,    98,    98,    99,
+      99
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
 static const unsigned char yyr2[] =
 {
        0,     2,     1,     1,     2,     2,     1,     1,     1,     1,
-       1,     1,     5,     4,     6,     5,     8,     7,     7,     6,
-       4,     3,     1,     2,     2,     0,     5,     1,     3,     2,
-       1,     1,     2,     2,     1,     1,     1,     1,     1,     0,
-       5,     2,     1,     4,     3,     4,     7,     8,     1,     2,
-       2,     0,     5,     0,     5,    14,    10,     1,     2,     1,
-       2,     3,     1,     2,     3,     0,     6,     3,     0,     5,
-       3,     3,     2,     0,     0,     0,    12,     0,     6,     2,
-       3,     3,     2,     2,     0,     5,     2,     2,     2,     3,
-       3,     3,     1,     2,     0,     1,     3,     3,     5,     5,
-       5,     5,     1,     3,     5,     3,     5,     3,     0,     5,
-       3,     0,     3,     3,     2,     1,     0,     1,     0,     3,
-       1,     2,     4,     3,     4,     3,     2,     3,     1,     2,
-       1,     5,     4,     3,     4,     3,     2,     3,     2,     2,
-      14,    10,     3,    15,    11,     2,     1,     1,     4,     3
+       1,     1,     4,     1,     0,     8,     7,     7,     6,     4,
+       3,     1,     2,     2,     0,     5,     1,     3,     2,     2,
+       3,     1,     1,     2,     2,     1,     1,     1,     1,     1,
+       0,     5,     2,     1,     4,     3,     4,     7,     8,     1,
+       2,     2,     0,     5,     0,     5,    14,    10,     1,     2,
+       1,     2,     3,     1,     2,     3,     0,     6,     3,     0,
+       5,     3,     3,     2,     0,     0,     0,    12,     0,     6,
+       2,     3,     3,     2,     2,     0,     5,     2,     2,     2,
+       3,     3,     3,     1,     2,     0,     1,     3,     3,     5,
+       5,     5,     5,     1,     3,     5,     3,     5,     3,     0,
+       5,     3,     0,     3,     3,     2,     1,     0,     1,     0,
+       3,     1,     2,     4,     3,     4,     3,     2,     3,     1,
+       2,     1,     5,     2,     2,     3,     2,     2,     3,     2,
+       2,    14,    10,     3,    15,    11,     2,     1,     1,     4,
+       3
 };
 
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
@@ -658,261 +668,258 @@
    means the default is an error.  */
 static const unsigned char yydefact[] =
 {
-       0,     0,     9,     0,     0,     0,     0,     0,     3,     6,
-       7,     8,    11,    10,     0,     0,     0,     0,     1,     5,
-       4,     0,     0,    21,     0,     0,    22,     0,    31,    13,
-      42,     0,     0,     0,     0,     0,     0,     0,     0,    30,
-      38,    34,    36,    37,    35,     0,    27,     0,    25,    24,
-      20,    23,     0,     0,     0,     0,     0,     0,     0,     0,
-      41,    39,     0,    33,    12,    32,     0,    29,     0,     0,
-       0,    15,     0,     0,     0,     0,    59,     0,   133,     0,
-       0,   135,     0,   149,   147,   146,     0,     0,     0,     0,
-      92,     0,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,   111,     0,     0,     0,     0,    44,   118,
-       0,    19,     0,   130,     0,   128,     0,    28,     0,    14,
-      43,     0,    45,    60,     0,   136,   138,   132,     0,   134,
-     145,   148,     0,   139,     0,     0,     0,    48,     0,     0,
-      65,    51,     0,    53,     0,    62,    95,     0,   102,     0,
-      87,    86,    88,    73,    77,    83,    68,    72,     0,    94,
-      94,    94,    79,     0,     0,     0,     0,   120,   114,    57,
-     117,     0,    82,    84,     0,    18,   129,    17,     0,    26,
-       0,    61,     0,   137,   142,     0,    59,     0,    40,    50,
-      67,    49,   108,    81,     0,     0,    59,     0,     0,     0,
-       0,     0,    63,     0,     0,    70,     0,     0,    71,     0,
-       0,     0,   112,     0,    90,    89,    91,     0,     0,   126,
-      80,   121,    58,   113,   116,     0,     0,    16,     0,     0,
-      59,     0,     0,     0,   110,   118,     0,     0,     0,     0,
-       0,     0,     0,    64,    97,    96,    62,   103,   107,   105,
-       0,     0,     0,    93,   125,   127,     0,   115,   119,     0,
-       0,     0,    46,     0,     0,     0,     0,     0,     0,    52,
-       0,     0,    54,     0,     0,     0,     0,     0,    74,     0,
-      69,     0,     0,    85,   131,    47,     0,     0,     0,     0,
-     109,    66,     0,     0,   101,   100,    99,    98,   106,   104,
-       0,    78,     0,     0,     0,     0,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,    75,     0,     0,     0,     0,
-       0,     0,     0,     0,     0,   141,     0,    56,     0,     0,
-     144,     0,     0,     0,     0,     0,     0,     0,    76,     0,
-       0,     0,     0,   140,    55,   143
+      14,     9,     0,     0,    13,     0,     0,     3,     6,     0,
+       7,     8,     0,     0,     1,     5,     4,     0,     0,    20,
+       0,     0,    21,    11,    10,     0,     0,    26,     0,    24,
+      23,    19,    22,     0,    12,     0,    28,     0,     0,     0,
+      32,    29,    43,     0,     0,     0,     0,     0,     0,     0,
+       0,    31,    39,    35,    37,    38,    36,     0,    18,    93,
+       0,     0,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,   112,     0,     0,     0,     0,   131,   119,
+       0,     0,   129,     0,    27,     0,     0,     0,     0,     0,
+       0,   133,   134,     0,    42,    40,     0,    34,    30,    33,
+       0,    49,     0,     0,    66,    52,     0,    54,     0,    63,
+      96,     0,   103,     0,    88,    87,    89,    74,    78,     0,
+      84,    69,    73,     0,    95,    95,    95,    80,     0,     0,
+       0,     0,   121,   115,    58,   118,     0,    83,    85,    17,
+     130,    16,     0,    25,     0,     0,     0,    60,     0,   136,
+       0,     0,   150,   148,   147,     0,     0,     0,    45,    51,
+      68,    50,   109,    82,     0,     0,    60,     0,     0,     0,
+       0,     0,    64,     0,     0,    71,     0,     0,    72,     0,
+       0,     0,     0,   113,     0,    91,    90,    92,     0,     0,
+     127,    81,   122,    59,   114,   117,     0,    15,    44,     0,
+      46,    61,     0,   137,   139,   135,     0,   146,   149,     0,
+     140,     0,     0,   111,   119,     0,     0,     0,     0,     0,
+       0,     0,    65,    98,    97,    63,   104,   108,   106,     0,
+       0,     0,     0,    94,   126,   128,     0,   116,   120,     0,
+       0,    62,     0,   138,   143,     0,    60,     0,    41,     0,
+       0,    53,     0,     0,    55,     0,     0,     0,     0,     0,
+      75,     0,   132,    70,     0,     0,    86,     0,     0,    60,
+       0,     0,     0,   110,    67,     0,     0,   102,   101,   100,
+      99,   107,   105,     0,    79,     0,    47,     0,     0,     0,
+       0,     0,     0,     0,    48,     0,     0,     0,     0,     0,
+       0,    76,     0,     0,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,    57,     0,     0,     0,     0,     0,     0,
+       0,     0,     0,     0,   142,     0,     0,    77,   145,     0,
+       0,     0,     0,     0,    56,     0,     0,     0,   141,   144
 };
 
 /* YYDEFGOTO[NTERM-NUM]. */
 static const short int yydefgoto[] =
 {
-      -1,     6,     7,     8,    14,     9,    10,    11,    25,    26,
-      70,    47,    38,    39,    88,    40,    41,   136,   104,   195,
-     105,   198,   106,   170,    77,   146,   107,   194,   137,   211,
-     209,   300,   322,   210,   225,   214,   147,   149,   139,   235,
-     109,   158,   110,   258,   171,   166,   167,   114,   115,    42,
-      43,    80,    86,    87,    44
+      -1,     5,     6,     7,    25,     8,     9,    10,    11,    21,
+      22,    39,    28,    34,    50,    51,   157,    52,    53,   100,
+      74,   165,    75,   168,    76,   135,   148,   110,    77,   164,
+     101,   182,   179,   283,   308,   180,   196,   185,   111,   113,
+     103,   214,    79,   123,    80,   238,   136,   131,   132,    81,
+      82,    54,    55,    91,   151,   155,   156,    56
 };
 
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
-#define YYPACT_NINF -193
+#define YYPACT_NINF -180
 static const short int yypact[] =
 {
-     121,   117,  -193,   -38,    84,    17,    95,   343,  -193,  -193,
-    -193,  -193,  -193,  -193,    98,   122,     9,   117,  -193,  -193,
-    -193,   151,    53,  -193,   110,    14,  -193,   167,  -193,  -193,
-    -193,   102,    39,   182,   200,   214,   218,   184,   204,  -193,
-    -193,  -193,  -193,  -193,  -193,   219,  -193,   196,  -193,  -193,
-    -193,  -193,   280,   183,   221,   207,   187,    23,    44,    20,
-    -193,  -193,   461,  -193,  -193,  -193,   357,  -193,   228,   192,
-     195,  -193,   333,   229,   187,   461,   197,   234,  -193,   238,
-      16,  -193,    46,  -193,  -193,  -193,     5,   147,   206,   461,
-    -193,   211,   249,   250,   251,   252,   125,   220,   254,   256,
-     258,   253,   261,   104,   461,   461,   461,   129,  -193,    60,
-      50,  -193,   230,  -193,   383,  -193,   409,  -193,   262,  -193,
-    -193,   270,  -193,   239,   242,  -193,  -193,  -193,   276,  -193,
-    -193,  -193,   149,  -193,   246,   281,   274,  -193,   263,   282,
-    -193,  -193,   257,  -193,   173,     7,   201,   283,    63,   287,
-    -193,  -193,  -193,  -193,  -193,  -193,  -193,  -193,   298,   292,
-     292,   292,  -193,   273,   284,   306,   138,  -193,  -193,   286,
-    -193,   120,  -193,  -193,   324,  -193,  -193,  -193,   435,  -193,
-     294,  -193,   236,  -193,  -193,   299,    -6,   328,  -193,  -193,
-    -193,  -193,   335,  -193,   307,   308,    40,   336,   308,   220,
-     220,   311,  -193,   220,   220,  -193,   312,   166,  -193,   313,
-     314,   315,  -193,   461,  -193,  -193,  -193,   346,   349,   461,
-    -193,  -193,  -193,  -193,   326,   327,   461,  -193,   354,   461,
-      65,   359,   187,   187,  -193,   308,   373,   374,   187,   187,
-     385,   386,   380,  -193,   387,   391,   109,  -193,  -193,  -193,
-     392,   399,   410,  -193,   461,   461,     4,  -193,  -193,   411,
-     304,   461,  -193,   187,   187,   394,   388,   177,   418,  -193,
-     412,   415,  -193,   220,   220,   220,   220,   174,  -193,   461,
-    -193,    64,   113,  -193,  -193,  -193,   417,   421,   187,   187,
-    -193,  -193,   187,   187,  -193,  -193,  -193,  -193,  -193,  -193,
-     382,  -193,   187,   187,   420,   431,   432,   436,   440,   438,
-     439,   187,   187,   187,   187,  -193,   187,   187,   448,   445,
-     452,   453,   429,   463,   462,  -193,   187,  -193,   187,   467,
-    -193,   187,   464,   465,   461,   469,   187,   187,  -193,   187,
-     476,   478,   483,  -193,  -193,  -193
+     132,  -180,   -31,    19,  -180,    16,   105,  -180,  -180,    30,
+    -180,  -180,    29,     8,  -180,  -180,  -180,   -10,    11,  -180,
+      67,     3,  -180,  -180,  -180,    66,    68,  -180,    20,  -180,
+    -180,  -180,  -180,   283,  -180,   360,  -180,    78,    71,    75,
+    -180,  -180,  -180,    94,   -16,   131,   141,   141,   146,    95,
+     336,  -180,  -180,  -180,  -180,  -180,  -180,   464,  -180,  -180,
+     116,   152,   158,   159,   173,    -7,   143,   177,   178,   179,
+     182,   183,   149,   163,   464,   464,   464,    23,  -180,    12,
+      81,   386,  -180,   412,  -180,   184,   150,   189,   174,   156,
+       9,  -180,  -180,     1,  -180,  -180,   464,  -180,  -180,  -180,
+     277,  -180,   193,   192,  -180,  -180,   161,  -180,    56,    13,
+      70,   199,    22,   202,  -180,  -180,  -180,  -180,  -180,   211,
+    -180,  -180,  -180,   210,   198,   198,   198,  -180,   180,   186,
+     213,    63,  -180,  -180,   187,  -180,   124,  -180,  -180,  -180,
+    -180,  -180,   438,  -180,   217,   156,   464,   195,   227,  -180,
+     229,     4,  -180,  -180,  -180,     2,   101,   197,  -180,  -180,
+    -180,  -180,   235,  -180,   204,   205,    60,   237,   205,   143,
+     143,   208,  -180,   143,   143,  -180,   212,    74,  -180,   214,
+     215,   464,   219,  -180,   464,  -180,  -180,  -180,   241,   243,
+     464,  -180,  -180,  -180,  -180,   221,   222,  -180,  -180,   262,
+    -180,   236,   238,  -180,  -180,  -180,   268,  -180,  -180,   114,
+    -180,   242,   279,  -180,   205,   263,   285,   156,   156,   286,
+     280,   281,  -180,   288,   294,     6,  -180,  -180,  -180,   293,
+     309,   307,   312,  -180,   464,   464,    59,  -180,  -180,   320,
+     276,  -180,   306,  -180,  -180,   290,    61,   327,  -180,   166,
+     338,  -180,   330,   334,  -180,   143,   143,   143,   143,   100,
+    -180,   464,  -180,  -180,   134,   239,  -180,   322,   464,    62,
+     339,   156,   156,  -180,  -180,   156,   156,  -180,  -180,  -180,
+    -180,  -180,  -180,   308,  -180,   464,  -180,   156,   156,   341,
+     340,   342,   343,   344,  -180,   345,   346,   156,   156,   156,
+     156,  -180,   156,   156,   347,   348,   352,   349,   328,   350,
+     357,   156,   156,  -180,   156,   364,   156,   156,   365,   368,
+     370,   464,   376,   382,  -180,   156,   156,  -180,  -180,   156,
+     383,   392,   387,   156,  -180,   156,   394,   395,  -180,  -180
 };
 
 /* YYPGOTO[NTERM-NUM].  */
 static const short int yypgoto[] =
 {
-    -193,  -193,  -193,   485,   479,  -193,  -193,  -193,  -193,   470,
-    -193,  -193,   446,    37,  -193,  -193,  -193,  -192,  -193,  -193,
-    -193,  -193,  -193,    18,   -63,   -96,  -193,  -193,   -62,  -193,
-    -193,  -193,  -193,  -193,  -193,    35,  -193,  -193,  -193,  -193,
-    -193,  -193,  -193,  -193,   264,  -193,   331,   384,  -112,  -193,
-    -193,   443,  -193,   419,  -193
+    -180,  -180,  -180,   401,  -180,  -180,  -180,  -180,  -180,  -180,
+     326,  -180,  -180,  -180,  -180,   359,  -180,  -180,  -180,  -179,
+    -180,  -180,  -180,  -180,  -180,    15,   -94,   -44,  -180,  -180,
+     -35,  -180,  -180,  -180,  -180,  -180,  -180,    18,  -180,  -180,
+    -180,  -180,  -180,  -180,  -180,  -180,   196,  -180,   291,   353,
+     -80,  -180,  -180,   374,  -180,  -180,   270,  -180
 };
 
 /* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
    positive, shift that token.  If negative, reduce the rule which
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -125
+#define YYTABLE_NINF -126
 static const short int yytable[] =
 {
-     108,   148,   176,    15,   113,   189,   130,   232,    89,  -123,
-     131,   121,    90,   122,    23,    49,    91,   126,   201,    50,
-      17,   127,    92,    93,    94,    83,    95,   256,    78,    96,
-      97,    98,    99,   100,   260,   123,   101,   102,  -123,  -123,
-    -123,    84,   159,   160,   161,   103,    85,   126,   202,    81,
-      24,   129,   113,   238,   113,    24,    84,   128,   172,   173,
-      45,    85,   281,   282,    79,   189,   176,   168,    89,  -122,
-      54,   187,    90,   206,   191,    65,    91,   207,   263,   197,
-      55,   123,    92,    93,    94,    79,    95,   128,    16,    96,
-      97,    98,    99,   100,    46,    18,   101,   102,  -122,  -122,
-    -122,   169,    21,   241,   242,   103,   123,   244,   245,    65,
-     247,   249,   155,   156,   189,   157,   113,    89,  -124,    48,
-     201,    90,   231,   277,     1,    91,    53,   223,    22,     2,
-     224,    92,    93,    94,   162,    95,     3,     4,    96,    97,
-      98,    99,   100,   220,     5,   101,   102,  -124,  -124,  -124,
-     202,   253,    28,    12,   103,   133,    29,   184,    13,    30,
-     134,   144,   185,   163,   164,   165,   145,   262,    31,   265,
-     266,    52,   163,   164,   165,   270,   271,   294,   295,   296,
-     297,    32,    33,   199,   290,    60,   200,   224,    56,    34,
-      35,    36,    37,    61,   191,   215,   216,    67,   191,   285,
-     286,   287,   248,    68,    57,    63,    69,   145,    62,    64,
-     298,   203,    30,   237,   204,   299,   240,   301,    58,   191,
-     191,    31,    59,    66,    73,   304,   305,    74,    76,   306,
-     307,    75,   116,   117,    32,    33,   118,   120,   123,   309,
-     310,   124,    34,    35,    36,    37,   125,   135,   318,   319,
-     320,   321,   138,   323,   324,   140,   141,   142,   143,   153,
-     229,   145,   150,   332,   151,   333,   152,   154,   335,   192,
-     179,   174,   338,   340,   341,   189,   342,   180,    89,   190,
-     181,    28,    90,   182,   183,    71,    91,   186,    30,   188,
-     193,   205,    92,    93,    94,   208,    95,    31,   196,    96,
-      97,    98,    99,   100,   212,   189,   101,   102,    89,   284,
-      32,    33,    90,   213,   217,   103,    91,   219,    34,    35,
-      36,    37,    92,    93,    94,   218,    95,   222,   226,    96,
-      97,    98,    99,   100,    63,   228,   101,   102,   119,   233,
-     230,    30,   234,    -2,    19,   103,     1,   239,   236,   169,
-      31,     2,   243,   246,   250,   251,   252,   254,     3,     4,
-     255,    89,   111,    32,    33,    90,     5,   257,   259,    91,
-     264,    34,    35,    36,    37,    92,    93,    94,   261,    95,
-     268,   269,    96,    97,    98,    99,   100,    89,   175,   101,
-     102,    90,   272,   274,   112,    91,   273,   275,   103,   289,
-     278,    92,    93,    94,   276,    95,   279,   288,    96,    97,
-      98,    99,   100,    89,   177,   101,   102,    90,   280,   283,
-     112,    91,   291,   308,   103,   292,   293,    92,    93,    94,
-     302,    95,   303,   311,    96,    97,    98,    99,   100,    89,
-     227,   101,   102,    90,   312,   313,   112,    91,   315,   314,
-     103,   316,   317,    92,    93,    94,   325,    95,   326,   327,
-      96,    97,    98,    99,   100,    89,   328,   101,   102,    90,
-     329,   330,   112,    91,   334,   331,   103,   336,   337,    92,
-      93,    94,   339,    95,   343,   344,    96,    97,    98,    99,
-     100,   345,    20,   101,   102,    51,    27,   221,    72,   267,
-     178,    82,   103,     0,     0,   132
+      78,   140,   231,   207,    30,   204,   152,   208,    31,   205,
+      12,   236,   167,    19,   149,    87,    14,   171,    26,   133,
+     259,    36,   112,    13,   171,    88,    23,    37,   127,   108,
+      38,    24,   176,    17,   109,    18,   177,   153,   153,   124,
+     125,   126,   154,   154,    20,   206,    78,   172,    78,    20,
+     150,   199,    27,   134,   172,   264,   265,   128,   129,   130,
+     159,   158,   140,    57,  -124,   161,   169,    59,   191,   170,
+      33,    60,    35,   217,   271,   287,    29,    61,    62,    63,
+     173,    64,    83,   174,    65,    66,    67,    68,    69,   137,
+     138,    70,    71,  -124,  -124,  -124,    94,   128,   129,   130,
+      73,   201,   201,   201,    95,    -2,    15,    78,   -14,   210,
+     227,   200,    84,     1,   211,   109,    85,   247,    86,    96,
+       2,     3,   244,   252,   253,   220,   221,   245,     4,   223,
+     224,   194,   226,   228,   195,   159,   281,    89,    57,  -123,
+       1,   282,    59,   186,   187,    90,    60,     2,     3,   233,
+      93,   270,    61,    62,    63,     4,    64,   102,   104,    65,
+      66,    67,    68,    69,   105,   106,    70,    71,  -123,  -123,
+    -123,   120,   121,   273,   122,    73,   195,   289,   290,   107,
+     216,   291,   292,   219,   109,   114,   115,   116,   117,   118,
+     119,   144,   143,   295,   296,   145,   161,   147,   146,   162,
+     163,   161,   166,   304,   305,   306,   307,   175,   309,   310,
+     178,   277,   278,   279,   280,   181,   183,   318,   319,   184,
+     320,   188,   322,   323,   190,   198,   284,   189,   193,   161,
+     161,   330,   331,   286,   202,   332,   201,   203,   212,   336,
+     159,   337,   213,    57,  -125,   215,   134,    59,   218,   222,
+     294,    60,   234,   225,   235,   229,   230,    61,    62,    63,
+     232,    64,   237,   239,    65,    66,    67,    68,    69,   240,
+     250,    70,    71,  -125,  -125,  -125,   243,   241,   159,   242,
+      73,    57,   160,   246,    40,    59,   327,   248,    41,    60,
+     255,    42,   251,   254,   256,    61,    62,    63,   257,    64,
+      43,   260,    65,    66,    67,    68,    69,   258,   159,    70,
+      71,    57,   262,    44,    45,    59,   261,   267,    73,    60,
+     263,    46,    47,    48,    49,    61,    62,    63,   266,    64,
+     268,   269,    65,    66,    67,    68,    69,    97,   272,    70,
+      71,    98,   274,   275,    42,   276,   285,    32,    73,   293,
+     288,   298,   301,    43,   297,   299,   300,   303,   302,   313,
+     311,   312,   314,   316,    57,    58,    44,    45,    59,   315,
+     317,   321,    60,   324,    46,    47,    48,    49,    61,    62,
+      63,   325,    64,   326,   328,    65,    66,    67,    68,    69,
+      57,   139,    70,    71,    59,   329,   333,    72,    60,   334,
+     335,    73,   338,   339,    61,    62,    63,    16,    64,    99,
+     249,    65,    66,    67,    68,    69,    57,   141,    70,    71,
+      59,    92,   192,    72,    60,   209,     0,    73,     0,     0,
+      61,    62,    63,     0,    64,     0,   142,    65,    66,    67,
+      68,    69,    57,   197,    70,    71,    59,     0,     0,    72,
+      60,     0,     0,    73,     0,     0,    61,    62,    63,     0,
+      64,     0,     0,    65,    66,    67,    68,    69,    57,     0,
+      70,    71,    59,     0,     0,    72,    60,     0,     0,    73,
+       0,     0,    61,    62,    63,     0,    64,     0,     0,    65,
+      66,    67,    68,    69,     0,     0,    70,    71,     0,     0,
+       0,     0,     0,     0,     0,    73
 };
 
 static const short int yycheck[] =
 {
-      62,    97,   114,    41,    66,     1,     1,    13,     4,     5,
-       5,    74,     8,    75,     5,     1,    12,     1,    11,     5,
-       3,     5,    18,    19,    20,     5,    22,   219,     5,    25,
-      26,    27,    28,    29,   226,    41,    32,    33,    34,    35,
-      36,    36,   104,   105,   106,    41,    41,     1,    41,     5,
-      41,     5,   114,    13,   116,    41,    36,    41,     8,     9,
-       7,    41,   254,   255,    41,     1,   178,     7,     4,     5,
-      31,   134,     8,    10,   136,    38,    12,    14,    13,   142,
-      41,    41,    18,    19,    20,    41,    22,    41,     4,    25,
-      26,    27,    28,    29,    41,     0,    32,    33,    34,    35,
-      36,    41,     4,   199,   200,    41,    41,   203,   204,    72,
-     206,   207,     8,     9,     1,    11,   178,     4,     5,     9,
-      11,     8,   185,    14,     3,    12,    24,     7,     6,     8,
-      10,    18,    19,    20,     5,    22,    15,    16,    25,    26,
-      27,    28,    29,     5,    23,    32,    33,    34,    35,    36,
-      41,   213,     1,    36,    41,     8,     5,     8,    41,     8,
-      13,    36,    13,    34,    35,    36,    41,   229,    17,   232,
-     233,     4,    34,    35,    36,   238,   239,   273,   274,   275,
-     276,    30,    31,    10,     7,     1,    13,    10,     6,    38,
-      39,    40,    41,     9,   256,   160,   161,     1,   260,   261,
-     263,   264,    36,     7,     4,     1,    10,    41,    24,     5,
-      36,    10,     8,   195,    13,    41,   198,   279,     4,   281,
-     282,    17,     4,     4,    41,   288,   289,     6,    41,   292,
-     293,    24,     4,    41,    30,    31,    41,     8,    41,   302,
-     303,     7,    38,    39,    40,    41,     8,    41,   311,   312,
-     313,   314,    41,   316,   317,     6,     6,     6,     6,     6,
-      24,    41,     8,   326,     8,   328,     8,     6,   331,     6,
-       8,    41,   334,   336,   337,     1,   339,     7,     4,     5,
-      41,     1,     8,    41,     8,     5,    12,    41,     8,     8,
-       8,     8,    18,    19,    20,     8,    22,    17,    41,    25,
-      26,    27,    28,    29,     6,     1,    32,    33,     4,     5,
-      30,    31,     8,    21,    41,    41,    12,    11,    38,    39,
-      40,    41,    18,    19,    20,    41,    22,    41,     4,    25,
-      26,    27,    28,    29,     1,    41,    32,    33,     5,    11,
-      41,     8,     7,     0,     1,    41,     3,    11,    41,    41,
-      17,     8,    41,    41,    41,    41,    41,    11,    15,    16,
-      11,     4,     5,    30,    31,     8,    23,    41,    41,    12,
-      11,    38,    39,    40,    41,    18,    19,    20,    24,    22,
-       7,     7,    25,    26,    27,    28,    29,     4,     5,    32,
-      33,     8,     7,    13,    37,    12,    10,    10,    41,    11,
-       8,    18,    19,    20,    13,    22,     7,    13,    25,    26,
-      27,    28,    29,     4,     5,    32,    33,     8,     8,     8,
-      37,    12,     4,    41,    41,    13,    11,    18,    19,    20,
-      13,    22,    11,    13,    25,    26,    27,    28,    29,     4,
-       5,    32,    33,     8,    13,    13,    37,    12,     8,    13,
-      41,    13,    13,    18,    19,    20,     8,    22,    13,     7,
-      25,    26,    27,    28,    29,     4,    13,    32,    33,     8,
-      41,     8,    37,    12,     7,    13,    41,    13,    13,    18,
-      19,    20,    13,    22,     8,     7,    25,    26,    27,    28,
-      29,     8,     7,    32,    33,    25,    17,   166,    52,   235,
-     116,    58,    41,    -1,    -1,    86
+      35,    81,   181,     1,     1,     1,     5,     5,     5,     5,
+      41,   190,   106,     5,     5,    31,     0,    11,     7,     7,
+      14,     1,    66,     4,    11,    41,    36,     7,     5,    36,
+      10,    41,    10,     3,    41,     6,    14,    36,    36,    74,
+      75,    76,    41,    41,    41,    41,    81,    41,    83,    41,
+      41,   145,    41,    41,    41,   234,   235,    34,    35,    36,
+       1,    96,   142,     4,     5,   100,    10,     8,     5,    13,
+       4,    12,     4,    13,    13,    13,     9,    18,    19,    20,
+      10,    22,     4,    13,    25,    26,    27,    28,    29,     8,
+       9,    32,    33,    34,    35,    36,     1,    34,    35,    36,
+      41,    41,    41,    41,     9,     0,     1,   142,     3,     8,
+      36,   146,    41,     8,    13,    41,    41,   211,    24,    24,
+      15,    16,     8,   217,   218,   169,   170,    13,    23,   173,
+     174,     7,   176,   177,    10,     1,    36,     6,     4,     5,
+       8,    41,     8,   125,   126,     4,    12,    15,    16,   184,
+       4,   245,    18,    19,    20,    23,    22,    41,     6,    25,
+      26,    27,    28,    29,     6,     6,    32,    33,    34,    35,
+      36,     8,     9,     7,    11,    41,    10,   271,   272,     6,
+     165,   275,   276,   168,    41,     8,     8,     8,     6,     6,
+      41,    41,     8,   287,   288,     6,   231,    41,    24,     6,
+       8,   236,    41,   297,   298,   299,   300,     8,   302,   303,
+       8,   255,   256,   257,   258,     4,     6,   311,   312,    21,
+     314,    41,   316,   317,    11,     8,   261,    41,    41,   264,
+     265,   325,   326,   268,     7,   329,    41,     8,    41,   333,
+       1,   335,     7,     4,     5,    41,    41,     8,    11,    41,
+     285,    12,    11,    41,    11,    41,    41,    18,    19,    20,
+      41,    22,    41,    41,    25,    26,    27,    28,    29,     7,
+       7,    32,    33,    34,    35,    36,     8,    41,     1,    41,
+      41,     4,     5,    41,     1,     8,   321,     8,     5,    12,
+      10,     8,     7,     7,    13,    18,    19,    20,    10,    22,
+      17,     8,    25,    26,    27,    28,    29,    13,     1,    32,
+      33,     4,     5,    30,    31,     8,     7,    41,    41,    12,
+       8,    38,    39,    40,    41,    18,    19,    20,     8,    22,
+      24,    41,    25,    26,    27,    28,    29,     1,    11,    32,
+      33,     5,     4,    13,     8,    11,    24,    21,    41,    41,
+      11,    11,     8,    17,    13,    13,    13,    11,    13,     7,
+      13,    13,    13,    13,     4,     5,    30,    31,     8,    41,
+      13,     7,    12,     8,    38,    39,    40,    41,    18,    19,
+      20,    13,    22,    13,     8,    25,    26,    27,    28,    29,
+       4,     5,    32,    33,     8,    13,    13,    37,    12,     7,
+      13,    41,     8,     8,    18,    19,    20,     6,    22,    50,
+     214,    25,    26,    27,    28,    29,     4,     5,    32,    33,
+       8,    47,   131,    37,    12,   155,    -1,    41,    -1,    -1,
+      18,    19,    20,    -1,    22,    -1,    83,    25,    26,    27,
+      28,    29,     4,     5,    32,    33,     8,    -1,    -1,    37,
+      12,    -1,    -1,    41,    -1,    -1,    18,    19,    20,    -1,
+      22,    -1,    -1,    25,    26,    27,    28,    29,     4,    -1,
+      32,    33,     8,    -1,    -1,    37,    12,    -1,    -1,    41,
+      -1,    -1,    18,    19,    20,    -1,    22,    -1,    -1,    25,
+      26,    27,    28,    29,    -1,    -1,    32,    33,    -1,    -1,
+      -1,    -1,    -1,    -1,    -1,    41
 };
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
 static const unsigned char yystos[] =
 {
-       0,     3,     8,    15,    16,    23,    43,    44,    45,    47,
-      48,    49,    36,    41,    46,    41,     4,     3,     0,     1,
-      45,     4,     6,     5,    41,    50,    51,    46,     1,     5,
-       8,    17,    30,    31,    38,    39,    40,    41,    54,    55,
-      57,    58,    91,    92,    96,     7,    41,    53,     9,     1,
-       5,    51,     4,    24,    31,    41,     6,     4,     4,     4,
-       1,     9,    24,     1,     5,    55,     4,     1,     7,    10,
-      52,     5,    54,    41,     6,    24,    41,    66,     5,    41,
-      93,     5,    93,     5,    36,    41,    94,    95,    56,     4,
-       8,    12,    18,    19,    20,    22,    25,    26,    27,    28,
-      29,    32,    33,    41,    60,    62,    64,    68,    70,    82,
-      84,     5,    37,    70,    89,    90,     4,    41,    41,     5,
-       8,    66,    70,    41,     7,     8,     1,     5,    41,     5,
-       1,     5,    95,     8,    13,    41,    59,    70,    41,    80,
-       6,     6,     6,     6,    36,    41,    67,    78,    67,    79,
-       8,     8,     8,     6,     6,     8,     9,    11,    83,    70,
-      70,    70,     5,    34,    35,    36,    87,    88,     7,    41,
-      65,    86,     8,     9,    41,     5,    90,     5,    89,     8,
-       7,    41,    41,     8,     8,    13,    41,    66,     8,     1,
-       5,    70,     6,     8,    69,    61,    41,    66,    63,    10,
-      13,    11,    41,    10,    13,     8,    10,    14,     8,    72,
-      75,    71,     6,    21,    77,    77,    77,    41,    41,    11,
-       5,    88,    41,     7,    10,    76,     4,     5,    41,    24,
-      41,    66,    13,    11,     7,    81,    41,    65,    13,    11,
-      65,    67,    67,    41,    67,    67,    41,    67,    36,    67,
-      41,    41,    41,    70,    11,    11,    59,    41,    85,    41,
-      59,    24,    70,    13,    11,    66,    66,    86,     7,     7,
-      66,    66,     7,    10,    13,    10,    13,    14,     8,     7,
-       8,    59,    59,     8,     5,    70,    66,    66,    13,    11,
-       7,     4,    13,    11,    67,    67,    67,    67,    36,    41,
-      73,    70,    13,    11,    66,    66,    66,    66,    41,    66,
-      66,    13,    13,    13,    13,     8,    13,    13,    66,    66,
-      66,    66,    74,    66,    66,     8,    13,     7,    13,    41,
-       8,    13,    66,    66,     7,    66,    13,    13,    70,    13,
-      66,    66,    66,     8,     7,     8
+       0,     8,    15,    16,    23,    43,    44,    45,    47,    48,
+      49,    50,    41,     4,     0,     1,    45,     3,     6,     5,
+      41,    51,    52,    36,    41,    46,     7,    41,    54,     9,
+       1,     5,    52,     4,    55,     4,     1,     7,    10,    53,
+       1,     5,     8,    17,    30,    31,    38,    39,    40,    41,
+      56,    57,    59,    60,    93,    94,    99,     4,     5,     8,
+      12,    18,    19,    20,    22,    25,    26,    27,    28,    29,
+      32,    33,    37,    41,    62,    64,    66,    70,    72,    84,
+      86,    91,    92,     4,    41,    41,    24,    31,    41,     6,
+       4,    95,    95,     4,     1,     9,    24,     1,     5,    57,
+      61,    72,    41,    82,     6,     6,     6,     6,    36,    41,
+      69,    80,    69,    81,     8,     8,     8,     6,     6,    41,
+       8,     9,    11,    85,    72,    72,    72,     5,    34,    35,
+      36,    89,    90,     7,    41,    67,    88,     8,     9,     5,
+      92,     5,    91,     8,    41,     6,    24,    41,    68,     5,
+      41,    96,     5,    36,    41,    97,    98,    58,    72,     1,
+       5,    72,     6,     8,    71,    63,    41,    68,    65,    10,
+      13,    11,    41,    10,    13,     8,    10,    14,     8,    74,
+      77,     4,    73,     6,    21,    79,    79,    79,    41,    41,
+      11,     5,    90,    41,     7,    10,    78,     5,     8,    68,
+      72,    41,     7,     8,     1,     5,    41,     1,     5,    98,
+       8,    13,    41,     7,    83,    41,    67,    13,    11,    67,
+      69,    69,    41,    69,    69,    41,    69,    36,    69,    41,
+      41,    61,    41,    72,    11,    11,    61,    41,    87,    41,
+       7,    41,    41,     8,     8,    13,    41,    68,     8,    88,
+       7,     7,    68,    68,     7,    10,    13,    10,    13,    14,
+       8,     7,     5,     8,    61,    61,     8,    41,    24,    41,
+      68,    13,    11,     7,     4,    13,    11,    69,    69,    69,
+      69,    36,    41,    75,    72,    24,    72,    13,    11,    68,
+      68,    68,    68,    41,    72,    68,    68,    13,    11,    13,
+      13,     8,    13,    11,    68,    68,    68,    68,    76,    68,
+      68,    13,    13,     7,    13,    41,    13,    13,    68,    68,
+      68,     7,    68,    68,     8,    13,    13,    72,     8,    13,
+      68,    68,    68,    13,     7,    13,    68,    68,     8,     8
 };
 
 #define yyerrok		(yyerrstatus = 0)
@@ -1288,311 +1295,327 @@
   switch (yytype)
     {
       case 41: /* "word" */
-#line 160 "ael.y"
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1294 "ael.tab.c"
+#line 1301 "ael.tab.c"
         break;
       case 44: /* "objects" */
-#line 148 "ael.y"
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1302 "ael.tab.c"
+#line 1309 "ael.tab.c"
         break;
       case 45: /* "object" */
-#line 148 "ael.y"
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1310 "ael.tab.c"
+#line 1317 "ael.tab.c"
         break;
       case 46: /* "word_or_default" */
-#line 160 "ael.y"
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1315 "ael.tab.c"
+#line 1322 "ael.tab.c"
         break;
       case 47: /* "context" */
-#line 148 "ael.y"
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1323 "ael.tab.c"
+#line 1330 "ael.tab.c"
         break;
-      case 48: /* "macro" */
-#line 148 "ael.y"
+      case 49: /* "macro" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1331 "ael.tab.c"
+#line 1338 "ael.tab.c"
         break;
-      case 49: /* "globals" */
-#line 148 "ael.y"
+      case 50: /* "globals" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1339 "ael.tab.c"
+#line 1346 "ael.tab.c"
         break;
-      case 50: /* "global_statements" */
-#line 148 "ael.y"
+      case 51: /* "global_statements" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1347 "ael.tab.c"
+#line 1354 "ael.tab.c"
         break;
-      case 51: /* "global_statement" */
-#line 148 "ael.y"
+      case 52: /* "global_statement" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1355 "ael.tab.c"
+#line 1362 "ael.tab.c"
         break;
-      case 53: /* "arglist" */
-#line 148 "ael.y"
+      case 54: /* "arglist" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1363 "ael.tab.c"
+#line 1370 "ael.tab.c"
         break;
-      case 54: /* "elements" */
-#line 148 "ael.y"
+      case 55: /* "elements_block" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1371 "ael.tab.c"
+#line 1378 "ael.tab.c"
         break;
-      case 55: /* "element" */
-#line 148 "ael.y"
+      case 56: /* "elements" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1379 "ael.tab.c"
+#line 1386 "ael.tab.c"
         break;
-      case 57: /* "ignorepat" */
-#line 148 "ael.y"
+      case 57: /* "element" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1387 "ael.tab.c"
+#line 1394 "ael.tab.c"
         break;
-      case 58: /* "extension" */
-#line 148 "ael.y"
+      case 59: /* "ignorepat" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1395 "ael.tab.c"
+#line 1402 "ael.tab.c"
         break;
-      case 59: /* "statements" */
-#line 148 "ael.y"
+      case 60: /* "extension" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1403 "ael.tab.c"
+#line 1410 "ael.tab.c"
         break;
-      case 60: /* "if_head" */
-#line 148 "ael.y"
+      case 61: /* "statements" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1411 "ael.tab.c"
+#line 1418 "ael.tab.c"
         break;
-      case 62: /* "random_head" */
-#line 148 "ael.y"
+      case 62: /* "if_head" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1419 "ael.tab.c"
+#line 1426 "ael.tab.c"
         break;
-      case 64: /* "iftime_head" */
-#line 148 "ael.y"
+      case 64: /* "random_head" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1427 "ael.tab.c"
+#line 1434 "ael.tab.c"
         break;
-      case 65: /* "word_list" */
-#line 160 "ael.y"
+      case 66: /* "iftime_head" */
+#line 159 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1442 "ael.tab.c"
+        break;
+      case 67: /* "word_list" */
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1432 "ael.tab.c"
+#line 1447 "ael.tab.c"
         break;
-      case 66: /* "word3_list" */
-#line 160 "ael.y"
+      case 68: /* "word3_list" */
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1437 "ael.tab.c"
+#line 1452 "ael.tab.c"
         break;
-      case 67: /* "goto_word" */
-#line 160 "ael.y"
+      case 69: /* "goto_word" */
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1442 "ael.tab.c"
+#line 1457 "ael.tab.c"
         break;
-      case 68: /* "switch_head" */
-#line 148 "ael.y"
+      case 70: /* "switch_head" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1450 "ael.tab.c"
+#line 1465 "ael.tab.c"
         break;
-      case 70: /* "statement" */
-#line 148 "ael.y"
+      case 72: /* "statement" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1458 "ael.tab.c"
+#line 1473 "ael.tab.c"
         break;
-      case 77: /* "opt_else" */
-#line 148 "ael.y"
+      case 79: /* "opt_else" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1466 "ael.tab.c"
+#line 1481 "ael.tab.c"
         break;
-      case 78: /* "target" */
-#line 148 "ael.y"
+      case 80: /* "target" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1474 "ael.tab.c"
+#line 1489 "ael.tab.c"
         break;
-      case 79: /* "jumptarget" */
-#line 148 "ael.y"
+      case 81: /* "jumptarget" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1482 "ael.tab.c"
+#line 1497 "ael.tab.c"
         break;
-      case 80: /* "macro_call" */
-#line 148 "ael.y"
+      case 82: /* "macro_call" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1490 "ael.tab.c"
+#line 1505 "ael.tab.c"
         break;
-      case 82: /* "application_call_head" */
-#line 148 "ael.y"
+      case 84: /* "application_call_head" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1498 "ael.tab.c"
+#line 1513 "ael.tab.c"
         break;
-      case 84: /* "application_call" */
-#line 148 "ael.y"
+      case 86: /* "application_call" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1506 "ael.tab.c"
+#line 1521 "ael.tab.c"
         break;
-      case 85: /* "opt_word" */
-#line 160 "ael.y"
+      case 87: /* "opt_word" */
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1511 "ael.tab.c"
+#line 1526 "ael.tab.c"
         break;
-      case 86: /* "eval_arglist" */
-#line 148 "ael.y"
+      case 88: /* "eval_arglist" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1519 "ael.tab.c"
+#line 1534 "ael.tab.c"
         break;
-      case 87: /* "case_statements" */
-#line 148 "ael.y"
+      case 89: /* "case_statements" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1527 "ael.tab.c"
+#line 1542 "ael.tab.c"
         break;
-      case 88: /* "case_statement" */
-#line 148 "ael.y"
+      case 90: /* "case_statement" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1535 "ael.tab.c"
+#line 1550 "ael.tab.c"
         break;
-      case 89: /* "macro_statements" */
-#line 148 "ael.y"
+      case 91: /* "macro_statements" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1543 "ael.tab.c"
+#line 1558 "ael.tab.c"
         break;
-      case 90: /* "macro_statement" */
-#line 148 "ael.y"
+      case 92: /* "macro_statement" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1551 "ael.tab.c"
+#line 1566 "ael.tab.c"
         break;
-      case 91: /* "switches" */
-#line 148 "ael.y"
+      case 93: /* "switches" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1559 "ael.tab.c"
+#line 1574 "ael.tab.c"
         break;
-      case 92: /* "eswitches" */
-#line 148 "ael.y"
+      case 94: /* "eswitches" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1567 "ael.tab.c"
+#line 1582 "ael.tab.c"
         break;
-      case 93: /* "switchlist" */
-#line 148 "ael.y"
+      case 95: /* "switchlist_block" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1575 "ael.tab.c"
+#line 1590 "ael.tab.c"
         break;
-      case 94: /* "includeslist" */
-#line 148 "ael.y"
+      case 96: /* "switchlist" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1583 "ael.tab.c"
+#line 1598 "ael.tab.c"
         break;
-      case 95: /* "includedname" */
-#line 160 "ael.y"
+      case 97: /* "includeslist" */
+#line 159 "ael.y"
+        {
+		destroy_pval((yyvaluep->pval));
+		prev_word=0;
+	};
+#line 1606 "ael.tab.c"
+        break;
+      case 98: /* "includedname" */
+#line 172 "ael.y"
         { free((yyvaluep->str));};
-#line 1588 "ael.tab.c"
+#line 1611 "ael.tab.c"
         break;
-      case 96: /* "includes" */
-#line 148 "ael.y"
+      case 99: /* "includes" */
+#line 159 "ael.y"
         {
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1596 "ael.tab.c"
+#line 1619 "ael.tab.c"
         break;
 
       default:
@@ -1909,17 +1932,17 @@
   switch (yyn)
     {
         case 2:
-#line 165 "ael.y"
+#line 177 "ael.y"
     { (yyval.pval) = parseio->pval = (yyvsp[0].pval); ;}
     break;
 
   case 3:
-#line 168 "ael.y"
+#line 180 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 4:
-#line 170 "ael.y"
+#line 182 "ael.y"
     {
 			if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {
 				(yyval.pval)=(yyvsp[-1].pval);
@@ -1933,249 +1956,244 @@
     break;
 
   case 5:
-#line 180 "ael.y"
+#line 192 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 6:
-#line 183 "ael.y"
+#line 195 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 7:
-#line 184 "ael.y"
+#line 196 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 8:
-#line 185 "ael.y"
+#line 197 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 9:
-#line 186 "ael.y"
+#line 198 "ael.y"
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
   case 10:
-#line 189 "ael.y"
+#line 201 "ael.y"
     { (yyval.str) = (yyvsp[0].str); ;}
     break;
 
   case 11:
-#line 190 "ael.y"
+#line 202 "ael.y"
     { (yyval.str) = strdup("default"); ;}
     break;
 
   case 12:
-#line 193 "ael.y"
+#line 205 "ael.y"
     {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval); ;}
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-3]), &(yylsp[0]));
+		(yyval.pval)->u1.str = (yyvsp[-1].str);
+		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval)->u3.abstract = (yyvsp[-3].intval); ;}
     break;
 
   case 13:
-#line 197 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+#line 213 "ael.y"
+    { (yyval.intval) = 1; ;}
     break;
 
   case 14:
-#line 200 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-5]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->u3.abstract = 1; ;}
+#line 214 "ael.y"
+    { (yyval.intval) = 0; ;}
     break;
 
   case 15:
-#line 205 "ael.y"
+#line 217 "ael.y"
     {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u3.abstract = 1; ;}
-    break;
-
-  case 16:
-#line 229 "ael.y"
-    {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-7]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-6].str); (yyval.pval)->u2.arglist = (yyvsp[-4].pval); (yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
-  case 17:
-#line 232 "ael.y"
+  case 16:
+#line 220 "ael.y"
     {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-6]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-5].str); (yyval.pval)->u2.arglist = (yyvsp[-3].pval); ;}
     break;
 
-  case 18:
-#line 235 "ael.y"
+  case 17:
+#line 223 "ael.y"
     {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-6]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-5].str);
 		(yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
-  case 19:
-#line 239 "ael.y"
+  case 18:
+#line 227 "ael.y"
     {
 		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str); ;}
     break;
 
-  case 20:
-#line 244 "ael.y"
+  case 19:
+#line 232 "ael.y"
     {
 		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.statements = (yyvsp[-1].pval);;}
     break;
 
-  case 21:
-#line 247 "ael.y"
+  case 20:
+#line 235 "ael.y"
     { /* empty globals is OK */
 		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-2]), &(yylsp[0])); ;}
     break;
 
-  case 22:
-#line 251 "ael.y"
+  case 21:
+#line 239 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 23:
-#line 252 "ael.y"
+  case 22:
+#line 240 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));;}
     break;
 
-  case 24:
-#line 253 "ael.y"
+  case 23:
+#line 241 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 25:
-#line 256 "ael.y"
+  case 24:
+#line 244 "ael.y"
     { reset_semicount(parseio->scanner); ;}
     break;
 
-  case 26:
-#line 256 "ael.y"
+  case 25:
+#line 244 "ael.y"
     {
 		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
-  case 27:
-#line 262 "ael.y"
-    {
-		(yyval.pval)= npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[0].str); ;}
+  case 26:
+#line 250 "ael.y"
+    { (yyval.pval)= nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
-  case 28:
-#line 265 "ael.y"
+  case 27:
+#line 251 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[0]));
 		z->u1.str = (yyvsp[0].str);
 		(yyval.pval) = linku1((yyvsp[-2].pval),z); ;}
     break;
 
-  case 29:
-#line 269 "ael.y"
+  case 28:
+#line 255 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
+  case 29:
+#line 258 "ael.y"
+    { (yyval.pval) = NULL; ;}
+    break;
+
   case 30:
-#line 272 "ael.y"
-    { (yyval.pval)=(yyvsp[0].pval);;}
+#line 259 "ael.y"
+    { (yyval.pval) = (yyvsp[-1].pval); ;}
     break;
 
   case 31:
-#line 273 "ael.y"
-    {(yyval.pval)=0;;}
+#line 262 "ael.y"
+    { (yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 32:
-#line 274 "ael.y"
+#line 263 "ael.y"
+    {(yyval.pval)=0;;}
+    break;
+
+  case 33:
+#line 264 "ael.y"
     { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 				else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 				else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 33:
-#line 277 "ael.y"
+  case 34:
+#line 267 "ael.y"
     { (yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 34:
-#line 280 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
-    break;
-
   case 35:
-#line 281 "ael.y"
+#line 270 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 36:
-#line 282 "ael.y"
+#line 271 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 37:
-#line 283 "ael.y"
+#line 272 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 38:
-#line 284 "ael.y"
+#line 273 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 39:
-#line 285 "ael.y"
-    { reset_semicount(parseio->scanner); ;}
+#line 274 "ael.y"
+    {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 40:
-#line 285 "ael.y"
+#line 275 "ael.y"
+    { reset_semicount(parseio->scanner); ;}
+    break;
+
+  case 41:
+#line 275 "ael.y"
     {
 		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
-  case 41:
-#line 289 "ael.y"
+  case 42:
+#line 279 "ael.y"
     {free((yyvsp[-1].str)); (yyval.pval)=0;;}
     break;
 
-  case 42:
-#line 290 "ael.y"
+  case 43:
+#line 280 "ael.y"
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
-  case 43:
-#line 293 "ael.y"
+  case 44:
+#line 283 "ael.y"
     {
 		(yyval.pval) = npval2(PV_IGNOREPAT, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 44:
-#line 298 "ael.y"
+  case 45:
+#line 288 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
     break;
 
-  case 45:
-#line 302 "ael.y"
+  case 46:
+#line 292 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2183,8 +2201,8 @@
 		(yyval.pval)->u4.regexten=1;;}
     break;
 
-  case 46:
-#line 307 "ael.y"
+  case 47:
+#line 297 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-6]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2192,8 +2210,8 @@
 		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
     break;
 
-  case 47:
-#line 312 "ael.y"
+  case 48:
+#line 302 "ael.y"
     {
 		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-7]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
@@ -2202,49 +2220,49 @@
 		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
     break;
 
-  case 48:
-#line 321 "ael.y"
+  case 49:
+#line 311 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 49:
-#line 322 "ael.y"
+  case 50:
+#line 312 "ael.y"
     {if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 50:
-#line 325 "ael.y"
+  case 51:
+#line 315 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 51:
-#line 328 "ael.y"
+  case 52:
+#line 318 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
-  case 52:
-#line 328 "ael.y"
+  case 53:
+#line 318 "ael.y"
     {
 		(yyval.pval)= npval2(PV_IF, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
     break;
 
-  case 53:
-#line 333 "ael.y"
+  case 54:
+#line 323 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
-  case 54:
-#line 333 "ael.y"
+  case 55:
+#line 323 "ael.y"
     {
 		(yyval.pval) = npval2(PV_RANDOM, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str=(yyvsp[-1].str);;}
     break;
 
-  case 55:
-#line 339 "ael.y"
+  case 56:
+#line 329 "ael.y"
     {
 		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-13]), &(yylsp[-9])); /* XXX really @5 or more ? */
 		(yyval.pval)->u1.list = npval2(PV_WORD, &(yylsp[-11]), &(yylsp[-11]));
@@ -2252,39 +2270,32 @@
 		free((yyvsp[-11].str));
 		free((yyvsp[-9].str));
 		free((yyvsp[-7].str));
-		(yyval.pval)->u1.list->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
-		(yyval.pval)->u1.list->next->u1.str = (yyvsp[-5].str);
-		(yyval.pval)->u1.list->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
-		(yyval.pval)->u1.list->next->next->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u1.list->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
-		(yyval.pval)->u1.list->next->next->next->u1.str = (yyvsp[-1].str);
+		(yyval.pval)->u1.list->next = nword((yyvsp[-5].str), &(yylsp[-5]));
+		(yyval.pval)->u1.list->next->next = nword((yyvsp[-3].str), &(yylsp[-3]));
+		(yyval.pval)->u1.list->next->next->next = nword((yyvsp[-1].str), &(yylsp[-1]));
 		prev_word = 0;
 	;}
     break;
 
-  case 56:
-#line 354 "ael.y"
+  case 57:
+#line 341 "ael.y"
     {
 		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-9]), &(yylsp[-5])); /* XXX @5 or greater ? */
-		(yyval.pval)->u1.list = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
-		(yyval.pval)->u1.list->u1.str = (yyvsp[-7].str);
-		(yyval.pval)->u1.list->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
-		(yyval.pval)->u1.list->next->u1.str = (yyvsp[-5].str);
-		(yyval.pval)->u1.list->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
-		(yyval.pval)->u1.list->next->next->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u1.list->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
-		(yyval.pval)->u1.list->next->next->next->u1.str = (yyvsp[-1].str);
+		(yyval.pval)->u1.list = nword((yyvsp[-7].str), &(yylsp[-7]));
+		(yyval.pval)->u1.list->next = nword((yyvsp[-5].str), &(yylsp[-5]));
+		(yyval.pval)->u1.list->next->next = nword((yyvsp[-3].str), &(yylsp[-3]));
+		(yyval.pval)->u1.list->next->next->next = nword((yyvsp[-1].str), &(yylsp[-1]));
 		prev_word = 0;
 	;}
     break;
 
-  case 57:
-#line 374 "ael.y"
+  case 58:
+#line 357 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 58:
-#line 375 "ael.y"
+  case 59:
+#line 358 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-1].str));
@@ -2292,13 +2303,13 @@
 		prev_word = (yyval.str);;}
     break;
 
-  case 59:
-#line 382 "ael.y"
+  case 60:
+#line 365 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 60:
-#line 383 "ael.y"
+  case 61:
+#line 366 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-1].str));
@@ -2306,8 +2317,8 @@
 		prev_word = (yyval.str);;}
     break;
 
-  case 61:
-#line 388 "ael.y"
+  case 62:
+#line 371 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s%s", (yyvsp[-2].str), (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-2].str));
@@ -2316,97 +2327,97 @@
 		prev_word=(yyval.str);;}
     break;
 
-  case 62:
-#line 396 "ael.y"
+  case 63:
+#line 379 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 63:
-#line 397 "ael.y"
+  case 64:
+#line 380 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
 		free((yyvsp[-1].str));
 		free((yyvsp[0].str));;}
     break;
 
-  case 64:
-#line 401 "ael.y"
+  case 65:
+#line 384 "ael.y"
     {
 		asprintf(&((yyval.str)), "%s:%s", (yyvsp[-2].str), (yyvsp[0].str));
 		free((yyvsp[-2].str));
 		free((yyvsp[0].str));;}
     break;
 
-  case 65:
-#line 407 "ael.y"
+  case 66:
+#line 390 "ael.y"
     { reset_parencount(parseio->scanner); ;}
     break;
 
-  case 66:
-#line 407 "ael.y"
+  case 67:
+#line 390 "ael.y"
     {
 		(yyval.pval) = npval2(PV_SWITCH, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 67:
-#line 415 "ael.y"
+  case 68:
+#line 398 "ael.y"
     {
 		(yyval.pval) = npval2(PV_STATEMENTBLOCK, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
     break;
 
-  case 68:
-#line 418 "ael.y"
+  case 69:
+#line 401 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 69:
-#line 418 "ael.y"
+  case 70:
+#line 401 "ael.y"
     {
 		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
     break;
 
-  case 70:
-#line 422 "ael.y"
+  case 71:
+#line 405 "ael.y"
     {
 		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
-  case 71:
-#line 425 "ael.y"
+  case 72:
+#line 408 "ael.y"
     {
 		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
-  case 72:
-#line 428 "ael.y"
+  case 73:
+#line 411 "ael.y"
     {
 		(yyval.pval) = npval2(PV_LABEL, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
     break;
 
-  case 73:
-#line 431 "ael.y"
+  case 74:
+#line 414 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 74:
-#line 432 "ael.y"
+  case 75:
+#line 415 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 75:
-#line 433 "ael.y"
+  case 76:
+#line 416 "ael.y"
     {reset_parencount(parseio->scanner);;}
     break;
 
-  case 76:
-#line 433 "ael.y"
+  case 77:
+#line 416 "ael.y"
     {
 		(yyval.pval) = npval2(PV_FOR, &(yylsp[-11]), &(yylsp[0]));
 		(yyval.pval)->u1.for_init = (yyvsp[-8].str);
@@ -2415,66 +2426,58 @@
 		(yyval.pval)->u4.for_statements = (yyvsp[0].pval);;}
     break;
 
-  case 77:
-#line 439 "ael.y"
+  case 78:
+#line 422 "ael.y"
     {reset_parencount(parseio->scanner);;}
     break;
 
-  case 78:
-#line 439 "ael.y"
+  case 79:
+#line 422 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WHILE, &(yylsp[-5]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
     break;
 
-  case 79:
-#line 443 "ael.y"
-    {
-		(yyval.pval)=(yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[0]).last_line;
-		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
-    break;
-
   case 80:
-#line 447 "ael.y"
+#line 426 "ael.y"
     {
-		(yyval.pval)=(yyvsp[-2].pval);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[0]).last_line;
-		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
+		(yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[0])); ;}
     break;
 
   case 81:
-#line 452 "ael.y"
+#line 428 "ael.y"
     {
-		(yyval.pval) = (yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[-1]).last_line;
-		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
+		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[0]));
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
     break;
 
   case 82:
-#line 456 "ael.y"
+#line 431 "ael.y"
     {
-		(yyval.pval) = (yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[0]).last_line;
-		(yyval.pval)->endcol = (yylsp[0]).last_column;;}
+		(yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[-1])); ;}
     break;
 
   case 83:
-#line 460 "ael.y"
+#line 433 "ael.y"
     {
+		(yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[0])); ;}
+    break;
+
+  case 84:
+#line 435 "ael.y"
+    {
 		(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 84:
-#line 463 "ael.y"
+  case 85:
+#line 438 "ael.y"
     {reset_semicount(parseio->scanner);;}
     break;
 
-  case 85:
-#line 463 "ael.y"
+  case 86:
+#line 438 "ael.y"
     {
 		char *bufx;
 		int tot=0;
@@ -2510,165 +2513,138 @@
 	;}
     break;
 
-  case 86:
-#line 496 "ael.y"
+  case 87:
+#line 471 "ael.y"
     { (yyval.pval) = npval2(PV_BREAK, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
-  case 87:
-#line 497 "ael.y"
+  case 88:
+#line 472 "ael.y"
     { (yyval.pval) = npval2(PV_RETURN, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
-  case 88:
-#line 498 "ael.y"
+  case 89:
+#line 473 "ael.y"
     { (yyval.pval) = npval2(PV_CONTINUE, &(yylsp[-1]), &(yylsp[0])); ;}
     break;
 
-  case 89:
-#line 499 "ael.y"
-    {
-		(yyval.pval)=(yyvsp[-2].pval);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[-1]).last_line;
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);
-		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
-    break;
-
   case 90:
-#line 513 "ael.y"
+#line 474 "ael.y"
     {
-		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[-1])); /* XXX probably @3... */
 		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[-1]).last_line;
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);
-		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 91:
-#line 527 "ael.y"
+#line 478 "ael.y"
     {
-		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[-1])); /* XXX probably @3... */
 		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->endline = (yylsp[-1]).last_line;
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);
-		(yyval.pval)->endcol = (yylsp[-1]).last_column;;}
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 92:
-#line 541 "ael.y"
-    { (yyval.pval)=0; ;}
+#line 482 "ael.y"
+    {
+		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[-1])); /* XXX probably @3... */
+		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 93:
-#line 544 "ael.y"
-    { (yyval.pval) = (yyvsp[0].pval); ;}
+#line 486 "ael.y"
+    { (yyval.pval)=0; ;}
     break;
 
   case 94:
-#line 545 "ael.y"
-    { (yyval.pval) = NULL ; ;}
+#line 489 "ael.y"
+    { (yyval.pval) = (yyvsp[0].pval); ;}
     break;
 
   case 95:
-#line 550 "ael.y"
-    { (yyval.pval) = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[0].str);;}
+#line 490 "ael.y"
+    { (yyval.pval) = NULL ; ;}
     break;
 
   case 96:
-#line 552 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
+#line 495 "ael.y"
+    { (yyval.pval) = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 97:
-#line 557 "ael.y"
+#line 496 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
+		(yyval.pval) = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 98:
-#line 562 "ael.y"
+#line 499 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
-		(yyval.pval)->u1.str = (yyvsp[-4].str);
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+		(yyval.pval) = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 99:
-#line 569 "ael.y"
+#line 502 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
-		(yyval.pval)->u1.str = (yyvsp[-4].str);
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+		(yyval.pval) = nword((yyvsp[-4].str), &(yylsp[-4]));
+		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 100:
-#line 576 "ael.y"
+#line 506 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
-		(yyval.pval)->u1.str = strdup("default");
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+		(yyval.pval) = nword((yyvsp[-4].str), &(yylsp[-4]));
+		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 101:
-#line 583 "ael.y"
+#line 510 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
-		(yyval.pval)->u1.str = strdup("default");
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->next->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->next->u1.str = (yyvsp[0].str); ;}
+		(yyval.pval) = nword(strdup("default"), &(yylsp[-4]));
+		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 102:
-#line 592 "ael.y"
+#line 514 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[0].str);
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0])); /* XXX not really @1 */
-		(yyval.pval)->next->u1.str = strdup("1");;}
+		(yyval.pval) = nword(strdup("default"), &(yylsp[-4]));
+		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
     break;
 
   case 103:
-#line 597 "ael.y"
+#line 521 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->next->u1.str = (yyvsp[0].str);;}
+		(yyval.pval) = nword((yyvsp[0].str), &(yylsp[0]));
+		(yyval.pval)->next = nword(strdup("1"), &(yylsp[0])); ;}
     break;
 
   case 104:
-#line 602 "ael.y"
+#line 524 "ael.y"
     {
+		(yyval.pval) = nword((yyvsp[-2].str), &(yylsp[-2]));
+		(yyval.pval)->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+    break;
+
+  case 105:
+#line 527 "ael.y"
+    {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
-		(yyval.pval)->u1.str = (yyvsp[0].str);
+		(yyval.pval)->u1.str = (yyvsp[0].str);	/* XXX must check this */
 		(yyval.pval)->next = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->next->u1.str = (yyvsp[-4].str);
 		(yyval.pval)->next->next = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
 		(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 105:
-#line 609 "ael.y"
+  case 106:
+#line 534 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = (yyvsp[0].str);
@@ -2678,8 +2654,8 @@
 		(yyval.pval)->next->next->u1.str = strdup("1"); ;}
     break;
 
-  case 106:
-#line 616 "ael.y"
+  case 107:
+#line 541 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-4]), &(yylsp[-4]));
 		(yyval.pval)->u1.str = strdup("default");
@@ -2689,8 +2665,8 @@
 		(yyval.pval)->next->next->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 107:
-#line 623 "ael.y"
+  case 108:
+#line 548 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-2]), &(yylsp[-2]));
 		(yyval.pval)->u1.str = strdup("default");
@@ -2700,13 +2676,13 @@
 		(yyval.pval)->next->next->u1.str = strdup("1"); ;}
     break;
 
-  case 108:
-#line 632 "ael.y"
+  case 109:
+#line 557 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
-  case 109:
-#line 632 "ael.y"
+  case 110:
+#line 557 "ael.y"
     {
 		/* XXX original code had @2 but i think we need @5 */
 		(yyval.pval) = npval2(PV_MACRO_CALL, &(yylsp[-4]), &(yylsp[0]));
@@ -2714,20 +2690,20 @@
 		(yyval.pval)->u2.arglist = (yyvsp[-1].pval);;}
     break;
 
-  case 110:
-#line 637 "ael.y"
+  case 111:
+#line 562 "ael.y"
     {
 		(yyval.pval)= npval2(PV_MACRO_CALL, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 111:
-#line 642 "ael.y"
+  case 112:
+#line 567 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
-  case 112:
-#line 642 "ael.y"
+  case 113:
+#line 567 "ael.y"
     {
 		if (strcasecmp((yyvsp[-2].str),"goto") == 0) {
 			(yyval.pval)= npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
@@ -2738,171 +2714,167 @@
 		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
     break;
 
-  case 113:
-#line 652 "ael.y"
-    {(yyval.pval) = (yyvsp[-2].pval);
+  case 114:
+#line 577 "ael.y"
+    {
+		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[0]));
  		if( (yyval.pval)->type == PV_GOTO )
 			(yyval.pval)->u1.list = (yyvsp[-1].pval);
 	 	else
 			(yyval.pval)->u2.arglist = (yyvsp[-1].pval);
- 		(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
+	;}
     break;
 
-  case 114:
-#line 658 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);(yyval.pval)->endline = (yylsp[0]).last_line; (yyval.pval)->endcol = (yylsp[0]).last_column;;}
-    break;
-
   case 115:
-#line 661 "ael.y"
-    { (yyval.str) = (yyvsp[0].str) ;}
+#line 584 "ael.y"
+    { (yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[0])); ;}
     break;
 
   case 116:
-#line 662 "ael.y"
-    { (yyval.str) = strdup(""); ;}
+#line 587 "ael.y"
+    { (yyval.str) = (yyvsp[0].str) ;}
     break;
 
   case 117:
-#line 665 "ael.y"
-    { 
-		(yyval.pval)= npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[0].str);;}
+#line 588 "ael.y"
+    { (yyval.str) = strdup(""); ;}
     break;
 
   case 118:
-#line 668 "ael.y"
+#line 591 "ael.y"
+    { (yyval.pval) = nword((yyvsp[0].str), &(yylsp[0])); ;}
+    break;
+
+  case 119:
+#line 592 "ael.y"
     {
 		(yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
 		(yyval.pval)->u1.str = strdup(""); ;}
     break;
 
-  case 119:
-#line 671 "ael.y"
+  case 120:
+#line 595 "ael.y"
     {
-		pval *z = npval2(PV_WORD, &(yylsp[0]), &(yylsp[0]));
+		pval *z = nword((yyvsp[0].str), &(yylsp[0]));
 		(yyval.pval) = (yyvsp[-2].pval);
-		linku1((yyvsp[-2].pval),z);
-		z->u1.str = (yyvsp[0].str);;}
+		linku1((yyvsp[-2].pval),z); ;}
     break;
 
-  case 120:
-#line 685 "ael.y"
+  case 121:
+#line 601 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 121:
-#line 686 "ael.y"
+  case 122:
+#line 602 "ael.y"
     { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 122:
-#line 691 "ael.y"
+  case 123:
+#line 607 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CASE, &(yylsp[-3]), &(yylsp[-1])); /* XXX 3 or 4 ? */
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
-  case 123:
-#line 695 "ael.y"
+  case 124:
+#line 611 "ael.y"
     {
 		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = NULL;
 		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
-  case 124:
-#line 699 "ael.y"
+  case 125:
+#line 615 "ael.y"
     {
 		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-3]), &(yylsp[0])); /* XXX at 3 or @4 ? */
 		(yyval.pval)->u1.str = (yyvsp[-2].str);
 		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
     break;
 
-  case 125:
-#line 703 "ael.y"
+  case 126:
+#line 619 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CASE, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 126:
-#line 706 "ael.y"
+  case 127:
+#line 622 "ael.y"
     {
 		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = NULL;;}
     break;
 
-  case 127:
-#line 709 "ael.y"
+  case 128:
+#line 625 "ael.y"
     {
 		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-2]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 128:
-#line 714 "ael.y"
+  case 129:
+#line 630 "ael.y"
     {(yyval.pval) = (yyvsp[0].pval);;}
     break;
 
-  case 129:
-#line 715 "ael.y"
+  case 130:
+#line 631 "ael.y"
     { if ( (yyvsp[-1].pval) && (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
-  case 130:
-#line 720 "ael.y"
+  case 131:
+#line 636 "ael.y"
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
-  case 131:
-#line 721 "ael.y"
+  case 132:
+#line 637 "ael.y"
     {
 		(yyval.pval) = npval2(PV_CATCH, &(yylsp[-4]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-3].str);
 		(yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
     break;
 
-  case 132:
-#line 727 "ael.y"
-    {
-		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
-    break;
-
   case 133:
-#line 730 "ael.y"
+#line 643 "ael.y"
     {
-		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-2]), &(yylsp[0])); ;}
+		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[0].pval); ;}
     break;
 
   case 134:
-#line 734 "ael.y"
+#line 648 "ael.y"
     {
-		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-1]), &(yylsp[0]));
+		(yyval.pval)->u1.list = (yyvsp[0].pval); ;}
     break;
 
   case 135:
-#line 737 "ael.y"
-    { /* empty switch list OK */
-		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-2]), &(yylsp[0])); ;}
+#line 653 "ael.y"
+    { (yyval.pval) = (yyvsp[-1].pval); ;}
     break;
 
   case 136:
-#line 741 "ael.y"
+#line 654 "ael.y"
+    { (yyval.pval) = NULL; ;}
+    break;
+
+  case 137:
+#line 657 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 137:
-#line 744 "ael.y"
+  case 138:
+#line 660 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
 		z->u1.str = (yyvsp[-1].str);
@@ -2910,20 +2882,20 @@
 		linku1((yyval.pval),z); ;}
     break;
 
-  case 138:
-#line 749 "ael.y"
+  case 139:
+#line 665 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 139:
-#line 752 "ael.y"
+  case 140:
+#line 668 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0]));
 		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
     break;
 
-  case 140:
-#line 756 "ael.y"
+  case 141:
+#line 672 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-13]), &(yylsp[-12]));
 		(yyval.pval)->u1.str = (yyvsp[-13].str);
@@ -2932,35 +2904,28 @@
 		free((yyvsp[-11].str));
 		free((yyvsp[-9].str));
 		free((yyvsp[-7].str));
-		(yyval.pval)->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
-		(yyval.pval)->u2.arglist->next->u1.str = (yyvsp[-5].str);
-		(yyval.pval)->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
-		(yyval.pval)->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
-		(yyval.pval)->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		(yyval.pval)->u2.arglist->next = nword((yyvsp[-5].str), &(yylsp[-5]));
+		(yyval.pval)->u2.arglist->next->next = nword((yyvsp[-3].str), &(yylsp[-3]));
+		(yyval.pval)->u2.arglist->next->next->next = nword((yyvsp[-1].str), &(yylsp[-1]));
 		prev_word=0;
 	;}
     break;
 
-  case 141:
-#line 772 "ael.y"
+  case 142:
+#line 685 "ael.y"
     {
 		(yyval.pval) = npval2(PV_WORD, &(yylsp[-9]), &(yylsp[-8]));
 		(yyval.pval)->u1.str = (yyvsp[-9].str);
-		(yyval.pval)->u2.arglist = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));
-		(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
-		(yyval.pval)->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
-		(yyval.pval)->u2.arglist->next->u1.str = (yyvsp[-5].str);
-		(yyval.pval)->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
-		(yyval.pval)->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
-		(yyval.pval)->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		(yyval.pval)->u2.arglist = nword((yyvsp[-7].str), &(yylsp[-7]));
+		(yyval.pval)->u2.arglist->next = nword((yyvsp[-5].str), &(yylsp[-5]));
+		(yyval.pval)->u2.arglist->next->next = nword((yyvsp[-3].str), &(yylsp[-3]));
+		(yyval.pval)->u2.arglist->next->next->next = nword((yyvsp[-1].str), &(yylsp[-1]));
 		prev_word=0;
 	;}
     break;
 
-  case 142:
-#line 785 "ael.y"
+  case 143:
+#line 694 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[0])); /* XXX don't we need @1- at 3 ?*/
 		(yyval.pval)=(yyvsp[-2].pval);
@@ -2968,8 +2933,8 @@
 		linku1((yyval.pval),z); ;}
     break;
 
-  case 143:
-#line 791 "ael.y"
+  case 144:
+#line 700 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-13]), &(yylsp[-12]));
 		(yyval.pval)=(yyvsp[-14].pval); z->u1.str = (yyvsp[-13].str);
@@ -2979,59 +2944,53 @@
 		free((yyvsp[-11].str));
 		free((yyvsp[-9].str));
 		free((yyvsp[-7].str));
-		z->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
-		z->u2.arglist->next->u1.str = (yyvsp[-5].str);
-		z->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
-		z->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
-		z->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
-		z->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		z->u2.arglist->next = nword((yyvsp[-5].str), &(yylsp[-5]));
+		z->u2.arglist->next->next = nword((yyvsp[-3].str), &(yylsp[-3]));
+		z->u2.arglist->next->next->next = nword((yyvsp[-1].str), &(yylsp[-1]));
 		prev_word=0;
 	;}
     break;
 
-  case 144:
-#line 808 "ael.y"
+  case 145:
+#line 714 "ael.y"
     {
 		pval *z = npval2(PV_WORD, &(yylsp[-9]), &(yylsp[-8]));
 		(yyval.pval)=(yyvsp[-10].pval);
 		linku1((yyval.pval),z);
-		(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);
+		(yyval.pval)->u2.arglist->u1.str = (yyvsp[-7].str);			/* XXX maybe too early ? */
 		z->u1.str = (yyvsp[-9].str);
 		z->u2.arglist = npval2(PV_WORD, &(yylsp[-7]), &(yylsp[-7]));	/* XXX is this correct ? */
-		z->u2.arglist->next = npval2(PV_WORD, &(yylsp[-5]), &(yylsp[-5]));
-		z->u2.arglist->next->u1.str = (yyvsp[-5].str);
-		z->u2.arglist->next->next = npval2(PV_WORD, &(yylsp[-3]), &(yylsp[-3]));
-		z->u2.arglist->next->next->u1.str = (yyvsp[-3].str);
-		z->u2.arglist->next->next->next = npval2(PV_WORD, &(yylsp[-1]), &(yylsp[-1]));
-		z->u2.arglist->next->next->next->u1.str = (yyvsp[-1].str);
+		z->u2.arglist->next = nword((yyvsp[-5].str), &(yylsp[-5]));
+		z->u2.arglist->next->next = nword((yyvsp[-3].str), &(yylsp[-3]));
+		z->u2.arglist->next->next->next = nword((yyvsp[-1].str), &(yylsp[-1]));
 		prev_word=0;
 	;}
     break;
 
-  case 145:
-#line 823 "ael.y"
+  case 146:
+#line 726 "ael.y"
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
-  case 146:
-#line 826 "ael.y"
+  case 147:
+#line 729 "ael.y"
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
-  case 147:
-#line 827 "ael.y"
+  case 148:
+#line 730 "ael.y"
     {(yyval.str)=strdup("default");;}
     break;
 
-  case 148:
-#line 830 "ael.y"
+  case 149:
+#line 733 "ael.y"
     {
 		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-3]), &(yylsp[0]));
 		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
     break;
 
-  case 149:
-#line 833 "ael.y"
+  case 150:
+#line 736 "ael.y"
     {
 		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-2]), &(yylsp[0]));;}
     break;
@@ -3041,7 +3000,7 @@
     }
 
 /* Line 1126 of yacc.c.  */
-#line 3045 "ael.tab.c"
+#line 3004 "ael.tab.c"
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -3316,7 +3275,7 @@
 }
 
 
-#line 838 "ael.y"
+#line 741 "ael.y"
 
 
 static char *token_equivs1[] =
@@ -3475,6 +3434,22 @@
 			first->first_column, last->last_column);
 }
 
+static struct pval *update_last(pval *obj, YYLTYPE *last)
+{
+	obj->endline = last->last_line;
+	obj->endcol = last->last_column;
+	return obj;
+}
+
+/* frontend for npval to create a PV_WORD string from the given token */
+static pval *nword(char *string, YYLTYPE *pos)
+{
+	pval *p = npval2(PV_WORD, pos, pos);
+	if (p)
+		p->u1.str = string;
+	return p;
+}
+
 /* append second element to the list in the first one */
 static pval * linku1(pval *head, pval *tail)
 {

Modified: trunk/pbx/ael/ael.tab.h
===================================================================
--- trunk/pbx/ael/ael.tab.h	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/ael/ael.tab.h	2006-04-30 15:42:56 UTC (rev 15)
@@ -115,13 +115,14 @@
 
 
 #if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
-#line 53 "ael.y"
+#line 49 "ael.y"
 typedef union YYSTYPE {
-	char *str;
-	struct pval *pval;
+	int	intval;		/* integer value, typically flags */
+	char	*str;		/* strings */
+	struct pval *pval;	/* full objects */
 } YYSTYPE;
 /* Line 1447 of yacc.c.  */
-#line 125 "ael.tab.h"
+#line 126 "ael.tab.h"
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1

Modified: trunk/pbx/ael/ael.y
===================================================================
--- trunk/pbx/ael/ael.y	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/ael/ael.y	2006-04-30 15:42:56 UTC (rev 15)
@@ -28,10 +28,6 @@
 #include "asterisk/utils.h"		/* ast_calloc() */
 #include "asterisk/ael_structs.h"
 
-/* create a new object with start-end marker */
-static pval *npval(pvaltype type, int first_line, int last_line,
-	int first_column, int last_column);
-
 static pval * linku1(pval *head, pval *tail);
 
 void reset_parencount(yyscan_t yyscanner);
@@ -51,8 +47,9 @@
 
 
 %union {
-	char *str;
-	struct pval *pval;
+	int	intval;		/* integer value, typically flags */
+	char	*str;		/* strings */
+	struct pval *pval;	/* full objects */
 }
 
 %{
@@ -60,10 +57,20 @@
 void yyerror(YYLTYPE *locp, struct parse_io *parseio, char const *s);
 int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void * yyscanner);
 
+/* create a new object with start-end marker */
+static pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column);
+
 /* create a new object with start-end marker, simplified interface.
  * Must be declared here because YYLTYPE is not known before
  */
 static pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last);
+
+/* another frontend for npval, this time for a string */
+static pval *nword(char *string, YYLTYPE *pos);
+
+/* update end position of an object, return the object */
+static pval *update_last(pval *, YYLTYPE *);
 %}
 
 
@@ -113,6 +120,8 @@
 %type <pval>file
 /* XXX lr changes */
 %type <pval>opt_else
+%type <pval>elements_block
+%type <pval>switchlist_block
 
 %type <str>opt_word
 %type <str>word_or_default
@@ -122,6 +131,8 @@
 %type <str>word3_list
 %type <str>includedname
 
+%type <intval>opt_abstract
+
 /*
  * OPTIONS
  */
@@ -156,6 +167,7 @@
 		ignorepat element elements arglist global_statement
 		global_statements globals macro context object objects
 		opt_else
+		elements_block switchlist_block
 
 %destructor { free($$);}  word word_list goto_word word3_list includedname opt_word word_or_default
 
@@ -190,42 +202,18 @@
 	| KW_DEFAULT { $$ = strdup("default"); }
 	;
 
-context : KW_CONTEXT word_or_default LC elements RC {
-		$$ = npval2(PV_CONTEXT, &@1, &@5);
-		$$->u1.str = $2;
-		$$->u2.statements = $4; }
-	| KW_CONTEXT word_or_default LC RC /* empty context OK */ {
+context : opt_abstract KW_CONTEXT word_or_default elements_block {
 		$$ = npval2(PV_CONTEXT, &@1, &@4);
-		$$->u1.str = $2; }
-	| KW_ABSTRACT KW_CONTEXT word_or_default LC elements RC {
-		$$ = npval2(PV_CONTEXT, &@1, &@6);
 		$$->u1.str = $3;
-		$$->u2.statements = $5;
-		$$->u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT word_or_default LC RC /* empty context OK */ {
-		$$ = npval2(PV_CONTEXT, &@1, &@5);
-		$$->u1.str = $3;
-		$$->u3.abstract = 1; }
-/*
-	| KW_CONTEXT KW_DEFAULT LC elements RC {
-		$$ = npval2(PV_CONTEXT, &@1, &@5);
-		$$->u1.str = strdup("default");
-		$$->u2.statements = $4; }
-	| KW_CONTEXT KW_DEFAULT LC RC {
-		$$ = npval2(PV_CONTEXT, &@1, &@4);
-		$$->u1.str = strdup("default"); }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC elements RC  {
-		$$ = npval2(PV_CONTEXT, &@1, &@6);
-		$$->u1.str = strdup("default");
-		$$->u2.statements = $5;
-		$$->u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC {
-		$$ = npval2(PV_CONTEXT, &@1, &@5);
-		$$->u1.str = strdup("default");
-		$$->u3.abstract = 1; }
-*/
+		$$->u2.statements = $4;
+		$$->u3.abstract = $1; }
 	;
 
+/* optional "abstract" keyword */
+opt_abstract: KW_ABSTRACT { $$ = 1; }
+	| /* nothing */ { $$ = 0; }
+	;
+
 macro : KW_MACRO word LP arglist RP LC macro_statements RC {
 		$$ = npval2(PV_MACRO, &@1, &@8);
 		$$->u1.str = $2; $$->u2.arglist = $4; $$->u3.macro_statements = $7; }
@@ -259,9 +247,7 @@
 		$$->u2.val = $4; }
 	;
 
-arglist : word {
-		$$= npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1; }
+arglist : word { $$= nword($1, &@1); }
 	| arglist COMMA word {
 		pval *z = npval2(PV_WORD, &@1, &@3);
 		z->u1.str = $3;
@@ -269,6 +255,10 @@
 	| arglist error {$$=$1;}
 	;
 
+elements_block : LC RC	{ $$ = NULL; }
+	| LC elements RC { $$ = $2; }
+	;
+
 elements : element { $$=$1;}
 	| error {$$=0;}
 	| elements element { if ( $1 && $2 ) {$$=$1; linku1($$,$2);}
@@ -343,24 +333,17 @@
 		free($3);
 		free($5);
 		free($7);
-		$$->u1.list->next = npval2(PV_WORD, &@9, &@9);
-		$$->u1.list->next->u1.str = $9;
-		$$->u1.list->next->next = npval2(PV_WORD, &@11, &@11);
-		$$->u1.list->next->next->u1.str = $11;
-		$$->u1.list->next->next->next = npval2(PV_WORD, &@13, &@13);
-		$$->u1.list->next->next->next->u1.str = $13;
+		$$->u1.list->next = nword($9, &@9);
+		$$->u1.list->next->next = nword($11, &@11);
+		$$->u1.list->next->next->next = nword($13, &@13);
 		prev_word = 0;
 	}
 	| KW_IFTIME LP word BAR word3_list BAR word3_list BAR word3_list RP {
 		$$ = npval2(PV_IFTIME, &@1, &@5); /* XXX @5 or greater ? */
-		$$->u1.list = npval2(PV_WORD, &@3, &@3);
-		$$->u1.list->u1.str = $3;
-		$$->u1.list->next = npval2(PV_WORD, &@5, &@5);
-		$$->u1.list->next->u1.str = $5;
-		$$->u1.list->next->next = npval2(PV_WORD, &@7, &@7);
-		$$->u1.list->next->next->u1.str = $7;
-		$$->u1.list->next->next->next = npval2(PV_WORD, &@9, &@9);
-		$$->u1.list->next->next->next->u1.str = $9;
+		$$->u1.list = nword($3, &@3);
+		$$->u1.list->next = nword($5, &@5);
+		$$->u1.list->next->next = nword($7, &@7);
+		$$->u1.list->next->next->next = nword($9, &@9);
 		prev_word = 0;
 	}
 
@@ -441,22 +424,14 @@
 		$$->u1.str = $4;
 		$$->u2.statements = $6; }
 	| switch_head RC /* empty list OK */ {
-		$$=$1;
-		$$->endline = @2.last_line;
-		$$->endcol = @2.last_column;}
+		$$ = update_last($1, &@2); }
 	| switch_head case_statements RC {
-		$$=$1;
-		$$->u2.statements = $2;
-		$$->endline = @3.last_line;
-		$$->endcol = @3.last_column;}
+		$$ = update_last($1, &@3);
+		$$->u2.statements = $2;}
 	| AMPER macro_call SEMI {
-		$$ = $2;
-		$$->endline = @2.last_line;
-		$$->endcol = @2.last_column;}
+		$$ = update_last($2, &@2); }
 	| application_call SEMI {
-		$$ = $1;
-		$$->endline = @2.last_line;
-		$$->endcol = @2.last_column;}
+		$$ = update_last($1, &@2); }
 	| word SEMI {
 		$$= npval2(PV_APPLICATION_CALL, &@1, &@2);
 		$$->u1.str = $1;}
@@ -497,47 +472,17 @@
 	| KW_RETURN SEMI { $$ = npval2(PV_RETURN, &@1, &@2); }
 	| KW_CONTINUE SEMI { $$ = npval2(PV_CONTINUE, &@1, &@2); }
 	| random_head statement opt_else {
-		$$=$1;
+		$$ = update_last($1, &@2); /* XXX probably @3... */
 		$$->u2.statements = $2;
-		$$->endline = @2.last_line;
-		$$->u3.else_statements = $3;
-		$$->endcol = @2.last_column;}
-/*
-	| random_head statement KW_ELSE statement {
-		$$=$1;
-		$$->u2.statements = $2;
-		$$->endline = @2.last_line;
-		$$->endcol = @2.last_column;
-		$$->u3.else_statements = $4;}
-*/
+		$$->u3.else_statements = $3;}
 	| if_head statement opt_else {
-		$$=$1;
+		$$ = update_last($1, &@2); /* XXX probably @3... */
 		$$->u2.statements = $2;
-		$$->endline = @2.last_line;
-		$$->u3.else_statements = $3;
-		$$->endcol = @2.last_column;}
-/*
-	| if_head statement KW_ELSE statement {
-		$$=$1;
-		$$->u2.statements = $2;
-		$$->endline = @2.last_line;
-		$$->endcol = @2.last_column;
-	$$->u3.else_statements = $4;}
-*/
+		$$->u3.else_statements = $3;}
 	| iftime_head statement opt_else {
-		$$=$1;
+		$$ = update_last($1, &@2); /* XXX probably @3... */
 		$$->u2.statements = $2;
-		$$->endline = @2.last_line;
-		$$->u3.else_statements = $3;
-		$$->endcol = @2.last_column;}
-/*
-	| iftime_head statement KW_ELSE statement {
-		$$=$1;
-		$$->u2.statements = $2;
-		$$->endline = @2.last_line;
-		$$->endcol = @2.last_column;
-		$$->u3.else_statements = $4;}
-*/
+		$$->u3.else_statements = $3;}
 	| SEMI { $$=0; }
 	;
 
@@ -547,61 +492,41 @@
 /* XXX unused */
 bar_or_comma: BAR | COMMA ;
 
-target : goto_word { $$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;}
+target : goto_word { $$ = nword($1, &@1); }
 	| goto_word BAR goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;}
+		$$ = nword($1, &@1);
+		$$->next = nword($3, &@3); }
 	| goto_word COMMA goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;}
+		$$ = nword($1, &@1);
+		$$->next = nword($3, &@3); }
 	| goto_word BAR goto_word BAR goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;
-		$$->next->next = npval2(PV_WORD, &@5, &@5);
-		$$->next->next->u1.str = $5; }
+		$$ = nword($1, &@1);
+		$$->next = nword($3, &@3);
+		$$->next->next = nword($5, &@5); }
 	| goto_word COMMA goto_word COMMA goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;
-		$$->next->next = npval2(PV_WORD, &@5, &@5);
-		$$->next->next->u1.str = $5; }
+		$$ = nword($1, &@1);
+		$$->next = nword($3, &@3);
+		$$->next->next = nword($5, &@5); }
 	| KW_DEFAULT BAR goto_word BAR goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = strdup("default");
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;
-		$$->next->next = npval2(PV_WORD, &@5, &@5);
-		$$->next->next->u1.str = $5; }
+		$$ = nword(strdup("default"), &@1);
+		$$->next = nword($3, &@3);
+		$$->next->next = nword($5, &@5); }
 	| KW_DEFAULT COMMA goto_word COMMA goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = strdup("default");
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;
-		$$->next->next = npval2(PV_WORD, &@5, &@5);
-		$$->next->next->u1.str = $5; }
+		$$ = nword(strdup("default"), &@1);
+		$$->next = nword($3, &@3);
+		$$->next->next = nword($5, &@5); }
 	;
 
+/* XXX please document the form of jumptarget */
 jumptarget : goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;
-		$$->next = npval2(PV_WORD, &@1, &@1); /* XXX not really @1 */
-		$$->next->u1.str = strdup("1");}  /*  jump extension[,priority][@context] */
+		$$ = nword($1, &@1);
+		$$->next = nword(strdup("1"), &@1); }  /*  jump extension[,priority][@context] */
 	| goto_word COMMA goto_word {
-		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;
-		$$->next = npval2(PV_WORD, &@3, &@3);
-		$$->next->u1.str = $3;}
+		$$ = nword($1, &@1);
+		$$->next = nword($3, &@3); }
 	| goto_word COMMA word AT word {
 		$$ = npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $5;
+		$$->u1.str = $5;	/* XXX must check this */
 		$$->next = npval2(PV_WORD, &@3, &@3);
 		$$->next->u1.str = $1;
 		$$->next->next = npval2(PV_WORD, &@5, &@5);
@@ -649,37 +574,28 @@
 		$$->u1.str = $1; }
 	;
 
-application_call : application_call_head eval_arglist RP {$$ = $1;
+application_call : application_call_head eval_arglist RP {
+		$$ = update_last($1, &@3);
  		if( $$->type == PV_GOTO )
 			$$->u1.list = $2;
 	 	else
 			$$->u2.arglist = $2;
- 		$$->endline = @3.last_line; $$->endcol = @3.last_column;}
-	| application_call_head RP {$$=$1;$$->endline = @2.last_line; $$->endcol = @2.last_column;}
+	}
+	| application_call_head RP { $$ = update_last($1, &@2); }
 	;
 
 opt_word : word { $$ = $1 }
 	| { $$ = strdup(""); }
 	;
 
-eval_arglist :  word_list { 
-		$$= npval2(PV_WORD, &@1, &@1);
-		$$->u1.str = $1;}
+eval_arglist :  word_list { $$ = nword($1, &@1); }
 	| /*nothing! */   {
 		$$= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
 		$$->u1.str = strdup(""); }
 	| eval_arglist COMMA  opt_word {
-		pval *z = npval2(PV_WORD, &@3, &@3);
+		pval *z = nword($3, &@3);
 		$$ = $1;
-		linku1($1,z);
-		z->u1.str = $3;}
-/*
-	| eval_arglist COMMA {
-		pval *z = npval2(PV_WORD, &@2, &@2);
-		$$ = $1;
-		linku1($1,z);
-		z->u1.str = strdup("");}
-*/
+		linku1($1,z); }
 	;
 
 case_statements: case_statement {$$=$1;}
@@ -724,20 +640,20 @@
 		$$->u2.statements = $4;}
 	;
 
-switches : KW_SWITCHES LC switchlist RC {
-		$$ = npval2(PV_SWITCHES, &@1, &@4);
-		$$->u1.list = $3; }
-	| KW_SWITCHES LC RC /* empty switch list OK */ {
-		$$ = npval2(PV_SWITCHES, &@1, &@3); }
+switches : KW_SWITCHES switchlist_block {
+		$$ = npval2(PV_SWITCHES, &@1, &@2);
+		$$->u1.list = $2; }
 	;
 
-eswitches : KW_ESWITCHES LC switchlist RC {
-		$$ = npval2(PV_ESWITCHES, &@1, &@4);
-		$$->u1.list = $3; }
-	| KW_ESWITCHES LC  RC { /* empty switch list OK */
-		$$ = npval2(PV_ESWITCHES, &@1, &@3); } /* if there's nothing to declare, why include it? */
+eswitches : KW_ESWITCHES switchlist_block {
+		$$ = npval2(PV_ESWITCHES, &@1, &@2);
+		$$->u1.list = $2; }
 	;
 
+switchlist_block : LC switchlist RC { $$ = $2; }
+	| LC RC { $$ = NULL; }
+	;
+
 switchlist : word SEMI {
 		$$ = npval2(PV_WORD, &@1, &@2);
 		$$->u1.str = $1;}
@@ -761,25 +677,18 @@
 		free($3);
 		free($5);
 		free($7);
-		$$->u2.arglist->next = npval2(PV_WORD, &@9, &@9);
-		$$->u2.arglist->next->u1.str = $9;
-		$$->u2.arglist->next->next = npval2(PV_WORD, &@11, &@11);
-		$$->u2.arglist->next->next->u1.str = $11;
-		$$->u2.arglist->next->next->next = npval2(PV_WORD, &@13, &@13);
-		$$->u2.arglist->next->next->next->u1.str = $13;
+		$$->u2.arglist->next = nword($9, &@9);
+		$$->u2.arglist->next->next = nword($11, &@11);
+		$$->u2.arglist->next->next->next = nword($13, &@13);
 		prev_word=0;
 	}
 	| includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
 		$$ = npval2(PV_WORD, &@1, &@2);
 		$$->u1.str = $1;
-		$$->u2.arglist = npval2(PV_WORD, &@3, &@3);
-		$$->u2.arglist->u1.str = $3;
-		$$->u2.arglist->next = npval2(PV_WORD, &@5, &@5);
-		$$->u2.arglist->next->u1.str = $5;
-		$$->u2.arglist->next->next = npval2(PV_WORD, &@7, &@7);
-		$$->u2.arglist->next->next->u1.str = $7;
-		$$->u2.arglist->next->next->next = npval2(PV_WORD, &@9, &@9);
-		$$->u2.arglist->next->next->next->u1.str = $9;
+		$$->u2.arglist = nword($3, &@3);
+		$$->u2.arglist->next = nword($5, &@5);
+		$$->u2.arglist->next->next = nword($7, &@7);
+		$$->u2.arglist->next->next->next = nword($9, &@9);
 		prev_word=0;
 	}
 	| includeslist includedname SEMI {
@@ -797,27 +706,21 @@
 		free($4);
 		free($6);
 		free($8);
-		z->u2.arglist->next = npval2(PV_WORD, &@10, &@10);
-		z->u2.arglist->next->u1.str = $10;
-		z->u2.arglist->next->next = npval2(PV_WORD, &@12, &@12);
-		z->u2.arglist->next->next->u1.str = $12;
-		z->u2.arglist->next->next->next = npval2(PV_WORD, &@14, &@14);
-		z->u2.arglist->next->next->next->u1.str = $14;
+		z->u2.arglist->next = nword($10, &@10);
+		z->u2.arglist->next->next = nword($12, &@12);
+		z->u2.arglist->next->next->next = nword($14, &@14);
 		prev_word=0;
 	}
 	| includeslist includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
 		pval *z = npval2(PV_WORD, &@2, &@3);
 		$$=$1;
 		linku1($$,z);
-		$$->u2.arglist->u1.str = $4;
+		$$->u2.arglist->u1.str = $4;			/* XXX maybe too early ? */
 		z->u1.str = $2;
 		z->u2.arglist = npval2(PV_WORD, &@4, &@4);	/* XXX is this correct ? */
-		z->u2.arglist->next = npval2(PV_WORD, &@6, &@6);
-		z->u2.arglist->next->u1.str = $6;
-		z->u2.arglist->next->next = npval2(PV_WORD, &@8, &@8);
-		z->u2.arglist->next->next->u1.str = $8;
-		z->u2.arglist->next->next->next = npval2(PV_WORD, &@10, &@10);
-		z->u2.arglist->next->next->next->u1.str = $10;
+		z->u2.arglist->next = nword($6, &@6);
+		z->u2.arglist->next->next = nword($8, &@8);
+		z->u2.arglist->next->next->next = nword($10, &@10);
 		prev_word=0;
 	}
 	| includeslist error {$$=$1;}
@@ -993,6 +896,22 @@
 			first->first_column, last->last_column);
 }
 
+static struct pval *update_last(pval *obj, YYLTYPE *last)
+{
+	obj->endline = last->last_line;
+	obj->endcol = last->last_column;
+	return obj;
+}
+
+/* frontend for npval to create a PV_WORD string from the given token */
+static pval *nword(char *string, YYLTYPE *pos)
+{
+	pval *p = npval2(PV_WORD, pos, pos);
+	if (p)
+		p->u1.str = string;
+	return p;
+}
+
 /* append second element to the list in the first one */
 static pval * linku1(pval *head, pval *tail)
 {

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/ael/ael_lex.c	2006-04-30 15:42:56 UTC (rev 15)
@@ -686,6 +686,8 @@
  */
 static char pbcstack[400];	/* XXX missing size checks */
 static int pbcpos = 0;
+static void pbcpush(char x);
+static int pbcpop(char x);
 
 static int parencount = 0;
 static int commaout = 0;
@@ -710,8 +712,6 @@
 void ael_yyset_column (int  column_no , yyscan_t yyscanner);
 
 int ael_yyparse (struct parse_io *);
-static void pbcpush(char x);
-static int pbcpop(char x);
 
 /*
  * A stack to process include files.
@@ -1348,8 +1348,7 @@
 		} else {
 			STORE_LOC;
 			yylval->str = strdup(yytext);
-			*(yylval->str+strlen(yylval->str)-1)=0;
-			/* printf("Got paren word %s\n", yylval->str); */
+			yylval->str[strlen(yylval->str)-1] = '\0'; /* trim trailing ')' */
 			unput(')');
 			BEGIN(0);
 			return word;
@@ -1359,7 +1358,7 @@
 case 45:
 /* rule 45 can match eol */
 YY_RULE_SETUP
-#line 251 "ael.flex"
+#line 250 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if (c == '(')
@@ -1371,7 +1370,7 @@
 case 46:
 /* rule 46 can match eol */
 YY_RULE_SETUP
-#line 259 "ael.flex"
+#line 258 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c))  { /* error */
@@ -1388,7 +1387,7 @@
 case 47:
 /* rule 47 can match eol */
 YY_RULE_SETUP
-#line 272 "ael.flex"
+#line 271 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if (c == '(')
@@ -1400,7 +1399,7 @@
 case 48:
 /* rule 48 can match eol */
 YY_RULE_SETUP
-#line 280 "ael.flex"
+#line 279 "ael.flex"
 {
 		if ( pbcpop(')') ) { /* error */
 			STORE_LOC;
@@ -1417,7 +1416,7 @@
 			STORE_LOC;
 			yylval->str = strdup(yytext);
 			if(yyleng > 1 )
-				*(yylval->str+yyleng-1)=0;
+				yylval->str[yyleng-1] = '\0'; /* trim trailing ')' */
 			BEGIN(0);
 			if ( !strcmp(yylval->str,")") ) {
 				free(yylval->str);
@@ -1434,7 +1433,7 @@
 case 49:
 /* rule 49 can match eol */
 YY_RULE_SETUP
-#line 310 "ael.flex"
+#line 309 "ael.flex"
 {
 		if( parencount != 0) { /* printf("Folding in a comma!\n"); */
 			yymore();
@@ -1464,7 +1463,7 @@
 case 50:
 /* rule 50 can match eol */
 YY_RULE_SETUP
-#line 336 "ael.flex"
+#line 335 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c) ) { /* error */
@@ -1480,7 +1479,7 @@
 case 51:
 /* rule 51 can match eol */
 YY_RULE_SETUP
-#line 350 "ael.flex"
+#line 349 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		yymore();
@@ -1490,7 +1489,7 @@
 case 52:
 /* rule 52 can match eol */
 YY_RULE_SETUP
-#line 356 "ael.flex"
+#line 355 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c) ) { /* error */
@@ -1506,7 +1505,7 @@
 case 53:
 /* rule 53 can match eol */
 YY_RULE_SETUP
-#line 368 "ael.flex"
+#line 367 "ael.flex"
 {
 		STORE_LOC;
 		yylval->str = strdup(yytext);
@@ -1520,7 +1519,7 @@
 case 54:
 /* rule 54 can match eol */
 YY_RULE_SETUP
-#line 378 "ael.flex"
+#line 377 "ael.flex"
 {
 		FILE *in1;
 		char fnamebuf[1024],*p1,*p2;
@@ -1587,7 +1586,7 @@
 case YY_STATE_EOF(paren):
 case YY_STATE_EOF(semic):
 case YY_STATE_EOF(argg):
-#line 440 "ael.flex"
+#line 439 "ael.flex"
 {
 		if ( --include_stack_index < 0 ) {
 			yyterminate();
@@ -1603,10 +1602,10 @@
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 453 "ael.flex"
+#line 452 "ael.flex"
 ECHO;
 	YY_BREAK
-#line 1610 "ael_lex.c"
+#line 1609 "ael_lex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -2736,7 +2735,7 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 453 "ael.flex"
+#line 452 "ael.flex"
 
 
 

Modified: trunk/pbx/pbx_ael.c
===================================================================
--- trunk/pbx/pbx_ael.c	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/pbx/pbx_ael.c	2006-04-30 15:42:56 UTC (rev 15)
@@ -3554,6 +3554,11 @@
 
 void destroy_pval_item(pval *item)
 {
+	if (item == NULL) {
+		ast_log(LOG_WARNING, "null item\n");
+		return;
+	}
+
 	if (item->filename)
 		free(item->filename);
 	

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-04-30 14:54:24 UTC (rev 14)
+++ trunk/utils/Makefile	2006-04-30 15:42:56 UTC (rev 15)
@@ -49,10 +49,10 @@
 	rm -f ast_expr2.o ast_expr2f.o
 
 astman.o: astman.c
-	$(CC) $(CFLAGS) -include ../include/autoconfig.h -c -o $@ $<
+	$(CC) $(CFLAGS) -c -o $@ $<
 
 astman: astman.o ../md5.o
-	$(CC) -D_GNU_SOURCE -o $@ $< ../md5.o -lnewt
+	$(CC) $(CFLAGS) -o $@ $< ../md5.o -lnewt
 
 stereorize: stereorize.o frame.o
 	$(CC) $(CFLAGS) -o stereorize stereorize.o frame.o -lm
@@ -60,10 +60,10 @@
 .PHONY: ../ast_expr2.c ../ast_expr2f.c ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ../pbx/pbx_ael.o
 
 ast_expr2.o: ../ast_expr2.c
-	gcc  $(CFLAGS) -include ../include/autoconfig.h -c -o $@ $<
+	gcc  $(CFLAGS) -c -o $@ $<
 
 ast_expr2f.o: ../ast_expr2f.c
-	gcc  $(CFLAGS) -include ../include/autoconfig.h -c -DSTANDALONE -o $@ $<
+	gcc  $(CFLAGS) -c -DSTANDALONE -o $@ $<
 
 check_expr: check_expr.c ast_expr2.o ast_expr2f.o
 	$(CC) $(CFLAGS) -o $@ $^
@@ -72,7 +72,7 @@
 	$(CC) $(CFLAGS) -g -o aelparse ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ael_main.o ../pbx/pbx_ael.o ../ast_expr2f.o ../ast_expr2.o
 
 ael_main.o : ael_main.c ../include/asterisk/ael_structs.h
-	$(CC) $(CFLAGS) -include ../include/autoconfig.h -c -g -o ael_main.o ael_main.c
+	$(CC) $(CFLAGS) -c -g -o ael_main.o ael_main.c
 
 ael_main1.o : ael_main.c ../include/asterisk/ael_structs.h
 	$(CC) $(CFLAGS) -c -g  -o ael_main1.o ael_main.c
@@ -85,7 +85,7 @@
 	./testexpr2s expr2.testinput
 
 smsq.o: smsq.c
-	$(CC) $(CFLAGS) -include ../include/autoconfig.h -c -o $@ $<
+	$(CC) $(CFLAGS) -c -o $@ $<
 
 smsq: smsq.o
 	$(CC) $(CFLAGS) -o smsq ${SOL} smsq.o -lpopt



From solid-pbx-svn-admin at lists.berlios.de  Sun Apr 30 19:20:14 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 30 Apr 2006 19:20:14 +0200
Subject: [solid-pbx-svn] r16 - trunk/channels
Message-ID: <200604301720.k3UHKEZL000491@sheep.berlios.de>

Author: casper2
Date: 2006-04-30 19:20:05 +0200 (Sun, 30 Apr 2006)
New Revision: 16

Modified:
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r23734

------------------------------------------------------------------------
r23704 | russell | 2006-04-30 17:29:38 +0200 (Sun, 30 Apr 2006) | 2 lines

fix a libtonezone detection issue on FreeBSD

------------------------------------------------------------------------
r23706 | kpfleming | 2006-04-30 17:48:56 +0200 (Sun, 30 Apr 2006) | 10 lines

Merged revisions 23705 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r23705 | kpfleming | 2006-04-30 10:46:22 -0500 (Sun, 30 Apr 2006) | 2 lines

remove a pointless comparison, since the buffer is smaller than the length being checked for

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-04-30 15:42:56 UTC (rev 15)
+++ trunk/channels/chan_iax2.c	2006-04-30 17:20:05 UTC (rev 16)
@@ -5062,10 +5062,10 @@
 	}
 	ast_mutex_unlock(&userl.lock);
 	user = best;
-	if (!user && !ast_strlen_zero(iaxs[callno]->username) && (strlen(iaxs[callno]->username) < 128)) {
+	if (!user && !ast_strlen_zero(iaxs[callno]->username)) {
 		user = realtime_user(iaxs[callno]->username);
 		if (user && !ast_strlen_zero(iaxs[callno]->context) &&			/* No context specified */
-			     !apply_context(user->contexts, iaxs[callno]->context)) {			/* Context is permitted */
+		    !apply_context(user->contexts, iaxs[callno]->context)) {		/* Context is permitted */
 			destroy_user(user);
 			user = NULL;
 		}



From solid-pbx-svn-admin at lists.berlios.de  Sun Apr 30 19:58:29 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 30 Apr 2006 19:58:29 +0200
Subject: [solid-pbx-svn] r17 - in trunk: . build_tools channels res
Message-ID: <200604301758.k3UHwTfd018691@sheep.berlios.de>

Author: casper2
Date: 2006-04-30 19:58:23 +0200 (Sun, 30 Apr 2006)
New Revision: 17

Modified:
   trunk/build_tools/menuselect-deps.in
   trunk/channels/Makefile
   trunk/channels/chan_oss.c
   trunk/configure.ac
   trunk/makeopts.in
   trunk/res/Makefile
Log:
Update to Asterisk SVN trunk r23737

------------------------------------------------------------------------
r23735 | kpfleming | 2006-04-30 19:25:01 +0200 (Sun, 30 Apr 2006) | 2 lines

remove remaining MFC/R2 stuff

------------------------------------------------------------------------
r23736 | kpfleming | 2006-04-30 19:49:50 +0200 (Sun, 30 Apr 2006) | 2 lines

use proper method of detecting OSS support on Linux and FreeBSD

------------------------------------------------------------------------
r23737 | kpfleming | 2006-04-30 19:53:37 +0200 (Sun, 30 Apr 2006) | 2 lines

remove macro defined that is no longer needed

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect-deps.in
===================================================================
--- trunk/build_tools/menuselect-deps.in	2006-04-30 17:20:05 UTC (rev 16)
+++ trunk/build_tools/menuselect-deps.in	2006-04-30 17:58:23 UTC (rev 17)
@@ -4,7 +4,6 @@
 GTK=@PBX_GTK@
 H323=@PBX_H323@
 KDE=@PBX_KDE@
-LIBMFCR2=@PBX_LIBmfcr2@
 LIBNEWT=@PBX_LIBnewt@
 LIBOSPTK=@PBX_LIBosptk@
 LIBPOPT=@PBX_LIBpopt@

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-04-30 17:20:05 UTC (rev 16)
+++ trunk/channels/Makefile	2006-04-30 17:58:23 UTC (rev 17)
@@ -103,15 +103,10 @@
 	./gentone ringtone 440 480
 
 chan_oss.o: chan_oss.c busy.h ringtone.h
+	$(CC) -c -o $@ $(CFLAGS) $(OSSAUDIO_INCLUDE) $<
 
-ifeq ($(OSARCH),OpenBSD)
 chan_oss.so: chan_oss.o
-	$(CC) $(SOLINK) -o $@ chan_oss.o -lossaudio
-endif
-ifeq ($(OSARCH),NetBSD)
-chan_oss.so: chan_oss.o
-	$(CC) $(SOLINK) -o $@ chan_oss.o -lossaudio
-endif
+	$(CC) $(SOLINK) -o $@ chan_oss.o $(OSSAUDIO_LIB)
 
 chan_iax2.so: chan_iax2.o iax2-parser.o iax2-provision.o
 	$(CC) $(SOLINK) -o $@ $< iax2-parser.o iax2-provision.o

Modified: trunk/channels/chan_oss.c
===================================================================
--- trunk/channels/chan_oss.c	2006-04-30 17:20:05 UTC (rev 16)
+++ trunk/channels/chan_oss.c	2006-04-30 17:58:23 UTC (rev 17)
@@ -33,7 +33,7 @@
  */
 
 /*** MODULEINFO
-	<depend>osssound</depend>
+	<depend>ossaudio</depend>
  ***/
 
 #include <stdio.h>

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-04-30 17:20:05 UTC (rev 16)
+++ trunk/configure.ac	2006-04-30 17:58:23 UTC (rev 17)
@@ -174,14 +174,25 @@
 AST_EXT_LIB([vorbis], [vorbis_info_init], [vorbis/codec.h], [VORBIS], [Vorbis], [-lm -lvorbisenc])
 AST_EXT_LIB([z], [compress], [zlib.h], [ZLIB], [zlib])
 
+PBX_LIBossaudio=0
 if test "x${PBX_OSTYPE}" = "xLinux" ; then
-   AST_EXT_LIB([ossaudio], [oss_ioctl_mixer], [linux/soundcard.h], [OSS], [Open Sound System])
+   AC_CHECK_HEADER([linux/soundcard.h],
+                   [PBX_LIBossaudio=1
+		    AC_DEFINE_UNQUOTED([HAVE_OSS], 1, [Define to indicate the Open Sound System library])
+		  ])
 elif test "x${PBX_OSTYPE}" = "xFreeBSD" ; then
-   AST_EXT_LIB([ossaudio], [oss_ioctl_mixer], [sys/soundcard.h], [OSS], [Open Sound System])
-else
+   AC_CHECK_HEADER([sys/soundcard.h],
+                   [PBX_LIBossaudio=1
+		    AC_DEFINE_UNQUOTED([HAVE_OSS], 1, [Define to indicate the Open Sound System library])
+		  ])
+elif test "x${PBX_OSTYPE}" = "xOpenBSD" ; then
    AST_EXT_LIB([ossaudio], [oss_ioctl_mixer], [soundcard.h], [OSS], [Open Sound System])
+elif test "x${PBX_OSTYPE}" = "xNetBSD" ; then
+   AST_EXT_LIB([ossaudio], [oss_ioctl_mixer], [soundcard.h], [OSS], [Open Sound System])
 fi
 
+AC_SUBST([PBX_LIBossaudio])
+
 if test "x${PBX_OSTYPE}" = "xLinux" ; then
    AST_EXT_LIB([tonezone], [tone_zone_find], [linux/zaptel.h], [ZAPTEL], [Zaptel])
 else

Modified: trunk/makeopts.in
===================================================================
--- trunk/makeopts.in	2006-04-30 17:20:05 UTC (rev 16)
+++ trunk/makeopts.in	2006-04-30 17:58:23 UTC (rev 17)
@@ -51,9 +51,6 @@
 PRI_LIB=@pri_LIB@
 PRI_INCLUDE=@pri_INCLUDE@
 
-MFCR2_LIB=@mfcr2_LIB@
-MFCR2_INCLUDE=@mfcr2_INCLUDE@
-
 OSPTK_LIB=@osptk_LIB@
 OSPTK_INCLUDE=@osptk_INCLUDE@
 

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-04-30 17:20:05 UTC (rev 16)
+++ trunk/res/Makefile	2006-04-30 17:58:23 UTC (rev 17)
@@ -34,12 +34,6 @@
   SNMP_LDLIBS+=$(shell net-snmp-config --agent-libs)
 endif
 
-
-#
-# Work around buggy RedHat 9.0
-#
-CFLAGS+=-DOPENSSL_NO_KRB5
-
 all: depend $(MODS)
 
 install: all



