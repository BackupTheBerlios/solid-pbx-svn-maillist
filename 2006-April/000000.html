<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [Solid-pbx-svn] r3 - in trunk: . apps build_tools channels configs include/asterisk pbx pbx/ael pbx/ael/ael-test utils
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-April/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5BSolid-pbx-svn%5D%20r3%20-%20in%20trunk%3A%20.%20apps%20build_tools%20channels%20configs%20include/asterisk%20pbx%20pbx/ael%20pbx/ael/ael-test%20utils&In-Reply-To=%3C200604290251.k3T2pw5q014322%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000001.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[Solid-pbx-svn] r3 - in trunk: . apps build_tools channels configs include/asterisk pbx pbx/ael pbx/ael/ael-test utils</H1>
    <B>casper2 at berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5BSolid-pbx-svn%5D%20r3%20-%20in%20trunk%3A%20.%20apps%20build_tools%20channels%20configs%20include/asterisk%20pbx%20pbx/ael%20pbx/ael/ael-test%20utils&In-Reply-To=%3C200604290251.k3T2pw5q014322%40sheep.berlios.de%3E"
       TITLE="[Solid-pbx-svn] r3 - in trunk: . apps build_tools channels configs include/asterisk pbx pbx/ael pbx/ael/ael-test utils">casper2 at berlios.de
       </A><BR>
    <I>Sat Apr 29 04:51:58 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000001.html">[Solid-pbx-svn] r4 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-04-29 04:51:28 +0200 (Sat, 29 Apr 2006)
New Revision: 3

Modified:
   trunk/Makefile
   trunk/acinclude.m4
   trunk/apps/app_directory.c
   trunk/apps/app_meetme.c
   trunk/apps/app_queue.c
   trunk/apps/app_voicemail.c
   trunk/apps/app_while.c
   trunk/ast_expr2.fl
   trunk/ast_expr2f.c
   trunk/asterisk.c
   trunk/build_tools/menuselect-deps.in
   trunk/build_tools/prep_moduledeps
   trunk/channel.c
   trunk/channels/chan_sip.c
   trunk/channels/chan_zap.c
   trunk/channels/misdn_config.c
   trunk/cli.c
   trunk/configs/mgcp.conf.sample
   trunk/configs/misdn.conf.sample
   trunk/configs/sip.conf.sample
   trunk/configs/zapata.conf.sample
   trunk/configure.ac
   trunk/http.c
   trunk/include/asterisk/ael_structs.h
   trunk/pbx/ael/ael-test/runtests
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael.tab.c
   trunk/pbx/ael/ael.tab.h
   trunk/pbx/ael/ael.y
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/pbx_ael.c
   trunk/rtp.c
   trunk/utils/Makefile
   trunk/utils/ael_main.c
Log:
Update to Asterisk SVN trunk r23270

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/Makefile	2006-04-29 02:51:28 UTC (rev 3)
@@ -564,6 +564,8 @@
 	$(MAKE) -C db1-ast clean
 	$(MAKE) -C stdtime clean
 
+distclean: dist-clean
+
 dist-clean: clean
 	rm -f menuselect.makeopts makeopts makeopts.xml
 	rm -f config.log config.status

Modified: trunk/acinclude.m4
===================================================================
--- trunk/acinclude.m4	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/acinclude.m4	2006-04-29 02:51:28 UTC (rev 3)
@@ -20,8 +20,7 @@
 PBX_LIB$1=0
 
 if test &quot;${USE_$1}&quot; != &quot;no&quot;; then	
-   AC_CHECK_LIB([$1], [$2], AC_DEFINE_UNQUOTED([HAVE_$4], 1,
-   [Define to indicate the $5 library]), [], -L${$1_DIR}/lib $6)
+   AC_CHECK_LIB([$1], [$2], [], [], -L${$1_DIR}/lib $6)
 
    if test &quot;${ac_cv_lib_$1_$2}&quot; = &quot;yes&quot;; then
       $1_LIB=&quot;-l$1 $6&quot;
@@ -51,6 +50,7 @@
          PBX_LIB$1=0
       else
          PBX_LIB$1=1
+         AC_DEFINE_UNQUOTED([HAVE_$4], 1, [Define to indicate the $5 library])
       fi
    elif test ! -z &quot;${$1_MANDATORY}&quot;;
    then

Modified: trunk/apps/app_directory.c
===================================================================
--- trunk/apps/app_directory.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_directory.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -32,7 +32,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22082 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23067 $&quot;)
 
 #include &quot;asterisk/lock.h&quot;
 #include &quot;asterisk/file.h&quot;
@@ -153,19 +153,22 @@
  *           '1' for selected entry from directory
  *           '*' for skipped entry from directory
  */
-static int play_mailbox_owner(struct ast_channel *chan, char *context, char *dialcontext, char *ext, char *name, int readext) {
+static int play_mailbox_owner(struct ast_channel *chan, char *context,
+		char *dialcontext, char *ext, char *name, int readext)
+{
 	int res = 0;
-	int loop = 3;
+	int loop;
 	char fn[256];
-	char fn2[256];
 
 	/* Check for the VoiceMail2 greeting first */
 	snprintf(fn, sizeof(fn), &quot;%s/voicemail/%s/%s/greet&quot;,
-		(char *)ast_config_AST_SPOOL_DIR, context, ext);
+		ast_config_AST_SPOOL_DIR, context, ext);
 
-	/* Otherwise, check for an old-style Voicemail greeting */
-	snprintf(fn2, sizeof(fn2), &quot;%s/vm/%s/greet&quot;,
-		(char *)ast_config_AST_SPOOL_DIR, ext);
+	if (ast_fileexists(fn, NULL, chan-&gt;language) &lt;= 0) {
+		/* no file, check for an old-style Voicemail greeting */
+		snprintf(fn, sizeof(fn), &quot;%s/vm/%s/greet&quot;,
+			ast_config_AST_SPOOL_DIR, ext);
+	}
 
 	if (ast_fileexists(fn, NULL, chan-&gt;language) &gt; 0) {
 		res = ast_stream_and_wait(chan, fn, chan-&gt;language, AST_DIGIT_ANY);
@@ -175,14 +178,6 @@
 			ast_stream_and_wait(chan, &quot;vm-extension&quot;, chan-&gt;language, AST_DIGIT_ANY);
 			res = ast_say_character_str(chan, ext, AST_DIGIT_ANY, chan-&gt;language);
 		}
-	} else if (ast_fileexists(fn2, NULL, chan-&gt;language) &gt; 0) {
-		res = ast_stream_and_wait(chan, fn2, chan-&gt;language, AST_DIGIT_ANY);
-		ast_stopstream(chan);
-		/* If Option 'e' was specified, also read the extension number with the name */
-		if (readext) {
-			ast_stream_and_wait(chan, &quot;vm-extension&quot;, chan-&gt;language, AST_DIGIT_ANY);
-			res = ast_say_character_str(chan, ext, AST_DIGIT_ANY, chan-&gt;language);
-		}
 	} else {
 		res = ast_say_character_str(chan, S_OR(name, ext), AST_DIGIT_ANY, chan-&gt;language);
 		if (!ast_strlen_zero(name) &amp;&amp; readext) {
@@ -191,45 +186,32 @@
 		}
 	}
 
-	while (loop) {
+	for (loop = 3 ; loop &gt; 0; loop--) {
 		if (!res)
 			res = ast_stream_and_wait(chan, &quot;dir-instr&quot;, chan-&gt;language, AST_DIGIT_ANY);
 		if (!res)
 			res = ast_waitfordigit(chan, 3000);
 		ast_stopstream(chan);
 	
-		if (res &gt; -1) {
-			switch (res) {
-				case '1':
-					/* Name selected */
-					loop = 0;
-					if (ast_goto_if_exists(chan, dialcontext, ext, 1)) {
-						ast_log(LOG_WARNING,
-							&quot;Can't find extension '%s' in context '%s'.  &quot;
-							&quot;Did you pass the wrong context to Directory?\n&quot;,
-							ext, dialcontext);
-						res = -1;
-					}
-					break;
-	
-				case '*':   
-					/* Skip to next match in list */
-					loop = 0;
-					break;
-	
-				default:
-					/* Not '1', or '*', so decrement number of tries */
-					res = 0;
-					loop--;
-					break;
-			} /* end switch */
-		} /* end if */
-		else {
-			/* User hungup, so jump out now */
-			loop = 0;
+		if (res &lt; 0) /* User hungup, so jump out now */
+			break;
+		if (res == '1') {	/* Name selected */
+			if (ast_goto_if_exists(chan, dialcontext, ext, 1)) {
+				ast_log(LOG_WARNING,
+					&quot;Can't find extension '%s' in context '%s'.  &quot;
+					&quot;Did you pass the wrong context to Directory?\n&quot;,
+					ext, dialcontext);
+				res = -1;
+			}
+			break;
 		}
-	} /* end while */
+		if (res == '*') /* Skip to next match in list */
+			break;
 
+		/* Not '1', or '*', so decrement number of tries */
+		res = 0;
+	}
+
 	return(res);
 }
 

Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_meetme.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -44,7 +44,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22267 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22931 $&quot;)
 
 #include &quot;asterisk/lock.h&quot;
 #include &quot;asterisk/file.h&quot;
@@ -92,7 +92,8 @@
 &quot;      'D' -- dynamically add conference, prompting for a PIN\n&quot;
 &quot;      'e' -- select an empty conference\n&quot;
 &quot;      'E' -- select an empty pinless conference\n&quot;
-&quot;      'i' -- announce user join/leave\n&quot;
+&quot;      'i' -- announce user join/leave with review\n&quot;
+&quot;      'I' -- announce user join/leave without review\n&quot;
 &quot;      'm' -- set monitor only mode (Listen only, no talking)\n&quot;
 &quot;      'M' -- enable music on hold when the conference has a single caller\n&quot;
 &quot;      'o' -- set talker optimization - treats talkers who aren't speaking as\n&quot;
@@ -253,8 +254,8 @@
 #define CONFFLAG_ANNOUNCEUSERCOUNT (1 &lt;&lt; 22)	/* If set, when user joins the conference, they will be told the number of users that are already in */
 #define CONFFLAG_OPTIMIZETALKER (1 &lt;&lt; 23)	/* If set, treats talking users as muted users */
 #define CONFFLAG_NOONLYPERSON (1 &lt;&lt; 24)		/* If set, won't speak the extra prompt when the first person enters the conference */
+#define CONFFLAG_INTROUSERNOREVIEW (1 &lt;&lt; 25) /* If set, user will be asked to record name on entry of conference without review */
 
-
 AST_APP_OPTIONS(meetme_opts, {
 	AST_APP_OPTION('A', CONFFLAG_MARKEDUSER ),
 	AST_APP_OPTION('a', CONFFLAG_ADMIN ),
@@ -265,6 +266,7 @@
 	AST_APP_OPTION('E', CONFFLAG_EMPTYNOPIN ),
 	AST_APP_OPTION('e', CONFFLAG_EMPTY ),
 	AST_APP_OPTION('i', CONFFLAG_INTROUSER ),
+	AST_APP_OPTION('I', CONFFLAG_INTROUSERNOREVIEW ),
 	AST_APP_OPTION('M', CONFFLAG_MOH ),
 	AST_APP_OPTION('m', CONFFLAG_MONITOR ),
 	AST_APP_OPTION('o', CONFFLAG_OPTIMIZETALKER ),
@@ -951,11 +953,14 @@
 			ast_copy_string(exitcontext, chan-&gt;context, sizeof(exitcontext));
 	}
 
-	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; (confflags &amp; CONFFLAG_INTROUSER)) {
+	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; ((confflags &amp; CONFFLAG_INTROUSER) || (confflags &amp; CONFFLAG_INTROUSERNOREVIEW))) {
 		snprintf(user-&gt;namerecloc, sizeof(user-&gt;namerecloc),
 			 &quot;%s/meetme/meetme-username-%s-%d&quot;, ast_config_AST_SPOOL_DIR,
 			 conf-&gt;confno, user-&gt;user_no);
-		res = ast_record_review(chan, &quot;vm-rec-name&quot;, user-&gt;namerecloc, 10, &quot;sln&quot;, &amp;duration, NULL);
+		if (confflags &amp; CONFFLAG_INTROUSERNOREVIEW)
+			res = ast_play_and_record(chan, &quot;vm-rec-name&quot;, user-&gt;namerecloc, 10, &quot;sln&quot;, &amp;duration, 128, 0, NULL);
+		else
+			res = ast_record_review(chan, &quot;vm-rec-name&quot;, user-&gt;namerecloc, 10, &quot;sln&quot;, &amp;duration, NULL);
 		if (res == -1)
 			goto outrun;
 	}
@@ -1088,7 +1093,7 @@
 
 	ast_mutex_lock(&amp;conf-&gt;playlock);
 
-	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; (confflags &amp; CONFFLAG_INTROUSER) &amp;&amp; conf-&gt;users &gt; 1) {
+	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; ((confflags &amp; CONFFLAG_INTROUSER) || (confflags &amp; CONFFLAG_INTROUSERNOREVIEW)) &amp;&amp; conf-&gt;users &gt; 1) {
 		if (conf-&gt;chan &amp;&amp; ast_fileexists(user-&gt;namerecloc, NULL, NULL)) {
 			if (!ast_streamfile(conf-&gt;chan, user-&gt;namerecloc, chan-&gt;language))
 				ast_waitstream(conf-&gt;chan, &quot;&quot;);
@@ -1646,7 +1651,7 @@
 	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; !(confflags &amp; CONFFLAG_MONITOR) &amp;&amp; !(confflags &amp; CONFFLAG_ADMIN))
 		conf_play(chan, conf, LEAVE);
 
-	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; (confflags &amp; CONFFLAG_INTROUSER)) {
+	if (!(confflags &amp; CONFFLAG_QUIET) &amp;&amp; ((confflags &amp; CONFFLAG_INTROUSER) || (confflags &amp; CONFFLAG_INTROUSERNOREVIEW))) {
 		if (ast_fileexists(user-&gt;namerecloc, NULL, NULL)) {
 			if ((conf-&gt;chan) &amp;&amp; (conf-&gt;users &gt; 1)) {
 				if (!ast_streamfile(conf-&gt;chan, user-&gt;namerecloc, chan-&gt;language))

Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_queue.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -68,7 +68,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 21821 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22655 $&quot;)
 
 #include &quot;asterisk/lock.h&quot;
 #include &quot;asterisk/file.h&quot;
@@ -3132,8 +3132,47 @@
 			}
 		}
 		ast_mutex_unlock(&amp;q-&gt;lock);
+	} else
+		ast_log(LOG_WARNING, &quot;queue %s was not found\n&quot;, data);
+
+	snprintf(buf, len, &quot;%d&quot;, count);
+	LOCAL_USER_REMOVE(lu);
+	return 0;
+}
+
+static int queue_function_queuewaitingcount(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
+{
+	int count = 0;
+	struct ast_call_queue *q;
+	struct localuser *lu;
+
+	buf[0] = '\0';
+	
+	if (ast_strlen_zero(data)) {
+		ast_log(LOG_ERROR, &quot;%s requires an argument: queuename\n&quot;, cmd);
+		return -1;
 	}
 
+	LOCAL_USER_ADD(lu);
+	
+	AST_LIST_LOCK(&amp;queues);
+
+	/* Find the right queue */
+	AST_LIST_TRAVERSE(&amp;queues, q, list) {
+		if (!strcasecmp(q-&gt;name, data)) {
+			ast_mutex_lock(&amp;q-&gt;lock);
+			break;
+		}
+	}
+
+	AST_LIST_UNLOCK(&amp;queues);
+
+	if (q) {
+		count = q-&gt;count;
+		ast_mutex_unlock(&amp;q-&gt;lock);
+	} else
+		ast_log(LOG_WARNING, &quot;queue %s was not found\n&quot;, data);
+
 	snprintf(buf, len, &quot;%d&quot;, count);
 	LOCAL_USER_REMOVE(lu);
 	return 0;
@@ -3184,7 +3223,8 @@
 			}
 		}
 		ast_mutex_unlock(&amp;q-&gt;lock);
-	}
+	} else
+		ast_log(LOG_WARNING, &quot;queue %s was not found\n&quot;, data);
 
 	/* We should already be terminated, but let's make sure. */
 	buf[len - 1] = '\0';
@@ -3211,6 +3251,15 @@
 	.read = queue_function_qac,
 };
 
+static struct ast_custom_function queuewaitingcount_function = {
+	.name = &quot;QUEUE_WAITING_COUNT&quot;,
+	.synopsis = &quot;Count number of calls currently waiting in a queue&quot;,
+	.syntax = &quot;QUEUE_WAITING_COUNT(&lt;queuename&gt;)&quot;,
+	.desc = 
+&quot;Returns the number of callers currently waiting in the specified queue.\n&quot;,
+	.read = queue_function_queuewaitingcount,
+};
+
 static struct ast_custom_function queuememberlist_function = {
 	.name = &quot;QUEUE_MEMBER_LIST&quot;,
 	.synopsis = &quot;Returns a list of interfaces on a queue&quot;,
@@ -3870,6 +3919,7 @@
 	res |= ast_custom_function_unregister(&amp;queueagentcount_function);
 	res |= ast_custom_function_unregister(&amp;queuemembercount_function);
 	res |= ast_custom_function_unregister(&amp;queuememberlist_function);
+	res |= ast_custom_function_unregister(&amp;queuewaitingcount_function);
 	res |= ast_unregister_application(app);
 
 	STANDARD_HANGUP_LOCALUSERS;
@@ -3899,6 +3949,7 @@
 	res |= ast_custom_function_register(&amp;queueagentcount_function);
 	res |= ast_custom_function_register(&amp;queuemembercount_function);
 	res |= ast_custom_function_register(&amp;queuememberlist_function);
+	res |= ast_custom_function_register(&amp;queuewaitingcount_function);
 
 	if (!res) {	
 		reload_queues();

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_voicemail.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -54,7 +54,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22268 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23250 $&quot;)
 
 #include &quot;asterisk/lock.h&quot;
 #include &quot;asterisk/file.h&quot;
@@ -245,10 +245,10 @@
 };
 
 struct vm_zone {
+	AST_LIST_ENTRY(vm_zone) list;
 	char name[80];
 	char timezone[80];
 	char msg_format[512];
-	struct vm_zone *next;
 };
 
 struct vm_state {
@@ -388,8 +388,7 @@
 static char *app4 = &quot;VMAuthenticate&quot;;
 
 static AST_LIST_HEAD_STATIC(users, ast_vm_user);
-struct vm_zone *zones = NULL;
-struct vm_zone *zonesl = NULL;
+static AST_LIST_HEAD_STATIC(zones, vm_zone);
 static int maxsilence;
 static int maxmsg;
 static int silencethreshold = 128;
@@ -1655,9 +1654,12 @@
 	/* Does this user have a timezone specified? */
 	if (!ast_strlen_zero(vmu-&gt;zonetag)) {
 		/* Find the zone in the list */
-		for (z = zones; z ; z = z-&gt;next)
+		AST_LIST_LOCK(&amp;zones);
+		AST_LIST_TRAVERSE(&amp;zones, z, list) {
 			if (!strcmp(z-&gt;name, vmu-&gt;zonetag))
 				break;
+		}
+		AST_LIST_UNLOCK(&amp;zones);
 	}
 	ast_localtime(&amp;t, tm, z ? z-&gt;timezone : NULL);
 	return tm;
@@ -3426,8 +3428,8 @@
 		/* start optimistic */
 		valid_extensions = 1;
 		while (s) {
-			/* find_user is going to ast_malloc since we have a NULL as first argument */
-			if ((receiver = find_user(NULL, context, s))) {
+			/* Don't forward to ourselves.  find_user is going to malloc since we have a NULL as first argument */
+			if (strcmp(s,sender-&gt;mailbox) &amp;&amp; (receiver = find_user(NULL, context, s))) {
 				AST_LIST_INSERT_HEAD(&amp;extensions, receiver, list);
 				found++;
 			} else {
@@ -3592,12 +3594,14 @@
 	if (!ast_strlen_zero(vmu-&gt;zonetag)) {
 		/* Find the zone in the list */
 		struct vm_zone *z;
-		for (z = zones; z; z = z-&gt;next) {
+		AST_LIST_LOCK(&amp;zones);
+		AST_LIST_TRAVERSE(&amp;zones, z, list) {
 			if (!strcmp(z-&gt;name, vmu-&gt;zonetag)) {
 				the_zone = z;
 				break;
 			}
 		}
+		AST_LIST_UNLOCK(&amp;zones);
 	}
 
 /* No internal variable parsing for now, so we'll comment it out for the time being */
@@ -5858,22 +5862,26 @@
 
 static int handle_show_voicemail_zones(int fd, int argc, char *argv[])
 {
-	struct vm_zone *zone = zones;
+	struct vm_zone *zone;
 	char *output_format = &quot;%-15s %-20s %-45s\n&quot;;
+	int res = RESULT_SUCCESS;
 
-	if (argc != 3) return RESULT_SHOWUSAGE;
+	if (argc != 3)
+		return RESULT_SHOWUSAGE;
 
-	if (zone) {
+	AST_LIST_LOCK(&amp;zones);
+	if (!AST_LIST_EMPTY(&amp;zones)) {
 		ast_cli(fd, output_format, &quot;Zone&quot;, &quot;Timezone&quot;, &quot;Message Format&quot;);
-		while (zone) {
+		AST_LIST_TRAVERSE(&amp;zones, zone, list) {
 			ast_cli(fd, output_format, zone-&gt;name, zone-&gt;timezone, zone-&gt;msg_format);
-			zone = zone-&gt;next;
 		}
 	} else {
 		ast_cli(fd, &quot;There are no voicemail zones currently defined\n&quot;);
-		return RESULT_FAILURE;
+		res = RESULT_FAILURE;
 	}
-	return RESULT_SUCCESS;
+	AST_LIST_UNLOCK(&amp;zones);
+
+	return res;
 }
 
 static char *complete_show_voicemail_users(const char *line, const char *word, int pos, int state)
@@ -5913,7 +5921,7 @@
 static int load_config(void)
 {
 	struct ast_vm_user *cur;
-	struct vm_zone *zcur, *zl;
+	struct vm_zone *zcur;
 	struct ast_config *cfg;
 	char *cat;
 	struct ast_variable *var;
@@ -5950,21 +5958,18 @@
 	int tmpadsi[4];
 
 	cfg = ast_config_load(VOICEMAIL_CONFIG);
+
 	AST_LIST_LOCK(&amp;users);
-	AST_LIST_TRAVERSE_SAFE_BEGIN(&amp;users, cur, list) {
-		AST_LIST_REMOVE_CURRENT(&amp;users, list);
+	while ((cur = AST_LIST_REMOVE_HEAD(&amp;users, list))) {
 		ast_set_flag(cur, VM_ALLOCED);	
 		free_user(cur);
 	}
-	AST_LIST_TRAVERSE_SAFE_END;
-	zcur = zones;
-	while (zcur) {
-		zl = zcur;
-		zcur = zcur-&gt;next;
-		free_zone(zl);
-	}
-	zones = NULL;
-	zonesl = NULL;
+
+	AST_LIST_LOCK(&amp;zones);
+	while ((zcur = AST_LIST_REMOVE_HEAD(&amp;zones, list))) 
+		free_zone(zcur);
+	AST_LIST_UNLOCK(&amp;zones);
+
 	memset(ext_pass_cmd, 0, sizeof(ext_pass_cmd));
 
 	if (cfg) {
@@ -6232,14 +6237,9 @@
 									ast_copy_string(z-&gt;name, var-&gt;name, sizeof(z-&gt;name));
 									ast_copy_string(z-&gt;timezone, timezone, sizeof(z-&gt;timezone));
 									ast_copy_string(z-&gt;msg_format, msg_format, sizeof(z-&gt;msg_format));
-									z-&gt;next = NULL;
-									if (zones) {
-										zonesl-&gt;next = z;
-										zonesl = z;
-									} else {
-										zones = z;
-										zonesl = z;
-									}
+									AST_LIST_LOCK(&amp;zones);
+									AST_LIST_INSERT_HEAD(&amp;zones, z, list);
+									AST_LIST_UNLOCK(&amp;zones);
 								} else {
 									ast_log(LOG_WARNING, &quot;Invalid timezone definition at line %d\n&quot;, var-&gt;lineno);
 									free(z);

Modified: trunk/apps/app_while.c
===================================================================
--- trunk/apps/app_while.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/apps/app_while.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -32,7 +32,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 20003 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22573 $&quot;)
 
 #include &quot;asterisk/file.h&quot;
 #include &quot;asterisk/logger.h&quot;
@@ -52,7 +52,7 @@
 &quot;Usage:  ExecIF (&lt;expr&gt;|&lt;app&gt;|&lt;data&gt;)\n&quot;
 &quot;If &lt;expr&gt; is true, execute and return the result of &lt;app&gt;(&lt;data&gt;).\n&quot;
 &quot;If &lt;expr&gt; is true, but &lt;app&gt; is not found, then the application\n&quot;
-&quot;will return a non-zero value.&quot;;
+&quot;will return a non-zero value.\n&quot;;
 static char *exec_synopsis = &quot;Conditional exec&quot;;
 
 static char *start_app = &quot;While&quot;;
@@ -61,16 +61,28 @@
 &quot;Start a While Loop.  Execution will return to this point when\n&quot;
 &quot;EndWhile is called until expr is no longer true.\n&quot;;
 
-static char *start_synopsis = &quot;Start A While Loop&quot;;
+static char *start_synopsis = &quot;Start a while loop&quot;;
 
 
 static char *stop_app = &quot;EndWhile&quot;;
 static char *stop_desc = 
 &quot;Usage:  EndWhile()\n&quot;
-&quot;Return to the previous called While\n\n&quot;;
+&quot;Return to the previous called While\n&quot;;
 
-static char *stop_synopsis = &quot;End A While Loop&quot;;
+static char *stop_synopsis = &quot;End a while loop&quot;;
 
+static char *exit_app = &quot;ExitWhile&quot;;
+static char *exit_desc =
+&quot;Usage:  ExitWhile()\n&quot;
+&quot;Exits a While loop, whether or not the conditional has been satisfied.\n&quot;;
+static char *exit_synopsis = &quot;End a While loop&quot;;
+
+static char *continue_app = &quot;ContinueWhile&quot;;
+static char *continue_desc =
+&quot;Usage:  ContinueWhile()\n&quot;
+&quot;Returns to the top of the while loop and re-evaluates the conditional.\n&quot;;
+static char *continue_synopsis = &quot;Restart a While loop&quot;;
+
 static char *tdesc = &quot;While Loops and Conditional Execution&quot;;
 
 LOCAL_USER_DECL;
@@ -265,7 +277,7 @@
 	}
 	
 
-	if (!end &amp;&amp; !ast_true(condition)) {
+	if ((!end &amp;&amp; !ast_true(condition)) || (end == 2)) {
 		/* Condition Met (clean up helper vars) */
 		const char *goto_str;
 		pbx_builtin_setvar_helper(chan, varname, NULL);
@@ -324,7 +336,29 @@
 	return _while_exec(chan, data, 1);
 }
 
+static int while_exit_exec(struct ast_channel *chan, void *data) {
+	return _while_exec(chan, data, 2);
+}
 
+static int while_continue_exec(struct ast_channel *chan, void *data)
+{
+	int x;
+	const char *prefix = &quot;WHILE&quot;, *while_pri=NULL;
+
+	for (x = 0; ; x++) {
+		const char *tmp = get_index(chan, prefix, x);
+		if (tmp)
+			while_pri = tmp;
+		else
+			break;
+	}
+
+	if (while_pri)
+		ast_parseable_goto(chan, while_pri);
+
+	return 0;
+}
+
 static int unload_module(void *mod)
 {
 	int res;
@@ -332,6 +366,8 @@
 	res = ast_unregister_application(start_app);
 	res |= ast_unregister_application(exec_app);
 	res |= ast_unregister_application(stop_app);
+	res |= ast_unregister_application(exit_app);
+	res |= ast_unregister_application(continue_app);
 
 	STANDARD_HANGUP_LOCALUSERS;
 
@@ -345,6 +381,8 @@
 	res = ast_register_application(start_app, while_start_exec, start_synopsis, start_desc);
 	res |= ast_register_application(exec_app, execif_exec, exec_synopsis, exec_desc);
 	res |= ast_register_application(stop_app, while_end_exec, stop_synopsis, stop_desc);
+	res |= ast_register_application(exit_app, while_exit_exec, exit_synopsis, exit_desc);
+	res |= ast_register_application(continue_app, while_continue_exec, continue_synopsis, continue_desc);
 
 	return res;
 }

Modified: trunk/ast_expr2.fl
===================================================================
--- trunk/ast_expr2.fl	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/ast_expr2.fl	2006-04-29 02:51:28 UTC (rev 3)
@@ -39,7 +39,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22273 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23175 $&quot;)
 
 #include &quot;asterisk/ast_expr.h&quot;
 #include &quot;asterisk/logger.h&quot;
@@ -59,10 +59,24 @@
 
 #include &quot;ast_expr2.h&quot; /* the o/p of the bison on ast_expr2.y */
 
-#define SET_COLUMNS yylloc_param-&gt;first_column = (int)(yyg-&gt;yytext_r - YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf);yylloc_param-&gt;last_column = yylloc_param-&gt;last_column + yyleng - 1; yylloc_param-&gt;first_line = yylloc_param-&gt;last_line = 1
-#define SET_STRING yylval_param-&gt;val = (struct val *)calloc(sizeof(struct val),1); yylval_param-&gt;val-&gt;type = AST_EXPR_string; yylval_param-&gt;val-&gt;u.s = strdup(yytext);
-#define SET_NUMERIC_STRING yylval_param-&gt;val = (struct val *)calloc(sizeof(struct val),1); yylval_param-&gt;val-&gt;type = AST_EXPR_numeric_string; yylval_param-&gt;val-&gt;u.s = strdup(yytext);
+#define SET_COLUMNS	do {		\
+	yylloc_param-&gt;first_column = (int)(yyg-&gt;yytext_r - YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf); \
+	yylloc_param-&gt;last_column += yyleng - 1; \
+	yylloc_param-&gt;first_line = yylloc_param-&gt;last_line = 1; \
+	} while (0)
 
+#define SET_STRING	do {		\
+	yylval_param-&gt;val = calloc(1, sizeof(struct val));	\
+	yylval_param-&gt;val-&gt;type = AST_EXPR_string;		\
+	yylval_param-&gt;val-&gt;u.s = strdup(yytext);		\
+	} while (0)
+
+#define SET_NUMERIC_STRING	do {	\
+	yylval_param-&gt;val = calloc(1, sizeof(struct val));	\
+	yylval_param-&gt;val-&gt;type = AST_EXPR_numeric_string;	\
+	yylval_param-&gt;val-&gt;u.s = strdup(yytext);	\
+	} while (0)
+
 struct parse_io
 {
 	char *string;
@@ -110,26 +124,82 @@
 \:\:	{ SET_COLUMNS; SET_STRING; return TOK_COLONCOLON;}
 \(	{ SET_COLUMNS; SET_STRING; return TOK_LP;}
 \)	{ SET_COLUMNS; SET_STRING; return TOK_RP;}
-\$\{   {/* gather the contents of ${} expressions, with trailing stuff, into a single TOKEN. They are much more complex now than they used to be */
-                       curlycount = 0; BEGIN(var); yymore();}
+\$\{	{
+		/* gather the contents of ${} expressions, with trailing stuff,
+		 * into a single TOKEN.
+		 * They are much more complex now than they used to be
+		 */
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
 
-[ 	\r]		{}
-\&quot;[^&quot;]*\&quot;   {SET_COLUMNS; SET_STRING; return TOKEN;}
+[ \t\r]		{}
+\&quot;[^&quot;]*\&quot;	{SET_COLUMNS; SET_STRING; return TOKEN;}
 
-[\n]	{/* what to do with eol */}
-[0-9]+		{   SET_COLUMNS;  /* the original behavior of the expression parser was to bring in numbers as a numeric string */
-				SET_NUMERIC_STRING;
-				return TOKEN;}
+[\n]		{/* what to do with eol */}
+[0-9]+		{
+		SET_COLUMNS;
+		/* the original behavior of the expression parser was
+		 * to bring in numbers as a numeric string
+		 */
+		SET_NUMERIC_STRING;
+		return TOKEN;
+	}
 
-[a-zA-Z0-9,.';\\_^$#@]+	{SET_COLUMNS; SET_STRING; return TOKEN;}
+[a-zA-Z0-9,.';\\_^$#@]+	{
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 
-&lt;var&gt;[^{}]*\}  {curlycount--; if(curlycount &lt; 0){ BEGIN(trail);  yymore();} else {  yymore();}}
-&lt;var&gt;[^{}]*\{  {curlycount++; yymore();  }
-&lt;trail&gt;[^-\t\r \n$():?%/+=*&lt;&gt;!|&amp;]* {BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN;}
-&lt;trail&gt;[-\t\r \n$():?%/+=*&lt;&gt;!|&amp;]        {char c = yytext[yyleng-1]; BEGIN(0); unput(c); SET_COLUMNS; SET_STRING; return TOKEN;}
-&lt;trail&gt;\$\{            {curlycount = 0; BEGIN(var); yymore();  }
-&lt;trail&gt;&lt;&lt;EOF&gt;&gt;		{BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN; /*actually, if an expr is only a variable ref, this could happen a LOT */}
 
+&lt;var&gt;[^{}]*\}	{
+		curlycount--;
+		if (curlycount &lt; 0) {
+			BEGIN(trail);
+			yymore();
+		} else {
+			yymore();
+		}
+	}
+	
+&lt;var&gt;[^{}]*\{	{
+		curlycount++;
+		yymore();
+	}
+	
+
+&lt;trail&gt;[^-\t\r \n$():?%/+=*&lt;&gt;!|&amp;]*	{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
+	
+&lt;trail&gt;[-\t\r \n$():?%/+=*&lt;&gt;!|&amp;]	{
+		char c = yytext[yyleng-1];
+		BEGIN(0);
+		unput(c);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
+	
+&lt;trail&gt;\$\{	{
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
+	
+&lt;trail&gt;&lt;&lt;EOF&gt;&gt;	{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+		/*actually, if an expr is only a variable ref, this could happen a LOT */
+	}
+
 %%
 
 /* I'm putting the interface routine to the whole parse here in the flexer input file

Modified: trunk/ast_expr2f.c
===================================================================
--- trunk/ast_expr2f.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/ast_expr2f.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -9,7 +9,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 31
+#define YY_FLEX_SUBMINOR_VERSION 33
 #if YY_FLEX_SUBMINOR_VERSION &gt; 0
 #define FLEX_BETA
 #endif
@@ -31,7 +31,15 @@
 
 /* C99 systems have &lt;inttypes.h&gt;. Non-C99 systems may or may not. */
 
-#if defined __STDC_VERSION__ &amp;&amp; __STDC_VERSION__ &gt;= 199901L
+#if __STDC_VERSION__ &gt;= 199901L
+
+/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
+ * if you want the limit (max/min) macros for int types. 
+ */
+#ifndef __STDC_LIMIT_MACROS
+#define __STDC_LIMIT_MACROS 1
+#endif
+
 #include &lt;inttypes.h&gt;
 typedef int8_t flex_int8_t;
 typedef uint8_t flex_uint8_t;
@@ -154,6 +162,10 @@
 #define YY_BUF_SIZE 16384
 #endif
 
+/* The state buf must be large enough to hold one state per character in the main buffer.
+ */
+#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
+
 #ifndef YY_TYPEDEF_YY_BUFFER_STATE
 #define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
@@ -1359,7 +1371,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22273 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23175 $&quot;)
 
 #include &quot;asterisk/ast_expr.h&quot;
 #include &quot;asterisk/logger.h&quot;
@@ -1379,10 +1391,24 @@
 
 #include &quot;ast_expr2.h&quot; /* the o/p of the bison on ast_expr2.y */
 
-#define SET_COLUMNS yylloc_param-&gt;first_column = (int)(yyg-&gt;yytext_r - YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf);yylloc_param-&gt;last_column = yylloc_param-&gt;last_column + yyleng - 1; yylloc_param-&gt;first_line = yylloc_param-&gt;last_line = 1
-#define SET_STRING yylval_param-&gt;val = (struct val *)calloc(sizeof(struct val),1); yylval_param-&gt;val-&gt;type = AST_EXPR_string; yylval_param-&gt;val-&gt;u.s = strdup(yytext);
-#define SET_NUMERIC_STRING yylval_param-&gt;val = (struct val *)calloc(sizeof(struct val),1); yylval_param-&gt;val-&gt;type = AST_EXPR_numeric_string; yylval_param-&gt;val-&gt;u.s = strdup(yytext);
+#define SET_COLUMNS	do {		\
+	yylloc_param-&gt;first_column = (int)(yyg-&gt;yytext_r - YY_CURRENT_BUFFER_LVALUE-&gt;yy_ch_buf); \
+	yylloc_param-&gt;last_column += yyleng - 1; \
+	yylloc_param-&gt;first_line = yylloc_param-&gt;last_line = 1; \
+	} while (0)
 
+#define SET_STRING	do {		\
+	yylval_param-&gt;val = calloc(1, sizeof(struct val));	\
+	yylval_param-&gt;val-&gt;type = AST_EXPR_string;		\
+	yylval_param-&gt;val-&gt;u.s = strdup(yytext);		\
+	} while (0)
+
+#define SET_NUMERIC_STRING	do {	\
+	yylval_param-&gt;val = calloc(1, sizeof(struct val));	\
+	yylval_param-&gt;val-&gt;type = AST_EXPR_numeric_string;	\
+	yylval_param-&gt;val-&gt;u.s = strdup(yytext);	\
+	} while (0)
+
 struct parse_io
 {
 	char *string;
@@ -1395,17 +1421,19 @@
 static int curlycount = 0;
 static char *expr2_token_subst(char *mess);
 
-#line 1394 &quot;ast_expr2f.c&quot;
+#line 1425 &quot;ast_expr2f.c&quot;
 
 #define INITIAL 0
 #define var 1
 #define trail 2
 
+#ifndef YY_NO_UNISTD_H
 /* Special case for &quot;unistd.h&quot;, since it is non-ANSI. We include it way
  * down here because we want the user's section 1 to have been scanned first.
  * The user has a chance to override it with an option.
  */
 #include &lt;unistd.h&gt;
+#endif
 
 #ifndef YY_EXTRA_TYPE
 #define YY_EXTRA_TYPE void *
@@ -1449,6 +1477,8 @@
 
     }; /* end struct yyguts_t */
 
+static int yy_init_globals (yyscan_t yyscanner );
+
     /* This must go here because YYSTYPE and YYLTYPE are included
      * from bison output in section 1.*/
     #    define yylval yyg-&gt;yylval_r
@@ -1583,9 +1613,11 @@
 #ifndef YY_DECL
 #define YY_DECL_IS_OURS 1
 
-extern int ast_yylex (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
+extern int ast_yylex \
+               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
 
-#define YY_DECL int ast_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
+#define YY_DECL int ast_yylex \
+               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
 #endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
@@ -1612,18 +1644,18 @@
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 83 &quot;ast_expr2.fl&quot;
+#line 102 &quot;ast_expr2.fl&quot;
 
 
-#line 1614 &quot;ast_expr2f.c&quot;
+#line 1651 &quot;ast_expr2f.c&quot;
 
     yylval = yylval_param;
 
     yylloc = yylloc_param;
 
-	if ( yyg-&gt;yy_init )
+	if ( !yyg-&gt;yy_init )
 		{
-		yyg-&gt;yy_init = 0;
+		yyg-&gt;yy_init = 1;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
@@ -1698,192 +1730,241 @@
 
 case 1:
 YY_RULE_SETUP
-#line 85 &quot;ast_expr2.fl&quot;
+#line 104 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_OR;}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 86 &quot;ast_expr2.fl&quot;
+#line 105 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_AND;}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 87 &quot;ast_expr2.fl&quot;
+#line 106 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_EQ;}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 88 &quot;ast_expr2.fl&quot;
+#line 107 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_OR;}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 89 &quot;ast_expr2.fl&quot;
+#line 108 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_AND;}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 90 &quot;ast_expr2.fl&quot;
+#line 109 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_EQ;}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 91 &quot;ast_expr2.fl&quot;
+#line 110 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_EQTILDE;}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 92 &quot;ast_expr2.fl&quot;
+#line 111 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_GT;}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 93 &quot;ast_expr2.fl&quot;
+#line 112 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_LT;}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 94 &quot;ast_expr2.fl&quot;
+#line 113 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_GE;}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 95 &quot;ast_expr2.fl&quot;
+#line 114 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_LE;}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 96 &quot;ast_expr2.fl&quot;
+#line 115 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_NE;}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 97 &quot;ast_expr2.fl&quot;
+#line 116 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_PLUS;}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 98 &quot;ast_expr2.fl&quot;
+#line 117 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_MINUS;}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 99 &quot;ast_expr2.fl&quot;
+#line 118 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_MULT;}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 100 &quot;ast_expr2.fl&quot;
+#line 119 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_DIV;}
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 101 &quot;ast_expr2.fl&quot;
+#line 120 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_MOD;}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 102 &quot;ast_expr2.fl&quot;
+#line 121 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_COND;}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 103 &quot;ast_expr2.fl&quot;
+#line 122 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_COMPL;}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 104 &quot;ast_expr2.fl&quot;
+#line 123 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_COLON;}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 105 &quot;ast_expr2.fl&quot;
+#line 124 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_COLONCOLON;}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 106 &quot;ast_expr2.fl&quot;
+#line 125 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_LP;}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 107 &quot;ast_expr2.fl&quot;
+#line 126 &quot;ast_expr2.fl&quot;
 { SET_COLUMNS; SET_STRING; return TOK_RP;}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 108 &quot;ast_expr2.fl&quot;
-{/* gather the contents of ${} expressions, with trailing stuff, into a single TOKEN. They are much more complex now than they used to be */
-                       curlycount = 0; BEGIN(var); yymore();}
+#line 127 &quot;ast_expr2.fl&quot;
+{
+		/* gather the contents of ${} expressions, with trailing stuff,
+		 * into a single TOKEN.
+		 * They are much more complex now than they used to be
+		 */
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 111 &quot;ast_expr2.fl&quot;
+#line 137 &quot;ast_expr2.fl&quot;
 {}
 	YY_BREAK
 case 26:
 /* rule 26 can match eol */
 YY_RULE_SETUP
-#line 112 &quot;ast_expr2.fl&quot;
+#line 138 &quot;ast_expr2.fl&quot;
 {SET_COLUMNS; SET_STRING; return TOKEN;}
 	YY_BREAK
 case 27:
 /* rule 27 can match eol */
 YY_RULE_SETUP
-#line 114 &quot;ast_expr2.fl&quot;
+#line 140 &quot;ast_expr2.fl&quot;
 {/* what to do with eol */}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 115 &quot;ast_expr2.fl&quot;
-{   SET_COLUMNS;  /* the original behavior of the expression parser was to bring in numbers as a numeric string */
-				SET_NUMERIC_STRING;
-				return TOKEN;}
+#line 141 &quot;ast_expr2.fl&quot;
+{
+		SET_COLUMNS;
+		/* the original behavior of the expression parser was
+		 * to bring in numbers as a numeric string
+		 */
+		SET_NUMERIC_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 119 &quot;ast_expr2.fl&quot;
-{SET_COLUMNS; SET_STRING; return TOKEN;}
+#line 150 &quot;ast_expr2.fl&quot;
+{
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 30:
 /* rule 30 can match eol */
 YY_RULE_SETUP
-#line 121 &quot;ast_expr2.fl&quot;
-{curlycount--; if(curlycount &lt; 0){ BEGIN(trail);  yymore();} else {  yymore();}}
+#line 157 &quot;ast_expr2.fl&quot;
+{
+		curlycount--;
+		if (curlycount &lt; 0) {
+			BEGIN(trail);
+			yymore();
+		} else {
+			yymore();
+		}
+	}
 	YY_BREAK
 case 31:
 /* rule 31 can match eol */
 YY_RULE_SETUP
-#line 122 &quot;ast_expr2.fl&quot;
-{curlycount++; yymore();  }
+#line 167 &quot;ast_expr2.fl&quot;
+{
+		curlycount++;
+		yymore();
+	}
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 123 &quot;ast_expr2.fl&quot;
-{BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN;}
+#line 173 &quot;ast_expr2.fl&quot;
+{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 33:
 /* rule 33 can match eol */
 YY_RULE_SETUP
-#line 124 &quot;ast_expr2.fl&quot;
-{char c = yytext[yyleng-1]; BEGIN(0); unput(c); SET_COLUMNS; SET_STRING; return TOKEN;}
+#line 180 &quot;ast_expr2.fl&quot;
+{
+		char c = yytext[yyleng-1];
+		BEGIN(0);
+		unput(c);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+	}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 125 &quot;ast_expr2.fl&quot;
-{curlycount = 0; BEGIN(var); yymore();  }
+#line 189 &quot;ast_expr2.fl&quot;
+{
+		curlycount = 0;
+		BEGIN(var);
+		yymore();
+	}
 	YY_BREAK
 case YY_STATE_EOF(trail):
-#line 126 &quot;ast_expr2.fl&quot;
-{BEGIN(0); SET_COLUMNS; SET_STRING; return TOKEN; /*actually, if an expr is only a variable ref, this could happen a LOT */}
+#line 195 &quot;ast_expr2.fl&quot;
+{
+		BEGIN(0);
+		SET_COLUMNS;
+		SET_STRING;
+		return TOKEN;
+		/*actually, if an expr is only a variable ref, this could happen a LOT */
+	}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 128 &quot;ast_expr2.fl&quot;
+#line 203 &quot;ast_expr2.fl&quot;
 ECHO;
 	YY_BREAK
-#line 1882 &quot;ast_expr2f.c&quot;
+#line 1968 &quot;ast_expr2f.c&quot;
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(var):
 	yyterminate();
@@ -2071,7 +2152,7 @@
 
 	else
 		{
-			size_t num_to_read =
+			int num_to_read =
 			YY_CURRENT_BUFFER_LVALUE-&gt;yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read &lt;= 0 )
@@ -2185,7 +2266,7 @@
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
 {
 	register int yy_is_jam;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
 	register char *yy_cp = yyg-&gt;yy_c_buf_p;
 
 	yy_current_state = yy_NUL_trans[yy_current_state];
@@ -2625,16 +2706,16 @@
 
 /** Setup the input buffer state to scan a string. The next call to ast_yylex() will
  * scan from a @e copy of @a str.
- * @param str a NUL-terminated string to scan
+ * @param yystr a NUL-terminated string to scan
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
  *       ast_yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE ast_yy_scan_string (yyconst char * str , yyscan_t yyscanner)
+YY_BUFFER_STATE ast_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
 {
     
-	return ast_yy_scan_bytes(str,strlen(str) ,yyscanner);
+	return ast_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to ast_yylex() will
@@ -2644,7 +2725,7 @@
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE ast_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
+YY_BUFFER_STATE ast_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
 	char *buf;
@@ -2652,15 +2733,15 @@
 	int i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = len + 2;
+	n = _yybytes_len + 2;
 	buf = (char *) ast_yyalloc(n ,yyscanner );
 	if ( ! buf )
 		YY_FATAL_ERROR( &quot;out of dynamic memory in ast_yy_scan_bytes()&quot; );
 
-	for ( i = 0; i &lt; len; ++i )
-		buf[i] = bytes[i];
+	for ( i = 0; i &lt; _yybytes_len; ++i )
+		buf[i] = yybytes[i];
 
-	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
 	b = ast_yy_scan_buffer(buf,n ,yyscanner);
 	if ( ! b )
@@ -2871,21 +2952,51 @@
     yylloc = yylloc_param;
 }
     
+/* User-visible API */
+
+/* ast_yylex_init is special because it creates the scanner itself, so it is
+ * the ONLY reentrant function that doesn't take the scanner as the last argument.
+ * That's why we explicitly handle the declaration, instead of using our macros.
+ */
+
+int ast_yylex_init(yyscan_t* ptr_yy_globals)
+
+{
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+
+    *ptr_yy_globals = (yyscan_t) ast_yyalloc ( sizeof( struct yyguts_t ), NULL );
+
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+
+    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
+    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
+
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
 static int yy_init_globals (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
     /* Initialization is the same as for the non-reentrant scanner.
-       This function is called once per scanner lifetime. */
+     * This function is called from ast_yylex_destroy(), so don't allocate here.
+     */
 
     yyg-&gt;yy_buffer_stack = 0;
     yyg-&gt;yy_buffer_stack_top = 0;
     yyg-&gt;yy_buffer_stack_max = 0;
     yyg-&gt;yy_c_buf_p = (char *) 0;
-    yyg-&gt;yy_init = 1;
+    yyg-&gt;yy_init = 0;
     yyg-&gt;yy_start = 0;
+
     yyg-&gt;yy_start_stack_ptr = 0;
     yyg-&gt;yy_start_stack_depth = 0;
-    yyg-&gt;yy_start_stack = (int *) 0;
+    yyg-&gt;yy_start_stack =  NULL;
 
 /* Defined in main.c */
 #ifdef YY_STDINIT
@@ -2902,33 +3013,6 @@
     return 0;
 }
 
-/* User-visible API */
-
-/* ast_yylex_init is special because it creates the scanner itself, so it is
- * the ONLY reentrant function that doesn't take the scanner as the last argument.
- * That's why we explicitly handle the declaration, instead of using our macros.
- */
-
-int ast_yylex_init(yyscan_t* ptr_yy_globals)
-
-{
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) ast_yyalloc ( sizeof( struct yyguts_t ), NULL );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    memset(*ptr_yy_globals,0,sizeof(struct yyguts_t));
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
 /* ast_yylex_destroy is for both reentrant and non-reentrant scanners. */
 int ast_yylex_destroy  (yyscan_t yyscanner)
 {
@@ -2949,8 +3033,13 @@
         ast_yyfree(yyg-&gt;yy_start_stack ,yyscanner );
         yyg-&gt;yy_start_stack = NULL;
 
+    /* Reset the globals. This is important in a non-reentrant scanner so the next time
+     * ast_yylex() is called, initialization will occur. */
+    yy_init_globals( yyscanner);
+
     /* Destroy the main struct (reentrant only). */
     ast_yyfree ( yyscanner , yyscanner );
+    yyscanner = NULL;
     return 0;
 }
 
@@ -2962,7 +3051,6 @@
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
 {
 	register int i;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	for ( i = 0; i &lt; n; ++i )
 		s1[i] = s2[i];
 }
@@ -2972,7 +3060,6 @@
 static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
 {
 	register int n;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -3004,22 +3091,10 @@
 
 #define YYTABLES_NAME &quot;yytables&quot;
 
-#undef YY_NEW_FILE
-#undef YY_FLUSH_BUFFER
-#undef yy_set_bol
-#undef yy_new_buffer
-#undef yy_set_interactive
-#undef yytext_ptr
-#undef YY_DO_BEFORE_ACTION
+#line 203 &quot;ast_expr2.fl&quot;
 
-#ifdef YY_DECL_IS_OURS
-#undef YY_DECL_IS_OURS
-#undef YY_DECL
-#endif
-#line 128 &quot;ast_expr2.fl&quot;
 
 
-
 /* I'm putting the interface routine to the whole parse here in the flexer input file
    mainly because of all the flexer initialization that has to be done. Shouldn't matter
    where it is, as long as it's somewhere. I didn't want to define a prototype for the

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/asterisk.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -92,7 +92,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 21451 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23229 $&quot;)
 
 #include &quot;asterisk/logger.h&quot;
 #include &quot;asterisk/options.h&quot;
@@ -224,6 +224,13 @@
 char ast_config_AST_CTL[AST_CONFIG_MAX_PATH] = &quot;asterisk.ctl&quot;;
 char ast_config_AST_SYSTEM_NAME[20] = &quot;&quot;;
 
+extern const char *ast_build_hostname;
+extern const char *ast_build_kernel;
+extern const char *ast_build_machine;
+extern const char *ast_build_os;
+extern const char *ast_build_date;
+extern const char *ast_build_user;
+
 static char *_argv[256];
 static int shuttingdown = 0;
 static int restartnow = 0;
@@ -1271,6 +1278,20 @@
 &quot;Usage: show license\n&quot;
 &quot;	Shows the license(s) for this copy of Asterisk.\n&quot;;
 
+static char version_help[] =
+&quot;Usage: show version\n&quot;
+&quot;       Shows Asterisk version information.\n&quot;;
+
+static int handle_version(int fd, int argc, char *argv[])
+{
+	if (argc != 2)
+		return RESULT_SHOWUSAGE;
+	ast_cli(fd, &quot;Asterisk %s built by %s @ %s on a %s running %s on %s\n&quot;,
+		ASTERISK_VERSION, ast_build_user, ast_build_hostname,
+		ast_build_machine, ast_build_os, ast_build_date);
+	return RESULT_SUCCESS;
+}
+
 #if 0
 static int handle_quit(int fd, int argc, char *argv[])
 {
@@ -1431,6 +1452,8 @@
 	  &quot;Show the warranty (if any) for this copy of Asterisk&quot;, show_warranty_help },
 	{ { &quot;show&quot;, &quot;license&quot;, NULL }, show_license,
 	  &quot;Show the license(s) for this copy of Asterisk&quot;, show_license_help },
+	{ { &quot;show&quot;, &quot;version&quot;, NULL }, handle_version, 
+	  &quot;Display version info&quot;, version_help },
 	{ { &quot;!&quot;, NULL }, handle_bang,
 	  &quot;Execute a shell command&quot;, bang_help },
 #if !defined(LOW_MEMORY)

Modified: trunk/build_tools/menuselect-deps.in
===================================================================
--- trunk/build_tools/menuselect-deps.in	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/build_tools/menuselect-deps.in	2006-04-29 02:51:28 UTC (rev 3)
@@ -15,7 +15,6 @@
 OGG=@PBX_LIBogg@
 OSSAUDIO=@PBX_LIBossaudio@
 PGSQL=@PBX_LIBpq@
-PTLIB=@PBX_LIBPWLIB@
 QT=@PBX_QT@
 SQLITE=@PBX_LIBsqlite@
 SSL=@PBX_LIBssl@
@@ -25,3 +24,4 @@
 ZLIB=@PBX_LIBz@
 ZAPTEL=@PBX_LIBtonezone@
 LIBGSM=@PBX_LIBgsm@
+IXJUSER=@PBX_IXJUSER@

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/build_tools/prep_moduledeps	2006-04-29 02:51:28 UTC (rev 3)
@@ -25,7 +25,7 @@
 process_dir channels chan CHANNELS &quot;Channel Drivers&quot;
 process_dir codecs codec CODECS &quot;Codec Translators&quot;
 process_dir formats format FORMATS &quot;Format Interpreters&quot;
-process_dir funcs func FUNCS &quot;Diaplan Functions&quot;
+process_dir funcs func FUNCS &quot;Dialplan Functions&quot;
 process_dir pbx pbx PBX &quot;PBX Modules&quot;
 process_dir res res RES &quot;Resource Modules&quot;
 cat build_tools/cflags.xml

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channel.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -46,7 +46,7 @@
 #endif
 #endif
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22267 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22631 $&quot;)
 
 #include &quot;asterisk/pbx.h&quot;
 #include &quot;asterisk/frame.h&quot;
@@ -313,9 +313,9 @@
 static int ast_check_hangup_locked(struct ast_channel *chan)
 {
 	int res;
-	ast_mutex_lock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
 	res = ast_check_hangup(chan);
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -682,13 +682,13 @@
 		ast_log(LOG_WARNING, &quot;Unable to duplicate frame\n&quot;);
 		return -1;
 	}
-	ast_mutex_lock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
 	prev = NULL;
 	for (cur = chan-&gt;readq; cur; cur = cur-&gt;next) {
 		if ((cur-&gt;frametype == AST_FRAME_CONTROL) &amp;&amp; (cur-&gt;subclass == AST_CONTROL_HANGUP)) {
 			/* Don't bother actually queueing anything after a hangup */
 			ast_frfree(f);
-			ast_mutex_unlock(&amp;chan-&gt;lock);
+			ast_channel_unlock(chan);
 			return 0;
 		}
 		prev = cur;
@@ -702,7 +702,7 @@
 		} else {
 			ast_log(LOG_DEBUG, &quot;Dropping voice to exceptionally long queue on %s\n&quot;, chan-&gt;name);
 			ast_frfree(f);
-			ast_mutex_unlock(&amp;chan-&gt;lock);
+			ast_channel_unlock(chan);
 			return 0;
 		}
 	}
@@ -721,7 +721,7 @@
 	} else if (ast_test_flag(chan, AST_FLAG_BLOCKING)) {
 		pthread_kill(chan-&gt;blocker, SIGURG);
 	}
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 	return 0;
 }
 
@@ -730,9 +730,9 @@
 {
 	struct ast_frame f = { AST_FRAME_CONTROL, AST_CONTROL_HANGUP };
 	/* Yeah, let's not change a lock-critical value without locking */
-	if (!ast_mutex_trylock(&amp;chan-&gt;lock)) {
+	if (!ast_channel_trylock(chan)) {
 		chan-&gt;_softhangup |= AST_SOFTHANGUP_DEV;
-		ast_mutex_unlock(&amp;chan-&gt;lock);
+		ast_channel_unlock(chan);
 	}
 	return ast_queue_frame(chan, &amp;f);
 }
@@ -821,7 +821,8 @@
 			break;
 		}
 		/* exit if chan not found or mutex acquired successfully */
-		done = c == NULL || ast_mutex_trylock(&amp;c-&gt;lock) == 0;
+		/* this is slightly unsafe, as we _should_ hold the lock to access c-&gt;name */
+		done = c == NULL || ast_channel_trylock(c) == 0;
 		if (!done)
 			ast_log(LOG_DEBUG, &quot;Avoiding %s for channel '%p'\n&quot;, msg, c);
 		AST_LIST_UNLOCK(&amp;channels);
@@ -926,8 +927,8 @@
 	AST_LIST_REMOVE(&amp;channels, chan, chan_list);
 	/* Lock and unlock the channel just to be sure nobody
 	   has it locked still */
-	ast_mutex_lock(&amp;chan-&gt;lock);
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
+	ast_channel_unlock(chan);
 	if (chan-&gt;tech_pvt) {
 		ast_log(LOG_WARNING, &quot;Channel '%s' may not have been hung up properly\n&quot;, chan-&gt;name);
 		free(chan-&gt;tech_pvt);
@@ -1241,9 +1242,9 @@
 int ast_softhangup(struct ast_channel *chan, int cause)
 {
 	int res;
-	ast_mutex_lock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
 	res = ast_softhangup_nolock(chan, cause);
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -1474,7 +1475,7 @@
 	ast_channel_lock(chan);
 	/* Stop if we're a zombie or need a soft hangup */
 	if (ast_test_flag(chan, AST_FLAG_ZOMBIE) || ast_check_hangup(chan)) {
-		ast_mutex_unlock(&amp;chan-&gt;lock);
+		ast_channel_unlock(chan);
 		return -1;
 	}
 	switch(chan-&gt;_state) {
@@ -1497,7 +1498,7 @@
 
 void ast_deactivate_generator(struct ast_channel *chan)
 {
-	ast_mutex_lock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
 	if (chan-&gt;generatordata) {
 		if (chan-&gt;generator &amp;&amp; chan-&gt;generator-&gt;release)
 			chan-&gt;generator-&gt;release(chan, chan-&gt;generatordata);
@@ -1507,7 +1508,7 @@
 		ast_clear_flag(chan, AST_FLAG_WRITE_INT);
 		ast_settimeout(chan, 0, NULL, NULL);
 	}
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 }
 
 static int generator_force(void *data)
@@ -2054,7 +2055,7 @@
 	chan-&gt;fin = FRAMECOUNT_INC(chan-&gt;fin);
 
 done:
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 	return f;
 }
 
@@ -2625,11 +2626,11 @@
 	   return anyway.  */
 	int res = -1;
 	/* Stop if we're a zombie or need a soft hangup */
-	ast_mutex_lock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
 	if (!ast_test_flag(chan, AST_FLAG_ZOMBIE) &amp;&amp; !ast_check_hangup(chan))
 		if (chan-&gt;tech-&gt;call)
 			res = chan-&gt;tech-&gt;call(chan, addr, timeout);
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -2645,7 +2646,7 @@
 	int res = -1;
 
 	/* Stop if we're a zombie or need a soft hangup */
-	ast_mutex_lock(&amp;chan-&gt;lock);
+	ast_channel_lock(chan);
 	if (!ast_test_flag(chan, AST_FLAG_ZOMBIE) &amp;&amp; !ast_check_hangup(chan)) {
 		if (chan-&gt;tech-&gt;transfer) {
 			res = chan-&gt;tech-&gt;transfer(chan, dest);
@@ -2654,7 +2655,7 @@
 		} else
 			res = 0;
 	}
-	ast_mutex_unlock(&amp;chan-&gt;lock);
+	ast_channel_unlock(chan);
 	return res;
 }
 
@@ -2786,11 +2787,11 @@
 		ast_log(LOG_WARNING, &quot;Can't masquerade channel '%s' into itself!\n&quot;, original-&gt;name);
 		return -1;
 	}
-	ast_mutex_lock(&amp;original-&gt;lock);
-	while(ast_mutex_trylock(&amp;clone-&gt;lock)) {
-		ast_mutex_unlock(&amp;original-&gt;lock);
+	ast_channel_lock(original);
+	while(ast_channel_trylock(clone)) {
+		ast_channel_unlock(original);
 		usleep(1);
-		ast_mutex_lock(&amp;original-&gt;lock);
+		ast_channel_lock(original);
 	}
 	ast_log(LOG_DEBUG, &quot;Planning to masquerade channel %s into the structure of %s\n&quot;,
 		clone-&gt;name, original-&gt;name);
@@ -2808,8 +2809,8 @@
 		ast_log(LOG_DEBUG, &quot;Done planning to masquerade channel %s into the structure of %s\n&quot;, clone-&gt;name, original-&gt;name);
 		res = 0;
 	}
-	ast_mutex_unlock(&amp;clone-&gt;lock);
-	ast_mutex_unlock(&amp;original-&gt;lock);
+	ast_channel_unlock(clone);
+	ast_channel_unlock(original);
 	return res;
 }
 

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channels/chan_sip.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -105,7 +105,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22267 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23178 $&quot;)
 
 #include &quot;asterisk/lock.h&quot;
 #include &quot;asterisk/channel.h&quot;
@@ -8384,6 +8384,7 @@
 		ast_cli(fd,&quot;\n&quot;);
 		ASTOBJ_UNREF(peer,sip_destroy_peer);
 	} else  if (peer &amp;&amp; type == 1) { /* manager listing */
+		char buf[256];
 		astman_append(s, &quot;Channeltype: SIP\r\n&quot;);
 		astman_append(s, &quot;ObjectName: %s\r\n&quot;, peer-&gt;name);
 		astman_append(s, &quot;ChanObjectType: peer\r\n&quot;);
@@ -8400,9 +8401,9 @@
 		if (!ast_strlen_zero(peer-&gt;fromdomain))
 			astman_append(s, &quot;SIP-FromDomain: %s\r\n&quot;, peer-&gt;fromdomain);
 		astman_append(s, &quot;Callgroup: &quot;);
-		print_group(fd, peer-&gt;callgroup, 1);
+		astman_append(s, &quot;%s\r\n&quot;, ast_print_group(buf, sizeof(buf), peer-&gt;callgroup));
 		astman_append(s, &quot;Pickupgroup: &quot;);
-		print_group(fd, peer-&gt;pickupgroup, 1);
+		astman_append(s, &quot;%s\r\n&quot;, ast_print_group(buf, sizeof(buf), peer-&gt;pickupgroup));
 		astman_append(s, &quot;VoiceMailbox: %s\r\n&quot;, peer-&gt;mailbox);
 		astman_append(s, &quot;TransferMode: %s\r\n&quot;, transfermode2str(peer-&gt;allowtransfer));
 		astman_append(s, &quot;LastMsgsSent: %d\r\n&quot;, peer-&gt;lastmsgssent);

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channels/chan_zap.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -77,7 +77,7 @@
 #include &lt;libmfcr2.h&gt;
 #endif
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22267 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22932 $&quot;)
 
 #include &quot;asterisk/lock.h&quot;
 #include &quot;asterisk/channel.h&quot;
@@ -386,7 +386,7 @@
 	return j;
 }
 
-/*! Chunk size to read -- we use 20ms chunks to make things happy.  */   
+/*! Chunk size to read -- we use 20ms chunks to make things happy.  */
 #define READ_SIZE 160
 
 #define MASK_AVAIL		(1 &lt;&lt; 0)	/*!&lt; Channel available for PRI use */
@@ -9315,7 +9315,7 @@
 					ast_log(LOG_WARNING, &quot;Received SETUP_ACKNOWLEDGE on unconfigured channel %d/%d span %d\n&quot;, 
 						PRI_SPAN(e-&gt;setup_ack.channel), PRI_CHANNEL(e-&gt;setup_ack.channel), pri-&gt;span);
 				} else {
-					chanpos = pri_fixup_principle(pri, chanpos, e-&gt;ring.call);
+					chanpos = pri_fixup_principle(pri, chanpos, e-&gt;setup_ack.call);
 					if (chanpos &gt; -1) {
 						ast_mutex_lock(&amp;pri-&gt;pvts[chanpos]-&gt;lock);
 						pri-&gt;pvts[chanpos]-&gt;setup_ack = 1;
@@ -9844,6 +9844,47 @@
 	return RESULT_FAILURE;
 }
 
+static int setup_zap(int reload);
+static int zap_restart(void)
+{
+	if (option_verbose &gt; 0)
+		ast_verbose(VERBOSE_PREFIX_1 &quot;Destroying channels and reloading zaptel configuration.\n&quot;);
+	while (iflist) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, &quot;Destroying zaptel channel no. %d\n&quot;, iflist-&gt;channel);
+		/* Also updates iflist: */
+		destroy_channel(NULL, iflist, 1);
+	}
+	if (option_debug)
+		ast_log(LOG_DEBUG, &quot;Channels destroyed. Now re-reading config.\n&quot;);
+	if (setup_zap(0) != 0) {
+		ast_log(LOG_WARNING, &quot;Reload channels from zap config failed!\n&quot;);
+		return 1;
+	}
+	return 0;
+}
+
+static int zap_restart_cmd(int fd, int argc, char **argv)
+{
+	if (argc != 2) {
+		return RESULT_SHOWUSAGE;
+	}
+
+	if (zap_restart() != 0)
+		return RESULT_FAILURE;
+	return RESULT_SUCCESS;
+}
+
+static int action_zaprestart(struct mansession *s, struct message *m)
+{
+	if (zap_restart() != 0) {
+		astman_send_error(s, m, &quot;Failed rereading zaptel configuration&quot;);
+		return 1;
+	}
+	astman_send_ack(s, m, &quot;ZapRestart: Success&quot;);
+	return 0;
+}
+
 static int zap_show_channels(int fd, int argc, char **argv)
 {
 #define FORMAT &quot;%7s %-10.10s %-15.15s %-10.10s %-20.20s\n&quot;
@@ -10153,6 +10194,13 @@
 	&quot;Usage: zap destroy channel &lt;chan num&gt;\n&quot;
 	&quot;	DON'T USE THIS UNLESS YOU KNOW WHAT YOU ARE DOING.  Immediately removes a given channel, whether it is in use or not\n&quot;;
 
+static char zap_restart_usage[] =
+	&quot;Usage: zap restart\n&quot;
+	&quot;	Restarts the zaptel channels: destroys them all and then\n&quot;
+	&quot;	re-reads them from zapata.conf.\n&quot;
+	&quot;	Note that this will STOP any running CALL on zaptel channels.\n&quot;
+	&quot;&quot;;
+
 static struct ast_cli_entry zap_cli[] = {
 	{ { &quot;zap&quot;, &quot;show&quot;, &quot;cadences&quot;, NULL }, handle_zap_show_cadences,
 	  &quot;List cadences&quot;, zap_show_cadences_help },
@@ -10162,6 +10210,8 @@
 	  &quot;Show information on a channel&quot;, show_channel_usage },
 	{ {&quot;zap&quot;, &quot;destroy&quot;, &quot;channel&quot;, NULL}, zap_destroy_channel,
 	  &quot;Destroy a channel&quot;, destroy_channel_usage },
+	{ {&quot;zap&quot;, &quot;restart&quot;, NULL}, zap_restart_cmd,
+	  &quot;Fully restart zaptel channels&quot;, zap_restart_usage },
 	{ {&quot;zap&quot;, &quot;show&quot;, &quot;status&quot;, NULL}, zap_show_status,
 	  &quot;Show all Zaptel cards status&quot;, zap_show_status_usage },
 };
@@ -11332,6 +11382,7 @@
 	ast_manager_register( &quot;ZapDNDon&quot;, 0, action_zapdndon, &quot;Toggle Zap channel Do Not Disturb status ON&quot; );
 	ast_manager_register( &quot;ZapDNDoff&quot;, 0, action_zapdndoff, &quot;Toggle Zap channel Do Not Disturb status OFF&quot; );
 	ast_manager_register(&quot;ZapShowChannels&quot;, 0, action_zapshowchannels, &quot;Show status zapata channels&quot;);
+	ast_manager_register(&quot;ZapRestart&quot;, 0, action_zaprestart, &quot;Fully Restart zaptel channels (terminates calls)&quot;);
 
 	return res;
 }

Modified: trunk/channels/misdn_config.c
===================================================================
--- trunk/channels/misdn_config.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/channels/misdn_config.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -121,7 +121,7 @@
 static const struct misdn_cfg_spec gen_spec[] = {
 	{ &quot;debug&quot;, MISDN_GEN_DEBUG, MISDN_CTYPE_INT, &quot;0&quot;, NONE },
 	{ &quot;misdn_init&quot;, MISDN_GEN_MISDN_INIT, MISDN_CTYPE_STR, &quot;/etc/misdn-init.conf&quot;, NONE },
-	{ &quot;tracefile&quot;, MISDN_GEN_TRACEFILE, MISDN_CTYPE_STR, &quot;/var/log/misdn.trace&quot;, NONE },
+	{ &quot;tracefile&quot;, MISDN_GEN_TRACEFILE, MISDN_CTYPE_STR, &quot;/var/log/asterisk/misdn.log&quot;, NONE },
 	{ &quot;bridging&quot;, MISDN_GEN_BRIDGING, MISDN_CTYPE_BOOL, &quot;yes&quot;, NONE },
 	{ &quot;stop_tone_after_first_digit&quot;, MISDN_GEN_STOP_TONE, MISDN_CTYPE_BOOL, &quot;yes&quot;, NONE },
 	{ &quot;append_digits2exten&quot;, MISDN_GEN_APPEND_DIGITS2EXTEN, MISDN_CTYPE_BOOL, &quot;yes&quot;, NONE },

Modified: trunk/cli.c
===================================================================
--- trunk/cli.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/cli.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -34,7 +34,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 21933 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 23229 $&quot;)
 
 #include &quot;asterisk/logger.h&quot;
 #include &quot;asterisk/options.h&quot;
@@ -51,15 +51,7 @@
 /* For rl_filename_completion */
 #include &quot;editline/readline/readline.h&quot;
 /* For module directory */
-#include &quot;asterisk/version.h&quot;
 
-extern const char *ast_build_hostname;
-extern const char *ast_build_kernel;
-extern const char *ast_build_machine;
-extern const char *ast_build_os;
-extern const char *ast_build_date;
-extern const char *ast_build_user;
-
 extern unsigned long global_fin, global_fout;
 	
 void ast_cli(int fd, char *fmt, ...)
@@ -292,10 +284,6 @@
 &quot;Usage: show modules [like keyword]\n&quot;
 &quot;       Shows Asterisk modules currently in use, and usage statistics.\n&quot;;
 
-static char version_help[] =
-&quot;Usage: show version\n&quot;
-&quot;       Shows Asterisk version information.\n&quot;;
-
 static char uptime_help[] =
 &quot;Usage: show uptime [seconds]\n&quot;
 &quot;       Shows Asterisk uptime information.\n&quot;
@@ -390,16 +378,6 @@
 #undef MODLIST_FORMAT
 #undef MODLIST_FORMAT2
 
-static int handle_version(int fd, int argc, char *argv[])
-{
-	if (argc != 2)
-		return RESULT_SHOWUSAGE;
-	ast_cli(fd, &quot;Asterisk %s built by %s @ %s on a %s running %s on %s\n&quot;,
-		ASTERISK_VERSION, ast_build_user, ast_build_hostname,
-		ast_build_machine, ast_build_os, ast_build_date);
-	return RESULT_SUCCESS;
-}
-
 static int handle_chanlist(int fd, int argc, char *argv[])
 {
 #define FORMAT_STRING  &quot;%-20.20s %-20.20s %-7.7s %-30.30s\n&quot;
@@ -941,7 +919,6 @@
 	{ { &quot;show&quot;, &quot;modules&quot;, NULL }, handle_modlist, &quot;List modules and info&quot;, modlist_help },
 	{ { &quot;show&quot;, &quot;modules&quot;, &quot;like&quot;, NULL }, handle_modlist, &quot;List modules and info&quot;, modlist_help, complete_mod_4 },
  	{ { &quot;show&quot;, &quot;uptime&quot;, NULL }, handle_showuptime, &quot;Show uptime information&quot;, uptime_help },
-	{ { &quot;show&quot;, &quot;version&quot;, NULL }, handle_version, &quot;Display version info&quot;, version_help },
 	{ { &quot;soft&quot;, &quot;hangup&quot;, NULL }, handle_softhangup, &quot;Request a hangup on a given channel&quot;, softhangup_help, complete_ch_3 },
 	{ { &quot;unload&quot;, NULL }, handle_unload, &quot;Unload a dynamic module by name&quot;, unload_help, complete_fn },
 	{ { NULL }, NULL, NULL, NULL }

Modified: trunk/configs/mgcp.conf.sample
===================================================================
--- trunk/configs/mgcp.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/mgcp.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -27,8 +27,8 @@
 ;context=local 
 ;host=192.168.1.20 
 ;callerid = &quot;John Doe&quot; &lt;123&gt; 
-;callgroup=0 
-;pickupgroup=0
+;callgroup=0      ; in the range from 0 to 63
+;pickupgroup=0    ; in the range from 0 to 63
 ;nat=no 
 ;threewaycalling=yes 
 ;transfer=yes     ; transfer requires threewaycalling=yes. Use FLASH to transfer

Modified: trunk/configs/misdn.conf.sample
===================================================================
--- trunk/configs/misdn.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/misdn.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -29,7 +29,7 @@
 ;
 ; default value: [not set]
 ;
-;tracefile=/var/log/misdn.trace
+;tracefile=/var/log/asterisk/misdn.log
 
 
 ; set to yes if you want mISDN_dsp to bridge the calls in HW
@@ -233,6 +233,7 @@
 ; Pickup and Callgroup
 ;
 ; deafult values: not set = 0
+; range: 0-63
 ;
 ;callgroup=1
 ;pickupgroup=1

Modified: trunk/configs/sip.conf.sample
===================================================================
--- trunk/configs/sip.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/sip.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -473,6 +473,9 @@
 ;qualify=1000			; Consider it down if it's 1 second to reply
 				; Helps with NAT session
 				; qualify=yes uses default value
+;
+; Call group and Pickup group should be in the range from 0 to 63
+;
 ;callgroup=1,3-4		; We are in caller groups 1,3,4
 ;pickupgroup=1,3-5		; We can do call pick-p for call group 1,3,4,5
 ;defaultip=192.168.0.60		; IP address to use if peer has not registred

Modified: trunk/configs/zapata.conf.sample
===================================================================
--- trunk/configs/zapata.conf.sample	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configs/zapata.conf.sample	2006-04-29 02:51:28 UTC (rev 3)
@@ -354,7 +354,7 @@
 ; Ring groups (a.k.a. call groups) and pickup groups.  If a phone is ringing
 ; and it is a member of a group which is one of your pickup groups, then
 ; you can answer it by picking up and dialing *8#.  For simple offices, just
-; make these both the same
+; make these both the same.  Groups range from 0 to 63.
 ;
 callgroup=1
 pickupgroup=1

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/configure.ac	2006-04-29 02:51:28 UTC (rev 3)
@@ -20,7 +20,7 @@
 AC_CONFIG_HEADER(include/autoconfig.h)
 
 AC_COPYRIGHT(&quot;Asterisk&quot;)
-AC_REVISION($Revision: 22346 $)
+AC_REVISION($Revision: 22990 $)
 
 AC_PREFIX_DEFAULT()
 
@@ -160,7 +160,7 @@
 AST_EXT_LIB([asound], [snd_spcm_init], [alsa/asoundlib.h], [ALSA], [Advanced Linux Sound Architecture], [-lm -ldl])
 AST_EXT_LIB([curses], [initscr], [curses.h], [CURSES], [curses], [])
 AST_EXT_LIB([mfcr2], [mfcr2_MakeCall], [libmfcr2.h], [MFCR2], [MFCR2])
-AST_EXT_LIB([nbs], [nbs_setup], [nbs.h], [NBS], [Network Broadcast Sound])
+AST_EXT_LIB([nbs], [nbs_connect], [nbs.h], [NBS], [Network Broadcast Sound])
 AST_EXT_LIB([ncurses], [initscr], [curses.h], [NCURSES], [ncurses], [])
 AST_EXT_LIB([newt], [newtBell], [newt.h], [NEWT], [newt])
 AST_EXT_LIB([odbc], [SQLConnect], [sql.h], [UNIXODBC], [unixODBC])
@@ -302,9 +302,11 @@
 AC_CHECK_HEADER([h323.h], [PBX_H323=1], [])
 AC_SUBST(PBX_H323)
 
-HAVE_QUICKNET=0
-AC_CHECK_HEADER([ixjuser.h], [HAVE_QUICKNET=1],[])
-AC_SUBST(HAVE_QUICKNET)
+PBX_IXJUSER=0
+AC_CHECK_HEADER([linux/ixjuser.h], [
+   AC_CHECK_HEADER([linux/telephony.h], [
+      AC_CHECK_HEADER([linux/version.h], [PBX_IXJUSER=1])])])
+AC_SUBST(PBX_IXJUSER)
 
 AC_ARG_WITH([vpb], AC_HELP_STRING([--with-vpb=PATH],[use vpb files in PATH]),[
 case ${withval} in

Modified: trunk/http.c
===================================================================
--- trunk/http.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/http.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -45,7 +45,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 20330 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22933 $&quot;)
 
 #include &quot;asterisk/cli.h&quot;
 #include &quot;asterisk/http.h&quot;
@@ -493,9 +493,6 @@
 				close(ser-&gt;fd);
 				free(ser);
 			}
-		} else {
-			close(ser-&gt;fd);
-			free(ser);
 		}
 	}
 	return NULL;

Modified: trunk/include/asterisk/ael_structs.h
===================================================================
--- trunk/include/asterisk/ael_structs.h	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/include/asterisk/ael_structs.h	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,3 +1,6 @@
+#ifndef _ASTERISK_AEL_STRUCTS_H
+#define _ASTERISK_AEL_STRUCTS_H
+
 #if !defined(SOLARIS) &amp;&amp; !defined(__CYGWIN__)
 #include &lt;err.h&gt;
 #else
@@ -113,6 +116,7 @@
 
 typedef struct pval pval;
 
+#if 0
 pval *npval(pvaltype type, int first_line, int last_line, int first_column, int last_column);
 void linku1(pval *head, pval *tail);
 void print_pval_list(FILE *f, pval *item, int depth);
@@ -122,9 +126,13 @@
 struct pval *find_label_in_current_extension(char *label);
 int count_labels_in_current_context(char *label);
 struct pval *find_label_in_current_db(char *context, char *exten, char *label);
-struct pval *ael2_parse(char *fname, int *errs);
+void ael2_print(char *fname, pval *tree);
+#endif
+struct pval *ael2_parse(char *fname, int *errs);	/* in ael.flex */
 void destroy_pval(pval *item);
-void ael2_print(char *fname, pval *tree);
+
+extern char *prev_word;	/* in ael.flex */
+
 #ifndef YY_TYPEDEF_YY_SCANNER_T
 #define YY_TYPEDEF_YY_SCANNER_T
 typedef void* yyscan_t;
@@ -175,4 +183,4 @@
 	int return_needed;
 };
 
-
+#endif /* _ASTERISK_AEL_STRUCTS_H */

Modified: trunk/pbx/ael/ael-test/runtests
===================================================================
--- trunk/pbx/ael/ael-test/runtests	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael-test/runtests	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,14 +1,24 @@
 #!/bin/bash
+ORIG=`mktemp /tmp/mytest.XXXXXX`
+NEW=`mktemp /tmp/mytest.XXXXXX`
 
+do_filter() {
+	sed 's/line:[0-9]*//; /^Executed.*/d; s/column=[0-9]*/ /; s/Cols: [0-9]*-[0-9]*/___/'
+}
+
 for i in ael-test*; do
 	echo -n Test: $i..................
 	(cd $i; ../../../../utils/aelparse -n -d | grep -v -i 'seconds' &gt; ../res.$i)
-	if (diff -q res.$i ref.$i &gt; /dev/null 2&gt;&amp;1 ) then
+	do_filter &lt; res.$i &gt; $NEW
+	do_filter &lt; ref.$i &gt; $ORIG
+	if (diff -q $NEW $ORIG &gt; /dev/null 2&gt;&amp;1 ) then
 		echo PASSED
 		rm res.$i
 	else
 		echo %%%%%%FAILED%%%%%%
-		diff -u ref.$i res.$i
+		# diff -u ref.$i res.$i
+		diff -u $ORIG $NEW
 	fi
 
 done
+rm $NEW $ORIG

Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.flex	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,4 +1,3 @@
-%{
 /*
  * Asterisk -- An open source telephony toolkit.
  *
@@ -19,8 +18,45 @@
 /*! \file
  *
  * \brief Flex scanner description of tokens used in AEL2 .
- * 
- */#include &lt;sys/types.h&gt;
+ *
+ */
+
+/*
+ * Start with flex options:
+ *
+ * %x describes the contexts we have: paren, semic and argg, plus INITIAL
+ */
+%x paren semic argg
+
+/* prefix used for various globally-visible functions and variables.
+ * This renames also yywrap, but since we do not use it, we just
+ * add option noyywrap to remove it.
+ */
+%option prefix=&quot;ael_yy&quot;
+%option noyywrap
+
+/* batch gives a bit more performance if we are using it in
+ * a non-interactive mode. We probably don't care much.
+ */
+%option batch
+
+/* outfile is the filename to be used instead of lex.yy.c */
+%option outfile=&quot;ael_lex.c&quot;
+
+/*
+ * These are not supported in flex 2.5.4, but we need them
+ * at the moment:
+ * reentrant produces a thread-safe parser. Not 100% sure that
+ * we require it, though.
+ * bison-bridge passes an additional yylval argument to yylex().
+ * bison-locations is probably not needed.
+ */
+%option reentrant
+%option bison-bridge
+%option bison-locations
+
+%{
+#include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;unistd.h&gt;
 
@@ -29,475 +65,391 @@
 #include &quot;ael/ael.tab.h&quot;
 #include &quot;asterisk/ael_structs.h&quot;
 
-static char pbcstack[400];
+/*
+ * A stack to keep track of matching brackets ( [ { } ] )
+ */
+static char pbcstack[400];	/* XXX missing size checks */
 static int pbcpos = 0;
 
 static int parencount = 0;
 static int commaout = 0;
-int my_lineno = 1;
-int my_col = 0;
-char *my_file = 0;
-char *prev_word;
+
+/*
+ * current line, column and filename, updated as we read the input.
+ */
+static int my_lineno = 1;	/* current line in the source */
+static int my_col = 1;		/* current column in the source */
+char *my_file = 0;		/* used also in the bison code */
+char *prev_word;		/* XXX document it */
+
 #define MAX_INCLUDE_DEPTH 50
 
-void reset_parencount(yyscan_t yyscanner );
-void reset_semicount(yyscan_t yyscanner );
-void reset_argcount(yyscan_t yyscanner );
-struct pval *ael2_parse(char *filename, int *errors);
+/*
+ * flex is not too smart, and generates global functions
+ * without prototypes so the compiler may complain.
+ * To avoid that, we declare the prototypes here,
+ * even though these functions are not used.
+ */
 int ael_yyget_column  (yyscan_t yyscanner);
 void ael_yyset_column (int  column_no , yyscan_t yyscanner);
+
 int ael_yyparse (struct parse_io *);
 static void pbcpush(char x);
 static int pbcpop(char x);
-static void pbcwhere(char *text, int *line, int *col );
-static int c_prevword(void);
 
-struct stackelement
-{
-     char *fname;
-	 int lineno;
-     int colno;
-	 YY_BUFFER_STATE bufstate;
+/*
+ * A stack to process include files.
+ * As we switch into the new file we need to store the previous
+ * state to restore it later.
+ */
+struct stackelement {
+	char *fname;
+	int lineno;
+	int colno;
+	YY_BUFFER_STATE bufstate;
 };
-struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
-int include_stack_index = 0;
 
+static struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
+static int include_stack_index = 0;
+
+/*
+ * if we use the @n feature of bison, we must supply the start/end
+ * location of tokens in the structure pointed by yylloc.
+ * Simple tokens are just assumed to be on the same line, so
+ * the line number is constant, and the column is incremented
+ * by the length of the token.
+ */
+#ifdef FLEX_BETA	/* set for 2.5.33 */
+
+/* compute the total number of lines and columns in the text
+ * passed as argument.
+ */
+static void pbcwhere(const char *text, int *line, int *col )
+{
+	int loc_line = *line;
+	int loc_col = *col;
+	char c;
+	while ( (c = *text++) ) {
+		if ( c == '\t' ) {
+			loc_col += 8 - (loc_col % 8);
+		} else if ( c == '\n' ) {
+			loc_line++;
+			loc_col = 1;
+		} else
+			loc_col++;
+	}
+	*line = loc_line;
+	*col = loc_col;
+}
+
+#define	STORE_POS do {							\
+		yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno;	\
+		yylloc-&gt;first_column=my_col;				\
+		yylloc-&gt;last_column=my_col+yyleng-1;			\
+		my_col+=yyleng;						\
+	} while (0)
+
+#define	STORE_LOC do {					\
+		yylloc-&gt;first_line = my_lineno;		\
+		yylloc-&gt;first_column=my_col;		\
+		pbcwhere(yytext, &amp;my_lineno, &amp;my_col);	\
+		yylloc-&gt;last_line = my_lineno;		\
+		yylloc-&gt;last_column = my_col - 1;	\
+	} while (0)
+#else
+#define	STORE_POS
+#define	STORE_LOC
+#endif
 %}
 
-%x paren semic argg
-%option prefix=&quot;ael_yy&quot;
-%option batch
-%option outfile=&quot;ael_lex.c&quot;
-%option reentrant
-%option bison-bridge
-%option bison-locations
-/* %option yylineno I've tried hard, but haven't been able to use this */
-%option noyywrap
 
+NOPARENS	[^()\[\]\{\}]*
+
+NOARGG		[^(),\{\}\[\]]*
+
+NOSEMIC		[^;()\{\}\[\]]*
+
 %%
-\{	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return LC;}
-\}	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return RC;}
-\(	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return LP;}
-\)	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return RP;}
-\;	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return SEMI;}
-\=	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return EQ;}
-\,	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return COMMA;}
-\:	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return COLON;}
-\&amp;	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return AMPER;}
-\|	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return BAR;}
-\=\&gt;	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return EXTENMARK;}
-\@	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return AT;}
-\/\/[^\n]*  {/*comment*/}
-context	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CONTEXT;}
-abstract	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_ABSTRACT;}
-macro	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_MACRO;};
-globals	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_GLOBALS;}
-ignorepat	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_IGNOREPAT;}
-switch	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_SWITCH;}
-if	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_IF;}
-ifTime	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_IFTIME;}
-random	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_RANDOM;}
-regexten	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_REGEXTEN;}
-hint	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_HINT;}
-else	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_ELSE;}
-goto	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_GOTO;}
-jump	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_JUMP;}
-return	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_RETURN;}
-break	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_BREAK;}
-continue	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CONTINUE;}
-for	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_FOR;}
-while	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_WHILE;}
-case	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CASE;}
-default	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_DEFAULT;}
-pattern	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_PATTERN;}
-catch	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CATCH;}
-switches	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_SWITCHES;}
-eswitches	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_ESWITCHES;}
-includes	{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_INCLUDES;}
 
-\n		{my_lineno++;my_col=0;}
-[ ]+	{/* nothing */ my_col+=yyleng;}
-[	]+	{/* nothing */ int wid = 8-(my_col%8); my_col+=wid;}
+\{		{ STORE_POS; return LC;}
+\}		{ STORE_POS; return RC;}
+\(		{ STORE_POS; return LP;}
+\)		{ STORE_POS; return RP;}
+\;		{ STORE_POS; return SEMI;}
+\=		{ STORE_POS; return EQ;}
+\,		{ STORE_POS; return COMMA;}
+\:		{ STORE_POS; return COLON;}
+\&amp;		{ STORE_POS; return AMPER;}
+\|		{ STORE_POS; return BAR;}
+\=\&gt;		{ STORE_POS; return EXTENMARK;}
+\@		{ STORE_POS; return AT;}
+\/\/[^\n]*	{/*comment*/}
+context		{ STORE_POS; return KW_CONTEXT;}
+abstract	{ STORE_POS; return KW_ABSTRACT;}
+macro		{ STORE_POS; return KW_MACRO;};
+globals		{ STORE_POS; return KW_GLOBALS;}
+ignorepat	{ STORE_POS; return KW_IGNOREPAT;}
+switch		{ STORE_POS; return KW_SWITCH;}
+if		{ STORE_POS; return KW_IF;}
+ifTime		{ STORE_POS; return KW_IFTIME;}
+random		{ STORE_POS; return KW_RANDOM;}
+regexten	{ STORE_POS; return KW_REGEXTEN;}
+hint		{ STORE_POS; return KW_HINT;}
+else		{ STORE_POS; return KW_ELSE;}
+goto		{ STORE_POS; return KW_GOTO;}
+jump		{ STORE_POS; return KW_JUMP;}
+return		{ STORE_POS; return KW_RETURN;}
+break		{ STORE_POS; return KW_BREAK;}
+continue	{ STORE_POS; return KW_CONTINUE;}
+for		{ STORE_POS; return KW_FOR;}
+while		{ STORE_POS; return KW_WHILE;}
+case		{ STORE_POS; return KW_CASE;}
+default		{ STORE_POS; return KW_DEFAULT;}
+pattern		{ STORE_POS; return KW_PATTERN;}
+catch		{ STORE_POS; return KW_CATCH;}
+switches	{ STORE_POS; return KW_SWITCHES;}
+eswitches	{ STORE_POS; return KW_ESWITCHES;}
+includes	{ STORE_POS; return KW_INCLUDES;}
 
+\n		{ my_lineno++; my_col = 1; }
+[ ]+		{ my_col += yyleng; }
+[\t]+		{ my_col += (yyleng*8)-(my_col%8); }
+
 [-a-zA-Z0-9'&quot;_/.\&lt;\&gt;\*\+!$#\[\]][-a-zA-Z0-9'&quot;_/.!\*\+\&lt;\&gt;\{\}$#\[\]]*	{
-                                               yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno;yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col; /* set up the ptr */
-                                               yylval-&gt;str = strdup(yytext);  
-                                               /* printf(&quot;\nGot WORD %s[%d][%d:%d]\n&quot;, yylval-&gt;str, my_lineno ,yylloc-&gt;first_column,yylloc-&gt;last_column );  */
-                                               my_col+=yyleng; 
-                                               prev_word = yylval-&gt;str;
-                                               return word;
-                                        }
+		STORE_POS;
+		yylval-&gt;str = strdup(yytext);
+		prev_word = yylval-&gt;str;
+		return word;
+	}
 
-&lt;paren&gt;[^()\[\]\{\}]*\)	{yylloc-&gt;first_line = my_lineno; yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n&quot;, my_file, my_lineno+l4, c4, yytext);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             prev_word = 0;
-                             return word;
-                         }
-                 parencount--;
-                 if ( parencount &gt;= 0) {
-                   yymore();
-                 } else { 
-                   int l4,c4;
-                   pbcwhere(yytext, &amp;l4, &amp;c4);
-                   yylloc-&gt;last_line = my_lineno+l4;
-				   yylloc-&gt;last_column=c4; 
-                   yylval-&gt;str = strdup(yytext); 
-                   *(yylval-&gt;str+strlen(yylval-&gt;str)-1)=0;
-                   /* printf(&quot;Got paren word %s\n&quot;, yylval-&gt;str); */ 
-                   unput(')'); 
-	               my_col=c4;
-                   my_lineno += l4;
-                   BEGIN(0); 
-                   return word;
-                 } 
-                }
 
-&lt;paren&gt;[^()\[\]\{\}]*\(	{yylloc-&gt;first_line = my_lineno; yylloc-&gt;first_column=my_col; 
-                  parencount++; pbcpush('(');
-                  yymore();
-                 }
-&lt;paren&gt;[^()\[\]\{\}]*\[	{yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('['); }
-&lt;paren&gt;[^()\[\]\{\}]*\]	{yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ']' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
-&lt;paren&gt;[^()\[\]\{\}]*\{	{yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col;  yymore(); pbcpush('{'); }
-&lt;paren&gt;[^()\[\]\{\}]*\}	{yylloc-&gt;first_line = my_lineno;
-                         yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '}' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
 
 
-&lt;argg&gt;[^(),\{\}\[\]]*\)	{/* printf(&quot;ARGG:%s\n&quot;,yytext); */
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
+&lt;paren&gt;{NOPARENS}\)	{
+		if ( pbcpop(')') ) {	/* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n&quot;, my_file, my_lineno, my_col, yytext);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			prev_word = 0;
+			return word;
+		}
+		parencount--;
+		if ( parencount &gt;= 0) {
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval-&gt;str = strdup(yytext);
+			*(yylval-&gt;str+strlen(yylval-&gt;str)-1)=0;
+			/* printf(&quot;Got paren word %s\n&quot;, yylval-&gt;str); */
+			unput(')');
+			BEGIN(0);
+			return word;
+		}
+	}
 
-					yylloc-&gt;first_line = my_lineno;
-                    yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                   
+&lt;paren&gt;{NOPARENS}[\(\[\{]	{
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 
-					while (*pt) {
-                       if (*pt == '\n') {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc-&gt;last_line = my_lineno+linecount;
-                    yylloc-&gt;last_column=colcount; 
-                    parencount--;
-                    if( parencount &gt;= 0){ 
-                        yymore(); 
-                    } else { 
-                        yylval-&gt;str = strdup(yytext); 
-					   if(yyleng &gt; 1 ) 
-                              *(yylval-&gt;str+yyleng-1)=0;
-                       /* printf(&quot;Got argg word '%s'\n&quot;, yylval-&gt;str);  */
-                       BEGIN(0); 
-                       if ( !strcmp(yylval-&gt;str,&quot;)&quot;) ) { 
-                             free(yylval-&gt;str); 
-                             yylval-&gt;str = 0; 
-                             my_col+=1;
-                             return RP;  
-                       } else {
-                             unput(')');
-                             my_col=colcount;
-							 my_lineno+=linecount;
-                             return word;
-                       }
-                    } 
-                }
-&lt;argg&gt;[^(),\{\}\[\]]*\(	  { /* printf(&quot;ARGG:%s\n&quot;,yytext); */
-                      /* printf(&quot;GOT AN LP!!!\n&quot;); */
-                      yylloc-&gt;first_line = my_lineno;
-                      yylloc-&gt;first_column=my_col; 
-                      parencount++; 
-                      pbcpush('(');
-                      yymore();
-                  }
+&lt;paren&gt;{NOPARENS}[\]\}]	{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c))  { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n&quot;,
+				my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 
-&lt;argg&gt;[^(),\{\}\[\]]*\,	{  /* printf(&quot;ARGG:%s\n&quot;,yytext); */
-                  if( parencount != 0) { 
-					/* printf(&quot;Folding in a comma!\n&quot;); */ 
-					yymore();
-				  } else  { 
-                     /* printf(&quot;got a comma!\n\n&quot;);  */
-					 int linecount = 0;
-                     int colcount = my_col;
-					 char *pt;
+&lt;argg&gt;{NOARGG}[\(\[\{]	  {
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 
-					 pt = yytext;
-					 while (*pt) {
-                        if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                        }
-                        pt++;
-                        colcount++;
-                     }
-                     yylloc-&gt;first_line = my_lineno; 
-                     yylloc-&gt;last_line = my_lineno+linecount; 
-                     yylloc-&gt;last_column=colcount; 
-                     yylloc-&gt;first_column=my_col;
-                     if( !commaout ) { 
-						if( !strcmp(yytext,&quot;,&quot; ) ) 
-							{commaout = 0; my_col+=1; return COMMA;} 
-						yylval-&gt;str = strdup(yytext); /* printf(&quot;Got argg2 word %s\n&quot;, yylval-&gt;str); */ 
-						unput(','); 
-						commaout = 1; 
-						if(yyleng &gt; 1 ) 
-							*(yylval-&gt;str+yyleng-1)=0;
-                        my_lineno+=linecount;
-						my_col=colcount;
-						return word;
-					 } else {
-                            commaout = 0;
-							my_col+=1;
-							return COMMA;
-						}
-                   }
-				}
+&lt;argg&gt;{NOARGG}\)	{
+		if ( pbcpop(')') ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression!\n&quot;, my_file, my_lineno, my_col);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
 
-&lt;argg&gt;[^(),\{\}\[\]]*\{	{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; pbcpush('{'); yymore();  }
-&lt;argg&gt;[^(),\{\}\[\]]*\}	{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '}' in expression!\n&quot;, my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
+		parencount--;
+		if( parencount &gt;= 0){
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval-&gt;str = strdup(yytext);
+			if(yyleng &gt; 1 )
+				*(yylval-&gt;str+yyleng-1)=0;
+			BEGIN(0);
+			if ( !strcmp(yylval-&gt;str,&quot;)&quot;) ) {
+				free(yylval-&gt;str);
+				yylval-&gt;str = 0;
+				my_col++; /* XXX why ? */
+				return RP;
+			} else {
+				unput(')');
+				return word;
+			}
+		}
+	}
+
+&lt;argg&gt;{NOARGG}\,	{
+		if( parencount != 0) { /* printf(&quot;Folding in a comma!\n&quot;); */
+			yymore();
+		} else  {
+			STORE_LOC;
+			if( !commaout ) {
+				if( !strcmp(yytext,&quot;,&quot; ) ) {
+					commaout = 0;
+					my_col+=1;
+					return COMMA;
 				}
-&lt;argg&gt;[^(),\{\}\[\]]*\[	{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('['); }
-&lt;argg&gt;[^(),\{\}\[\]]*\]	{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ']' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-				}
+				yylval-&gt;str = strdup(yytext);
+				/* printf(&quot;Got argg2 word %s\n&quot;, yylval-&gt;str); */
+				unput(',');
+				commaout = 1;
+				if (yyleng &gt; 1 )
+					*(yylval-&gt;str+yyleng-1)=0;
+				return word;
+			} else {
+				commaout = 0;
+				my_col+=1;
+				return COMMA;
+			}
+		}
+	}
 
+&lt;argg&gt;{NOARGG}[\]\}]	{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n&quot;, my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 
-&lt;semic&gt;[^;()\{\}\[\]]*\[	{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('['); }
-&lt;semic&gt;[^;()\{\}\[\]]*\]	{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ']' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-&lt;semic&gt;[^;()\{\}\[\]]*\{	{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('{');}
-&lt;semic&gt;[^;()\{\}\[\]]*\}	{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '}' in expression!\n&quot;, my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-&lt;semic&gt;[^;()\{\}\[\]]*\(	{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('(');}
-&lt;semic&gt;[^;()\{\}\[\]]*\)	{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression!\n&quot;, my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-&lt;semic&gt;[^;()\{\}\[\]]*;	{
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
-					while (*pt) {
-                       if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc-&gt;first_line = my_lineno; 
-					yylloc-&gt;last_line = my_lineno+linecount; 
-					yylloc-&gt;last_column=colcount; 
-					yylloc-&gt;first_column=my_col;
-                    yylval-&gt;str = strdup(yytext);
-                    if(yyleng &gt; 1)
-                      *(yylval-&gt;str+yyleng-1)=0;
-                    /* printf(&quot;Got semic word %s\n&quot;, yylval-&gt;str); */
-                    unput(';');
-                    BEGIN(0);
-                    my_col=colcount;
-                    my_lineno += linecount;
-                    return word;
-                }
 
-\#include[ \t]+\&quot;[^\&quot;]+\&quot; {
-                     FILE *in1;
-					 char fnamebuf[1024],*p1,*p2;
-                     if ( include_stack_index &gt;= MAX_INCLUDE_DEPTH ) {
-						ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n&quot;, my_file, my_lineno, my_col);
-                     } else {
-                         p1 = strchr(yytext,'&quot;');
-                         p2 = strrchr(yytext,'&quot;');
-                         if ( (int)(p2-p1) &gt; 1023 ) {
-							ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n&quot;, my_file, my_lineno, my_col, yyleng - 10);
-        	             } else {
-								int i;
-								int found = 0;
-								strncpy(fnamebuf,p1,p2-p1);
-								fnamebuf[p2-p1] = 0;
-								for (i=0; i&lt;include_stack_index; i++) {
-									if ( !strcmp(fnamebuf,include_stack[i].fname )) {
-										ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n&quot;, 
-												my_file, my_lineno, my_col, fnamebuf);
-										found=1;
-										break;
-									}
-								}
-								if( !found )
-								{
-                                	*p2 = 0;
-                                    /* relative vs. absolute */
-                                    if ( *(p1+1) != '/' )
-                                    {
-                                        strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
-										strcat(fnamebuf,&quot;/&quot;);
-										strcat(fnamebuf,p1+1);
-                                    }
-                                    else
-                                	    strcpy(fnamebuf,p1+1);
-		                        	in1 = fopen( fnamebuf, &quot;r&quot; );
-                                	if ( ! in1 ) {
-						ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n&quot;, my_file, my_lineno, my_col, fnamebuf);
-                                	} else {
-						char *buffer;
-	                             	 	struct stat stats;
-	                            		stat(fnamebuf, &amp;stats);
-	                             		buffer = (char*)malloc(stats.st_size+1);
-	                             		fread(buffer, 1, stats.st_size, in1);
-						buffer[stats.st_size] = 0;
-						ast_log(LOG_NOTICE,&quot;  --Read in included file %s, %d chars\n&quot;,fnamebuf, (int)stats.st_size);
-	                                	fclose(in1);
 
-						include_stack[include_stack_index].fname = my_file;
-						my_file = strdup(fnamebuf);
-						include_stack[include_stack_index].lineno = my_lineno;
-						include_stack[include_stack_index].colno = my_col+yyleng;
-						include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
+&lt;semic&gt;{NOSEMIC}[\(\[\{]	{
+		char c = yytext[yyleng-1];
+		yymore();
+		pbcpush(c);
+	}
 
-	                                	yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
-                                    		free(buffer);
-                                  	  	my_lineno = 1;
-                                    		my_col = 1;
-                                    		BEGIN(INITIAL);
-                                	}
-                                }
-                         }
-                     }
-                 }
+&lt;semic&gt;{NOSEMIC}[\)\]\}]	{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n&quot;, my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 
-&lt;&lt;EOF&gt;&gt;  {
-                 if ( --include_stack_index &lt; 0 ) {
-                 	    yyterminate();
-                     } else {
-						 free(my_file);
-                         yy_delete_buffer( YY_CURRENT_BUFFER, yyscanner );
-                         yy_switch_to_buffer(include_stack[include_stack_index].bufstate, yyscanner );
-                         my_lineno = include_stack[include_stack_index].lineno;
-                         my_col    = include_stack[include_stack_index].colno;
-                         my_file   = include_stack[include_stack_index].fname;
-                     }
-          }
+&lt;semic&gt;{NOSEMIC};	{
+		STORE_LOC;
+		yylval-&gt;str = strdup(yytext);
+		if(yyleng &gt; 1)
+			*(yylval-&gt;str+yyleng-1)=0;
+		unput(';');
+		BEGIN(0);
+		return word;
+	}
 
+\#include[ \t]+\&quot;[^\&quot;]+\&quot; {
+		FILE *in1;
+		char fnamebuf[1024],*p1,*p2;
+		int error = 1;	/* don't use the file if set */
+		p1 = strchr(yytext,'&quot;');
+		p2 = strrchr(yytext,'&quot;');
+		if ( include_stack_index &gt;= MAX_INCLUDE_DEPTH ) {
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n&quot;, my_file, my_lineno, my_col);
+		} else if ( (int)(p2-p1) &gt; sizeof(fnamebuf) - 1 ) {
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n&quot;, my_file, my_lineno, my_col, yyleng - 10);
+		} else {
+			int i;
+			strncpy(fnamebuf, p1, p2-p1);
+			fnamebuf[p2-p1] = 0;
+			for (i=0; i&lt;include_stack_index; i++) {
+				if ( !strcmp(fnamebuf,include_stack[i].fname )) {
+					ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n&quot;,
+						my_file, my_lineno, my_col, fnamebuf);
+					break;
+				}
+			}
+			if (i == include_stack_index)
+				error = 0;	/* we can use this file */
+		}
+		if ( !error ) {	/* valid file name */
+			*p2 = 0;
+			/* relative vs. absolute */
+			if ( *(p1+1) != '/' ) {
+				/* XXX must check overflows */
+				strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
+				strcat(fnamebuf,&quot;/&quot;);
+				strcat(fnamebuf,p1+1);
+			} else
+				strcpy(fnamebuf,p1+1);
+			in1 = fopen( fnamebuf, &quot;r&quot; );
+			if ( ! in1 ) {
+				ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n&quot;, my_file, my_lineno, my_col, fnamebuf);
+			} else {
+				char *buffer;
+				struct stat stats;
+				stat(fnamebuf, &amp;stats);
+				buffer = (char*)malloc(stats.st_size+1);
+				fread(buffer, 1, stats.st_size, in1);
+				buffer[stats.st_size] = 0;
+				ast_log(LOG_NOTICE,&quot;  --Read in included file %s, %d chars\n&quot;,fnamebuf, (int)stats.st_size);
+				fclose(in1);
 
+				include_stack[include_stack_index].fname = my_file;
+				my_file = strdup(fnamebuf);
+				include_stack[include_stack_index].lineno = my_lineno;
+				include_stack[include_stack_index].colno = my_col+yyleng;
+				include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
+
+				yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
+				free(buffer);
+				my_lineno = 1;
+				my_col = 1;
+				BEGIN(INITIAL);
+			}
+		}
+	}
+
+&lt;&lt;EOF&gt;&gt;		{
+		if ( --include_stack_index &lt; 0 ) {
+			yyterminate();
+		} else {
+			free(my_file);
+			yy_delete_buffer( YY_CURRENT_BUFFER, yyscanner );
+			yy_switch_to_buffer(include_stack[include_stack_index].bufstate, yyscanner );
+			my_lineno = include_stack[include_stack_index].lineno;
+			my_col    = include_stack[include_stack_index].colno;
+			my_file   = include_stack[include_stack_index].fname;
+		}
+	}
+
 %%
 
 static void pbcpush(char x)
@@ -513,47 +465,36 @@
 		pbcpos--;
 		return 0;
 	}
-	else
-		return 1; /* error */
+	return 1; /* error */
 }
 
 static int c_prevword(void)
 {
-    char *c = prev_word;
-	int ret = 0;
-	while ( c &amp;&amp; *c ) {
-        switch (*c) {
-            case '{': pbcpush('{');break;
-            case '}': ret = pbcpop('}');break;
-            case '[':pbcpush('[');break;
-            case ']':ret = pbcpop(']');break;
-            case '(':pbcpush('(');break;
-            case ')':ret = pbcpop(')'); break;
-        }
-        if( ret )
-            return 1;
+	char *c = prev_word;
+	if (c == NULL)
+		return 0;
+	while ( *c ) {
+		switch (*c) {
+		case '{':
+		case '[':
+		case '(':
+			pbcpush(*c);
+			break;
+		case '}':
+		case ']':
+		case ')':
+			if (pbcpop(*c))
+				return 1;
+			break;
+		}
 		c++;
 	}
 	return 0;
 }
 
-static void pbcwhere(char *text, int *line, int *col )
-{
-	int loc_line = 0;
-    int loc_col = 0;
-	while ( *text ) {
-       if ( *text == '\n' ) {
-             loc_line++;
-             loc_col = 1;
-       } else {
-             loc_col++;
-       }
-       text++;
-    }
-	*line = loc_line;
-    *col = loc_col;
-}
 
+/* used by the bison code */
+void reset_parencount(yyscan_t yyscanner );
 void reset_parencount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -564,6 +505,8 @@
 	BEGIN(paren);
 }
 
+/* used by the bison code */
+void reset_semicount(yyscan_t yyscanner );
 void reset_semicount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -571,6 +514,8 @@
 	BEGIN(semic);
 }
 
+/* used by the bison code */
+void reset_argcount(yyscan_t yyscanner );
 void reset_argcount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -582,7 +527,7 @@
 	BEGIN(argg);
 }
 
-
+/* used elsewhere, but some local vars */
 struct pval *ael2_parse(char *filename, int *errors)
 {
 	struct pval *pval;
@@ -613,7 +558,7 @@
 	fread(buffer, 1, stats.st_size, fin);
 	buffer[stats.st_size]=0;
 	fclose(fin);
-	
+
 	ael_yy_scan_string (buffer ,io-&gt;scanner);
 	ael_yyset_lineno(1 , io-&gt;scanner);
 

Modified: trunk/pbx/ael/ael.tab.c
===================================================================
--- trunk/pbx/ael/ael.tab.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.tab.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -153,7 +153,7 @@
 #line 1 &quot;ael.y&quot;
 
 /*
- * Asterisk -- An open source telephony toolkit. 
+ * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 2006, Digium, Inc.
  *
@@ -172,18 +172,25 @@
 /*! \file
  *
  * \brief Bison Grammar description of AEL2.
- * 
+ *
  */
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &quot;asterisk/logger.h&quot;
+#include &quot;asterisk/utils.h&quot;		/* ast_calloc() */
 #include &quot;asterisk/ael_structs.h&quot;
 
-extern void reset_parencount(yyscan_t yyscanner);
-extern void reset_semicount(yyscan_t yyscanner);
-extern void reset_argcount(yyscan_t yyscanner );
+/* create a new object with start-end marker */
+static pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column);
 
+static pval * linku1(pval *head, pval *tail);
+
+void reset_parencount(yyscan_t yyscanner);
+void reset_semicount(yyscan_t yyscanner);
+void reset_argcount(yyscan_t yyscanner );
+
 #define YYLEX_PARAM ((struct parse_io *)parseio)-&gt;scanner
 #define YYERROR_VERBOSE 1
 
@@ -191,11 +198,10 @@
 #ifdef AAL_ARGCHECK
 int ael_is_funcname(char *name);
 #endif
- static char *ael_token_subst(char *mess);
- extern char *prev_word;
- 
+static char *ael_token_subst(char *mess);
 
 
+
 /* Enabling traces.  */
 #ifndef YYDEBUG
 # define YYDEBUG 0
@@ -215,13 +221,13 @@
 #endif
 
 #if ! defined (YYSTYPE) &amp;&amp; ! defined (YYSTYPE_IS_DECLARED)
-#line 47 &quot;ael.y&quot;
+#line 53 &quot;ael.y&quot;
 typedef union YYSTYPE {
 	char *str;
 	struct pval *pval;
 } YYSTYPE;
 /* Line 196 of yacc.c.  */
-#line 225 &quot;ael.tab.c&quot;
+#line 231 &quot;ael.tab.c&quot;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -242,16 +248,20 @@
 
 
 /* Copy the second part of user declarations.  */
-#line 52 &quot;ael.y&quot;
+#line 58 &quot;ael.y&quot;
 
 	/* declaring these AFTER the union makes things a lot simpler! */
 void yyerror(YYLTYPE *locp, struct parse_io *parseio, char const *s);
 int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void * yyscanner);
-	
 
+/* create a new object with start-end marker, simplified interface.
+ * Must be declared here because YYLTYPE is not known before
+ */
+static pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last);
 
+
 /* Line 219 of yacc.c.  */
-#line 255 &quot;ael.tab.c&quot;
+#line 265 &quot;ael.tab.c&quot;
 
 #if ! defined (YYSIZE_T) &amp;&amp; defined (__SIZE_TYPE__)
 # define YYSIZE_T __SIZE_TYPE__
@@ -551,22 +561,22 @@
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const unsigned short int yyrline[] =
 {
-       0,   126,   126,   129,   130,   133,   136,   137,   138,   139,
-     142,   143,   144,   145,   146,   147,   148,   149,   152,   154,
-     155,   156,   159,   160,   163,   164,   165,   168,   168,   171,
-     172,   173,   176,   177,   178,   181,   184,   185,   186,   187,
-     188,   189,   189,   190,   191,   194,   197,   198,   199,   200,
-     204,   205,   208,   211,   211,   214,   214,   217,   236,   255,
-     256,   258,   259,   260,   263,   264,   265,   268,   268,   273,
-     274,   274,   277,   278,   279,   280,   281,   282,   280,   285,
-     285,   288,   289,   290,   291,   292,   294,   294,   327,   328,
-     329,   330,   331,   332,   333,   334,   335,   336,   339,   340,
-     343,   346,   351,   356,   361,   368,   371,   374,   379,   384,
-     389,   396,   396,   399,   402,   402,   411,   417,   420,   421,
-     422,   423,   426,   427,   432,   433,   434,   435,   436,   437,
-     440,   441,   446,   447,   450,   451,   454,   455,   458,   459,
-     460,   463,   464,   485,   498,   499,   519,   532,   535,   536,
-     539,   540
+       0,   157,   157,   160,   161,   172,   175,   176,   177,   178,
+     181,   185,   188,   192,   195,   200,   204,   209,   215,   218,
+     221,   225,   230,   233,   237,   238,   239,   242,   242,   248,
+     251,   256,   259,   260,   261,   264,   267,   268,   269,   270,
+     271,   272,   272,   276,   277,   280,   285,   289,   294,   299,
+     308,   309,   312,   315,   315,   320,   320,   325,   341,   361,
+     362,   369,   370,   375,   383,   384,   388,   394,   394,   402,
+     405,   405,   409,   412,   415,   418,   419,   420,   418,   426,
+     426,   430,   434,   439,   443,   447,   450,   450,   483,   484,
+     485,   486,   491,   497,   502,   508,   513,   519,   522,   524,
+     529,   534,   541,   548,   555,   564,   569,   574,   581,   588,
+     595,   604,   604,   609,   614,   614,   624,   630,   633,   636,
+     639,   644,   651,   652,   657,   661,   665,   669,   672,   675,
+     680,   681,   686,   687,   693,   696,   700,   703,   707,   710,
+     715,   718,   721,   738,   751,   756,   774,   788,   791,   792,
+     795,   798
 };
 #endif
 
@@ -1303,194 +1313,293 @@
   switch (yytype)
     {
       case 41: /* &quot;word&quot; */
-#line 121 &quot;ael.y&quot;
+#line 152 &quot;ael.y&quot;
         { free((yyvaluep-&gt;str));};
-#line 1309 &quot;ael.tab.c&quot;
+#line 1319 &quot;ael.tab.c&quot;
         break;
       case 44: /* &quot;objects&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1314 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1327 &quot;ael.tab.c&quot;
         break;
       case 45: /* &quot;object&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1319 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1335 &quot;ael.tab.c&quot;
         break;
       case 46: /* &quot;context&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1324 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1343 &quot;ael.tab.c&quot;
         break;
       case 47: /* &quot;macro&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1329 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1351 &quot;ael.tab.c&quot;
         break;
       case 48: /* &quot;globals&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1334 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1359 &quot;ael.tab.c&quot;
         break;
       case 49: /* &quot;global_statements&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1339 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1367 &quot;ael.tab.c&quot;
         break;
       case 50: /* &quot;global_statement&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1344 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1375 &quot;ael.tab.c&quot;
         break;
       case 52: /* &quot;arglist&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1349 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1383 &quot;ael.tab.c&quot;
         break;
       case 53: /* &quot;elements&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1354 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1391 &quot;ael.tab.c&quot;
         break;
       case 54: /* &quot;element&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1359 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1399 &quot;ael.tab.c&quot;
         break;
       case 56: /* &quot;ignorepat&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1364 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1407 &quot;ael.tab.c&quot;
         break;
       case 57: /* &quot;extension&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1369 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1415 &quot;ael.tab.c&quot;
         break;
       case 58: /* &quot;statements&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1374 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1423 &quot;ael.tab.c&quot;
         break;
       case 59: /* &quot;if_head&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1379 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1431 &quot;ael.tab.c&quot;
         break;
       case 61: /* &quot;random_head&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1384 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1439 &quot;ael.tab.c&quot;
         break;
       case 63: /* &quot;iftime_head&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1389 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1447 &quot;ael.tab.c&quot;
         break;
       case 64: /* &quot;word_list&quot; */
-#line 121 &quot;ael.y&quot;
+#line 152 &quot;ael.y&quot;
         { free((yyvaluep-&gt;str));};
-#line 1394 &quot;ael.tab.c&quot;
+#line 1452 &quot;ael.tab.c&quot;
         break;
       case 65: /* &quot;word3_list&quot; */
-#line 121 &quot;ael.y&quot;
+#line 152 &quot;ael.y&quot;
         { free((yyvaluep-&gt;str));};
-#line 1399 &quot;ael.tab.c&quot;
+#line 1457 &quot;ael.tab.c&quot;
         break;
       case 66: /* &quot;goto_word&quot; */
-#line 121 &quot;ael.y&quot;
+#line 152 &quot;ael.y&quot;
         { free((yyvaluep-&gt;str));};
-#line 1404 &quot;ael.tab.c&quot;
+#line 1462 &quot;ael.tab.c&quot;
         break;
       case 67: /* &quot;switch_head&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1409 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1470 &quot;ael.tab.c&quot;
         break;
       case 69: /* &quot;statement&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1414 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1478 &quot;ael.tab.c&quot;
         break;
       case 76: /* &quot;target&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1419 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1486 &quot;ael.tab.c&quot;
         break;
       case 77: /* &quot;jumptarget&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1424 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1494 &quot;ael.tab.c&quot;
         break;
       case 78: /* &quot;macro_call&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1429 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1502 &quot;ael.tab.c&quot;
         break;
       case 80: /* &quot;application_call_head&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1434 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1510 &quot;ael.tab.c&quot;
         break;
       case 82: /* &quot;application_call&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1439 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1518 &quot;ael.tab.c&quot;
         break;
       case 83: /* &quot;eval_arglist&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1444 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1526 &quot;ael.tab.c&quot;
         break;
       case 84: /* &quot;case_statements&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1449 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1534 &quot;ael.tab.c&quot;
         break;
       case 85: /* &quot;case_statement&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1454 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1542 &quot;ael.tab.c&quot;
         break;
       case 86: /* &quot;macro_statements&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1459 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1550 &quot;ael.tab.c&quot;
         break;
       case 87: /* &quot;macro_statement&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1464 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1558 &quot;ael.tab.c&quot;
         break;
       case 88: /* &quot;switches&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1469 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1566 &quot;ael.tab.c&quot;
         break;
       case 89: /* &quot;eswitches&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1474 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1574 &quot;ael.tab.c&quot;
         break;
       case 90: /* &quot;switchlist&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1479 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1582 &quot;ael.tab.c&quot;
         break;
       case 91: /* &quot;includeslist&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1484 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1590 &quot;ael.tab.c&quot;
         break;
       case 92: /* &quot;includedname&quot; */
-#line 121 &quot;ael.y&quot;
+#line 152 &quot;ael.y&quot;
         { free((yyvaluep-&gt;str));};
-#line 1489 &quot;ael.tab.c&quot;
+#line 1595 &quot;ael.tab.c&quot;
         break;
       case 93: /* &quot;includes&quot; */
-#line 118 &quot;ael.y&quot;
-        { if (yymsg[0] != 'C') {destroy_pval((yyvaluep-&gt;pval)); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} };
-#line 1494 &quot;ael.tab.c&quot;
+#line 141 &quot;ael.y&quot;
+        {
+		destroy_pval((yyvaluep-&gt;pval));
+		prev_word=0;
+	};
+#line 1603 &quot;ael.tab.c&quot;
         break;
 
       default:
@@ -1807,696 +1916,877 @@
   switch (yyn)
     {
         case 2:
-#line 126 &quot;ael.y&quot;
+#line 157 &quot;ael.y&quot;
     { (yyval.pval) = parseio-&gt;pval = (yyvsp[0].pval); ;}
     break;
 
   case 3:
-#line 129 &quot;ael.y&quot;
+#line 160 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 4:
-#line 130 &quot;ael.y&quot;
-    {if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
-						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
-						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
+#line 162 &quot;ael.y&quot;
+    {
+			if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {
+				(yyval.pval)=(yyvsp[-1].pval);
+				linku1((yyval.pval),(yyvsp[0].pval));
+			} else if ( (yyvsp[-1].pval) ) {
+				(yyval.pval)=(yyvsp[-1].pval);
+			} else if ( (yyvsp[0].pval) ) {
+				(yyval.pval)=(yyvsp[0].pval);
+			}
+		;}
     break;
 
   case 5:
-#line 133 &quot;ael.y&quot;
+#line 172 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 6:
-#line 136 &quot;ael.y&quot;
+#line 175 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 7:
-#line 137 &quot;ael.y&quot;
+#line 176 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 8:
-#line 138 &quot;ael.y&quot;
+#line 177 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 9:
-#line 139 &quot;ael.y&quot;
+#line 178 &quot;ael.y&quot;
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
   case 10:
-#line 142 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-3].str); (yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval); ;}
+#line 181 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval); ;}
     break;
 
   case 11:
-#line 143 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
+#line 185 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 12:
-#line 144 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval); ;}
+#line 188 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval); ;}
     break;
 
   case 13:
-#line 145 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); ;}
+#line 192 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); ;}
     break;
 
   case 14:
-#line 146 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-3].str); (yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);  (yyval.pval)-&gt;u3.abstract = 1;;}
+#line 195 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-5]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)-&gt;u3.abstract = 1; ;}
     break;
 
   case 15:
-#line 147 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u3.abstract = 1; ;}
+#line 200 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u3.abstract = 1; ;}
     break;
 
   case 16:
-#line 148 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval); (yyval.pval)-&gt;u3.abstract = 1; ;}
+#line 204 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-5]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)-&gt;u3.abstract = 1; ;}
     break;
 
   case 17:
-#line 149 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CONTEXT,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;u3.abstract = 1; ;}
+#line 209 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CONTEXT, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;u3.abstract = 1; ;}
     break;
 
   case 18:
-#line 152 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-7]).first_line,(yylsp[0]).last_line, (yylsp[-7]).first_column, (yylsp[0]).last_column); 
-																	 (yyval.pval)-&gt;u1.str = (yyvsp[-6].str); (yyval.pval)-&gt;u2.arglist = (yyvsp[-4].pval); (yyval.pval)-&gt;u3.macro_statements = (yyvsp[-1].pval); ;}
+#line 215 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_MACRO, &amp;(yylsp[-7]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-6].str); (yyval.pval)-&gt;u2.arglist = (yyvsp[-4].pval); (yyval.pval)-&gt;u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
   case 19:
-#line 154 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-6]).first_line,(yylsp[0]).last_line, (yylsp[-6]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-5].str); (yyval.pval)-&gt;u2.arglist = (yyvsp[-3].pval); ;}
+#line 218 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_MACRO, &amp;(yylsp[-6]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-5].str); (yyval.pval)-&gt;u2.arglist = (yyvsp[-3].pval); ;}
     break;
 
   case 20:
-#line 155 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-6]).first_line,(yylsp[0]).last_line, (yylsp[-6]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-5].str); (yyval.pval)-&gt;u3.macro_statements = (yyvsp[-1].pval); ;}
+#line 221 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_MACRO, &amp;(yylsp[-6]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-5].str);
+		(yyval.pval)-&gt;u3.macro_statements = (yyvsp[-1].pval); ;}
     break;
 
   case 21:
-#line 156 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_MACRO,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-4].str); /* pretty empty! */ ;}
+#line 225 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_MACRO, &amp;(yylsp[-5]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str); ;}
     break;
 
   case 22:
-#line 159 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_GLOBALS,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.statements = (yyvsp[-1].pval);;}
+#line 230 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_GLOBALS, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.statements = (yyvsp[-1].pval);;}
     break;
 
   case 23:
-#line 160 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_GLOBALS,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); /* and that's all */ ;}
+#line 233 &quot;ael.y&quot;
+    { /* empty globals is OK */
+		(yyval.pval) = npval2(PV_GLOBALS, &amp;(yylsp[-2]), &amp;(yylsp[0])); ;}
     break;
 
   case 24:
-#line 163 &quot;ael.y&quot;
+#line 237 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 25:
-#line 164 &quot;ael.y&quot;
+#line 238 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));;}
     break;
 
   case 26:
-#line 165 &quot;ael.y&quot;
+#line 239 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 27:
-#line 168 &quot;ael.y&quot;
+#line 242 &quot;ael.y&quot;
     { reset_semicount(parseio-&gt;scanner); ;}
     break;
 
   case 28:
-#line 168 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-4].str);(yyval.pval)-&gt;u2.val = (yyvsp[-1].str); ;}
+#line 242 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_VARDEC, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;u2.val = (yyvsp[-1].str); ;}
     break;
 
   case 29:
-#line 171 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[0].str); ;}
+#line 248 &quot;ael.y&quot;
+    {
+		(yyval.pval)= npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[0].str); ;}
     break;
 
   case 30:
-#line 172 &quot;ael.y&quot;
-    {pval *z = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); z-&gt;u1.str = (yyvsp[0].str); (yyval.pval)=(yyvsp[-2].pval); linku1((yyval.pval),z); ;}
+#line 251 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		z-&gt;u1.str = (yyvsp[0].str);
+		(yyval.pval)=(yyvsp[-2].pval);
+		linku1((yyval.pval),z); ;}
     break;
 
   case 31:
-#line 173 &quot;ael.y&quot;
+#line 256 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 32:
-#line 176 &quot;ael.y&quot;
+#line 259 &quot;ael.y&quot;
     { (yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 33:
-#line 177 &quot;ael.y&quot;
+#line 260 &quot;ael.y&quot;
     {(yyval.pval)=0;;}
     break;
 
   case 34:
-#line 178 &quot;ael.y&quot;
-    { if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
-						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
-						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
+#line 261 &quot;ael.y&quot;
+    { if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
+				else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
+				else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 35:
-#line 181 &quot;ael.y&quot;
+#line 264 &quot;ael.y&quot;
     { (yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 36:
-#line 184 &quot;ael.y&quot;
+#line 267 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 37:
-#line 185 &quot;ael.y&quot;
+#line 268 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 38:
-#line 186 &quot;ael.y&quot;
+#line 269 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 39:
-#line 187 &quot;ael.y&quot;
+#line 270 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 40:
-#line 188 &quot;ael.y&quot;
+#line 271 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 41:
-#line 189 &quot;ael.y&quot;
+#line 272 &quot;ael.y&quot;
     { reset_semicount(parseio-&gt;scanner); ;}
     break;
 
   case 42:
-#line 189 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-4].str);(yyval.pval)-&gt;u2.val = (yyvsp[-1].str); ;}
+#line 272 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_VARDEC, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;u2.val = (yyvsp[-1].str); ;}
     break;
 
   case 43:
-#line 190 &quot;ael.y&quot;
+#line 276 &quot;ael.y&quot;
     {free((yyvsp[-1].str)); (yyval.pval)=0;;}
     break;
 
   case 44:
-#line 191 &quot;ael.y&quot;
+#line 277 &quot;ael.y&quot;
     {(yyval.pval)=0;/* allow older docs to be read */;}
     break;
 
   case 45:
-#line 194 &quot;ael.y&quot;
-    { (yyval.pval)=npval(PV_IGNOREPAT,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
+#line 280 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_IGNOREPAT, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
     break;
 
   case 46:
-#line 197 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); ;}
+#line 285 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); ;}
     break;
 
   case 47:
-#line 198 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-3]).first_line,(yylsp[-1]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); (yyval.pval)-&gt;u4.regexten=1;;}
+#line 289 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);
+		(yyval.pval)-&gt;u4.regexten=1;;}
     break;
 
   case 48:
-#line 199 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-6]).first_line,(yylsp[0]).last_line, (yylsp[-6]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); (yyval.pval)-&gt;u3.hints = (yyvsp[-4].str);;}
+#line 294 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &amp;(yylsp[-6]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);
+		(yyval.pval)-&gt;u3.hints = (yyvsp[-4].str);;}
     break;
 
   case 49:
-#line 200 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_EXTENSION,(yylsp[-7]).first_line,(yylsp[-4]).last_line, (yylsp[-7]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); (yyval.pval)-&gt;u4.regexten=1;(yyval.pval)-&gt;u3.hints = (yyvsp[-4].str);;}
+#line 299 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_EXTENSION, &amp;(yylsp[-7]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);
+		(yyval.pval)-&gt;u4.regexten=1;
+		(yyval.pval)-&gt;u3.hints = (yyvsp[-4].str);;}
     break;
 
   case 50:
-#line 204 &quot;ael.y&quot;
+#line 308 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 51:
-#line 205 &quot;ael.y&quot;
-    {if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
+#line 309 &quot;ael.y&quot;
+    {if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 52:
-#line 208 &quot;ael.y&quot;
+#line 312 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 53:
-#line 211 &quot;ael.y&quot;
+#line 315 &quot;ael.y&quot;
     { reset_parencount(parseio-&gt;scanner); ;}
     break;
 
   case 54:
-#line 211 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_IF,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str); ;}
+#line 315 &quot;ael.y&quot;
+    {
+		(yyval.pval)= npval2(PV_IF, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str); ;}
     break;
 
   case 55:
-#line 214 &quot;ael.y&quot;
+#line 320 &quot;ael.y&quot;
     { reset_parencount(parseio-&gt;scanner); ;}
     break;
 
   case 56:
-#line 214 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_RANDOM,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str=(yyvsp[-1].str);;}
+#line 320 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_RANDOM, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str=(yyvsp[-1].str);;}
     break;
 
   case 57:
-#line 217 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_IFTIME,(yylsp[-13]).first_line,(yylsp[-9]).last_line, (yylsp[-13]).first_column, (yylsp[-9]).last_column); 
-					(yyval.pval)-&gt;u1.list = npval(PV_WORD,(yylsp[-11]).first_line,(yylsp[-11]).last_line, (yylsp[-11]).first_column, (yylsp[-11]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;u1.str = (char*)malloc(strlen((yyvsp[-11].str))+strlen((yyvsp[-9].str))+strlen((yyvsp[-7].str))+4);
-					strcpy((yyval.pval)-&gt;u1.list-&gt;u1.str,(yyvsp[-11].str));
-					strcat((yyval.pval)-&gt;u1.list-&gt;u1.str,&quot;:&quot;);
-					strcat((yyval.pval)-&gt;u1.list-&gt;u1.str,(yyvsp[-9].str));
-					strcat((yyval.pval)-&gt;u1.list-&gt;u1.str,&quot;:&quot;);
-					strcat((yyval.pval)-&gt;u1.list-&gt;u1.str,(yyvsp[-7].str));
-					free((yyvsp[-11].str));
-					free((yyvsp[-9].str));
-					free((yyvsp[-7].str));
-					(yyval.pval)-&gt;u1.list-&gt;next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;u1.str = (yyvsp[-5].str); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str); 
-					prev_word = 0;
-		;}
+#line 326 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_IFTIME, &amp;(yylsp[-13]), &amp;(yylsp[-9])); /* XXX really @5 or more ? */
+		(yyval.pval)-&gt;u1.list = npval2(PV_WORD, &amp;(yylsp[-11]), &amp;(yylsp[-11]));
+		asprintf(&amp;((yyval.pval)-&gt;u1.list-&gt;u1.str), &quot;%s:%s:%s&quot;, (yyvsp[-11].str), (yyvsp[-9].str), (yyvsp[-7].str));
+		free((yyvsp[-11].str));
+		free((yyvsp[-9].str));
+		free((yyvsp[-7].str));
+		(yyval.pval)-&gt;u1.list-&gt;next = npval2(PV_WORD, &amp;(yylsp[-5]), &amp;(yylsp[-5]));
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;u1.str = (yyvsp[-5].str);
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-3]), &amp;(yylsp[-3]));
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[-1]));
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
+		prev_word = 0;
+	;}
     break;
 
   case 58:
-#line 236 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_IFTIME,(yylsp[-9]).first_line,(yylsp[-5]).last_line, (yylsp[-9]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)-&gt;u1.list = npval(PV_WORD,(yylsp[-7]).first_line,(yylsp[-7]).last_line, (yylsp[-7]).first_column, (yylsp[-7]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;u1.str = (yyvsp[-7].str);
-					(yyval.pval)-&gt;u1.list-&gt;next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;u1.str = (yyvsp[-5].str); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str); 
-					prev_word = 0;
-		;}
+#line 341 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_IFTIME, &amp;(yylsp[-9]), &amp;(yylsp[-5])); /* XXX @5 or greater ? */
+		(yyval.pval)-&gt;u1.list = npval2(PV_WORD, &amp;(yylsp[-7]), &amp;(yylsp[-7]));
+		(yyval.pval)-&gt;u1.list-&gt;u1.str = (yyvsp[-7].str);
+		(yyval.pval)-&gt;u1.list-&gt;next = npval2(PV_WORD, &amp;(yylsp[-5]), &amp;(yylsp[-5]));
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;u1.str = (yyvsp[-5].str);
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-3]), &amp;(yylsp[-3]));
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[-1]));
+		(yyval.pval)-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
+		prev_word = 0;
+	;}
     break;
 
   case 59:
-#line 255 &quot;ael.y&quot;
+#line 361 &quot;ael.y&quot;
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 60:
-#line 256 &quot;ael.y&quot;
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-1].str)); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-1].str)); free((yyvsp[0].str));prev_word = (yyval.str);;}
+#line 362 &quot;ael.y&quot;
+    {
+		asprintf(&amp;((yyval.str)), &quot;%s%s&quot;, (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));
+		prev_word = (yyval.str);;}
     break;
 
   case 61:
-#line 258 &quot;ael.y&quot;
+#line 369 &quot;ael.y&quot;
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 62:
-#line 259 &quot;ael.y&quot;
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-1].str)); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-1].str)); free((yyvsp[0].str));prev_word = (yyval.str);;}
+#line 370 &quot;ael.y&quot;
+    {
+		asprintf(&amp;((yyval.str)), &quot;%s%s&quot;, (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));
+		prev_word = (yyval.str);;}
     break;
 
   case 63:
-#line 260 &quot;ael.y&quot;
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-2].str))+strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-2].str)); strcat((yyval.str), (yyvsp[-1].str));  strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-2].str)); free((yyvsp[-1].str)); free((yyvsp[0].str));prev_word=(yyval.str);;}
+#line 375 &quot;ael.y&quot;
+    {
+		asprintf(&amp;((yyval.str)), &quot;%s%s%s&quot;, (yyvsp[-2].str), (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-2].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));
+		prev_word=(yyval.str);;}
     break;
 
   case 64:
-#line 263 &quot;ael.y&quot;
+#line 383 &quot;ael.y&quot;
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 65:
-#line 264 &quot;ael.y&quot;
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-1].str))+strlen((yyvsp[0].str))+1); strcpy((yyval.str), (yyvsp[-1].str)); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-1].str)); free((yyvsp[0].str));;}
+#line 384 &quot;ael.y&quot;
+    {
+		asprintf(&amp;((yyval.str)), &quot;%s%s&quot;, (yyvsp[-1].str), (yyvsp[0].str));
+		free((yyvsp[-1].str));
+		free((yyvsp[0].str));;}
     break;
 
   case 66:
-#line 265 &quot;ael.y&quot;
-    { (yyval.str) = (char*)malloc(strlen((yyvsp[-2].str))+strlen((yyvsp[0].str))+2); strcpy((yyval.str), (yyvsp[-2].str)); strcat((yyval.str),&quot;:&quot;); strcat((yyval.str), (yyvsp[0].str));  free((yyvsp[-2].str)); free((yyvsp[0].str));;}
+#line 388 &quot;ael.y&quot;
+    {
+		asprintf(&amp;((yyval.str)), &quot;%s:%s&quot;, (yyvsp[-2].str), (yyvsp[0].str));
+		free((yyvsp[-2].str));
+		free((yyvsp[0].str));;}
     break;
 
   case 67:
-#line 268 &quot;ael.y&quot;
+#line 394 &quot;ael.y&quot;
     { reset_parencount(parseio-&gt;scanner); ;}
     break;
 
   case 68:
-#line 269 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_SWITCH,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column);
-						(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
+#line 394 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_SWITCH, &amp;(yylsp[-5]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 69:
-#line 273 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_STATEMENTBLOCK,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.list = (yyvsp[-1].pval); ;}
+#line 402 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_STATEMENTBLOCK, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval); ;}
     break;
 
   case 70:
-#line 274 &quot;ael.y&quot;
+#line 405 &quot;ael.y&quot;
     {reset_semicount(parseio-&gt;scanner);;}
     break;
 
   case 71:
-#line 275 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); 
-				(yyval.pval)-&gt;u1.str = (yyvsp[-4].str); (yyval.pval)-&gt;u2.val = (yyvsp[-1].str); ;}
+#line 405 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_VARDEC, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;u2.val = (yyvsp[-1].str); ;}
     break;
 
   case 72:
-#line 277 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_GOTO,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);;}
+#line 409 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_GOTO, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);;}
     break;
 
   case 73:
-#line 278 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_GOTO,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);;}
+#line 412 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_GOTO, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);;}
     break;
 
   case 74:
-#line 279 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_LABEL,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str); ;}
+#line 415 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_LABEL, &amp;(yylsp[-1]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str); ;}
     break;
 
   case 75:
-#line 280 &quot;ael.y&quot;
+#line 418 &quot;ael.y&quot;
     {reset_semicount(parseio-&gt;scanner);;}
     break;
 
   case 76:
-#line 281 &quot;ael.y&quot;
+#line 419 &quot;ael.y&quot;
     {reset_semicount(parseio-&gt;scanner);;}
     break;
 
   case 77:
-#line 282 &quot;ael.y&quot;
+#line 420 &quot;ael.y&quot;
     {reset_parencount(parseio-&gt;scanner);;}
     break;
 
   case 78:
-#line 283 &quot;ael.y&quot;
-    { (yyval.pval)=npval(PV_FOR,(yylsp[-11]).first_line,(yylsp[0]).last_line, (yylsp[-11]).first_column, (yylsp[0]).last_column); 
-						(yyval.pval)-&gt;u1.for_init = (yyvsp[-8].str); (yyval.pval)-&gt;u2.for_test=(yyvsp[-5].str); (yyval.pval)-&gt;u3.for_inc = (yyvsp[-2].str); (yyval.pval)-&gt;u4.for_statements = (yyvsp[0].pval);;}
+#line 420 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_FOR, &amp;(yylsp[-11]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.for_init = (yyvsp[-8].str);
+		(yyval.pval)-&gt;u2.for_test=(yyvsp[-5].str);
+		(yyval.pval)-&gt;u3.for_inc = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u4.for_statements = (yyvsp[0].pval);;}
     break;
 
   case 79:
-#line 285 &quot;ael.y&quot;
+#line 426 &quot;ael.y&quot;
     {reset_parencount(parseio-&gt;scanner);;}
     break;
 
   case 80:
-#line 286 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WHILE,(yylsp[-5]).first_line,(yylsp[0]).last_line, (yylsp[-5]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); ;}
+#line 426 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WHILE, &amp;(yylsp[-5]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval); ;}
     break;
 
   case 81:
-#line 288 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-1].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
+#line 430 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)-&gt;endline = (yylsp[0]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 82:
-#line 289 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-2].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
+#line 434 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-2].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);
+		(yyval.pval)-&gt;endline = (yylsp[0]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 83:
-#line 290 &quot;ael.y&quot;
-    {(yyval.pval) = (yyvsp[-1].pval);(yyval.pval)-&gt;endline = (yylsp[-1]).last_line; (yyval.pval)-&gt;endcol = (yylsp[-1]).last_column;;}
+#line 439 &quot;ael.y&quot;
+    {
+		(yyval.pval) = (yyvsp[-1].pval);
+		(yyval.pval)-&gt;endline = (yylsp[-1]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[-1]).last_column;;}
     break;
 
   case 84:
-#line 291 &quot;ael.y&quot;
-    { (yyval.pval) = (yyvsp[-1].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
+#line 443 &quot;ael.y&quot;
+    {
+		(yyval.pval) = (yyvsp[-1].pval);
+		(yyval.pval)-&gt;endline = (yylsp[0]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 85:
-#line 292 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_APPLICATION_CALL,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); 
-																						(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
+#line 447 &quot;ael.y&quot;
+    {
+		(yyval.pval)= npval2(PV_APPLICATION_CALL, &amp;(yylsp[-1]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
     break;
 
   case 86:
-#line 294 &quot;ael.y&quot;
+#line 450 &quot;ael.y&quot;
     {reset_semicount(parseio-&gt;scanner);;}
     break;
 
   case 87:
-#line 294 &quot;ael.y&quot;
+#line 450 &quot;ael.y&quot;
     {
-                          char *bufx;
-						  int tot=0;
-						  pval *pptr;
-						  
-                          (yyval.pval) = npval(PV_VARDEC,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column);
-						  (yyval.pval)-&gt;u2.val=(yyvsp[-1].str);
-						  /* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
-                          /* string to big to fit in the buffer? */
-						  tot+=strlen((yyvsp[-4].pval)-&gt;u1.str);
-						  for(pptr=(yyvsp[-4].pval)-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
-							  tot+=strlen(pptr-&gt;u1.str);
-							  tot++; /* for a sep like a comma */
-						  }
-						  tot+=4; /* for safety */
-						  bufx = (char *)malloc(tot);
-						  strcpy(bufx,(yyvsp[-4].pval)-&gt;u1.str);
-						  strcat(bufx,&quot;(&quot;);
-						  for (pptr=(yyvsp[-4].pval)-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
-							  if ( pptr != (yyvsp[-4].pval)-&gt;u2.arglist )
-								  strcat(bufx,&quot;,&quot;);
-							  strcat(bufx,pptr-&gt;u1.str);
-						  }
-						  strcat(bufx,&quot;)&quot;);
+		char *bufx;
+		int tot=0;
+		pval *pptr;
+		(yyval.pval) = npval2(PV_VARDEC, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u2.val=(yyvsp[-1].str);
+		/* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
+		/* string to big to fit in the buffer? */
+		tot+=strlen((yyvsp[-4].pval)-&gt;u1.str);
+		for(pptr=(yyvsp[-4].pval)-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
+			tot+=strlen(pptr-&gt;u1.str);
+			tot++; /* for a sep like a comma */
+		}
+		tot+=4; /* for safety */
+		bufx = ast_calloc(1, tot);
+		strcpy(bufx,(yyvsp[-4].pval)-&gt;u1.str);
+		strcat(bufx,&quot;(&quot;);
+		/* XXX need to advance the pointer or the loop is very inefficient */
+		for (pptr=(yyvsp[-4].pval)-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
+			if ( pptr != (yyvsp[-4].pval)-&gt;u2.arglist )
+				strcat(bufx,&quot;,&quot;);
+			strcat(bufx,pptr-&gt;u1.str);
+		}
+		strcat(bufx,&quot;)&quot;);
 #ifdef AAL_ARGCHECK
-						  if ( !ael_is_funcname((yyvsp[-4].pval)-&gt;u1.str) )
-                              ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n&quot;, 
-									  my_file, (yylsp[-4]).first_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column, (yyvsp[-4].pval)-&gt;u1.str);
+		if ( !ael_is_funcname((yyvsp[-4].pval)-&gt;u1.str) )
+			ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n&quot;,
+				my_file, (yylsp[-4]).first_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column, (yyvsp[-4].pval)-&gt;u1.str);
 #endif
-						  (yyval.pval)-&gt;u1.str = bufx;
-						  destroy_pval((yyvsp[-4].pval)); /* the app call it is not, get rid of that chain */
-						  prev_word = 0;
-                       ;}
+		(yyval.pval)-&gt;u1.str = bufx;
+		destroy_pval((yyvsp[-4].pval)); /* the app call it is not, get rid of that chain */
+		prev_word = 0;
+	;}
     break;
 
   case 88:
-#line 327 &quot;ael.y&quot;
-    { (yyval.pval) = npval(PV_BREAK,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column);;}
+#line 483 &quot;ael.y&quot;
+    { (yyval.pval) = npval2(PV_BREAK, &amp;(yylsp[-1]), &amp;(yylsp[0])); ;}
     break;
 
   case 89:
-#line 328 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_RETURN,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column);;}
+#line 484 &quot;ael.y&quot;
+    { (yyval.pval) = npval2(PV_RETURN, &amp;(yylsp[-1]), &amp;(yylsp[0])); ;}
     break;
 
   case 90:
-#line 329 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_CONTINUE,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column);;}
+#line 485 &quot;ael.y&quot;
+    { (yyval.pval) = npval2(PV_CONTINUE, &amp;(yylsp[-1]), &amp;(yylsp[0])); ;}
     break;
 
   case 91:
-#line 330 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-1].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
+#line 486 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);
+		(yyval.pval)-&gt;endline = (yylsp[0]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 92:
-#line 331 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-3].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[-2].pval);(yyval.pval)-&gt;endline = (yylsp[-2]).last_line; (yyval.pval)-&gt;endcol = (yylsp[-2]).last_column; (yyval.pval)-&gt;u3.else_statements = (yyvsp[0].pval);;}
+#line 491 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-3].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-2].pval);
+		(yyval.pval)-&gt;endline = (yylsp[-2]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[-2]).last_column;
+		(yyval.pval)-&gt;u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 93:
-#line 332 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-1].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
+#line 497 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);
+		(yyval.pval)-&gt;endline = (yylsp[0]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 94:
-#line 333 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-3].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[-2].pval);(yyval.pval)-&gt;endline = (yylsp[-2]).last_line; (yyval.pval)-&gt;endcol = (yylsp[-2]).last_column; (yyval.pval)-&gt;u3.else_statements = (yyvsp[0].pval);;}
+#line 502 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-3].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-2].pval);
+		(yyval.pval)-&gt;endline = (yylsp[-2]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[-2]).last_column;
+		(yyval.pval)-&gt;u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 95:
-#line 334 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-1].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
+#line 508 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-1].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);
+		(yyval.pval)-&gt;endline = (yylsp[0]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 96:
-#line 335 &quot;ael.y&quot;
-    {(yyval.pval)=(yyvsp[-3].pval); (yyval.pval)-&gt;u2.statements = (yyvsp[-2].pval);(yyval.pval)-&gt;endline = (yylsp[-2]).last_line; (yyval.pval)-&gt;endcol = (yylsp[-2]).last_column; (yyval.pval)-&gt;u3.else_statements = (yyvsp[0].pval);;}
+#line 513 &quot;ael.y&quot;
+    {
+		(yyval.pval)=(yyvsp[-3].pval);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-2].pval);
+		(yyval.pval)-&gt;endline = (yylsp[-2]).last_line;
+		(yyval.pval)-&gt;endcol = (yylsp[-2]).last_column;
+		(yyval.pval)-&gt;u3.else_statements = (yyvsp[0].pval);;}
     break;
 
   case 97:
-#line 336 &quot;ael.y&quot;
+#line 519 &quot;ael.y&quot;
     { (yyval.pval)=0; ;}
     break;
 
   case 98:
-#line 339 &quot;ael.y&quot;
-    { (yyval.pval) = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[0].str);;}
+#line 522 &quot;ael.y&quot;
+    { (yyval.pval) = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[0].str);;}
     break;
 
   case 99:
-#line 340 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[0].str);;}
+#line 524 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[0].str);;}
     break;
 
   case 100:
-#line 343 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[0].str);;}
+#line 529 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[0].str);;}
     break;
 
   case 101:
-#line 346 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[-4].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
+#line 534 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-4]), &amp;(yylsp[-4]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
     break;
 
   case 102:
-#line 351 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[-4].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
+#line 541 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-4]), &amp;(yylsp[-4]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
     break;
 
   case 103:
-#line 356 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
+#line 548 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-4]), &amp;(yylsp[-4]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
     break;
 
   case 104:
-#line 361 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
+#line 555 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-4]), &amp;(yylsp[-4]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[0].str); ;}
     break;
 
   case 105:
-#line 368 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[0].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = strdup(&quot;1&quot;);;}
+#line 564 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[0].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0])); /* XXX not really @1 */
+		(yyval.pval)-&gt;next-&gt;u1.str = strdup(&quot;1&quot;);;}
     break;
 
   case 106:
-#line 371 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[0].str);;}
+#line 569 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[0].str);;}
     break;
 
   case 107:
-#line 374 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[0].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-4].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-2].str); ;}
+#line 574 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-4]), &amp;(yylsp[-4]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[0].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 108:
-#line 379 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;u1.str = (yyvsp[0].str); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); ;}
+#line 581 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[0].str);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); ;}
     break;
 
   case 109:
-#line 384 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-4]).first_line,(yylsp[-4]).last_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column); 
-					(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-4].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-2].str); ;}
+#line 588 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-4]), &amp;(yylsp[-4]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 110:
-#line 389 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-2]).first_line,(yylsp[-2]).last_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column); 
-					(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;); (yyval.pval)-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str); 
-					(yyval.pval)-&gt;next-&gt;next = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); 
-					(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); ;}
+#line 595 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-2]), &amp;(yylsp[-2]));
+		(yyval.pval)-&gt;u1.str = strdup(&quot;default&quot;);
+		(yyval.pval)-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); ;}
     break;
 
   case 111:
-#line 396 &quot;ael.y&quot;
+#line 604 &quot;ael.y&quot;
     {reset_argcount(parseio-&gt;scanner);;}
     break;
 
   case 112:
-#line 397 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_MACRO_CALL,(yylsp[-4]).first_line,(yylsp[-3]).last_line, (yylsp[-4]).first_column, (yylsp[-3]).last_column); 
-			(yyval.pval)-&gt;u1.str = (yyvsp[-4].str); (yyval.pval)-&gt;u2.arglist = (yyvsp[-1].pval);;}
+#line 604 &quot;ael.y&quot;
+    {
+		/* XXX original code had @2 but i think we need @5 */
+		(yyval.pval) = npval2(PV_MACRO_CALL, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-4].str);
+		(yyval.pval)-&gt;u2.arglist = (yyvsp[-1].pval);;}
     break;
 
   case 113:
-#line 399 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_MACRO_CALL,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
+#line 609 &quot;ael.y&quot;
+    {
+		(yyval.pval)= npval2(PV_MACRO_CALL, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 114:
-#line 402 &quot;ael.y&quot;
+#line 614 &quot;ael.y&quot;
     {reset_argcount(parseio-&gt;scanner);;}
     break;
 
   case 115:
-#line 402 &quot;ael.y&quot;
-    {if (strcasecmp((yyvsp[-2].str),&quot;goto&quot;) == 0) {
-																							(yyval.pval)= npval(PV_GOTO,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column);
-																							free((yyvsp[-2].str)); /* won't be using this */
-																							ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n&quot;, my_file, (yylsp[-2]).first_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column );
-																						} else
-																							(yyval.pval)= npval(PV_APPLICATION_CALL,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); 
-																						(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
+#line 614 &quot;ael.y&quot;
+    {
+		if (strcasecmp((yyvsp[-2].str),&quot;goto&quot;) == 0) {
+			(yyval.pval)= npval2(PV_GOTO, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+			free((yyvsp[-2].str)); /* won't be using this */
+			ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n&quot;, my_file, (yylsp[-2]).first_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column );
+		} else
+			(yyval.pval)= npval2(PV_APPLICATION_CALL, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str); ;}
     break;
 
   case 116:
-#line 411 &quot;ael.y&quot;
+#line 624 &quot;ael.y&quot;
     {(yyval.pval) = (yyvsp[-2].pval);
  		if( (yyval.pval)-&gt;type == PV_GOTO )
 			(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);
@@ -2506,244 +2796,289 @@
     break;
 
   case 117:
-#line 417 &quot;ael.y&quot;
+#line 630 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);(yyval.pval)-&gt;endline = (yylsp[0]).last_line; (yyval.pval)-&gt;endcol = (yylsp[0]).last_column;;}
     break;
 
   case 118:
-#line 420 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[0].str);;}
+#line 633 &quot;ael.y&quot;
+    { 
+		(yyval.pval)= npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[0].str);;}
     break;
 
   case 119:
-#line 421 &quot;ael.y&quot;
-    { (yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/); (yyval.pval)-&gt;u1.str = strdup(&quot;&quot;); ;}
+#line 636 &quot;ael.y&quot;
+    {
+		(yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
+		(yyval.pval)-&gt;u1.str = strdup(&quot;&quot;); ;}
     break;
 
   case 120:
-#line 422 &quot;ael.y&quot;
-    { pval *z = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval) = (yyvsp[-2].pval); linku1((yyvsp[-2].pval),z); z-&gt;u1.str = (yyvsp[0].str);;}
+#line 639 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval) = (yyvsp[-2].pval);
+		linku1((yyvsp[-2].pval),z);
+		z-&gt;u1.str = (yyvsp[0].str);;}
     break;
 
   case 121:
-#line 423 &quot;ael.y&quot;
-    { pval *z = npval(PV_WORD,(yylsp[0]).first_line,(yylsp[0]).last_line, (yylsp[0]).first_column, (yylsp[0]).last_column); (yyval.pval) = (yyvsp[-1].pval); linku1((yyvsp[-1].pval),z); z-&gt;u1.str = strdup(&quot;&quot;);;}
+#line 644 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[0]), &amp;(yylsp[0]));
+		(yyval.pval) = (yyvsp[-1].pval);
+		linku1((yyvsp[-1].pval),z);
+		z-&gt;u1.str = strdup(&quot;&quot;);;}
     break;
 
   case 122:
-#line 426 &quot;ael.y&quot;
+#line 651 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 123:
-#line 427 &quot;ael.y&quot;
-    { if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
+#line 652 &quot;ael.y&quot;
+    { if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 124:
-#line 432 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_CASE,(yylsp[-3]).first_line,(yylsp[-1]).last_line, (yylsp[-3]).first_column, (yylsp[-1]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);;}
+#line 657 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CASE, &amp;(yylsp[-3]), &amp;(yylsp[-1])); /* XXX 3 or 4 ? */
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);;}
     break;
 
   case 125:
-#line 433 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_DEFAULT,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = 0; (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);;}
+#line 661 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_DEFAULT, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = NULL;
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);;}
     break;
 
   case 126:
-#line 434 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_PATTERN,(yylsp[-3]).first_line,(yylsp[-1]).last_line, (yylsp[-3]).first_column, (yylsp[-1]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-2].str); (yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);;}
+#line 665 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_PATTERN, &amp;(yylsp[-3]), &amp;(yylsp[0])); /* <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">XXX at 3</A> or @4 ? */
+		(yyval.pval)-&gt;u1.str = (yyvsp[-2].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[0].pval);;}
     break;
 
   case 127:
-#line 435 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_CASE,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
+#line 669 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CASE, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
     break;
 
   case 128:
-#line 436 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_DEFAULT,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = 0;;}
+#line 672 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_DEFAULT, &amp;(yylsp[-1]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = NULL;;}
     break;
 
   case 129:
-#line 437 &quot;ael.y&quot;
-    {(yyval.pval) = npval(PV_PATTERN,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
+#line 675 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_PATTERN, &amp;(yylsp[-2]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
     break;
 
   case 130:
-#line 440 &quot;ael.y&quot;
+#line 680 &quot;ael.y&quot;
     {(yyval.pval) = (yyvsp[0].pval);;}
     break;
 
   case 131:
-#line 441 &quot;ael.y&quot;
-    { if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));} 
+#line 681 &quot;ael.y&quot;
+    { if ( (yyvsp[-1].pval) &amp;&amp; (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[-1].pval); linku1((yyval.pval),(yyvsp[0].pval));}
 						 else if ( (yyvsp[-1].pval) ) {(yyval.pval)=(yyvsp[-1].pval);}
 						 else if ( (yyvsp[0].pval) ) {(yyval.pval)=(yyvsp[0].pval);} ;}
     break;
 
   case 132:
-#line 446 &quot;ael.y&quot;
+#line 686 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[0].pval);;}
     break;
 
   case 133:
-#line 447 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_CATCH,(yylsp[-4]).first_line,(yylsp[0]).last_line, (yylsp[-4]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-3].str); (yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);;}
+#line 687 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_CATCH, &amp;(yylsp[-4]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u2.statements = (yyvsp[-1].pval);;}
     break;
 
   case 134:
-#line 450 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_SWITCHES,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.list = (yyvsp[-1].pval); ;}
+#line 693 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_SWITCHES, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval); ;}
     break;
 
   case 135:
-#line 451 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_SWITCHES,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column);;}
+#line 696 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_SWITCHES, &amp;(yylsp[-2]), &amp;(yylsp[0])); ;}
     break;
 
   case 136:
-#line 454 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_ESWITCHES,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.list = (yyvsp[-1].pval); ;}
+#line 700 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_ESWITCHES, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval); ;}
     break;
 
   case 137:
-#line 455 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_ESWITCHES,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column); ;}
+#line 703 &quot;ael.y&quot;
+    { /* empty switch list OK */
+		(yyval.pval) = npval2(PV_ESWITCHES, &amp;(yylsp[-2]), &amp;(yylsp[0])); ;}
     break;
 
   case 138:
-#line 458 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
+#line 707 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
     break;
 
   case 139:
-#line 459 &quot;ael.y&quot;
-    {pval *z = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)=(yyvsp[-2].pval); z-&gt;u1.str = (yyvsp[-1].str); linku1((yyval.pval),z); ;}
+#line 710 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[0]));
+		z-&gt;u1.str = (yyvsp[-1].str);
+		(yyval.pval)=(yyvsp[-2].pval);
+		linku1((yyval.pval),z); ;}
     break;
 
   case 140:
-#line 460 &quot;ael.y&quot;
+#line 715 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 141:
-#line 463 &quot;ael.y&quot;
-    {(yyval.pval)=npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
+#line 718 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-1].str);;}
     break;
 
   case 142:
-#line 464 &quot;ael.y&quot;
+#line 722 &quot;ael.y&quot;
     {
-                    (yyval.pval)=npval(PV_WORD,(yylsp[-13]).first_line,(yylsp[-12]).last_line, (yylsp[-13]).first_column, (yylsp[-12]).last_column); 
-                    (yyval.pval)-&gt;u1.str = (yyvsp[-13].str);
-					(yyval.pval)-&gt;u2.arglist = npval(PV_WORD,(yylsp[-11]).first_line,(yylsp[-7]).last_line, (yylsp[-11]).first_column, (yylsp[-7]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;u1.str = (char*)malloc(strlen((yyvsp[-11].str))+strlen((yyvsp[-9].str))+strlen((yyvsp[-7].str))+4);
-					strcpy((yyval.pval)-&gt;u2.arglist-&gt;u1.str,(yyvsp[-11].str));
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,(yyvsp[-9].str));
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,(yyvsp[-7].str));
-					free((yyvsp[-11].str));
-					free((yyvsp[-9].str));
-					free((yyvsp[-7].str));
-					(yyval.pval)-&gt;u2.arglist-&gt;next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str); 
-					prev_word=0;
-			;}
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-13]), &amp;(yylsp[-12]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-13].str);
+		(yyval.pval)-&gt;u2.arglist = npval2(PV_WORD, &amp;(yylsp[-11]), &amp;(yylsp[-7]));
+		asprintf( &amp;((yyval.pval)-&gt;u2.arglist-&gt;u1.str), &quot;%s:%s:%s&quot;, (yyvsp[-11].str), (yyvsp[-9].str), (yyvsp[-7].str));
+		free((yyvsp[-11].str));
+		free((yyvsp[-9].str));
+		free((yyvsp[-7].str));
+		(yyval.pval)-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;(yylsp[-5]), &amp;(yylsp[-5]));
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str);
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-3]), &amp;(yylsp[-3]));
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[-1]));
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 143:
-#line 485 &quot;ael.y&quot;
+#line 738 &quot;ael.y&quot;
     {
-                    (yyval.pval)=npval(PV_WORD,(yylsp[-9]).first_line,(yylsp[-8]).last_line, (yylsp[-9]).first_column, (yylsp[-8]).last_column); 
-                    (yyval.pval)-&gt;u1.str = (yyvsp[-9].str);
-					(yyval.pval)-&gt;u2.arglist = npval(PV_WORD,(yylsp[-7]).first_line,(yylsp[-7]).last_line, (yylsp[-7]).first_column, (yylsp[-7]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;u1.str = (yyvsp[-7].str);
-					(yyval.pval)-&gt;u2.arglist-&gt;next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str); 
-					prev_word=0;
-			;}
+		(yyval.pval) = npval2(PV_WORD, &amp;(yylsp[-9]), &amp;(yylsp[-8]));
+		(yyval.pval)-&gt;u1.str = (yyvsp[-9].str);
+		(yyval.pval)-&gt;u2.arglist = npval2(PV_WORD, &amp;(yylsp[-7]), &amp;(yylsp[-7]));
+		(yyval.pval)-&gt;u2.arglist-&gt;u1.str = (yyvsp[-7].str);
+		(yyval.pval)-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;(yylsp[-5]), &amp;(yylsp[-5]));
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str);
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-3]), &amp;(yylsp[-3]));
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[-1]));
+		(yyval.pval)-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 144:
-#line 498 &quot;ael.y&quot;
-    {pval *z = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[0]).last_line, (yylsp[-1]).first_column, (yylsp[0]).last_column); (yyval.pval)=(yyvsp[-2].pval); z-&gt;u1.str = (yyvsp[-1].str); linku1((yyval.pval),z); ;}
+#line 751 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[0])); /* XXX don't we need @<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">1- at 4</A> ?*/
+		(yyval.pval)=(yyvsp[-2].pval);
+		z-&gt;u1.str = (yyvsp[-1].str);
+		linku1((yyval.pval),z); ;}
     break;
 
   case 145:
-#line 499 &quot;ael.y&quot;
-    {pval *z = npval(PV_WORD,(yylsp[-13]).first_line,(yylsp[-12]).last_line, (yylsp[-13]).first_column, (yylsp[-12]).last_column); 
-					(yyval.pval)=(yyvsp[-14].pval); z-&gt;u1.str = (yyvsp[-13].str); linku1((yyval.pval),z);
-					z-&gt;u2.arglist = npval(PV_WORD,(yylsp[-11]).first_line,(yylsp[-11]).last_line, (yylsp[-11]).first_column, (yylsp[-11]).last_column); 
-					(yyval.pval)-&gt;u2.arglist-&gt;u1.str = (char*)malloc(strlen((yyvsp[-11].str))+strlen((yyvsp[-9].str))+strlen((yyvsp[-7].str))+4);
-					strcpy((yyval.pval)-&gt;u2.arglist-&gt;u1.str,(yyvsp[-11].str));
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,(yyvsp[-9].str));
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat((yyval.pval)-&gt;u2.arglist-&gt;u1.str,(yyvsp[-7].str));
-					free((yyvsp[-11].str));
-					free((yyvsp[-9].str));
-					free((yyvsp[-7].str));
-					z-&gt;u2.arglist-&gt;next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column); 
-					z-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str); 
-					z-&gt;u2.arglist-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column); 
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str); 
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column); 
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str); 
-					prev_word=0;
-			;}
+#line 757 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[-13]), &amp;(yylsp[-12]));
+		(yyval.pval)=(yyvsp[-14].pval); z-&gt;u1.str = (yyvsp[-13].str);
+		linku1((yyval.pval),z);
+		z-&gt;u2.arglist = npval2(PV_WORD, &amp;(yylsp[-11]), &amp;(yylsp[-11]));
+		asprintf( &amp;((yyval.pval)-&gt;u2.arglist-&gt;u1.str), &quot;%s:%s:%s&quot;, (yyvsp[-11].str), (yyvsp[-9].str), (yyvsp[-7].str));
+		free((yyvsp[-11].str));
+		free((yyvsp[-9].str));
+		free((yyvsp[-7].str));
+		z-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;(yylsp[-5]), &amp;(yylsp[-5]));
+		z-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str);
+		z-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-3]), &amp;(yylsp[-3]));
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[-1]));
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 146:
-#line 520 &quot;ael.y&quot;
-    {pval *z = npval(PV_WORD,(yylsp[-9]).first_line,(yylsp[-9]).last_line, (yylsp[-9]).first_column, (yylsp[-8]).last_column);
-					(yyval.pval)=(yyvsp[-10].pval); z-&gt;u1.str = (yyvsp[-9].str); linku1((yyval.pval),z);
-					z-&gt;u2.arglist = npval(PV_WORD,(yylsp[-7]).first_line,(yylsp[-7]).last_line, (yylsp[-7]).first_column, (yylsp[-7]).last_column);
-					(yyval.pval)-&gt;u2.arglist-&gt;u1.str = (yyvsp[-7].str);
-					z-&gt;u2.arglist-&gt;next = npval(PV_WORD,(yylsp[-5]).first_line,(yylsp[-5]).last_line, (yylsp[-5]).first_column, (yylsp[-5]).last_column);
-					z-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str);
-					z-&gt;u2.arglist-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-3]).first_line,(yylsp[-3]).last_line, (yylsp[-3]).first_column, (yylsp[-3]).last_column);
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(PV_WORD,(yylsp[-1]).first_line,(yylsp[-1]).last_line, (yylsp[-1]).first_column, (yylsp[-1]).last_column);
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
-					prev_word=0;
-			;}
+#line 774 &quot;ael.y&quot;
+    {
+		pval *z = npval2(PV_WORD, &amp;(yylsp[-9]), &amp;(yylsp[-8]));
+		(yyval.pval)=(yyvsp[-10].pval);
+		z-&gt;u1.str = (yyvsp[-9].str); linku1((yyval.pval),z);
+		z-&gt;u2.arglist = npval2(PV_WORD, &amp;(yylsp[-7]), &amp;(yylsp[-7]));
+		(yyval.pval)-&gt;u2.arglist-&gt;u1.str = (yyvsp[-7].str);
+		z-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;(yylsp[-5]), &amp;(yylsp[-5]));
+		z-&gt;u2.arglist-&gt;next-&gt;u1.str = (yyvsp[-5].str);
+		z-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-3]), &amp;(yylsp[-3]));
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-3].str);
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;(yylsp[-1]), &amp;(yylsp[-1]));
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = (yyvsp[-1].str);
+		prev_word=0;
+	;}
     break;
 
   case 147:
-#line 532 &quot;ael.y&quot;
+#line 788 &quot;ael.y&quot;
     {(yyval.pval)=(yyvsp[-1].pval);;}
     break;
 
   case 148:
-#line 535 &quot;ael.y&quot;
+#line 791 &quot;ael.y&quot;
     { (yyval.str) = (yyvsp[0].str);;}
     break;
 
   case 149:
-#line 536 &quot;ael.y&quot;
+#line 792 &quot;ael.y&quot;
     {(yyval.str)=strdup(&quot;default&quot;);;}
     break;
 
   case 150:
-#line 539 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_INCLUDES,(yylsp[-3]).first_line,(yylsp[0]).last_line, (yylsp[-3]).first_column, (yylsp[0]).last_column); (yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);;}
+#line 795 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_INCLUDES, &amp;(yylsp[-3]), &amp;(yylsp[0]));
+		(yyval.pval)-&gt;u1.list = (yyvsp[-1].pval);;}
     break;
 
   case 151:
-#line 540 &quot;ael.y&quot;
-    {(yyval.pval)= npval(PV_INCLUDES,(yylsp[-2]).first_line,(yylsp[0]).last_line, (yylsp[-2]).first_column, (yylsp[0]).last_column);;}
+#line 798 &quot;ael.y&quot;
+    {
+		(yyval.pval) = npval2(PV_INCLUDES, &amp;(yylsp[-2]), &amp;(yylsp[0]));;}
     break;
 
 
@@ -2751,7 +3086,7 @@
     }
 
 /* Line 1126 of yacc.c.  */
-#line 2755 &quot;ael.tab.c&quot;
+#line 3090 &quot;ael.tab.c&quot;
 
   yyvsp -= yylen;
   yyssp -= yylen;
@@ -3026,10 +3361,10 @@
 }
 
 
-#line 544 &quot;ael.y&quot;
+#line 803 &quot;ael.y&quot;
 
 
-static char *token_equivs1[] = 
+static char *token_equivs1[] =
 {
 	&quot;AMPER&quot;,
 	&quot;AT&quot;,
@@ -3038,15 +3373,15 @@
 	&quot;COMMA&quot;,
 	&quot;EQ&quot;,
 	&quot;EXTENMARK&quot;,
-	&quot;KW_BREAK&quot;, 
-	&quot;KW_CASE&quot;, 
-	&quot;KW_CATCH&quot;, 
+	&quot;KW_BREAK&quot;,
+	&quot;KW_CASE&quot;,
+	&quot;KW_CATCH&quot;,
 	&quot;KW_CONTEXT&quot;,
-	&quot;KW_CONTINUE&quot;, 
-	&quot;KW_DEFAULT&quot;, 
+	&quot;KW_CONTINUE&quot;,
+	&quot;KW_DEFAULT&quot;,
 	&quot;KW_ELSE&quot;,
 	&quot;KW_ESWITCHES&quot;,
-	&quot;KW_FOR&quot;, 
+	&quot;KW_FOR&quot;,
 	&quot;KW_GLOBALS&quot;,
 	&quot;KW_GOTO&quot;,
 	&quot;KW_HINT&quot;,
@@ -3056,12 +3391,12 @@
 	&quot;KW_INCLUDES&quot;
 	&quot;KW_JUMP&quot;,
 	&quot;KW_MACRO&quot;,
-	&quot;KW_PATTERN&quot;, 
-	&quot;KW_REGEXTEN&quot;, 
-	&quot;KW_RETURN&quot;, 
-	&quot;KW_SWITCHES&quot;, 
+	&quot;KW_PATTERN&quot;,
+	&quot;KW_REGEXTEN&quot;,
+	&quot;KW_RETURN&quot;,
+	&quot;KW_SWITCHES&quot;,
 	&quot;KW_SWITCH&quot;,
-	&quot;KW_WHILE&quot;, 
+	&quot;KW_WHILE&quot;,
 	&quot;LC&quot;,
 	&quot;LP&quot;,
 	&quot;RC&quot;,
@@ -3069,7 +3404,7 @@
 	&quot;SEMI&quot;,
 };
 
-static char *token_equivs2[] = 
+static char *token_equivs2[] =
 {
 	&quot;&amp;&quot;,
 	&quot;@&quot;,
@@ -3078,15 +3413,15 @@
 	&quot;,&quot;,
 	&quot;=&quot;,
 	&quot;=&gt;&quot;,
-	&quot;break&quot;, 
-	&quot;case&quot;, 
-	&quot;catch&quot;, 
+	&quot;break&quot;,
+	&quot;case&quot;,
+	&quot;catch&quot;,
 	&quot;context&quot;,
-	&quot;continue&quot;, 
-	&quot;default&quot;, 
+	&quot;continue&quot;,
+	&quot;default&quot;,
 	&quot;else&quot;,
 	&quot;eswitches&quot;,
-	&quot;for&quot;, 
+	&quot;for&quot;,
 	&quot;globals&quot;,
 	&quot;goto&quot;,
 	&quot;hint&quot;,
@@ -3096,12 +3431,12 @@
 	&quot;includes&quot;
 	&quot;jump&quot;,
 	&quot;macro&quot;,
-	&quot;pattern&quot;, 
-	&quot;regexten&quot;, 
-	&quot;return&quot;, 
-	&quot;switches&quot;, 
+	&quot;pattern&quot;,
+	&quot;regexten&quot;,
+	&quot;return&quot;,
+	&quot;switches&quot;,
 	&quot;switch&quot;,
-	&quot;while&quot;, 
+	&quot;while&quot;,
 	&quot;{&quot;,
 	&quot;(&quot;,
 	&quot;}&quot;,
@@ -3129,7 +3464,7 @@
 		}
 		len++;
 	}
-	res = (char*)malloc(len+1);
+	res = ast_calloc(1, len+1);
 	res[0] = 0;
 	s = res;
 	for (p=mess; *p;) {
@@ -3165,10 +3500,11 @@
 	parseio-&gt;syntax_error_count++;
 }
 
-struct pval *npval(pvaltype type,int first_line, int last_line, int first_column, int last_column)
+static struct pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column)
 {
 	extern char *my_file;
-	pval *z = (pval *)calloc(sizeof(struct pval),1);
+	pval *z = ast_calloc(1, sizeof(struct pval));
 	z-&gt;type = type;
 	z-&gt;startline = first_line;
 	z-&gt;endline = last_line;
@@ -3178,15 +3514,24 @@
 	return z;
 }
 
-void linku1(pval *head, pval *tail)
+static struct pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last)
 {
+	return npval(type, first-&gt;first_line, last-&gt;last_line,
+			first-&gt;first_column, last-&gt;last_column);
+}
+
+/* append second element to the list in the first one */
+static pval * linku1(pval *head, pval *tail)
+{
+	if (!head)
+		return tail;
 	if (!head-&gt;next) {
 		head-&gt;next = tail;
-		head-&gt;u1_last = tail;
 	} else {
 		head-&gt;u1_last-&gt;next = tail;
-		head-&gt;u1_last = tail;
 	}
+	head-&gt;u1_last = tail;
+	return head;
 }
 
 

Modified: trunk/pbx/ael/ael.tab.h
===================================================================
--- trunk/pbx/ael/ael.tab.h	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.tab.h	2006-04-29 02:51:28 UTC (rev 3)
@@ -115,7 +115,7 @@
 
 
 #if ! defined (YYSTYPE) &amp;&amp; ! defined (YYSTYPE_IS_DECLARED)
-#line 47 &quot;ael.y&quot;
+#line 53 &quot;ael.y&quot;
 typedef union YYSTYPE {
 	char *str;
 	struct pval *pval;

Modified: trunk/pbx/ael/ael.y
===================================================================
--- trunk/pbx/ael/ael.y	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael.y	2006-04-29 02:51:28 UTC (rev 3)
@@ -1,6 +1,6 @@
 %{
 /*
- * Asterisk -- An open source telephony toolkit. 
+ * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 2006, Digium, Inc.
  *
@@ -19,18 +19,25 @@
 /*! \file
  *
  * \brief Bison Grammar description of AEL2.
- * 
+ *
  */
 #include &lt;stdio.h&gt;
 #include &lt;stdlib.h&gt;
 #include &lt;string.h&gt;
 #include &quot;asterisk/logger.h&quot;
+#include &quot;asterisk/utils.h&quot;		/* ast_calloc() */
 #include &quot;asterisk/ael_structs.h&quot;
 
-extern void reset_parencount(yyscan_t yyscanner);
-extern void reset_semicount(yyscan_t yyscanner);
-extern void reset_argcount(yyscan_t yyscanner );
+/* create a new object with start-end marker */
+static pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column);
 
+static pval * linku1(pval *head, pval *tail);
+
+void reset_parencount(yyscan_t yyscanner);
+void reset_semicount(yyscan_t yyscanner);
+void reset_argcount(yyscan_t yyscanner );
+
 #define YYLEX_PARAM ((struct parse_io *)parseio)-&gt;scanner
 #define YYERROR_VERBOSE 1
 
@@ -38,9 +45,8 @@
 #ifdef AAL_ARGCHECK
 int ael_is_funcname(char *name);
 #endif
- static char *ael_token_subst(char *mess);
- extern char *prev_word;
- 
+static char *ael_token_subst(char *mess);
+
 %}
 
 
@@ -53,10 +59,14 @@
 	/* declaring these AFTER the union makes things a lot simpler! */
 void yyerror(YYLTYPE *locp, struct parse_io *parseio, char const *s);
 int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , void * yyscanner);
-	
+
+/* create a new object with start-end marker, simplified interface.
+ * Must be declared here because YYLTYPE is not known before
+ */
+static pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last);
 %}
 
- 
+
 %token KW_CONTEXT LC RC LP RP SEMI EQ COMMA COLON AMPER BAR AT
 %token KW_MACRO KW_GLOBALS KW_IGNOREPAT KW_SWITCH KW_IF KW_IFTIME KW_ELSE KW_RANDOM KW_ABSTRACT
 %token EXTENMARK KW_GOTO KW_JUMP KW_RETURN KW_BREAK KW_CONTINUE KW_REGEXTEN KW_HINT
@@ -81,9 +91,7 @@
 %type &lt;pval&gt;target jumptarget
 %type &lt;pval&gt;statement
 %type &lt;pval&gt;switch_head
-%type &lt;str&gt;word_list goto_word
-%type &lt;str&gt;word3_list
-%type &lt;str&gt;includedname
+
 %type &lt;pval&gt;if_head
 %type &lt;pval&gt;random_head
 %type &lt;pval&gt;iftime_head
@@ -99,25 +107,48 @@
 %type &lt;pval&gt;macro
 %type &lt;pval&gt;context
 %type &lt;pval&gt;object
-%type &lt;pval&gt;objects 
-%type &lt;pval&gt;file 
+%type &lt;pval&gt;objects
+%type &lt;pval&gt;file
 
-/* OPTIONS */
-%locations
-%pure-parser
+%type &lt;str&gt;goto_word
+%type &lt;str&gt;word_list
+%type &lt;str&gt;word3_list
+%type &lt;str&gt;includedname
+
+/*
+ * OPTIONS
+ */
+
+%locations	/* track source location using @n variables (yylloc in flex) */
+%pure-parser	/* pass yylval and yylloc as arguments to yylex(). */
 %name-prefix=&quot;ael_yy&quot;
-/* the following option does two things: 
-    it adds the locp arg to the yyerror
-    and it adds the NULL to the yyerrr arg list, and calls yyerror with NULL for that arg.
-    You can't get the locp arg without the NULL arg, don't ask me why. */
+/*
+ * add an additional argument, parseio, to yyparse(),
+ * which is then accessible in the grammar actions
+ */
 %parse-param {struct parse_io *parseio}
-/* there will be two shift/reduce conflicts, they involve the if statement, where a single statement occurs not wrapped in curlies in the &quot;true&quot; section 
+
+/* there will be two shift/reduce conflicts, they involve the if statement, where a single statement occurs not wrapped in curlies in the &quot;true&quot; section
    the default action to shift will attach the else to the preceeding if. */
 %expect 5
 %error-verbose
-%destructor { if (yymsg[0] != 'C') {destroy_pval($$); prev_word=0;} else {printf(&quot;Cleanup destructor called for pvals\n&quot;);} } includes includeslist switchlist eswitches switches macro_statement macro_statements case_statement case_statements eval_arglist application_call 
-                                application_call_head macro_call target jumptarget statement switch_head if_head random_head iftime_head statements extension ignorepat element
-                                elements arglist global_statement global_statements globals macro context object objects
+
+/*
+ * declare destructors for objects.
+ * The former is for pval, the latter for strings.
+ * NOTE: we must not have a destructor for a 'file' object.
+ */
+%destructor {
+		destroy_pval($$);
+		prev_word=0;
+	}	includes includeslist switchlist eswitches switches
+		macro_statement macro_statements case_statement case_statements
+		eval_arglist application_call application_call_head
+		macro_call target jumptarget statement switch_head
+		if_head random_head iftime_head statements extension
+		ignorepat element elements arglist global_statement
+		global_statements globals macro context object objects
+
 %destructor { free($$);}  word word_list goto_word word3_list includedname
 
 
@@ -127,9 +158,17 @@
 	;
 
 objects : object {$$=$1;}
-	| objects object {if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);} 
-						 else if ( $1 ) {$$=$1;}
-						 else if ( $2 ) {$$=$2;} }
+	| objects object
+		{
+			if ( $1 &amp;&amp; $2 ) {
+				$$=$1;
+				linku1($$,$2);
+			} else if ( $1 ) {
+				$$=$1;
+			} else if ( $2 ) {
+				$$=$2;
+			}
+		}
 	| objects error {$$=$1;}
 	;
 
@@ -139,25 +178,60 @@
 	| SEMI  {$$=0;/* allow older docs to be read */}
 	;
 
-context : KW_CONTEXT word LC elements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = $2; $$-&gt;u2.statements = $4; }
-	| KW_CONTEXT word LC RC /* empty context OK */ {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.str = $2; }
-	| KW_CONTEXT KW_DEFAULT LC elements RC  {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;u2.statements = $4; }
-	| KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.str = strdup(&quot;default&quot;); }
-    | KW_ABSTRACT KW_CONTEXT word LC elements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 6.last_line</A>, @1.first_column, @6.last_column); $$-&gt;u1.str = $3; $$-&gt;u2.statements = $5;  $$-&gt;u3.abstract = 1;}
-	| KW_ABSTRACT KW_CONTEXT word LC RC /* empty context OK */ {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = $3; $$-&gt;u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC elements RC  {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 6.last_line</A>, @1.first_column, @6.last_column); $$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;u2.statements = $5; $$-&gt;u3.abstract = 1; }
-	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTEXT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;u3.abstract = 1; }
+context : KW_CONTEXT word LC elements RC {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $2;
+		$$-&gt;u2.statements = $4; }
+	| KW_CONTEXT word LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@4);
+		$$-&gt;u1.str = $2; }
+	| KW_CONTEXT KW_DEFAULT LC elements RC {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;u2.statements = $4; }
+	| KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@4);
+		$$-&gt;u1.str = strdup(&quot;default&quot;); }
+	| KW_ABSTRACT KW_CONTEXT word LC elements RC {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@6);
+		$$-&gt;u1.str = $3;
+		$$-&gt;u2.statements = $5;
+		$$-&gt;u3.abstract = 1; }
+	| KW_ABSTRACT KW_CONTEXT word LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $3;
+		$$-&gt;u3.abstract = 1; }
+	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC elements RC  {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@6);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;u2.statements = $5;
+		$$-&gt;u3.abstract = 1; }
+	| KW_ABSTRACT KW_CONTEXT KW_DEFAULT LC RC /* empty context OK */ {
+		$$ = npval2(PV_CONTEXT, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;u3.abstract = 1; }
 	;
 
-macro : KW_MACRO word LP arglist RP LC macro_statements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_MACRO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 8.last_line</A>, @1.first_column, @8.last_column); 
-																	 $$-&gt;u1.str = $2; $$-&gt;u2.arglist = $4; $$-&gt;u3.macro_statements = $7; }
-	| KW_MACRO word LP arglist RP LC  RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_MACRO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 7.last_line</A>, @1.first_column, @7.last_column); $$-&gt;u1.str = $2; $$-&gt;u2.arglist = $4; }
-	| KW_MACRO word LP RP LC macro_statements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_MACRO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 7.last_line</A>, @1.first_column, @7.last_column); $$-&gt;u1.str = $2; $$-&gt;u3.macro_statements = $6; }
-	| KW_MACRO word LP RP LC  RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_MACRO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 6.last_line</A>, @1.first_column, @6.last_column); $$-&gt;u1.str = $2; /* pretty empty! */ }
+macro : KW_MACRO word LP arglist RP LC macro_statements RC {
+		$$ = npval2(PV_MACRO, &amp;@1, &amp;@8);
+		$$-&gt;u1.str = $2; $$-&gt;u2.arglist = $4; $$-&gt;u3.macro_statements = $7; }
+	| KW_MACRO word LP arglist RP LC  RC {
+		$$ = npval2(PV_MACRO, &amp;@1, &amp;@7);
+		$$-&gt;u1.str = $2; $$-&gt;u2.arglist = $4; }
+	| KW_MACRO word LP RP LC macro_statements RC {
+		$$ = npval2(PV_MACRO, &amp;@1, &amp;@7);
+		$$-&gt;u1.str = $2;
+		$$-&gt;u3.macro_statements = $6; }
+	| KW_MACRO word LP RP LC  RC {
+		$$ = npval2(PV_MACRO, &amp;@1, &amp;@6);
+		$$-&gt;u1.str = $2; }
 	;
 
-globals : KW_GLOBALS LC global_statements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_GLOBALS, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.statements = $3;}
-	| KW_GLOBALS LC RC /* empty global is OK */ {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_GLOBALS, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); /* and that's all */ }
+globals : KW_GLOBALS LC global_statements RC {
+		$$ = npval2(PV_GLOBALS, &amp;@1, &amp;@4);
+		$$-&gt;u1.statements = $3;}
+	| KW_GLOBALS LC RC { /* empty globals is OK */
+		$$ = npval2(PV_GLOBALS, &amp;@1, &amp;@3); }
 	;
 
 global_statements : global_statement {$$=$1;}
@@ -165,19 +239,28 @@
 	| global_statements error {$$=$1;}
 	;
 
-global_statement : word EQ { reset_semicount(parseio-&gt;scanner); }  word SEMI {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_VARDEC, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = $1;$$-&gt;u2.val = $4; }
+global_statement : word EQ { reset_semicount(parseio-&gt;scanner); }  word SEMI {
+		$$ = npval2(PV_VARDEC, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.val = $4; }
 	;
 
-arglist : word {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); $$-&gt;u1.str = $1; }
-	| arglist COMMA word {pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); z-&gt;u1.str = $3; $$=$1; linku1($$,z); }
+arglist : word {
+		$$= npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1; }
+	| arglist COMMA word {
+		pval *z = npval2(PV_WORD, &amp;@1, &amp;@3);
+		z-&gt;u1.str = $3;
+		$$=$1;
+		linku1($$,z); }
 	| arglist error {$$=$1;}
 	;
 
 elements : element { $$=$1;}
-    | error {$$=0;}
-	| elements element { if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);} 
-						 else if ( $1 ) {$$=$1;}
-						 else if ( $2 ) {$$=$2;} }
+	| error {$$=0;}
+	| elements element { if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);}
+				else if ( $1 ) {$$=$1;}
+				else if ( $2 ) {$$=$2;} }
 	| elements error   { $$=$1;}
 	;
 
@@ -186,226 +269,356 @@
 	| switches {$$=$1;}
 	| eswitches {$$=$1;}
 	| ignorepat {$$=$1;}
-	| word EQ { reset_semicount(parseio-&gt;scanner); } word SEMI {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_VARDEC, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = $1;$$-&gt;u2.val = $4; }
-    | word error {free($1); $$=0;}
+	| word EQ { reset_semicount(parseio-&gt;scanner); } word SEMI {
+		$$ = npval2(PV_VARDEC, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.val = $4; }
+	| word error {free($1); $$=0;}
 	| SEMI  {$$=0;/* allow older docs to be read */}
 	;
 
-ignorepat : KW_IGNOREPAT EXTENMARK word SEMI { $$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_IGNOREPAT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.str = $3;}
+ignorepat : KW_IGNOREPAT EXTENMARK word SEMI {
+		$$ = npval2(PV_IGNOREPAT, &amp;@1, &amp;@4);
+		$$-&gt;u1.str = $3;}
 	;
 
-extension : word EXTENMARK statement {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_EXTENSION, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = $1; $$-&gt;u2.statements = $3; }
-		  | KW_REGEXTEN word EXTENMARK statement {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_EXTENSION, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.str = $2; $$-&gt;u2.statements = $4; $$-&gt;u4.regexten=1;}
-		  | KW_HINT LP word3_list RP word EXTENMARK statement {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_EXTENSION, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 7.last_line</A>, @1.first_column, @7.last_column); $$-&gt;u1.str = $5; $$-&gt;u2.statements = $7; $$-&gt;u3.hints = $3;}
-		  | KW_REGEXTEN KW_HINT LP word3_list RP word EXTENMARK statement {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_EXTENSION, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @8.last_column); $$-&gt;u1.str = $6; $$-&gt;u2.statements = $8; $$-&gt;u4.regexten=1;$$-&gt;u3.hints = $4;}
+extension : word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &amp;@1, &amp;@3);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.statements = $3; }
+	| KW_REGEXTEN word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &amp;@1, &amp;@4);
+		$$-&gt;u1.str = $2;
+		$$-&gt;u2.statements = $4;
+		$$-&gt;u4.regexten=1;}
+	| KW_HINT LP word3_list RP word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &amp;@1, &amp;@7);
+		$$-&gt;u1.str = $5;
+		$$-&gt;u2.statements = $7;
+		$$-&gt;u3.hints = $3;}
+	| KW_REGEXTEN KW_HINT LP word3_list RP word EXTENMARK statement {
+		$$ = npval2(PV_EXTENSION, &amp;@1, &amp;@8);
+		$$-&gt;u1.str = $6;
+		$$-&gt;u2.statements = $8;
+		$$-&gt;u4.regexten=1;
+		$$-&gt;u3.hints = $4;}
 
 	;
 
 statements : statement {$$=$1;}
-	| statements statement {if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);} 
+	| statements statement {if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);}
 						 else if ( $1 ) {$$=$1;}
 						 else if ( $2 ) {$$=$2;} }
 	| statements error {$$=$1;}
 	;
 
-if_head : KW_IF LP { reset_parencount(parseio-&gt;scanner); }  word_list RP { $$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_IF, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = $4; }
-		;
+if_head : KW_IF LP { reset_parencount(parseio-&gt;scanner); }  word_list RP {
+		$$= npval2(PV_IF, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $4; }
+	;
 
-random_head : KW_RANDOM LP { reset_parencount(parseio-&gt;scanner); } word_list RP { $$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_RANDOM, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str=$4;}
-		;
+random_head : KW_RANDOM LP { reset_parencount(parseio-&gt;scanner); } word_list RP {
+		$$ = npval2(PV_RANDOM, &amp;@1, &amp;@5);
+		$$-&gt;u1.str=$4;}
+	;
 
-iftime_head : KW_IFTIME LP word3_list COLON word3_list COLON word3_list BAR word3_list BAR word3_list BAR word3_list RP { $$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_IFTIME, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); 
-					$$-&gt;u1.list = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;u1.list-&gt;u1.str = (char*)malloc(strlen($3)+strlen($5)+strlen($7)+4);
-					strcpy($$-&gt;u1.list-&gt;u1.str,$3);
-					strcat($$-&gt;u1.list-&gt;u1.str,&quot;:&quot;);
-					strcat($$-&gt;u1.list-&gt;u1.str,$5);
-					strcat($$-&gt;u1.list-&gt;u1.str,&quot;:&quot;);
-					strcat($$-&gt;u1.list-&gt;u1.str,$7);
-					free($3);
-					free($5);
-					free($7);
-					$$-&gt;u1.list-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 9.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 9.last_line</A>, @9.first_column, @9.last_column); 
-					$$-&gt;u1.list-&gt;next-&gt;u1.str = $9; 
-					$$-&gt;u1.list-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 11.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 11.last_line</A>, @11.first_column, @11.last_column); 
-					$$-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = $11; 
-					$$-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 13.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 13.last_line</A>, @13.first_column, @13.last_column); 
-					$$-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = $13; 
-					prev_word = 0;
-		}
-		| KW_IFTIME LP word BAR word3_list BAR word3_list BAR word3_list RP { $$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_IFTIME, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); 
-					$$-&gt;u1.list = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;u1.list-&gt;u1.str = $3;
-					$$-&gt;u1.list-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;u1.list-&gt;next-&gt;u1.str = $5; 
-					$$-&gt;u1.list-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 7.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 7.last_line</A>, @7.first_column, @7.last_column); 
-					$$-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = $7; 
-					$$-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 9.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 9.last_line</A>, @9.first_column, @9.last_column); 
-					$$-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = $9; 
-					prev_word = 0;
-		}
+iftime_head : KW_IFTIME LP word3_list COLON word3_list COLON word3_list
+		BAR word3_list BAR word3_list BAR word3_list RP {
+		$$ = npval2(PV_IFTIME, &amp;@1, &amp;@5); /* XXX really @5 or more ? */
+		$$-&gt;u1.list = npval2(PV_WORD, &amp;@3, &amp;@3);
+		asprintf(&amp;($$-&gt;u1.list-&gt;u1.str), &quot;%s:%s:%s&quot;, $3, $5, $7);
+		free($3);
+		free($5);
+		free($7);
+		$$-&gt;u1.list-&gt;next = npval2(PV_WORD, &amp;@9, &amp;@9);
+		$$-&gt;u1.list-&gt;next-&gt;u1.str = $9;
+		$$-&gt;u1.list-&gt;next-&gt;next = npval2(PV_WORD, &amp;@11, &amp;@11);
+		$$-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = $11;
+		$$-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;@13, &amp;@13);
+		$$-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = $13;
+		prev_word = 0;
+	}
+	| KW_IFTIME LP word BAR word3_list BAR word3_list BAR word3_list RP {
+		$$ = npval2(PV_IFTIME, &amp;@1, &amp;@5); /* XXX @5 or greater ? */
+		$$-&gt;u1.list = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;u1.list-&gt;u1.str = $3;
+		$$-&gt;u1.list-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;u1.list-&gt;next-&gt;u1.str = $5;
+		$$-&gt;u1.list-&gt;next-&gt;next = npval2(PV_WORD, &amp;@7, &amp;@7);
+		$$-&gt;u1.list-&gt;next-&gt;next-&gt;u1.str = $7;
+		$$-&gt;u1.list-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;@9, &amp;@9);
+		$$-&gt;u1.list-&gt;next-&gt;next-&gt;next-&gt;u1.str = $9;
+		prev_word = 0;
+	}
 
 	;
 
 /* word_list is a hack to fix a problem with context switching between bison and flex;
-   by the time you register a new context with flex, you've already got a look-ahead token 
+   by the time you register a new context with flex, you've already got a look-ahead token
    from the old context, with no way to put it back and start afresh. So, we kludge this
    and merge the words back together. */
 
-word_list : word { $$ = $1;}  
-	| word word { $$ = (char*)malloc(strlen($1)+strlen($2)+1); strcpy($$, $1); strcat($$, $2);  free($1); free($2);prev_word = $$;}
+word_list : word { $$ = $1;}
+	| word word {
+		asprintf(&amp;($$), &quot;%s%s&quot;, $1, $2);
+		free($1);
+		free($2);
+		prev_word = $$;}
 	;
-word3_list : word { $$ = $1;}  
-	| word word { $$ = (char*)malloc(strlen($1)+strlen($2)+1); strcpy($$, $1); strcat($$, $2);  free($1); free($2);prev_word = $$;}
-	| word word word { $$ = (char*)malloc(strlen($1)+strlen($2)+strlen($3)+1); strcpy($$, $1); strcat($$, $2);  strcat($$, $3);  free($1); free($2); free($3);prev_word=$$;}
+
+word3_list : word { $$ = $1;}
+	| word word {
+		asprintf(&amp;($$), &quot;%s%s&quot;, $1, $2);
+		free($1);
+		free($2);
+		prev_word = $$;}
+	| word word word {
+		asprintf(&amp;($$), &quot;%s%s%s&quot;, $1, $2, $3);
+		free($1);
+		free($2);
+		free($3);
+		prev_word=$$;}
 	;
 
 goto_word : word { $$ = $1;}
-	| word word { $$ = (char*)malloc(strlen($1)+strlen($2)+1); strcpy($$, $1); strcat($$, $2);  free($1); free($2);}
-	| word COLON word { $$ = (char*)malloc(strlen($1)+strlen($3)+2); strcpy($$, $1); strcat($$,&quot;:&quot;); strcat($$, $3);  free($1); free($3);}
+	| word word {
+		asprintf(&amp;($$), &quot;%s%s&quot;, $1, $2);
+		free($1);
+		free($2);}
+	| word COLON word {
+		asprintf(&amp;($$), &quot;%s:%s&quot;, $1, $3);
+		free($1);
+		free($3);}
 	;
 
-switch_head : KW_SWITCH LP { reset_parencount(parseio-&gt;scanner); } word RP  LC 
-					{$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_SWITCH, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 6.last_line</A>, @1.first_column, @6.last_column);
-						$$-&gt;u1.str = $4; }
+switch_head : KW_SWITCH LP { reset_parencount(parseio-&gt;scanner); } word RP  LC {
+		$$ = npval2(PV_SWITCH, &amp;@1, &amp;@6);
+		$$-&gt;u1.str = $4; }
 	;
 
-statement : LC statements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_STATEMENTBLOCK, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.list = $2; }
-	| word EQ {reset_semicount(parseio-&gt;scanner);} word SEMI 
-			{$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_VARDEC, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); 
-				$$-&gt;u1.str = $1; $$-&gt;u2.val = $4; }
-	| KW_GOTO target SEMI {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_GOTO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.list = $2;}
-    | KW_JUMP jumptarget SEMI {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_GOTO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.list = $2;}
-	| word COLON {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_LABEL, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); $$-&gt;u1.str = $1; }
+/*
+ * Definition of a statememt in our language
+ */
+statement : LC statements RC {
+		$$ = npval2(PV_STATEMENTBLOCK, &amp;@1, &amp;@3);
+		$$-&gt;u1.list = $2; }
+	| word EQ {reset_semicount(parseio-&gt;scanner);} word SEMI {
+		$$ = npval2(PV_VARDEC, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.val = $4; }
+	| KW_GOTO target SEMI {
+		$$ = npval2(PV_GOTO, &amp;@1, &amp;@3);
+		$$-&gt;u1.list = $2;}
+	| KW_JUMP jumptarget SEMI {
+		$$ = npval2(PV_GOTO, &amp;@1, &amp;@3);
+		$$-&gt;u1.list = $2;}
+	| word COLON {
+		$$ = npval2(PV_LABEL, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = $1; }
 	| KW_FOR LP {reset_semicount(parseio-&gt;scanner);} word SEMI
 			{reset_semicount(parseio-&gt;scanner);} word SEMI
-			{reset_parencount(parseio-&gt;scanner);} word RP statement 
-				{ $$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_FOR, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 12.last_line</A>, @1.first_column, @12.last_column); 
-						$$-&gt;u1.for_init = $4; $$-&gt;u2.for_test=$7; $$-&gt;u3.for_inc = $10; $$-&gt;u4.for_statements = $12;}
-	| KW_WHILE LP {reset_parencount(parseio-&gt;scanner);} word RP statement 
-			{$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WHILE, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 6.last_line</A>, @1.first_column, @6.last_column); 
-					$$-&gt;u1.str = $4; $$-&gt;u2.statements = $6; }
-	| switch_head RC /* empty list OK */ {$$=$1;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
-	| switch_head case_statements RC {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @3.last_line; $$-&gt;endcol = @3.last_column;}
-	| AMPER macro_call SEMI {$$ = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
-	| application_call SEMI { $$ = $1;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
-    | word SEMI { $$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_APPLICATION_CALL, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); 
-																						$$-&gt;u1.str = $1;}
+			{reset_parencount(parseio-&gt;scanner);} word RP statement {
+		$$ = npval2(PV_FOR, &amp;@1, &amp;@12);
+		$$-&gt;u1.for_init = $4;
+		$$-&gt;u2.for_test=$7;
+		$$-&gt;u3.for_inc = $10;
+		$$-&gt;u4.for_statements = $12;}
+	| KW_WHILE LP {reset_parencount(parseio-&gt;scanner);} word RP statement {
+		$$ = npval2(PV_WHILE, &amp;@1, &amp;@6);
+		$$-&gt;u1.str = $4;
+		$$-&gt;u2.statements = $6; }
+	| switch_head RC /* empty list OK */ {
+		$$=$1;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;}
+	| switch_head case_statements RC {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @3.last_line;
+		$$-&gt;endcol = @3.last_column;}
+	| AMPER macro_call SEMI {
+		$$ = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;}
+	| application_call SEMI {
+		$$ = $1;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;}
+	| word SEMI {
+		$$= npval2(PV_APPLICATION_CALL, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = $1;}
 	| application_call EQ {reset_semicount(parseio-&gt;scanner);} word SEMI {
-                          char *bufx;
-						  int tot=0;
-						  pval *pptr;
-						  
-                          $$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_VARDEC, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column);
-						  $$-&gt;u2.val=$4;
-						  /* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
-                          /* string to big to fit in the buffer? */
-						  tot+=strlen($1-&gt;u1.str);
-						  for(pptr=$1-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
-							  tot+=strlen(pptr-&gt;u1.str);
-							  tot++; /* for a sep like a comma */
-						  }
-						  tot+=4; /* for safety */
-						  bufx = (char *)malloc(tot);
-						  strcpy(bufx,$1-&gt;u1.str);
-						  strcat(bufx,&quot;(&quot;);
-						  for (pptr=$1-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
-							  if ( pptr != $1-&gt;u2.arglist )
-								  strcat(bufx,&quot;,&quot;);
-							  strcat(bufx,pptr-&gt;u1.str);
-						  }
-						  strcat(bufx,&quot;)&quot;);
+		char *bufx;
+		int tot=0;
+		pval *pptr;
+		$$ = npval2(PV_VARDEC, &amp;@1, &amp;@5);
+		$$-&gt;u2.val=$4;
+		/* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
+		/* string to big to fit in the buffer? */
+		tot+=strlen($1-&gt;u1.str);
+		for(pptr=$1-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
+			tot+=strlen(pptr-&gt;u1.str);
+			tot++; /* for a sep like a comma */
+		}
+		tot+=4; /* for safety */
+		bufx = ast_calloc(1, tot);
+		strcpy(bufx,$1-&gt;u1.str);
+		strcat(bufx,&quot;(&quot;);
+		/* XXX need to advance the pointer or the loop is very inefficient */
+		for (pptr=$1-&gt;u2.arglist;pptr;pptr=pptr-&gt;next) {
+			if ( pptr != $1-&gt;u2.arglist )
+				strcat(bufx,&quot;,&quot;);
+			strcat(bufx,pptr-&gt;u1.str);
+		}
+		strcat(bufx,&quot;)&quot;);
 #ifdef AAL_ARGCHECK
-						  if ( !ael_is_funcname($1-&gt;u1.str) )
-                              ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n&quot;, 
-									  my_file, @1.first_line, @1.first_column, @1.last_column, $1-&gt;u1.str);
+		if ( !ael_is_funcname($1-&gt;u1.str) )
+			ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n&quot;,
+				my_file, @1.first_line, @1.first_column, @1.last_column, $1-&gt;u1.str);
 #endif
-						  $$-&gt;u1.str = bufx;
-						  destroy_pval($1); /* the app call it is not, get rid of that chain */
-						  prev_word = 0;
-                       }
-	| KW_BREAK SEMI { $$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_BREAK, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column);}
-	| KW_RETURN SEMI {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_RETURN, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column);}
-	| KW_CONTINUE SEMI {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CONTINUE, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column);}
-	| random_head statement {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
-	| random_head statement KW_ELSE statement {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column; $$-&gt;u3.else_statements = $4;}
-	| if_head statement {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
-	| if_head statement KW_ELSE statement {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column; $$-&gt;u3.else_statements = $4;}
-	| iftime_head statement {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
-	| iftime_head statement KW_ELSE statement {$$=$1; $$-&gt;u2.statements = $2;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column; $$-&gt;u3.else_statements = $4;}
+		$$-&gt;u1.str = bufx;
+		destroy_pval($1); /* the app call it is not, get rid of that chain */
+		prev_word = 0;
+	}
+	| KW_BREAK SEMI { $$ = npval2(PV_BREAK, &amp;@1, &amp;@2); }
+	| KW_RETURN SEMI { $$ = npval2(PV_RETURN, &amp;@1, &amp;@2); }
+	| KW_CONTINUE SEMI { $$ = npval2(PV_CONTINUE, &amp;@1, &amp;@2); }
+	| random_head statement {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;}
+	| random_head statement KW_ELSE statement {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;
+		$$-&gt;u3.else_statements = $4;}
+	| if_head statement {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;}
+	| if_head statement KW_ELSE statement {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;
+		$$-&gt;u3.else_statements = $4;}
+	| iftime_head statement {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;}
+	| iftime_head statement KW_ELSE statement {
+		$$=$1;
+		$$-&gt;u2.statements = $2;
+		$$-&gt;endline = @2.last_line;
+		$$-&gt;endcol = @2.last_column;
+		$$-&gt;u3.else_statements = $4;}
 	| SEMI { $$=0; }
 	;
 
-target : goto_word { $$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); $$-&gt;u1.str = $1;}
-	| goto_word BAR goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $1; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3;}
-	| goto_word COMMA goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $1; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3;}
-	| goto_word BAR goto_word BAR goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $1; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = $5; }
-	| goto_word COMMA goto_word COMMA goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $1; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = $5; }
-	| KW_DEFAULT BAR goto_word BAR goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = $5; }
-	| KW_DEFAULT COMMA goto_word COMMA goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = $5; }
+target : goto_word { $$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;}
+	| goto_word BAR goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;}
+	| goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;}
+	| goto_word BAR goto_word BAR goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;next-&gt;next-&gt;u1.str = $5; }
+	| goto_word COMMA goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;next-&gt;next-&gt;u1.str = $5; }
+	| KW_DEFAULT BAR goto_word BAR goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;next-&gt;next-&gt;u1.str = $5; }
+	| KW_DEFAULT COMMA goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;next-&gt;next-&gt;u1.str = $5; }
 	;
 
-jumptarget : goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $1; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;next-&gt;u1.str = strdup(&quot;1&quot;);}  /*  jump extension[,priority][@context] */
-		| goto_word COMMA goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $1; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $3;} 
-		| goto_word COMMA word AT word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $5; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $1; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = $3; } 
-		| goto_word AT goto_word {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = $3; $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $1; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); } 
-		| goto_word COMMA word AT KW_DEFAULT {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $1; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = $3; } 
-		| goto_word AT KW_DEFAULT {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); 
-					$$-&gt;u1.str = strdup(&quot;default&quot;); $$-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;u1.str = $1; 
-					$$-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); } 
-		;
+jumptarget : goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;
+		$$-&gt;next = npval2(PV_WORD, &amp;@1, &amp;@1); /* XXX not really @1 */
+		$$-&gt;next-&gt;u1.str = strdup(&quot;1&quot;);}  /*  jump extension[,priority][@context] */
+	| goto_word COMMA goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $3;}
+	| goto_word COMMA word AT word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $5;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $1;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;next-&gt;next-&gt;u1.str = $3; }
+	| goto_word AT goto_word {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $3;
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $1;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); }
+	| goto_word COMMA word AT KW_DEFAULT {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $1;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;next-&gt;next-&gt;u1.str = $3; }
+	| goto_word AT KW_DEFAULT {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = strdup(&quot;default&quot;);
+		$$-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;u1.str = $1;
+		$$-&gt;next-&gt;next = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;next-&gt;next-&gt;u1.str = strdup(&quot;1&quot;); }
+	;
 
-macro_call : word LP {reset_argcount(parseio-&gt;scanner);} eval_arglist RP 
-			{$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_MACRO_CALL, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); 
-			$$-&gt;u1.str = $1; $$-&gt;u2.arglist = $4;}
-	| word LP RP {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_MACRO_CALL, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = $1; }
+macro_call : word LP {reset_argcount(parseio-&gt;scanner);} eval_arglist RP {
+		/* XXX original code had @2 but i think we need @5 */
+		$$ = npval2(PV_MACRO_CALL, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.arglist = $4;}
+	| word LP RP {
+		$$= npval2(PV_MACRO_CALL, &amp;@1, &amp;@3);
+		$$-&gt;u1.str = $1; }
 	;
 
-application_call_head: word {reset_argcount(parseio-&gt;scanner);} LP  {if (strcasecmp($1,&quot;goto&quot;) == 0) {
-																							$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_GOTO, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column);
-																							free($1); /* won't be using this */
-																							ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n&quot;, my_file, @1.first_line, @1.first_column, @1.last_column );
-																						} else
-																							$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_APPLICATION_CALL, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); 
-																						$$-&gt;u1.str = $1; }
+application_call_head: word {reset_argcount(parseio-&gt;scanner);} LP  {
+		if (strcasecmp($1,&quot;goto&quot;) == 0) {
+			$$= npval2(PV_GOTO, &amp;@1, &amp;@3);
+			free($1); /* won't be using this */
+			ast_log(LOG_WARNING, &quot;==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n&quot;, my_file, @1.first_line, @1.first_column, @1.last_column );
+		} else
+			$$= npval2(PV_APPLICATION_CALL, &amp;@1, &amp;@3);
+		$$-&gt;u1.str = $1; }
 	;
 
 application_call : application_call_head eval_arglist RP {$$ = $1;
@@ -417,133 +630,179 @@
 	| application_call_head RP {$$=$1;$$-&gt;endline = @2.last_line; $$-&gt;endcol = @2.last_column;}
 	;
 
-eval_arglist :  word_list { $$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 1.last_line</A>, @1.first_column, @1.last_column); $$-&gt;u1.str = $1;}
-	| /*nothing! */   { $$= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/); $$-&gt;u1.str = strdup(&quot;&quot;); }
-	| eval_arglist COMMA  word { pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); $$ = $1; linku1($1,z); z-&gt;u1.str = $3;}
-	| eval_arglist COMMA { pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 2.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @2.first_column, @2.last_column); $$ = $1; linku1($1,z); z-&gt;u1.str = strdup(&quot;&quot;);}
+eval_arglist :  word_list { 
+		$$= npval2(PV_WORD, &amp;@1, &amp;@1);
+		$$-&gt;u1.str = $1;}
+	| /*nothing! */   {
+		$$= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
+		$$-&gt;u1.str = strdup(&quot;&quot;); }
+	| eval_arglist COMMA  word {
+		pval *z = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$ = $1;
+		linku1($1,z);
+		z-&gt;u1.str = $3;}
+	| eval_arglist COMMA {
+		pval *z = npval2(PV_WORD, &amp;@2, &amp;@2);
+		$$ = $1;
+		linku1($1,z);
+		z-&gt;u1.str = strdup(&quot;&quot;);}
 	;
 
 case_statements: case_statement {$$=$1;}
-	| case_statements case_statement { if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);} 
+	| case_statements case_statement { if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);}
 						 else if ( $1 ) {$$=$1;}
 						 else if ( $2 ) {$$=$2;} }
 	;
 
-case_statement: KW_CASE word COLON statements {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CASE, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = $2; $$-&gt;u2.statements = $4;}
-	| KW_DEFAULT COLON statements {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_DEFAULT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = 0; $$-&gt;u2.statements = $3;}
-	| KW_PATTERN word COLON statements {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_PATTERN, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = $2; $$-&gt;u2.statements = $4;}
-    | KW_CASE word COLON {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CASE, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = $2;}
-	| KW_DEFAULT COLON {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_DEFAULT, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); $$-&gt;u1.str = 0;}
-	| KW_PATTERN word COLON  {$$ = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_PATTERN, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); $$-&gt;u1.str = $2;}
+case_statement: KW_CASE word COLON statements {
+		$$ = npval2(PV_CASE, &amp;@1, &amp;@3); /* XXX 3 or 4 ? */
+		$$-&gt;u1.str = $2;
+		$$-&gt;u2.statements = $4;}
+	| KW_DEFAULT COLON statements {
+		$$ = npval2(PV_DEFAULT, &amp;@1, &amp;@3);
+		$$-&gt;u1.str = NULL;
+		$$-&gt;u2.statements = $3;}
+	| KW_PATTERN word COLON statements {
+		$$ = npval2(PV_PATTERN, &amp;@1, &amp;@4); /* <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">XXX at 3</A> or @4 ? */
+		$$-&gt;u1.str = $2;
+		$$-&gt;u2.statements = $4;}
+	| KW_CASE word COLON {
+		$$ = npval2(PV_CASE, &amp;@1, &amp;@3);
+		$$-&gt;u1.str = $2;}
+	| KW_DEFAULT COLON {
+		$$ = npval2(PV_DEFAULT, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = NULL;}
+	| KW_PATTERN word COLON  {
+		$$ = npval2(PV_PATTERN, &amp;@1, &amp;@3);
+		$$-&gt;u1.str = $2;}
 	;
 
 macro_statements: macro_statement {$$ = $1;}
-	| macro_statements macro_statement { if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);} 
+	| macro_statements macro_statement { if ( $1 &amp;&amp; $2 ) {$$=$1; linku1($$,$2);}
 						 else if ( $1 ) {$$=$1;}
 						 else if ( $2 ) {$$=$2;} }
 	;
 
 macro_statement : statement {$$=$1;}
-	| KW_CATCH word LC statements RC {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_CATCH, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @1.first_column, @5.last_column); $$-&gt;u1.str = $2; $$-&gt;u2.statements = $4;}
+	| KW_CATCH word LC statements RC {
+		$$ = npval2(PV_CATCH, &amp;@1, &amp;@5);
+		$$-&gt;u1.str = $2;
+		$$-&gt;u2.statements = $4;}
 	;
 
-switches : KW_SWITCHES LC switchlist RC {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_SWITCHES, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.list = $3; }
-	| KW_SWITCHES LC RC /* empty switch list OK */ {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_SWITCHES, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column);}
+switches : KW_SWITCHES LC switchlist RC {
+		$$ = npval2(PV_SWITCHES, &amp;@1, &amp;@4);
+		$$-&gt;u1.list = $3; }
+	| KW_SWITCHES LC RC /* empty switch list OK */ {
+		$$ = npval2(PV_SWITCHES, &amp;@1, &amp;@3); }
 	;
 
-eswitches : KW_ESWITCHES LC switchlist RC {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_ESWITCHES, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.list = $3; }
-	| KW_ESWITCHES LC  RC /* empty switch list OK */ {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_ESWITCHES, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column); } /* if there's nothing to declare, why include it? */
+eswitches : KW_ESWITCHES LC switchlist RC {
+		$$ = npval2(PV_ESWITCHES, &amp;@1, &amp;@4);
+		$$-&gt;u1.list = $3; }
+	| KW_ESWITCHES LC  RC { /* empty switch list OK */
+		$$ = npval2(PV_ESWITCHES, &amp;@1, &amp;@3); } /* if there's nothing to declare, why include it? */
 	;
 
-switchlist : word SEMI {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); $$-&gt;u1.str = $1;}
-	| switchlist word SEMI {pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 2.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @2.first_column, @3.last_column); $$=$1; z-&gt;u1.str = $2; linku1($$,z); }
+switchlist : word SEMI {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = $1;}
+	| switchlist word SEMI {
+		pval *z = npval2(PV_WORD, &amp;@2, &amp;@3);
+		z-&gt;u1.str = $2;
+		$$=$1;
+		linku1($$,z); }
 	| switchlist error {$$=$1;}
 	;
 
-includeslist : includedname SEMI {$$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); $$-&gt;u1.str = $1;}
-	| includedname BAR word3_list COLON word3_list COLON word3_list BAR word3_list BAR word3_list BAR word3_list SEMI {
-                    $$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); 
-                    $$-&gt;u1.str = $1;
-					$$-&gt;u2.arglist = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 7.last_line</A>, @3.first_column, @7.last_column); 
-					$$-&gt;u2.arglist-&gt;u1.str = (char*)malloc(strlen($3)+strlen($5)+strlen($7)+4);
-					strcpy($$-&gt;u2.arglist-&gt;u1.str,$3);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,$5);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,$7);
-					free($3);
-					free($5);
-					free($7);
-					$$-&gt;u2.arglist-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 9.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 9.last_line</A>, @9.first_column, @9.last_column); 
-					$$-&gt;u2.arglist-&gt;next-&gt;u1.str = $9; 
-					$$-&gt;u2.arglist-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 11.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 11.last_line</A>, @11.first_column, @11.last_column); 
-					$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $11; 
-					$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 13.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 13.last_line</A>, @13.first_column, @13.last_column); 
-					$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $13; 
-					prev_word=0;
-			}
+includeslist : includedname SEMI {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = $1;}
+	| includedname BAR word3_list COLON word3_list COLON word3_list
+			BAR word3_list BAR word3_list BAR word3_list SEMI {
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.arglist = npval2(PV_WORD, &amp;@3, &amp;@7);
+		asprintf( &amp;($$-&gt;u2.arglist-&gt;u1.str), &quot;%s:%s:%s&quot;, $3, $5, $7);
+		free($3);
+		free($5);
+		free($7);
+		$$-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;@9, &amp;@9);
+		$$-&gt;u2.arglist-&gt;next-&gt;u1.str = $9;
+		$$-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;@11, &amp;@11);
+		$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $11;
+		$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;@13, &amp;@13);
+		$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $13;
+		prev_word=0;
+	}
 	| includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
-                    $$=npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @1.first_column, @2.last_column); 
-                    $$-&gt;u1.str = $1;
-					$$-&gt;u2.arglist = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 3.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @3.first_column, @3.last_column); 
-					$$-&gt;u2.arglist-&gt;u1.str = $3;
-					$$-&gt;u2.arglist-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 5.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 5.last_line</A>, @5.first_column, @5.last_column); 
-					$$-&gt;u2.arglist-&gt;next-&gt;u1.str = $5; 
-					$$-&gt;u2.arglist-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 7.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 7.last_line</A>, @7.first_column, @7.last_column); 
-					$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $7; 
-					$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 9.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 9.last_line</A>, @9.first_column, @9.last_column); 
-					$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $9; 
-					prev_word=0;
-			}
-	| includeslist includedname SEMI {pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 2.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @2.first_column, @3.last_column); $$=$1; z-&gt;u1.str = $2; linku1($$,z); }
-	| includeslist includedname BAR word3_list COLON word3_list COLON word3_list BAR word3_list BAR word3_list BAR word3_list SEMI {pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 2.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @2.first_column, @3.last_column); 
-					$$=$1; z-&gt;u1.str = $2; linku1($$,z);
-					z-&gt;u2.arglist = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 4.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @4.first_column, @4.last_column); 
-					$$-&gt;u2.arglist-&gt;u1.str = (char*)malloc(strlen($4)+strlen($6)+strlen($8)+4);
-					strcpy($$-&gt;u2.arglist-&gt;u1.str,$4);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,$6);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,&quot;:&quot;);
-					strcat($$-&gt;u2.arglist-&gt;u1.str,$8);
-					free($4);
-					free($6);
-					free($8);
-					z-&gt;u2.arglist-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 10.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 10.last_line</A>, @10.first_column, @10.last_column); 
-					z-&gt;u2.arglist-&gt;next-&gt;u1.str = $10; 
-					z-&gt;u2.arglist-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 12.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 12.last_line</A>, @12.first_column, @12.last_column); 
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $12; 
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 14.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 14.last_line</A>, @14.first_column, @14.last_column); 
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $14; 
-					prev_word=0;
-			}
-	| includeslist includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI
-                   {pval *z = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 2.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 2.last_line</A>, @2.first_column, @3.last_column);
-					$$=$1; z-&gt;u1.str = $2; linku1($$,z);
-					z-&gt;u2.arglist = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 4.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @4.first_column, @4.last_column);
-					$$-&gt;u2.arglist-&gt;u1.str = $4;
-					z-&gt;u2.arglist-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 6.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 6.last_line</A>, @6.first_column, @6.last_column);
-					z-&gt;u2.arglist-&gt;next-&gt;u1.str = $6;
-					z-&gt;u2.arglist-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 8.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 8.last_line</A>, @8.first_column, @8.last_column);
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $8;
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_WORD, at 10.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 10.last_line</A>, @10.first_column, @10.last_column);
-					z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $10;
-					prev_word=0;
-			}
+		$$ = npval2(PV_WORD, &amp;@1, &amp;@2);
+		$$-&gt;u1.str = $1;
+		$$-&gt;u2.arglist = npval2(PV_WORD, &amp;@3, &amp;@3);
+		$$-&gt;u2.arglist-&gt;u1.str = $3;
+		$$-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;@5, &amp;@5);
+		$$-&gt;u2.arglist-&gt;next-&gt;u1.str = $5;
+		$$-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;@7, &amp;@7);
+		$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $7;
+		$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;@9, &amp;@9);
+		$$-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $9;
+		prev_word=0;
+	}
+	| includeslist includedname SEMI {
+		pval *z = npval2(PV_WORD, &amp;@2, &amp;@3); /* XXX don't we need @<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">1- at 4</A> ?*/
+		$$=$1;
+		z-&gt;u1.str = $2;
+		linku1($$,z); }
+	| includeslist includedname BAR word3_list COLON word3_list COLON word3_list
+			BAR word3_list BAR word3_list BAR word3_list SEMI {
+		pval *z = npval2(PV_WORD, &amp;@2, &amp;@3);
+		$$=$1; z-&gt;u1.str = $2;
+		linku1($$,z);
+		z-&gt;u2.arglist = npval2(PV_WORD, &amp;@4, &amp;@4);
+		asprintf( &amp;($$-&gt;u2.arglist-&gt;u1.str), &quot;%s:%s:%s&quot;, $4, $6, $8);
+		free($4);
+		free($6);
+		free($8);
+		z-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;@10, &amp;@10);
+		z-&gt;u2.arglist-&gt;next-&gt;u1.str = $10;
+		z-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;@12, &amp;@12);
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $12;
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;@14, &amp;@14);
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $14;
+		prev_word=0;
+	}
+	| includeslist includedname BAR word BAR word3_list BAR word3_list BAR word3_list SEMI {
+		pval *z = npval2(PV_WORD, &amp;@2, &amp;@3);
+		$$=$1;
+		z-&gt;u1.str = $2; linku1($$,z);
+		z-&gt;u2.arglist = npval2(PV_WORD, &amp;@4, &amp;@4);
+		$$-&gt;u2.arglist-&gt;u1.str = $4;
+		z-&gt;u2.arglist-&gt;next = npval2(PV_WORD, &amp;@6, &amp;@6);
+		z-&gt;u2.arglist-&gt;next-&gt;u1.str = $6;
+		z-&gt;u2.arglist-&gt;next-&gt;next = npval2(PV_WORD, &amp;@8, &amp;@8);
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;u1.str = $8;
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next = npval2(PV_WORD, &amp;@10, &amp;@10);
+		z-&gt;u2.arglist-&gt;next-&gt;next-&gt;next-&gt;u1.str = $10;
+		prev_word=0;
+	}
 	| includeslist error {$$=$1;}
 	;
 
 includedname : word { $$ = $1;}
-			| KW_DEFAULT {$$=strdup(&quot;default&quot;);}
-			;
+	| KW_DEFAULT {$$=strdup(&quot;default&quot;);}
+	;
 
-includes : KW_INCLUDES LC includeslist RC {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_INCLUDES, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 4.last_line</A>, @1.first_column, @4.last_column); $$-&gt;u1.list = $3;}
-	| KW_INCLUDES LC RC  {$$= npval(<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">PV_INCLUDES, at 1.first_line</A><A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">, at 3.last_line</A>, @1.first_column, @3.last_column);}
+includes : KW_INCLUDES LC includeslist RC {
+		$$ = npval2(PV_INCLUDES, &amp;@1, &amp;@4);
+		$$-&gt;u1.list = $3;}
+	| KW_INCLUDES LC RC {
+		$$ = npval2(PV_INCLUDES, &amp;@1, &amp;@3);}
 	;
 
 
 %%
 
-static char *token_equivs1[] = 
+static char *token_equivs1[] =
 {
 	&quot;AMPER&quot;,
 	&quot;AT&quot;,
@@ -552,15 +811,15 @@
 	&quot;COMMA&quot;,
 	&quot;EQ&quot;,
 	&quot;EXTENMARK&quot;,
-	&quot;KW_BREAK&quot;, 
-	&quot;KW_CASE&quot;, 
-	&quot;KW_CATCH&quot;, 
+	&quot;KW_BREAK&quot;,
+	&quot;KW_CASE&quot;,
+	&quot;KW_CATCH&quot;,
 	&quot;KW_CONTEXT&quot;,
-	&quot;KW_CONTINUE&quot;, 
-	&quot;KW_DEFAULT&quot;, 
+	&quot;KW_CONTINUE&quot;,
+	&quot;KW_DEFAULT&quot;,
 	&quot;KW_ELSE&quot;,
 	&quot;KW_ESWITCHES&quot;,
-	&quot;KW_FOR&quot;, 
+	&quot;KW_FOR&quot;,
 	&quot;KW_GLOBALS&quot;,
 	&quot;KW_GOTO&quot;,
 	&quot;KW_HINT&quot;,
@@ -570,12 +829,12 @@
 	&quot;KW_INCLUDES&quot;
 	&quot;KW_JUMP&quot;,
 	&quot;KW_MACRO&quot;,
-	&quot;KW_PATTERN&quot;, 
-	&quot;KW_REGEXTEN&quot;, 
-	&quot;KW_RETURN&quot;, 
-	&quot;KW_SWITCHES&quot;, 
+	&quot;KW_PATTERN&quot;,
+	&quot;KW_REGEXTEN&quot;,
+	&quot;KW_RETURN&quot;,
+	&quot;KW_SWITCHES&quot;,
 	&quot;KW_SWITCH&quot;,
-	&quot;KW_WHILE&quot;, 
+	&quot;KW_WHILE&quot;,
 	&quot;LC&quot;,
 	&quot;LP&quot;,
 	&quot;RC&quot;,
@@ -583,7 +842,7 @@
 	&quot;SEMI&quot;,
 };
 
-static char *token_equivs2[] = 
+static char *token_equivs2[] =
 {
 	&quot;&amp;&quot;,
 	&quot;@&quot;,
@@ -592,15 +851,15 @@
 	&quot;,&quot;,
 	&quot;=&quot;,
 	&quot;=&gt;&quot;,
-	&quot;break&quot;, 
-	&quot;case&quot;, 
-	&quot;catch&quot;, 
+	&quot;break&quot;,
+	&quot;case&quot;,
+	&quot;catch&quot;,
 	&quot;context&quot;,
-	&quot;continue&quot;, 
-	&quot;default&quot;, 
+	&quot;continue&quot;,
+	&quot;default&quot;,
 	&quot;else&quot;,
 	&quot;eswitches&quot;,
-	&quot;for&quot;, 
+	&quot;for&quot;,
 	&quot;globals&quot;,
 	&quot;goto&quot;,
 	&quot;hint&quot;,
@@ -610,12 +869,12 @@
 	&quot;includes&quot;
 	&quot;jump&quot;,
 	&quot;macro&quot;,
-	&quot;pattern&quot;, 
-	&quot;regexten&quot;, 
-	&quot;return&quot;, 
-	&quot;switches&quot;, 
+	&quot;pattern&quot;,
+	&quot;regexten&quot;,
+	&quot;return&quot;,
+	&quot;switches&quot;,
 	&quot;switch&quot;,
-	&quot;while&quot;, 
+	&quot;while&quot;,
 	&quot;{&quot;,
 	&quot;(&quot;,
 	&quot;}&quot;,
@@ -643,7 +902,7 @@
 		}
 		len++;
 	}
-	res = (char*)malloc(len+1);
+	res = ast_calloc(1, len+1);
 	res[0] = 0;
 	s = res;
 	for (p=mess; *p;) {
@@ -679,10 +938,11 @@
 	parseio-&gt;syntax_error_count++;
 }
 
-struct pval *npval(pvaltype type,int first_line, int last_line, int first_column, int last_column)
+static struct pval *npval(pvaltype type, int first_line, int last_line,
+	int first_column, int last_column)
 {
 	extern char *my_file;
-	pval *z = (pval *)calloc(sizeof(struct pval),1);
+	pval *z = ast_calloc(1, sizeof(struct pval));
 	z-&gt;type = type;
 	z-&gt;startline = first_line;
 	z-&gt;endline = last_line;
@@ -692,14 +952,23 @@
 	return z;
 }
 
-void linku1(pval *head, pval *tail)
+static struct pval *npval2(pvaltype type, YYLTYPE *first, YYLTYPE *last)
 {
+	return npval(type, first-&gt;first_line, last-&gt;last_line,
+			first-&gt;first_column, last-&gt;last_column);
+}
+
+/* append second element to the list in the first one */
+static pval * linku1(pval *head, pval *tail)
+{
+	if (!head)
+		return tail;
 	if (!head-&gt;next) {
 		head-&gt;next = tail;
-		head-&gt;u1_last = tail;
 	} else {
 		head-&gt;u1_last-&gt;next = tail;
-		head-&gt;u1_last = tail;
 	}
+	head-&gt;u1_last = tail;
+	return head;
 }
 

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/ael/ael_lex.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -356,8 +356,8 @@
 	*yy_cp = '\0'; \
 	yyg-&gt;yy_c_buf_p = yy_cp;
 
-#define YY_NUM_RULES 65
-#define YY_END_OF_BUFFER 66
+#define YY_NUM_RULES 55
+#define YY_END_OF_BUFFER 56
 /* This struct is not used in this scanner,
    but its presence is necessary. */
 struct yy_trans_info
@@ -365,21 +365,19 @@
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static yyconst flex_int16_t yy_accept[226] =
+static yyconst flex_int16_t yy_accept[206] =
     {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,   66,   65,
+        0,    0,    0,    0,    0,    0,    0,    0,   56,   55,
        42,   40,   41,   43,   43,    9,    3,    4,    7,   43,
         8,    5,    6,   12,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,    1,
-       10,    2,   65,   45,   44,   46,   47,   48,   49,   65,
-       61,   62,   63,   57,   58,   59,   60,   65,   51,   50,
-       52,   55,   56,   53,   54,   42,   41,   43,   43,   13,
+       10,    2,   55,   45,   44,   46,   55,   51,   52,   53,
+       55,   47,   48,   49,   50,   42,   41,   43,   43,   13,
        11,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   20,   43,   43,   43,   43,   43,   43,   43,
-       43,   43,    0,   45,   44,   46,   47,   48,   49,    0,
+       43,   43,    0,   45,   44,   46,    0,   51,   52,   53,
+        0,   47,   48,   49,   50,   43,   13,   13,   43,   43,
 
-       61,   62,   63,   57,   58,   59,   60,    0,   51,   50,
-       52,   55,   56,   53,   54,   43,   13,   13,   43,   43,
        43,   43,   43,   43,   43,   43,   31,   43,   43,   43,
        43,   43,   43,   43,   43,   43,   43,   43,   43,   43,
        43,   43,   43,   43,   33,   43,   43,   43,   25,   43,
@@ -388,10 +386,10 @@
        43,   43,   43,   43,   43,   43,   16,   43,   43,   43,
        43,   43,   32,   43,   43,   43,   43,   43,   43,   43,
        21,   43,   43,   43,   22,   43,   28,   19,   43,   43,
-
        14,   43,   34,   43,   17,   43,   43,   35,   43,   43,
        43,   15,   30,   43,   43,   39,   23,   37,    0,   38,
-       18,    0,    0,   64,    0
+
+       18,    0,    0,   54,    0
     } ;
 
 static yyconst flex_int32_t yy_ec[256] =
@@ -435,21 +433,19 @@
         3,    3,    3,    1,    3
     } ;
 
-static yyconst flex_int16_t yy_base[236] =
+static yyconst flex_int16_t yy_base[216] =
     {   0,
         0,    0,   37,   40,   77,  114,  151,  188,  237,  507,
       234,  507,  228,    0,  201,  507,  507,  507,  507,  217,
       507,  507,  212,  507,  205,  189,   27,  200,   20,  189,
        19,  194,   37,  182,  200,  199,   40,  178,  190,  507,
-      507,  507,   57,  507,  507,  507,  507,  507,  507,  225,
-      507,  507,  507,  507,  507,  507,  507,  262,  507,  507,
-      507,  507,  507,  507,  507,  215,  212,    0,  181,  307,
+      507,  507,   57,  507,  507,  507,  225,  507,  507,  507,
+      262,  507,  507,  507,  507,  215,  212,    0,  181,  307,
       507,  176,  188,   30,  178,  185,  172,  168,  169,  170,
       165,  169,  184,  167,  177,  162,  170,  153,  157,   45,
-      161,  160,   69,  507,  507,  507,  507,  507,  507,  343,
+      161,  160,   69,  507,  507,  507,  343,  507,  507,  507,
+      380,  507,  507,  507,  507,  165,    0,  425,  148,  165,
 
-      507,  507,  507,  507,  507,  507,  507,  380,  507,  507,
-      507,  507,  507,  507,  507,  165,    0,  425,  148,  165,
       160,  161,  144,  161,  156,  151,    0,  157,  143,  138,
       147,  140,  142,  137,  135,  130,  144,  142,  126,  126,
       132,  131,  121,  125,    0,  127,   45,  114,    0,  114,
@@ -458,41 +454,39 @@
       105,  113,  103,  107,  106,  106,    0,   92,   94,   87,
        91,   93,    0,   95,   95,   78,   76,   76,   85,   73,
         0,   74,   84,   74,    0,   82,    0,   81,   80,   65,
-
         0,   78,    0,   76,    0,   78,   60,    0,   61,   55,
        51,    0,    0,   43,   36,    0,    0,    0,   88,    0,
+
         0,    0,   67,  507,  507,  469,  473,  477,  479,  483,
       487,  491,  495,  499,  503
     } ;
 
-static yyconst flex_int16_t yy_def[236] =
+static yyconst flex_int16_t yy_def[216] =
     {   0,
-      225,    1,  226,  226,  227,  227,  228,  228,  225,  225,
-      225,  225,  225,  229,  229,  225,  225,  225,  225,  229,
-      225,  225,  225,  225,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  225,
-      225,  225,  230,  225,  225,  225,  225,  225,  225,  231,
-      225,  225,  225,  225,  225,  225,  225,  232,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  229,  229,  233,
-      225,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  230,  225,  225,  225,  225,  225,  225,  231,
+      205,    1,  206,  206,  207,  207,  208,  208,  205,  205,
+      205,  205,  205,  209,  209,  205,  205,  205,  205,  209,
+      205,  205,  205,  205,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  205,
+      205,  205,  210,  205,  205,  205,  211,  205,  205,  205,
+      212,  205,  205,  205,  205,  205,  205,  209,  209,  213,
+      205,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  210,  205,  205,  205,  211,  205,  205,  205,
+      212,  205,  205,  205,  205,  209,  214,  213,  209,  209,
 
-      225,  225,  225,  225,  225,  225,  225,  232,  225,  225,
-      225,  225,  225,  225,  225,  229,  234,  233,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  209,  209,
+      209,  209,  209,  209,  209,  209,  209,  209,  205,  209,
 
-      229,  229,  229,  229,  229,  229,  229,  229,  229,  229,
-      229,  229,  229,  229,  229,  229,  229,  229,  225,  229,
-      229,  235,  235,  225,    0,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225
+      209,  215,  215,  205,    0,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205
     } ;
 
 static yyconst flex_int16_t yy_nxt[553] =
@@ -501,63 +495,63 @@
        19,   20,   21,   22,   23,   14,   24,   14,   14,   14,
        25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
        14,   14,   35,   14,   14,   36,   37,   38,   14,   14,
-       39,   14,   40,   41,   42,   44,   45,   74,   44,   45,
-       80,   77,  219,   81,  219,   46,   47,   78,   46,   47,
-       89,   75,   83,   84,   90,   94,   95,  121,  122,  169,
-       85,  138,  224,  170,  221,   96,   97,   94,   95,   48,
-      220,   49,   48,  139,   49,   51,   52,   96,   97,  219,
-       53,  219,  218,  222,  217,   54,   55,  216,  215,   98,
+       39,   14,   40,   41,   42,   44,   45,   64,   44,   45,
+       70,   67,  199,   71,  199,   44,   46,   68,   44,   46,
+       79,   65,   73,   74,   80,   84,   85,  101,  102,  149,
+       75,  118,  204,  150,  201,   84,   86,   84,   85,   44,
+      200,   46,   44,  119,   46,   48,   49,   84,   86,  199,
+       50,  199,  198,  202,  197,   48,   49,  196,  195,   84,
 
-      214,   99,  213,  212,  211,  210,  209,  208,  207,  206,
-      205,   98,  204,   99,  203,  202,  201,  200,  199,   56,
-      198,   57,   51,   52,  197,  196,  195,   53,  194,  193,
-      192,  191,   54,   55,  190,  189,  188,  187,  186,  185,
-      184,  183,  182,  181,  180,  179,  178,  177,  176,  175,
-      174,  173,  172,  171,  168,  167,   56,  166,   57,   59,
-       60,   61,  165,  164,  163,  162,  161,  160,  159,   62,
-       63,  158,  157,  156,  155,  154,  153,  152,  151,  150,
-      149,  148,  147,  146,  145,  144,  143,  142,  141,  140,
-      137,  136,  135,   64,  134,   65,   59,   60,   61,  133,
+      194,   86,  193,  192,  191,  190,  189,  188,  187,  186,
+      185,   84,  184,   86,  183,  182,  181,  180,  179,   48,
+      178,   49,   48,   49,  177,  176,  175,   50,  174,  173,
+      172,  171,   48,   49,  170,  169,  168,  167,  166,  165,
+      164,  163,  162,  161,  160,  159,  158,  157,  156,  155,
+      154,  153,  152,  151,  148,  147,   48,  146,   49,   52,
+       53,   54,  145,  144,  143,  142,  141,  140,  139,   52,
+       55,  138,  137,  136,  135,  134,  133,  132,  131,  130,
+      129,  128,  127,  126,  125,  124,  123,  122,  121,  120,
+      117,  116,  115,   52,  114,   55,   52,   53,   54,  113,
 
-      132,  131,  130,  129,  128,  127,   62,   63,  126,  125,
-      124,  123,  120,  119,  116,   67,   66,   92,   91,   88,
-       87,   86,   82,   79,   76,   73,   72,   71,   70,   69,
-       64,   67,   65,  101,  102,   66,  225,  225,  103,  225,
-      225,  225,  225,  104,  105,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  106,  225,  107,
-      109,  110,  111,  225,  225,  225,  225,  225,  225,  225,
-      112,  113,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
+      112,  111,  110,  109,  108,  107,   52,   55,  106,  105,
+      104,  103,  100,   99,   96,   57,   56,   82,   81,   78,
+       77,   76,   72,   69,   66,   63,   62,   61,   60,   59,
+       52,   57,   55,   88,   89,   56,  205,  205,   90,  205,
+      205,  205,  205,   88,   89,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,   88,  205,   89,
+       92,   93,   94,  205,  205,  205,  205,  205,  205,  205,
+       92,   95,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
 
-      225,  225,  225,  225,  114,  225,  115,  117,  117,  225,
-      117,  225,  225,  225,  117,  117,  117,  117,  225,  117,
-      117,  117,  225,  117,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      117,  101,  102,  225,  225,  225,  103,  225,  225,  225,
-      225,  104,  105,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  106,  225,  107,  109,  110,
-      111,  225,  225,  225,  225,  225,  225,  225,  112,  113,
+      205,  205,  205,  205,   92,  205,   95,   97,   97,  205,
+       97,  205,  205,  205,   97,   97,   97,   97,  205,   97,
+       97,   97,  205,   97,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+       97,   88,   89,  205,  205,  205,   90,  205,  205,  205,
+      205,   88,   89,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,   88,  205,   89,   92,   93,
+       94,  205,  205,  205,  205,  205,  205,  205,   92,   95,
 
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  114,  225,  115,  117,  117,  225,  117,  225,
-      225,  225,  117,  117,  117,  117,  225,  117,  117,  117,
-      225,  117,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  117,   43,
-       43,   43,   43,   50,   50,   50,   50,   58,   58,   58,
-       58,   68,   68,   93,   93,   93,   93,  100,  100,  100,
-      100,  108,  108,  108,  108,  118,  225,  118,  118,  117,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,   92,  205,   95,   97,   97,  205,   97,  205,
+      205,  205,   97,   97,   97,   97,  205,   97,   97,   97,
+      205,   97,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,   97,   43,
+       43,   43,   43,   47,   47,   47,   47,   51,   51,   51,
+       51,   58,   58,   83,   83,   83,   83,   87,   87,   87,
+       87,   91,   91,   91,   91,   98,  205,   98,   98,   97,
 
-      225,  117,  117,  223,  223,  223,    9,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225
+      205,   97,   97,  203,  203,  203,    9,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205
     } ;
 
 static yyconst flex_int16_t yy_chk[553] =
@@ -567,62 +561,62 @@
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    3,    3,   27,    4,    4,
-       31,   29,  211,   31,  211,    3,    3,   29,    4,    4,
-       37,   27,   33,   33,   37,   43,   43,   74,   74,  147,
-       33,   90,  223,  147,  215,   43,   43,   93,   93,    3,
-      214,    3,    4,   90,    4,    5,    5,   93,   93,  219,
-        5,  219,  210,  219,  209,    5,    5,  207,  206,   43,
+       31,   29,  191,   31,  191,    3,    3,   29,    4,    4,
+       37,   27,   33,   33,   37,   43,   43,   64,   64,  127,
+       33,   80,  203,  127,  195,   43,   43,   83,   83,    3,
+      194,    3,    4,   80,    4,    5,    5,   83,   83,  199,
+        5,  199,  190,  199,  189,    5,    5,  187,  186,   43,
 
-      204,   43,  202,  200,  199,  198,  196,  194,  193,  192,
-      190,   93,  189,   93,  188,  187,  186,  185,  184,    5,
-      182,    5,    6,    6,  181,  180,  179,    6,  178,  176,
-      175,  174,    6,    6,  173,  172,  171,  170,  169,  166,
-      165,  164,  163,  162,  161,  160,  159,  158,  156,  155,
-      154,  151,  150,  148,  146,  144,    6,  143,    6,    7,
-        7,    7,  142,  141,  140,  139,  138,  137,  136,    7,
-        7,  135,  134,  133,  132,  131,  130,  129,  128,  126,
-      125,  124,  123,  122,  121,  120,  119,  116,   92,   91,
-       89,   88,   87,    7,   86,    7,    8,    8,    8,   85,
+      184,   43,  182,  180,  179,  178,  176,  174,  173,  172,
+      170,   83,  169,   83,  168,  167,  166,  165,  164,    5,
+      162,    5,    6,    6,  161,  160,  159,    6,  158,  156,
+      155,  154,    6,    6,  153,  152,  151,  150,  149,  146,
+      145,  144,  143,  142,  141,  140,  139,  138,  136,  135,
+      134,  131,  130,  128,  126,  124,    6,  123,    6,    7,
+        7,    7,  122,  121,  120,  119,  118,  117,  116,    7,
+        7,  115,  114,  113,  112,  111,  110,  109,  108,  106,
+      105,  104,  103,  102,  101,  100,   99,   96,   82,   81,
+       79,   78,   77,    7,   76,    7,    8,    8,    8,   75,
 
-       84,   83,   82,   81,   80,   79,    8,    8,   78,   77,
-       76,   75,   73,   72,   69,   67,   66,   39,   38,   36,
+       74,   73,   72,   71,   70,   69,    8,    8,   68,   67,
+       66,   65,   63,   62,   59,   57,   56,   39,   38,   36,
        35,   34,   32,   30,   28,   26,   25,   23,   20,   15,
-        8,   13,    8,   50,   50,   11,    9,    0,   50,    0,
-        0,    0,    0,   50,   50,    0,    0,    0,    0,    0,
+        8,   13,    8,   47,   47,   11,    9,    0,   47,    0,
+        0,    0,    0,   47,   47,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,   50,    0,   50,
-       58,   58,   58,    0,    0,    0,    0,    0,    0,    0,
-       58,   58,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,    0,    0,    0,   47,    0,   47,
+       51,   51,   51,    0,    0,    0,    0,    0,    0,    0,
+       51,   51,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
 
-        0,    0,    0,    0,   58,    0,   58,   70,   70,    0,
-       70,    0,    0,    0,   70,   70,   70,   70,    0,   70,
-       70,   70,    0,   70,    0,    0,    0,    0,    0,    0,
+        0,    0,    0,    0,   51,    0,   51,   60,   60,    0,
+       60,    0,    0,    0,   60,   60,   60,   60,    0,   60,
+       60,   60,    0,   60,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       70,  100,  100,    0,    0,    0,  100,    0,    0,    0,
-        0,  100,  100,    0,    0,    0,    0,    0,    0,    0,
+       60,   87,   87,    0,    0,    0,   87,    0,    0,    0,
+        0,   87,   87,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,  100,    0,  100,  108,  108,
-      108,    0,    0,    0,    0,    0,    0,    0,  108,  108,
+        0,    0,    0,    0,    0,   87,    0,   87,   91,   91,
+       91,    0,    0,    0,    0,    0,    0,    0,   91,   91,
 
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,  108,    0,  108,  118,  118,    0,  118,    0,
-        0,    0,  118,  118,  118,  118,    0,  118,  118,  118,
-        0,  118,    0,    0,    0,    0,    0,    0,    0,    0,
+        0,    0,   91,    0,   91,   98,   98,    0,   98,    0,
+        0,    0,   98,   98,   98,   98,    0,   98,   98,   98,
+        0,   98,    0,    0,    0,    0,    0,    0,    0,    0,
         0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-        0,    0,    0,    0,    0,    0,    0,    0,  118,  226,
-      226,  226,  226,  227,  227,  227,  227,  228,  228,  228,
-      228,  229,  229,  230,  230,  230,  230,  231,  231,  231,
-      231,  232,  232,  232,  232,  233,    0,  233,  233,  234,
+        0,    0,    0,    0,    0,    0,    0,    0,   98,  206,
+      206,  206,  206,  207,  207,  207,  207,  208,  208,  208,
+      208,  209,  209,  210,  210,  210,  210,  211,  211,  211,
+      211,  212,  212,  212,  212,  213,    0,  213,  213,  214,
 
-        0,  234,  234,  235,  235,  235,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225,  225,  225,  225,  225,  225,  225,  225,  225,
-      225,  225
+        0,  214,  214,  215,  215,  215,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205,  205,  205,  205,  205,  205,  205,  205,  205,
+      205,  205
     } ;
 
 /* The intent behind this definition is that it'll catch
@@ -633,7 +627,6 @@
 #define YY_MORE_ADJ yyg-&gt;yy_more_len
 #define YY_RESTORE_YY_MORE_OFFSET
 #line 1 &quot;ael.flex&quot;
-#line 2 &quot;ael.flex&quot;
 /*
  * Asterisk -- An open source telephony toolkit.
  *
@@ -654,8 +647,32 @@
 /*! \file
  *
  * \brief Flex scanner description of tokens used in AEL2 .
- * 
- */#include &lt;sys/types.h&gt;
+ *
+ */
+/*
+ * Start with flex options:
+ *
+ * %x describes the contexts we have: paren, semic and argg, plus INITIAL
+ */
+
+/* prefix used for various globally-visible functions and variables.
+ * This renames also ael_yywrap, but since we do not use it, we just
+ * add option noyywrap to remove it.
+ */
+/* batch gives a bit more performance if we are using it in
+ * a non-interactive mode. We probably don't care much.
+ */
+/* outfile is the filename to be used instead of lex.yy.c */
+/*
+ * These are not supported in flex 2.5.4, but we need them
+ * at the moment:
+ * reentrant produces a thread-safe parser. Not 100% sure that
+ * we require it, though.
+ * bison-bridge passes an additional yylval argument to ael_yylex().
+ * bison-locations is probably not needed.
+ */
+#line 59 &quot;ael.flex&quot;
+#include &lt;sys/types.h&gt;
 #include &lt;sys/stat.h&gt;
 #include &lt;unistd.h&gt;
 
@@ -664,43 +681,103 @@
 #include &quot;ael/ael.tab.h&quot;
 #include &quot;asterisk/ael_structs.h&quot;
 
-static char pbcstack[400];
+/*
+ * A stack to keep track of matching brackets ( [ { } ] )
+ */
+static char pbcstack[400];	/* XXX missing size checks */
 static int pbcpos = 0;
 
 static int parencount = 0;
 static int commaout = 0;
-int my_lineno = 1;
-int my_col = 0;
-char *my_file = 0;
-char *prev_word;
+
+/*
+ * current line, column and filename, updated as we read the input.
+ */
+static int my_lineno = 1;	/* current line in the source */
+static int my_col = 1;		/* current column in the source */
+char *my_file = 0;		/* used also in the bison code */
+char *prev_word;		/* XXX document it */
+
 #define MAX_INCLUDE_DEPTH 50
 
-void reset_parencount(yyscan_t yyscanner );
-void reset_semicount(yyscan_t yyscanner );
-void reset_argcount(yyscan_t yyscanner );
-struct pval *ael2_parse(char *filename, int *errors);
+/*
+ * flex is not too smart, and generates global functions
+ * without prototypes so the compiler may complain.
+ * To avoid that, we declare the prototypes here,
+ * even though these functions are not used.
+ */
 int ael_yyget_column  (yyscan_t yyscanner);
 void ael_yyset_column (int  column_no , yyscan_t yyscanner);
+
 int ael_yyparse (struct parse_io *);
 static void pbcpush(char x);
 static int pbcpop(char x);
-static void pbcwhere(char *text, int *line, int *col );
-static int c_prevword(void);
 
-struct stackelement
-{
-     char *fname;
-	 int lineno;
-     int colno;
-	 YY_BUFFER_STATE bufstate;
+/*
+ * A stack to process include files.
+ * As we switch into the new file we need to store the previous
+ * state to restore it later.
+ */
+struct stackelement {
+	char *fname;
+	int lineno;
+	int colno;
+	YY_BUFFER_STATE bufstate;
 };
-struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
-int include_stack_index = 0;
 
+static struct stackelement  include_stack[MAX_INCLUDE_DEPTH];
+static int include_stack_index = 0;
 
-/* %option yylineno I've tried hard, but haven't been able to use this */
-#line 703 &quot;ael_lex.c&quot;
+/*
+ * if we use the @n feature of bison, we must supply the start/end
+ * location of tokens in the structure pointed by yylloc.
+ * Simple tokens are just assumed to be on the same line, so
+ * the line number is constant, and the column is incremented
+ * by the length of the token.
+ */
+#ifdef FLEX_BETA	/* set for 2.5.33 */
 
+/* compute the total number of lines and columns in the text
+ * passed as argument.
+ */
+static void pbcwhere(const char *text, int *line, int *col )
+{
+	int loc_line = *line;
+	int loc_col = *col;
+	char c;
+	while ( (c = *text++) ) {
+		if ( c == '\t' ) {
+			loc_col += 8 - (loc_col % 8);
+		} else if ( c == '\n' ) {
+			loc_line++;
+			loc_col = 1;
+		} else
+			loc_col++;
+	}
+	*line = loc_line;
+	*col = loc_col;
+}
+
+#define	STORE_POS do {							\
+		yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno;	\
+		yylloc-&gt;first_column=my_col;				\
+		yylloc-&gt;last_column=my_col+yyleng-1;			\
+		my_col+=yyleng;						\
+	} while (0)
+
+#define	STORE_LOC do {					\
+		yylloc-&gt;first_line = my_lineno;		\
+		yylloc-&gt;first_column=my_col;		\
+		pbcwhere(yytext, &amp;my_lineno, &amp;my_col);	\
+		yylloc-&gt;last_line = my_lineno;		\
+		yylloc-&gt;last_column = my_col - 1;	\
+	} while (0)
+#else
+#define	STORE_POS
+#define	STORE_LOC
+#endif
+#line 780 &quot;ael_lex.c&quot;
+
 #define INITIAL 0
 #define paren 1
 #define semic 2
@@ -939,10 +1016,11 @@
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 77 &quot;ael.flex&quot;
+#line 172 &quot;ael.flex&quot;
 
-#line 945 &quot;ael_lex.c&quot;
 
+#line 1023 &quot;ael_lex.c&quot;
+
     yylval = yylval_param;
 
     yylloc = yylloc_param;
@@ -1004,13 +1082,13 @@
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state &gt;= 226 )
+				if ( yy_current_state &gt;= 206 )
 					yy_c = yy_meta[(unsigned int) yy_c];
 				}
 			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_current_state != 225 );
+		while ( yy_current_state != 205 );
 		yy_cp = yyg-&gt;yy_last_accepting_cpos;
 		yy_current_state = yyg-&gt;yy_last_accepting_state;
 
@@ -1032,703 +1110,503 @@
 
 case 1:
 YY_RULE_SETUP
-#line 78 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return LC;}
+#line 174 &quot;ael.flex&quot;
+{ STORE_POS; return LC;}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 79 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return RC;}
+#line 175 &quot;ael.flex&quot;
+{ STORE_POS; return RC;}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 80 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return LP;}
+#line 176 &quot;ael.flex&quot;
+{ STORE_POS; return LP;}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 81 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return RP;}
+#line 177 &quot;ael.flex&quot;
+{ STORE_POS; return RP;}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 82 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return SEMI;}
+#line 178 &quot;ael.flex&quot;
+{ STORE_POS; return SEMI;}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 83 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return EQ;}
+#line 179 &quot;ael.flex&quot;
+{ STORE_POS; return EQ;}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 84 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return COMMA;}
+#line 180 &quot;ael.flex&quot;
+{ STORE_POS; return COMMA;}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 85 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return COLON;}
+#line 181 &quot;ael.flex&quot;
+{ STORE_POS; return COLON;}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 86 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return AMPER;}
+#line 182 &quot;ael.flex&quot;
+{ STORE_POS; return AMPER;}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 87 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return BAR;}
+#line 183 &quot;ael.flex&quot;
+{ STORE_POS; return BAR;}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 88 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return EXTENMARK;}
+#line 184 &quot;ael.flex&quot;
+{ STORE_POS; return EXTENMARK;}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 89 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return AT;}
+#line 185 &quot;ael.flex&quot;
+{ STORE_POS; return AT;}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 90 &quot;ael.flex&quot;
+#line 186 &quot;ael.flex&quot;
 {/*comment*/}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 91 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CONTEXT;}
+#line 187 &quot;ael.flex&quot;
+{ STORE_POS; return KW_CONTEXT;}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 92 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_ABSTRACT;}
+#line 188 &quot;ael.flex&quot;
+{ STORE_POS; return KW_ABSTRACT;}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 93 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_MACRO;};
+#line 189 &quot;ael.flex&quot;
+{ STORE_POS; return KW_MACRO;};
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 94 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_GLOBALS;}
+#line 190 &quot;ael.flex&quot;
+{ STORE_POS; return KW_GLOBALS;}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 95 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_IGNOREPAT;}
+#line 191 &quot;ael.flex&quot;
+{ STORE_POS; return KW_IGNOREPAT;}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 96 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_SWITCH;}
+#line 192 &quot;ael.flex&quot;
+{ STORE_POS; return KW_SWITCH;}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 97 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_IF;}
+#line 193 &quot;ael.flex&quot;
+{ STORE_POS; return KW_IF;}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 98 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_IFTIME;}
+#line 194 &quot;ael.flex&quot;
+{ STORE_POS; return KW_IFTIME;}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 99 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_RANDOM;}
+#line 195 &quot;ael.flex&quot;
+{ STORE_POS; return KW_RANDOM;}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 100 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_REGEXTEN;}
+#line 196 &quot;ael.flex&quot;
+{ STORE_POS; return KW_REGEXTEN;}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 101 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_HINT;}
+#line 197 &quot;ael.flex&quot;
+{ STORE_POS; return KW_HINT;}
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 102 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_ELSE;}
+#line 198 &quot;ael.flex&quot;
+{ STORE_POS; return KW_ELSE;}
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 103 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_GOTO;}
+#line 199 &quot;ael.flex&quot;
+{ STORE_POS; return KW_GOTO;}
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 104 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_JUMP;}
+#line 200 &quot;ael.flex&quot;
+{ STORE_POS; return KW_JUMP;}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 105 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_RETURN;}
+#line 201 &quot;ael.flex&quot;
+{ STORE_POS; return KW_RETURN;}
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 106 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_BREAK;}
+#line 202 &quot;ael.flex&quot;
+{ STORE_POS; return KW_BREAK;}
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 107 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CONTINUE;}
+#line 203 &quot;ael.flex&quot;
+{ STORE_POS; return KW_CONTINUE;}
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 108 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_FOR;}
+#line 204 &quot;ael.flex&quot;
+{ STORE_POS; return KW_FOR;}
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 109 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_WHILE;}
+#line 205 &quot;ael.flex&quot;
+{ STORE_POS; return KW_WHILE;}
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 110 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CASE;}
+#line 206 &quot;ael.flex&quot;
+{ STORE_POS; return KW_CASE;}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 111 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_DEFAULT;}
+#line 207 &quot;ael.flex&quot;
+{ STORE_POS; return KW_DEFAULT;}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 112 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_PATTERN;}
+#line 208 &quot;ael.flex&quot;
+{ STORE_POS; return KW_PATTERN;}
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 113 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_CATCH;}
+#line 209 &quot;ael.flex&quot;
+{ STORE_POS; return KW_CATCH;}
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 114 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_SWITCHES;}
+#line 210 &quot;ael.flex&quot;
+{ STORE_POS; return KW_SWITCHES;}
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 115 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_ESWITCHES;}
+#line 211 &quot;ael.flex&quot;
+{ STORE_POS; return KW_ESWITCHES;}
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 116 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno; yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col;my_col+=yyleng;return KW_INCLUDES;}
+#line 212 &quot;ael.flex&quot;
+{ STORE_POS; return KW_INCLUDES;}
 	YY_BREAK
 case 40:
 /* rule 40 can match eol */
 YY_RULE_SETUP
-#line 118 &quot;ael.flex&quot;
-{my_lineno++;my_col=0;}
+#line 214 &quot;ael.flex&quot;
+{ my_lineno++; my_col = 1; }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 119 &quot;ael.flex&quot;
-{/* nothing */ my_col+=yyleng;}
+#line 215 &quot;ael.flex&quot;
+{ my_col += yyleng; }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 120 &quot;ael.flex&quot;
-{/* nothing */ int wid = 8-(my_col%8); my_col+=wid;}
+#line 216 &quot;ael.flex&quot;
+{ my_col += (yyleng*8)-(my_col%8); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 122 &quot;ael.flex&quot;
+#line 218 &quot;ael.flex&quot;
 {
-                                               yylloc-&gt;first_line = yylloc-&gt;last_line = my_lineno;yylloc-&gt;last_column=my_col+yyleng-1; yylloc-&gt;first_column=my_col; /* set up the ptr */
-                                               yylval-&gt;str = strdup(yytext);  
-                                               /* printf(&quot;\nGot WORD %s[%d][%d:%d]\n&quot;, yylval-&gt;str, my_lineno ,yylloc-&gt;first_column,yylloc-&gt;last_column );  */
-                                               my_col+=yyleng; 
-                                               prev_word = yylval-&gt;str;
-                                               return word;
-                                        }
+		STORE_POS;
+		yylval-&gt;str = strdup(yytext);
+		prev_word = yylval-&gt;str;
+		return word;
+	}
 	YY_BREAK
 case 44:
 /* rule 44 can match eol */
 YY_RULE_SETUP
-#line 131 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = my_lineno; yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n&quot;, my_file, my_lineno+l4, c4, yytext);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             prev_word = 0;
-                             return word;
-                         }
-                 parencount--;
-                 if ( parencount &gt;= 0) {
-                   yymore();
-                 } else { 
-                   int l4,c4;
-                   pbcwhere(yytext, &amp;l4, &amp;c4);
-                   yylloc-&gt;last_line = my_lineno+l4;
-				   yylloc-&gt;last_column=c4; 
-                   yylval-&gt;str = strdup(yytext); 
-                   *(yylval-&gt;str+strlen(yylval-&gt;str)-1)=0;
-                   /* printf(&quot;Got paren word %s\n&quot;, yylval-&gt;str); */ 
-                   unput(')'); 
-	               my_col=c4;
-                   my_lineno += l4;
-                   BEGIN(0); 
-                   return word;
-                 } 
-                }
+#line 228 &quot;ael.flex&quot;
+{
+		if ( pbcpop(')') ) {	/* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression: %s !\n&quot;, my_file, my_lineno, my_col, yytext);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			prev_word = 0;
+			return word;
+		}
+		parencount--;
+		if ( parencount &gt;= 0) {
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval-&gt;str = strdup(yytext);
+			*(yylval-&gt;str+strlen(yylval-&gt;str)-1)=0;
+			/* printf(&quot;Got paren word %s\n&quot;, yylval-&gt;str); */
+			unput(')');
+			BEGIN(0);
+			return word;
+		}
+	}
 	YY_BREAK
 case 45:
 /* rule 45 can match eol */
 YY_RULE_SETUP
-#line 165 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = my_lineno; yylloc-&gt;first_column=my_col; 
-                  parencount++; pbcpush('(');
-                  yymore();
-                 }
+#line 251 &quot;ael.flex&quot;
+{
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 	YY_BREAK
 case 46:
 /* rule 46 can match eol */
 YY_RULE_SETUP
-#line 169 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('['); }
+#line 259 &quot;ael.flex&quot;
+{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c))  { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n&quot;,
+				my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 	YY_BREAK
 case 47:
 /* rule 47 can match eol */
 YY_RULE_SETUP
-#line 170 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ']' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
+#line 272 &quot;ael.flex&quot;
+{
+		char c = yytext[yyleng-1];
+		if (c == '(')
+			parencount++;
+		pbcpush(c);
+		yymore();
+	}
 	YY_BREAK
 case 48:
 /* rule 48 can match eol */
 YY_RULE_SETUP
-#line 186 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col;  yymore(); pbcpush('{'); }
+#line 280 &quot;ael.flex&quot;
+{
+		if ( pbcpop(')') ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression!\n&quot;, my_file, my_lineno, my_col);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+
+		parencount--;
+		if( parencount &gt;= 0){
+			yymore();
+		} else {
+			STORE_LOC;
+			yylval-&gt;str = strdup(yytext);
+			if(yyleng &gt; 1 )
+				*(yylval-&gt;str+yyleng-1)=0;
+			BEGIN(0);
+			if ( !strcmp(yylval-&gt;str,&quot;)&quot;) ) {
+				free(yylval-&gt;str);
+				yylval-&gt;str = 0;
+				my_col++; /* XXX why ? */
+				return RP;
+			} else {
+				unput(')');
+				return word;
+			}
+		}
+	}
 	YY_BREAK
 case 49:
 /* rule 49 can match eol */
 YY_RULE_SETUP
-#line 187 &quot;ael.flex&quot;
-{yylloc-&gt;first_line = my_lineno;
-                         yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '}' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-                        }
+#line 310 &quot;ael.flex&quot;
+{
+		if( parencount != 0) { /* printf(&quot;Folding in a comma!\n&quot;); */
+			yymore();
+		} else  {
+			STORE_LOC;
+			if( !commaout ) {
+				if( !strcmp(yytext,&quot;,&quot; ) ) {
+					commaout = 0;
+					my_col+=1;
+					return COMMA;
+				}
+				yylval-&gt;str = strdup(yytext);
+				/* printf(&quot;Got argg2 word %s\n&quot;, yylval-&gt;str); */
+				unput(',');
+				commaout = 1;
+				if (yyleng &gt; 1 )
+					*(yylval-&gt;str+yyleng-1)=0;
+				return word;
+			} else {
+				commaout = 0;
+				my_col+=1;
+				return COMMA;
+			}
+		}
+	}
 	YY_BREAK
 case 50:
 /* rule 50 can match eol */
 YY_RULE_SETUP
-#line 206 &quot;ael.flex&quot;
-{/* printf(&quot;ARGG:%s\n&quot;,yytext); */
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
-
-					yylloc-&gt;first_line = my_lineno;
-                    yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                   
-
-					while (*pt) {
-                       if (*pt == '\n') {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc-&gt;last_line = my_lineno+linecount;
-                    yylloc-&gt;last_column=colcount; 
-                    parencount--;
-                    if( parencount &gt;= 0){ 
-                        yymore(); 
-                    } else { 
-                        yylval-&gt;str = strdup(yytext); 
-					   if(yyleng &gt; 1 ) 
-                              *(yylval-&gt;str+yyleng-1)=0;
-                       /* printf(&quot;Got argg word '%s'\n&quot;, yylval-&gt;str);  */
-                       BEGIN(0); 
-                       if ( !strcmp(yylval-&gt;str,&quot;)&quot;) ) { 
-                             free(yylval-&gt;str); 
-                             yylval-&gt;str = 0; 
-                             my_col+=1;
-                             return RP;  
-                       } else {
-                             unput(')');
-                             my_col=colcount;
-							 my_lineno+=linecount;
-                             return word;
-                       }
-                    } 
-                }
+#line 336 &quot;ael.flex&quot;
+{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n&quot;, my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 	YY_BREAK
 case 51:
 /* rule 51 can match eol */
 YY_RULE_SETUP
-#line 260 &quot;ael.flex&quot;
-{ /* printf(&quot;ARGG:%s\n&quot;,yytext); */
-                      /* printf(&quot;GOT AN LP!!!\n&quot;); */
-                      yylloc-&gt;first_line = my_lineno;
-                      yylloc-&gt;first_column=my_col; 
-                      parencount++; 
-                      pbcpush('(');
-                      yymore();
-                  }
+#line 350 &quot;ael.flex&quot;
+{
+		char c = yytext[yyleng-1];
+		yymore();
+		pbcpush(c);
+	}
 	YY_BREAK
 case 52:
 /* rule 52 can match eol */
 YY_RULE_SETUP
-#line 269 &quot;ael.flex&quot;
-{  /* printf(&quot;ARGG:%s\n&quot;,yytext); */
-                  if( parencount != 0) { 
-					/* printf(&quot;Folding in a comma!\n&quot;); */ 
-					yymore();
-				  } else  { 
-                     /* printf(&quot;got a comma!\n\n&quot;);  */
-					 int linecount = 0;
-                     int colcount = my_col;
-					 char *pt;
-
-					 pt = yytext;
-					 while (*pt) {
-                        if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                        }
-                        pt++;
-                        colcount++;
-                     }
-                     yylloc-&gt;first_line = my_lineno; 
-                     yylloc-&gt;last_line = my_lineno+linecount; 
-                     yylloc-&gt;last_column=colcount; 
-                     yylloc-&gt;first_column=my_col;
-                     if( !commaout ) { 
-						if( !strcmp(yytext,&quot;,&quot; ) ) 
-							{commaout = 0; my_col+=1; return COMMA;} 
-						yylval-&gt;str = strdup(yytext); /* printf(&quot;Got argg2 word %s\n&quot;, yylval-&gt;str); */ 
-						unput(','); 
-						commaout = 1; 
-						if(yyleng &gt; 1 ) 
-							*(yylval-&gt;str+yyleng-1)=0;
-                        my_lineno+=linecount;
-						my_col=colcount;
-						return word;
-					 } else {
-                            commaout = 0;
-							my_col+=1;
-							return COMMA;
-						}
-                   }
-				}
+#line 356 &quot;ael.flex&quot;
+{
+		char c = yytext[yyleng-1];
+		if ( pbcpop(c) ) { /* error */
+			STORE_LOC;
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '%c' in expression!\n&quot;, my_file, my_lineno, my_col, c);
+			BEGIN(0);
+			yylval-&gt;str = strdup(yytext);
+			return word;
+		}
+		yymore();
+	}
 	YY_BREAK
 case 53:
 /* rule 53 can match eol */
 YY_RULE_SETUP
-#line 311 &quot;ael.flex&quot;
-{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; pbcpush('{'); yymore();  }
+#line 368 &quot;ael.flex&quot;
+{
+		STORE_LOC;
+		yylval-&gt;str = strdup(yytext);
+		if(yyleng &gt; 1)
+			*(yylval-&gt;str+yyleng-1)=0;
+		unput(';');
+		BEGIN(0);
+		return word;
+	}
 	YY_BREAK
 case 54:
 /* rule 54 can match eol */
 YY_RULE_SETUP
-#line 312 &quot;ael.flex&quot;
-{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '}' in expression!\n&quot;, my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-				}
-	YY_BREAK
-case 55:
-/* rule 55 can match eol */
-YY_RULE_SETUP
-#line 328 &quot;ael.flex&quot;
-{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('['); }
-	YY_BREAK
-case 56:
-/* rule 56 can match eol */
-YY_RULE_SETUP
-#line 329 &quot;ael.flex&quot;
-{/*printf(&quot;ARGG:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ']' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();
-				}
-	YY_BREAK
-case 57:
-/* rule 57 can match eol */
-YY_RULE_SETUP
-#line 347 &quot;ael.flex&quot;
-{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('['); }
-	YY_BREAK
-case 58:
-/* rule 58 can match eol */
-YY_RULE_SETUP
-#line 348 &quot;ael.flex&quot;
-{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(']') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ']' in expression!\n&quot;, my_file, my_lineno+l4, c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-	YY_BREAK
-case 59:
-/* rule 59 can match eol */
-YY_RULE_SETUP
-#line 363 &quot;ael.flex&quot;
-{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('{');}
-	YY_BREAK
-case 60:
-/* rule 60 can match eol */
-YY_RULE_SETUP
-#line 364 &quot;ael.flex&quot;
-{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop('}') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched '}' in expression!\n&quot;, my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-	YY_BREAK
-case 61:
-/* rule 61 can match eol */
-YY_RULE_SETUP
-#line 379 &quot;ael.flex&quot;
-{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; yymore(); pbcpush('(');}
-	YY_BREAK
-case 62:
-/* rule 62 can match eol */
-YY_RULE_SETUP
-#line 380 &quot;ael.flex&quot;
-{/*printf(&quot;SEMIC:%s\n&quot;,yytext);*/yylloc-&gt;first_line = my_lineno;yylloc-&gt;first_column=my_col; 
-                         if ( pbcpop(')') ) {
-                             /* error */
-                             int l4,c4;
-                             pbcwhere(yytext, &amp;l4, &amp;c4);
-                             ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Mismatched ')' in expression!\n&quot;, my_file, my_lineno+l4, my_col+c4);
-                             BEGIN(0);
-                             yylloc-&gt;last_line = my_lineno+l4;
-                             yylloc-&gt;last_column=my_col+c4; 
-                             my_col=c4;
-                             my_lineno += l4;
-		                     yylval-&gt;str = strdup(yytext);
-                             return word;
-                         }
-                         yymore();}
-	YY_BREAK
-case 63:
-/* rule 63 can match eol */
-YY_RULE_SETUP
-#line 395 &quot;ael.flex&quot;
+#line 378 &quot;ael.flex&quot;
 {
-					int linecount = 0;
-                    int colcount = my_col;
-					char *pt = yytext;
-					while (*pt) {
-                       if ( *pt == '\n' ) {
-                           linecount++;
-                           colcount=0;
-                       }
-                       pt++;
-                       colcount++;
-                    }
-                    yylloc-&gt;first_line = my_lineno; 
-					yylloc-&gt;last_line = my_lineno+linecount; 
-					yylloc-&gt;last_column=colcount; 
-					yylloc-&gt;first_column=my_col;
-                    yylval-&gt;str = strdup(yytext);
-                    if(yyleng &gt; 1)
-                      *(yylval-&gt;str+yyleng-1)=0;
-                    /* printf(&quot;Got semic word %s\n&quot;, yylval-&gt;str); */
-                    unput(';');
-                    BEGIN(0);
-                    my_col=colcount;
-                    my_lineno += linecount;
-                    return word;
-                }
-	YY_BREAK
-case 64:
-/* rule 64 can match eol */
-YY_RULE_SETUP
-#line 422 &quot;ael.flex&quot;
-{
-                     FILE *in1;
-					 char fnamebuf[1024],*p1,*p2;
-                     if ( include_stack_index &gt;= MAX_INCLUDE_DEPTH ) {
-						ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n&quot;, my_file, my_lineno, my_col);
-                     } else {
-                         p1 = strchr(yytext,'&quot;');
-                         p2 = strrchr(yytext,'&quot;');
-                         if ( (int)(p2-p1) &gt; 1023 ) {
-							ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n&quot;, my_file, my_lineno, my_col, yyleng - 10);
-        	             } else {
-								int i;
-								int found = 0;
-								strncpy(fnamebuf,p1,p2-p1);
-								fnamebuf[p2-p1] = 0;
-								for (i=0; i&lt;include_stack_index; i++) {
-									if ( !strcmp(fnamebuf,include_stack[i].fname )) {
-										ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n&quot;, 
-												my_file, my_lineno, my_col, fnamebuf);
-										found=1;
-										break;
-									}
-								}
-								if( !found )
-								{
-                                	*p2 = 0;
-                                    /* relative vs. absolute */
-                                    if ( *(p1+1) != '/' )
-                                    {
-                                        strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
-										strcat(fnamebuf,&quot;/&quot;);
-										strcat(fnamebuf,p1+1);
-                                    }
-                                    else
-                                	    strcpy(fnamebuf,p1+1);
-		                        	in1 = fopen( fnamebuf, &quot;r&quot; );
-                                	if ( ! in1 ) {
-						ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n&quot;, my_file, my_lineno, my_col, fnamebuf);
-                                	} else {
-						char *buffer;
-	                             	 	struct stat stats;
-	                            		stat(fnamebuf, &amp;stats);
-	                             		buffer = (char*)malloc(stats.st_size+1);
-	                             		fread(buffer, 1, stats.st_size, in1);
-						buffer[stats.st_size] = 0;
-						ast_log(LOG_NOTICE,&quot;  --Read in included file %s, %d chars\n&quot;,fnamebuf, (int)stats.st_size);
-	                                	fclose(in1);
+		FILE *in1;
+		char fnamebuf[1024],*p1,*p2;
+		int error = 1;	/* don't use the file if set */
+		p1 = strchr(yytext,'&quot;');
+		p2 = strrchr(yytext,'&quot;');
+		if ( include_stack_index &gt;= MAX_INCLUDE_DEPTH ) {
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Includes nested too deeply! Wow!!! How did you do that?\n&quot;, my_file, my_lineno, my_col);
+		} else if ( (int)(p2-p1) &gt; sizeof(fnamebuf) - 1 ) {
+			ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Filename is incredibly way too long (%d chars!). Inclusion ignored!\n&quot;, my_file, my_lineno, my_col, yyleng - 10);
+		} else {
+			int i;
+			strncpy(fnamebuf, p1, p2-p1);
+			fnamebuf[p2-p1] = 0;
+			for (i=0; i&lt;include_stack_index; i++) {
+				if ( !strcmp(fnamebuf,include_stack[i].fname )) {
+					ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Nice Try!!! But %s has already been included (perhaps by another file), and would cause an infinite loop of file inclusions!!! Include directive ignored\n&quot;,
+						my_file, my_lineno, my_col, fnamebuf);
+					break;
+				}
+			}
+			if (i == include_stack_index)
+				error = 0;	/* we can use this file */
+		}
+		if ( !error ) {	/* valid file name */
+			*p2 = 0;
+			/* relative vs. absolute */
+			if ( *(p1+1) != '/' ) {
+				/* XXX must check overflows */
+				strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
+				strcat(fnamebuf,&quot;/&quot;);
+				strcat(fnamebuf,p1+1);
+			} else
+				strcpy(fnamebuf,p1+1);
+			in1 = fopen( fnamebuf, &quot;r&quot; );
+			if ( ! in1 ) {
+				ast_log(LOG_ERROR,&quot;File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n&quot;, my_file, my_lineno, my_col, fnamebuf);
+			} else {
+				char *buffer;
+				struct stat stats;
+				stat(fnamebuf, &amp;stats);
+				buffer = (char*)malloc(stats.st_size+1);
+				fread(buffer, 1, stats.st_size, in1);
+				buffer[stats.st_size] = 0;
+				ast_log(LOG_NOTICE,&quot;  --Read in included file %s, %d chars\n&quot;,fnamebuf, (int)stats.st_size);
+				fclose(in1);
 
-						include_stack[include_stack_index].fname = my_file;
-						my_file = strdup(fnamebuf);
-						include_stack[include_stack_index].lineno = my_lineno;
-						include_stack[include_stack_index].colno = my_col+yyleng;
-						include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
+				include_stack[include_stack_index].fname = my_file;
+				my_file = strdup(fnamebuf);
+				include_stack[include_stack_index].lineno = my_lineno;
+				include_stack[include_stack_index].colno = my_col+yyleng;
+				include_stack[include_stack_index++].bufstate = YY_CURRENT_BUFFER;
 
-	                                	ael_yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
-                                    		free(buffer);
-                                  	  	my_lineno = 1;
-                                    		my_col = 1;
-                                    		BEGIN(INITIAL);
-                                	}
-                                }
-                         }
-                     }
-                 }
+				ael_yy_switch_to_buffer(ael_yy_scan_string (buffer ,yyscanner),yyscanner);
+				free(buffer);
+				my_lineno = 1;
+				my_col = 1;
+				BEGIN(INITIAL);
+			}
+		}
+	}
 	YY_BREAK
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(paren):
 case YY_STATE_EOF(semic):
 case YY_STATE_EOF(argg):
-#line 487 &quot;ael.flex&quot;
+#line 440 &quot;ael.flex&quot;
 {
-                 if ( --include_stack_index &lt; 0 ) {
-                 	    yyterminate();
-                     } else {
-						 free(my_file);
-                         ael_yy_delete_buffer(YY_CURRENT_BUFFER,yyscanner );
-                         ael_yy_switch_to_buffer(include_stack[include_stack_index].bufstate,yyscanner );
-                         my_lineno = include_stack[include_stack_index].lineno;
-                         my_col    = include_stack[include_stack_index].colno;
-                         my_file   = include_stack[include_stack_index].fname;
-                     }
-          }
+		if ( --include_stack_index &lt; 0 ) {
+			yyterminate();
+		} else {
+			free(my_file);
+			ael_yy_delete_buffer(YY_CURRENT_BUFFER,yyscanner );
+			ael_yy_switch_to_buffer(include_stack[include_stack_index].bufstate,yyscanner );
+			my_lineno = include_stack[include_stack_index].lineno;
+			my_col    = include_stack[include_stack_index].colno;
+			my_file   = include_stack[include_stack_index].fname;
+		}
+	}
 	YY_BREAK
-case 65:
+case 55:
 YY_RULE_SETUP
-#line 501 &quot;ael.flex&quot;
+#line 453 &quot;ael.flex&quot;
 ECHO;
 	YY_BREAK
-#line 1732 &quot;ael_lex.c&quot;
+#line 1610 &quot;ael_lex.c&quot;
 
 	case YY_END_OF_BUFFER:
 		{
@@ -2013,7 +1891,7 @@
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state &gt;= 226 )
+			if ( yy_current_state &gt;= 206 )
 				yy_c = yy_meta[(unsigned int) yy_c];
 			}
 		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
@@ -2042,11 +1920,11 @@
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state &gt;= 226 )
+		if ( yy_current_state &gt;= 206 )
 			yy_c = yy_meta[(unsigned int) yy_c];
 		}
 	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 225);
+	yy_is_jam = (yy_current_state == 205);
 
 	return yy_is_jam ? 0 : yy_current_state;
 }
@@ -2858,7 +2736,7 @@
 
 #define YYTABLES_NAME &quot;yytables&quot;
 
-#line 501 &quot;ael.flex&quot;
+#line 453 &quot;ael.flex&quot;
 
 
 
@@ -2875,47 +2753,36 @@
 		pbcpos--;
 		return 0;
 	}
-	else
-		return 1; /* error */
+	return 1; /* error */
 }
 
 static int c_prevword(void)
 {
-    char *c = prev_word;
-	int ret = 0;
-	while ( c &amp;&amp; *c ) {
-        switch (*c) {
-            case '{': pbcpush('{');break;
-            case '}': ret = pbcpop('}');break;
-            case '[':pbcpush('[');break;
-            case ']':ret = pbcpop(']');break;
-            case '(':pbcpush('(');break;
-            case ')':ret = pbcpop(')'); break;
-        }
-        if( ret )
-            return 1;
+	char *c = prev_word;
+	if (c == NULL)
+		return 0;
+	while ( *c ) {
+		switch (*c) {
+		case '{':
+		case '[':
+		case '(':
+			pbcpush(*c);
+			break;
+		case '}':
+		case ']':
+		case ')':
+			if (pbcpop(*c))
+				return 1;
+			break;
+		}
 		c++;
 	}
 	return 0;
 }
 
-static void pbcwhere(char *text, int *line, int *col )
-{
-	int loc_line = 0;
-    int loc_col = 0;
-	while ( *text ) {
-       if ( *text == '\n' ) {
-             loc_line++;
-             loc_col = 1;
-       } else {
-             loc_col++;
-       }
-       text++;
-    }
-	*line = loc_line;
-    *col = loc_col;
-}
 
+/* used by the bison code */
+void reset_parencount(yyscan_t yyscanner );
 void reset_parencount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2926,6 +2793,8 @@
 	BEGIN(paren);
 }
 
+/* used by the bison code */
+void reset_semicount(yyscan_t yyscanner );
 void reset_semicount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2933,6 +2802,8 @@
 	BEGIN(semic);
 }
 
+/* used by the bison code */
+void reset_argcount(yyscan_t yyscanner );
 void reset_argcount(yyscan_t yyscanner )
 {
 	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
@@ -2944,7 +2815,7 @@
 	BEGIN(argg);
 }
 
-
+/* used elsewhere, but some local vars */
 struct pval *ael2_parse(char *filename, int *errors)
 {
 	struct pval *pval;
@@ -2975,7 +2846,7 @@
 	fread(buffer, 1, stats.st_size, fin);
 	buffer[stats.st_size]=0;
 	fclose(fin);
-	
+
 	ael_yy_scan_string (buffer ,io-&gt;scanner);
 	ael_yyset_lineno(1 , io-&gt;scanner);
 

Modified: trunk/pbx/pbx_ael.c
===================================================================
--- trunk/pbx/pbx_ael.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/pbx/pbx_ael.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -29,10 +29,11 @@
 #include &lt;ctype.h&gt;
 #include &lt;errno.h&gt;
 #include &lt;regex.h&gt;
+#include &lt;sys/stat.h&gt;
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22413 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22654 $&quot;)
 
 #include &quot;asterisk/pbx.h&quot;
 #include &quot;asterisk/config.h&quot;
@@ -124,9 +125,9 @@
 static const char *description(void);
 static const char *key(void);
 
-static char *match_context;
-static char *match_exten;
-static char *match_label;
+static const char *match_context;
+static const char *match_exten;
+static const char *match_label;
 static int in_abstract_context;
 static int count_labels; /* true, put matcher in label counting mode */
 static int label_count;  /* labels are only meant to be counted in a context or exten */
@@ -138,15 +139,20 @@
 static void check_day(pval *DAY);
 static void check_month(pval *MON);
 static void check_expr2_input(pval *expr, char *str);
-static int extension_matches(pval *here, char *exten, char *pattern);
+static int extension_matches(pval *here, const char *exten, const char *pattern);
 static void check_goto(pval *item);
 static void find_pval_goto_item(pval *item, int lev);
 static void find_pval_gotos(pval *item, int lev);
 
+static struct pval *find_label_in_current_context(char *exten, char *label);
+static void print_pval_list(FILE *fin, pval *item, int depth);
 
+static struct pval *find_label_in_current_extension(const char *label);
+static struct pval *find_label_in_current_db(const char *context, const char *exten, const char *label);
+
 /* PRETTY PRINTER FOR AEL:  ============================================================================= */
 
-void print_pval(FILE *fin, pval *item, int depth)
+static void print_pval(FILE *fin, pval *item, int depth)
 {
 	int i;
 	pval *lp;
@@ -400,7 +406,7 @@
 	}
 }
 
-void print_pval_list(FILE *fin, pval *item, int depth)
+static void print_pval_list(FILE *fin, pval *item, int depth)
 {
 	pval *i;
 	
@@ -409,7 +415,8 @@
 	}
 }
 
-void ael2_print(char *fname, pval *tree)
+#if 0
+static void ael2_print(char *fname, pval *tree)
 {
 	FILE *fin = fopen(fname,&quot;w&quot;);
 	if ( !fin ) {
@@ -419,6 +426,7 @@
 	print_pval_list(fin, tree, 0);
 	fclose(fin);
 }
+#endif
 
 
 /* EMPTY TEMPLATE FUNCS FOR AEL TRAVERSAL:  ============================================================================= */
@@ -677,7 +685,7 @@
 
 
 
-static int extension_matches(pval *here, char *exten, char *pattern)
+static int extension_matches(pval *here, const char *exten, const char *pattern)
 {
 	int err1;
 	regex_t preg;
@@ -688,7 +696,8 @@
 	
 	if ( pattern[0] == '_' ) {
 		char reg1[2000];
-		char *p,*r=reg1;
+		const char *p;
+		char *r = reg1;
 		
 		if ( strlen(pattern)*5 &gt;= 2000 ) /* safety valve */ {
 			ast_log(LOG_ERROR,&quot;Error: The pattern %s is way too big. Pattern matching cancelled.\n&quot;,
@@ -1511,7 +1520,7 @@
 	return 0;
 }
 
-
+#if 0
 int count_labels_in_current_context(char *label)
 {
 	label_count = 0;
@@ -1521,6 +1530,7 @@
 	
 	return label_count;
 }
+#endif
 
 struct pval *find_label_in_current_context(char *exten, char *label)
 {
@@ -1564,7 +1574,7 @@
 	return 0;
 }
 
-struct pval *find_label_in_current_extension(char *label)
+static struct pval *find_label_in_current_extension(const char *label)
 {
 	/* printf(&quot;  --- Got args %s\n&quot;, label); */
 	count_labels = 0;
@@ -1577,7 +1587,7 @@
 	return match_pval(current_extension-&gt;u2.statements);
 }
 
-struct pval *find_label_in_current_db(char *context, char *exten, char *label)
+static struct pval *find_label_in_current_db(const char *context, const char *exten, const char *label)
 {
 	/* printf(&quot;  --- Got args %s, %s, %s\n&quot;, context, exten, label); */
 	count_labels = 0;
@@ -2408,7 +2418,7 @@
 	}
 }
 
-void ael2_semantic_check(pval *item, int *arg_errs, int *arg_warns, int *arg_notes)
+static void ael2_semantic_check(pval *item, int *arg_errs, int *arg_warns, int *arg_notes)
 {
 	
 #ifdef AAL_ARGCHECK

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/rtp.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -41,7 +41,7 @@
 
 #include &quot;asterisk.h&quot;
 
-ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 20224 $&quot;)
+ASTERISK_FILE_VERSION(__FILE__, &quot;$Revision: 22905 $&quot;)
 
 #include &quot;asterisk/rtp.h&quot;
 #include &quot;asterisk/frame.h&quot;
@@ -739,11 +739,11 @@
 	struct ast_rtp *vdestp, *vsrcp;		/* Video RTP channels */
 	struct ast_rtp_protocol *destpr, *srcpr;
 	/* Lock channels */
-	ast_mutex_lock(&amp;dest-&gt;lock);
-	while(ast_mutex_trylock(&amp;src-&gt;lock)) {
-		ast_mutex_unlock(&amp;dest-&gt;lock);
+	ast_channel_lock(dest);
+	while(ast_channel_trylock(src)) {
+		ast_channel_unlock(dest);
 		usleep(1);
-		ast_mutex_lock(&amp;dest-&gt;lock);
+		ast_channel_lock(dest);
 	}
 
 	/* Find channel driver interfaces */
@@ -752,15 +752,15 @@
 	if (!destpr) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, &quot;Channel '%s' has no RTP, not doing anything\n&quot;, dest-&gt;name);
-		ast_mutex_unlock(&amp;dest-&gt;lock);
-		ast_mutex_unlock(&amp;src-&gt;lock);
+		ast_channel_unlock(dest);
+		ast_channel_unlock(src);
 		return 0;
 	}
 	if (!srcpr) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, &quot;Channel '%s' has no RTP, not doing anything\n&quot;, src-&gt;name);
-		ast_mutex_unlock(&amp;dest-&gt;lock);
-		ast_mutex_unlock(&amp;src-&gt;lock);
+		ast_channel_unlock(dest);
+		ast_channel_unlock(src);
 		return 0;
 	}
 
@@ -773,15 +773,15 @@
 	/* Check if bridge is still possible (In SIP canreinvite=no stops this, like NAT) */
 	if (!destp || !srcp) {
 		/* Somebody doesn't want to play... */
-		ast_mutex_unlock(&amp;dest-&gt;lock);
-		ast_mutex_unlock(&amp;src-&gt;lock);
+		ast_channel_unlock(dest);
+		ast_channel_unlock(src);
 		return 0;
 	}
 	ast_rtp_pt_copy(destp, srcp);
 	if (vdestp &amp;&amp; vsrcp)
 		ast_rtp_pt_copy(vdestp, vsrcp);
-	ast_mutex_unlock(&amp;dest-&gt;lock);
-	ast_mutex_unlock(&amp;src-&gt;lock);
+	ast_channel_unlock(dest);
+	ast_channel_unlock(src);
 	if (option_debug)
 		ast_log(LOG_DEBUG, &quot;Seeded SDP of '%s' with that of '%s'\n&quot;, dest-&gt;name, src-&gt;name);
 	return 1;
@@ -1562,11 +1562,11 @@
 		return AST_BRIDGE_FAILED_NOWARN;
 
 	/* Lock channels */
-	ast_mutex_lock(&amp;c0-&gt;lock);
-	while(ast_mutex_trylock(&amp;c1-&gt;lock)) {
-		ast_mutex_unlock(&amp;c0-&gt;lock);
+	ast_channel_lock(c0);
+	while(ast_channel_trylock(c1)) {
+		ast_channel_unlock(c0);
 		usleep(1);
-		ast_mutex_lock(&amp;c0-&gt;lock);
+		ast_channel_lock(c0);
 	}
 
 	/* Find channel driver interfaces */
@@ -1574,14 +1574,14 @@
 	pr1 = get_proto(c1);
 	if (!pr0) {
 		ast_log(LOG_WARNING, &quot;Can't find native functions for channel '%s'\n&quot;, c0-&gt;name);
-		ast_mutex_unlock(&amp;c0-&gt;lock);
-		ast_mutex_unlock(&amp;c1-&gt;lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return AST_BRIDGE_FAILED;
 	}
 	if (!pr1) {
 		ast_log(LOG_WARNING, &quot;Can't find native functions for channel '%s'\n&quot;, c1-&gt;name);
-		ast_mutex_unlock(&amp;c0-&gt;lock);
-		ast_mutex_unlock(&amp;c1-&gt;lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return AST_BRIDGE_FAILED;
 	}
 
@@ -1598,8 +1598,8 @@
 	/* Check if bridge is still possible (In SIP canreinvite=no stops this, like NAT) */
 	if (!p0 || !p1) {
 		/* Somebody doesn't want to play... */
-		ast_mutex_unlock(&amp;c0-&gt;lock);
-		ast_mutex_unlock(&amp;c1-&gt;lock);
+		ast_channel_unlock(c0);
+		ast_channel_unlock(c1);
 		return AST_BRIDGE_FAILED_NOWARN;
 	}
 	/* Get codecs from both sides */
@@ -1610,8 +1610,8 @@
 		if (!(codec0 &amp; codec1)) {
 			if (option_debug)
 				ast_log(LOG_DEBUG, &quot;Channel codec0 = %d is not codec1 = %d, cannot native bridge in RTP.\n&quot;, codec0, codec1);
-			ast_mutex_unlock(&amp;c0-&gt;lock);
-			ast_mutex_unlock(&amp;c1-&gt;lock);
+			ast_channel_unlock(c0);
+			ast_channel_unlock(c1);
 			return AST_BRIDGE_FAILED_NOWARN;
 		}
 	}
@@ -1637,8 +1637,8 @@
 		if (vp0)
 			ast_rtp_get_peer(vp0, &amp;vac0);
 	}
-	ast_mutex_unlock(&amp;c0-&gt;lock);
-	ast_mutex_unlock(&amp;c1-&gt;lock);
+	ast_channel_unlock(c0);
+	ast_channel_unlock(c1);
 	/* External RTP Bridge up, now loop and see if something happes that force us to take the
 		media back to Asterisk */
 	cs[0] = c0;

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/utils/Makefile	2006-04-29 02:51:28 UTC (rev 3)
@@ -14,7 +14,7 @@
 #
 # Don't use ast mm routines
 #
-UTILS:=astman smsq stereorize streamplayer
+UTILS:=astman smsq stereorize streamplayer aelparse
 
 ifeq (${OSARCH},SunOS)
   SOL=../strcompat.o
@@ -70,7 +70,7 @@
 	$(CC) $(CFLAGS) -g -o aelparse ../pbx/ael/aelflex.o ../pbx/ael/aelbison.o ael_main.o ../pbx/pbx_ael.o ../ast_expr2f.o ../ast_expr2.o
 
 ael_main.o : ael_main.c ../include/asterisk/ael_structs.h
-	$(CC) $(CFLAGS) -c -g -o ael_main.o ael_main.c
+	$(CC) $(CFLAGS) -include ../include/autoconfig.h -c -g -o ael_main.o ael_main.c
 
 ael_main1.o : ael_main.c ../include/asterisk/ael_structs.h
 	$(CC) $(CFLAGS) -c -g  -o ael_main1.o ael_main.c

Modified: trunk/utils/ael_main.c
===================================================================
--- trunk/utils/ael_main.c	2006-04-26 17:29:21 UTC (rev 2)
+++ trunk/utils/ael_main.c	2006-04-29 02:51:28 UTC (rev 3)
@@ -6,17 +6,15 @@
 #include &lt;ctype.h&gt;
 #if !defined(SOLARIS) &amp;&amp; !defined(__CYGWIN__)
 #include &lt;err.h&gt;
-#else
-#define quad_t int64_t
 #endif
 #include &lt;errno.h&gt;
 #include &lt;regex.h&gt;
 #include &lt;limits.h&gt;
-#include &lt;asterisk/ast_expr.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/app.h&gt;
+#include &quot;asterisk/ast_expr.h&quot;
+#include &quot;asterisk/logger.h&quot;
+#include &quot;asterisk/module.h&quot;
+#include &quot;asterisk/channel.h&quot;
+#include &quot;asterisk/app.h&quot;
 #include &quot;asterisk/ael_structs.h&quot;
 #define AST_CONFIG_MAX_PATH 255
 


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000001.html">[Solid-pbx-svn] r4 - trunk
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#0">[ date ]</a>
              <a href="thread.html#0">[ thread ]</a>
              <a href="subject.html#0">[ subject ]</a>
              <a href="author.html#0">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
