From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 00:02:00 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 00:02:00 +0200
Subject: [solid-pbx-svn] r203 - in trunk: . include/asterisk
Message-ID: <200605312202.k4VM2083027730@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 00:01:54 +0200 (Thu, 01 Jun 2006)
New Revision: 203

Added:
   trunk/abstract_jb.c
   trunk/include/asterisk/abstract_jb.h
   trunk/scx_jitterbuf.c
   trunk/scx_jitterbuf.h
Log:
Add missing files

Added: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-05-31 21:56:33 UTC (rev 202)
+++ trunk/abstract_jb.c	2006-05-31 22:01:54 UTC (rev 203)
@@ -0,0 +1,784 @@
+/*
+ * abstract_jb: common implementation-independent jitterbuffer stuff
+ *
+ * Copyright (C) 2005, Attractel OOD
+ *
+ * Contributors:
+ * Slav Klenov <slav at securax.org>
+ *
+ * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Common implementation-independent jitterbuffer stuff.
+ * 
+ * \author Slav Klenov <slav at securax.org>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <limits.h>
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
+#include "asterisk/frame.h"
+#include "asterisk/channel.h"
+#include "asterisk/logger.h"
+#include "asterisk/term.h"
+#include "asterisk/options.h"
+#include "asterisk/utils.h"
+
+#include "asterisk/abstract_jb.h"
+#include "scx_jitterbuf.h"
+#include "jitterbuf.h"
+
+/*! Internal jb flags */
+enum {
+	JB_USE =                  (1 << 0),
+	JB_TIMEBASE_INITIALIZED = (1 << 1),
+	JB_CREATED =              (1 << 2)
+};
+
+/* Hooks for the abstract jb implementation */
+
+/*! \brief Create */
+typedef void * (*jb_create_impl)(struct ast_jb_conf *general_config, long resynch_threshold);
+/*! \brief Destroy */
+typedef void (*jb_destroy_impl)(void *jb);
+/*! \brief Put first frame */
+typedef int (*jb_put_first_impl)(void *jb, struct ast_frame *fin, long now);
+/*! \brief Put frame */
+typedef int (*jb_put_impl)(void *jb, struct ast_frame *fin, long now);
+/*! \brief Get frame for now */
+typedef int (*jb_get_impl)(void *jb, struct ast_frame **fout, long now, long interpl);
+/*! \brief Get next */
+typedef long (*jb_next_impl)(void *jb);
+/*! \brief Remove first frame */
+typedef int (*jb_remove_impl)(void *jb, struct ast_frame **fout);
+/*! \brief Force resynch */
+typedef void (*jb_force_resynch_impl)(void *jb);
+
+
+/*!
+ * \brief Jitterbuffer implementation private struct.
+ */
+struct ast_jb_impl
+{
+	char name[AST_JB_IMPL_NAME_SIZE];
+	jb_create_impl create;
+	jb_destroy_impl destroy;
+	jb_put_first_impl put_first;
+	jb_put_impl put;
+	jb_get_impl get;
+	jb_next_impl next;
+	jb_remove_impl remove;
+	jb_force_resynch_impl force_resync;
+};
+
+/* Implementation functions */
+/* scx */
+static void * jb_create_scx(struct ast_jb_conf *general_config, long resynch_threshold);
+static void jb_destroy_scx(void *jb);
+static int jb_put_first_scx(void *jb, struct ast_frame *fin, long now);
+static int jb_put_scx(void *jb, struct ast_frame *fin, long now);
+static int jb_get_scx(void *jb, struct ast_frame **fout, long now, long interpl);
+static long jb_next_scx(void *jb);
+static int jb_remove_scx(void *jb, struct ast_frame **fout);
+static void jb_force_resynch_scx(void *jb);
+/* stevek */
+static void * jb_create_stevek(struct ast_jb_conf *general_config, long resynch_threshold);
+static void jb_destroy_stevek(void *jb);
+static int jb_put_first_stevek(void *jb, struct ast_frame *fin, long now);
+static int jb_put_stevek(void *jb, struct ast_frame *fin, long now);
+static int jb_get_stevek(void *jb, struct ast_frame **fout, long now, long interpl);
+static long jb_next_stevek(void *jb);
+static int jb_remove_stevek(void *jb, struct ast_frame **fout);
+static void jb_force_resynch_stevek(void *jb);
+
+/* Available jb implementations */
+static struct ast_jb_impl avail_impl[] = 
+{
+	{
+		.name = "fixed",
+		.create = jb_create_scx,
+		.destroy = jb_destroy_scx,
+		.put_first = jb_put_first_scx,
+		.put = jb_put_scx,
+		.get = jb_get_scx,
+		.next = jb_next_scx,
+		.remove = jb_remove_scx,
+		.force_resync = jb_force_resynch_scx
+	},
+	{
+		.name = "adaptive",
+		.create = jb_create_stevek,
+		.destroy = jb_destroy_stevek,
+		.put_first = jb_put_first_stevek,
+		.put = jb_put_stevek,
+		.get = jb_get_stevek,
+		.next = jb_next_stevek,
+		.remove = jb_remove_stevek,
+		.force_resync = jb_force_resynch_stevek
+	}
+};
+
+static int default_impl = 0;
+
+
+/*! Abstract return codes */
+enum {
+	JB_IMPL_OK,
+	JB_IMPL_DROP,
+	JB_IMPL_INTERP,
+	JB_IMPL_NOFRAME
+};
+
+/* Translations between impl and abstract return codes */
+static int scx_to_abstract_code[] =
+	{JB_IMPL_OK, JB_IMPL_DROP, JB_IMPL_INTERP, JB_IMPL_NOFRAME};
+static int stevek_to_abstract_code[] =
+	{JB_IMPL_OK, JB_IMPL_NOFRAME, JB_IMPL_NOFRAME, JB_IMPL_INTERP, JB_IMPL_DROP, JB_IMPL_OK};
+
+/* JB_GET actions (used only for the frames log) */
+static char *jb_get_actions[] = {"Delivered", "Dropped", "Interpolated", "No"};
+
+/*! \brief Macros for the frame log files */
+#define jb_framelog(...) do { \
+	if (jb->logfile) { \
+		fprintf(jb->logfile, __VA_ARGS__); \
+		fflush(jb->logfile); \
+	} \
+} while (0)
+
+
+/* Internal utility functions */
+static void jb_choose_impl(struct ast_channel *chan);
+static void jb_get_and_deliver(struct ast_channel *chan);
+static int create_jb(struct ast_channel *chan, struct ast_frame *first_frame);
+static long get_now(struct ast_jb *jb, struct timeval *tv);
+
+
+/* Interface ast jb functions impl */
+
+
+static void jb_choose_impl(struct ast_channel *chan)
+{
+	struct ast_jb *jb = &chan->jb;
+	struct ast_jb_conf *jbconf = &jb->conf;
+	struct ast_jb_impl *test_impl;
+	int i, avail_impl_count = sizeof(avail_impl) / sizeof(avail_impl[0]);
+	
+	jb->impl = &avail_impl[default_impl];
+	
+	if (ast_strlen_zero(jbconf->impl))
+		return;
+		
+	for (i = 0; i < avail_impl_count; i++) {
+		test_impl = &avail_impl[i];
+		if (!strcasecmp(jbconf->impl, test_impl->name)) {
+			jb->impl = test_impl;
+			return;
+		}
+	}
+}
+
+int ast_jb_do_usecheck(struct ast_channel *c0, struct ast_channel *c1)
+{
+	struct ast_jb *jb0 = &c0->jb;
+	struct ast_jb *jb1 = &c1->jb;
+	struct ast_jb_conf *conf0 = &jb0->conf;
+	struct ast_jb_conf *conf1 = &jb1->conf;
+	int c0_wants_jitter = c0->tech->properties & AST_CHAN_TP_WANTSJITTER;
+	int c0_creates_jitter = c0->tech->properties & AST_CHAN_TP_CREATESJITTER;
+	int c0_jb_enabled = ast_test_flag(conf0, AST_JB_ENABLED);
+	int c0_force_jb = ast_test_flag(conf0, AST_JB_FORCED);
+	int c0_jb_timebase_initialized = ast_test_flag(jb0, JB_TIMEBASE_INITIALIZED);
+	int c0_jb_created = ast_test_flag(jb0, JB_CREATED);
+	int c1_wants_jitter = c1->tech->properties & AST_CHAN_TP_WANTSJITTER;
+	int c1_creates_jitter = c1->tech->properties & AST_CHAN_TP_CREATESJITTER;
+	int c1_jb_enabled = ast_test_flag(conf1, AST_JB_ENABLED);
+	int c1_force_jb = ast_test_flag(conf1, AST_JB_FORCED);
+	int c1_jb_timebase_initialized = ast_test_flag(jb1, JB_TIMEBASE_INITIALIZED);
+	int c1_jb_created = ast_test_flag(jb1, JB_CREATED);
+	int inuse = 0;
+
+	/* Determine whether audio going to c0 needs a jitter buffer */
+	if (((!c0_wants_jitter && c1_creates_jitter) || (c0_force_jb && c1_creates_jitter)) && c0_jb_enabled) {
+		ast_set_flag(jb0, JB_USE);
+		if (!c0_jb_timebase_initialized) {
+			if (c1_jb_timebase_initialized) {
+				memcpy(&jb0->timebase, &jb1->timebase, sizeof(struct timeval));
+			} else {
+				gettimeofday(&jb0->timebase, NULL);
+			}
+			ast_set_flag(jb0, JB_TIMEBASE_INITIALIZED);
+		}
+		
+		if (!c0_jb_created) {
+			jb_choose_impl(c0);
+		}
+
+		inuse = 1;
+	}
+	
+	/* Determine whether audio going to c1 needs a jitter buffer */
+	if (((!c1_wants_jitter && c0_creates_jitter) || (c1_force_jb && c0_creates_jitter)) && c1_jb_enabled) {
+		ast_set_flag(jb1, JB_USE);
+		if (!c1_jb_timebase_initialized) {
+			if (c0_jb_timebase_initialized) {
+				memcpy(&jb1->timebase, &jb0->timebase, sizeof(struct timeval));
+			} else {
+				gettimeofday(&jb1->timebase, NULL);
+			}
+			ast_set_flag(jb1, JB_TIMEBASE_INITIALIZED);
+		}
+		
+		if (!c1_jb_created) {
+			jb_choose_impl(c1);
+		}
+
+		inuse = 1;
+	}
+
+	return inuse;
+}
+
+int ast_jb_get_when_to_wakeup(struct ast_channel *c0, struct ast_channel *c1, int time_left)
+{
+	struct ast_jb *jb0 = &c0->jb;
+	struct ast_jb *jb1 = &c1->jb;
+	int c0_use_jb = ast_test_flag(jb0, JB_USE);
+	int c0_jb_is_created = ast_test_flag(jb0, JB_CREATED);
+	int c1_use_jb = ast_test_flag(jb1, JB_USE);
+	int c1_jb_is_created = ast_test_flag(jb1, JB_CREATED);
+	int wait, wait0, wait1;
+	struct timeval tv_now;
+	
+	if (time_left == 0) {
+		/* No time left - the bridge will be retried */
+		/* TODO: Test disable this */
+		/*return 0;*/
+	}
+	
+	if (time_left < 0) {
+		time_left = INT_MAX;
+	}
+	
+	gettimeofday(&tv_now, NULL);
+	
+	wait0 = (c0_use_jb && c0_jb_is_created) ? jb0->next - get_now(jb0, &tv_now) : time_left;
+	wait1 = (c1_use_jb && c1_jb_is_created) ? jb1->next - get_now(jb1, &tv_now) : time_left;
+	
+	wait = wait0 < wait1 ? wait0 : wait1;
+	wait = wait < time_left ? wait : time_left;
+	
+	if (wait == INT_MAX) {
+		wait = -1;
+	} else if (wait < 1) {
+		/* don't let wait=0, because this can cause the pbx thread to loop without any sleeping at all */
+		wait = 1;
+	}
+	
+	return wait;
+}
+
+
+int ast_jb_put(struct ast_channel *chan, struct ast_frame *f)
+{
+	struct ast_jb *jb = &chan->jb;
+	struct ast_jb_impl *jbimpl = jb->impl;
+	void *jbobj = jb->jbobj;
+	struct ast_frame *frr;
+	long now = 0;
+	
+	if (!ast_test_flag(jb, JB_USE))
+		return -1;
+
+	if (f->frametype != AST_FRAME_VOICE) {
+		if (f->frametype == AST_FRAME_DTMF && ast_test_flag(jb, JB_CREATED)) {
+			jb_framelog("JB_PUT {now=%ld}: Received DTMF frame. Force resynching jb...\n", now);
+			jbimpl->force_resync(jbobj);
+		}
+		
+		return -1;
+	}
+
+	/* We consider an enabled jitterbuffer should receive frames with valid timing info. */
+	if (!f->has_timing_info || f->len < 2 || f->ts < 0) {
+		ast_log(LOG_WARNING, "%s recieved frame with invalid timing info: "
+			"has_timing_info=%d, len=%ld, ts=%ld, src=%s\n",
+			chan->name, f->has_timing_info, f->len, f->ts, f->src);
+		return -1;
+	}
+
+	if (f->mallocd & AST_MALLOCD_HDR)
+		frr = ast_frdup(f);
+	else
+		frr = ast_frisolate(f);
+
+	if (!frr) {
+		ast_log(LOG_ERROR, "Failed to isolate frame for the jitterbuffer on channel '%s'\n", chan->name);
+		return -1;
+	}
+
+	if (!ast_test_flag(jb, JB_CREATED)) {
+		if (create_jb(chan, frr)) {
+			ast_frfree(frr);
+			/* Disable the jitterbuffer */
+			ast_clear_flag(jb, JB_USE);
+			return -1;
+		}
+
+		ast_set_flag(jb, JB_CREATED);
+		return 0;
+	} else {
+		now = get_now(jb, NULL);
+		if (jbimpl->put(jbobj, frr, now) != JB_IMPL_OK) {
+			jb_framelog("JB_PUT {now=%ld}: Dropped frame with ts=%ld and len=%ld\n", now, frr->ts, frr->len);
+			ast_frfree(frr);
+			/*return -1;*/
+			/* TODO: Check this fix - should return 0 here, because the dropped frame shouldn't 
+			   be delivered at all */
+			return 0;
+		}
+
+		jb->next = jbimpl->next(jbobj);
+
+		jb_framelog("JB_PUT {now=%ld}: Queued frame with ts=%ld and len=%ld\n", now, frr->ts, frr->len);
+
+		return 0;
+	}
+}
+
+
+void ast_jb_get_and_deliver(struct ast_channel *c0, struct ast_channel *c1)
+{
+	struct ast_jb *jb0 = &c0->jb;
+	struct ast_jb *jb1 = &c1->jb;
+	int c0_use_jb = ast_test_flag(jb0, JB_USE);
+	int c0_jb_is_created = ast_test_flag(jb0, JB_CREATED);
+	int c1_use_jb = ast_test_flag(jb1, JB_USE);
+	int c1_jb_is_created = ast_test_flag(jb1, JB_CREATED);
+	
+	if (c0_use_jb && c0_jb_is_created)
+		jb_get_and_deliver(c0);
+	
+	if (c1_use_jb && c1_jb_is_created)
+		jb_get_and_deliver(c1);
+}
+
+
+static void jb_get_and_deliver(struct ast_channel *chan)
+{
+	struct ast_jb *jb = &chan->jb;
+	struct ast_jb_impl *jbimpl = jb->impl;
+	void *jbobj = jb->jbobj;
+	struct ast_frame *f, finterp;
+	long now;
+	int interpolation_len, res;
+	
+	now = get_now(jb, NULL);
+	jb->next = jbimpl->next(jbobj);
+	if (now < jb->next) {
+		jb_framelog("\tJB_GET {now=%ld}: now < next=%ld\n", now, jb->next);
+		return;
+	}
+	
+	while (now >= jb->next) {
+		interpolation_len = ast_codec_interp_len(jb->last_format);
+		
+		res = jbimpl->get(jbobj, &f, now, interpolation_len);
+		
+		switch(res) {
+		case JB_IMPL_OK:
+			/* deliver the frame */
+			ast_write(chan, f);
+		case JB_IMPL_DROP:
+			jb_framelog("\tJB_GET {now=%ld}: %s frame with ts=%ld and len=%ld\n",
+				now, jb_get_actions[res], f->ts, f->len);
+			jb->last_format = f->subclass;
+			ast_frfree(f);
+			break;
+		case JB_IMPL_INTERP:
+			/* interpolate a frame */
+			f = &finterp;
+			f->frametype = AST_FRAME_VOICE;
+			f->subclass = jb->last_format;
+			f->datalen  = 0;
+			f->samples  = interpolation_len * 8;
+			f->mallocd  = 0;
+			f->src  = "JB interpolation";
+			f->data  = NULL;
+			f->delivery = ast_tvadd(jb->timebase, ast_samp2tv(jb->next, 1000));
+			f->offset = AST_FRIENDLY_OFFSET;
+			/* deliver the interpolated frame */
+			ast_write(chan, f);
+			jb_framelog("\tJB_GET {now=%ld}: Interpolated frame with len=%d\n", now, interpolation_len);
+			break;
+		case JB_IMPL_NOFRAME:
+			ast_log(LOG_WARNING,
+				"JB_IMPL_NOFRAME is retuned from the %s jb when now=%ld >= next=%ld, jbnext=%ld!\n",
+				jbimpl->name, now, jb->next, jbimpl->next(jbobj));
+			jb_framelog("\tJB_GET {now=%ld}: No frame for now!?\n", now);
+			return;
+		default:
+			ast_log(LOG_ERROR, "This should never happen!\n");
+			CRASH;
+			break;
+		}
+		
+		jb->next = jbimpl->next(jbobj);
+	}
+}
+
+
+static int create_jb(struct ast_channel *chan, struct ast_frame *frr)
+{
+	struct ast_jb *jb = &chan->jb;
+	struct ast_jb_conf *jbconf = &jb->conf;
+	struct ast_jb_impl *jbimpl = jb->impl;
+	void *jbobj;
+	struct ast_channel *bridged;
+	long now;
+	char logfile_pathname[20 + AST_JB_IMPL_NAME_SIZE + 2*AST_CHANNEL_NAME + 1];
+	char name1[AST_CHANNEL_NAME], name2[AST_CHANNEL_NAME], *tmp;
+	int res;
+
+	jbobj = jb->jbobj = jbimpl->create(jbconf, jbconf->resync_threshold);
+	if (!jbobj) {
+		ast_log(LOG_WARNING, "Failed to create jitterbuffer on channel '%s'\n", chan->name);
+		return -1;
+	}
+	
+	now = get_now(jb, NULL);
+	res = jbimpl->put_first(jbobj, frr, now);
+	
+	/* The result of putting the first frame should not differ from OK. However, its possible
+	   some implementations (i.e. stevek's when resynch_threshold is specified) to drop it. */
+	if (res != JB_IMPL_OK) {
+		ast_log(LOG_WARNING, "Failed to put first frame in the jitterbuffer on channel '%s'\n", chan->name);
+		/*
+		jbimpl->destroy(jbobj);
+		return -1;
+		*/
+	}
+	
+	/* Init next */
+	jb->next = jbimpl->next(jbobj);
+	
+	/* Init last format for a first time. */
+	jb->last_format = frr->subclass;
+	
+	/* Create a frame log file */
+	if (ast_test_flag(jbconf, AST_JB_LOG)) {
+		snprintf(name2, sizeof(name2), "%s", chan->name);
+		tmp = strchr(name2, '/');
+		if (tmp)
+			*tmp = '#';
+		
+		bridged = ast_bridged_channel(chan);
+		if (!bridged) {
+			/* We should always have bridged chan if a jitterbuffer is in use */
+			CRASH;
+		}
+		snprintf(name1, sizeof(name1), "%s", bridged->name);
+		tmp = strchr(name1, '/');
+		if (tmp)
+			*tmp = '#';
+		
+		snprintf(logfile_pathname, sizeof(logfile_pathname),
+			"/tmp/ast_%s_jb_%s--%s.log", jbimpl->name, name1, name2);
+		jb->logfile = fopen(logfile_pathname, "w+b");
+		
+		if (!jb->logfile)
+			ast_log(LOG_WARNING, "Failed to create frame log file with pathname '%s'\n", logfile_pathname);
+		
+		if (res == JB_IMPL_OK)
+			jb_framelog("JB_PUT_FIRST {now=%ld}: Queued frame with ts=%ld and len=%ld\n",
+				now, frr->ts, frr->len);
+		else
+			jb_framelog("JB_PUT_FIRST {now=%ld}: Dropped frame with ts=%ld and len=%ld\n",
+				now, frr->ts, frr->len);
+	}
+
+	if (option_verbose > 2) 
+		ast_verbose(VERBOSE_PREFIX_3 "%s jitterbuffer created on channel %s\n", jbimpl->name, chan->name);
+	
+	/* Free the frame if it has not been queued in the jb */
+	if (res != JB_IMPL_OK)
+		ast_frfree(frr);
+	
+	return 0;
+}
+
+
+void ast_jb_destroy(struct ast_channel *chan)
+{
+	struct ast_jb *jb = &chan->jb;
+	struct ast_jb_impl *jbimpl = jb->impl;
+	void *jbobj = jb->jbobj;
+	struct ast_frame *f;
+
+	if (jb->logfile) {
+		fclose(jb->logfile);
+		jb->logfile = NULL;
+	}
+	
+	if (ast_test_flag(jb, JB_CREATED)) {
+		/* Remove and free all frames still queued in jb */
+		while (jbimpl->remove(jbobj, &f) == JB_IMPL_OK) {
+			ast_frfree(f);
+		}
+		
+		jbimpl->destroy(jbobj);
+		jb->jbobj = NULL;
+		
+		ast_clear_flag(jb, JB_CREATED);
+
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "%s jitterbuffer destroyed on channel %s\n", jbimpl->name, chan->name);
+	}
+}
+
+
+static long get_now(struct ast_jb *jb, struct timeval *tv)
+{
+	struct timeval now;
+
+	if (!tv) {
+		tv = &now;
+		gettimeofday(tv, NULL);
+	}
+
+	return ast_tvdiff_ms(*tv, jb->timebase);
+}
+
+
+int ast_jb_read_conf(struct ast_jb_conf *conf, char *varname, char *value)
+{
+	int prefixlen = sizeof(AST_JB_CONF_PREFIX) - 1;
+	char *name;
+	int tmp;
+	
+	if (strncasecmp(AST_JB_CONF_PREFIX, varname, prefixlen))
+		return -1;
+	
+	name = varname + prefixlen;
+	
+	if (!strcasecmp(name, AST_JB_CONF_ENABLE)) {
+		ast_set2_flag(conf, ast_true(value), AST_JB_ENABLED);
+	} else if (!strcasecmp(name, AST_JB_CONF_FORCE)) {
+		ast_set2_flag(conf, ast_true(value), AST_JB_FORCED);
+	} else if (!strcasecmp(name, AST_JB_CONF_MAX_SIZE)) {
+		if ((tmp = atoi(value)) > 0)
+			conf->max_size = tmp;
+	} else if (!strcasecmp(name, AST_JB_CONF_RESYNCH_THRESHOLD)) {
+		if ((tmp = atoi(value)) > 0)
+			conf->resync_threshold = tmp;
+	} else if (!strcasecmp(name, AST_JB_CONF_IMPL)) {
+		if (!ast_strlen_zero(value))
+			snprintf(conf->impl, sizeof(conf->impl), "%s", value);
+	} else if (!strcasecmp(name, AST_JB_CONF_LOG)) {
+		ast_set2_flag(conf, ast_true(value), AST_JB_LOG);
+	} else {
+		return -1;
+	}
+	
+	return 0;
+}
+
+
+void ast_jb_configure(struct ast_channel *chan, const struct ast_jb_conf *conf)
+{
+	memcpy(&chan->jb.conf, conf, sizeof(*conf));
+}
+
+
+void ast_jb_get_config(const struct ast_channel *chan, struct ast_jb_conf *conf)
+{
+	memcpy(conf, &chan->jb.conf, sizeof(*conf));
+}
+
+
+/* Implementation functions */
+
+/* scx */
+
+static void * jb_create_scx(struct ast_jb_conf *general_config, long resynch_threshold)
+{
+	struct scx_jb_conf conf;
+	
+	conf.jbsize = general_config->max_size;
+	conf.resync_threshold = resynch_threshold;
+	
+	return scx_jb_new(&conf);
+}
+
+
+static void jb_destroy_scx(void *jb)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	
+	/* destroy the jb */
+	scx_jb_destroy(scxjb);
+}
+
+
+static int jb_put_first_scx(void *jb, struct ast_frame *fin, long now)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	int res;
+	
+	res = scx_jb_put_first(scxjb, fin, fin->len, fin->ts, now);
+	
+	return scx_to_abstract_code[res];
+}
+
+
+static int jb_put_scx(void *jb, struct ast_frame *fin, long now)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	int res;
+	
+	res = scx_jb_put(scxjb, fin, fin->len, fin->ts, now);
+	
+	return scx_to_abstract_code[res];
+}
+
+
+static int jb_get_scx(void *jb, struct ast_frame **fout, long now, long interpl)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct scx_jb_frame frame;
+	int res;
+	
+	res = scx_jb_get(scxjb, &frame, now, interpl);
+	*fout = frame.data;
+	
+	return scx_to_abstract_code[res];
+}
+
+
+static long jb_next_scx(void *jb)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	
+	return scx_jb_next(scxjb);
+}
+
+
+static int jb_remove_scx(void *jb, struct ast_frame **fout)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct scx_jb_frame frame;
+	int res;
+	
+	res = scx_jb_remove(scxjb, &frame);
+	*fout = frame.data;
+	
+	return scx_to_abstract_code[res];
+}
+
+
+static void jb_force_resynch_scx(void *jb)
+{
+	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	
+	scx_jb_set_force_resynch(scxjb);
+}
+
+
+/* stevek */
+
+static void *jb_create_stevek(struct ast_jb_conf *general_config, long resynch_threshold)
+{
+	jb_conf jbconf;
+	jitterbuf *stevekjb;
+
+	stevekjb = jb_new();
+	if (stevekjb) {
+		jbconf.max_jitterbuf = general_config->max_size;
+		jbconf.resync_threshold = general_config->resync_threshold;
+		jbconf.max_contig_interp = 10;
+		jb_setconf(stevekjb, &jbconf);
+	}
+	
+	return stevekjb;
+}
+
+
+static void jb_destroy_stevek(void *jb)
+{
+	jitterbuf *stevekjb = (jitterbuf *) jb;
+	
+	jb_destroy(stevekjb);
+}
+
+
+static int jb_put_first_stevek(void *jb, struct ast_frame *fin, long now)
+{
+	return jb_put_stevek(jb, fin, now);
+}
+
+
+static int jb_put_stevek(void *jb, struct ast_frame *fin, long now)
+{
+	jitterbuf *stevekjb = (jitterbuf *) jb;
+	int res;
+	
+	res = jb_put(stevekjb, fin, JB_TYPE_VOICE, fin->len, fin->ts, now);
+	
+	return stevek_to_abstract_code[res];
+}
+
+
+static int jb_get_stevek(void *jb, struct ast_frame **fout, long now, long interpl)
+{
+	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jb_frame frame;
+	int res;
+	
+	res = jb_get(stevekjb, &frame, now, interpl);
+	*fout = frame.data;
+	
+	return stevek_to_abstract_code[res];
+}
+
+
+static long jb_next_stevek(void *jb)
+{
+	jitterbuf *stevekjb = (jitterbuf *) jb;
+	
+	return jb_next(stevekjb);
+}
+
+
+static int jb_remove_stevek(void *jb, struct ast_frame **fout)
+{
+	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jb_frame frame;
+	int res;
+	
+	res = jb_getall(stevekjb, &frame);
+	*fout = frame.data;
+	
+	return stevek_to_abstract_code[res];
+}
+
+
+static void jb_force_resynch_stevek(void *jb)
+{
+}

Added: trunk/include/asterisk/abstract_jb.h
===================================================================
--- trunk/include/asterisk/abstract_jb.h	2006-05-31 21:56:33 UTC (rev 202)
+++ trunk/include/asterisk/abstract_jb.h	2006-05-31 22:01:54 UTC (rev 203)
@@ -0,0 +1,220 @@
+/*
+ * abstract_jb: common implementation-independent jitterbuffer stuff
+ *
+ * Copyright (C) 2005, Attractel OOD
+ *
+ * Contributors:
+ * Slav Klenov <slav at securax.org>
+ *
+ * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file
+ *
+ * \brief Common implementation-independent jitterbuffer stuff.
+ * 
+ * \author Slav Klenov <slav at securax.org>
+ */
+
+#ifndef _ABSTRACT_JB_H_
+#define _ABSTRACT_JB_H_
+
+#include <stdio.h>
+#include <sys/time.h>
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+struct ast_channel;
+struct ast_frame;
+
+
+/* Configuration flags */
+enum {
+	AST_JB_ENABLED = (1 << 0),
+	AST_JB_FORCED =  (1 << 1),
+	AST_JB_LOG =     (1 << 2)
+};
+
+#define AST_JB_IMPL_NAME_SIZE 12
+
+/*!
+ * \brief General jitterbuffer configuration.
+ */
+struct ast_jb_conf
+{
+	/*! \brief Combination of the AST_JB_ENABLED, AST_JB_FORCED and AST_JB_LOG flags. */
+	unsigned int flags;
+	/*! \brief Max size of the jitterbuffer implementation. */
+	long max_size;
+	/*! \brief Resynchronization threshold of the jitterbuffer implementation. */
+ 	long resync_threshold;
+	/*! \brief Name of the jitterbuffer implementation to be used. */
+ 	char impl[AST_JB_IMPL_NAME_SIZE];
+};
+
+
+/* Jitterbuffer configuration property names */
+#define AST_JB_CONF_PREFIX "jb"
+#define AST_JB_CONF_ENABLE "enable"
+#define AST_JB_CONF_FORCE "force"
+#define AST_JB_CONF_MAX_SIZE "maxsize"
+#define AST_JB_CONF_RESYNCH_THRESHOLD "resyncthreshold"
+#define AST_JB_CONF_IMPL "impl"
+#define AST_JB_CONF_LOG "log"
+
+
+struct ast_jb_impl;
+
+
+/*!
+ * \brief General jitterbuffer state.
+ */
+struct ast_jb
+{
+	/*! \brief Jitterbuffer configuration. */
+	struct ast_jb_conf conf;
+	/*! \brief Jitterbuffer implementation to be used. */
+	struct ast_jb_impl *impl;
+	/*! \brief Jitterbuffer object, passed to the implementation. */
+	void *jbobj;
+	/*! \brief The time the jitterbuffer was created. */
+	struct timeval timebase;
+	/*! \brief The time the next frame should be played. */
+	long next;
+	/*! \brief Voice format of the last frame in. */
+	int last_format;
+	/*! \brief File for frame timestamp tracing. */
+	FILE *logfile;
+	/*! \brief Jitterbuffer internal state flags. */
+	unsigned int flags;
+};
+
+
+/*!
+ * \brief Checks the need of a jb use in a generic bridge.
+ * \param c0 first bridged channel.
+ * \param c1 second bridged channel.
+ *
+ * Called from ast_generic_bridge() when two channels are entering in a bridge.
+ * The function checks the need of a jitterbuffer, depending on both channel's
+ * configuration and technology properties. As a result, this function sets
+ * appropriate internal jb flags to the channels, determining further behaviour
+ * of the bridged jitterbuffers.
+ *
+ * \return zero if there are no jitter buffers in use, non-zero if there are
+ */
+int ast_jb_do_usecheck(struct ast_channel *c0, struct ast_channel *c1);
+
+
+/*!
+ * \brief Calculates the time, left to the closest delivery moment in a bridge.
+ * \param c0 first bridged channel.
+ * \param c1 second bridged channel.
+ * \param time_left bridge time limit, or -1 if not set.
+ *
+ * Called from ast_generic_bridge() to determine the maximum time to wait for
+ * activity in ast_waitfor_n() call. If neihter of the channels is using jb,
+ * this function returns the time limit passed.
+ *
+ * \return maximum time to wait.
+ */
+int ast_jb_get_when_to_wakeup(struct ast_channel *c0, struct ast_channel *c1, int time_left);
+
+
+/*!
+ * \brief Puts a frame into a channel jitterbuffer.
+ * \param chan channel.
+ * \param frame frame.
+ *
+ * Called from ast_generic_bridge() to put a frame into a channel's jitterbuffer.
+ * The function will successfuly enqueue a frame if and only if:
+ * 1. the channel is using a jitterbuffer (as determined by ast_jb_do_usecheck()),
+ * 2. the frame's type is AST_FRAME_VOICE,
+ * 3. the frame has timing info set and has length >= 2 ms,
+ * 4. there is no some internal error happened (like failed memory allocation).
+ * Frames, successfuly queued, should be delivered by the channel's jitterbuffer,
+ * when their delivery time has came.
+ * Frames, not successfuly queued, should be delivered immediately.
+ * Dropped by the jb implementation frames are considered successfuly enqueued as
+ * far as they should not be delivered at all.
+ *
+ * \return zero if the frame was queued, -1 if not.
+ */
+int ast_jb_put(struct ast_channel *chan, struct ast_frame *f);
+
+
+/*!
+ * \brief Deliver the queued frames that should be delivered now for both channels.
+ * \param c0 first bridged channel.
+ * \param c1 second bridged channel.
+ *
+ * Called from ast_generic_bridge() to deliver any frames, that should be delivered
+ * for the moment of invocation. Does nothing if neihter of the channels is using jb
+ * or has any frames currently queued in. The function delivers frames usig ast_write()
+ * each of the channels.
+ */
+void ast_jb_get_and_deliver(struct ast_channel *c0, struct ast_channel *c1);
+
+
+/*!
+ * \brief Destroys jitterbuffer on a channel.
+ * \param chan channel.
+ *
+ * Called from ast_channel_free() when a channel is destroyed.
+ */
+void ast_jb_destroy(struct ast_channel *chan);
+
+
+/*!
+ * \brief Sets jitterbuffer configuration property.
+ * \param conf configuration to store the property in.
+ * \param varname property name.
+ * \param value property value.
+ *
+ * Called from a channel driver to build a jitterbuffer configuration tipically when
+ * reading a configuration file. It is not neccessary for a channel driver to know
+ * each of the jb configuration property names. The jitterbuffer itself knows them.
+ * The channel driver can pass each config var it reads through this function. It will
+ * return 0 if the variable was consumed from the jb conf.
+ *
+ * \return zero if the property was set to the configuration, -1 if not.
+ */
+int ast_jb_read_conf(struct ast_jb_conf *conf, char *varname, char *value);
+
+
+/*!
+ * \brief Configures a jitterbuffer on a channel.
+ * \param chan channel to configure.
+ * \param conf configuration to apply.
+ *
+ * Called from a channel driver when a channel is created and its jitterbuffer needs
+ * to be configured.
+ */
+void ast_jb_configure(struct ast_channel *chan, const struct ast_jb_conf *conf);
+
+
+/*!
+ * \brief Copies a channel's jitterbuffer configuration.
+ * \param chan channel.
+ * \param conf destination.
+ */
+void ast_jb_get_config(const struct ast_channel *chan, struct ast_jb_conf *conf);
+
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif /* _ABSTRACT_JB_H_ */

Added: trunk/scx_jitterbuf.c
===================================================================
--- trunk/scx_jitterbuf.c	2006-05-31 21:56:33 UTC (rev 202)
+++ trunk/scx_jitterbuf.c	2006-05-31 22:01:54 UTC (rev 203)
@@ -0,0 +1,351 @@
+/*
+ * scx_jitterbuf: jitterbuffering algorithm
+ *
+ * Copyright (C) 2005, Attractel OOD
+ *
+ * Contributors:
+ * Slav Klenov <slav at securax.org>
+ *
+ * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file 
+ * 
+ * \brief Jitterbuffering algorithm.
+ * 
+ * \author Slav Klenov <slav at securax.org>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "asterisk.h"
+ASTERISK_FILE_VERSION(__FILE__, "$Revision $")
+
+#include "asterisk/utils.h"
+#include "scx_jitterbuf.h"
+
+#undef SCX_JB_DEBUG
+
+#ifdef SCX_JB_DEBUG
+#define ASSERT(a)
+#else
+#define ASSERT(a) assert(a)
+#endif
+
+/*! \brief private scx_jb structure */
+struct scx_jb
+{
+	struct scx_jb_frame *frames;
+	struct scx_jb_frame *tail;
+	struct scx_jb_conf conf;
+	long rxcore;
+	long delay;
+	long next_delivery;
+	int force_resynch;
+};
+
+
+static struct scx_jb_frame *alloc_jb_frame(struct scx_jb *jb);
+static void release_jb_frame(struct scx_jb *jb, struct scx_jb_frame *frame);
+static void get_jb_head(struct scx_jb *jb, struct scx_jb_frame *frame);
+static int resynch_jb(struct scx_jb *jb, void *data, long ms, long ts, long now);
+
+static inline struct scx_jb_frame *alloc_jb_frame(struct scx_jb *jb)
+{
+	return ast_calloc(1, sizeof(struct scx_jb_frame));
+}
+
+static inline void release_jb_frame(struct scx_jb *jb, struct scx_jb_frame *frame)
+{
+	free(frame);
+}
+
+static void get_jb_head(struct scx_jb *jb, struct scx_jb_frame *frame)
+{
+	struct scx_jb_frame *fr;
+	
+	/* unlink the frame */
+	fr = jb->frames;
+	jb->frames = fr->next;
+	if (jb->frames) {
+		jb->frames->prev = NULL;
+	} else {
+		/* the jb is empty - update tail */
+		jb->tail = NULL;
+	}
+	
+	/* update next */
+	jb->next_delivery = fr->delivery + fr->ms;
+	
+	/* copy the destination */
+	memcpy(frame, fr, sizeof(struct scx_jb_frame));
+	
+	/* and release the frame */
+	release_jb_frame(jb, fr);
+}
+
+
+struct scx_jb *scx_jb_new(struct scx_jb_conf *conf)
+{
+	struct scx_jb *jb;
+	
+	if (!(jb = ast_calloc(1, sizeof(*jb))))
+		return NULL;
+	
+	/* First copy our config */
+	memcpy(&jb->conf, conf, sizeof(struct scx_jb_conf));
+
+	/* we dont need the passed config anymore - continue working with the saved one */
+	conf = &jb->conf;
+	
+	/* validate the configuration */
+	if (conf->jbsize < 1)
+		conf->jbsize = SCX_JB_SIZE_DEFAULT;
+
+	if (conf->resync_threshold < 1)
+		conf->resync_threshold = SCX_JB_RESYNCH_THRESHOLD_DEFAULT;
+	
+	/* Set the constant delay to the jitterbuf */
+	jb->delay = conf->jbsize;
+	
+	return jb;
+}
+
+
+void scx_jb_destroy(struct scx_jb *jb)
+{
+	/* jitterbuf MUST be empty before it can be destroyed */
+	ASSERT(jb->frames == NULL);
+	
+	free(jb);
+}
+
+
+static int resynch_jb(struct scx_jb *jb, void *data, long ms, long ts, long now)
+{
+	long diff, offset;
+	struct scx_jb_frame *frame;
+	
+	/* If jb is empty, just reinitialize the jb */
+	if (!jb->frames) {
+		/* debug check: tail should also be NULL */
+		ASSERT(jb->tail == NULL);
+		
+		return scx_jb_put_first(jb, data, ms, ts, now);
+	}
+	
+	/* Adjust all jb state just as the new frame is with delivery = the delivery of the last
+	   frame (e.g. this one with max delivery) + the length of the last frame. */
+	
+	/* Get the diff in timestamps */
+	diff = ts - jb->tail->ts;
+	
+	/* Ideally this should be just the length of the last frame. The deviation is the desired
+	   offset */
+	offset = diff - jb->tail->ms;
+	
+	/* Do we really need to resynch, or this is just a frame for dropping? */
+	if (!jb->force_resynch && (offset < jb->conf.resync_threshold && offset > -jb->conf.resync_threshold))
+		return SCX_JB_DROP;
+	
+	/* Reset the force resynch flag */
+	jb->force_resynch = 0;
+	
+	/* apply the offset to the jb state */
+	jb->rxcore -= offset;
+	frame = jb->frames;
+	while (frame) {
+		frame->ts += offset;
+		frame = frame->next;
+	}
+	
+	/* now jb_put() should add the frame at a last position */
+	return scx_jb_put(jb, data, ms, ts, now);
+}
+
+
+void scx_jb_set_force_resynch(struct scx_jb *jb)
+{
+	jb->force_resynch = 1;
+}
+
+
+int scx_jb_put_first(struct scx_jb *jb, void *data, long ms, long ts, long now)
+{
+	/* this is our first frame - set the base of the receivers time */
+	jb->rxcore = now - ts;
+	
+	/* init next for a first time - it should be the time the first frame should be played */
+	jb->next_delivery = now + jb->delay;
+	
+	/* put the frame */
+	return scx_jb_put(jb, data, ms, ts, now);
+}
+
+
+int scx_jb_put(struct scx_jb *jb, void *data, long ms, long ts, long now)
+{
+	struct scx_jb_frame *frame, *next, *newframe;
+	long delivery;
+	
+	/* debug check the validity of the input params */
+	ASSERT(data != NULL);
+	/* do not allow frames shorter than 2 ms */
+	ASSERT(ms >= 2);
+	ASSERT(ts >= 0);
+	ASSERT(now >= 0);
+	
+	delivery = jb->rxcore + jb->delay + ts;
+	
+	/* check if the new frame is not too late */
+	if (delivery < jb->next_delivery) {
+		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
+		   the force resynch flag was not set. */
+		return resynch_jb(jb, data, ms, ts, now);
+	}
+	
+	/* what if the delivery time is bigger than next + delay? Seems like a frame for the future.
+	   However, allow more resync_threshold ms in advance */
+	if (delivery > jb->next_delivery + jb->delay + jb->conf.resync_threshold) {
+		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
+		   the force resynch flag was not set. */
+		return resynch_jb(jb, data, ms, ts, now);
+	}
+
+	/* find the right place in the frames list, sorted by delivery time */
+	frame = jb->tail;
+	while (frame && frame->delivery > delivery) {
+		frame = frame->prev;
+	}
+	
+	/* Check if the new delivery time is not covered already by the chosen frame */
+	if (frame && (frame->delivery == delivery ||
+		         delivery < frame->delivery + frame->ms ||
+		         (frame->next && delivery + ms > frame->next->delivery)))
+	{
+		/* TODO: Should we check for resynch here? Be careful to do not allow threshold smaller than
+		   the size of the jb */
+		
+		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
+		   the force resynch flag was not set. */
+		return resynch_jb(jb, data, ms, ts, now);
+	}
+	
+	/* Reset the force resynch flag */
+	jb->force_resynch = 0;
+	
+	/* Get a new frame */
+	newframe = alloc_jb_frame(jb);
+	newframe->data = data;
+	newframe->ts = ts;
+	newframe->ms = ms;
+	newframe->delivery = delivery;
+	
+	/* and insert it right on place */
+	if (frame) {
+		next = frame->next;
+		frame->next = newframe;
+		if (next) {
+			newframe->next = next;
+			next->prev = newframe;
+		} else {
+			/* insert after the last frame - should update tail */
+			jb->tail = newframe;
+			newframe->next = NULL;
+		}
+		newframe->prev = frame;
+		
+		return SCX_JB_OK;
+	} else if (!jb->frames) {
+		/* the frame list is empty or thats just the first frame ever */
+		/* tail should also be NULL is that case */
+		ASSERT(jb->tail == NULL);
+		jb->frames = jb->tail = newframe;
+		newframe->next = NULL;
+		newframe->prev = NULL;
+		
+		return SCX_JB_OK;
+	} else {
+		/* insert on a first position - should update frames head */
+		newframe->next = jb->frames;
+		newframe->prev = NULL;
+		jb->frames->prev = newframe;
+		jb->frames = newframe;
+		
+		return SCX_JB_OK;
+	}
+}
+
+
+int scx_jb_get(struct scx_jb *jb, struct scx_jb_frame *frame, long now, long interpl)
+{
+	ASSERT(now >= 0);
+	ASSERT(interpl >= 2);
+	
+	if (now < jb->next_delivery) {
+		/* too early for the next frame */
+		return SCX_JB_NOFRAME;
+	}
+	
+	/* Is the jb empty? */
+	if (!jb->frames) {
+		/* should interpolate a frame */
+		/* update next */
+		jb->next_delivery += interpl;
+		
+		return SCX_JB_INTERP;
+	}
+	
+	/* Isn't it too late for the first frame available in the jb? */
+	if (now > jb->frames->delivery + jb->frames->ms) {
+		/* yes - should drop this frame and update next to point the next frame (get_jb_head() does it) */
+		get_jb_head(jb, frame);
+		
+		return SCX_JB_DROP;
+	}
+	
+	/* isn't it too early to play the first frame available? */
+	if (now < jb->frames->delivery) {
+		/* yes - should interpolate one frame */
+		/* update next */
+		jb->next_delivery += interpl;
+		
+		return SCX_JB_INTERP;
+	}
+	
+	/* we have a frame for playing now (get_jb_head() updates next) */
+	get_jb_head(jb, frame);
+	
+	return SCX_JB_OK;
+}
+
+
+long scx_jb_next(struct scx_jb *jb)
+{
+	return jb->next_delivery;
+}
+
+
+int scx_jb_remove(struct scx_jb *jb, struct scx_jb_frame *frameout)
+{
+	if (!jb->frames)
+		return SCX_JB_NOFRAME;
+	
+	get_jb_head(jb, frameout);
+	
+	return SCX_JB_OK;
+}

Added: trunk/scx_jitterbuf.h
===================================================================
--- trunk/scx_jitterbuf.h	2006-05-31 21:56:33 UTC (rev 202)
+++ trunk/scx_jitterbuf.h	2006-05-31 22:01:54 UTC (rev 203)
@@ -0,0 +1,95 @@
+/*
+ * scx_jitterbuf: jitterbuffering algorithm
+ *
+ * Copyright (C) 2005, Attractel OOD
+ *
+ * Contributors:
+ * Slav Klenov <slav at securax.org>
+ *
+ * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file 
+ * 
+ * \brief Jitterbuffering algorithm.
+ * 
+ */
+
+#ifndef _SCX_JITTERBUF_H_
+#define _SCX_JITTERBUF_H_
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+
+/* return codes */
+enum {
+	SCX_JB_OK,
+	SCX_JB_DROP,
+	SCX_JB_INTERP,
+	SCX_JB_NOFRAME
+};
+
+
+/* defaults */
+#define SCX_JB_SIZE_DEFAULT 200
+#define SCX_JB_RESYNCH_THRESHOLD_DEFAULT 1000
+
+
+/* jb configuration properties */
+struct scx_jb_conf
+{
+	long jbsize;
+ 	long resync_threshold;
+};
+
+
+struct scx_jb_frame
+{
+	void *data;
+	long ts;
+	long ms;
+	long delivery;
+	struct scx_jb_frame *next;
+	struct scx_jb_frame *prev;
+};
+
+
+struct scx_jb;
+
+
+/* jb interface */
+
+struct scx_jb * scx_jb_new(struct scx_jb_conf *conf);
+
+void scx_jb_destroy(struct scx_jb *jb);
+
+int scx_jb_put_first(struct scx_jb *jb, void *data, long ms, long ts, long now);
+
+int scx_jb_put(struct scx_jb *jb, void *data, long ms, long ts, long now);
+
+int scx_jb_get(struct scx_jb *jb, struct scx_jb_frame *frame, long now, long interpl);
+
+long scx_jb_next(struct scx_jb *jb);
+
+int scx_jb_remove(struct scx_jb *jb, struct scx_jb_frame *frameout);
+
+void scx_jb_set_force_resynch(struct scx_jb *jb);
+
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif /* _SCX_JITTERBUF_H_ */



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 01:25:57 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 01:25:57 +0200
Subject: [solid-pbx-svn] r204 - in trunk: . apps
Message-ID: <200605312325.k4VNPvRL023110@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 01:25:48 +0200 (Thu, 01 Jun 2006)
New Revision: 204

Modified:
   trunk/apps/app_meetme.c
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r31193

------------------------------------------------------------------------
r31162 | kpfleming | 2006-06-01 00:28:03 +0200 (Thu, 01 Jun 2006) | 10 lines

Merged revisions 31161 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31161 | kpfleming | 2006-05-31 17:26:38 -0500 (Wed, 31 May 2006) | 2 lines

silence a warning message that is not a warning

.......

------------------------------------------------------------------------
r31163 | file | 2006-06-01 00:54:58 +0200 (Thu, 01 Jun 2006) | 2 lines

Fix up meetme some more (thanks TonyM!!!)

------------------------------------------------------------------------
r31193 | file | 2006-06-01 01:10:56 +0200 (Thu, 01 Jun 2006) | 2 lines

Documentation changes for Qwell

------------------------------------------------------------------------


Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-05-31 22:01:54 UTC (rev 203)
+++ trunk/apps/app_meetme.c	2006-05-31 23:25:48 UTC (rev 204)
@@ -151,7 +151,7 @@
 	/*! If set, user will be asked to record name on entry of conference 
 	 *  without review */
 	CONFFLAG_STARTMUTED = (1 << 24)
-	/*! If set, the user will be initially muted by admin */
+	/*! If set, the user will be initially self-muted */
 };
 
 AST_APP_OPTIONS(meetme_opts, {
@@ -212,7 +212,7 @@
 "      'i' -- announce user join/leave with review\n"
 "      'I' -- announce user join/leave without review\n"
 "      'l' -- set listen only mode (Listen only, no talking)\n"
-"      'm' -- set initially muted by admin\n"
+"      'm' -- set initially muted\n"
 "      'M' -- enable music on hold when the conference has a single caller\n"
 "      'o' -- set talker optimization - treats talkers who aren't speaking as\n"
 "             being muted, meaning (a) No encode is done on transmission and\n"
@@ -250,10 +250,10 @@
 "      'K' -- Kick all users out of conference\n"
 "      'l' -- Unlock conference\n"
 "      'L' -- Lock conference\n"
-"      'm' -- Unmute conference\n"
-"      'M' -- Mute conference\n"
-"      'n' -- Unmute entire conference (except admin)\n"
-"      'N' -- Mute entire conference (except admin)\n"
+"      'm' -- Unmute one user\n"
+"      'M' -- Mute one user\n"
+"      'n' -- Unmute all users in the conference\n"
+"      'N' -- Mute all non-admin users in the conference\n"
 "      'r' -- Reset one user's volume settings\n"
 "      'R' -- Reset all users volume settings\n"
 "      's' -- Lower entire conference speaking volume\n"
@@ -702,8 +702,8 @@
 					S_OR(user->chan->cid.cid_name, "<no name>"),
 					user->chan->name,
 					user->userflags & CONFFLAG_ADMIN ? "(Admin)" : "",
-					user->adminflags & ADMINFLAG_SELFMUTED ? "(Listen only)" : "",
-					user->adminflags & ADMINFLAG_MUTED ? "(Admin Muted)" : "",
+					user->userflags & CONFFLAG_MONITOR ? "(Listen only)" : "",
+					user->adminflags & ADMINFLAG_MUTED ? "(Admin Muted)" : user->adminflags & ADMINFLAG_SELFMUTED ? "(Muted)" : "",
 					istalking(user->talking), hr, min, sec);
 			else 
 				ast_cli(fd, "%d!%s!%s!%s!%s!%s!%s!%d!%02d:%02d:%02d\n",
@@ -712,8 +712,8 @@
 					S_OR(user->chan->cid.cid_name, ""),
 					user->chan->name,
 					user->userflags  & CONFFLAG_ADMIN   ? "1" : "",
-					user->adminflags & ADMINFLAG_SELFMUTED ? "1" : "",
-					user->adminflags & ADMINFLAG_MUTED  ? "1" : "",
+					user->userflags  & CONFFLAG_MONITOR ? "1" : "",
+					user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED)  ? "1" : "",
 					user->talking, hr, min, sec);
 			
 		}
@@ -964,11 +964,7 @@
 
 	user->chan = chan;
 	user->userflags = confflags;
-	user->adminflags = 0;
-	if (confflags & CONFFLAG_STARTMUTED)
-		user->adminflags |= ADMINFLAG_MUTED;
-	if (confflags & CONFFLAG_MONITOR)
-		user->adminflags |= ADMINFLAG_SELFMUTED;
+	user->adminflags = (confflags & CONFFLAG_STARTMUTED) ? ADMINFLAG_SELFMUTED : 0;
 	user->talking = -1;
 	conf->users++;
 	/* Update table */
@@ -1380,7 +1376,7 @@
 					user->zapchannel = !retryzap;
 					goto zapretry;
 				}
-				if ((user->adminflags & ADMINFLAG_SELFMUTED) || (user->adminflags & ADMINFLAG_MUTED))
+				if ((confflags & CONFFLAG_MONITOR) || (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED)))
 					f = ast_read_noaudio(c);
 				else
 					f = ast_read(c);
@@ -1484,14 +1480,17 @@
 								menu_active = 0;
 
 								/* for admin, change both admin and use flags */
-								if (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED)) {
+								if (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED))
 									user->adminflags &= ~(ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED);
-									if (!ast_streamfile(chan, "conf-unmuted", chan->language))
-										ast_waitstream(chan, "");
-								} else {
+								else
 									user->adminflags |= (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED);
+
+								if ((confflags & CONFFLAG_MONITOR) || (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED))) {
 									if (!ast_streamfile(chan, "conf-muted", chan->language))
 										ast_waitstream(chan, "");
+								} else {
+									if (!ast_streamfile(chan, "conf-unmuted", chan->language))
+										ast_waitstream(chan, "");
 								}
 								break;
 							case '2': /* Un/Lock the Conference */
@@ -1559,19 +1558,13 @@
 								user->adminflags ^= ADMINFLAG_SELFMUTED;
 
 								/* they can't override the admin mute state */
-								if (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED)) {
-									ztc.confmode = ZT_CONF_CONF | ZT_CONF_LISTENER;
+								if ((confflags & CONFFLAG_MONITOR) || (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED))) {
 									if (!ast_streamfile(chan, "conf-muted", chan->language))
 										ast_waitstream(chan, "");
 								} else {
-									ztc.confmode = ZT_CONF_CONF | ZT_CONF_TALKER | ZT_CONF_LISTENER;
 									if (!ast_streamfile(chan, "conf-unmuted", chan->language))
 										ast_waitstream(chan, "");
 								}
-								if (ioctl(fd, ZT_SETCONF, &ztc)) {
-									ast_log(LOG_WARNING, "Error setting conference - Un/Mute\n");
-									ret = -1;
-								}
 								break;
 							case '4':
 								tweak_listen_volume(user, VOL_DOWN);
@@ -1624,8 +1617,8 @@
 					fr.data = buf;
 					fr.offset = AST_FRIENDLY_OFFSET;
 					if (!user->listen.actual && 
-						((user->adminflags & ADMINFLAG_SELFMUTED) || 
-						 (user->adminflags & ADMINFLAG_MUTED) ||
+						((confflags & CONFFLAG_MONITOR) || 
+						 (user->adminflags & (ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED)) ||
 						 (!user->talking && (confflags & CONFFLAG_OPTIMIZETALKER))
 						 )) {
 						int index;
@@ -2307,13 +2300,13 @@
 				break;					
 			case 109: /* m: Unmute */ 
 				if (user) {
-					user->adminflags &= ~ADMINFLAG_MUTED;
+					user->adminflags &= ~(ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED);
 				} else
 					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			case 110: /* n: Unmute all users */
 				AST_LIST_TRAVERSE(&cnf->userlist, user, list)
-					user->adminflags &= ~ADMINFLAG_MUTED;
+					user->adminflags &= ~(ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED);
 				break;
 			case 107: /* k: Kick user */ 
 				if (user)
@@ -2434,7 +2427,7 @@
 	if (mute)
 		user->adminflags |= ADMINFLAG_MUTED;	/* request user muting */
 	else
-		user->adminflags &= ~ADMINFLAG_MUTED;	/* request user unmuting */
+		user->adminflags &= ~(ADMINFLAG_MUTED | ADMINFLAG_SELFMUTED);	/* request user unmuting */
 
 	AST_LIST_UNLOCK(&confs);
 

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-05-31 22:01:54 UTC (rev 203)
+++ trunk/rtp.c	2006-05-31 23:25:48 UTC (rev 204)
@@ -762,7 +762,8 @@
 	ssrc = ntohl(rtpheader[2]);
 	
 	if (!mark && rtp->rxssrc && rtp->rxssrc != ssrc) {
-		ast_log(LOG_WARNING, "Forcing Marker bit, because SSRC has changed\n");
+		if (option_verbose > 1)
+			ast_verbose(VERBOSE_PREFIX_2 "Forcing Marker bit, because SSRC has changed\n");
 		mark = 1;
 	}
 



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 02:25:47 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 02:25:47 +0200
Subject: [solid-pbx-svn] r205 - in trunk: . cdr res
Message-ID: <200606010025.k510Plmc005640@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 02:25:36 +0200 (Thu, 01 Jun 2006)
New Revision: 205

Modified:
   trunk/Makefile
   trunk/cdr/cdr_radius.c
   trunk/res/res_agi.c
Log:
Update to Asterisk SVN trunk r31226

------------------------------------------------------------------------
r31195 | russell | 2006-06-01 01:51:39 +0200 (Thu, 01 Jun 2006) | 11 lines

Merged revisions 31194 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31194 | russell | 2006-05-31 19:50:00 -0400 (Wed, 31 May 2006) | 3 lines

if the connection to a FastAGI server fails because of a timeout, log a more
informative log message

.......

------------------------------------------------------------------------
r31225 | russell | 2006-06-01 02:09:18 +0200 (Thu, 01 Jun 2006) | 3 lines

fix the problem where defaults.h is missing after a forced make clean in a
different way that actually works

------------------------------------------------------------------------
r31226 | russell | 2006-06-01 02:15:25 +0200 (Thu, 01 Jun 2006) | 2 lines

change a warning message to a debug message

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-05-31 23:25:48 UTC (rev 204)
+++ trunk/Makefile	2006-06-01 00:25:36 UTC (rev 205)
@@ -371,7 +371,7 @@
 	@echo " +               make install                +"  
 	@echo " +-------------------------------------------+"  
 
-all: cleantest defaults.h config.status menuselect.makeopts depend asterisk subdirs
+all: cleantest config.status menuselect.makeopts depend asterisk subdirs
 
 config.status: configure
 	@CFLAGS="" ./configure
@@ -907,6 +907,7 @@
 cleantest:
 	@if cmp -s .cleancount .lastclean ; then echo ; else \
 		$(MAKE) clean; cp -f .cleancount .lastclean;\
+		$(MAKE) defaults.h;\
 	fi
 
 _uninstall:

Modified: trunk/cdr/cdr_radius.c
===================================================================
--- trunk/cdr/cdr_radius.c	2006-05-31 23:25:48 UTC (rev 204)
+++ trunk/cdr/cdr_radius.c	2006-06-01 00:25:36 UTC (rev 205)
@@ -47,6 +47,7 @@
 #include "asterisk/module.h"
 #include "asterisk/logger.h"
 #include "asterisk/utils.h"
+#include "asterisk/options.h"
 
 /*! ISO 8601 standard format */
 #define DATE_FORMAT "%Y-%m-%d %T %z"
@@ -216,7 +217,8 @@
 	VALUE_PAIR *send = NULL;
 
 	if (build_radius_record(&send, cdr)) {
-		ast_log(LOG_WARNING, "Unable to create RADIUS record. CDR not recorded!\n");
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Unable to create RADIUS record. CDR not recorded!\n");
 		return result;
 	}
 	

Modified: trunk/res/res_agi.c
===================================================================
--- trunk/res/res_agi.c	2006-05-31 23:25:48 UTC (rev 204)
+++ trunk/res/res_agi.c	2006-06-01 00:25:36 UTC (rev 205)
@@ -149,6 +149,7 @@
 	struct sockaddr_in sin;
 	struct hostent *hp;
 	struct ast_hostent ahp;
+	int res;
 
 	/* agiusl is "agi://host.domain[:port][/script/name]" */
 	host = ast_strdupa(agiurl + 6);	/* Remove agi:// */
@@ -200,9 +201,13 @@
 
 	pfds[0].fd = s;
 	pfds[0].events = POLLOUT;
-	while (poll(pfds, 1, MAX_AGI_CONNECT) != 1) {
+	while ((res = poll(pfds, 1, MAX_AGI_CONNECT)) != 1) {
 		if (errno != EINTR) {
-			ast_log(LOG_WARNING, "Connect to '%s' failed: %s\n", agiurl, strerror(errno));
+			if (!res) {
+				ast_log(LOG_WARNING, "FastAGI connection to '%s' timed out after MAX_AGI_CONNECT (%d) milliseconds.\n",
+					agiurl, MAX_AGI_CONNECT);
+			} else
+				ast_log(LOG_WARNING, "Connect to '%s' failed: %s\n", agiurl, strerror(errno));
 			close(s);
 			return AGI_RESULT_FAILURE;
 		}



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 07:25:43 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 07:25:43 +0200
Subject: [solid-pbx-svn] r206 - in trunk: channels configs
Message-ID: <200606010525.k515Phh2023119@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 07:25:31 +0200 (Thu, 01 Jun 2006)
New Revision: 206

Modified:
   trunk/channels/chan_skinny.c
   trunk/configs/skinny.conf.sample
Log:
Update to Asterisk SVN trunk r31273

------------------------------------------------------------------------
r31250 | north | 2006-06-01 06:35:00 +0200 (Thu, 01 Jun 2006) | 4 lines

Nobody saw this coming, I bet.

jitterbuffer!

------------------------------------------------------------------------


Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-01 00:25:36 UTC (rev 205)
+++ trunk/channels/chan_skinny.c	2006-06-01 05:25:31 UTC (rev 206)
@@ -69,6 +69,7 @@
 #include "asterisk/utils.h"
 #include "asterisk/dsp.h"
 #include "asterisk/stringfields.h"
+#include "asterisk/abstract_jb.h"
 
 /*************************************
  * Skinny/Asterisk Protocol Settings *
@@ -116,6 +117,15 @@
 #define htoles(x) __bswap_16(x)
 #endif
 
+/*! Global jitterbuffer configuration - by default, jb is disabled */
+static struct ast_jb_conf default_jbconf =
+{
+	.flags = 0,
+	.max_size = -1,
+	.resync_threshold = -1,
+	.impl = ""
+};
+static struct ast_jb_conf global_jbconf;
 
 /*********************
  * Protocol Messages *
@@ -816,6 +826,8 @@
 	int nat;
 	int outgoing;
 	int alreadygone;
+	struct ast_jb_conf jbconf;
+
 	struct skinny_subchannel *next;
 };
 
@@ -1603,6 +1615,10 @@
 							callnums++;
 							sub->cxmode = SKINNY_CX_INACTIVE;
 							sub->nat = nat;
+
+							/* Assign default jb conf to the new skinny_subchannel */
+							memcpy(&sub->jbconf, &global_jbconf, sizeof(struct ast_jb_conf));
+
 							sub->next = l->sub;
 							l->sub = sub;
 						} else {
@@ -2292,6 +2308,10 @@
 				tmp = NULL;
 			}
 		}
+
+		/* Configure the new channel jb */
+		if (tmp && sub && sub->rtp)
+			ast_jb_configure(tmp, &sub->jbconf);
 	} else {
 		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
 	}
@@ -3094,10 +3114,21 @@
 		ast_log(LOG_NOTICE, "Unable to load config %s, Skinny disabled\n", config);
 		return 0;
 	}
+	memset(&bindaddr, 0, sizeof(bindaddr));
+
+	/* Copy the default jb config over global_jbconf */
+	memcpy(&global_jbconf, &default_jbconf, sizeof(struct ast_jb_conf));
+
 	/* load the general section */
-	memset(&bindaddr, 0, sizeof(bindaddr));
 	v = ast_variable_browse(cfg, "general");
 	while(v) {
+		/* handle jb conf */
+		if (!ast_jb_read_conf(&global_jbconf, v->name, v->value))
+		{
+			v = v->next;
+			continue;
+		}
+
 		/* Create the interface list */
 		if (!strcasecmp(v->name, "bindaddr")) {
 			if (!(hp = ast_gethostbyname(v->value, &ahp))) {

Modified: trunk/configs/skinny.conf.sample
===================================================================
--- trunk/configs/skinny.conf.sample	2006-06-01 00:25:36 UTC (rev 205)
+++ trunk/configs/skinny.conf.sample	2006-06-01 05:25:31 UTC (rev 206)
@@ -10,7 +10,34 @@
 ;allow=all
 ;disallow=
 
+;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+;jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
+                             ; skinny channel. Defaults to "no". An enabled jitterbuffer will
+                             ; be used only if the sending side can create and the receiving
+                             ; side can not accept jitter. The skinny channel can accept
+                             ; jitter, thus a jitterbuffer on the receive skinny side will be
+                             ; used only if it is forced and enabled.
 
+;jbforce = no                ; Forces the use of a jitterbuffer on the receive side of a skinny
+                             ; channel. Defaults to "no".
+
+;jbmaxsize = 200             ; Max length of the jitterbuffer in milliseconds.
+
+;jbresyncthreshold = 1000    ; Jump in the frame timestamps over which the jitterbuffer is
+                             ; resynchronized. Useful to improve the quality of the voice, with
+                             ; big jumps in/broken timestamps, usualy sent from exotic devices
+                             ; and programs. Defaults to 1000.
+
+;jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a
+                             ; skinny channel. Two implementation are currently available
+                             ; - "fixed" (with size always equals to jbmaxsize)
+                             ; - "adaptive" (with variable size, actually the new jb of IAX2).
+                             ; Defaults to fixed.
+
+;jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
+;-----------------------------------------------------------------------------------
+
+
 ; Typical config for 12SP+
 ;[florian]
 ;device=SEP00D0BA847E6B



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 10:25:37 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 10:25:37 +0200
Subject: [solid-pbx-svn] r207 - in trunk: channels configs include/asterisk res
Message-ID: <200606010825.k518PbFZ001468@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 10:25:34 +0200 (Thu, 01 Jun 2006)
New Revision: 207

Modified:
   trunk/channels/chan_sip.c
   trunk/configs/jabber.conf.sample
   trunk/include/asterisk/jabber.h
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r31297

------------------------------------------------------------------------
r31274 | oej | 2006-06-01 09:30:45 +0200 (Thu, 01 Jun 2006) | 7 lines

Commit of the new SIP transfer support (oej/siptransfer branch)
- improved support of attended transfers (REFER with replaces)
- support of INVITE/replaces in the context of a transfer
- improved support of blind transfers (REFER)

Thanks to Voop, Nuvio and Foniris for sponsoring this work.

------------------------------------------------------------------------
r31275 | mogorman | 2006-06-01 09:49:47 +0200 (Thu, 01 Jun 2006) | 3 lines

adds statusmessage customization from Julian Lyndon-Smith
and fixes bug with pruneregister

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-01 05:25:31 UTC (rev 206)
+++ trunk/channels/chan_sip.c	2006-06-01 08:25:34 UTC (rev 207)
@@ -638,7 +638,7 @@
 #define SIP_USECLIENTCODE	(1 << 12)	/*!< Trust X-ClientCode info message */
 #define SIP_OUTGOING		(1 << 13)	/*!< Is this an outgoing call? */
 #define SIP_CAN_BYE		(1 << 14)	/*!< Can we send BYE on this dialog? */
-#define SIP_FREEBIT3		(1 << 15)	/*!< Free for session-related use */
+#define SIP_DEFER_BYE_ON_TRANSFER	(1 << 15)	/*!< Do not hangup at first ast_hangup */
 #define SIP_DTMF		(3 << 16)	/*!< DTMF Support: four settings, uses two bits */
 #define SIP_DTMF_RFC2833	(0 << 16)	/*!< DTMF Support: RTP DTMF - "rfc2833" */
 #define SIP_DTMF_INBAND		(1 << 16)	/*!< DTMF Support: Inband audio, only for ULAW/ALAW - "inband" */
@@ -763,9 +763,6 @@
 		AST_STRING_FIELD(opaque);	/*!< Opaque nonsense */
 		AST_STRING_FIELD(qop);		/*!< Quality of Protection, since SIP wasn't complicated enough yet. */
 		AST_STRING_FIELD(domain);	/*!< Authorization domain */
-		AST_STRING_FIELD(refer_to);	/*!< Place to store REFER-TO extension */
-		AST_STRING_FIELD(referred_by);	/*!< Place to store REFERRED-BY extension */
-		AST_STRING_FIELD(refer_contact);/*!< Place to store Contact info from a REFER extension */
 		AST_STRING_FIELD(from);		/*!< The From: header */
 		AST_STRING_FIELD(useragent);	/*!< User agent in SIP request */
 		AST_STRING_FIELD(exten);	/*!< Extension where to start */
@@ -824,7 +821,6 @@
 	struct sockaddr_in recv;		/*!< Received as */
 	struct in_addr ourip;			/*!< Our IP */
 	struct ast_channel *owner;		/*!< Who owns us */
-	struct sip_pvt *refer_call;		/*!< Call we are referring */
 	struct sip_route *route;		/*!< Head of linked list of routing steps (fm Record-Route) */
 	int route_persistant;			/*!< Is this the "real" route? */
 	struct sip_auth *peerauth;		/*!< Realm authentication */
@@ -1115,6 +1111,7 @@
 static const char *hangup_cause2sip(int cause);
 static int sip_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
 static struct sip_pvt *find_call(struct sip_request *req, struct sockaddr_in *sin, const int intended_method);
+int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno);
 
 /*--- Codec handling / SDP */
 static void try_suggested_sip_codec(struct sip_pvt *p);
@@ -1250,6 +1247,7 @@
 static int handle_request_subscribe(struct sip_pvt *p, struct sip_request *req, struct sockaddr_in *sin, int seqno, char *e);
 static void handle_request_info(struct sip_pvt *p, struct sip_request *req);
 static int handle_request_options(struct sip_pvt *p, struct sip_request *req);
+static int handle_invite_replaces(struct sip_pvt *p, struct sip_request *req, int debug, int ignore, int seqno, struct sockaddr_in *sin);
 
 /*------Response handling functions */
 static void handle_response_invite(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int seqno);
@@ -2880,10 +2878,29 @@
 	if (option_debug && sipdebug)
 		ast_log(LOG_DEBUG, "Hangup call %s, SIP callid %s)\n", ast->name, p->callid);
 
+	if (ast_test_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER)) {
+		if (option_debug >3)
+			ast_log(LOG_DEBUG, "SIP Transfer: Not hanging up right now... Rescheduling hangup.\n");
+		if (p->autokillid > -1)
+			sip_cancel_destroy(p);
+		sip_scheddestroy(p, 32000);
+		ast_clear_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Really hang up next time */
+		ast_clear_flag(&p->flags[0], SIP_NEEDDESTROY);
+		p->owner = NULL;  /* Owner will be gone after we return, so take it away */
+		return 0;
+	}
+	if (option_debug) {
+		if (ast_test_flag(ast, AST_FLAG_ZOMBIE) && p->refer && option_debug)
+         		ast_log(LOG_DEBUG, "SIP Transfer: Hanging up Zombie channel %s after transfer ... Call-ID: %s\n", ast->name, p->callid);
+		else 
+			ast_log(LOG_DEBUG, "Hangup call %s, SIP callid %s)\n", ast->name, p->callid);
+	}
+
 	ast_mutex_lock(&p->lock);
 	if (option_debug && sipdebug)
 		ast_log(LOG_DEBUG, "update_call_counter(%s) - decrement call limit counter on hangup\n", p->username);
 	update_call_counter(p, DEC_CALL_LIMIT);
+
 	/* Determine how to disconnect */
 	if (p->owner != ast) {
 		ast_log(LOG_WARNING, "Huh?  We aren't the owner? Can't hangup call.\n");
@@ -3079,6 +3096,19 @@
 		p->owner = newchan;
 		ret = 0;
 	}
+	if (option_debug > 2)
+		ast_log(LOG_DEBUG, "SIP Fixup: New owner for dialogue %s: %s (Old parent: %s)\n", p->callid, p->owner->name, oldchan->name);
+	if (p->refer) {
+		if (option_debug > 2) {
+			if (oldchan->tech_pvt) {
+				struct sip_pvt *old = oldchan->tech_pvt;
+				ast_log(LOG_DEBUG, "Releasing connection between %s and pvt %s\n", oldchan->name, old->callid);
+			} else
+				ast_log(LOG_DEBUG, "Hmmm. No sip_pvt to release for %s\n", oldchan->name);
+		}
+		oldchan->tech_pvt = NULL;	/* Release connection between old channel and it's pvt so we can hang up in peace */
+	}
+
 	ast_mutex_unlock(&p->lock);
 	return ret;
 }
@@ -4307,6 +4337,10 @@
 	snprintf(req->header[req->headers], maxlen, "%s: %s\r\n", var, value);
 	req->len += strlen(req->header[req->headers]);
 	req->headers++;
+	if (req->headers < SIP_MAX_HEADERS)
+		req->headers++;
+	else
+		ast_log(LOG_WARNING, "Out of SIP header space... Will generate broken SIP message\n");
 
 	return 0;	
 }
@@ -6506,6 +6540,9 @@
 		p->addr = pvt->recv;
 	}
 
+	/* Save SIP options profile */
+	p->sipoptions = pvt->sipoptions;
+
 	if (c)	/* Overwrite the default username from config at registration */
 		ast_copy_string(p->username, c, sizeof(p->username));
 	else
@@ -7223,167 +7260,227 @@
 	return sip_pvt_ptr;
 }
 
-/*! \brief Call transfer support (the REFER method) */
-static int get_refer_info(struct sip_pvt *sip_pvt, struct sip_request *outgoing_req)
+/*! \brief Call transfer support (the REFER method) 
+ * 	Extracts Refer headers into pvt dialog structure */
+static int get_refer_info(struct sip_pvt *transferer, struct sip_request *outgoing_req)
 {
 
-	const char *p_refer_to = NULL;
-	const char *h_contact = NULL;
 	const char *p_referred_by = NULL;
-	char *h_refer_to = NULL, *h_referred_by = NULL;
-	char *replace_callid = "", *refer_to = NULL, *referred_by = NULL, *ptr = NULL;
+	char *h_refer_to = NULL; 
+	char *h_referred_by = NULL;
+	char *refer_to;
+	const char *p_refer_to;
+	char *referred_by_uri = NULL;
+	char *ptr;
 	struct sip_request *req = NULL;
-	struct sip_pvt *sip_pvt_ptr = NULL;
-	struct ast_channel *chan = NULL, *peer = NULL;
+	const char *transfer_context = NULL;
+	struct sip_refer *referdata;
 
+
 	req = outgoing_req;
+	referdata = transferer->refer;
 
 	if (!req)
-		req = &sip_pvt->initreq;
+		req = &transferer->initreq;
 
 	if (!(p_refer_to = get_header(req, "Refer-To"))) {
-		ast_log(LOG_WARNING, "No Refer-To Header That's illegal\n");
-		return -1;
+		ast_log(LOG_WARNING, "Refer-To Header missing. Skipping transfer.\n");
+		return -2;	/* Syntax error */
 	}
 	h_refer_to = ast_strdupa(p_refer_to);
 	refer_to = get_in_brackets(h_refer_to);
+	if (pedanticsipchecking)
+		ast_uri_decode(refer_to);
 
-	if (!(p_referred_by = get_header(req, "Referred-By"))) {
-		ast_log(LOG_DEBUG, "No Referrred-By Header That's not illegal\n");
-		return -1;
+	if (strncasecmp(refer_to, "sip:", 4)) {
+		ast_log(LOG_WARNING, "Can't transfer to non-sip: URI.  (Refer-to: %s)?\n", refer_to);
+		return -3;
 	}
-	h_referred_by = ast_strdupa(p_referred_by);
-	if (pedanticsipchecking)
-		ast_uri_decode(h_referred_by);
-	referred_by = get_in_brackets(h_referred_by);
-	h_contact = get_header(req, "Contact");
-	
-	if (strncmp(refer_to, "sip:", 4)) {
-		ast_log(LOG_WARNING, "Refer-to: Huh?  Not a SIP header (%s)?\n", refer_to);
-		return -1;
-	}
+	refer_to += 4;			/* Skip sip: */
 
-	if (strncmp(referred_by, "sip:", 4)) {
-		ast_log(LOG_WARNING, "Referred-by: Huh?  Not a SIP header (%s) Ignoring?\n", referred_by);
-		referred_by = NULL;
+	/* Get referred by header if it exists */
+	if ((p_referred_by = get_header(req, "Referred-By"))) {
+		char *lessthan;
+		h_referred_by = ast_strdupa(p_referred_by);
+		if (pedanticsipchecking)
+			ast_uri_decode(h_referred_by);
+
+		/* Store referrer's caller ID name */
+		ast_copy_string(referdata->referred_by_name, h_referred_by, sizeof(referdata->referred_by_name));
+		if ((lessthan = strchr(referdata->referred_by_name, '<'))) {
+			*(lessthan - 1) = '\0';	/* Space */
+		}
+
+		referred_by_uri = get_in_brackets(h_referred_by);
+		if(strncasecmp(referred_by_uri, "sip:", 4)) {
+			ast_log(LOG_WARNING, "Huh?  Not a sip: header (Referred-by: %s). Skipping.\n", referred_by_uri);
+			referred_by_uri = (char *) NULL;
+		} else {
+			referred_by_uri += 4;		/* Skip sip: */
+		}
 	}
 
-	if (refer_to)
-		refer_to += 4;
-
-	if (referred_by)
-		referred_by += 4;
-	
-	if ((ptr = strchr(refer_to, '?'))) {
-		/* Search for arguments */
+	/* Check for arguments in the refer_to header */
+	if ((ptr = strchr(refer_to, '?'))) { /* Search for arguments */
 		*ptr = '\0';
 		ptr++;
 		if (!strncasecmp(ptr, "REPLACES=", 9)) {
-			char *p;
-			replace_callid = ast_strdupa(ptr + 9);
-			/* someday soon to support invite/replaces properly!
-			   replaces_header = ast_strdupa(replace_callid); 
-			   -anthm
-			*/
-			ast_uri_decode(replace_callid);
-			if ((ptr = strchr(replace_callid, '%'))) 
+			char *to, *from;
+
+			/* This is an attended transfer */
+			referdata->attendedtransfer = 1;
+			strncpy(referdata->replaces_callid, ptr+9, sizeof(referdata->replaces_callid));
+			ast_uri_decode(referdata->replaces_callid);
+			if ((ptr = strchr(referdata->replaces_callid, ';'))) 	/* Remove options */ {
 				*ptr = '\0';
-			if ((ptr = strchr(replace_callid, ';'))) 
-				*ptr = '\0';
-			/* Skip leading whitespace XXX memmove behaviour with overlaps ? */
-			p = ast_skip_blanks(replace_callid);
-			if (p != replace_callid)
-				memmove(replace_callid, p, strlen(p));
+			}
+			ptr++;
+
+			/* Find the different tags before we destroy the string */
+			to = strcasestr(ptr, "to-tag=");
+			from = strcasestr(ptr, "from-tag=");
+
+			/* Grab the to header */
+			if (to) {
+				ptr = to + 7;
+				if ((to = strchr(ptr, '&')))
+					*to = '\0';
+				if ((to = strchr(ptr, ';')))
+					*to = '\0';
+				ast_copy_string(referdata->replaces_callid_totag, ptr, sizeof(referdata->replaces_callid_totag));
+			}
+
+			if (from) {
+				ptr = from + 9;
+				if ((to = strchr(ptr, '&')))
+					*to = '\0';
+				if ((to = strchr(ptr, ';')))
+					*to = '\0';
+				ast_copy_string(referdata->replaces_callid_fromtag, ptr, sizeof(referdata->replaces_callid_fromtag));
+			}
+
+			if (option_debug > 1) {
+				if (!pedanticsipchecking)
+					ast_log(LOG_DEBUG,"Attended transfer: Will use Replace-Call-ID : %s (No check of from/to tags)\n", referdata->replaces_callid );
+				else
+					ast_log(LOG_DEBUG,"Attended transfer: Will use Replace-Call-ID : %s F-tag: %s T-tag: %s\n", referdata->replaces_callid, referdata->replaces_callid_fromtag ? referdata->replaces_callid_fromtag : "<none>", referdata->replaces_callid_totag ? referdata->replaces_callid_totag : "<none>" );
+			}
 		}
 	}
 	
-	/* strip domain and everything after ';' (domain should be saved in SIPDOMAIN) */
-	ptr = refer_to;
-	strsep(&ptr, "@;");	/* trim anything after @ or ; */
-	ptr = referred_by;
-	strsep(&ptr, "@;");	/* trim anything after @ or ;, NULL is ok */
+	if ((ptr = strchr(refer_to, '@'))) {	/* Separate domain */
+		char *urioption;
+		*ptr = '\0';
+		ptr++;
+		if ((urioption = strchr(ptr, ';'))) {
+			*urioption = '\0';
+			urioption++;
+		}	
+		/* Save the domain for the dial plan */
+		strncpy(referdata->refer_to_domain, ptr, sizeof(referdata->refer_to_domain));
+		if (urioption)
+			strncpy(referdata->refer_to_urioption, urioption, sizeof(referdata->refer_to_urioption));
+	}
 
-	if (sip_debug_test_pvt(sip_pvt)) {
-		ast_verbose("Transfer to %s in %s\n", refer_to, sip_pvt->context);
-		if (referred_by)
-			ast_verbose("Transfer from %s in %s\n", referred_by, sip_pvt->context);
+	if ((ptr = strchr(refer_to, ';'))) 	/* Remove options */
+		*ptr = '\0';
+	ast_copy_string(referdata->refer_to, refer_to, sizeof(referdata->refer_to));
+	
+	if ((ptr = strchr(referred_by_uri, ';'))) 	/* Remove options */
+		*ptr = '\0';
+	ast_copy_string(referdata->referred_by, referred_by_uri, sizeof(referdata->referred_by));
+
+	/* Determine transfer context */
+	if (transferer->owner)	/* Mimic behaviour in res_features.c */
+		transfer_context = pbx_builtin_getvar_helper(transferer->owner, "TRANSFER_CONTEXT");
+
+	/* By default, use the context in the channel sending the REFER */
+	if (ast_strlen_zero(transfer_context)) {
+		if (!ast_strlen_zero(transferer->owner->macrocontext))
+			transfer_context=transferer->owner->macrocontext;
+		else if (ast_strlen_zero(transferer->context))
+			transfer_context = default_context;
+		else
+			transfer_context = transferer->context;
 	}
-	if (!ast_strlen_zero(replace_callid)) {	
-		/* This is a supervised transfer */
-		ast_log(LOG_DEBUG,"Assigning Replace-Call-ID Info %s to REPLACE_CALL_ID\n", replace_callid);
-		
-		ast_string_field_free(sip_pvt, refer_to);
-		ast_string_field_free(sip_pvt, referred_by);
-		ast_string_field_free(sip_pvt, refer_contact);
-		sip_pvt->refer_call = NULL;
-		if ((sip_pvt_ptr = get_sip_pvt_byid_locked(replace_callid, NULL, NULL))) {
-			sip_pvt->refer_call = sip_pvt_ptr;
-			if (sip_pvt->refer_call == sip_pvt) {
-				ast_log(LOG_NOTICE, "Supervised transfer attempted to transfer into same call id (%s == %s)!\n", replace_callid, sip_pvt->callid);
-				sip_pvt->refer_call = NULL;
-			} else
-				return 0;
-		} else {
-			ast_log(LOG_NOTICE, "Supervised transfer requested, but unable to find callid '%s'.  Both legs must reside on Asterisk box to transfer at this time.\n", replace_callid);
-			/* XXX The refer_to could contain a call on an entirely different machine, requiring an 
-				INVITE with a replaces header -anthm XXX */
-			/* The only way to find out is to use the dialplan - oej */
+
+	strncpy(referdata->refer_to_context, transfer_context, sizeof(referdata->refer_to_context));
+	
+	/* Either an existing extension or the parking extension */
+	if (ast_exists_extension(NULL, transfer_context, refer_to, 1, NULL) ) {
+		if (sip_debug_test_pvt(transferer)) {
+			ast_verbose("SIP transfer to extension %s@%s by %s\n", refer_to, transfer_context, referred_by_uri);
 		}
-	} else if (ast_exists_extension(NULL, sip_pvt->context, refer_to, 1, NULL) || !strcmp(refer_to, ast_parking_ext())) {
-		/* This is an unsupervised transfer (blind transfer) */
-		
-		ast_log(LOG_DEBUG,"Unsupervised transfer to (Refer-To): %s\n", refer_to);
-		if (referred_by)
-			ast_log(LOG_DEBUG,"Transferred by  (Referred-by: ) %s \n", referred_by);
-		ast_log(LOG_DEBUG,"Transfer Contact Info %s (REFER_CONTACT)\n", h_contact);
-		ast_string_field_set(sip_pvt, refer_to, refer_to);
-		if (referred_by)
-			ast_string_field_set(sip_pvt, referred_by, referred_by);
-		if (h_contact)
-			ast_string_field_set(sip_pvt, refer_contact, h_contact);
-		sip_pvt->refer_call = NULL;
-		chan = sip_pvt->owner;
-		if (chan && (peer = ast_bridged_channel(chan)) != NULL) {
-			pbx_builtin_setvar_helper(chan, "BLINDTRANSFER", peer->name);
-			pbx_builtin_setvar_helper(peer, "BLINDTRANSFER", chan->name);
-		}
+		/* We are ready to transfer to the extension */
 		return 0;
-	} else if (ast_canmatch_extension(NULL, sip_pvt->context, refer_to, 1, NULL)) {
-		return 1;
-	}
+	} 
+	if (sip_debug_test_pvt(transferer))
+		ast_verbose("Failed SIP Transfer to non-existing extension %s in context %s\n n", refer_to, transfer_context);
 
+	/* Failure, we can't find this extension */
 	return -1;
 }
 
-/*! \brief  Call transfer support (old way, deprecated in the IETF) */
+
+/*! \brief Call transfer support (old way, depreciated by the IETF)--*/
 static int get_also_info(struct sip_pvt *p, struct sip_request *oreq)
 {
-	char tmp[256], *c, *a;
+	char tmp[256] = "", *c, *a;
 	struct sip_request *req = oreq;
+	struct sip_refer *referdata;
+	const char *transfer_context = NULL;
 	
-	if (!req)
+	referdata = p->refer;
+	
+	if (!oreq)
 		req = &p->initreq;
+	else
+		req = oreq;
 	ast_copy_string(tmp, get_header(req, "Also"), sizeof(tmp));
 	c = get_in_brackets(tmp);
+
+	if (pedanticsipchecking)
+		ast_uri_decode(c);
+	
 	if (strncmp(c, "sip:", 4)) {
-		ast_log(LOG_WARNING, "Huh?  Not a SIP header (%s)?\n", c);
+		ast_log(LOG_WARNING, "Huh?  Not a SIP header in Also: transfer (%s)?\n", c);
 		return -1;
 	}
 	c += 4;
-	a = c;
-	strsep(&a, "@;");	/* trim anything after @ or ; */
+	if ((a = strchr(c, '@'))) {	/* Separate Domain */
+		*a = '\0';
+		a++;
+		ast_copy_string(referdata->refer_to_domain, a, sizeof(referdata->refer_to_domain));
+	}
 	
+	if ((a = strchr(c, ';'))) 	/* Remove arguments */
+		*a = '\0';
+	
 	if (sip_debug_test_pvt(p))
 		ast_verbose("Looking for %s in %s\n", c, p->context);
 
-	if (ast_exists_extension(NULL, p->context, c, 1, NULL)) {
-		/* This is an unsupervised transfer */
+	if (p->owner)	/* Mimic behaviour in res_features.c */
+		transfer_context = pbx_builtin_getvar_helper(p->owner, "TRANSFER_CONTEXT");
+
+	/* By default, use the context in the channel sending the REFER */
+	if (!transfer_context || ast_strlen_zero(transfer_context)) {
+		if (!ast_strlen_zero(p->owner->macrocontext))
+			transfer_context = p->owner->macrocontext;
+		else if (ast_strlen_zero(p->context))
+			transfer_context = default_context;
+		else
+			transfer_context = p->context;
+	}
+	if (ast_exists_extension(NULL, transfer_context, c, 1, NULL)) {
+		/* This is a blind transfer */
 		if (option_debug)
-			ast_log(LOG_DEBUG,"Assigning Extension %s to REFER-TO\n", c);
-		ast_string_field_set(p, refer_to, c);
-		ast_string_field_free(p, referred_by);
-		ast_string_field_free(p, refer_contact);
-		p->refer_call = NULL;
+			ast_log(LOG_DEBUG,"SIP Bye-also transfer to Extension %s@%s \n", c, transfer_context);
+		ast_copy_string(referdata->refer_to, c, sizeof(referdata->refer_to));
+		ast_copy_string(referdata->referred_by, "", sizeof(referdata->referred_by));
+		ast_copy_string(referdata->refer_contact, "", sizeof(referdata->refer_contact));
+		referdata->refer_call = NULL;
+		/* Set new context */
+		ast_string_field_set(p, context, transfer_context);
 		return 0;
 	} else if (ast_canmatch_extension(NULL, p->context, c, 1, NULL)) {
 		return 1;
@@ -7391,7 +7488,6 @@
 
 	return -1;
 }
-
 /*! \brief check Via: header for hostname, port and rport request/answer */
 static int check_via(struct sip_pvt *p, struct sip_request *req)
 {
@@ -9173,6 +9269,7 @@
 				ast_cli(fd, "  * SIP Call\n");
 			ast_cli(fd, "  Direction:              %s\n", ast_test_flag(&cur->flags[0], SIP_OUTGOING)?"Outgoing":"Incoming");
 			ast_cli(fd, "  Call-ID:                %s\n", cur->callid);
+			ast_cli(fd, "  Owner channel ID:       %s\n", cur->owner ? cur->owner->name : "<none>");
 			ast_cli(fd, "  Our Codec Capability:   %d\n", cur->capability);
 			ast_cli(fd, "  Non-Codec Capability (DTMF):   %d\n", cur->noncodeccapability);
 			ast_cli(fd, "  Their Codec Capability:   %d\n", cur->peercapability);
@@ -10297,11 +10394,11 @@
 	case 202:   /* Transfer accepted */
 		/* We need  to do something here */
 		/* The transferee is now sending INVITE to target */
+		p->refer->status = REFER_ACCEPTED;
 		/* Now wait for next message */
 		if (option_debug > 2)
 			ast_log(LOG_DEBUG, "Got 202 accepted on transfer\n");
 		/* We should hang along, waiting for NOTIFY's here */
-		/* (done in a separate function) */
 		break;
 
 	case 401:   /* Not www-authorized on SIP method */
@@ -10317,6 +10414,7 @@
 		}
 		if ((p->authtries > 1) || do_proxy_auth(p, req, auth, auth2, SIP_REFER, 0)) {
 			ast_log(LOG_NOTICE, "Failed to authenticate on REFER to '%s'\n", get_header(&p->initreq, "From"));
+			p->refer->status = REFER_NOAUTH;
 			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
 		}
 		break;
@@ -10326,11 +10424,13 @@
 	case 501:   /* Method not implemented */
 		/* Return to the current call onhold */
 		/* Status flag needed to be reset */
-		ast_log(LOG_NOTICE, "SIP transfer failed, call miserably fails. \n");
+		ast_log(LOG_NOTICE, "SIP transfer to %s failed, call miserably fails. \n", p->refer->refer_to);
 		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+		p->refer->status = REFER_FAILED;
 		break;
 	case 603:   /* Transfer declined */
-		ast_log(LOG_NOTICE, "SIP transfer declined, call fails. \n" );
+		ast_log(LOG_NOTICE, "SIP transfer to %s declined, call miserably fails. \n", p->refer->refer_to);
+		p->refer->status = REFER_FAILED;
 		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
 		break;
 	}
@@ -10571,12 +10671,13 @@
 			} else if (sipmethod == SIP_NOTIFY) {
 				/* They got the notify, this is the end */
 				if (p->owner) {
-					ast_log(LOG_WARNING, "Notify answer on an owned channel?\n");
-					ast_queue_hangup(p->owner);
+					if (!p->refer) {
+						ast_log(LOG_WARNING, "Notify answer on an owned channel?\n");
+						ast_queue_hangup(p->owner);
+					}
 				} else {
-					if (p->subscribed == NONE) {
+					if (p->subscribed == NONE) 
 						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY); 
-					}
 				}
 			} else if (sipmethod == SIP_REGISTER)
 				res = handle_response_register(p, resp, rest, req, ignore, seqno);
@@ -10790,6 +10891,16 @@
 			} else if (sipmethod == SIP_CANCEL) {
 				ast_log(LOG_DEBUG, "Got 200 OK on CANCEL\n");
 				/* Wait for 487, then destroy */
+			} else if (sipmethod == SIP_NOTIFY) {
+				/* They got the notify, this is the end */
+				if (p->owner) {
+					ast_log(LOG_WARNING, "Notify answer on an owned channel?\n");
+					ast_queue_hangup(p->owner);
+				} else {
+					if (!p->subscribed)
+						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
+				}
+				/* Wait for 487, then destroy */
 			} else if (sipmethod == SIP_MESSAGE)
 				/* We successfully transmitted a message */
 				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
@@ -10819,6 +10930,8 @@
 			if (sipmethod == SIP_INVITE) {
 				/* Re-invite failed */
 				handle_response_invite(p, resp, rest, req, seqno);
+			} else if (sipdebug) {
+				ast_log	(LOG_DEBUG, "Remote host can't match request %s to call '%s'. Giving up\n", sip_methods[sipmethod].text, p->callid);
 			}
 			break;
 		case 501: /* Not Implemented */
@@ -10900,13 +11013,13 @@
 	transmit_response(transferer->tech_pvt, "202 Accepted", &req);
 	if (!res)	{
 		/* Transfer succeeded */
-		transmit_notify_with_sipfrag(transferer->tech_pvt, d->seqno, "200 OK", 1);
+		transmit_notify_with_sipfrag(transferer->tech_pvt, d->seqno, "200 OK", TRUE);
 		transferer->hangupcause = AST_CAUSE_NORMAL_CLEARING;
 		ast_hangup(transferer); /* This will cause a BYE */
 		if (option_debug)
 			ast_log(LOG_DEBUG, "SIP Call parked on extension '%d'\n", ext);
 	} else {
-		transmit_notify_with_sipfrag(transferer->tech_pvt, d->seqno, "503 Service Unavailable", 1);
+		transmit_notify_with_sipfrag(transferer->tech_pvt, d->seqno, "503 Service Unavailable", TRUE);
 		if (option_debug)
 			ast_log(LOG_DEBUG, "SIP Call parked failed \n");
 		/* Do not hangup call */
@@ -10994,72 +11107,89 @@
 	}
 }
 
-/*! \brief Attempt transfer of SIP call */
-static int attempt_transfer(struct sip_pvt *p1, struct sip_pvt *p2)
+/*! \brief Attempt transfer of SIP call 
+	This fix for attended transfers on a local PBX */
+static int attempt_transfer(struct sip_dual *transferer, struct sip_dual *target)
 {
 	int res = 0;
-	struct ast_channel 
-		*chana = NULL,
-		*chanb = NULL,
-		*bridgea = NULL,
-		*bridgeb = NULL,
-		*peera = NULL,
+	struct ast_channel *peera = NULL,	
 		*peerb = NULL,
 		*peerc = NULL,
 		*peerd = NULL;
 
-	if (!p1->owner || !p2->owner) {
-		ast_log(LOG_WARNING, "Transfer attempted without dual ownership?\n");
-		return -1;
+
+	/* We will try to connect the transferee with the target and hangup
+   	all channels to the transferer */	
+	if (option_debug > 3) {
+		ast_log(LOG_DEBUG, "Sip transfer:--------------------\n");
+		if (transferer->chan1)
+			ast_log(LOG_DEBUG, "-- Transferer to PBX channel: %s State %s\n", transferer->chan1->name, ast_state2str(transferer->chan1->_state));
+		else
+			ast_log(LOG_DEBUG, "-- No transferer first channel - odd??? \n");
+		if (target->chan1)
+			ast_log(LOG_DEBUG, "-- Transferer to PBX second channel (target): %s State %s\n", target->chan1->name, ast_state2str(target->chan1->_state));
+		else
+			ast_log(LOG_DEBUG, "-- No target first channel ---\n");
+		if (transferer->chan2)
+			ast_log(LOG_DEBUG, "-- Bridged call to transferee: %s State %s\n", transferer->chan2->name, ast_state2str(transferer->chan2->_state));
+		else
+			ast_log(LOG_DEBUG, "-- No bridged call to transferee\n");
+		if (target->chan2)
+			ast_log(LOG_DEBUG, "-- Bridged call to transfer target: %s State %s\n", target->chan2 ? target->chan2->name : "<none>", target->chan2 ? ast_state2str(target->chan2->_state) : "(none)");
+		else
+			ast_log(LOG_DEBUG, "-- No target second channel ---\n");
+		ast_log(LOG_DEBUG, "-- END Sip transfer:--------------------\n");
 	}
-	chana = p1->owner;
-	chanb = p2->owner;
-	bridgea = ast_bridged_channel(chana);
-	bridgeb = ast_bridged_channel(chanb);
-	
-	if (bridgea) {
-		peera = chana;
-		peerb = chanb;
-		peerc = bridgea;
-		peerd = bridgeb;
-	} else if (bridgeb) {
-		peera = chanb;
-		peerb = chana;
-		peerc = bridgeb;
-		peerd = bridgea;
+	if (transferer->chan2) {			/* We have a bridge on the transferer's channel */
+		peera = transferer->chan1;	/* Transferer - PBX -> transferee channel * the one we hangup */
+		peerb = target->chan1;		/* Transferer - PBX -> target channel - This will get lost in masq */
+		peerc = transferer->chan2;	/* Asterisk to Transferee */
+		peerd = target->chan2;		/* Asterisk to Target */
+		if (option_debug > 2)
+			ast_log(LOG_DEBUG, "SIP transfer: Four channels to handle\n");
+	} else if (target->chan2) {	/* Transferer has no bridge (IVR), but transferee */
+		peera = target->chan1;		/* Transferer to PBX -> target channel */
+		peerb = transferer->chan1;	/* Transferer to IVR*/
+		peerc = target->chan2;		/* Asterisk to Target */
+		peerd = transferer->chan2;	/* Nothing */
+		if (option_debug > 2)
+			ast_log(LOG_DEBUG, "SIP transfer: Three channels to handle\n");
 	}
-	
+
 	if (peera && peerb && peerc && (peerb != peerc)) {
-		ast_quiet_chan(peera);
-		ast_quiet_chan(peerb);
+		ast_quiet_chan(peera);		/* Stop generators */
+		ast_quiet_chan(peerb);	
 		ast_quiet_chan(peerc);
-		ast_quiet_chan(peerd);
+		if (peerd)
+			ast_quiet_chan(peerd);
 
-		if (peera->cdr && peerb->cdr) {
+		/* Fix CDRs so they're attached to the remaining channel */
+		if (peera->cdr && peerb->cdr)
 			peerb->cdr = ast_cdr_append(peerb->cdr, peera->cdr);
-		} else if (peera->cdr) {
+		else if (peera->cdr) 
 			peerb->cdr = peera->cdr;
-		}
 		peera->cdr = NULL;
 
-		if (peerb->cdr && peerc->cdr) {
+		if (peerb->cdr && peerc->cdr) 
 			peerb->cdr = ast_cdr_append(peerb->cdr, peerc->cdr);
-		} else if (peerc->cdr) {
+		else if (peerc->cdr)
 			peerb->cdr = peerc->cdr;
-		}
 		peerc->cdr = NULL;
-		
+	
+		if (option_debug > 3)
+			ast_log(LOG_DEBUG, "SIP transfer: trying to masquerade %s into %s\n", peerc->name, peerb->name);
 		if (ast_channel_masquerade(peerb, peerc)) {
 			ast_log(LOG_WARNING, "Failed to masquerade %s into %s\n", peerb->name, peerc->name);
 			res = -1;
-		}
+		} else
+			ast_log(LOG_DEBUG, "SIP transfer: Succeeded to masquerade channels.\n");
 		return res;
 	} else {
-		ast_log(LOG_NOTICE, "Transfer attempted with no appropriate bridged calls to transfer\n");
-		if (chana)
-			ast_softhangup_nolock(chana, AST_SOFTHANGUP_DEV);
-		if (chanb)
-			ast_softhangup_nolock(chanb, AST_SOFTHANGUP_DEV);
+		ast_log(LOG_NOTICE, "SIP Transfer attempted with no appropriate bridged calls to transfer\n");
+		if (transferer->chan1)
+			ast_softhangup_nolock(transferer->chan1, AST_SOFTHANGUP_DEV);
+		if (target->chan1)
+			ast_softhangup_nolock(target->chan1, AST_SOFTHANGUP_DEV);
 		return -1;
 	}
 	return 0;
@@ -11248,14 +11378,177 @@
 	return res;
 }
 
-/*! \brief Handle incoming INVITE request */
+/*! \brief Handle the transfer part of INVITE with a replaces: header, 
+    meaning a target pickup or an attended transfer */
+static int handle_invite_replaces(struct sip_pvt *p, struct sip_request *req, int debug, int ignore, int seqno, struct sockaddr_in *sin)
+{
+	struct ast_frame *f;
+	int earlyreplace = 0;
+	int oneleggedreplace = 0;		/* Call with no bridge, propably IVR or voice message */
+	struct ast_channel *c = p->owner;	/* Our incoming call */
+	struct ast_channel *replacecall = p->refer->refer_call->owner;	/* The channel we're about to take over */
+	struct ast_channel *targetcall;		/* The bridge to the take-over target */
+
+	/* Check if we're in ring state */
+	if (replacecall->_state == AST_STATE_RING)
+		earlyreplace = 1;
+
+	/* Check if we have a bridge */
+	if (!(targetcall = ast_bridged_channel(replacecall))) {
+		/* We have no bridge */
+		if (!earlyreplace) {
+			if (option_debug > 1)
+			ast_log(LOG_DEBUG, "	Attended transfer attempted to replace call with no bridge (maybe ringing). Channel %s!\n", replacecall->name);
+			oneleggedreplace = 1;
+		}
+	} 
+	if (option_debug > 3 && targetcall && targetcall->_state == AST_STATE_RINGING)
+			ast_log(LOG_DEBUG, "SIP transfer: Target channel is in ringing state\n");
+
+	if (option_debug > 3) {
+		if (targetcall) 
+			ast_log(LOG_DEBUG, "SIP transfer: Invite Replace incoming channel should bridge to channel %s while hanging up channel %s\n", targetcall->name, replacecall->name); 
+		else
+			ast_log(LOG_DEBUG, "SIP transfer: Invite Replace incoming channel should replace and hang up channel %s (one call leg)\n", replacecall->name); 
+	}
+
+	if (ignore) {
+		ast_log(LOG_NOTICE, "Ignoring this INVITE with replaces in a stupid way.\n");
+		/* We should answer something here. If we are here, the
+			call we are replacing exists, so an accepted 
+			can't harm */
+		transmit_response_with_sdp(p, "200 OK", req, 1);
+		/* Do something more clever here */
+		ast_channel_unlock(c);
+		ast_mutex_unlock(&p->refer->refer_call->lock);
+		return 1;
+	} 
+	if (!c) {
+		/* What to do if no channel ??? */
+		ast_log(LOG_ERROR, "Unable to create new channel.  Invite/replace failed.\n");
+		transmit_response_with_sdp(p, "503 Service Unavailable", req, 1);
+		append_history(p, "Xfer", "INVITE/Replace Failed. No new channel.");
+		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
+		ast_mutex_unlock(&p->refer->refer_call->lock);
+		return 1;
+	}
+	append_history(p, "Xfer", "INVITE/Replace received");
+	/* We have three channels to play with
+		channel c: New incoming call
+		targetcall: Call from PBX to target
+		p->refer->refer_call: SIP pvt dialog from transferer to pbx.
+		replacecall: The owner of the previous
+		We need to masq C into refer_call to connect to 
+		targetcall;
+		If we are talking to internal audio stream, target call is null.
+	*/
+
+	/* Fake call progress */
+	transmit_response(p, "100 Trying", req);
+	ast_setstate(c, AST_STATE_RING);
+
+	/* Masquerade the new call into the referred call to connect to target call 
+	   Targetcall is not touched by the masq */
+
+	/* Answer the incoming call and set channel to UP state */
+	transmit_response_with_sdp(p, "200 OK", req, 1);
+	ast_setstate(c, AST_STATE_UP);
+	
+	/* Stop music on hold and other generators */
+	ast_quiet_chan(replacecall);
+	if (option_debug > 3)
+		ast_log(LOG_DEBUG, "Invite/Replaces: preparing to masquerade %s into %s\n", c->name, replacecall->name);
+	/* Unlock clone, but not original (replacecall) */
+	ast_channel_unlock(c);
+
+	/* Unlock PVT */
+	ast_mutex_unlock(&p->refer->refer_call->lock);
+
+	/* Make sure that the masq does not free our PVT for the old call */
+	ast_set_flag(&p->refer->refer_call->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Delay hangup */
+		
+	/* Prepare the masquerade - if this does not happen, we will be gone */
+	if(ast_channel_masquerade(replacecall, c))
+		ast_log(LOG_ERROR, "Failed to masquerade C into Replacecall\n");
+	else if (option_debug > 3)
+		ast_log(LOG_DEBUG, "Invite/Replaces: Going to masquerade %s into %s\n", c->name, replacecall->name);
+
+	/* The masquerade will happen as soon as someone reads a frame from the channel */
+
+	/* C should now be in place of replacecall */
+	/* ast_read needs to lock channel */
+	ast_channel_unlock(c);
+	
+	if (earlyreplace || oneleggedreplace ) {
+		/* Force the masq to happen */
+		if ((f = ast_read(replacecall))) {	/* Force the masq to happen */
+			ast_frfree(f);
+			f = NULL;
+			if (option_debug > 3)
+				ast_log(LOG_DEBUG, "Invite/Replace:  Could successfully read frame from RING channel!\n");
+		} else {
+			ast_log(LOG_WARNING, "Invite/Replace:  Could not read frame from RING channel \n");
+		}
+		c->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
+		ast_channel_unlock(replacecall);
+	} else {	/* Bridged call, UP channel */
+		if ((f = ast_read(replacecall))) {	/* Force the masq to happen */
+			/* Masq ok */
+			ast_frfree(f);
+			f = NULL;
+			if (option_debug > 2)
+				ast_log(LOG_DEBUG, "Invite/Replace:  Could successfully read frame from channel! Masq done.\n");
+		} else {
+			ast_log(LOG_WARNING, "Invite/Replace:  Could not read frame from channel. Transfer failed\n");
+		}
+		ast_channel_unlock(replacecall);
+	}
+	ast_mutex_unlock(&p->refer->refer_call->lock);
+
+	ast_setstate(c, AST_STATE_DOWN);
+	if (option_debug > 3) {
+		struct ast_channel *test;
+		ast_log(LOG_DEBUG, "After transfer:----------------------------\n");
+		ast_log(LOG_DEBUG, " -- C:        %s State %s\n", c->name, ast_state2str(c->_state));
+		if (replacecall)
+			ast_log(LOG_DEBUG, " -- replacecall:        %s State %s\n", replacecall->name, ast_state2str(replacecall->_state));
+		if (p->owner) {
+			ast_log(LOG_DEBUG, " -- P->owner: %s State %s\n", p->owner->name, ast_state2str(p->owner->_state));
+			test = ast_bridged_channel(p->owner);
+			if (test)
+				ast_log(LOG_DEBUG, " -- Call bridged to P->owner: %s State %s\n", test->name, ast_state2str(test->_state));
+			else
+				ast_log(LOG_DEBUG, " -- No call bridged to C->owner \n");
+		} else 
+			ast_log(LOG_DEBUG, " -- No channel yet \n");
+		ast_log(LOG_DEBUG, "End After transfer:----------------------------\n");
+	}
+
+	ast_channel_unlock(p->owner);	/* Unlock new owner */
+	ast_mutex_unlock(&p->lock);	/* Unlock SIP structure */
+
+	/* The call should be down with no ast_channel, so hang it up */
+	c->tech_pvt = NULL;
+	ast_hangup(c);
+	return 0;
+}
+
+
+/*! \brief Handle incoming INVITE request
+\note 	If the INVITE has a Replaces header, it is part of an
+ *	attended transfer. If so, we do not go through the dial
+ *	plan but tries to find the active call and masquerade
+ *	into it 
+ */
 static int handle_request_invite(struct sip_pvt *p, struct sip_request *req, int debug, int seqno, struct sockaddr_in *sin, int *recount, char *e)
 {
 	int res = 1;
-	struct ast_channel *c=NULL;		/* New channel */
 	int gotdest;
+	const char *p_replaces;
+	char *replace_id = NULL;
 	const char *required;
 	unsigned int required_profile = 0;
+	struct ast_channel *c = NULL;		/* New channel */
 
 	/* Find out what they support */
 	if (!p->sipoptions) {
@@ -11266,43 +11559,163 @@
 
 	/* Find out what they require */
 	required = get_header(req, "Require");
-	if (!ast_strlen_zero(required)) {
+	if (required && !ast_strlen_zero(required)) {
 		required_profile = parse_sip_options(NULL, required);
-		if (required_profile) { 	/* They require something */
-			/* At this point we support no extensions, so fail */
-			transmit_response_with_unsupported(p, "420 Bad extension", req, required);
+		if (required_profile && required_profile != SIP_OPT_REPLACES) {
+			/* At this point we only support REPLACES */
+			transmit_response_with_unsupported(p, "420 Bad extension (unsupported)", req, required);
 			ast_log(LOG_WARNING,"Received SIP INVITE with unsupported required extension: %s\n", required);
 			if (!p->lastinvite)
 				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 			return -1;
-			
 		}
 	}
 
 	/* Check if this is a loop */
-	/* This happens since we do not properly support SIP domain
-	   handling yet... -oej */
 	if (ast_test_flag(&p->flags[0], SIP_OUTGOING) && p->owner && (p->owner->_state != AST_STATE_UP)) {
 		/* This is a call to ourself.  Send ourselves an error code and stop
-		   processing immediately, as SIP really has no good mechanism for
-		   being able to call yourself */
+	   	processing immediately, as SIP really has no good mechanism for
+	   	being able to call yourself */
+		/* If pedantic is on, we need to check the tags. If they're different, this is
+	   	in fact a forked call through a SIP proxy somewhere. */
 		transmit_response(p, "482 Loop Detected", req);
 		/* We do NOT destroy p here, so that our response will be accepted */
 		return 0;
 	}
-
+	
 	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->pendinginvite) {
 		/* We already have a pending invite. Sorry. You are on hold. */
 		transmit_response(p, "491 Request Pending", req);
-		if (option_debug > 1)
+		if (option_debug)
 			ast_log(LOG_DEBUG, "Got INVITE on call where we already have pending INVITE, deferring that - %s\n", p->callid);
-		/* Do NOT destroy dialog */
 		return 0;
 	}
 
+	if ((p_replaces = get_header(req, "Replaces")) && !ast_strlen_zero(p_replaces)) {
+		/* We have a replaces header */
+		char *ptr;
+		char *fromtag = NULL;
+		char *totag = NULL;
+		char *start, *to;
+		int error = 0;
+
+		if (p->owner) {
+			if (option_debug > 2)
+				ast_log(LOG_DEBUG, "INVITE w Replaces on existing call? Refusing action. [%s]\n", p->callid);
+			transmit_response(p, "400 Bad request", req);	/* The best way to not not accept the transfer */
+			/* Do not destroy existing call */
+			return -1;
+		}
+
+		if (sipdebug && option_debug > 2)
+			ast_log(LOG_DEBUG, "INVITE part of call transfer. Replaces [%s]\n", p_replaces);
+		/* Create a buffer we can manipulate */
+		replace_id = ast_strdupa(p_replaces);
+		ast_uri_decode(replace_id);
+
+		if (!p->refer && !sip_refer_allocate(p)) {
+			transmit_response(p, "500 Server Internal Error", req);
+			append_history(p, "Xfer", "INVITE/Replace Failed. Out of memory.");
+			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+			return -1;
+		}
+
+		/*  Todo: (When we find phones that support this)
+			if the replaces header contains ";early-only"
+			we can only replace the call in early
+			stage, not after it's up.
+
+			If it's not in early mode, 486 Busy.
+		*/
+		
+		/* Skip leading whitespace */
+		while(replace_id[0] && (replace_id[0] < 33))
+			memmove(replace_id, replace_id+1, strlen(replace_id));
+
+		if ((ptr = strchr(replace_id, ';'))) {
+			*ptr = '\0';
+			ptr++;
+		}
+		start = ptr;
+
+		to = strcasestr(ptr, "to-tag=");
+		if (to) {
+			ptr = to + 7;
+			totag = ptr;
+			if ((to = strchr(ptr, ';')))
+				*to = '\0';
+			to++;
+			ptr = to;
+		}
+
+		to = strcasestr(ptr, "from-tag=");
+		if (to) {
+			ptr = to + 9;
+			fromtag = ptr;
+			if ((to = strchr(ptr, '&')))
+				*to = '\0';
+			if ((to = strchr(ptr, ';')))
+				*to = '\0';
+		}
+
+		if (sipdebug && option_debug > 3) 
+			ast_log(LOG_DEBUG,"Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\n", replace_id, fromtag ? fromtag : "<no from tag>", totag ? totag : "<no to tag>");
+
+
+		/* Try to find call that we are replacing 
+			If we have a Replaces  header, we need to cancel that call if we succeed with this call 
+		*/
+		if ((p->refer->refer_call = get_sip_pvt_byid_locked(replace_id, totag, fromtag)) == NULL) {
+			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existent call id (%s)!\n", replace_id);
+			transmit_response(p, "481 Call Leg Does Not Exist (Replaces)", req);
+			error = 1;
+		}
+
+		/* At this point, bot the pvt and the owner of the call to be replaced is locked */
+
+		/* The matched call is the call from the transferer to Asterisk .
+			We want to bridge the bridged part of the call to the 
+			incoming invite, thus taking over the refered call */
+
+		if (p->refer->refer_call == p) {
+			ast_log(LOG_NOTICE, "INVITE with replaces into it's own call id (%s == %s)!\n", replace_id, p->callid);
+			p->refer->refer_call = NULL;
+			transmit_response(p, "400 Bad request", req);	/* The best way to not not accept the transfer */
+			error = 1;
+		}
+
+		if (!error && !p->refer->refer_call->owner) {
+			/* Oops, someting wrong anyway, no owner, no call */
+			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-existing call id (%s)!\n", replace_id);
+			/* Check for better return code */
+			transmit_response(p, "481 Call Leg Does Not Exist (Replace)", req);
+			error = 1;
+		}
+
+		if (!error && p->refer->refer_call->owner->_state != AST_STATE_RING && p->refer->refer_call->owner->_state != AST_STATE_UP ) {
+			ast_log(LOG_NOTICE, "Supervised transfer attempted to replace non-ringing or active call id (%s)!\n", replace_id);
+			transmit_response(p, "603 Declined (Replaces)", req);
+			error = 1;
+		}
+
+		if (error) {	/* Give up this dialog */
+			append_history(p, "Xfer", "INVITE/Replace Failed.");
+			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+			ast_mutex_unlock(&p->lock);
+			if (p->refer->refer_call) {
+				ast_mutex_unlock(&p->refer->refer_call->lock);
+				ast_channel_unlock(p->refer->refer_call->owner);
+			}
+			return -1;
+		}
+	}
+
+
+	/* Check if this is an INVITE that sets up a new dialog or
+	   a re-invite in an existing dialog */
+
 	if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
 		sip_cancel_destroy(p);
-
 		/* This also counts as a pending invite */
 		p->pendinginvite = seqno;
 		check_via(p, req);
@@ -11331,8 +11744,10 @@
 		}
 	} else if (debug)
 		ast_verbose("Ignoring this INVITE request\n");
+
+	
 	if (!p->lastinvite && !ast_test_flag(req, SIP_PKT_IGNORE) && !p->owner) {
-
+		/* This is a new invite */
 		/* Handle authentication if this is our first invite */
 		res = check_user(p, req, SIP_INVITE, e, XMIT_RELIABLE, sin);
 		if (res == AUTH_CHALLENGE_SENT)
@@ -11360,20 +11775,23 @@
 					ast_log(LOG_DEBUG, "No compatible codecs for this SIP call.\n");
 				return -1;
 			}
-		} else {
+		} else {	/* No SDP in invite, call control session */
 			p->jointcapability = p->capability;
 			if (option_debug > 1)
 				ast_log(LOG_DEBUG, "No SDP in Invite, third party call control\n");
 		}
 
 		/* Queue NULL frame to prod ast_rtp_bridge if appropriate */
+		/* This seems redundant ... see !p-owner above */
 		if (p->owner)
 			ast_queue_frame(p->owner, &ast_null_frame);
 
+
 		/* Initialize the context if it hasn't been already */
 		if (ast_strlen_zero(p->context))
 			ast_string_field_set(p, context, default_context);
 
+
 		/* Check number of concurrent calls -vs- incoming limit HERE */
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Checking SIP call limits for device %s\n", p->username);
@@ -11391,7 +11809,7 @@
 		build_contact(p);			/* Build our contact header */
 		ast_rtp_setdtmf(p->rtp, ast_test_flag(&p->flags[0], SIP_DTMF) != SIP_DTMF_INFO);
 
-		if (gotdest) {
+		if (!replace_id && gotdest) {	/* No matching extension found */
 			if (gotdest == 1 && ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP)) {
 				transmit_response_reliable(p, "484 Address Incomplete", req);
 				update_call_counter(p, DEC_CALL_LIMIT);
@@ -11402,21 +11820,25 @@
 			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);		
 		} else {
 			/* If no extension was specified, use the s one */
+			/* Basically for calling to IP/Host name only */
 			if (ast_strlen_zero(p->exten))
 				ast_string_field_set(p, exten, "s");
 			/* Initialize our tag */	
+
 			make_our_tag(p->tag, sizeof(p->tag));
-			/* First invitation */
+
+			/* First invitation - create the channel */
 			c = sip_new(p, AST_STATE_DOWN, S_OR(p->username, NULL));
 			*recount = 1;
+
 			/* Save Record-Route for any later requests we make on this dialogue */
 			build_route(p, req, 0);
+
 			if (c) {
 				/* Pre-lock the call */
 				ast_channel_lock(c);
 			}
 		}
-		
 	} else {
 		if (option_debug > 1 && sipdebug) {
 			if (!ast_test_flag(req, SIP_PKT_IGNORE))
@@ -11426,19 +11848,31 @@
 		}
 		c = p->owner;
 	}
+
 	if (!ast_test_flag(req, SIP_PKT_IGNORE) && p)
 		p->lastinvite = seqno;
-	if (c) {
+
+	if (replace_id) { 	/* Attended transfer or call pickup - we're the target */
+		/* Go and take over the target call */
+		if (sipdebug && option_debug > 3)
+			ast_log(LOG_DEBUG, "Sending this call to the invite/replcaes handler %s\n", p->callid);
+		return handle_invite_replaces(p, req, debug, ast_test_flag(req, SIP_PKT_IGNORE), seqno, sin);
+	}
+
+
+	if (c) {	/* We have a call  -either a new call or an old one (RE-INVITE) */
 		switch(c->_state) {
 		case AST_STATE_DOWN:
+			if (option_debug > 1)
+				ast_log(LOG_DEBUG, "%s: New call is still down.... Trying... \n", c->name);
 			transmit_response(p, "100 Trying", req);
 			ast_setstate(c, AST_STATE_RING);
-			if (strcmp(p->exten, ast_pickup_ext())) {
+			if (strcmp(p->exten, ast_pickup_ext())) {	/* Call to extension -start pbx on this call */
 				enum ast_pbx_result res;
 
 				res = ast_pbx_start(c);
 
-				switch (res) {
+				switch(res) {
 				case AST_PBX_FAILED:
 					ast_log(LOG_WARNING, "Failed to start PBX :(\n");
 					if (ast_test_flag(req, SIP_PKT_IGNORE))
@@ -11459,9 +11893,10 @@
 				}
 
 				if (res) {
+
 					/* Unlock locks so ast_hangup can do its magic */
-					ast_channel_unlock(c);
-					ast_channel_unlock(p);
+					ast_mutex_unlock(&c->lock);
+					ast_mutex_unlock(&p->lock);
 					ast_hangup(c);
 					ast_mutex_lock(&p->lock);
 					c = NULL;
@@ -11471,7 +11906,7 @@
 				if (ast_pickup_call(c)) {
 					ast_log(LOG_NOTICE, "Nothing to pick up for %s\n", p->callid);
 					if (ast_test_flag(req, SIP_PKT_IGNORE))
-						transmit_response(p, "503 Unavailable", req);
+						transmit_response(p, "503 Unavailable", req);	/* OEJ - Right answer? */
 					else
 						transmit_response_reliable(p, "503 Unavailable", req);
 					ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
@@ -11495,11 +11930,15 @@
 			transmit_response(p, "180 Ringing", req);
 			break;
 		case AST_STATE_UP:
+			if (option_debug > 1)
+				ast_log(LOG_DEBUG, "%s: New call is UP.... \n", c->name);
 			transmit_response_with_sdp(p, "200 OK", req, XMIT_CRITICAL);
+
 			break;
 		default:
 			ast_log(LOG_WARNING, "Don't know how to handle INVITE in state %d\n", c->_state);
 			transmit_response(p, "100 Trying", req);
+			break;
 		}
 	} else {
 		if (p && !ast_test_flag(&p->flags[0], SIP_NEEDDESTROY)) {
@@ -11522,24 +11961,185 @@
 	return res;
 }
 
+/*! \brief  Find all call legs and bridge transferee with target 
+ *	called from handle_request_refer */
+int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno)
+{
+	struct sip_dual target;		/* Chan 1: Call from tranferer to Asterisk */
+					/* Chan 2: Call from Asterisk to target */
+	int res = 0;
+	struct sip_pvt *targetcall_pvt;
+	int error = 0;
+
+	/* Check if the call ID of the replaces header does exist locally */
+	if (!(targetcall_pvt = get_sip_pvt_byid_locked(transferer->refer->replaces_callid, transferer->refer->replaces_callid_totag, 
+		transferer->refer->replaces_callid_fromtag))) {
+		if (transferer->refer->localtransfer) {
+			/* We did not find the refered call. Sorry, can't accept then */
+			transmit_response(transferer, "202 Accepted", req);
+			/* Let's fake a response from someone else in order
+		   	to follow the standard */
+			transmit_notify_with_sipfrag(transferer, seqno, "481 Call leg/transaction does not exist", TRUE);
+			append_history(transferer, "Xfer", "Refer failed");
+			ast_clear_flag(&transferer->flags[0], SIP_GOTREFER);	
+			transferer->refer->status = REFER_FAILED;
+			return -1;
+		}
+		/* Fall through for remote transfers that we did not find locally */
+		if (option_debug > 2)
+			ast_log(LOG_DEBUG, "SIP attended transfer: Not our call - generating INVITE with replaces\n");
+		return 0;
+	}
+
+	/* Ok, we can accept this transfer */
+	transmit_response(transferer, "202 Accepted", req);
+	append_history(transferer, "Xfer", "Refer accepted");
+	if (!targetcall_pvt->owner) {	/* No active channel */
+		if (option_debug > 3)
+			ast_log(LOG_DEBUG, "SIP attended transfer: Error: No owner of target call\n");
+		error = 1;
+	}
+	/* We have a channel, find the bridge */
+	target.chan1 = targetcall_pvt->owner;				/* Transferer to Asterisk */
+
+	if (!error) {
+		target.chan2 = ast_bridged_channel(targetcall_pvt->owner);	/* Asterisk to target */
+
+		if (!target.chan2 || !(target.chan2->_state == AST_STATE_UP || target.chan2->_state == AST_STATE_RINGING) ) {
+			/* Wrong state of new channel */
+			if (option_debug > 3) {
+				if (target.chan2) 
+					ast_log(LOG_DEBUG, "SIP attended transfer: Error: Wrong state of target call: %s\n", ast_state2str(target.chan2->_state));
+				else if (target.chan1->_state != AST_STATE_RING)
+					ast_log(LOG_DEBUG, "SIP attended transfer: Error: No target channel\n");
+				else
+					ast_log(LOG_DEBUG, "SIP attended transfer: Attempting transfer in ringing state\n");
+			}
+			if (target.chan1->_state != AST_STATE_RING)
+				error = 1;
+		}
+	}
+	if (error) {	/* Cancel transfer */
+		transmit_notify_with_sipfrag(transferer, seqno, "503 Service Unavailable", TRUE);
+		append_history(transferer, "Xfer", "Refer failed");
+		ast_clear_flag(&transferer->flags[0], SIP_GOTREFER);	
+		transferer->refer->status = REFER_FAILED;
+		ast_mutex_unlock(&targetcall_pvt->lock);
+		ast_channel_unlock(current->chan1);
+		ast_channel_unlock(target.chan1);
+		return -1;
+	}
+
+	/* Transfer */
+	if (option_debug > 3 && sipdebug) {
+		if (current->chan2)	/* We have two bridges */
+			ast_log(LOG_DEBUG, "SIP attended transfer: trying to bridge %s and %s\n", target.chan1->name, current->chan2->name);
+		else			/* One bridge, propably transfer of IVR/voicemail etc */
+			ast_log(LOG_DEBUG, "SIP attended transfer: trying to make %s take over (masq) %s\n", target.chan1->name, current->chan1->name);
+	}
+
+	ast_set_flag(&transferer->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Delay hangup */
+
+	/* Perform the transfer */
+	res = attempt_transfer(current, &target);
+	ast_mutex_unlock(&targetcall_pvt->lock);
+	if (res) {
+		/* Failed transfer */
+		/* Could find better message, but they will get the point */
+		transmit_notify_with_sipfrag(transferer, seqno, "486 Busy", TRUE);
+		append_history(transferer, "Xfer", "Refer failed");
+		if (targetcall_pvt->owner)
+			ast_channel_unlock(targetcall_pvt->owner);
+		/* Right now, we have to hangup, sorry. Bridge is destroyed */
+		ast_hangup(transferer->owner);
+	} else {
+		/* Transfer succeeded! */
+
+		/* Tell transferer that we're done. */
+		transmit_notify_with_sipfrag(transferer, seqno, "200 OK", TRUE);
+		append_history(transferer, "Xfer", "Refer succeeded");
+		transferer->refer->status = REFER_200OK;
+		if (targetcall_pvt->owner) {
+			ast_log(LOG_DEBUG, "SIP attended transfer: Unlocking channel %s\n", targetcall_pvt->owner->name);
+			ast_channel_unlock(targetcall_pvt->owner);
+		}
+	}
+	return 1;
+}
+
+
 /*! \brief Handle incoming REFER request */
+/*! \page SIP_REFER SIP transfer Support (REFER)
+
+	REFER is used for call transfer in SIP. We get a REFER
+	to place a new call with an INVITE somwhere and then
+	keep the transferor up-to-date of the transfer. If the
+	transfer fails, get back on line with the orginal call. 
+
+	- REFER can be sent outside or inside of a dialog.
+	  Asterisk only accepts REFER inside of a dialog.
+
+	- If we get a replaces header, it is an attended transfer
+
+	\par Blind transfers
+	The transferor provides the transferee
+	with the transfer targets contact. The signalling between
+	transferer or transferee should not be cancelled, so the
+	call is recoverable if the transfer target can not be reached 
+	by the transferee.
+
+	In this case, Asterisk receives a TRANSFER from
+	the transferor, thus is the transferee. We should
+	try to set up a call to the contact provided
+	and if that fails, re-connect the current session.
+	If the new call is set up, we issue a hangup.
+	In this scenario, we are following section 5.2
+	in the SIP CC Transfer draft. (Transfer without
+	a GRUU)
+
+	\par Transfer with consultation hold
+	In this case, the transferor
+	talks to the transfer target before the transfer takes place.
+	This is implemented with SIP hold and transfer.
+	Note: The invite From: string could indicate a transfer.
+	(Section 6. Transfer with consultation hold)
+	The transferor places the transferee on hold, starts a call
+	with the transfer target to alert them to the impending
+	transfer, terminates the connection with the target, then
+	proceeds with the transfer (as in Blind transfer above)
+
+	\par Attended transfer
+	The transferor places the transferee
+	on hold, calls the transfer target to alert them,
+	places the target on hold, then proceeds with the transfer
+	using a Replaces header field in the Refer-to header. This
+	will force the transfee to send an Invite to the target,
+	with a replaces header that instructs the target to
+	hangup the call between the transferor and the target.
+	In this case, the Refer/to: uses the AOR address. (The same
+	URI that the transferee used to establish the session with
+	the transfer target (To: ). The Require: replaces header should
+	be in the INVITE to avoid the wrong UA in a forked SIP proxy
+	scenario to answer and have no call to replace with.
+
+	The referred-by header is *NOT* required, but if we get it,
+	can be copied into the INVITE to the transfer target to 
+	inform the target about the transferor
+
+	"Any REFER request has to be appropriately authenticated.".
+	
+	We can't destroy dialogs, since we want the call to continue.
+	
+	*/
 static int handle_request_refer(struct sip_pvt *p, struct sip_request *req, int debug, int ignore, int seqno, int *nounlock)
 {
-	struct ast_channel *c=NULL;
-	int res;
-	struct ast_channel *transfer_to;
+	struct sip_dual current;	/* Chan1: Call between asterisk and transferer */
+					/* Chan2: Call between asterisk and transferee */
 
-	if (option_debug > 2)
-		ast_log(LOG_DEBUG, "SIP call transfer received for call %s (REFER)!\n", p->callid);
+	int res = 0;
 
-	/* Check if transfer is allowed from this device */
-	if (p->allowtransfer == TRANSFER_CLOSED ) {
-		/* Transfer not allowed, decline */
-		transmit_response(p, "603 Declined (policy)", req);
-		append_history(p, "Xfer", "Refer failed. Allowtransfer == closed.");
-		/* Do not destroy SIP session */
-		return 0;
-	}
+	if (ast_test_flag(req, SIP_PKT_DEBUG))
+		ast_verbose("Call %s got a SIP call transfer from %s: (REFER)!\n", p->callid, ast_test_flag(&p->flags[0], SIP_OUTGOING) ? "callee" : "caller");
 
 	if (!p->owner) {
 		/* This is a REFER outside of an existing SIP dialog */
@@ -11555,67 +12155,262 @@
 		return 0;
 	}	
 
+
+	/* Check if transfer is allowed from this device */
+	if (p->allowtransfer == TRANSFER_CLOSED ) {
+		/* Transfer not allowed, decline */
+		transmit_response(p, "603 Declined (policy)", req);
+		append_history(p, "Xfer", "Refer failed. Allowtransfer == closed.");
+		/* Do not destroy SIP session */
+		return 0;
+	}
+
+	if(!ignore && ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
+		/* Already have a pending REFER */	
+		transmit_response(p, "491 Request pending", req);
+		append_history(p, "Xfer", "Refer failed. Request pending.");
+		return 0;
+	}
+
+	/* Allocate memory for call transfer data */
+	if (!p->refer && !sip_refer_allocate(p)) {
+		transmit_response(p, "500 Internal Server Error", req);
+		append_history(p, "Xfer", "Refer failed. Memory allocation error.");
+		return -3;
+	}
+
+	res = get_refer_info(p, req);	/* Extract headers */
+
+	p->refer->status = REFER_SENT;
+
+	if (res != 0) {
+		switch (res) {
+		case -2:	/* Syntax error */
+			transmit_response(p, "400 Bad Request (Refer-to missing)", req);
+			append_history(p, "Xfer", "Refer failed. Refer-to missing.");
+			if (ast_test_flag(req, SIP_PKT_DEBUG))
+				ast_log(LOG_DEBUG, "SIP transfer to black hole can't be handled (no refer-to: )\n");
+			break;
+		case -3:
+			transmit_response(p, "603 Declined (Non sip: uri)", req);
+			append_history(p, "Xfer", "Refer failed. Non SIP uri");
+			if (ast_test_flag(req, SIP_PKT_DEBUG))
+				ast_log(LOG_DEBUG, "SIP transfer to non-SIP uri denied\n");
+			break;
+		default:
+			/* Refer-to extension not found, fake a failed transfer */
+			transmit_response(p, "202 Accepted", req);
+			append_history(p, "Xfer", "Refer failed. Bad extension.");
+			transmit_notify_with_sipfrag(p, seqno, "404 Not found", TRUE);
+			ast_clear_flag(&p->flags[0], SIP_GOTREFER);	
+			if (ast_test_flag(req, SIP_PKT_DEBUG))
+				ast_log(LOG_DEBUG, "SIP transfer to bad extension: %s\n", p->refer->refer_to);
+			break;
+		} 
+		return 0;
+	}
 	if (ast_strlen_zero(p->context))
 		ast_string_field_set(p, context, default_context);
-	res = get_refer_info(p, req);
-	if (res > 0) {
-		if (ast_test_flag(&p->flags[1], SIP_PAGE2_ALLOWOVERLAP)) 
-			transmit_response_with_allow(p, "484 Address Incomplete", req, 1);
-		else
-			transmit_response_with_allow(p, "404 Not Found", req, 1);
-	} else if (res < 0)
-		transmit_response_with_allow(p, "404 Not Found", req, 1);
-	else {
-		int nobye = 0;
-		if (!ast_test_flag(req, SIP_PKT_IGNORE)) {
-			if (p->refer_call) {
-				ast_log(LOG_DEBUG,"202 Accepted (supervised)\n");
-				attempt_transfer(p, p->refer_call);
-				if (p->refer_call->owner)
-					ast_channel_unlock(p->refer_call->owner);
-				ast_mutex_unlock(&p->refer_call->lock);
-				p->refer_call = NULL;
-				ast_set_flag(&p->flags[0], SIP_GOTREFER);	
-			} else {
-				ast_log(LOG_DEBUG,"202 Accepted (blind)\n");
-				c = p->owner;
-				if (c) {
-					transfer_to = ast_bridged_channel(c);
-					if (transfer_to) {
-						ast_log(LOG_DEBUG, "Got SIP blind transfer, applying to '%s'\n", transfer_to->name);
-						ast_moh_stop(transfer_to);
-						if (!strcmp(p->refer_to, ast_parking_ext())) {
-							/* Must release c's lock now, because it will not longer
-							    be accessible after the transfer! */
-							*nounlock = 1;
-							ast_channel_unlock(c);
-							sip_park(transfer_to, c, req, seqno);
-							nobye = 1;
-						} else {
-							/* Must release c's lock now, because it will not longer
-							    be accessible after the transfer! */
-							*nounlock = 1;
-							ast_channel_unlock(c);
-							ast_async_goto(transfer_to,p->context, p->refer_to,1);
-						}
-					} else {
-						ast_log(LOG_DEBUG, "Got SIP blind transfer but nothing to transfer to.\n");
-						ast_queue_hangup(p->owner);
-					}
-				}
-				ast_set_flag(&p->flags[0], SIP_GOTREFER);	
-			}
-			transmit_response(p, "202 Accepted", req);
-			transmit_notify_with_sipfrag(p, seqno, "200 OK", 1);
-			/* Always increment on a BYE */
-			if (!nobye) {
-				transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, TRUE);
-				ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
-			}
-		}
+
+	/* If we do not support SIP domains, all transfers are local */
+	if (allow_external_domains && check_sip_domain(p->refer->refer_to_domain, NULL, 0)) {
+		p->refer->localtransfer = 1;
+		if (sipdebug && option_debug > 2)
+			ast_log(LOG_DEBUG, "This SIP transfer is local : %s\n", p->refer->refer_to_domain);
+	} else if (!allow_external_domains) {
+		/* This PBX don't bother with SIP domains, so all transfers are local */
+		p->refer->localtransfer = 1;
+	} else
+		if (sipdebug && option_debug > 2)
+			ast_log(LOG_DEBUG, "This SIP transfer is to a remote SIP extension (remote domain %s)\n", p->refer->refer_to_domain);
+	
+	/* Is this a repeat of a current request? Ignore it */
+	/* Don't know what else to do right now. */
+	if (ignore) 
+		return res;
+
+	/* If this is a blind transfer, we have the following
+   	channels to work with:
+   	- chan1, chan2: The current call between transferer and transferee (2 channels)
+   	- target_channel: A new call from the transferee to the target (1 channel)
+   	We need to stay tuned to what happens in order to be able
+   	to bring back the call to the transferer */
+
+	/* If this is a attended transfer, we should have all call legs within reach:
+   	- chan1, chan2: The call between the transferer and transferee (2 channels)
+   	- target_channel, targetcall_pvt: The call between the transferer and the target (2 channels)
+	We want to bridge chan2 with targetcall_pvt!
+	
+   	The replaces call id in the refer message points
+   	to the call leg between Asterisk and the transferer.
+   	So we need to connect the target and the transferee channel
+   	and hangup the two other channels silently 
+	
+   	If the target is non-local, the call ID could be on a remote
+   	machine and we need to send an INVITE with replaces to the
+   	target. We basically handle this as a blind transfer
+   	and let the sip_call function catch that we need replaces
+   	header in the INVITE.
+	*/
+
+
+	/* Get the transferer's channel */
+	current.chan1 = p->owner;
+
+	/* Find the other part of the bridge (2) - transferee */
+	current.chan2 = ast_bridged_channel(current.chan1);
+	
+	if (sipdebug && option_debug > 2)
+		ast_log(LOG_DEBUG, "SIP %s transfer: Transferer channel %s, transferee channel %s\n", p->refer->attendedtransfer ? "attended" : "blind", current.chan1->name, current.chan2 ? current.chan2->name : "<none>");
+
+	if (!current.chan2 && !p->refer->attendedtransfer) {
+		/* No bridged channel, propably IVR or echo or similar... */
+		/* Guess we should masquerade or something here */
+		/* Until we figure it out, refuse transfer of such calls */
+		if (sipdebug && option_debug > 2)
+			ast_log(LOG_DEBUG,"Refused SIP transfer on non-bridged channel.\n");
+		p->refer->status = REFER_FAILED;
+		append_history(p, "Xfer", "Refer failed. Non-bridged channel.");
+		transmit_response(p, "603 Declined", req);
+		return -1;
 	}
+
+	if (sipdebug && option_debug > 3)
+		ast_log(LOG_DEBUG, "Got SIP transfer, applying to bridged peer '%s'\n", current.chan2->name);
+
+	/* Stop music on hold on this channel */
+	if (current.chan2)
+		ast_moh_stop(current.chan2);
+
+	ast_set_flag(&p->flags[0], SIP_GOTREFER);	
+
+	/* Attended transfer: Find all call legs and bridge transferee with target*/
+	if (p->refer->attendedtransfer) {
+		if ((res = local_attended_transfer(p, &current, req, seqno)))
+			return res;	/* We're done with the transfer */
+		/* Fall through for remote transfers that we did not find locally */
+		if (sipdebug && option_debug > 3)
+			ast_log(LOG_DEBUG, "SIP attended transfer: Still not our call - generating INVITE with replaces\n");
+		/* Fallthrough if we can't find the call leg internally */
+	}
+
+
+	/* Parking a call */
+	if (p->refer->localtransfer && !strcmp(p->refer->refer_to, ast_parking_ext())) {
+		/* Must release c's lock now, because it will not longer be accessible after the transfer! */
+		*nounlock = 1;
+		ast_channel_unlock(current.chan1);
+		copy_request(&current.req, req);
+		ast_clear_flag(&p->flags[0], SIP_GOTREFER);	
+		p->refer->status = REFER_200OK;
+		append_history(p, "Xfer", "REFER to call parking.");
+		if (sipdebug && option_debug > 3)
+			ast_log(LOG_DEBUG, "SIP transfer to parking: trying to park %s. Parked by %s\n", current.chan2->name, current.chan1->name);
+		sip_park(current.chan2, current.chan1, req, seqno);
+		return res;
+	} 
+
+	/* Blind transfers and remote attended xfers */
+	transmit_response(p, "202 Accepted", req);
+	if (current.chan2->name) {
+		ast_log(LOG_NOTICE, "chan2->name: %s\n", current.chan2->name);
+		pbx_builtin_setvar_helper(current.chan2, "BLINDTRANSFER", current.chan1->name);
+	}
+	if (current.chan1) {
+		ast_log(LOG_NOTICE, "chan1->name: %s\n", current.chan1->name);
+		pbx_builtin_setvar_helper(current.chan1, "BLINDTRANSFER", current.chan2->name);
+	}
+	if (current.chan2) {
+		pbx_builtin_setvar_helper(current.chan2, "SIPDOMAIN", p->refer->refer_to_domain);
+		pbx_builtin_setvar_helper(current.chan2, "SIPTRANSFER", "yes");
+		/* One for the new channel */
+		pbx_builtin_setvar_helper(current.chan2, "_SIPTRANSFER", "yes");
+		if (p->refer->referred_by)
+			pbx_builtin_setvar_helper(current.chan2, "_SIPTRANSFER_REFERER", p->refer->referred_by);
+		if (p->refer->referred_by)
+		/* Attended transfer to remote host, prepare headers for the INVITE */
+		pbx_builtin_setvar_helper(current.chan2, "_SIPTRANSFER_REFERER", p->refer->referred_by);
+	}
+	/* Generate an URI-encoded string */
+	if (p->refer->replaces_callid && !ast_strlen_zero(p->refer->replaces_callid)) {
+		char tempheader[BUFSIZ];
+		char tempheader2[BUFSIZ];
+		snprintf(tempheader, sizeof(tempheader), "%s%s%s%s%s", p->refer->replaces_callid, 
+				p->refer->replaces_callid_totag ? ";to-tag=" : "", 
+				p->refer->replaces_callid_totag, 
+				p->refer->replaces_callid_fromtag ? ";from-tag=" : "",
+				p->refer->replaces_callid_fromtag);
+
+		/* Convert it to URL encoding, also convert reserved strings */
+		ast_uri_encode(tempheader, tempheader2, sizeof(tempheader2), 1);
+
+		if (current.chan2)
+			pbx_builtin_setvar_helper(current.chan2, "_SIPTRANSFER_REPLACES", tempheader2);
+	}
+	/* Must release lock now, because it will not longer
+    	   be accessible after the transfer! */
+	*nounlock = 1;
+	ast_channel_unlock(current.chan1);
+	ast_channel_unlock(current.chan2);
+
+	/* Connect the call */
+	/* FAKE ringing if not attended transfer */
+	if (!p->refer->attendedtransfer)
+		transmit_notify_with_sipfrag(p, seqno, "183 Ringing", FALSE);
+		
+	/* For blind transfer, this will lead to a new call */
+	/* For attended transfer to remote host, this will lead to
+   	   a new SIP call with a replaces header, if the dial plan allows it 
+  	*/
+	if (!current.chan2) {
+		/* We have no bridge, so we're talking with Asterisk somehow */
+		/* We need to masquerade this call */
+		/* What to do to fix this situation:
+		   * Set up the new call in a new channel 
+		   * Let the new channel masq into this channel
+		   Please add that code here :-)
+		*/
+		transmit_response(p, "202 Accepted", req);
+		p->refer->status = REFER_FAILED;
+		transmit_notify_with_sipfrag(p, seqno, "503 Service Unavailable (can't handle one-legged xfers)", TRUE);
+		ast_clear_flag(&p->flags[0], SIP_GOTREFER);	
+		append_history(p, "Xfer", "Refer failed (only bridged calls).");
+		return -1;
+	}
+	ast_set_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Delay hangup */
+
+	/* For blind transfers, move the call to the new extensions. For attended transfers on multiple
+	   servers - generate an INVITE with Replaces. Either way, let the dial plan decided  */
+	res = ast_async_goto(current.chan2, p->refer->refer_to_context, p->refer->refer_to, 1);
+
+	if (!res) {
+		/* Success  - we have a new channel */
+		if (option_debug > 2)
+			ast_log(LOG_DEBUG, "%s transfer succeeded. Telling transferer.\n", p->refer->attendedtransfer? "Attended" : "Blind");
+		transmit_notify_with_sipfrag(p, seqno, "200 Ok", TRUE);
+		if (p->refer->localtransfer)
+			p->refer->status = REFER_200OK;
+		if (p->owner)
+			p->owner->hangupcause = AST_CAUSE_NORMAL_CLEARING;
+		append_history(p, "Xfer", "Refer succeeded.");
+		ast_clear_flag(&p->flags[0], SIP_GOTREFER);	
+		/* Do not hangup call, the other side do that when we say 200 OK */
+		/* We could possibly implement a timer here, auto congestion */
+		res = 0;
+	} else {
+		ast_clear_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Don't delay hangup */
+		if (option_debug > 2)
+			ast_log(LOG_DEBUG, "%s transfer failed. Resuming original call.\n", p->refer->attendedtransfer? "Attended" : "Blind");
+		append_history(p, "Xfer", "Refer failed.");
+		/* Failure of some kind */
+		p->refer->status = REFER_FAILED;
+		transmit_notify_with_sipfrag(p, seqno, "503 Service Unavailable", TRUE);
+		ast_clear_flag(&p->flags[0], SIP_GOTREFER);	
+		res = -1;
+	}
 	return res;
 }
+
 /*! \brief Handle incoming CANCEL request */
 static int handle_request_cancel(struct sip_pvt *p, struct sip_request *req)
 {
@@ -11687,7 +12482,7 @@
 				if (bridged_to) {
 					/* Don't actually hangup here... */
 					ast_moh_stop(bridged_to);
-					ast_async_goto(bridged_to, p->context, p->refer_to,1);
+					ast_async_goto(bridged_to, p->context, p->refer->refer_to,1);
 				} else
 					ast_queue_hangup(p->owner);
 			}

Modified: trunk/configs/jabber.conf.sample
===================================================================
--- trunk/configs/jabber.conf.sample	2006-06-01 05:25:31 UTC (rev 206)
+++ trunk/configs/jabber.conf.sample	2006-06-01 08:25:34 UTC (rev 207)
@@ -7,9 +7,11 @@
 ;type=client				;;Client or Component connection
 ;serverhost=astjab.org			;;Route to server for example,
 					;;	talk.google.com
-;username=asterisk at astjab.org/asterisk	;;username with optional roster.
+;username=asterisk at astjab.org/asterisk	;;Username with optional roster.
 ;secret=blah				;;Password
 ;port=5222				;;Port to use defaults to 5222
-;usetls=yes				;;use tls or not
-;usesasl=yes				;;use sasl or not
-;buddy=mogorman at astjab.org		;;manual addition of buddy to list.
+;usetls=yes				;;Use tls or not
+;usesasl=yes				;;Use sasl or not
+;buddy=mogorman at astjab.org		;;Manual addition of buddy to list.
+;statusmessage="I am available"		;;Have custom status message for
+					;;Asterisk.

Modified: trunk/include/asterisk/jabber.h
===================================================================
--- trunk/include/asterisk/jabber.h	2006-06-01 05:25:31 UTC (rev 206)
+++ trunk/include/asterisk/jabber.h	2006-06-01 08:25:34 UTC (rev 207)
@@ -93,6 +93,7 @@
 	char user[160];
 	char serverhost[160];
 	char context[100];
+	char statusmessage[256];
 	char sid[10]; /* Session ID */
 	char mid[6]; /* Message ID */
 	iksid *jid;

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-01 05:25:31 UTC (rev 206)
+++ trunk/res/res_jabber.c	2006-06-01 08:25:34 UTC (rev 207)
@@ -377,14 +377,14 @@
 {
 	struct aji_client *client = NULL;
 
-	char *s = NULL, *sender = NULL, *recipiant = NULL, *message = NULL;
+	char *s = NULL, *sender = NULL, *recipient = NULL, *message = NULL;
 	if (data) {
 		s = ast_strdupa((char *) data);
 		if (s) {
 			sender = strsep(&s, "|");
 			if (sender && (sender[0] != '\0')) {
-				recipiant = strsep(&s, "|");
-				if (recipiant && (recipiant[0] != '\0')) {
+				recipient = strsep(&s, "|");
+				if (recipient && (recipient[0] != '\0')) {
 					message = s;
 				} else {
 					ast_log(LOG_ERROR, "Bad arguments \n");
@@ -401,8 +401,8 @@
 		ast_log(LOG_ERROR, "Out of memory\n");
 		return -1;
 	}
-	if (strchr(recipiant, '@') && message)
-		ast_aji_send(client, recipiant, message);
+	if (strchr(recipient, '@') && message)
+		ast_aji_send(client, recipient, message);
 	return 0;
 }
 
@@ -1019,7 +1019,7 @@
 
 	buddy = ASTOBJ_CONTAINER_FIND(&client->buddies, pak->from->partial);
 	if (!buddy) {
-		ast_log(LOG_WARNING, "Got presence packet from %s, somone not in our roster!!!!\n", pak->from->partial);
+		ast_log(LOG_WARNING, "Got presence packet from %s, someone not in our roster!!!!\n", pak->from->partial);
 		return;
 	}
 	status = (pak->show) ? pak->show : 6;
@@ -1475,6 +1475,8 @@
 	send = iks_make_iq(IKS_TYPE_GET, "http://jabber.org/protocol/disco#items");
 
 	if (client && removeiq && removequery && removeitem && send) {
+		iks_insert_node(removeiq, removequery);
+		iks_insert_node(removequery, removeitem);
 		ASTOBJ_CONTAINER_TRAVERSE(&client->buddies, 1, {
 			ASTOBJ_RDLOCK(iterator);
 			/* For an aji_buddy, both AUTOPRUNE and AUTOREGISTER will never
@@ -1491,8 +1493,6 @@
 				iks_insert_attrib(removequery, "xmlns", "jabber:iq:roster");
 				iks_insert_attrib(removeitem, "jid", iterator->name);
 				iks_insert_attrib(removeitem, "subscription", "remove");
-				iks_insert_node(removeiq, removequery);
-				iks_insert_node(removequery, removeitem);
 				res = iks_send(client->p, removeiq);
 			} else if (ast_test_flag(iterator, AJI_AUTOREGISTER)) {
 				if (iterator->btype == AJI_USER) {	/*if it is not a transport */
@@ -1639,7 +1639,7 @@
 	roster = iks_make_iq(IKS_TYPE_GET, IKS_NS_ROSTER);
 	if(roster) {
 		iks_insert_attrib(roster, "id", "roster");
-		aji_set_presence(client, client->jid->full, 1, "im available");
+		aji_set_presence(client, client->jid->full, 1, client->statusmessage);
 		iks_send(client->p, roster);
 	}
 	if (roster)
@@ -1920,6 +1920,8 @@
 	client->keepalive = 1;
 	client->timeout = 20;
 	client->component = AJI_CLIENT;
+	ast_copy_string(client->statusmessage, "Online and Available", sizeof(client->statusmessage));
+
 	if (flag) client->authorized = 0;
 	client->usesasl = 0;
 	if (flag) client->state = AJI_DISCONNECTED;
@@ -1930,6 +1932,8 @@
 			ast_copy_string(client->serverhost, var->value, sizeof(client->serverhost));
 		else if (!strcasecmp(var->name, "secret"))
 			ast_copy_string(client->password, var->value, sizeof(client->password));
+		else if (!strcasecmp(var->name, "statusmessage"))
+			ast_copy_string(client->statusmessage, var->value, sizeof(client->statusmessage));
 		else if (!strcasecmp(var->name, "port"))
 			client->port = atoi(var->value);
 		else if (!strcasecmp(var->name, "debug"))



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 11:25:25 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 11:25:25 +0200
Subject: [solid-pbx-svn] r208 - trunk/res
Message-ID: <200606010925.k519PPu2007269@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 11:25:25 +0200 (Thu, 01 Jun 2006)
New Revision: 208

Modified:
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r31318

------------------------------------------------------------------------
r31298 | mogorman | 2006-06-01 10:22:44 +0200 (Thu, 01 Jun 2006) | 3 lines

solves bug where reload deleted things it shouldnt have
and adds check into jabberstatus so it cant segfault.

------------------------------------------------------------------------


Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-01 08:25:34 UTC (rev 207)
+++ trunk/res/res_jabber.c	2006-06-01 09:25:25 UTC (rev 208)
@@ -332,7 +332,11 @@
 		ast_log(LOG_WARNING, "Could not find Connection.\n");
 		return -1;
 	}
-
+	
+	if(!&client->buddies) {
+		ast_log(LOG_WARNING, "No buddies for connection.\n");
+		return -1;
+	}
 	ASTOBJ_CONTAINER_TRAVERSE(&client->buddies, 1, {
 		ASTOBJ_RDLOCK(iterator); 
 		if (!strcasecmp(iterator->user, screenname)) {
@@ -2057,6 +2061,7 @@
 		}
 	}
 	ASTOBJ_UNLOCK(buddy);
+	ASTOBJ_UNMARK(buddy);
 	ASTOBJ_CONTAINER_LINK(&client->buddies, buddy);
 	return 0;
 }
@@ -2088,8 +2093,10 @@
 	ASTOBJ_UNLOCK(buddy);
 	if(flag)
 		ASTOBJ_CONTAINER_LINK(&client->buddies, buddy);
-	else
+	else {
+		ASTOBJ_UNMARK(buddy);
 		ASTOBJ_UNREF(buddy, aji_buddy_destroy);
+	}
 	return 1;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 15:25:56 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 15:25:56 +0200
Subject: [solid-pbx-svn] r209 - in trunk: channels channels/misdn configs
Message-ID: <200606011325.k51DPuFo008044@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 15:25:44 +0200 (Thu, 01 Jun 2006)
New Revision: 209

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/chan_misdn_config.h
   trunk/channels/misdn/ie.c
   trunk/channels/misdn/isdn_lib.c
   trunk/channels/misdn/isdn_lib.h
   trunk/channels/misdn/isdn_msg_parser.c
   trunk/channels/misdn_config.c
   trunk/configs/misdn.conf.sample
   trunk/configs/sip.conf.sample
Log:
Update to Asterisk SVN trunk r31352

------------------------------------------------------------------------
r31322 | kpfleming | 2006-06-01 14:43:01 +0200 (Thu, 01 Jun 2006) | 10 lines

Merged revisions 31321 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31321 | kpfleming | 2006-06-01 07:41:47 -0500 (Thu, 01 Jun 2006) | 2 lines

remove a sample entry that never should have been added (code to support it was not merged)

.......

------------------------------------------------------------------------
r31324 | crichter | 2006-06-01 14:51:41 +0200 (Thu, 01 Jun 2006) | 1 line

added bearer capability reject support. we send release instead of disconnect in case we have no real channel yet. added support for Restarting channels added support for sending complete decoding. changed some log levels.
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/chan_misdn.c	2006-06-01 13:25:44 UTC (rev 209)
@@ -151,6 +151,8 @@
   
 	ast_mutex_t lock;
 
+	char allowed_bearers[BUFFERSIZE+1];
+	
 	enum misdn_chan_state state;
 	int holded; 
 	int orginator;
@@ -346,12 +348,28 @@
 }
 
 
+
+struct allowed_bearers {
+	int cap;
+	int val;
+	char *name;
+};
+
+struct allowed_bearers allowed_bearers_array[]={
+	{INFO_CAPABILITY_SPEECH,1,"speech"},
+	{INFO_CAPABILITY_AUDIO_3_1K,2,"3_1khz"},
+	{INFO_CAPABILITY_DIGITAL_UNRESTRICTED,4,"digital_unrestricted"},
+	{INFO_CAPABILITY_DIGITAL_RESTRICTED,8,"digital_restriced"},
+	{INFO_CAPABILITY_VIDEO,16,"video"}
+};
+
 static char *bearer2str(int cap) {
 	static char *bearers[]={
 		"Speech",
 		"Audio 3.1k",
 		"Unres Digital",
 		"Res Digital",
+		"Video",
 		"Unknown Bearer"
 	};
 	
@@ -368,9 +386,12 @@
 	case INFO_CAPABILITY_DIGITAL_RESTRICTED:
 		return bearers[3];
 		break;
-	default:
+	case INFO_CAPABILITY_VIDEO:
 		return bearers[4];
 		break;
+	default:
+		return bearers[5];
+		break;
 	}
 }
 
@@ -1153,7 +1174,7 @@
 	
 	int port=bc->port;
 	
-	chan_misdn_log(1,port,"update_config: Getting Config\n");
+	chan_misdn_log(5,port,"update_config: Getting Config\n");
 
 
 	int hdlc=0;
@@ -1243,7 +1264,7 @@
 	struct misdn_bchannel *bc=ch->bc;
 	int len=ch->jb_len, threshold=ch->jb_upper_threshold;
 	
-	chan_misdn_log(1,bc->port, "config_jb: Called\n");
+	chan_misdn_log(5,bc->port, "config_jb: Called\n");
 	
 	if ( ! len ) {
 		chan_misdn_log(1,bc->port, "config_jb: Deactivating Jitterbuffer\n");
@@ -1295,6 +1316,10 @@
 	}
 }
 
+
+
+
+
 static int read_config(struct chan_list *ch, int orig) {
 
 	if (!ch) {
@@ -1335,7 +1360,10 @@
 	misdn_cfg_get( port, MISDN_CFG_NEED_MORE_INFOS, &bc->need_more_infos, sizeof(int));
 	
 	misdn_cfg_get( port, MISDN_CFG_FAR_ALERTING, &ch->far_alerting, sizeof(int));
+
+	misdn_cfg_get( port, MISDN_CFG_ALLOWED_BEARERS, &ch->allowed_bearers, BUFFERSIZE);
 	
+	
 	int hdlc=0;
 	misdn_cfg_get( port, MISDN_CFG_HDLC, &hdlc, sizeof(int));
 	
@@ -1394,7 +1422,7 @@
 		misdn_cfg_get(port, MISDN_CFG_PICKUPGROUP, &pg, sizeof(pg));
 		misdn_cfg_get(port, MISDN_CFG_CALLGROUP, &cg, sizeof(cg));
 		
-		chan_misdn_log(2, port, " --> * CallGrp:%s PickupGrp:%s\n",ast_print_group(buf,sizeof(buf),cg),ast_print_group(buf,sizeof(buf),pg));
+		chan_misdn_log(5, port, " --> * CallGrp:%s PickupGrp:%s\n",ast_print_group(buf,sizeof(buf),cg),ast_print_group(buf,sizeof(buf),pg));
 		ast->pickupgroup=pg;
 		ast->callgroup=cg;
 	}
@@ -2228,18 +2256,20 @@
 	int bridging;
 	misdn_cfg_get( 0, MISDN_GEN_BRIDGING, &bridging, sizeof(int));
 	if (bridging) {
-		int ecwb;
+		int ecwb, ec;
 		misdn_cfg_get( ch1->bc->port, MISDN_CFG_ECHOCANCELWHENBRIDGED, &ecwb, sizeof(int));
-		if ( !ecwb ) {
+		misdn_cfg_get( ch1->bc->port, MISDN_CFG_ECHOCANCEL, &ec, sizeof(int));
+		if ( !ecwb && ec ) {
 			chan_misdn_log(2, ch1->bc->port, "Disabling Echo Cancellor when Bridged\n");
 			ch1->bc->ec_enable=0;
-		/*	manager_ec_disable(ch1->bc); */
+			manager_ec_disable(ch1->bc);
 		}
 		misdn_cfg_get( ch2->bc->port, MISDN_CFG_ECHOCANCELWHENBRIDGED, &ecwb, sizeof(int));
-		if ( !ecwb ) {
+		misdn_cfg_get( ch2->bc->port, MISDN_CFG_ECHOCANCEL, &ec, sizeof(int));
+		if ( !ecwb && ec) {
 			chan_misdn_log(2, ch2->bc->port, "Disabling Echo Cancellor when Bridged\n");
 			ch2->bc->ec_enable=0;
-		/*	manager_ec_disable(ch2->bc); */
+			manager_ec_disable(ch2->bc); 
 		}
 		
 		/* trying to make a mISDN_dsp conference */
@@ -2291,7 +2321,7 @@
 	const struct tone_zone_sound *ts= NULL;
 	struct ast_channel *ast=cl->ast;
 	
-	chan_misdn_log(2,cl->bc->port,"Tone Indicate:\n");
+	chan_misdn_log(3,cl->bc->port,"Tone Indicate:\n");
 	
 	if (!cl->ast) {
 		return 0;
@@ -2299,24 +2329,24 @@
 	
 	switch (tone) {
 	case TONE_DIAL:
-		chan_misdn_log(2,cl->bc->port," --> Dial\n");
+		chan_misdn_log(3,cl->bc->port," --> Dial\n");
 		ts=ast_get_indication_tone(ast->zone,"dial");
 		misdn_lib_tone_generator_start(cl->bc);
 		break;
 	case TONE_ALERTING:
-		chan_misdn_log(2,cl->bc->port," --> Ring\n");
+		chan_misdn_log(3,cl->bc->port," --> Ring\n");
 		ts=ast_get_indication_tone(ast->zone,"ring");
 		misdn_lib_tone_generator_stop(cl->bc);
 		break;
 	case TONE_FAR_ALERTING:
 	/* VERY UGLY HACK, BECAUSE CHAN_SIP DOES NOT GENERATE TONES */
-		chan_misdn_log(2,cl->bc->port," --> Ring\n");
+		chan_misdn_log(3,cl->bc->port," --> Ring\n");
 		ts=ast_get_indication_tone(ast->zone,"ring");
 		misdn_lib_tone_generator_start(cl->bc);
 		misdn_lib_echo(cl->bc,1);
 		break;
 	case TONE_BUSY:
-		chan_misdn_log(2,cl->bc->port," --> Busy\n");
+		chan_misdn_log(3,cl->bc->port," --> Busy\n");
 		ts=ast_get_indication_tone(ast->zone,"busy");
 		misdn_lib_tone_generator_stop(cl->bc);
 		break;
@@ -2324,7 +2354,7 @@
 		break;
 
 	case TONE_NONE:
-		chan_misdn_log(2,cl->bc->port," --> None\n");
+		chan_misdn_log(3,cl->bc->port," --> None\n");
 		misdn_lib_tone_generator_stop(cl->bc);
 		ast_playtones_stop(ast);
 		break;
@@ -2784,8 +2814,8 @@
 		} 
 		release_unlock;
 		
-		chan_misdn_log(1, bc->port, "Trying to Release bc with l3id: %x\n",bc->l3_id);
-
+		chan_misdn_log(1, bc->port, "release_chan: bc with l3id: %x\n",bc->l3_id);
+		
 		//releaseing jitterbuffer
 		if (ch->jb ) {
 			misdn_jb_destroy(ch->jb);
@@ -3325,6 +3355,24 @@
 
 		/** queue new chan **/
 		cl_queue_chan(&cl_te, ch) ;
+
+
+		if (!strstr(ch->allowed_bearers,"all")) {
+			int i;
+			for (i=0; i< sizeof(allowed_bearers_array)/sizeof(struct allowed_bearers); i++) {
+				if (allowed_bearers_array[i].cap == bc->capability) {
+					if (  !strstr( ch->allowed_bearers, allowed_bearers_array[i].name)) {
+						chan_misdn_log(0,bc->port,"Bearer Not allowed\b");
+						bc->out_cause=88;
+						
+						ch->state=MISDN_EXTCANTMATCH;
+						misdn_lib_send_event(bc, EVENT_RELEASE_COMPLETE );
+						return RESPONSE_OK;
+					}
+				}
+				
+			}
+		}
 		
 		/* Check for Pickup Request first */
 		if (!strcmp(chan->exten, ast_pickup_ext())) {
@@ -3380,7 +3428,8 @@
 			if (bc->nt)
 				misdn_lib_send_event(bc, EVENT_RELEASE_COMPLETE );
 			else
-				misdn_lib_send_event(bc, EVENT_DISCONNECT );
+				misdn_lib_send_event(bc, EVENT_RELEASE );
+				
 			break;
 		}
 		
@@ -3404,26 +3453,34 @@
 				if (bc->nt)
 					misdn_lib_send_event(bc, EVENT_RELEASE_COMPLETE );
 				else
-					misdn_lib_send_event(bc, EVENT_DISCONNECT );
+					misdn_lib_send_event(bc, EVENT_RELEASE);
 			}
 		} else {
-			int ret= misdn_lib_send_event(bc, EVENT_SETUP_ACKNOWLEDGE );
-			if (ret == -ENOCHAN) {
-				ast_log(LOG_WARNING,"Channel was catched, before we could Acknowledge\n");
-				misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
+
+
+			if (bc->sending_complete) {
+				bc->out_cause=1;
+				misdn_lib_send_event(bc, EVENT_RELEASE);
+			} else {
+				
+				int ret= misdn_lib_send_event(bc, EVENT_SETUP_ACKNOWLEDGE );
+				if (ret == -ENOCHAN) {
+					ast_log(LOG_WARNING,"Channel was catched, before we could Acknowledge\n");
+					misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
+				}
+				/*  send tone to phone :) */
+				
+				/** ADD IGNOREPAT **/
+				
+				int stop_tone;
+				misdn_cfg_get( 0, MISDN_GEN_STOP_TONE, &stop_tone, sizeof(int));
+				if ( (!ast_strlen_zero(bc->dad)) && stop_tone ) 
+					tone_indicate(ch,TONE_NONE);
+				else
+					tone_indicate(ch,TONE_DIAL);
+				
+				ch->state=MISDN_WAITING4DIGS;
 			}
-			/*  send tone to phone :) */
-
-			/** ADD IGNOREPAT **/
-			
-			int stop_tone;
-			misdn_cfg_get( 0, MISDN_GEN_STOP_TONE, &stop_tone, sizeof(int));
-			if ( (!ast_strlen_zero(bc->dad)) && stop_tone ) 
-				tone_indicate(ch,TONE_NONE);
-			else
-				tone_indicate(ch,TONE_DIAL);
-			
-			ch->state=MISDN_WAITING4DIGS;
 		}
       
 	}
@@ -3791,8 +3848,11 @@
 		
 		break;
 
+	case EVENT_RESTART:
 
-	case EVENT_RESTART:
+		stop_bc_tones(ch);
+		release_chan(bc);
+		
 		break;
 				
 	default:

Modified: trunk/channels/misdn/chan_misdn_config.h
===================================================================
--- trunk/channels/misdn/chan_misdn_config.h	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/misdn/chan_misdn_config.h	2006-06-01 13:25:44 UTC (rev 209)
@@ -23,6 +23,7 @@
 	/* port config items */
 	MISDN_CFG_FIRST = 0,
 	MISDN_CFG_GROUPNAME,           /* char[] */
+	MISDN_CFG_ALLOWED_BEARERS,           /* char[] */
 	MISDN_CFG_FAR_ALERTING,        /* int (bool) */
 	MISDN_CFG_RXGAIN,              /* int */
 	MISDN_CFG_TXGAIN,              /* int */

Modified: trunk/channels/misdn/ie.c
===================================================================
--- trunk/channels/misdn/ie.c	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/misdn/ie.c	2006-06-01 13:25:44 UTC (rev 209)
@@ -162,23 +162,28 @@
 	*stopbits = -1;
 	*dbits = -1;
 	*parity = -1;
-
+	
 	if (!nt)
 	{
 		p = NULL;
-		if (qi->QI_ELEMENT(llc))
+#ifdef LLC_SUPPORT
+		if (qi->QI_ELEMENT(llc)) {
+			
 			p = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(llc) + 1;
-		else if (qi->QI_ELEMENT(bearer_capability))
+		}
+#endif
+		if (qi->QI_ELEMENT(bearer_capability))
 			p = (unsigned char *)qi + sizeof(Q931_info_t) + qi->QI_ELEMENT(bearer_capability) + 1;
 	}
 	if (!p)
 		return;
+
 	if (p[0] < 2)
 	{
 		printf("%s: ERROR: IE too short (%d).\n", __FUNCTION__, p[0]);
 		return;
 	}
-
+	
 	*coding = (p[1]&0x60) >> 5;
 	*capability = p[1] & 0x1f;
 	octet = 2;

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-01 13:25:44 UTC (rev 209)
@@ -471,6 +471,10 @@
 	bc->channel = 0;
 	bc->in_use = 0;
 
+	bc->sending_complete = 0;
+
+	bc->restart_channel=0;
+	
 	bc->conf_id = 0;
 
 	bc->need_more_infos = 0;
@@ -557,7 +561,7 @@
 	unsigned char buff[32];
 	struct misdn_stack * stack;
 
-	cb_log(2, 0, "$$$ CLEANUP CALLED\n");
+	cb_log(3, 0, "$$$ CLEANUP CALLED\n");
 	
 	if (!bc  ) return -1;
 	stack=get_stack_by_bc(bc);
@@ -587,15 +591,18 @@
 		manager_ec_disable(bc);
 	}
 
-	mISDN_write_frame(stack->midev, buff, bc->layer_id|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC); 
+	if (bc->bc_state == BCHAN_SETUP) 
+		mISDN_write_frame(stack->midev, buff, bc->layer_id|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
+	else
+		mISDN_write_frame(stack->midev, buff, bc->addr|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
 
-	cb_log(2, stack->port, "$$$ CLEARING STACK\n");
+	cb_log(3, stack->port, "$$$ CLEARING STACK\n");
+	
 	ret=mISDN_clear_stack(stack->midev,bc->b_stid);
 	if (ret<0) {
 		cb_log(-1,stack->port,"clear stack failed [%s]\n",strerror(errno));
 	}
 
-	
 	bc->b_stid = 0;
 	bc_state_change(bc, BCHAN_CLEANED);
 	
@@ -612,8 +619,7 @@
 			cb_event(EVENT_CLEANUP, &stack->bc[i], glob_mgr->user_data);
 			empty_chan_in_stack(stack,i+1);
 			empty_bc(&stack->bc[i]);
-			queue_cleanup_bc(&stack->bc[i]);
-			
+			clean_up_bc(&stack->bc[i]);
 		}
 		
 	} 
@@ -971,19 +977,18 @@
 		pid.layermask = ISDN_LAYER((1)) | ISDN_LAYER((2)) | ISDN_LAYER((3)) | ISDN_LAYER((4));
 		
 	} 
-	
+
 	ret = mISDN_set_stack(midev, bc->b_stid, &pid);
-	
+
 	if (ret){
-		cb_log(5, stack->port,"$$$ Set Stack Err: %d %s\n",ret,strerror(errno));
+		cb_log(-1, stack->port,"$$$ Set Stack Err: %d %s\n",ret,strerror(errno));
 		
 		mISDN_write_frame(midev, buff, bc->layer_id, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
-
+		
 		bc_state_change(bc,BCHAN_ERROR);
 		return(-EINVAL);
 	}
 
-
 	bc_state_change(bc,BCHAN_SETUP);
 
 	
@@ -1479,7 +1484,7 @@
 				cb_log(4, stack->port, " --> lib: CLEANING UP l3id: %x\n",frm->dinfo);
 				empty_chan_in_stack(stack,bc->channel);
 				empty_bc(bc);
-				queue_cleanup_bc(bc);
+				clean_up_bc(bc);
 				dump_chan_list(stack);
 				bc->pid = 0;
 				cb_event(EVENT_CLEANUP, bc, glob_mgr->user_data);
@@ -1517,7 +1522,7 @@
 		empty_chan_in_stack(stack,bc->channel);
 		empty_bc(bc);
 	}
-	queue_cleanup_bc(bc);
+	clean_up_bc(bc);
 }
 
 
@@ -2049,7 +2054,7 @@
 		
 	case MGR_SETSTACK| INDICATION:
 		cb_log(2, stack->port, "BCHAN: MGR_SETSTACK|IND \n");
-
+		
 	AGAIN:
 		bc->addr = mISDN_get_layerid(stack->midev, bc->b_stid, bc->layer);
 		if (!bc->addr) {
@@ -2943,7 +2948,7 @@
 
 			empty_chan_in_stack(stack,bc->channel);
 			empty_bc(bc);
-			queue_cleanup_bc(bc);
+			clean_up_bc(bc);
 		}
 		
 		/** we set it up later at RETRIEVE_ACK again.**/
@@ -3018,6 +3023,13 @@
 		case MGR_SETSTACK|INDICATION:
 			return handle_bchan(msg);
 		break;
+
+		case MGR_SETSTACK|CONFIRM:
+		case MGR_CLEARSTACK|CONFIRM:
+			free_msg(msg) ; 
+			return 1;
+		break;
+
 		case DL_DATA|INDICATION:
 		{
 			int port=(frm->addr&MASTER_ID_MASK) >> 8;
@@ -3101,10 +3113,12 @@
 	if (handle_l1(msg)) 
 		return 0 ;
 
-	/* The L2/L3 will be queued */
-	if (queue_l2l3(msg))
+	if (handle_frm_nt(msg)) 
 		return 0;
 
+	if (handle_frm(msg))
+		return 0;
+
 	if (handle_err(msg)) 
 		return 0 ;
 
@@ -3862,7 +3876,7 @@
 }
 
 void misdn_lib_bridge( struct misdn_bchannel * bc1, struct misdn_bchannel *bc2) {
-	int conf_id=(bc1->pid<<1) +1;
+	int conf_id=bc1->pid +1;
 
 	cb_log(1, bc1->port, "I Send: BRIDGE from:%d to:%d\n",bc1->port,bc2->port);
 	

Modified: trunk/channels/misdn/isdn_lib.h
===================================================================
--- trunk/channels/misdn/isdn_lib.h	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/misdn/isdn_lib.h	2006-06-01 13:25:44 UTC (rev 209)
@@ -182,7 +182,8 @@
 	int l3_id;
 	int pid;
 	int ces;
-  
+
+	int restart_channel;
 	int channel;
 	int channel_preselected;
 	
@@ -208,6 +209,10 @@
 	/* get setup ack */
 	int need_more_infos;
 
+	/* may there be more infos ?*/
+	int sending_complete;
+
+
 	/* wether we should use jollys dsp or not */
 	int nodsp;
 	

Modified: trunk/channels/misdn/isdn_msg_parser.c
===================================================================
--- trunk/channels/misdn/isdn_msg_parser.c	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/misdn/isdn_msg_parser.c	2006-06-01 13:25:44 UTC (rev 209)
@@ -197,8 +197,8 @@
 	}
 
 	{
-		int  sending_complete;
-		dec_ie_complete(setup->COMPLETE, (Q931_info_t *)setup, &sending_complete, nt,bc);
+		dec_ie_complete(setup->COMPLETE, (Q931_info_t *)setup, &bc->sending_complete, nt,bc);
+		
 	}
   
 	{
@@ -217,6 +217,8 @@
 			break;
 		case 0: bc->capability=INFO_CAPABILITY_SPEECH;
 			break;
+		case 18: bc->capability=INFO_CAPABILITY_VIDEO;
+			break;
 		case 8: bc->capability=INFO_CAPABILITY_DIGITAL_UNRESTRICTED;
 			bc->user1 = user;
 			bc->urate = urate;
@@ -775,7 +777,7 @@
   
 	{
 		int  exclusive, channel;
-		dec_ie_channel_id(restart->CHANNEL_ID, (Q931_info_t *)restart, &exclusive, &channel, nt,bc);
+		dec_ie_channel_id(restart->CHANNEL_ID, (Q931_info_t *)restart, &exclusive, &bc->restart_channel, nt,bc);
 		if (channel==0xff) /* any channel */
 			channel=-1;
 		cb_log(3, stack->port, "CC_RESTART Request on channel:%d on this port.\n");

Modified: trunk/channels/misdn_config.c
===================================================================
--- trunk/channels/misdn_config.c	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/channels/misdn_config.c	2006-06-01 13:25:44 UTC (rev 209)
@@ -84,6 +84,7 @@
 
 static const struct misdn_cfg_spec port_spec[] = {
 	{ "name", MISDN_CFG_GROUPNAME, MISDN_CTYPE_STR, "default", NONE },
+	{ "allowed_bearers", MISDN_CFG_ALLOWED_BEARERS, MISDN_CTYPE_STR, "all", NONE },
 	{ "rxgain", MISDN_CFG_RXGAIN, MISDN_CTYPE_INT, "0", NONE },
 	{ "txgain", MISDN_CFG_TXGAIN, MISDN_CTYPE_INT, "0", NONE },
 	{ "te_choose_channel", MISDN_CFG_TE_CHOOSE_CHANNEL, MISDN_CTYPE_BOOL, "no", NONE },

Modified: trunk/configs/misdn.conf.sample
===================================================================
--- trunk/configs/misdn.conf.sample	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/configs/misdn.conf.sample	2006-06-01 13:25:44 UTC (rev 209)
@@ -128,6 +128,11 @@
 far_alerting=no
 
 
+;
+; here you can define which bearers should be allowed
+;
+allowed_bearers=all
+
 ; Prefixes for national and international, those are put before the 
 ; oad if an according dialplan is set by the other end. 
 ;

Modified: trunk/configs/sip.conf.sample
===================================================================
--- trunk/configs/sip.conf.sample	2006-06-01 09:25:25 UTC (rev 208)
+++ trunk/configs/sip.conf.sample	2006-06-01 13:25:44 UTC (rev 209)
@@ -460,7 +460,6 @@
 ;allow=alaw
 ;allow=g723.1			; Asterisk only supports g723.1 pass-thru!
 ;allow=g729			; Pass-thru only unless g729 license obtained
-;astdb=chan2ext/SIP/grandstream1=1234	; ensures an astDB entry exists
 ;callingpres=allowed_passed_screen	; Set caller ID presentation
 				; See README.callingpres for more information
 



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 16:25:43 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 16:25:43 +0200
Subject: [solid-pbx-svn] r210 - in trunk: . channels
Message-ID: <200606011425.k51EPhU8011540@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 16:25:36 +0200 (Thu, 01 Jun 2006)
New Revision: 210

Modified:
   trunk/CREDITS
   trunk/Makefile
   trunk/abstract_jb.c
   trunk/channels/chan_sip.c
   trunk/scx_jitterbuf.c
   trunk/scx_jitterbuf.h
Log:
Update to Asterisk SVN trunk r31359

------------------------------------------------------------------------
r31356 | russell | 2006-06-01 16:07:03 +0200 (Thu, 01 Jun 2006) | 4 lines

- add slav, zoa, and royk to the CREDITS for the generic jitterbuffer
- change references to the "scx" jitterbuffer to be called "fixed" and change
  references to the "stevek" jitterbuffer to be called "adaptive", instead

------------------------------------------------------------------------
r31359 | russell | 2006-06-01 16:15:16 +0200 (Thu, 01 Jun 2006) | 3 lines

make a global variable static and remove an unused global variable
(issue #7258, tardieu)

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/CREDITS	2006-06-01 14:25:36 UTC (rev 210)
@@ -30,58 +30,94 @@
 === MISCELLANEOUS PATCHES ===
 Jim Dixon - Zapata Telephony and app_rpt
 	http://www.zapatatelephony.org/app_rpt.html
+
 Russell Bryant - Asterisk 1.0 maintainer and misc. enhancements
 	russelb at clemson.edu
+
 Anthony Minessale II - Countless big and small fixes, and relentless forward push
 	anthmct at yahoo.com              http://www.asterlink.com
+
 James Golovich - Innumerable contributions
 	You can find him and asterisk-perl at http://asterisk.gnuinter.net
+
 Andre Bierwirth - Extension hints and status
+
 Oliver Daudey - ISDN4Linux fixes
+
 Pauline Middelink - ISDN4Linux patches and some general patches.
 	She can be found at http://www.polyware.nl/~middelink/En/
+
 Jean-Denis Girard - Various contributions from the South Pacific Islands
 	jd-girard at esoft.pf             http://www.esoft.pf
+
 William Jordan / Vonage - MySQL enhancements to Voicemail
 	wjordan at vonage.com
+
 Jac Kersing - Various fixes
+
 Steven Critchfield - Seek and Trunc functions for playback and recording
 	critch at basesys.com
+
 Jefferson Noxon - app_lookupcidname, app_db, and various other contributions
+
 Klaus-Peter Junghanns - in-band DTMF on SIP and MGCP
+
 Ross Finlayson - Dynamic RTP payload support
+
 Mahmut Fettahlioglu - Audio recording, music-on-hold changes, alaw file
 	format, and various fixes. Can be contacted at mahmut at oa.com.au
+
 James Dennis - Cisco SIP compatibility patches to work with SIP service
 	providers. Can be contacted at asterisk at jdennis.net
+
 Tilghman Lesher - ast_localtime(); ast_say_date_with_format(); 
 	GotoIfTime, Random, SayUnixTime, HasNewVoicemail applications;
 	CUT, SORT, EVAL, CURL, FIELDQTY, STRFTIME, QUEUEAGENT* functions;
 	and other innumerable bug fixes. http://asterisk.drunkcoder.com/
+
 Jayson Vantuyl - Manager protocol changes, various other bugs.
 	jvantuyl at computingedge.net
+
 Thorsten Lockert - OpenBSD, FreeBSD ports, making MacOS X port run on 10.3,
 	dialplan include verification, route lookup on OpenBSD, SNMP agent
 	support (res_snmp), various other bugs. tholo at sigmasoft.com
+
 Brian West - ODBC support and Bug Marshaling  
+
 Josh Roberson - chan_zap reload support, Advanced Voicemail Features, other misc. patches,
 	and Bug Marshalling. - josh at asteriasgi.com, http://www.asteriasgi.com
+
 William Waites - syslog support, SIP NAT traversal for SIP-UA. ww at styx.org
+
 Rich Murphey - Porting to FreeBSD, NetBSD, OpenBSD, and Darwin.
 	rich at whiteoaklabs.com  http://whiteoaklabs.com
+
 Simon Lockhart - Porting to Solaris (based on work of Logan ???)	
 	simon at slimey.org
+
 Olle E. Johansson - SIP RFC compliance, documentation and testing, testing, testing
 	oej at edvina.net, http://edvina.net
+
 Steve Kann - new jitter buffer for IAX2
 	stevek at stevek.com
+
 Constantine Filin - major contributions to the Asterisk Realtime Architecture
+
 Steve Murphy - privacy support, $[ ] parser upgrade, AEL2 parser upgrade
+
 Claude Patry - bug fixes, feature enhancements, and bug marshalling
 	cpatry at gmail.com
+
 Miroslav Nachev, miro at space-comm.com COSMOS Software Enterprises, Ltd.
 	- for Variable for No Answer Timeout for Attended Transfer
 
+Slav Klenov & Vanheuverzwijn Joachim - development of the generic jitterbuffer
+	Securax Ltd. info at securax.be
+
+Roy Sigurd Karlsbakk - providing funding for generic jitterbuffer development
+	roy at karlsbakk.net, Briiz Telecom AS
+
+
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt
 Michael Jerris - bug marshaling

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/Makefile	2006-06-01 14:25:36 UTC (rev 210)
@@ -282,7 +282,7 @@
 	astmm.o enum.o srv.o dns.o aescrypt.o aestab.o aeskey.o \
 	utils.o plc.o jitterbuf.o dnsmgr.o devicestate.o \
 	netsock.o slinfactory.o ast_expr2.o ast_expr2f.o \
-	cryptostub.o sha1.o http.o scx_jitterbuf.o abstract_jb.o
+	cryptostub.o sha1.o http.o fixedjitterbuf.o abstract_jb.o
 
 # we need to link in the objects statically, not as a library, because
 # otherwise modules will not have them available if none of the static

Modified: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/abstract_jb.c	2006-06-01 14:25:36 UTC (rev 210)
@@ -42,7 +42,7 @@
 #include "asterisk/utils.h"
 
 #include "asterisk/abstract_jb.h"
-#include "scx_jitterbuf.h"
+#include "fixedjitterbuf.h"
 #include "jitterbuf.h"
 
 /*! Internal jb flags */
@@ -89,49 +89,49 @@
 };
 
 /* Implementation functions */
-/* scx */
-static void * jb_create_scx(struct ast_jb_conf *general_config, long resynch_threshold);
-static void jb_destroy_scx(void *jb);
-static int jb_put_first_scx(void *jb, struct ast_frame *fin, long now);
-static int jb_put_scx(void *jb, struct ast_frame *fin, long now);
-static int jb_get_scx(void *jb, struct ast_frame **fout, long now, long interpl);
-static long jb_next_scx(void *jb);
-static int jb_remove_scx(void *jb, struct ast_frame **fout);
-static void jb_force_resynch_scx(void *jb);
-/* stevek */
-static void * jb_create_stevek(struct ast_jb_conf *general_config, long resynch_threshold);
-static void jb_destroy_stevek(void *jb);
-static int jb_put_first_stevek(void *jb, struct ast_frame *fin, long now);
-static int jb_put_stevek(void *jb, struct ast_frame *fin, long now);
-static int jb_get_stevek(void *jb, struct ast_frame **fout, long now, long interpl);
-static long jb_next_stevek(void *jb);
-static int jb_remove_stevek(void *jb, struct ast_frame **fout);
-static void jb_force_resynch_stevek(void *jb);
+/* fixed */
+static void * jb_create_fixed(struct ast_jb_conf *general_config, long resynch_threshold);
+static void jb_destroy_fixed(void *jb);
+static int jb_put_first_fixed(void *jb, struct ast_frame *fin, long now);
+static int jb_put_fixed(void *jb, struct ast_frame *fin, long now);
+static int jb_get_fixed(void *jb, struct ast_frame **fout, long now, long interpl);
+static long jb_next_fixed(void *jb);
+static int jb_remove_fixed(void *jb, struct ast_frame **fout);
+static void jb_force_resynch_fixed(void *jb);
+/* adaptive */
+static void * jb_create_adaptive(struct ast_jb_conf *general_config, long resynch_threshold);
+static void jb_destroy_adaptive(void *jb);
+static int jb_put_first_adaptive(void *jb, struct ast_frame *fin, long now);
+static int jb_put_adaptive(void *jb, struct ast_frame *fin, long now);
+static int jb_get_adaptive(void *jb, struct ast_frame **fout, long now, long interpl);
+static long jb_next_adaptive(void *jb);
+static int jb_remove_adaptive(void *jb, struct ast_frame **fout);
+static void jb_force_resynch_adaptive(void *jb);
 
 /* Available jb implementations */
 static struct ast_jb_impl avail_impl[] = 
 {
 	{
 		.name = "fixed",
-		.create = jb_create_scx,
-		.destroy = jb_destroy_scx,
-		.put_first = jb_put_first_scx,
-		.put = jb_put_scx,
-		.get = jb_get_scx,
-		.next = jb_next_scx,
-		.remove = jb_remove_scx,
-		.force_resync = jb_force_resynch_scx
+		.create = jb_create_fixed,
+		.destroy = jb_destroy_fixed,
+		.put_first = jb_put_first_fixed,
+		.put = jb_put_fixed,
+		.get = jb_get_fixed,
+		.next = jb_next_fixed,
+		.remove = jb_remove_fixed,
+		.force_resync = jb_force_resynch_fixed
 	},
 	{
 		.name = "adaptive",
-		.create = jb_create_stevek,
-		.destroy = jb_destroy_stevek,
-		.put_first = jb_put_first_stevek,
-		.put = jb_put_stevek,
-		.get = jb_get_stevek,
-		.next = jb_next_stevek,
-		.remove = jb_remove_stevek,
-		.force_resync = jb_force_resynch_stevek
+		.create = jb_create_adaptive,
+		.destroy = jb_destroy_adaptive,
+		.put_first = jb_put_first_adaptive,
+		.put = jb_put_adaptive,
+		.get = jb_get_adaptive,
+		.next = jb_next_adaptive,
+		.remove = jb_remove_adaptive,
+		.force_resync = jb_force_resynch_adaptive
 	}
 };
 
@@ -147,9 +147,9 @@
 };
 
 /* Translations between impl and abstract return codes */
-static int scx_to_abstract_code[] =
+static int fixed_to_abstract_code[] =
 	{JB_IMPL_OK, JB_IMPL_DROP, JB_IMPL_INTERP, JB_IMPL_NOFRAME};
-static int stevek_to_abstract_code[] =
+static int adaptive_to_abstract_code[] =
 	{JB_IMPL_OK, JB_IMPL_NOFRAME, JB_IMPL_NOFRAME, JB_IMPL_INTERP, JB_IMPL_DROP, JB_IMPL_OK};
 
 /* JB_GET actions (used only for the frames log) */
@@ -467,7 +467,7 @@
 	res = jbimpl->put_first(jbobj, frr, now);
 	
 	/* The result of putting the first frame should not differ from OK. However, its possible
-	   some implementations (i.e. stevek's when resynch_threshold is specified) to drop it. */
+	   some implementations (i.e. adaptive's when resynch_threshold is specified) to drop it. */
 	if (res != JB_IMPL_OK) {
 		ast_log(LOG_WARNING, "Failed to put first frame in the jitterbuffer on channel '%s'\n", chan->name);
 		/*
@@ -615,170 +615,170 @@
 
 /* Implementation functions */
 
-/* scx */
+/* fixed */
 
-static void * jb_create_scx(struct ast_jb_conf *general_config, long resynch_threshold)
+static void * jb_create_fixed(struct ast_jb_conf *general_config, long resynch_threshold)
 {
-	struct scx_jb_conf conf;
+	struct fixed_jb_conf conf;
 	
 	conf.jbsize = general_config->max_size;
 	conf.resync_threshold = resynch_threshold;
 	
-	return scx_jb_new(&conf);
+	return fixed_jb_new(&conf);
 }
 
 
-static void jb_destroy_scx(void *jb)
+static void jb_destroy_fixed(void *jb)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	
 	/* destroy the jb */
-	scx_jb_destroy(scxjb);
+	fixed_jb_destroy(fixedjb);
 }
 
 
-static int jb_put_first_scx(void *jb, struct ast_frame *fin, long now)
+static int jb_put_first_fixed(void *jb, struct ast_frame *fin, long now)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	int res;
 	
-	res = scx_jb_put_first(scxjb, fin, fin->len, fin->ts, now);
+	res = fixed_jb_put_first(fixedjb, fin, fin->len, fin->ts, now);
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static int jb_put_scx(void *jb, struct ast_frame *fin, long now)
+static int jb_put_fixed(void *jb, struct ast_frame *fin, long now)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	int res;
 	
-	res = scx_jb_put(scxjb, fin, fin->len, fin->ts, now);
+	res = fixed_jb_put(fixedjb, fin, fin->len, fin->ts, now);
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static int jb_get_scx(void *jb, struct ast_frame **fout, long now, long interpl)
+static int jb_get_fixed(void *jb, struct ast_frame **fout, long now, long interpl)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
-	struct scx_jb_frame frame;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
+	struct fixed_jb_frame frame;
 	int res;
 	
-	res = scx_jb_get(scxjb, &frame, now, interpl);
+	res = fixed_jb_get(fixedjb, &frame, now, interpl);
 	*fout = frame.data;
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static long jb_next_scx(void *jb)
+static long jb_next_fixed(void *jb)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	
-	return scx_jb_next(scxjb);
+	return fixed_jb_next(fixedjb);
 }
 
 
-static int jb_remove_scx(void *jb, struct ast_frame **fout)
+static int jb_remove_fixed(void *jb, struct ast_frame **fout)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
-	struct scx_jb_frame frame;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
+	struct fixed_jb_frame frame;
 	int res;
 	
-	res = scx_jb_remove(scxjb, &frame);
+	res = fixed_jb_remove(fixedjb, &frame);
 	*fout = frame.data;
 	
-	return scx_to_abstract_code[res];
+	return fixed_to_abstract_code[res];
 }
 
 
-static void jb_force_resynch_scx(void *jb)
+static void jb_force_resynch_fixed(void *jb)
 {
-	struct scx_jb *scxjb = (struct scx_jb *) jb;
+	struct fixed_jb *fixedjb = (struct fixed_jb *) jb;
 	
-	scx_jb_set_force_resynch(scxjb);
+	fixed_jb_set_force_resynch(fixedjb);
 }
 
 
-/* stevek */
+/* adaptive */
 
-static void *jb_create_stevek(struct ast_jb_conf *general_config, long resynch_threshold)
+static void *jb_create_adaptive(struct ast_jb_conf *general_config, long resynch_threshold)
 {
 	jb_conf jbconf;
-	jitterbuf *stevekjb;
+	jitterbuf *adaptivejb;
 
-	stevekjb = jb_new();
-	if (stevekjb) {
+	adaptivejb = jb_new();
+	if (adaptivejb) {
 		jbconf.max_jitterbuf = general_config->max_size;
 		jbconf.resync_threshold = general_config->resync_threshold;
 		jbconf.max_contig_interp = 10;
-		jb_setconf(stevekjb, &jbconf);
+		jb_setconf(adaptivejb, &jbconf);
 	}
 	
-	return stevekjb;
+	return adaptivejb;
 }
 
 
-static void jb_destroy_stevek(void *jb)
+static void jb_destroy_adaptive(void *jb)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	
-	jb_destroy(stevekjb);
+	jb_destroy(adaptivejb);
 }
 
 
-static int jb_put_first_stevek(void *jb, struct ast_frame *fin, long now)
+static int jb_put_first_adaptive(void *jb, struct ast_frame *fin, long now)
 {
-	return jb_put_stevek(jb, fin, now);
+	return jb_put_adaptive(jb, fin, now);
 }
 
 
-static int jb_put_stevek(void *jb, struct ast_frame *fin, long now)
+static int jb_put_adaptive(void *jb, struct ast_frame *fin, long now)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	int res;
 	
-	res = jb_put(stevekjb, fin, JB_TYPE_VOICE, fin->len, fin->ts, now);
+	res = jb_put(adaptivejb, fin, JB_TYPE_VOICE, fin->len, fin->ts, now);
 	
-	return stevek_to_abstract_code[res];
+	return adaptive_to_abstract_code[res];
 }
 
 
-static int jb_get_stevek(void *jb, struct ast_frame **fout, long now, long interpl)
+static int jb_get_adaptive(void *jb, struct ast_frame **fout, long now, long interpl)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	jb_frame frame;
 	int res;
 	
-	res = jb_get(stevekjb, &frame, now, interpl);
+	res = jb_get(adaptivejb, &frame, now, interpl);
 	*fout = frame.data;
 	
-	return stevek_to_abstract_code[res];
+	return adaptive_to_abstract_code[res];
 }
 
 
-static long jb_next_stevek(void *jb)
+static long jb_next_adaptive(void *jb)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	
-	return jb_next(stevekjb);
+	return jb_next(adaptivejb);
 }
 
 
-static int jb_remove_stevek(void *jb, struct ast_frame **fout)
+static int jb_remove_adaptive(void *jb, struct ast_frame **fout)
 {
-	jitterbuf *stevekjb = (jitterbuf *) jb;
+	jitterbuf *adaptivejb = (jitterbuf *) jb;
 	jb_frame frame;
 	int res;
 	
-	res = jb_getall(stevekjb, &frame);
+	res = jb_getall(adaptivejb, &frame);
 	*fout = frame.data;
 	
-	return stevek_to_abstract_code[res];
+	return adaptive_to_abstract_code[res];
 }
 
 
-static void jb_force_resynch_stevek(void *jb)
+static void jb_force_resynch_adaptive(void *jb)
 {
 }

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/channels/chan_sip.c	2006-06-01 14:25:36 UTC (rev 210)
@@ -288,7 +288,7 @@
 	SIP_INFO,
 	SIP_CANCEL,
 	SIP_PUBLISH,
-} sip_method_list;
+};
 
 enum sip_auth_type {
 	PROXY_AUTH,
@@ -481,7 +481,7 @@
 static int allow_external_domains;	/*!< Accept calls to external SIP domains? */
 static int global_callevents;		/*!< Whether we send manager events or not */
 static int global_t1min;		/*!< T1 roundtrip time minimum */
-enum transfermodes global_allowtransfer;	/*! SIP Refer restriction scheme */
+static enum transfermodes global_allowtransfer;	/*!< SIP Refer restriction scheme */
 
 /*! \brief Codecs that we support by default: */
 static int global_capability = AST_FORMAT_ULAW | AST_FORMAT_ALAW | AST_FORMAT_GSM | AST_FORMAT_H263;

Modified: trunk/scx_jitterbuf.c
===================================================================
--- trunk/scx_jitterbuf.c	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/scx_jitterbuf.c	2006-06-01 14:25:36 UTC (rev 210)
@@ -1,351 +0,0 @@
-/*
- * scx_jitterbuf: jitterbuffering algorithm
- *
- * Copyright (C) 2005, Attractel OOD
- *
- * Contributors:
- * Slav Klenov <slav at securax.org>
- *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
- * See http://www.asterisk.org for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*! \file 
- * 
- * \brief Jitterbuffering algorithm.
- * 
- * \author Slav Klenov <slav at securax.org>
- */
-
-#include <stdio.h>
-#include <stdlib.h>
-#include <assert.h>
-#include <string.h>
-#include <unistd.h>
-
-#include "asterisk.h"
-ASTERISK_FILE_VERSION(__FILE__, "$Revision $")
-
-#include "asterisk/utils.h"
-#include "scx_jitterbuf.h"
-
-#undef SCX_JB_DEBUG
-
-#ifdef SCX_JB_DEBUG
-#define ASSERT(a)
-#else
-#define ASSERT(a) assert(a)
-#endif
-
-/*! \brief private scx_jb structure */
-struct scx_jb
-{
-	struct scx_jb_frame *frames;
-	struct scx_jb_frame *tail;
-	struct scx_jb_conf conf;
-	long rxcore;
-	long delay;
-	long next_delivery;
-	int force_resynch;
-};
-
-
-static struct scx_jb_frame *alloc_jb_frame(struct scx_jb *jb);
-static void release_jb_frame(struct scx_jb *jb, struct scx_jb_frame *frame);
-static void get_jb_head(struct scx_jb *jb, struct scx_jb_frame *frame);
-static int resynch_jb(struct scx_jb *jb, void *data, long ms, long ts, long now);
-
-static inline struct scx_jb_frame *alloc_jb_frame(struct scx_jb *jb)
-{
-	return ast_calloc(1, sizeof(struct scx_jb_frame));
-}
-
-static inline void release_jb_frame(struct scx_jb *jb, struct scx_jb_frame *frame)
-{
-	free(frame);
-}
-
-static void get_jb_head(struct scx_jb *jb, struct scx_jb_frame *frame)
-{
-	struct scx_jb_frame *fr;
-	
-	/* unlink the frame */
-	fr = jb->frames;
-	jb->frames = fr->next;
-	if (jb->frames) {
-		jb->frames->prev = NULL;
-	} else {
-		/* the jb is empty - update tail */
-		jb->tail = NULL;
-	}
-	
-	/* update next */
-	jb->next_delivery = fr->delivery + fr->ms;
-	
-	/* copy the destination */
-	memcpy(frame, fr, sizeof(struct scx_jb_frame));
-	
-	/* and release the frame */
-	release_jb_frame(jb, fr);
-}
-
-
-struct scx_jb *scx_jb_new(struct scx_jb_conf *conf)
-{
-	struct scx_jb *jb;
-	
-	if (!(jb = ast_calloc(1, sizeof(*jb))))
-		return NULL;
-	
-	/* First copy our config */
-	memcpy(&jb->conf, conf, sizeof(struct scx_jb_conf));
-
-	/* we dont need the passed config anymore - continue working with the saved one */
-	conf = &jb->conf;
-	
-	/* validate the configuration */
-	if (conf->jbsize < 1)
-		conf->jbsize = SCX_JB_SIZE_DEFAULT;
-
-	if (conf->resync_threshold < 1)
-		conf->resync_threshold = SCX_JB_RESYNCH_THRESHOLD_DEFAULT;
-	
-	/* Set the constant delay to the jitterbuf */
-	jb->delay = conf->jbsize;
-	
-	return jb;
-}
-
-
-void scx_jb_destroy(struct scx_jb *jb)
-{
-	/* jitterbuf MUST be empty before it can be destroyed */
-	ASSERT(jb->frames == NULL);
-	
-	free(jb);
-}
-
-
-static int resynch_jb(struct scx_jb *jb, void *data, long ms, long ts, long now)
-{
-	long diff, offset;
-	struct scx_jb_frame *frame;
-	
-	/* If jb is empty, just reinitialize the jb */
-	if (!jb->frames) {
-		/* debug check: tail should also be NULL */
-		ASSERT(jb->tail == NULL);
-		
-		return scx_jb_put_first(jb, data, ms, ts, now);
-	}
-	
-	/* Adjust all jb state just as the new frame is with delivery = the delivery of the last
-	   frame (e.g. this one with max delivery) + the length of the last frame. */
-	
-	/* Get the diff in timestamps */
-	diff = ts - jb->tail->ts;
-	
-	/* Ideally this should be just the length of the last frame. The deviation is the desired
-	   offset */
-	offset = diff - jb->tail->ms;
-	
-	/* Do we really need to resynch, or this is just a frame for dropping? */
-	if (!jb->force_resynch && (offset < jb->conf.resync_threshold && offset > -jb->conf.resync_threshold))
-		return SCX_JB_DROP;
-	
-	/* Reset the force resynch flag */
-	jb->force_resynch = 0;
-	
-	/* apply the offset to the jb state */
-	jb->rxcore -= offset;
-	frame = jb->frames;
-	while (frame) {
-		frame->ts += offset;
-		frame = frame->next;
-	}
-	
-	/* now jb_put() should add the frame at a last position */
-	return scx_jb_put(jb, data, ms, ts, now);
-}
-
-
-void scx_jb_set_force_resynch(struct scx_jb *jb)
-{
-	jb->force_resynch = 1;
-}
-
-
-int scx_jb_put_first(struct scx_jb *jb, void *data, long ms, long ts, long now)
-{
-	/* this is our first frame - set the base of the receivers time */
-	jb->rxcore = now - ts;
-	
-	/* init next for a first time - it should be the time the first frame should be played */
-	jb->next_delivery = now + jb->delay;
-	
-	/* put the frame */
-	return scx_jb_put(jb, data, ms, ts, now);
-}
-
-
-int scx_jb_put(struct scx_jb *jb, void *data, long ms, long ts, long now)
-{
-	struct scx_jb_frame *frame, *next, *newframe;
-	long delivery;
-	
-	/* debug check the validity of the input params */
-	ASSERT(data != NULL);
-	/* do not allow frames shorter than 2 ms */
-	ASSERT(ms >= 2);
-	ASSERT(ts >= 0);
-	ASSERT(now >= 0);
-	
-	delivery = jb->rxcore + jb->delay + ts;
-	
-	/* check if the new frame is not too late */
-	if (delivery < jb->next_delivery) {
-		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
-		   the force resynch flag was not set. */
-		return resynch_jb(jb, data, ms, ts, now);
-	}
-	
-	/* what if the delivery time is bigger than next + delay? Seems like a frame for the future.
-	   However, allow more resync_threshold ms in advance */
-	if (delivery > jb->next_delivery + jb->delay + jb->conf.resync_threshold) {
-		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
-		   the force resynch flag was not set. */
-		return resynch_jb(jb, data, ms, ts, now);
-	}
-
-	/* find the right place in the frames list, sorted by delivery time */
-	frame = jb->tail;
-	while (frame && frame->delivery > delivery) {
-		frame = frame->prev;
-	}
-	
-	/* Check if the new delivery time is not covered already by the chosen frame */
-	if (frame && (frame->delivery == delivery ||
-		         delivery < frame->delivery + frame->ms ||
-		         (frame->next && delivery + ms > frame->next->delivery)))
-	{
-		/* TODO: Should we check for resynch here? Be careful to do not allow threshold smaller than
-		   the size of the jb */
-		
-		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
-		   the force resynch flag was not set. */
-		return resynch_jb(jb, data, ms, ts, now);
-	}
-	
-	/* Reset the force resynch flag */
-	jb->force_resynch = 0;
-	
-	/* Get a new frame */
-	newframe = alloc_jb_frame(jb);
-	newframe->data = data;
-	newframe->ts = ts;
-	newframe->ms = ms;
-	newframe->delivery = delivery;
-	
-	/* and insert it right on place */
-	if (frame) {
-		next = frame->next;
-		frame->next = newframe;
-		if (next) {
-			newframe->next = next;
-			next->prev = newframe;
-		} else {
-			/* insert after the last frame - should update tail */
-			jb->tail = newframe;
-			newframe->next = NULL;
-		}
-		newframe->prev = frame;
-		
-		return SCX_JB_OK;
-	} else if (!jb->frames) {
-		/* the frame list is empty or thats just the first frame ever */
-		/* tail should also be NULL is that case */
-		ASSERT(jb->tail == NULL);
-		jb->frames = jb->tail = newframe;
-		newframe->next = NULL;
-		newframe->prev = NULL;
-		
-		return SCX_JB_OK;
-	} else {
-		/* insert on a first position - should update frames head */
-		newframe->next = jb->frames;
-		newframe->prev = NULL;
-		jb->frames->prev = newframe;
-		jb->frames = newframe;
-		
-		return SCX_JB_OK;
-	}
-}
-
-
-int scx_jb_get(struct scx_jb *jb, struct scx_jb_frame *frame, long now, long interpl)
-{
-	ASSERT(now >= 0);
-	ASSERT(interpl >= 2);
-	
-	if (now < jb->next_delivery) {
-		/* too early for the next frame */
-		return SCX_JB_NOFRAME;
-	}
-	
-	/* Is the jb empty? */
-	if (!jb->frames) {
-		/* should interpolate a frame */
-		/* update next */
-		jb->next_delivery += interpl;
-		
-		return SCX_JB_INTERP;
-	}
-	
-	/* Isn't it too late for the first frame available in the jb? */
-	if (now > jb->frames->delivery + jb->frames->ms) {
-		/* yes - should drop this frame and update next to point the next frame (get_jb_head() does it) */
-		get_jb_head(jb, frame);
-		
-		return SCX_JB_DROP;
-	}
-	
-	/* isn't it too early to play the first frame available? */
-	if (now < jb->frames->delivery) {
-		/* yes - should interpolate one frame */
-		/* update next */
-		jb->next_delivery += interpl;
-		
-		return SCX_JB_INTERP;
-	}
-	
-	/* we have a frame for playing now (get_jb_head() updates next) */
-	get_jb_head(jb, frame);
-	
-	return SCX_JB_OK;
-}
-
-
-long scx_jb_next(struct scx_jb *jb)
-{
-	return jb->next_delivery;
-}
-
-
-int scx_jb_remove(struct scx_jb *jb, struct scx_jb_frame *frameout)
-{
-	if (!jb->frames)
-		return SCX_JB_NOFRAME;
-	
-	get_jb_head(jb, frameout);
-	
-	return SCX_JB_OK;
-}

Modified: trunk/scx_jitterbuf.h
===================================================================
--- trunk/scx_jitterbuf.h	2006-06-01 13:25:44 UTC (rev 209)
+++ trunk/scx_jitterbuf.h	2006-06-01 14:25:36 UTC (rev 210)
@@ -1,95 +0,0 @@
-/*
- * scx_jitterbuf: jitterbuffering algorithm
- *
- * Copyright (C) 2005, Attractel OOD
- *
- * Contributors:
- * Slav Klenov <slav at securax.org>
- *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
- * See http://www.asterisk.org for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*! \file 
- * 
- * \brief Jitterbuffering algorithm.
- * 
- */
-
-#ifndef _SCX_JITTERBUF_H_
-#define _SCX_JITTERBUF_H_
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern "C" {
-#endif
-
-
-/* return codes */
-enum {
-	SCX_JB_OK,
-	SCX_JB_DROP,
-	SCX_JB_INTERP,
-	SCX_JB_NOFRAME
-};
-
-
-/* defaults */
-#define SCX_JB_SIZE_DEFAULT 200
-#define SCX_JB_RESYNCH_THRESHOLD_DEFAULT 1000
-
-
-/* jb configuration properties */
-struct scx_jb_conf
-{
-	long jbsize;
- 	long resync_threshold;
-};
-
-
-struct scx_jb_frame
-{
-	void *data;
-	long ts;
-	long ms;
-	long delivery;
-	struct scx_jb_frame *next;
-	struct scx_jb_frame *prev;
-};
-
-
-struct scx_jb;
-
-
-/* jb interface */
-
-struct scx_jb * scx_jb_new(struct scx_jb_conf *conf);
-
-void scx_jb_destroy(struct scx_jb *jb);
-
-int scx_jb_put_first(struct scx_jb *jb, void *data, long ms, long ts, long now);
-
-int scx_jb_put(struct scx_jb *jb, void *data, long ms, long ts, long now);
-
-int scx_jb_get(struct scx_jb *jb, struct scx_jb_frame *frame, long now, long interpl);
-
-long scx_jb_next(struct scx_jb *jb);
-
-int scx_jb_remove(struct scx_jb *jb, struct scx_jb_frame *frameout);
-
-void scx_jb_set_force_resynch(struct scx_jb *jb);
-
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-#endif /* _SCX_JITTERBUF_H_ */



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 17:26:11 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 17:26:11 +0200
Subject: [solid-pbx-svn] r211 - trunk
Message-ID: <200606011526.k51FQB5r018400@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 17:26:10 +0200 (Thu, 01 Jun 2006)
New Revision: 211

Modified:
   trunk/utils.c
Log:
Update to Asterisk SVN trunk r31384

------------------------------------------------------------------------
r31360 | russell | 2006-06-01 16:18:12 +0200 (Thu, 01 Jun 2006) | 2 lines

fix an incorrect comment (issue #7259, tardieu)

------------------------------------------------------------------------


Modified: trunk/utils.c
===================================================================
--- trunk/utils.c	2006-06-01 14:25:36 UTC (rev 210)
+++ trunk/utils.c	2006-06-01 15:26:10 UTC (rev 211)
@@ -70,7 +70,7 @@
 
 AST_MUTEX_DEFINE_STATIC(__mutex);
 
-/*! \brief Recursive replacement for gethostbyname for BSD-based systems.
+/*! \brief Reentrant replacement for gethostbyname for BSD-based systems.
 \note This
 routine is derived from code originally written and placed in the public 
 domain by Enzo Michelangeli <em at em.no-ip.com> */



From solid-pbx-svn-admin at lists.berlios.de  Thu Jun  1 18:25:26 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Thu, 1 Jun 2006 18:25:26 +0200
Subject: [solid-pbx-svn] r212 - trunk/channels
Message-ID: <200606011625.k51GPQAm024749@sheep.berlios.de>

Author: casper2
Date: 2006-06-01 18:25:25 +0200 (Thu, 01 Jun 2006)
New Revision: 212

Modified:
   trunk/channels/chan_skinny.c
Log:
Update to Asterisk SVN trunk r31407

------------------------------------------------------------------------
r31385 | north | 2006-06-01 17:44:35 +0200 (Thu, 01 Jun 2006) | 2 lines

This is what I get for coding while tired..  sorry ;/

------------------------------------------------------------------------


Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-01 15:26:10 UTC (rev 211)
+++ trunk/channels/chan_skinny.c	2006-06-01 16:25:25 UTC (rev 212)
@@ -3123,8 +3123,7 @@
 	v = ast_variable_browse(cfg, "general");
 	while(v) {
 		/* handle jb conf */
-		if (!ast_jb_read_conf(&global_jbconf, v->name, v->value))
-		{
+		if (!ast_jb_read_conf(&global_jbconf, v->name, v->value)) {
 			v = v->next;
 			continue;
 		}



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 04:47:47 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 04:47:47 +0200
Subject: [solid-pbx-svn] r213 - in trunk: . channels channels/misdn configs
Message-ID: <200606170247.k5H2llHn007749@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 04:46:45 +0200 (Sat, 17 Jun 2006)
New Revision: 213

Modified:
   trunk/.cleancount
   trunk/channels/chan_jingle.c
   trunk/channels/chan_mgcp.c
   trunk/channels/chan_oss.c
   trunk/channels/chan_sip.c
   trunk/channels/chan_skinny.c
   trunk/channels/chan_zap.c
   trunk/channels/misdn/isdn_lib.c
   trunk/channels/misdn/isdn_lib.h
   trunk/configs/alsa.conf.sample
   trunk/configs/mgcp.conf.sample
   trunk/configs/oss.conf.sample
   trunk/configs/sip.conf.sample
   trunk/configs/skinny.conf.sample
   trunk/configs/zapata.conf.sample
Log:
Update to Asterisk SVN trunk r31442

------------------------------------------------------------------------
r31409 | crichter | 2006-06-01 18:25:04 +0200 (Thu, 01 Jun 2006) | 1 line

unified the PH_CONTROL Interface for the mISDN_dsp interface to int
------------------------------------------------------------------------
r31411 | crichter | 2006-06-01 18:41:07 +0200 (Thu, 01 Jun 2006) | 1 line

the interface needs to be changed as well..
------------------------------------------------------------------------
r31412 | russell | 2006-06-01 18:42:38 +0200 (Thu, 01 Jun 2006) | 2 lines

my last changes to the jitterbuffer files need a forced make clean

------------------------------------------------------------------------
r31413 | russell | 2006-06-01 18:47:28 +0200 (Thu, 01 Jun 2006) | 8 lines

- add the ability to configure forced jitterbuffers on h323, jingle,
  and mgcp channels
- remove the jitterbuffer configuration from the pvt structures in
  the sip, zap, and skinny channel drivers, as copying the same global
  configuration into each pvt structure has no benefit.
- update and fix some typos in jitterbuffer related documentation
(issue #7257, north, with additional updates and modifications)

------------------------------------------------------------------------
r31414 | oej | 2006-06-01 18:58:06 +0200 (Thu, 01 Jun 2006) | 2 lines

Issue #7103 take two. Thanks Mikael!

------------------------------------------------------------------------


Modified: trunk/.cleancount
===================================================================
--- trunk/.cleancount	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/.cleancount	2006-06-17 02:46:45 UTC (rev 213)
@@ -1 +1 @@
-18
+19

Modified: trunk/channels/chan_jingle.c
===================================================================
--- trunk/channels/chan_jingle.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/chan_jingle.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -69,11 +69,22 @@
 #include "asterisk/utils.h"
 #include "asterisk/causes.h"
 #include "asterisk/astobj.h"
+#include "asterisk/abstract_jb.h"
 #include "asterisk/jabber.h"
 #include "asterisk/jingle.h"
 
 #define JINGLE_CONFIG "jingle.conf"
 
+/*! Global jitterbuffer configuration - by default, jb is disabled */
+static struct ast_jb_conf default_jbconf =
+{
+	.flags = 0,
+	.max_size = -1,
+	.resync_threshold = -1,
+	.impl = ""
+};
+static struct ast_jb_conf global_jbconf;
+
 enum jingle_protocol {
 	AJI_PROTOCOL_UDP = 1,
 	AJI_PROTOCOL_SSLTCP = 2,
@@ -773,6 +784,11 @@
 		ast_hangup(tmp);
 		tmp = NULL;
 	}
+
+	/* Configure the new channel jb */
+	if (tmp && i && i->rtp)
+		ast_jb_configure(tmp, &global_jbconf);
+
 	return tmp;
 }
 
@@ -1453,8 +1469,15 @@
 		return 0;
 	}
 
+	/* Copy the default jb config over global_jbconf */
+	memcpy(&global_jbconf, &default_jbconf, sizeof(struct ast_jb_conf));
+
 	cat = ast_category_browse(cfg, NULL);
 	for (var = ast_variable_browse(cfg, "general"); var; var = var->next) {
+		/* handle jb conf */
+		if (!ast_jb_read_conf(&global_jbconf, var->name, var->value))
+			continue;
+
 		if (!strcasecmp(var->name, "allowguest"))
 			allowguest =
 				(ast_true(ast_variable_retrieve(cfg, "general", "allowguest"))) ? 1 : 0;

Modified: trunk/channels/chan_mgcp.c
===================================================================
--- trunk/channels/chan_mgcp.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/chan_mgcp.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -117,6 +117,7 @@
 #include "asterisk/dsp.h"
 #include "asterisk/devicestate.h"
 #include "asterisk/stringfields.h"
+#include "asterisk/abstract_jb.h"
 
 #ifndef IPTOS_MINCOST
 #define IPTOS_MINCOST 0x02
@@ -137,6 +138,16 @@
 #define INADDR_NONE (in_addr_t)(-1)
 #endif
 
+/*! Global jitterbuffer configuration - by default, jb is disabled */
+static struct ast_jb_conf default_jbconf =
+{
+	.flags = 0,
+	.max_size = -1,
+	.resync_threshold = -1,
+	.impl = ""
+};
+static struct ast_jb_conf global_jbconf;
+
 static const char tdesc[] = "Media Gateway Control Protocol (MGCP)";
 static const char config[] = "mgcp.conf";
 
@@ -353,10 +364,6 @@
 			This should be obsoleted */
 	char cxident[80];
 	char callid[80];
-/* SC: obsolete
-	time_t lastouttime;
-	int lastout;
-*/
 	int cxmode;
 	struct mgcp_request *cx_queue; /*!< SC: pending CX commands */
 	ast_mutex_t cx_queue_lock;     /*!< SC: CX queue lock */
@@ -364,10 +371,6 @@
 	int iseq; /* Not used? RTP? */
 	int outgoing;
 	int alreadygone;
-/* SC: obsolete
-	int messagepending;
-	struct mgcp_message *msgs;
-*/
 	struct mgcp_subchannel *next; /* for out circular linked list */
 };
 
@@ -1499,6 +1502,10 @@
 			ast_verbose(VERBOSE_PREFIX_3 "MGCP mgcp_new(%s) created in state: %s\n",
 				tmp->name, ast_state2str(state));
 		}
+
+		/* Configure the new channel jb */
+		if (tmp && sub && sub->rtp)
+			ast_jb_configure(tmp, &global_jbconf);
 	} else {
 		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
 	}
@@ -4165,8 +4172,18 @@
 	}
 	memset(&bindaddr, 0, sizeof(bindaddr));
 	dtmfmode = 0;
+
+	/* Copy the default jb config over global_jbconf */
+	memcpy(&global_jbconf, &default_jbconf, sizeof(struct ast_jb_conf));
+
 	v = ast_variable_browse(cfg, "general");
-	while(v) {
+	while (v) {
+		/* handle jb conf */
+		if (!ast_jb_read_conf(&global_jbconf, v->name, v->value)) {
+			v = v->next;
+			continue;
+		}
+
 		/* Create the interface list */
 		if (!strcasecmp(v->name, "bindaddr")) {
 			if (!(hp = ast_gethostbyname(v->value, &ahp))) {

Modified: trunk/channels/chan_oss.c
===================================================================
--- trunk/channels/chan_oss.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/chan_oss.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -156,14 +156,10 @@
     ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of an
                                   ; OSS channel. Defaults to "no". An enabled jitterbuffer will
                                   ; be used only if the sending side can create and the receiving
-                                  ; side can not accept jitter. The ZAP channel can't accept jitter,
-                                  ; thus an enabled jitterbuffer on the receive ZAP side will always
-                                  ; be used if the sending side can create jitter or if ZAP jb is
-                                  ; forced.
+                                  ; side can not accept jitter. The OSS channel can't accept jitter,
+                                  ; thus an enabled jitterbuffer on the receive OSS side will always
+                                  ; be used if the sending side can create jitter.
 
-    ; jbforce = no                ; Forces the use of a jitterbuffer on the receive side of a ZAP
-                                  ; channel. Defaults to "no".
-
     ; jbmaxsize = 200             ; Max length of the jitterbuffer in milliseconds.
 
     ; jbresyncthreshold = 1000    ; Jump in the frame timestamps over which the jitterbuffer is
@@ -171,8 +167,8 @@
                                   ; big jumps in/broken timestamps, usualy sent from exotic devices
                                   ; and programs. Defaults to 1000.
 
-    ; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a SIP
-                                  ; channel. Two implementation are currenlty available - "fixed"
+    ; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of an OSS
+                                  ; channel. Two implementations are currenlty available - "fixed"
                                   ; (with size always equals to jbmax-size) and "adaptive" (with
                                   ; variable size, actually the new jb of IAX2). Defaults to fixed.
 

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/chan_sip.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -857,7 +857,6 @@
 	struct ast_variable *chanvars;		/*!< Channel variables to set for inbound call */
 	struct sip_pvt *next;			/*!< Next dialog in chain */
 	struct sip_invite_param *options;	/*!< Options for INVITE */
-	struct ast_jb_conf jbconf;
 } *iflist = NULL;
 
 #define FLAG_RESPONSE (1 << 0)
@@ -1367,7 +1366,7 @@
 	unsigned int profile = 0;
 	int i, found;
 
-	if (!pvt || ast_strlen_zero(supported) )
+	if (ast_strlen_zero(supported) )
 		return 0;
 
 	if (option_debug > 2 && sipdebug)
@@ -1393,7 +1392,8 @@
 			ast_log(LOG_DEBUG, "Found no match for SIP option: %s (Please file bug report!)\n", next);
 	}
 
-	pvt->sipoptions = profile;
+	if (pvt)
+		pvt->sipoptions = profile;
 	return profile;
 }
 
@@ -3357,7 +3357,7 @@
 
 	/* Configure the new channel jb */
 	if (tmp && i && i->rtp)
-		ast_jb_configure(tmp, &i->jbconf);
+		ast_jb_configure(tmp, &global_jbconf);
 
 	return tmp;
 }
@@ -3693,9 +3693,6 @@
 		p->noncodeccapability |= AST_RTP_DTMF;
 	ast_string_field_set(p, context, default_context);
 
-	/* Assign default jb conf to the new sip_pvt */
-	memcpy(&p->jbconf, &global_jbconf, sizeof(struct ast_jb_conf));
-
 	/* Add to active dialog list */
 	ast_mutex_lock(&iflock);
 	p->next = iflist;

Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/chan_skinny.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -826,8 +826,6 @@
 	int nat;
 	int outgoing;
 	int alreadygone;
-	struct ast_jb_conf jbconf;
-
 	struct skinny_subchannel *next;
 };
 
@@ -1615,10 +1613,6 @@
 							callnums++;
 							sub->cxmode = SKINNY_CX_INACTIVE;
 							sub->nat = nat;
-
-							/* Assign default jb conf to the new skinny_subchannel */
-							memcpy(&sub->jbconf, &global_jbconf, sizeof(struct ast_jb_conf));
-
 							sub->next = l->sub;
 							l->sub = sub;
 						} else {
@@ -2311,7 +2305,7 @@
 
 		/* Configure the new channel jb */
 		if (tmp && sub && sub->rtp)
-			ast_jb_configure(tmp, &sub->jbconf);
+			ast_jb_configure(tmp, &global_jbconf);
 	} else {
 		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
 	}
@@ -3121,7 +3115,7 @@
 
 	/* load the general section */
 	v = ast_variable_browse(cfg, "general");
-	while(v) {
+	while (v) {
 		/* handle jb conf */
 		if (!ast_jb_read_conf(&global_jbconf, v->name, v->value)) {
 			v = v->next;

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/chan_zap.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -698,8 +698,6 @@
 #endif	
 	int polarity;
 	int dsp_features;
-	struct ast_jb_conf jbconf;
-
 } *iflist = NULL, *ifend = NULL;
 
 static struct ast_channel *zt_request(const char *type, int format, void *data, int *cause);
@@ -5215,7 +5213,7 @@
 		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
 	/* Configure the new channel jb */
 	if (tmp && i)
-		ast_jb_configure(tmp, &i->jbconf);
+		ast_jb_configure(tmp, &global_jbconf);
 	return tmp;
 }
 
@@ -7011,8 +7009,6 @@
 		for (x = 0; x < 3; x++)
 			tmp->subs[x].zfd = -1;
 		tmp->channel = channel;
-		/* Assign default jb conf to the new zt_pvt */
-		memcpy(&tmp->jbconf, &global_jbconf, sizeof(struct ast_jb_conf));
 	}
 
 	if (tmp) {

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-17 02:46:45 UTC (rev 213)
@@ -166,7 +166,7 @@
 void te_lib_destroy(int midev) ;
 struct misdn_bchannel *manager_find_bc_by_pid(int pid);
 struct misdn_bchannel *manager_find_bc_holded(struct misdn_bchannel* bc);
-void manager_ph_control_block(struct misdn_bchannel *bc, long c1, void *c2, int c2_len);
+void manager_ph_control_block(struct misdn_bchannel *bc, int c1, void *c2, int c2_len);
 void manager_clean_bc(struct misdn_bchannel *bc );
 void manager_bchannel_setup (struct misdn_bchannel *bc);
 void manager_bchannel_cleanup (struct misdn_bchannel *bc);
@@ -3677,17 +3677,17 @@
 /*
  * send control information to the channel (dsp-module)
  */
-void manager_ph_control(struct misdn_bchannel *bc, long c1, long c2)
+void manager_ph_control(struct misdn_bchannel *bc, int c1, int c2)
 {
-	unsigned char buffer[mISDN_HEADER_LEN+2*sizeof(long)];
+	unsigned char buffer[mISDN_HEADER_LEN+2*sizeof(int)];
 	iframe_t *ctrl = (iframe_t *)buffer; /* preload data */
-	unsigned long *d = (unsigned long *)&ctrl->data.p;
+	unsigned int *d = (unsigned int*)&ctrl->data.p;
 	struct misdn_stack *stack=get_stack_by_bc(bc);
 	
 	ctrl->prim = PH_CONTROL | REQUEST;
 	ctrl->addr = bc->addr | FLG_MSG_DOWN;
 	ctrl->dinfo = 0;
-	ctrl->len = sizeof(unsigned long)*2;
+	ctrl->len = sizeof(unsigned int)*2;
 	*d++ = c1;
 	*d++ = c2;
 	mISDN_write(stack->midev, ctrl, mISDN_HEADER_LEN+ctrl->len, TIMEOUT_1SEC);
@@ -3696,17 +3696,17 @@
 /*
  * send control information to the channel (dsp-module)
  */
-void manager_ph_control_block(struct misdn_bchannel *bc, long c1, void *c2, int c2_len)
+void manager_ph_control_block(struct misdn_bchannel *bc, int c1, void *c2, int c2_len)
 {
-	unsigned char buffer[mISDN_HEADER_LEN+sizeof(long)+c2_len];
+	unsigned char buffer[mISDN_HEADER_LEN+sizeof(int)+c2_len];
 	iframe_t *ctrl = (iframe_t *)buffer;
-	unsigned long *d = (unsigned long *)&ctrl->data.p;
+	unsigned int *d = (unsigned int *)&ctrl->data.p;
 	struct misdn_stack *stack=get_stack_by_bc(bc);
 	
 	ctrl->prim = PH_CONTROL | REQUEST;
 	ctrl->addr = bc->addr | FLG_MSG_DOWN;
 	ctrl->dinfo = 0;
-	ctrl->len = sizeof(unsigned long) + c2_len;
+	ctrl->len = sizeof(unsigned int) + c2_len;
 	*d++ = c1;
 	memcpy(d, c2, c2_len);
 	mISDN_write(stack->midev, ctrl, mISDN_HEADER_LEN+ctrl->len, TIMEOUT_1SEC);

Modified: trunk/channels/misdn/isdn_lib.h
===================================================================
--- trunk/channels/misdn/isdn_lib.h	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/channels/misdn/isdn_lib.h	2006-06-17 02:46:45 UTC (rev 213)
@@ -350,7 +350,7 @@
 
 int misdn_lib_tx2misdn_frm(struct misdn_bchannel *bc, void *data, int len);
 
-void manager_ph_control(struct misdn_bchannel *bc, long c1, long c2);
+void manager_ph_control(struct misdn_bchannel *bc, int c1, int c2);
 
 
 int misdn_lib_port_restart(int port);

Modified: trunk/configs/alsa.conf.sample
===================================================================
--- trunk/configs/alsa.conf.sample	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/configs/alsa.conf.sample	2006-06-17 02:46:45 UTC (rev 213)
@@ -34,14 +34,10 @@
 ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of an
                               ; ALSA channel. Defaults to "no". An enabled jitterbuffer will
                               ; be used only if the sending side can create and the receiving
-                              ; side can not accept jitter. The ZAP channel can't accept jitter,
-                              ; thus an enabled jitterbuffer on the receive ZAP side will always
-                              ; be used if the sending side can create jitter or if ZAP jb is
-                              ; forced.
+                              ; side can not accept jitter. The ALSA channel can't accept jitter,
+                              ; thus an enabled jitterbuffer on the receive ALSA side will always
+                              ; be used if the sending side can create jitter.
 
-; jbforce = no                ; Forces the use of a jitterbuffer on the receive side of a ZAP
-                              ; channel. Defaults to "no".
-
 ; jbmaxsize = 200             ; Max length of the jitterbuffer in milliseconds.
 
 ; jbresyncthreshold = 1000    ; Jump in the frame timestamps over which the jitterbuffer is

Modified: trunk/configs/mgcp.conf.sample
===================================================================
--- trunk/configs/mgcp.conf.sample	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/configs/mgcp.conf.sample	2006-06-17 02:46:45 UTC (rev 213)
@@ -5,6 +5,33 @@
 ;port = 2427
 ;bindaddr = 0.0.0.0
 
+;------------------------------ JITTER BUFFER CONFIGURATION --------------------------
+; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of a
+                              ; MGCP channel. Defaults to "no". An enabled jitterbuffer will
+                              ; be used only if the sending side can create and the receiving
+                              ; side can not accept jitter. The MGCP channel can accept jitter,
+                              ; thus an enabled jitterbuffer on the receive MGCP side will only
+                              ; be used if the sending side can create jitter and jbforce is
+                              ; also set to yes.
+
+; jbforce = no                ; Forces the use of a jitterbuffer on the receive side of a MGCP
+                              ; channel. Defaults to "no".
+
+; jbmaxsize = 200             ; Max length of the jitterbuffer in milliseconds.
+
+; jbresyncthreshold = 1000    ; Jump in the frame timestamps over which the jitterbuffer is
+                              ; resynchronized. Useful to improve the quality of the voice, with
+                              ; big jumps in/broken timestamps, usualy sent from exotic devices
+                              ; and programs. Defaults to 1000.
+
+; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a MGCP
+                              ; channel. Two implementations are currenlty available - "fixed"
+                              ; (with size always equals to jbmax-size) and "adaptive" (with
+                              ; variable size, actually the new jb of IAX2). Defaults to fixed.
+
+; jblog = no                  ; Enables jitterbuffer frame logging. Defaults to "no".
+;-----------------------------------------------------------------------------------
+
 ;[dlinkgw]
 ;host = 192.168.0.64
 ;context = default

Modified: trunk/configs/oss.conf.sample
===================================================================
--- trunk/configs/oss.conf.sample	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/configs/oss.conf.sample	2006-06-17 02:46:45 UTC (rev 213)
@@ -50,14 +50,10 @@
     ; jbenable = yes              ; Enables the use of a jitterbuffer on the receiving side of an
                                   ; OSS channel. Defaults to "no". An enabled jitterbuffer will
                                   ; be used only if the sending side can create and the receiving
-                                  ; side can not accept jitter. The ZAP channel can't accept jitter,
-                                  ; thus an enabled jitterbuffer on the receive ZAP side will always
-                                  ; be used if the sending side can create jitter or if ZAP jb is
-                                  ; forced.
+                                  ; side can not accept jitter. The OSS channel can't accept jitter,
+                                  ; thus an enabled jitterbuffer on the receive OSS side will always
+                                  ; be used if the sending side can create jitter.
 
-    ; jbforce = no                ; Forces the use of a jitterbuffer on the receive side of a ZAP
-                                  ; channel. Defaults to "no".
-
     ; jbmaxsize = 200             ; Max length of the jitterbuffer in milliseconds.
 
     ; jbresyncthreshold = 1000    ; Jump in the frame timestamps over which the jitterbuffer is
@@ -65,8 +61,8 @@
                                   ; big jumps in/broken timestamps, usualy sent from exotic devices
                                   ; and programs. Defaults to 1000.
 
-    ; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a SIP
-                                  ; channel. Two implementation are currenlty available - "fixed"
+    ; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of an OSS
+                                  ; channel. Two implementations are currenlty available - "fixed"
                                   ; (with size always equals to jbmax-size) and "adaptive" (with
                                   ; variable size, actually the new jb of IAX2). Defaults to fixed.
 

Modified: trunk/configs/sip.conf.sample
===================================================================
--- trunk/configs/sip.conf.sample	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/configs/sip.conf.sample	2006-06-17 02:46:45 UTC (rev 213)
@@ -321,7 +321,7 @@
                               ; and programs. Defaults to 1000.
 
 ; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a SIP
-                              ; channel. Two implementation are currenlty available - "fixed"
+                              ; channel. Two implementations are currenlty available - "fixed"
                               ; (with size always equals to jbmaxsize) and "adaptive" (with
                               ; variable size, actually the new jb of IAX2). Defaults to fixed.
 

Modified: trunk/configs/skinny.conf.sample
===================================================================
--- trunk/configs/skinny.conf.sample	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/configs/skinny.conf.sample	2006-06-17 02:46:45 UTC (rev 213)
@@ -29,7 +29,7 @@
                              ; and programs. Defaults to 1000.
 
 ;jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a
-                             ; skinny channel. Two implementation are currently available
+                             ; skinny channel. Two implementations are currently available
                              ; - "fixed" (with size always equals to jbmaxsize)
                              ; - "adaptive" (with variable size, actually the new jb of IAX2).
                              ; Defaults to fixed.

Modified: trunk/configs/zapata.conf.sample
===================================================================
--- trunk/configs/zapata.conf.sample	2006-06-01 16:25:25 UTC (rev 212)
+++ trunk/configs/zapata.conf.sample	2006-06-17 02:46:45 UTC (rev 213)
@@ -501,12 +501,8 @@
                               ; be used only if the sending side can create and the receiving
                               ; side can not accept jitter. The ZAP channel can't accept jitter,
                               ; thus an enabled jitterbuffer on the receive ZAP side will always
-                              ; be used if the sending side can create jitter or if ZAP jb is
-                              ; forced.
+                              ; be used if the sending side can create jitter.
 
-; jbforce = no                ; Forces the use of a jitterbuffer on the receive side of a ZAP
-                              ; channel. Defaults to "no".
-
 ; jbmaxsize = 200             ; Max length of the jitterbuffer in milliseconds.
 
 ; jbresyncthreshold = 1000    ; Jump in the frame timestamps over which the jitterbuffer is
@@ -514,8 +510,8 @@
                               ; big jumps in/broken timestamps, usualy sent from exotic devices
                               ; and programs. Defaults to 1000.
 
-; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a SIP
-                              ; channel. Two implementation are currenlty available - "fixed"
+; jbimpl = fixed              ; Jitterbuffer implementation, used on the receiving side of a ZAP
+                              ; channel. Two implementations are currenlty available - "fixed"
                               ; (with size always equals to jbmax-size) and "adaptive" (with
                               ; variable size, actually the new jb of IAX2). Defaults to fixed.
 



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 04:52:30 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 04:52:30 +0200
Subject: [solid-pbx-svn] r214 - trunk
Message-ID: <200606170252.k5H2qUfE009095@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 04:52:28 +0200 (Sat, 17 Jun 2006)
New Revision: 214

Added:
   trunk/fixedjitterbuf.c
   trunk/fixedjitterbuf.h
Log:
Add missing files

Added: trunk/fixedjitterbuf.c
===================================================================
--- trunk/fixedjitterbuf.c	2006-06-17 02:46:45 UTC (rev 213)
+++ trunk/fixedjitterbuf.c	2006-06-17 02:52:28 UTC (rev 214)
@@ -0,0 +1,349 @@
+/*
+ * Copyright (C) 2005, Attractel OOD
+ *
+ * Contributors:
+ * Slav Klenov <slav at securax.org>
+ *
+ * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file 
+ * 
+ * \brief Jitterbuffering algorithm.
+ * 
+ * \author Slav Klenov <slav at securax.org>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <assert.h>
+#include <string.h>
+#include <unistd.h>
+
+#include "asterisk.h"
+ASTERISK_FILE_VERSION(__FILE__, "$Revision $")
+
+#include "asterisk/utils.h"
+#include "fixedjitterbuf.h"
+
+#undef FIXED_JB_DEBUG
+
+#ifdef FIXED_JB_DEBUG
+#define ASSERT(a)
+#else
+#define ASSERT(a) assert(a)
+#endif
+
+/*! \brief private fixed_jb structure */
+struct fixed_jb
+{
+	struct fixed_jb_frame *frames;
+	struct fixed_jb_frame *tail;
+	struct fixed_jb_conf conf;
+	long rxcore;
+	long delay;
+	long next_delivery;
+	int force_resynch;
+};
+
+
+static struct fixed_jb_frame *alloc_jb_frame(struct fixed_jb *jb);
+static void release_jb_frame(struct fixed_jb *jb, struct fixed_jb_frame *frame);
+static void get_jb_head(struct fixed_jb *jb, struct fixed_jb_frame *frame);
+static int resynch_jb(struct fixed_jb *jb, void *data, long ms, long ts, long now);
+
+static inline struct fixed_jb_frame *alloc_jb_frame(struct fixed_jb *jb)
+{
+	return ast_calloc(1, sizeof(struct fixed_jb_frame));
+}
+
+static inline void release_jb_frame(struct fixed_jb *jb, struct fixed_jb_frame *frame)
+{
+	free(frame);
+}
+
+static void get_jb_head(struct fixed_jb *jb, struct fixed_jb_frame *frame)
+{
+	struct fixed_jb_frame *fr;
+	
+	/* unlink the frame */
+	fr = jb->frames;
+	jb->frames = fr->next;
+	if (jb->frames) {
+		jb->frames->prev = NULL;
+	} else {
+		/* the jb is empty - update tail */
+		jb->tail = NULL;
+	}
+	
+	/* update next */
+	jb->next_delivery = fr->delivery + fr->ms;
+	
+	/* copy the destination */
+	memcpy(frame, fr, sizeof(struct fixed_jb_frame));
+	
+	/* and release the frame */
+	release_jb_frame(jb, fr);
+}
+
+
+struct fixed_jb *fixed_jb_new(struct fixed_jb_conf *conf)
+{
+	struct fixed_jb *jb;
+	
+	if (!(jb = ast_calloc(1, sizeof(*jb))))
+		return NULL;
+	
+	/* First copy our config */
+	memcpy(&jb->conf, conf, sizeof(struct fixed_jb_conf));
+
+	/* we dont need the passed config anymore - continue working with the saved one */
+	conf = &jb->conf;
+	
+	/* validate the configuration */
+	if (conf->jbsize < 1)
+		conf->jbsize = FIXED_JB_SIZE_DEFAULT;
+
+	if (conf->resync_threshold < 1)
+		conf->resync_threshold = FIXED_JB_RESYNCH_THRESHOLD_DEFAULT;
+	
+	/* Set the constant delay to the jitterbuf */
+	jb->delay = conf->jbsize;
+	
+	return jb;
+}
+
+
+void fixed_jb_destroy(struct fixed_jb *jb)
+{
+	/* jitterbuf MUST be empty before it can be destroyed */
+	ASSERT(jb->frames == NULL);
+	
+	free(jb);
+}
+
+
+static int resynch_jb(struct fixed_jb *jb, void *data, long ms, long ts, long now)
+{
+	long diff, offset;
+	struct fixed_jb_frame *frame;
+	
+	/* If jb is empty, just reinitialize the jb */
+	if (!jb->frames) {
+		/* debug check: tail should also be NULL */
+		ASSERT(jb->tail == NULL);
+		
+		return fixed_jb_put_first(jb, data, ms, ts, now);
+	}
+	
+	/* Adjust all jb state just as the new frame is with delivery = the delivery of the last
+	   frame (e.g. this one with max delivery) + the length of the last frame. */
+	
+	/* Get the diff in timestamps */
+	diff = ts - jb->tail->ts;
+	
+	/* Ideally this should be just the length of the last frame. The deviation is the desired
+	   offset */
+	offset = diff - jb->tail->ms;
+	
+	/* Do we really need to resynch, or this is just a frame for dropping? */
+	if (!jb->force_resynch && (offset < jb->conf.resync_threshold && offset > -jb->conf.resync_threshold))
+		return FIXED_JB_DROP;
+	
+	/* Reset the force resynch flag */
+	jb->force_resynch = 0;
+	
+	/* apply the offset to the jb state */
+	jb->rxcore -= offset;
+	frame = jb->frames;
+	while (frame) {
+		frame->ts += offset;
+		frame = frame->next;
+	}
+	
+	/* now jb_put() should add the frame at a last position */
+	return fixed_jb_put(jb, data, ms, ts, now);
+}
+
+
+void fixed_jb_set_force_resynch(struct fixed_jb *jb)
+{
+	jb->force_resynch = 1;
+}
+
+
+int fixed_jb_put_first(struct fixed_jb *jb, void *data, long ms, long ts, long now)
+{
+	/* this is our first frame - set the base of the receivers time */
+	jb->rxcore = now - ts;
+	
+	/* init next for a first time - it should be the time the first frame should be played */
+	jb->next_delivery = now + jb->delay;
+	
+	/* put the frame */
+	return fixed_jb_put(jb, data, ms, ts, now);
+}
+
+
+int fixed_jb_put(struct fixed_jb *jb, void *data, long ms, long ts, long now)
+{
+	struct fixed_jb_frame *frame, *next, *newframe;
+	long delivery;
+	
+	/* debug check the validity of the input params */
+	ASSERT(data != NULL);
+	/* do not allow frames shorter than 2 ms */
+	ASSERT(ms >= 2);
+	ASSERT(ts >= 0);
+	ASSERT(now >= 0);
+	
+	delivery = jb->rxcore + jb->delay + ts;
+	
+	/* check if the new frame is not too late */
+	if (delivery < jb->next_delivery) {
+		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
+		   the force resynch flag was not set. */
+		return resynch_jb(jb, data, ms, ts, now);
+	}
+	
+	/* what if the delivery time is bigger than next + delay? Seems like a frame for the future.
+	   However, allow more resync_threshold ms in advance */
+	if (delivery > jb->next_delivery + jb->delay + jb->conf.resync_threshold) {
+		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
+		   the force resynch flag was not set. */
+		return resynch_jb(jb, data, ms, ts, now);
+	}
+
+	/* find the right place in the frames list, sorted by delivery time */
+	frame = jb->tail;
+	while (frame && frame->delivery > delivery) {
+		frame = frame->prev;
+	}
+	
+	/* Check if the new delivery time is not covered already by the chosen frame */
+	if (frame && (frame->delivery == delivery ||
+		         delivery < frame->delivery + frame->ms ||
+		         (frame->next && delivery + ms > frame->next->delivery)))
+	{
+		/* TODO: Should we check for resynch here? Be careful to do not allow threshold smaller than
+		   the size of the jb */
+		
+		/* should drop the frame, but let first resynch_jb() check if this is not a jump in ts, or
+		   the force resynch flag was not set. */
+		return resynch_jb(jb, data, ms, ts, now);
+	}
+	
+	/* Reset the force resynch flag */
+	jb->force_resynch = 0;
+	
+	/* Get a new frame */
+	newframe = alloc_jb_frame(jb);
+	newframe->data = data;
+	newframe->ts = ts;
+	newframe->ms = ms;
+	newframe->delivery = delivery;
+	
+	/* and insert it right on place */
+	if (frame) {
+		next = frame->next;
+		frame->next = newframe;
+		if (next) {
+			newframe->next = next;
+			next->prev = newframe;
+		} else {
+			/* insert after the last frame - should update tail */
+			jb->tail = newframe;
+			newframe->next = NULL;
+		}
+		newframe->prev = frame;
+		
+		return FIXED_JB_OK;
+	} else if (!jb->frames) {
+		/* the frame list is empty or thats just the first frame ever */
+		/* tail should also be NULL is that case */
+		ASSERT(jb->tail == NULL);
+		jb->frames = jb->tail = newframe;
+		newframe->next = NULL;
+		newframe->prev = NULL;
+		
+		return FIXED_JB_OK;
+	} else {
+		/* insert on a first position - should update frames head */
+		newframe->next = jb->frames;
+		newframe->prev = NULL;
+		jb->frames->prev = newframe;
+		jb->frames = newframe;
+		
+		return FIXED_JB_OK;
+	}
+}
+
+
+int fixed_jb_get(struct fixed_jb *jb, struct fixed_jb_frame *frame, long now, long interpl)
+{
+	ASSERT(now >= 0);
+	ASSERT(interpl >= 2);
+	
+	if (now < jb->next_delivery) {
+		/* too early for the next frame */
+		return FIXED_JB_NOFRAME;
+	}
+	
+	/* Is the jb empty? */
+	if (!jb->frames) {
+		/* should interpolate a frame */
+		/* update next */
+		jb->next_delivery += interpl;
+		
+		return FIXED_JB_INTERP;
+	}
+	
+	/* Isn't it too late for the first frame available in the jb? */
+	if (now > jb->frames->delivery + jb->frames->ms) {
+		/* yes - should drop this frame and update next to point the next frame (get_jb_head() does it) */
+		get_jb_head(jb, frame);
+		
+		return FIXED_JB_DROP;
+	}
+	
+	/* isn't it too early to play the first frame available? */
+	if (now < jb->frames->delivery) {
+		/* yes - should interpolate one frame */
+		/* update next */
+		jb->next_delivery += interpl;
+		
+		return FIXED_JB_INTERP;
+	}
+	
+	/* we have a frame for playing now (get_jb_head() updates next) */
+	get_jb_head(jb, frame);
+	
+	return FIXED_JB_OK;
+}
+
+
+long fixed_jb_next(struct fixed_jb *jb)
+{
+	return jb->next_delivery;
+}
+
+
+int fixed_jb_remove(struct fixed_jb *jb, struct fixed_jb_frame *frameout)
+{
+	if (!jb->frames)
+		return FIXED_JB_NOFRAME;
+	
+	get_jb_head(jb, frameout);
+	
+	return FIXED_JB_OK;
+}

Added: trunk/fixedjitterbuf.h
===================================================================
--- trunk/fixedjitterbuf.h	2006-06-17 02:46:45 UTC (rev 213)
+++ trunk/fixedjitterbuf.h	2006-06-17 02:52:28 UTC (rev 214)
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2005, Attractel OOD
+ *
+ * Contributors:
+ * Slav Klenov <slav at securax.org>
+ *
+ * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
+ */
+
+/*! \file 
+ * 
+ * \brief Jitterbuffering algorithm.
+ * 
+ */
+
+#ifndef _FIXEDJITTERBUF_H_
+#define _FIXEDJITTERBUF_H_
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+
+/* return codes */
+enum {
+	FIXED_JB_OK,
+	FIXED_JB_DROP,
+	FIXED_JB_INTERP,
+	FIXED_JB_NOFRAME
+};
+
+
+/* defaults */
+#define FIXED_JB_SIZE_DEFAULT 200
+#define FIXED_JB_RESYNCH_THRESHOLD_DEFAULT 1000
+
+
+/* jb configuration properties */
+struct fixed_jb_conf
+{
+	long jbsize;
+ 	long resync_threshold;
+};
+
+
+struct fixed_jb_frame
+{
+	void *data;
+	long ts;
+	long ms;
+	long delivery;
+	struct fixed_jb_frame *next;
+	struct fixed_jb_frame *prev;
+};
+
+
+struct fixed_jb;
+
+
+/* jb interface */
+
+struct fixed_jb * fixed_jb_new(struct fixed_jb_conf *conf);
+
+void fixed_jb_destroy(struct fixed_jb *jb);
+
+int fixed_jb_put_first(struct fixed_jb *jb, void *data, long ms, long ts, long now);
+
+int fixed_jb_put(struct fixed_jb *jb, void *data, long ms, long ts, long now);
+
+int fixed_jb_get(struct fixed_jb *jb, struct fixed_jb_frame *frame, long now, long interpl);
+
+long fixed_jb_next(struct fixed_jb *jb);
+
+int fixed_jb_remove(struct fixed_jb *jb, struct fixed_jb_frame *frameout);
+
+void fixed_jb_set_force_resynch(struct fixed_jb *jb);
+
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif /* _FIXEDJITTERBUF_H_ */



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 04:55:03 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 04:55:03 +0200
Subject: [solid-pbx-svn] r215 - in trunk: . sounds
Message-ID: <200606170255.k5H2t38Y009446@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 04:54:58 +0200 (Sat, 17 Jun 2006)
New Revision: 215

Added:
   trunk/sounds/
   trunk/sounds/dictate/
   trunk/sounds/digits/
   trunk/sounds/letters/
   trunk/sounds/phonetic/
Removed:
   trunk/sounds/
Log:
Remove sounds - they do not live in the tree anymore



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 04:58:12 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 04:58:12 +0200
Subject: [solid-pbx-svn] r216 - trunk/sounds
Message-ID: <200606170258.k5H2wCP0010193@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 04:58:08 +0200 (Sat, 17 Jun 2006)
New Revision: 216

Removed:
   trunk/sounds/dictate/
   trunk/sounds/digits/
   trunk/sounds/letters/
   trunk/sounds/phonetic/
Log:
Remove subdirs in sounds



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 05:25:56 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 05:25:56 +0200
Subject: [solid-pbx-svn] r217 - trunk/build_tools
Message-ID: <200606170325.k5H3PunT017554@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 05:25:53 +0200 (Sat, 17 Jun 2006)
New Revision: 217

Modified:
   trunk/build_tools/menuselect.c
   trunk/build_tools/menuselect.h
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r31443

------------------------------------------------------------------------
r31443 | russell | 2006-06-01 19:40:50 +0200 (Thu, 01 Jun 2006) | 2 lines

allow menuselect to display dependencies and conflicts for modules

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-17 02:58:08 UTC (rev 216)
+++ trunk/build_tools/menuselect.c	2006-06-17 03:25:53 UTC (rev 217)
@@ -40,20 +40,6 @@
 
 #undef MENUSELECT_DEBUG
 
-struct depend {
-	/*! the name of the dependency */
-	const char *name;
-	/*! for linking */
-	AST_LIST_ENTRY(depend) list;
-};
-
-struct conflict {
-	/*! the name of the conflict */
-	const char *name;
-	/*! for linking */
-	AST_LIST_ENTRY(conflict) list;
-};
-
 /*! The list of categories */
 struct categories categories = AST_LIST_HEAD_NOLOCK_INIT_VALUE;
 

Modified: trunk/build_tools/menuselect.h
===================================================================
--- trunk/build_tools/menuselect.h	2006-06-17 02:58:08 UTC (rev 216)
+++ trunk/build_tools/menuselect.h	2006-06-17 03:25:53 UTC (rev 217)
@@ -31,9 +31,20 @@
 #define OUTPUT_MAKEOPTS_DEFAULT "menuselect.makeopts"
 #define MENUSELECT_DEPS         "build_tools/menuselect-deps"
 
-struct depend;
-struct conflict;
+struct depend {
+	/*! the name of the dependency */
+	const char *name;
+	/*! for linking */
+	AST_LIST_ENTRY(depend) list;
+};
 
+struct conflict {
+	/*! the name of the conflict */
+	const char *name;
+	/*! for linking */
+	AST_LIST_ENTRY(conflict) list;
+};
+
 struct member {
 	/*! What will be sent to the makeopts file */
 	const char *name;

Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-17 02:58:08 UTC (rev 216)
+++ trunk/build_tools/menuselect_curses.c	2006-06-17 03:25:53 UTC (rev 217)
@@ -126,7 +126,9 @@
 {
 	int i = 0;
 	int j = 0;
-	struct member *mem;
+	struct member *mem, *curmem = NULL;
+	struct depend *dep;
+	struct conflict *con;
 	char buf[64];
 	const char *desc = NULL;
 
@@ -146,16 +148,36 @@
 		waddstr(menu, buf);
 		
 		if (curopt + 1 == i)
-			desc = mem->displayname;
+			curmem = mem;
 
 		if (i == end)
 			break;
 	}
 
-	if (desc) {
+	if (curmem->displayname) {
 		wmove(menu, end - start + 2, max_x / 2 - 16);
-		waddstr(menu, desc);
+		waddstr(menu, curmem->displayname);
 	}
+	if (!AST_LIST_EMPTY(&curmem->deps)) {
+		wmove(menu, end - start + 3, max_x / 2 - 16);
+		snprintf(buf, sizeof(buf), "Depends on: ");
+		AST_LIST_TRAVERSE(&curmem->deps, dep, list) {
+			strncat(buf, dep->name, sizeof(buf) - strlen(buf) - 1);
+			if (AST_LIST_NEXT(dep, list))
+				strncat(buf, ", ", sizeof(buf) - strlen(buf) - 1);
+		}
+		waddstr(menu, buf);
+	}
+	if (!AST_LIST_EMPTY(&curmem->conflicts)) {
+		wmove(menu, end - start + 4, max_x / 2 - 16);
+		snprintf(buf, sizeof(buf), "Conflicts with: ");
+		AST_LIST_TRAVERSE(&curmem->conflicts, con, list) {
+			strncat(buf, con->name, sizeof(buf) - strlen(buf) - 1);
+			if (AST_LIST_NEXT(con, list))
+				strncat(buf, ", ", sizeof(buf) - strlen(buf) - 1);
+		}
+		waddstr(menu, buf);
+	}
 	wmove(menu, curopt - start, max_x / 2 - 9);
 
 	wrefresh(menu);



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 05:36:28 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 05:36:28 +0200
Subject: [solid-pbx-svn] r218 - trunk/res
Message-ID: <200606170336.k5H3aSAT026242@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 05:36:19 +0200 (Sat, 17 Jun 2006)
New Revision: 218

Modified:
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r31471

------------------------------------------------------------------------
r31469 | mogorman | 2006-06-01 20:48:22 +0200 (Thu, 01 Jun 2006) | 3 lines

more minor fixes thanks Julian on pointing out 
potential problems

------------------------------------------------------------------------


Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-17 03:25:53 UTC (rev 217)
+++ trunk/res/res_jabber.c	2006-06-17 03:36:19 UTC (rev 218)
@@ -342,9 +342,7 @@
 		if (!strcasecmp(iterator->user, screenname)) {
 			found = 1; 
 			r = iterator->resources; 
-			if (!r) {	/* client hasnt signed on */
-				break;
-			} else {
+			if (r) {	/* client has signed on */
 				if (resource) {
 					while (r) {
 						if (!strcasecmp(r->resource, resource)) {
@@ -353,7 +351,9 @@
 						}
 						r = r->next;
 					}
+					if(stat != 7) break;
 					ast_log(LOG_WARNING, "Resource not found %s\n", resource);
+					break;
 				} else {
 					stat = r->status; 
 					break;



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 05:37:54 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 05:37:54 +0200
Subject: [solid-pbx-svn] r219 - in trunk: . include/asterisk
Message-ID: <200606170337.k5H3bsi8027224@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 05:37:51 +0200 (Sat, 17 Jun 2006)
New Revision: 219

Modified:
   trunk/include/asterisk/utils.h
   trunk/utils.c
Log:
Update to Asterisk SVN trunk r31492

------------------------------------------------------------------------
r31492 | mogorman | 2006-06-01 21:05:45 +0200 (Thu, 01 Jun 2006) | 4 lines

changes for base64 to work in multiline instances
as well as being more efficient, patch from jcollie's
base64 branch

------------------------------------------------------------------------


Modified: trunk/include/asterisk/utils.h
===================================================================
--- trunk/include/asterisk/utils.h	2006-06-17 03:36:19 UTC (rev 218)
+++ trunk/include/asterisk/utils.h	2006-06-17 03:37:51 UTC (rev 219)
@@ -157,6 +157,7 @@
 	\brief Produces SHA1 hash based on input string */
 void ast_sha1_hash(char *output, char *input);
 
+int ast_base64encode_full(char *dst, const unsigned char *src, int srclen, int max, int linebreaks);
 int ast_base64encode(char *dst, const unsigned char *src, int srclen, int max);
 int ast_base64decode(unsigned char *dst, const char *src, int max);
 

Modified: trunk/utils.c
===================================================================
--- trunk/utils.c	2006-06-17 03:36:19 UTC (rev 218)
+++ trunk/utils.c	2006-06-17 03:37:51 UTC (rev 219)
@@ -324,17 +324,11 @@
 	unsigned int byte = 0;
 	unsigned int bits = 0;
 	int incnt = 0;
-#if 0
-	unsigned char *odst = dst;
-#endif
 	while(*src && (cnt < max)) {
 		/* Shift in 6 bits of input */
 		byte <<= 6;
 		byte |= (b2a[(int)(*src)]) & 0x3f;
 		bits += 6;
-#if 0
-		printf("Add: %c %s\n", *src, binary(b2a[(int)(*src)] & 0x3f, 6));
-#endif
 		src++;
 		incnt++;
 		/* If we have at least 8 bits left over, take that character 
@@ -342,66 +336,71 @@
 		if (bits >= 8)  {
 			bits -= 8;
 			*dst = (byte >> bits) & 0xff;
-#if 0
-			printf("Remove: %02x %s\n", *dst, binary(*dst, 8));
-#endif
 			dst++;
 			cnt++;
 		}
 	}
-#if 0
-	dump(odst, cnt);
-#endif
 	/* Dont worry about left over bits, they're extra anyway */
 	return cnt;
 }
 
 /*! \brief encode text to BASE64 coding */
-int ast_base64encode(char *dst, const unsigned char *src, int srclen, int max)
+int ast_base64encode_full(char *dst, const unsigned char *src, int srclen, int max, int linebreaks)
 {
 	int cnt = 0;
+	int col = 0;
 	unsigned int byte = 0;
 	int bits = 0;
-	int index;
 	int cntin = 0;
-#if 0
-	char *odst = dst;
-	dump(src, srclen);
-#endif
-	/* Reserve one bit for end */
+	/* Reserve space for null byte at end of string */
 	max--;
 	while((cntin < srclen) && (cnt < max)) {
 		byte <<= 8;
-#if 0
-		printf("Add: %02x %s\n", *src, binary(*src, 8));
-#endif
 		byte |= *(src++);
 		bits += 8;
 		cntin++;
-		while((bits >= 6) && (cnt < max)) {
-			bits -= 6;
-			/* We want only the top */
-			index = (byte >> bits) & 0x3f;
-			*dst = base64[index];
-#if 0
-			printf("Remove: %c %s\n", *dst, binary(index, 6));
-#endif
-			dst++;
+		if ((bits == 24) && (cnt + 4 < max)) {
+			*dst++ = base64[(byte >> 18) & 0x3f];
+			*dst++ = base64[(byte >> 12) & 0x3f];
+			*dst++ = base64[(byte >> 6) & 0x3f];
+			*dst++ = base64[byte & 0x3f];
+			cnt += 4;
+			col += 4;
+			bits = 0;
+			byte = 0;
+		}
+		if (linebreaks && (cnt < max) && (col == 64)) {
+			*dst++ = '\n';
 			cnt++;
+			col = 0;
 		}
 	}
-	if (bits && (cnt < max)) {
+	if (bits && (cnt + 4 < max)) {
 		/* Add one last character for the remaining bits, 
 		   padding the rest with 0 */
-		byte <<= (6 - bits);
-		index = (byte) & 0x3f;
-		*(dst++) = base64[index];
+		byte <<= 24 - bits;
+		*dst++ = base64[(byte >> 18) & 0x3f];
+		*dst++ = base64[(byte >> 12) & 0x3f];
+		if (bits == 16)
+			*dst++ = base64[(byte >> 6) & 0x3f];
+		else
+			*dst++ = '=';
+		*dst++ = '=';
+		cnt += 4;
+	}
+	if (linebreaks && (cnt < max)) {
+		*dst++ = '\n';
 		cnt++;
 	}
 	*dst = '\0';
 	return cnt;
 }
 
+int ast_base64encode(char *dst, const unsigned char *src, int srclen, int max)
+{
+	return ast_base64encode_full(dst, src, srclen, max, 0);
+}
+
 static void base64_init(void)
 {
 	int x;



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 05:38:40 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 05:38:40 +0200
Subject: [solid-pbx-svn] r220 - trunk/channels
Message-ID: <200606170338.k5H3cebm027776@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 05:38:37 +0200 (Sat, 17 Jun 2006)
New Revision: 220

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31495

------------------------------------------------------------------------
r31494 | oej | 2006-06-01 21:15:40 +0200 (Thu, 01 Jun 2006) | 2 lines

Minor change to DEBUG and WARNING messages

------------------------------------------------------------------------
r31495 | oej | 2006-06-01 21:21:46 +0200 (Thu, 01 Jun 2006) | 3 lines

- Formatting
- Add some comments

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-17 03:37:51 UTC (rev 219)
+++ trunk/channels/chan_sip.c	2006-06-17 03:38:37 UTC (rev 220)
@@ -2242,13 +2242,13 @@
 	natflags = ast_test_flag(&r->flags[0], SIP_NAT) & SIP_NAT_ROUTE;
 	if (r->rtp) {
 		if (option_debug)
-			ast_log(LOG_DEBUG, "Setting NAT on RTP to %d\n", natflags);
+			ast_log(LOG_DEBUG, "Setting NAT on RTP to %s\n", natflags ? "On" : "Off");
 		ast_rtp_setnat(r->rtp, natflags);
 		ast_rtp_setdtmf(r->rtp, ast_test_flag(&r->flags[0], SIP_DTMF) != SIP_DTMF_INFO);
 	}
 	if (r->vrtp) {
 		if (option_debug)
-			ast_log(LOG_DEBUG, "Setting NAT on VRTP to %d\n", natflags);
+			ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", natflags ? "On" : "Off");
 		ast_rtp_setnat(r->vrtp, natflags);
 		ast_rtp_setdtmf(r->vrtp, 0);
 	}
@@ -3262,7 +3262,7 @@
 	tmp = ast_channel_alloc(1);
 	ast_mutex_lock(&i->lock);
 	if (!tmp) {
-		ast_log(LOG_WARNING, "Unable to allocate SIP channel structure\n");
+		ast_log(LOG_WARNING, "Unable to allocate AST channel structure for SIP channel\n");
 		return NULL;
 	}
 	tmp->tech = &sip_tech;
@@ -4035,19 +4035,22 @@
 	return 0;
 }
 
-/*! \brief Process SIP SDP and activate RTP channels---*/
+/*! \brief Process SIP SDP, select formats and activate RTP channels */
 static int process_sdp(struct sip_pvt *p, struct sip_request *req)
 {
-	const char *m;
+	const char *m;		/* SDP media offer */
 	const char *c;
 	const char *a;
 	char host[258];
 	char iabuf[INET_ADDRSTRLEN];
 	int len = -1;
-	int portno = -1;
-	int vportno = -1;
+	int portno = -1;	/* Audio port */
+	int vportno = -1;	/* Video port */
+
+	/* Peer capability is the capability in the SDP, non codec is RFC2833 DTMF (101) */	
 	int peercapability, peernoncodeccapability;
-	int vpeercapability=0, vpeernoncodeccapability=0;
+
+	int vpeercapability=0, vpeernoncodeccapability=0;	/* Peer's video capabilities */
 	struct sockaddr_in sin;
 	const char *codecs;
 	struct hostent *hp;
@@ -4056,8 +4059,8 @@
 	int destiterator = 0;
 	int iterator;
 	int sendonly = 0;
-	int x,y;
-	int debug=sip_debug_test_pvt(p);
+	int x, y;
+	int debug = sip_debug_test_pvt(p);
 	struct ast_channel *bridgepeer = NULL;
 
 	if (!p->rtp) {
@@ -7713,12 +7716,12 @@
 
 		if (p->rtp) {
 			if (option_debug)
-				ast_log(LOG_DEBUG, "Setting NAT on RTP to %d\n", usenatroute);
+				ast_log(LOG_DEBUG, "Setting NAT on RTP to %s\n", usenatroute ? "On" : "Off");
 			ast_rtp_setnat(p->rtp, usenatroute);
 		}
 		if (p->vrtp) {
 			if (option_debug)
-				ast_log(LOG_DEBUG, "Setting NAT on VRTP to %d\n", usenatroute);
+				ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", usenatroute ? "On" : "Off");
 			ast_rtp_setnat(p->vrtp, usenatroute);
 		}
 		if (!(res = check_auth(p, req, user->name, user->secret, user->md5secret, sipmethod, uri, reliable, ast_test_flag(req, SIP_PKT_IGNORE)))) {
@@ -7816,11 +7819,11 @@
 			}
 			usenatroute = ast_test_flag(&p->flags[0], SIP_NAT_ROUTE);
 			if (p->rtp) {
-				ast_log(LOG_DEBUG, "Setting NAT on RTP to %d\n", usenatroute);
+				ast_log(LOG_DEBUG, "Setting NAT on RTP to %s\n", usenatroute ? "On" : "Off");
 				ast_rtp_setnat(p->rtp, usenatroute);
 			}
 			if (p->vrtp) {
-				ast_log(LOG_DEBUG, "Setting NAT on VRTP to %d\n", usenatroute);
+				ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", usenatroute ? "On" : "Off");
 				ast_rtp_setnat(p->vrtp, usenatroute);
 			}
 			ast_string_field_set(p, peersecret, peer->secret);



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 05:39:06 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 05:39:06 +0200
Subject: [solid-pbx-svn] r221 - trunk
Message-ID: <200606170339.k5H3d6uQ028195@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 05:39:04 +0200 (Sat, 17 Jun 2006)
New Revision: 221

Modified:
   trunk/frame.c
Log:
Update to Asterisk SVN trunk r31498

------------------------------------------------------------------------
r31496 | oej | 2006-06-01 21:28:01 +0200 (Thu, 01 Jun 2006) | 2 lines

Doxygen reformatting

------------------------------------------------------------------------
r31497 | oej | 2006-06-01 21:48:31 +0200 (Thu, 01 Jun 2006) | 2 lines

Formatting fixes

------------------------------------------------------------------------


Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-17 03:38:37 UTC (rev 220)
+++ trunk/frame.c	2006-06-17 03:39:04 UTC (rev 221)
@@ -18,7 +18,7 @@
 
 /*! \file
  *
- * \brief Frame manipulation routines
+ * \brief Frame and codec manipulation routines
  *
  * \author Mark Spencer <markster at digium.com> 
  */
@@ -91,7 +91,7 @@
 	{ 1, AST_FORMAT_LPC10, "lpc10", "LPC10" },	/*!< codec_lpc10.c */
 	{ 1, AST_FORMAT_G729A, "g729", "G.729A" },	/*!< Binary commercial distribution */
 	{ 1, AST_FORMAT_SPEEX, "speex", "SpeeX" },	/*!< codec_speex.c */
-	{ 1, AST_FORMAT_ILBC, "ilbc", "iLBC"},	/*!< codec_ilbc.c */
+	{ 1, AST_FORMAT_ILBC, "ilbc", "iLBC"},		/*!< codec_ilbc.c */
 	{ 0, 0, "nothing", "undefined" },
 	{ 0, 0, "nothing", "undefined" },
 	{ 0, 0, "nothing", "undefined" },
@@ -198,6 +198,7 @@
 {
 	struct ast_frame *opt;
 	int len;
+
 	/* IF we have an optimization frame, send it */
 	if (s->opt) {
 		if (s->opt->offset < AST_FRIENDLY_OFFSET)
@@ -480,13 +481,14 @@
 }
 
 #endif /* unused functions */
+
 void ast_swapcopy_samples(void *dst, const void *src, int samples)
 {
 	int i;
 	unsigned short *dst_s = dst;
 	const unsigned short *src_s = src;
 
-	for (i=0; i<samples; i++)
+	for (i = 0; i < samples; i++)
 		dst_s[i] = (src_s[i]<<8) | (src_s[i]>>8);
 }
 
@@ -515,12 +517,14 @@
 	return ret;
 }
 
-char *ast_getformatname_multiple(char *buf, size_t size, int format) {
-
+char *ast_getformatname_multiple(char *buf, size_t size, int format)
+{
 	int x;
 	unsigned len;
 	char *start, *end = buf;
-	if (!size) return buf;
+
+	if (!size)
+		return buf;
 	snprintf(end, size, "0x%x (", format);
 	len = strlen(end);
 	end += len;
@@ -544,13 +548,13 @@
 static struct ast_codec_alias_table {
 	char *alias;
 	char *realname;
-
 } ast_codec_alias_table[] = {
-	{"slinear","slin"},
-	{"g723.1","g723"},
+	{ "slinear", "slin"},
+	{ "g723.1", "g723"},
 };
 
-static const char *ast_expand_codec_alias(const char *in) {
+static const char *ast_expand_codec_alias(const char *in)
+{
 	int x;
 
 	for (x = 0; x < sizeof(ast_codec_alias_table) / sizeof(ast_codec_alias_table[0]); x++) {
@@ -567,8 +571,8 @@
 	all = strcasecmp(name, "all") ? 0 : 1;
 	for (x = 0; x < sizeof(AST_FORMAT_LIST) / sizeof(AST_FORMAT_LIST[0]); x++) {
 		if(AST_FORMAT_LIST[x].visible && (all || 
-										  !strcasecmp(AST_FORMAT_LIST[x].name,name) ||
-										  !strcasecmp(AST_FORMAT_LIST[x].name,ast_expand_codec_alias(name)))) {
+			  !strcasecmp(AST_FORMAT_LIST[x].name,name) ||
+			  !strcasecmp(AST_FORMAT_LIST[x].name,ast_expand_codec_alias(name)))) {
 			format |= AST_FORMAT_LIST[x].bits;
 			if(!all)
 				break;
@@ -578,7 +582,8 @@
 	return format;
 }
 
-char *ast_codec2str(int codec) {
+char *ast_codec2str(int codec)
+{
 	int x;
 	char *ret = "unknown";
 	for (x = 0; x < sizeof(AST_FORMAT_LIST) / sizeof(AST_FORMAT_LIST[0]); x++) {
@@ -648,13 +653,13 @@
 	if (sscanf(argv[2],"%d",&codec) != 1)
 		return RESULT_SHOWUSAGE;
 
-	for (i=0;i<32;i++)
+	for (i = 0; i < 32; i++)
 		if (codec & (1 << i)) {
 			found = 1;
 			ast_cli(fd, "%11u (1 << %2d)  %s\n",1 << i,i,ast_codec2str(1<<i));
 		}
 
-	if (! found)
+	if (!found)
 		ast_cli(fd, "Codec %d not found\n", codec);
 
 	return RESULT_SUCCESS;
@@ -938,7 +943,7 @@
 	return slot ? AST_FORMAT_LIST[slot-1].bits : 0;
 }
 
-/*! \brief ast_codec_pref_remove: Remove codec from pref list ---*/
+/*! \brief Remove codec from pref list */
 void ast_codec_pref_remove(struct ast_codec_pref *pref, int format)
 {
 	struct ast_codec_pref oldorder;
@@ -961,7 +966,7 @@
 	
 }
 
-/*! \brief ast_codec_pref_append: Append codec to list ---*/
+/*! \brief Append codec to list */
 int ast_codec_pref_append(struct ast_codec_pref *pref, int format)
 {
 	int x, newindex = -1;
@@ -988,7 +993,7 @@
 }
 
 
-/*! \brief ast_codec_choose: Pick a codec ---*/
+/*! \brief Pick a codec */
 int ast_codec_choose(struct ast_codec_pref *pref, int formats, int find_best)
 {
 	int x, ret = 0, slot;
@@ -996,9 +1001,9 @@
 	for (x = 0; x < sizeof(AST_FORMAT_LIST) / sizeof(AST_FORMAT_LIST[0]); x++) {
 		slot = pref->order[x];
 
-		if(!slot)
+		if (!slot)
 			break;
-		if ( formats & AST_FORMAT_LIST[slot-1].bits ) {
+		if (formats & AST_FORMAT_LIST[slot-1].bits) {
 			ret = AST_FORMAT_LIST[slot-1].bits;
 			break;
 		}



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 05:41:04 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 05:41:04 +0200
Subject: [solid-pbx-svn] r222 - in trunk: . include/asterisk
Message-ID: <200606170341.k5H3f4Kq028988@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 05:41:02 +0200 (Sat, 17 Jun 2006)
New Revision: 222

Modified:
   trunk/channel.c
   trunk/include/asterisk/channel.h
Log:
Update to Asterisk SVN trunk r31522

------------------------------------------------------------------------
r31522 | kpfleming | 2006-06-01 22:53:17 +0200 (Thu, 01 Jun 2006) | 10 lines

Merged revisions 31520 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31520 | kpfleming | 2006-06-01 15:27:50 -0500 (Thu, 01 Jun 2006) | 2 lines

handle Zap transfers behind chan_agent properly so the agent doesn't get stuck waiting for the call to hang up

.......

------------------------------------------------------------------------


Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-17 03:39:04 UTC (rev 221)
+++ trunk/channel.c	2006-06-17 03:41:02 UTC (rev 222)
@@ -2829,6 +2829,14 @@
 {
 	int res = -1;
 
+	/* each of these channels may be sitting behind a channel proxy (i.e. chan_agent)
+	   and if so, we don't really want to masquerade it, but its proxy */
+	if (original->_bridge && (original->_bridge != ast_bridged_channel(original)))
+		original = original->_bridge;
+
+	if (clone->_bridge && (clone->_bridge != ast_bridged_channel(clone)))
+		clone = clone->_bridge;
+
 	if (original == clone) {
 		ast_log(LOG_WARNING, "Can't masquerade channel '%s' into itself!\n", original->name);
 		return -1;

Modified: trunk/include/asterisk/channel.h
===================================================================
--- trunk/include/asterisk/channel.h	2006-06-17 03:39:04 UTC (rev 221)
+++ trunk/include/asterisk/channel.h	2006-06-17 03:41:02 UTC (rev 222)
@@ -311,8 +311,9 @@
 	/*! Current active data generator */
 	struct ast_generator *generator;
 
-	/*! Who are we bridged to, if we're bridged  Do not access directly,
-	    use ast_bridged_channel(chan) */
+	/*! Who are we bridged to, if we're bridged. Who is proxying for us,
+	  if we are proxied (i.e. chan_agent).
+	  Do not access directly, use ast_bridged_channel(chan) */
 	struct ast_channel *_bridge;
 	/*! Channel that will masquerade as us */
 	struct ast_channel *masq;		



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 17 16:25:27 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 17 Jun 2006 16:25:27 +0200
Subject: [solid-pbx-svn] r223 - trunk/res
Message-ID: <200606171425.k5HEPRKh030290@sheep.berlios.de>

Author: casper2
Date: 2006-06-17 16:25:26 +0200 (Sat, 17 Jun 2006)
New Revision: 223

Modified:
   trunk/res/res_musiconhold.c
Log:
Update to Asterisk SVN trunk r31558

------------------------------------------------------------------------
r31556 | kpfleming | 2006-06-01 23:47:49 +0200 (Thu, 01 Jun 2006) | 10 lines

Merged revisions 31555 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31555 | kpfleming | 2006-06-01 16:46:50 -0500 (Thu, 01 Jun 2006) | 2 lines

remove pointless forcing of the channel into SLINEAR mode; the write format will be set later based on the file that is chosen to be played to the channel

.......

------------------------------------------------------------------------


Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-06-17 03:41:02 UTC (rev 222)
+++ trunk/res/res_musiconhold.c	2006-06-17 14:25:26 UTC (rev 223)
@@ -226,10 +226,6 @@
 
 	state->pos = state->pos % state->class->total_files;
 	
-	if (ast_set_write_format(chan, AST_FORMAT_SLINEAR)) {
-		ast_log(LOG_WARNING, "Unable to set '%s' to linear format (write)\n", chan->name);
-		return -1;
-	}
 	if (!ast_openstream_full(chan, state->class->filearray[state->pos], chan->language, 1)) {
 		ast_log(LOG_WARNING, "Unable to open file '%s': %s\n", state->class->filearray[state->pos], strerror(errno));
 		state->pos++;
@@ -303,14 +299,8 @@
 
 		state->origwfmt = chan->writeformat;
 
-		if (ast_set_write_format(chan, AST_FORMAT_SLINEAR)) {
-			ast_log(LOG_WARNING, "Unable to set '%s' to linear format (write)\n", chan->name);
-			free(chan->music_state);
-			chan->music_state = NULL;
-		} else {
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Started music on hold, class '%s', on %s\n", class->name, chan->name);
-		}
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Started music on hold, class '%s', on %s\n", class->name, chan->name);
 	}
 	
 	return chan->music_state;



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 02:14:02 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 02:14:02 +0200
Subject: [solid-pbx-svn] r224 - trunk/build_tools
Message-ID: <200606180014.k5I0E2FV001187@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:13:32 +0200 (Sun, 18 Jun 2006)
New Revision: 224

Modified:
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r31588

------------------------------------------------------------------------
r31586 | russell | 2006-06-02 00:17:01 +0200 (Fri, 02 Jun 2006) | 2 lines

use strcpy instead of snprintf in a couple places

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-17 14:25:26 UTC (rev 223)
+++ trunk/build_tools/menuselect_curses.c	2006-06-18 00:13:32 UTC (rev 224)
@@ -160,7 +160,7 @@
 	}
 	if (!AST_LIST_EMPTY(&curmem->deps)) {
 		wmove(menu, end - start + 3, max_x / 2 - 16);
-		snprintf(buf, sizeof(buf), "Depends on: ");
+		strcpy(buf, "Depends on: ");
 		AST_LIST_TRAVERSE(&curmem->deps, dep, list) {
 			strncat(buf, dep->name, sizeof(buf) - strlen(buf) - 1);
 			if (AST_LIST_NEXT(dep, list))
@@ -170,7 +170,7 @@
 	}
 	if (!AST_LIST_EMPTY(&curmem->conflicts)) {
 		wmove(menu, end - start + 4, max_x / 2 - 16);
-		snprintf(buf, sizeof(buf), "Conflicts with: ");
+		strcpy(buf, "Conflicts with: ");
 		AST_LIST_TRAVERSE(&curmem->conflicts, con, list) {
 			strncat(buf, con->name, sizeof(buf) - strlen(buf) - 1);
 			if (AST_LIST_NEXT(con, list))



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 02:33:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 02:33:38 +0200
Subject: [solid-pbx-svn] r225 - trunk/res
Message-ID: <200606180033.k5I0XcIe005315@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:33:20 +0200 (Sun, 18 Jun 2006)
New Revision: 225

Modified:
   trunk/res/res_musiconhold.c
Log:
Update to Asterisk SVN trunk r31613

------------------------------------------------------------------------
r31613 | russell | 2006-06-02 05:34:09 +0200 (Fri, 02 Jun 2006) | 2 lines

add a comment where some memory usage optimization needs to be done

------------------------------------------------------------------------


Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-06-18 00:13:32 UTC (rev 224)
+++ trunk/res/res_musiconhold.c	2006-06-18 00:33:20 UTC (rev 225)
@@ -133,6 +133,7 @@
 	char dir[256];
 	char args[256];
 	char mode[80];
+	/* XXX This means that we are allocating 64KB of memory for every musiconhold class XXX */
 	char filearray[MAX_MOHFILES][MAX_MOHFILE_LEN];
 	unsigned int flags;
 	int total_files;



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 02:52:03 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 02:52:03 +0200
Subject: [solid-pbx-svn] r226 - trunk
Message-ID: <200606180052.k5I0q3D3008931@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:51:58 +0200 (Sun, 18 Jun 2006)
New Revision: 226

Modified:
   trunk/CREDITS
Log:
Update to Asterisk SVN trunk r31638

------------------------------------------------------------------------
r31636 | oej | 2006-06-02 08:24:30 +0200 (Fri, 02 Jun 2006) | 2 lines

Adding credits for SIP transfer work

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-18 00:33:20 UTC (rev 225)
+++ trunk/CREDITS	2006-06-18 00:51:58 UTC (rev 226)
@@ -117,6 +117,7 @@
 Roy Sigurd Karlsbakk - providing funding for generic jitterbuffer development
 	roy at karlsbakk.net, Briiz Telecom AS
 
+Voop A/S, Nuvio Inc and Foniris Telecom A/S - funding for rewrite of SIP transfers
 
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 02:53:42 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 02:53:42 +0200
Subject: [solid-pbx-svn] r227 - trunk
Message-ID: <200606180053.k5I0rg0L009037@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:53:18 +0200 (Sun, 18 Jun 2006)
New Revision: 227

Modified:
   trunk/CREDITS
Log:
Update to Asterisk SVN trunk r31668

------------------------------------------------------------------------
r31664 | russell | 2006-06-02 15:38:37 +0200 (Fri, 02 Jun 2006) | 2 lines

add credits for cdr_radius

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-18 00:51:58 UTC (rev 226)
+++ trunk/CREDITS	2006-06-18 00:53:18 UTC (rev 227)
@@ -119,6 +119,9 @@
 
 Voop A/S, Nuvio Inc and Foniris Telecom A/S - funding for rewrite of SIP transfers
 
+Philippe Sultan - RADIUS CDR module
+	INRIA, http://www.inria.fr/
+
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt
 Michael Jerris - bug marshaling



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 02:56:35 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 02:56:35 +0200
Subject: [solid-pbx-svn] r228 - trunk/apps
Message-ID: <200606180056.k5I0uZQP009531@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:56:29 +0200 (Sun, 18 Jun 2006)
New Revision: 228

Modified:
   trunk/apps/app_morsecode.c
Log:
Update to Asterisk SVN trunk r31693

------------------------------------------------------------------------
r31690 | tilghman | 2006-06-03 04:17:00 +0200 (Sat, 03 Jun 2006) | 2 lines

Ooops, those characters weren't really periods (credit to John Olson)

------------------------------------------------------------------------
r31691 | tilghman | 2006-06-03 04:18:59 +0200 (Sat, 03 Jun 2006) | 2 lines

Two missed cases

------------------------------------------------------------------------


Modified: trunk/apps/app_morsecode.c
===================================================================
--- trunk/apps/app_morsecode.c	2006-06-18 00:53:18 UTC (rev 227)
+++ trunk/apps/app_morsecode.c	2006-06-18 00:56:29 UTC (rev 228)
@@ -74,10 +74,10 @@
 	"--..--", /* 44 - , */
 	"-....-", /* 45 - - */
 	".-.-.-", /* 46 - . */
-	"-??-?",  /* 47 - / */
+	"-..-.",  /* 47 - / */
 	"-----", ".----", "..---", "...--", "....-", ".....", "-....", "--...", "---..", "----.", /* 48-57 - 0-9 */
 	"---...", /* 58 - : */
-	"-?-?-?", /* 59 - ; */
+	"-.-.-.", /* 59 - ; */
 	"",       /* 60 - < */
 	"-...-",  /* 61 - = */
 	"",       /* 62 - > */
@@ -86,18 +86,18 @@
 	".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--",
 	"-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--..",
 	"-.--.-", /* 91 - [ (really '(') */
-	"-??-?",  /* 92 - \ (really '/') */
+	"-..-.",  /* 92 - \ (really '/') */
 	"-.--.-", /* 93 - ] (really ')') */
 	"",       /* 94 - ^ */
-	"??--?-", /* 95 - _ */
+	"..--.-", /* 95 - _ */
 	".----.", /* 96 - ` */
 	".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--",
 	"-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--..",
 	"-.--.-", /* 123 - { (really '(') */
 	"",       /* 124 - | */
 	"-.--.-", /* 125 - } (really ')') */
-	"-??-?",  /* 126 - ~ (really bar) */
-	"? ? ?",  /* 127 - <del> (error) */
+	"-..-.",  /* 126 - ~ (really bar) */
+	". . .",  /* 127 - <del> (error) */
 };
 
 static void playtone(struct ast_channel *chan, int tone, int len)



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 02:57:46 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 02:57:46 +0200
Subject: [solid-pbx-svn] r229 - trunk
Message-ID: <200606180057.k5I0vkQf010043@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:57:42 +0200 (Sun, 18 Jun 2006)
New Revision: 229

Modified:
   trunk/CREDITS
Log:
Update to Asterisk SVN trunk r31723

------------------------------------------------------------------------
r31715 | oej | 2006-06-03 12:07:25 +0200 (Sat, 03 Jun 2006) | 2 lines

Adding John Martin to CREDITS for his video work

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-18 00:56:29 UTC (rev 228)
+++ trunk/CREDITS	2006-06-18 00:57:42 UTC (rev 229)
@@ -122,6 +122,8 @@
 Philippe Sultan - RADIUS CDR module
 	INRIA, http://www.inria.fr/
 
+John Martin, Aupix - Improved video support in the SIP channel
+
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt
 Michael Jerris - bug marshaling



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:00:01 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:00:01 +0200
Subject: [solid-pbx-svn] r230 - trunk/include/asterisk
Message-ID: <200606180100.k5I101YY010818@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 02:59:45 +0200 (Sun, 18 Jun 2006)
New Revision: 230

Modified:
   trunk/include/asterisk/linkedlists.h
Log:
Update to Asterisk SVN trunk r31743

------------------------------------------------------------------------
r31739 | bweschke | 2006-06-03 16:49:52 +0200 (Sat, 03 Jun 2006) | 11 lines

Merged revisions 31738 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31738 | bweschke | 2006-06-03 10:48:13 -0400 (Sat, 03 Jun 2006) | 3 lines

 Fix doxygen comment about AST_LIST_HEAD_INIT_NOLOCK


.......

------------------------------------------------------------------------


Modified: trunk/include/asterisk/linkedlists.h
===================================================================
--- trunk/include/asterisk/linkedlists.h	2006-06-18 00:57:42 UTC (rev 229)
+++ trunk/include/asterisk/linkedlists.h	2006-06-18 00:59:45 UTC (rev 230)
@@ -391,7 +391,8 @@
   \param head This is a pointer to the list head structure
 
   This macro initializes a list head structure by setting the head
-  entry to \a NULL (empty list) and recreating the embedded lock.
+  entry to \a NULL (empty list). There is no embedded lock handling
+  with this macro.
 */
 #define AST_LIST_HEAD_INIT_NOLOCK(head) {				\
 	(head)->first = NULL;						\



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:05:19 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:05:19 +0200
Subject: [solid-pbx-svn] r231 - trunk/res
Message-ID: <200606180105.k5I15Jps012664@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:05:10 +0200 (Sun, 18 Jun 2006)
New Revision: 231

Modified:
   trunk/res/res_musiconhold.c
Log:
Update to Asterisk SVN trunk r31783

------------------------------------------------------------------------
r31776 | russell | 2006-06-03 19:04:51 +0200 (Sat, 03 Jun 2006) | 3 lines

when using moh files mode, don't look for a file past the number of files
that have been loaded, or worse, past the size of the files array

------------------------------------------------------------------------


Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-06-18 00:59:45 UTC (rev 230)
+++ trunk/res/res_musiconhold.c	2006-06-18 01:05:10 UTC (rev 231)
@@ -218,6 +218,8 @@
 			if (ast_test_flag(state->class, MOH_RANDOMIZE))
 				state->pos = ast_random();
 
+			state->pos %= state->class->total_files;
+
 			/* check to see if this file's format can be opened */
 			if (ast_fileexists(state->class->filearray[state->pos], NULL, NULL) != -1)
 				break;



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:26:21 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:26:21 +0200
Subject: [solid-pbx-svn] r232 - trunk/channels
Message-ID: <200606180126.k5I1QLsK019108@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:25:26 +0200 (Sun, 18 Jun 2006)
New Revision: 232

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31813

------------------------------------------------------------------------
r31813 | rizzo | 2006-06-03 22:34:26 +0200 (Sat, 03 Jun 2006) | 5 lines

Replace '\"' with '"'.
The escape is unnecessary, and makes a bad example
to people reading the code.


------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 01:05:10 UTC (rev 231)
+++ trunk/channels/chan_sip.c	2006-06-18 01:25:26 UTC (rev 232)
@@ -7541,7 +7541,7 @@
 static char *get_calleridname(const char *input, char *output, size_t outputsize)
 {
 	const char *end = strchr(input,'<');	/* first_bracket */
-	const char *tmp = strchr(input,'\"');	/* first quote */
+	const char *tmp = strchr(input,'"');	/* first quote */
 	int bytes = 0;
 	int maxbytes = outputsize - 1;
 
@@ -7553,7 +7553,7 @@
 
 	/* we found "name" */
 	if (tmp && tmp < end) {
-		end = strchr(tmp+1, '\"');
+		end = strchr(tmp+1, '"');
 		if (!end)
 			return NULL;
 		bytes = (int) (end - tmp);
@@ -9714,7 +9714,7 @@
 				continue;
 			/* Found. Skip keyword, take text in quotes or up to the separator. */
 			c += strlen(i->key);
-			if (*c == '\"') {
+			if (*c == '"') {
 				src = ++c;
 				separator = "\"";
 			} else {



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:27:05 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:27:05 +0200
Subject: [solid-pbx-svn] r233 - trunk/channels
Message-ID: <200606180127.k5I1R5EZ019413@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:27:01 +0200 (Sun, 18 Jun 2006)
New Revision: 233

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31823

------------------------------------------------------------------------
r31814 | rizzo | 2006-06-03 22:40:54 +0200 (Sat, 03 Jun 2006) | 3 lines

remove duplicate code


------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 01:25:26 UTC (rev 232)
+++ trunk/channels/chan_sip.c	2006-06-18 01:27:01 UTC (rev 233)
@@ -7154,9 +7154,6 @@
 	/* Get the target domain */
 	if ((a = strchr(uri, '@'))) {
 		*a++ = '\0';
-		colon = strchr(a, ':'); /* Remove :port */
-		if (colon)
-			*colon = '\0';
 	} else {	/* No username part */
 		a = uri;
 		uri = "s";	/* Set extension to "s" */



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:29:02 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:29:02 +0200
Subject: [solid-pbx-svn] r234 - in trunk: . channels
Message-ID: <200606180129.k5I1T2Bk020342@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:28:54 +0200 (Sun, 18 Jun 2006)
New Revision: 234

Modified:
   trunk/channel.c
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31843

------------------------------------------------------------------------
r31840 | bweschke | 2006-06-04 00:08:25 +0200 (Sun, 04 Jun 2006) | 3 lines

 Make sure DEBUG is really cranked up before we decide to flood the logs with messages about Internal timing when a channel has to make a decision about generating internal timing (eg - MOH)


------------------------------------------------------------------------
r31841 | rizzo | 2006-06-04 00:18:41 +0200 (Sun, 04 Jun 2006) | 4 lines

mark XXX a bug in the code. oej/kevin, any idea what you want
to use here ?


------------------------------------------------------------------------
r31842 | rizzo | 2006-06-04 00:29:37 +0200 (Sun, 04 Jun 2006) | 3 lines

simplify logic in a small block of code


------------------------------------------------------------------------
r31843 | rizzo | 2006-06-04 00:56:45 +0200 (Sun, 04 Jun 2006) | 6 lines

mark XXX a buggy section of code and implement a probable
replacement (leave the original in case my code does not
do what the function was meant to do).
oej, please check this...


------------------------------------------------------------------------


Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-18 01:27:01 UTC (rev 233)
+++ trunk/channel.c	2006-06-18 01:28:54 UTC (rev 234)
@@ -2097,7 +2097,7 @@
 int ast_internal_timing_enabled(struct ast_channel *chan)
 {
 	int ret = ast_opt_internal_timing && chan->timingfd > -1;
-	if (option_debug > 3)
+	if (option_debug > 20)
 		ast_log(LOG_DEBUG, "Internal timing is %s (option_internal_timing=%d chan->timingfd=%d)\n", ret? "enabled": "disabled", ast_opt_internal_timing, chan->timingfd);
 	return ret;
 }

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 01:27:01 UTC (rev 233)
+++ trunk/channels/chan_sip.c	2006-06-18 01:28:54 UTC (rev 234)
@@ -7331,6 +7331,10 @@
 			if ((ptr = strchr(referdata->replaces_callid, ';'))) 	/* Remove options */ {
 				*ptr = '\0';
 			}
+			/*
+			 * XXX don't know what was the intention but this code is
+			 * definitely wrong, as ptr can be NULL here.
+			 */
 			ptr++;
 
 			/* Find the different tags before we destroy the string */
@@ -10030,15 +10034,11 @@
 	} else  if (!strcasecmp(colname, "codecs")) {
 		ast_getformatname_multiple(buf, len -1, peer->capability);
 	} else  if (!strncasecmp(colname, "codec[", 6)) {
-		char *codecnum, *ptr;
+		char *codecnum;
 		int index = 0, codec = 0;
 		
-		codecnum = strchr(colname, '[');
-		*codecnum = '\0';
-		codecnum++;
-		if ((ptr = strchr(codecnum, ']')))
-			*ptr = '\0';
-
+		codecnum = colname + 6;	/* move past the '[' */
+		codecnum = strsep(&codecnum, "]"); /* trim trailing ']' if any */
 		index = atoi(codecnum);
 		if((codec = ast_codec_pref_index(&peer->prefs, index))) {
 			ast_copy_string(buf, ast_getformatname(codec), len);
@@ -11626,9 +11626,28 @@
 		*/
 		
 		/* Skip leading whitespace */
-		while(replace_id[0] && (replace_id[0] < 33))
-			memmove(replace_id, replace_id+1, strlen(replace_id));
+		replace_id = ast_skip_blanks(replace_id);
 
+		/* XXX there are several bugs in the code below,
+		 * because 'ptr' can be NULL so all the dereferences in strcasestr()
+		 * would cause panics.
+		 * I think we should do something like the code below, which also has
+		 * the advantage of not depending on the order of headers.
+		 * Please test if it works, and in case remove the block in #else / #endif
+		 */
+#if 1	/* proposed replacement */
+
+		start = replace_id;
+		while ( (ptr = strsep(&start, ";")) ) {
+			ptr = ast_skip_blanks(ptr); /* XXX maybe unnecessary ? */
+			if ( (to = strcasestr(ptr, "to-tag=") ) )
+				totag = to + 7;	/* skip the keyword */
+			else if ( (to = strcasestr(ptr, "from-tag=") ) ) {
+				fromtag = to + 9;	/* skip the keyword */
+				fromtag = strsep(&fromtag, "&"); /* trim what ? */
+			}
+		}
+#else	/* original code, buggy */
 		if ((ptr = strchr(replace_id, ';'))) {
 			*ptr = '\0';
 			ptr++;
@@ -11641,6 +11660,7 @@
 			totag = ptr;
 			if ((to = strchr(ptr, ';')))
 				*to = '\0';
+			/* XXX this code is also wrong as to can be NULL */
 			to++;
 			ptr = to;
 		}
@@ -11654,6 +11674,7 @@
 			if ((to = strchr(ptr, ';')))
 				*to = '\0';
 		}
+#endif
 
 		if (sipdebug && option_debug > 3) 
 			ast_log(LOG_DEBUG,"Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\n", replace_id, fromtag ? fromtag : "<no from tag>", totag ? totag : "<no to tag>");



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:35:02 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:35:02 +0200
Subject: [solid-pbx-svn] r235 - trunk/channels
Message-ID: <200606180135.k5I1Z284021613@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:34:26 +0200 (Sun, 18 Jun 2006)
New Revision: 235

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31863

------------------------------------------------------------------------
r31861 | rizzo | 2006-06-04 01:03:29 +0200 (Sun, 04 Jun 2006) | 4 lines

use ast_skip_blanks() where appropriate, and use standard
C jargoon  *foo++ = '\0'; instead of two separate statements.


------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 01:28:54 UTC (rev 234)
+++ trunk/channels/chan_sip.c	2006-06-18 01:34:26 UTC (rev 235)
@@ -10163,8 +10163,7 @@
 	} else {
 		e = strchr(tmp, '@');
 		if (e) {
-			*e = '\0';
-			e++;
+			*e++ = '\0';
 			domain = e;
 		} else {
 			/* No username part */
@@ -11225,8 +11224,8 @@
 	char *sep;
 
 	if( (sep = strchr(event, ';')) ) {	/* XXX bug here - overwriting string ? */
-		*sep = '\0';
-		eventid = ++sep;
+		*sep++ = '\0';
+		eventid = sep;
 	}
 	
 	if (option_debug > 1 && sipdebug)
@@ -11291,27 +11290,20 @@
 		*/
 		if (option_debug > 2)
 			ast_log(LOG_DEBUG, "* SIP Transfer NOTIFY Attachment: \n---%s\n---\n", buf);
-		cmd = buf;
-		while(*cmd && (*cmd < 33)) {	/* Skip white space */
-			cmd++;
-		}
+		cmd = ast_skip_blanks(buf);
 		code = cmd;
 		/* We are at SIP/2.0 */
 		while(*code && (*code > 32)) {	/* Search white space */
 			code++;
 		}
-		*code = '\0';
-		code++;
-		while(*code && (*code < 33)) {	/* Skip white space */
-			code++;
-		}
+		*code++ = '\0';
+		code = ast_skip_blanks(code);
 		sep = code;
 		sep++;
 		while(*sep && (*sep > 32)) {	/* Search white space */
 			sep++;
 		}
-		*sep = '\0';
-		sep++;				/* Response string */
+		*sep++ = '\0';			/* Response string */
 		respcode = atoi(code);
 		switch (respcode) {
 		case 100:	/* Trying: */



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:39:46 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:39:46 +0200
Subject: [solid-pbx-svn] r236 - trunk/channels
Message-ID: <200606180139.k5I1dkMd022722@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:39:33 +0200 (Sun, 18 Jun 2006)
New Revision: 236

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31873

------------------------------------------------------------------------
r31868 | rizzo | 2006-06-04 01:17:54 +0200 (Sun, 04 Jun 2006) | 4 lines

some code simplifications using S_OR() to remove some if blocks
and duplicate code.


------------------------------------------------------------------------
r31869 | rizzo | 2006-06-04 01:23:24 +0200 (Sun, 04 Jun 2006) | 3 lines

fix indentation of a block


------------------------------------------------------------------------
r31870 | rizzo | 2006-06-04 01:34:01 +0200 (Sun, 04 Jun 2006) | 5 lines

mark XXX some places where there is a return right before
a large "else" block, which is suitable for a reduction of
the nesting depth.


------------------------------------------------------------------------
r31871 | rizzo | 2006-06-04 01:46:23 +0200 (Sun, 04 Jun 2006) | 3 lines

small simplification in assignments, and fix a typo in a comment.


------------------------------------------------------------------------
r31872 | rizzo | 2006-06-04 01:58:32 +0200 (Sun, 04 Jun 2006) | 6 lines

remove some duplicated code;
fix indentation on one line;
mark XXX some unreachable code;
mark XXX another place where we could reduce the nesting depth.


------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 01:34:26 UTC (rev 235)
+++ trunk/channels/chan_sip.c	2006-06-18 01:39:33 UTC (rev 236)
@@ -1980,24 +1980,24 @@
 	if (ast_strlen_zero(global_regcontext))
 		return;
 
-		ast_copy_string(multi, S_OR(peer->regexten, peer->name), sizeof(multi));
-		stringp = multi;
-		while ((ext = strsep(&stringp, "&"))) {
- 			if ((context = strchr(ext, '@'))) {
-				*context++ = '\0';	/* split ext at context */
-				if (!ast_context_find(context)) {
-					ast_log(LOG_WARNING, "Context %s must exist in regcontext= in sip.conf!\n", context);
-					continue;
-				}
-			} else {
-				context = global_regcontext;
+	ast_copy_string(multi, S_OR(peer->regexten, peer->name), sizeof(multi));
+	stringp = multi;
+	while ((ext = strsep(&stringp, "&"))) {
+		if ((context = strchr(ext, '@'))) {
+			*context++ = '\0';	/* split ext at context */
+			if (!ast_context_find(context)) {
+				ast_log(LOG_WARNING, "Context %s must exist in regcontext= in sip.conf!\n", context);
+				continue;
 			}
-			if (onoff)
-				ast_add_extension(context, 1, ext, 1, NULL, NULL, "Noop",
-					 ast_strdup(peer->name), free, "SIP");
-			else
-				ast_context_remove_extension(context, ext, 1, NULL);
+		} else {
+			context = global_regcontext;
 		}
+		if (onoff)
+			ast_add_extension(context, 1, ext, 1, NULL, NULL, "Noop",
+				 ast_strdup(peer->name), free, "SIP");
+		else
+			ast_context_remove_extension(context, ext, 1, NULL);
+	}
 }
 
 /*! \brief Destroy peer object from memory */
@@ -6026,10 +6026,7 @@
 	
 	/* Fromdomain is what we are registering to, regardless of actual
 	   host name from SRV */
-	if (!ast_strlen_zero(p->fromdomain))
-		snprintf(addr, sizeof(addr), "sip:%s", p->fromdomain);
-	else
-		snprintf(addr, sizeof(addr), "sip:%s", r->hostname);
+	snprintf(addr, sizeof(addr), "sip:%s", S_OR(p->fromdomain, r->hostname));
 	ast_string_field_set(p, uri, addr);
 
 	p->branch ^= ast_random();
@@ -6753,6 +6750,9 @@
 		sip_scheddestroy(p, SIP_TRANS_TIMEOUT);
 		return AUTH_CHALLENGE_SENT;
 	} else {	/* We have auth, so check it */
+
+		/* XXX reduce nesting here */
+
 		/* Whoever came up with the authentication section of SIP can suck my %&#$&* for not putting
 	   	an example in the spec of just what it is you're doing a hash on. */
 		char a1_hash[256];
@@ -7141,11 +7141,11 @@
 		}
 		from += 4;
 		from = strsep(&from, ";");
-		if ((a = strchr(from, '@'))) {
-			*a = '\0';
-			ast_string_field_set(p, fromdomain, a + 1);
-		} else
-			ast_string_field_set(p, fromdomain, from);
+		if ((a = strchr(from, '@')))
+			*a++ = '\0';
+		else
+			a = from;	/* just a domain */
+		ast_string_field_set(p, fromdomain, a);
 	}
 
 	/* Skip any options and find the domain */
@@ -7371,12 +7371,10 @@
 	
 	if ((ptr = strchr(refer_to, '@'))) {	/* Separate domain */
 		char *urioption;
-		*ptr = '\0';
-		ptr++;
-		if ((urioption = strchr(ptr, ';'))) {
-			*urioption = '\0';
-			urioption++;
-		}	
+
+		*ptr++ = '\0';
+		if ((urioption = strchr(ptr, ';')))
+			*urioption++ = '\0';
 		/* Save the domain for the dial plan */
 		strncpy(referdata->refer_to_domain, ptr, sizeof(referdata->refer_to_domain));
 		if (urioption)
@@ -7397,12 +7395,8 @@
 
 	/* By default, use the context in the channel sending the REFER */
 	if (ast_strlen_zero(transfer_context)) {
-		if (!ast_strlen_zero(transferer->owner->macrocontext))
-			transfer_context=transferer->owner->macrocontext;
-		else if (ast_strlen_zero(transferer->context))
-			transfer_context = default_context;
-		else
-			transfer_context = transferer->context;
+		transfer_context = S_OR(transferer->owner->macrocontext,
+					S_OR(transferer->context, default_context));
 	}
 
 	strncpy(referdata->refer_to_context, transfer_context, sizeof(referdata->refer_to_context));
@@ -7423,20 +7417,14 @@
 }
 
 
-/*! \brief Call transfer support (old way, depreciated by the IETF)--*/
+/*! \brief Call transfer support (old way, deprecated by the IETF)--*/
 static int get_also_info(struct sip_pvt *p, struct sip_request *oreq)
 {
 	char tmp[256] = "", *c, *a;
-	struct sip_request *req = oreq;
-	struct sip_refer *referdata;
+	struct sip_request *req = oreq ? oreq : &p->initreq;
+	struct sip_refer *referdata = p->refer;
 	const char *transfer_context = NULL;
 	
-	referdata = p->refer;
-	
-	if (!oreq)
-		req = &p->initreq;
-	else
-		req = oreq;
 	ast_copy_string(tmp, get_header(req, "Also"), sizeof(tmp));
 	c = get_in_brackets(tmp);
 
@@ -7449,8 +7437,7 @@
 	}
 	c += 4;
 	if ((a = strchr(c, '@'))) {	/* Separate Domain */
-		*a = '\0';
-		a++;
+		*a++ = '\0';
 		ast_copy_string(referdata->refer_to_domain, a, sizeof(referdata->refer_to_domain));
 	}
 	
@@ -7464,13 +7451,9 @@
 		transfer_context = pbx_builtin_getvar_helper(p->owner, "TRANSFER_CONTEXT");
 
 	/* By default, use the context in the channel sending the REFER */
-	if (!transfer_context || ast_strlen_zero(transfer_context)) {
-		if (!ast_strlen_zero(p->owner->macrocontext))
-			transfer_context = p->owner->macrocontext;
-		else if (ast_strlen_zero(p->context))
-			transfer_context = default_context;
-		else
-			transfer_context = p->context;
+	if (ast_strlen_zero(transfer_context)) {
+		transfer_context = S_OR(p->owner->macrocontext,
+					S_OR(p->context, default_context));
 	}
 	if (ast_exists_extension(NULL, transfer_context, c, 1, NULL)) {
 		/* This is a blind transfer */
@@ -11239,6 +11222,8 @@
 			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 		return -1;
 	} else {
+		/* XXX reduce nesting depth */
+
 		/* Handle REFER notifications */
 
 		char buf[1024];
@@ -11338,6 +11323,7 @@
 		return res;
 	};
 
+	/* XXX hey, we never reach this code! */
 	/* THis could be voicemail notification */
 	transmit_response(p, "200 OK", req);
 	if (!p->lastinvite) 
@@ -11387,7 +11373,7 @@
 		/* We have no bridge */
 		if (!earlyreplace) {
 			if (option_debug > 1)
-			ast_log(LOG_DEBUG, "	Attended transfer attempted to replace call with no bridge (maybe ringing). Channel %s!\n", replacecall->name);
+				ast_log(LOG_DEBUG, "	Attended transfer attempted to replace call with no bridge (maybe ringing). Channel %s!\n", replacecall->name);
 			oneleggedreplace = 1;
 		}
 	} 
@@ -11952,20 +11938,19 @@
 		}
 	} else {
 		if (p && !ast_test_flag(&p->flags[0], SIP_NEEDDESTROY)) {
-			if (!p->jointcapability) {
-				if (ast_test_flag(req, SIP_PKT_IGNORE))
-					transmit_response(p, "488 Not Acceptable Here (codec error)", req);
-				else
-					transmit_response_reliable(p, "488 Not Acceptable Here (codec error)", req);
-				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
-			} else {
+			const char *msg;
+
+			if (!p->jointcapability)
+				msg = "488 Not Acceptable Here (codec error)";
+			else {
 				ast_log(LOG_NOTICE, "Unable to create/find SIP channel for this INVITE\n");
-				if (ast_test_flag(req, SIP_PKT_IGNORE))
-					transmit_response(p, "503 Unavailable", req);
-				else
-					transmit_response_reliable(p, "503 Unavailable", req);
-				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
+				msg = "503 Unavailable";
 			}
+			if (ast_test_flag(req, SIP_PKT_IGNORE))
+				transmit_response(p, msg, req);
+			else
+				transmit_response_reliable(p, msg, req);
+			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 		}
 	}
 	return res;
@@ -12616,6 +12601,8 @@
 		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 		return 0;
 	} else {
+		/* XXX reduce nesting here */
+
 		/* Initialize tag for new subscriptions */	
 		if (ast_strlen_zero(p->tag))
 			make_our_tag(p->tag, sizeof(p->tag));
@@ -12714,6 +12701,7 @@
 				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 				return 0;
 			} else {
+				/* XXX reduce nesting here */
 				struct sip_pvt *p_old;
 	
 				transmit_response(p, "200 OK", req);



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:54:53 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:54:53 +0200
Subject: [solid-pbx-svn] r237 - trunk/channels
Message-ID: <200606180154.k5I1srRc026432@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:54:42 +0200 (Sun, 18 Jun 2006)
New Revision: 237

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r31903

------------------------------------------------------------------------
r31895 | rizzo | 2006-06-04 02:09:13 +0200 (Sun, 04 Jun 2006) | 3 lines

add a bit of comment on what build_route does,
plus minor code simplification.

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 01:39:33 UTC (rev 236)
+++ trunk/channels/chan_sip.c	2006-06-18 01:54:42 UTC (rev 237)
@@ -6622,7 +6622,11 @@
 	
 	p->route_persistant = backwards;
 	
-	/* We build up head, then assign it to p->route when we're done */
+	/* Build a tailq, then assign it to p->route when done.
+	 * If backwards, we add entries from the head so they end up
+	 * in reverse order. However, we do need to maintain a correct
+	 * tail pointer because the contact is always at the end.
+	 */
 	head = NULL;
 	tail = head;
 	/* 1st we pass through all the hops in any Record-Route headers */
@@ -6631,12 +6635,7 @@
 		rr = __get_header(req, "Record-Route", &start);
 		if (*rr == '\0')
 			break;
-		for (;;) {
-			/* Each route entry */
-			/* Find < */
-			rr = strchr(rr, '<');
-			if (!rr) 
-				break; /* No more hops */
+		for (; (rr = strchr(rr, '<')) ; rr += len) { /* Each route entry */
 			++rr;
 			len = strcspn(rr, ">") + 1;
 			/* Make a struct route */
@@ -6650,7 +6649,8 @@
 					thishop->next = head;
 					head = thishop;
 					/* If this was the first then it'll be the tail */
-					if (!tail) tail = thishop;
+					if (!tail)
+						tail = thishop;
 				} else {
 					thishop->next = NULL;
 					/* Link in at the end */
@@ -6661,7 +6661,6 @@
 					tail = thishop;
 				}
 			}
-			rr += len;
 		}
 	}
 



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:57:20 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:57:20 +0200
Subject: [solid-pbx-svn] r238 - trunk/apps
Message-ID: <200606180157.k5I1vK2K027026@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:57:10 +0200 (Sun, 18 Jun 2006)
New Revision: 238

Modified:
   trunk/apps/app_queue.c
Log:
Update to Asterisk SVN trunk r31923

------------------------------------------------------------------------
r31922 | kpfleming | 2006-06-04 05:45:54 +0200 (Sun, 04 Jun 2006) | 10 lines

Merged revisions 31921 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r31921 | kpfleming | 2006-06-03 22:43:35 -0500 (Sat, 03 Jun 2006) | 2 lines

return bridge exit logic to what it was before i broke it :-(

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-18 01:54:42 UTC (rev 237)
+++ trunk/apps/app_queue.c	2006-06-18 01:57:10 UTC (rev 238)
@@ -2606,7 +2606,7 @@
 		if (bridge != AST_PBX_NO_HANGUP_PEER)
 			ast_hangup(peer);
 		update_queue(qe->parent, member);
-		res = bridge ? -1 : 0;
+		res = bridge ? bridge : 1;
 	}
 out:
 	hangupcalls(outgoing, NULL);



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 03:58:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 03:58:41 +0200
Subject: [solid-pbx-svn] r239 - trunk/res
Message-ID: <200606180158.k5I1wfP3027396@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 03:58:35 +0200 (Sun, 18 Jun 2006)
New Revision: 239

Modified:
   trunk/res/res_musiconhold.c
Log:
Update to Asterisk SVN trunk r31953

------------------------------------------------------------------------
r31953 | russell | 2006-06-04 08:21:43 +0200 (Sun, 04 Jun 2006) | 10 lines

Use a dynamically sized array to store the list of files for moh "files" mode
 - Instead of always allocating 64KB of memory for every MOH class, this has
   been reduced to only a single pointer per class, with more memory only
   allocatted when using "files" mode, as needed
 - Instead of imposing a length limit on the full filename, including full
   path, of 127 characters, use PATH_MAX, the maximum length that the system
   can handle
 - There is no longer a limit on the number of files than can be used for a
   single MOH class using "files" mode

------------------------------------------------------------------------


Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-06-18 01:57:10 UTC (rev 238)
+++ trunk/res/res_musiconhold.c	2006-06-18 01:58:35 UTC (rev 239)
@@ -72,8 +72,7 @@
 #include "asterisk/stringfields.h"
 #include "asterisk/linkedlists.h"
 
-#define MAX_MOHFILES 512
-#define MAX_MOHFILE_LEN 128
+#define INITIAL_NUM_FILES   8
 
 static char *app0 = "MusicOnHold";
 static char *app1 = "WaitMusicOnHold";
@@ -133,17 +132,22 @@
 	char dir[256];
 	char args[256];
 	char mode[80];
-	/* XXX This means that we are allocating 64KB of memory for every musiconhold class XXX */
-	char filearray[MAX_MOHFILES][MAX_MOHFILE_LEN];
+	/*! A dynamically sized array to hold the list of filenames in "files" mode */
+	char **filearray;
+	/*! The current size of the filearray */
+	int allowed_files;
+	/*! The current number of files loaded into the filearray */
+	int total_files;
 	unsigned int flags;
-	int total_files;
+	/*! The format from the MOH source, not applicable to "files" mode */
 	int format;
-	int pid;		/* PID of mpg123 */
+	/*! The pid of the external application delivering MOH */
+	int pid;
 	time_t start;
 	pthread_t thread;
-	/* Source of audio */
+	/*! Source of audio */
 	int srcfd;
-	/* FD for timing source */
+	/*! FD for timing source */
 	int pseudofd;
 	AST_LIST_HEAD_NOLOCK(, mohdata) members;
 	AST_LIST_ENTRY(mohclass) list;
@@ -164,20 +168,28 @@
 #define MAX_MP3S 256
 
 
-static void ast_moh_free_class(struct mohclass **class) 
+static void ast_moh_free_class(struct mohclass **mohclass) 
 {
 	struct mohdata *member;
+	struct mohclass *class = *mohclass;
+	int i;
 	
-	while ((member = AST_LIST_REMOVE_HEAD(&((*class)->members), list)))
+	while ((member = AST_LIST_REMOVE_HEAD(&class->members, list)))
 		free(member);
 	
-	if ((*class)->thread) {
-		pthread_cancel((*class)->thread);
-		(*class)->thread = 0;
+	if (class->thread) {
+		pthread_cancel(class->thread);
+		class->thread = 0;
 	}
 
-	free(*class);
-	*class = NULL;
+	if (class->filearray) {
+		for (i = 0; i < class->total_files; i++)
+			free(class->filearray[i]);
+		free(class->filearray);
+	}
+
+	free(class);
+	*mohclass = NULL;
 }
 
 
@@ -402,14 +414,6 @@
 		ast_log(LOG_WARNING, "Pipe failed\n");
 		return -1;
 	}
-#if 0
-	printf("%d files total, %d args total\n", files, argc);
-	{
-		int x;
-		for (x=0;argv[x];x++)
-			printf("arg%d: %s\n", x, argv[x]);
-	}
-#endif	
 	if (!files) {
 		ast_log(LOG_WARNING, "Found no files in '%s'\n", class->dir);
 		close(fds[0]);
@@ -721,12 +725,35 @@
 	generate: moh_generate,
 };
 
+static int moh_add_file(struct mohclass *class, const char *filepath)
+{
+	if (!class->allowed_files) {
+		if (!(class->filearray = ast_calloc(1, INITIAL_NUM_FILES * sizeof(*class->filearray))))
+			return -1;
+		class->allowed_files = INITIAL_NUM_FILES;
+	} else if (class->total_files == class->allowed_files) {
+		if (!(class->filearray = ast_realloc(class->filearray, class->allowed_files * sizeof(*class->filearray) * 2))) {
+			class->allowed_files = 0;
+			class->total_files = 0;
+			return -1;
+		}
+		class->allowed_files *= 2;
+	}
+
+	if (!(class->filearray[class->total_files] = ast_strdup(filepath)))
+		return -1;
+
+	class->total_files++;
+
+	return 0;
+}
+
 static int moh_scan_files(struct mohclass *class) {
 
 	DIR *files_DIR;
 	struct dirent *files_dirent;
 	char path[512];
-	char filepath[MAX_MOHFILE_LEN];
+	char filepath[PATH_MAX];
 	char *ext;
 	struct stat statbuf;
 	int dirnamelen;
@@ -738,16 +765,19 @@
 		return -1;
 	}
 
+	for (i = 0; i < class->total_files; i++)
+		free(class->filearray[i]);
+
 	class->total_files = 0;
 	dirnamelen = strlen(class->dir) + 2;
 	getcwd(path, 512);
 	chdir(class->dir);
-	memset(class->filearray, 0, MAX_MOHFILES*MAX_MOHFILE_LEN);
 	while ((files_dirent = readdir(files_DIR))) {
-		if ((strlen(files_dirent->d_name) < 4) || ((strlen(files_dirent->d_name) + dirnamelen) >= MAX_MOHFILE_LEN))
+		/* The file name must be at least long enough to have the file type extension */
+		if ((strlen(files_dirent->d_name) < 4))
 			continue;
 
-		snprintf(filepath, MAX_MOHFILE_LEN, "%s/%s", class->dir, files_dirent->d_name);
+		snprintf(filepath, sizeof(filepath), "%s/%s", class->dir, files_dirent->d_name);
 
 		if (stat(filepath, &statbuf))
 			continue;
@@ -765,13 +795,10 @@
 			if (!strcmp(filepath, class->filearray[i]))
 				break;
 
-		if (i == class->total_files)
-			strcpy(class->filearray[class->total_files++], filepath);
-
-		/* If the new total files is equal to the maximum allowed, stop adding new ones */
-		if (class->total_files == MAX_MOHFILES)
-			break;
-
+		if (i == class->total_files) {
+			if (moh_add_file(class, filepath))
+				break;
+		}
 	}
 
 	closedir(files_DIR);



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 04:02:06 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 04:02:06 +0200
Subject: [solid-pbx-svn] r240 - in trunk: . include/asterisk
Message-ID: <200606180202.k5I226BU028150@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 04:01:52 +0200 (Sun, 18 Jun 2006)
New Revision: 240

Modified:
   trunk/include/asterisk/channel.h
   trunk/include/asterisk/translate.h
   trunk/translate.c
Log:
Update to Asterisk SVN trunk r31983

------------------------------------------------------------------------
r31977 | oej | 2006-06-04 10:15:41 +0200 (Sun, 04 Jun 2006) | 2 lines

Doxygen formatting fixes

------------------------------------------------------------------------
r31979 | oej | 2006-06-04 10:57:34 +0200 (Sun, 04 Jun 2006) | 2 lines

Doxygen improvements

------------------------------------------------------------------------


Modified: trunk/include/asterisk/channel.h
===================================================================
--- trunk/include/asterisk/channel.h	2006-06-18 01:58:35 UTC (rev 239)
+++ trunk/include/asterisk/channel.h	2006-06-18 02:01:52 UTC (rev 240)
@@ -78,6 +78,7 @@
 	\par Reference
 	\arg channel.c - generic functions
  	\arg channel.h - declarations of functions, flags and structures
+	\arg translate.h - Transcoding support functions
 	\arg \ref channel_drivers - Implemented channel drivers
 	\arg \ref Def_Frame Asterisk Multimedia Frames
 
@@ -99,13 +100,12 @@
 extern "C" {
 #endif
 
-/*! Max length of an extension */
-#define AST_MAX_EXTENSION	80
+#define AST_MAX_EXTENSION	80	/*!< Max length of an extension */
+#define AST_MAX_CONTEXT		80	/*!< Max length of a context */
+#define AST_CHANNEL_NAME	80	/*!< Max length of an ast_channel name */
+#define MAX_LANGUAGE		20	/*!< Max length of the language setting */
+#define MAX_MUSICCLASS		20	/*!< Max length of the music class setting */
 
-#define AST_MAX_CONTEXT		80
-
-#define AST_CHANNEL_NAME	80
-
 #include "asterisk/compat.h"
 #include "asterisk/frame.h"
 #include "asterisk/sched.h"
@@ -117,19 +117,16 @@
 #include "asterisk/linkedlists.h"
 #include "asterisk/stringfields.h"
 
-#define MAX_LANGUAGE		20
 
-#define MAX_MUSICCLASS		20
-
 #define AST_MAX_FDS		8
 /*
  * We have AST_MAX_FDS file descriptors in a channel.
  * Some of them have a fixed use:
  */
-#define AST_ALERT_FD	(AST_MAX_FDS-1)		/* used for alertpipe */
-#define AST_TIMING_FD	(AST_MAX_FDS-2)		/* used for timingfd */
-#define AST_AGENT_FD	(AST_MAX_FDS-3) /* used by agents for pass thru */
-#define AST_GENERATOR_FD	(AST_MAX_FDS-4) /* used by generator */
+#define AST_ALERT_FD	(AST_MAX_FDS-1)		/*!< used for alertpipe */
+#define AST_TIMING_FD	(AST_MAX_FDS-2)		/*!< used for timingfd */
+#define AST_AGENT_FD	(AST_MAX_FDS-3)		/*!< used by agents for pass through */
+#define AST_GENERATOR_FD	(AST_MAX_FDS-4)	/*!< used by generator */
 
 enum ast_bridge_result {
 	AST_BRIDGE_COMPLETE = 0,
@@ -146,43 +143,40 @@
 	int (*generate)(struct ast_channel *chan, void *data, int len, int samples);
 };
 
-/*! Structure for a data store type */
+/*! \brief Structure for a data store type */
 struct ast_datastore_info {
-	const char *type;		/*! Type of data store */
-	void (*destroy)(void *data);	/*! Destroy function */
+	const char *type;		/*!< Type of data store */
+	void (*destroy)(void *data);	/*!< Destroy function */
 };
 
-/*! Structure for a channel data store */
+/*! \brief Structure for a channel data store */
 struct ast_datastore {
-	/*! Unique data store identifier */
-	char *uid;
-	/*! Contained data */
-	void *data;
-	/*! Data store type information */
-	const struct ast_datastore_info *info;
-	/*! Used for easy linking */
-	AST_LIST_ENTRY(ast_datastore) entry;
+	char *uid;		/*!< Unique data store identifier */
+	void *data;		/*!< Contained data */
+	const struct ast_datastore_info *info;	/*!< Data store type information */
+	AST_LIST_ENTRY(ast_datastore) entry; /*!< Used for easy linking */
 };
 
-/*! Structure for all kinds of caller ID identifications.
- * All string fields here are malloc'ed, so they need to be
+/*! \brief Structure for all kinds of caller ID identifications.
+ * \note All string fields here are malloc'ed, so they need to be
  * freed when the structure is deleted.
  * Also, NULL and "" must be considered equivalent.
  */
 struct ast_callerid {
-	char *cid_dnid;		/*! Malloc'd Dialed Number Identifier */
-	char *cid_num;		/*! Malloc'd Caller Number */
-	char *cid_name;		/*! Malloc'd Caller Name */
-	char *cid_ani;		/*! Malloc'd ANI */
-	char *cid_rdnis;	/*! Malloc'd RDNIS */
-	int cid_pres;		/*! Callerid presentation/screening */
-	int cid_ani2;		/*! Callerid ANI 2 (Info digits) */
-	int cid_ton;		/*! Callerid Type of Number */
-	int cid_tns;		/*! Callerid Transit Network Select */
+	char *cid_dnid;		/*!< Malloc'd Dialed Number Identifier */
+	char *cid_num;		/*!< Malloc'd Caller Number */
+	char *cid_name;		/*!< Malloc'd Caller Name */
+	char *cid_ani;		/*!< Malloc'd ANI */
+	char *cid_rdnis;	/*!< Malloc'd RDNIS */
+	int cid_pres;		/*!< Callerid presentation/screening */
+	int cid_ani2;		/*!< Callerid ANI 2 (Info digits) */
+	int cid_ton;		/*!< Callerid Type of Number */
+	int cid_tns;		/*!< Callerid Transit Network Select */
 };
 
-/*! Structure to describe a channel "technology", ie a channel driver 
-	See
+/*! \brief 
+	Structure to describe a channel "technology", ie a channel driver 
+	See for examples:
 	\arg chan_iax2.c - The Inter-Asterisk exchange protocol
 	\arg chan_sip.c - The SIP channel driver
 	\arg chan_zap.c - PSTN connectivity (TDM, PRI, T1/E1, FXO, FXS)
@@ -192,216 +186,175 @@
 	this driver supports and where different callbacks are 
 	implemented.
 */
-	
-
 struct ast_channel_tech {
 	const char * const type;
 	const char * const description;
 
-	/*! Bitmap of formats this channel can handle */
-	int capabilities;
+	int capabilities;		/*!< Bitmap of formats this channel can handle */
 
-	/*! Technology Properties */
-	int properties;
+	int properties;			/*!< Technology Properties */
 
-	/*! Requester - to set up call data structures (pvt's) */
+	/*! \brief Requester - to set up call data structures (pvt's) */
 	struct ast_channel *(* const requester)(const char *type, int format, void *data, int *cause);
 
-	/*! Devicestate call back */
-	int (* const devicestate)(void *data);
+	int (* const devicestate)(void *data);	/*!< Devicestate call back */
 
-	/*! Send a literal DTMF digit */
-	int (* const send_digit)(struct ast_channel *chan, char digit);
+	int (* const send_digit)(struct ast_channel *chan, char digit);	/*!< Send a literal DTMF digit */
 
-	/*! Start sending a literal DTMF digit */
+	/*! \brief Start sending a literal DTMF digit */
 	int (* const send_digit_begin)(struct ast_channel *chan, char digit);
 
-	/*! Stop sending the last literal DTMF digit */
+	/*! \brief Stop sending the last literal DTMF digit */
 	int (* const send_digit_end)(struct ast_channel *chan);
 
-	/*! Call a given phone number (address, etc), but don't
+	/*! \brief Call a given phone number (address, etc), but don't
 	   take longer than timeout seconds to do so.  */
 	int (* const call)(struct ast_channel *chan, char *addr, int timeout);
 
-	/*! Hangup (and possibly destroy) the channel */
+	/*! \brief Hangup (and possibly destroy) the channel */
 	int (* const hangup)(struct ast_channel *chan);
 
-	/*! Answer the channel */
+	/*! \brief Answer the channel */
 	int (* const answer)(struct ast_channel *chan);
 
-	/*! Read a frame, in standard format (see frame.h) */
+	/*! \brief Read a frame, in standard format (see frame.h) */
 	struct ast_frame * (* const read)(struct ast_channel *chan);
 
-	/*! Write a frame, in standard format (see frame.h) */
+	/*! \brief Write a frame, in standard format (see frame.h) */
 	int (* const write)(struct ast_channel *chan, struct ast_frame *frame);
 
-	/*! Display or transmit text */
+	/*! \brief Display or transmit text */
 	int (* const send_text)(struct ast_channel *chan, const char *text);
 
-	/*! Display or send an image */
+	/*! \brief Display or send an image */
 	int (* const send_image)(struct ast_channel *chan, struct ast_frame *frame);
 
-	/*! Send HTML data */
+	/*! \brief Send HTML data */
 	int (* const send_html)(struct ast_channel *chan, int subclass, const char *data, int len);
 
-	/*! Handle an exception, reading a frame */
+	/*! \brief Handle an exception, reading a frame */
 	struct ast_frame * (* const exception)(struct ast_channel *chan);
 
-	/*! Bridge two channels of the same type together */
+	/*! \brief Bridge two channels of the same type together */
 	enum ast_bridge_result (* const bridge)(struct ast_channel *c0, struct ast_channel *c1, int flags,
 						struct ast_frame **fo, struct ast_channel **rc, int timeoutms);
 
-	/*! Indicate a particular condition (e.g. AST_CONTROL_BUSY or AST_CONTROL_RINGING or AST_CONTROL_CONGESTION */
+	/*! \brief Indicate a particular condition (e.g. AST_CONTROL_BUSY or AST_CONTROL_RINGING or AST_CONTROL_CONGESTION */
 	int (* const indicate)(struct ast_channel *c, int condition, const void *data, size_t datalen);
 
-	/*! Fix up a channel:  If a channel is consumed, this is called.  Basically update any ->owner links */
+	/*! \brief Fix up a channel:  If a channel is consumed, this is called.  Basically update any ->owner links */
 	int (* const fixup)(struct ast_channel *oldchan, struct ast_channel *newchan);
 
-	/*! Set a given option */
+	/*! \brief Set a given option */
 	int (* const setoption)(struct ast_channel *chan, int option, void *data, int datalen);
 
-	/*! Query a given option */
+	/*! \brief Query a given option */
 	int (* const queryoption)(struct ast_channel *chan, int option, void *data, int *datalen);
 
-	/*! Blind transfer other side (see app_transfer.c and ast_transfer() */
+	/*! \brief Blind transfer other side (see app_transfer.c and ast_transfer() */
 	int (* const transfer)(struct ast_channel *chan, const char *newdest);
 
-	/*! Write a frame, in standard format */
+	/*! \brief Write a frame, in standard format */
 	int (* const write_video)(struct ast_channel *chan, struct ast_frame *frame);
 
-	/*! Find bridged channel */
+	/*! \brief Find bridged channel */
 	struct ast_channel *(* const bridged_channel)(struct ast_channel *chan, struct ast_channel *bridge);
 
-	/*! Provide additional items for CHANNEL() dialplan function */
+	/*! \brief Provide additional read items for CHANNEL() dialplan function */
 	int (* func_channel_read)(struct ast_channel *chan, char *function, char *data, char *buf, size_t len);
+
+	/*! \brief Provide additional write items for CHANNEL() dialplan function */
 	int (* func_channel_write)(struct ast_channel *chan, char *function, char *data, const char *value);
 };
 
 struct ast_channel_spy_list;
 
-/*! Main Channel structure associated with a channel. 
+#define	DEBUGCHAN_FLAG  0x80000000
+#define	FRAMECOUNT_INC(x)	( ((x) & DEBUGCHAN_FLAG) | ((x++) & ~DEBUGCHAN_FLAG) )
+
+
+/*! \brief Main Channel structure associated with a channel. 
  * This is the side of it mostly used by the pbx and call management.
  *
  * \note XXX It is important to remember to increment .cleancount each time
  *       this structure is changed. XXX
  */
 struct ast_channel {
-	/*! Technology (point to channel driver) */
+	/*! \brief Technology (point to channel driver) */
 	const struct ast_channel_tech *tech;
 
-	/*! Private data used by the technology driver */
+	/*! \brief Private data used by the technology driver */
 	void *tech_pvt;
 
 	AST_DECLARE_STRING_FIELDS(
-		AST_STRING_FIELD(name);			/*! ASCII unique channel name */
-		AST_STRING_FIELD(language);		/*! Language requested for voice prompts */
-		AST_STRING_FIELD(musicclass);		/*! Default music class */
-		AST_STRING_FIELD(accountcode);		/*! Account code for billing */
-		AST_STRING_FIELD(call_forward);		/*! Where to forward to if asked to dial on this interface */
-		AST_STRING_FIELD(uniqueid);		/*! Unique Channel Identifier */
+		AST_STRING_FIELD(name);			/*!< ASCII unique channel name */
+		AST_STRING_FIELD(language);		/*!< Language requested for voice prompts */
+		AST_STRING_FIELD(musicclass);		/*!< Default music class */
+		AST_STRING_FIELD(accountcode);		/*!< Account code for billing */
+		AST_STRING_FIELD(call_forward);		/*!< Where to forward to if asked to dial on this interface */
+		AST_STRING_FIELD(uniqueid);		/*!< Unique Channel Identifier */
 	);
 	
-	/*! File descriptor for channel -- Drivers will poll on these file descriptors, so at least one must be non -1.  */
+	/*! \brief File descriptor for channel -- Drivers will poll on these file descriptors, so at least one must be non -1.  */
 	int fds[AST_MAX_FDS];			
 
-	/*! Music State*/
-	void *music_state;
-	/*! Current generator data if there is any */
-	void *generatordata;
-	/*! Current active data generator */
-	struct ast_generator *generator;
+	void *music_state;				/*!< Music State*/
+	void *generatordata;				/*!< Current generator data if there is any */
+	struct ast_generator *generator;		/*!< Current active data generator */
 
-	/*! Who are we bridged to, if we're bridged. Who is proxying for us,
+	/*! \brief Who are we bridged to, if we're bridged. Who is proxying for us,
 	  if we are proxied (i.e. chan_agent).
 	  Do not access directly, use ast_bridged_channel(chan) */
 	struct ast_channel *_bridge;
-	/*! Channel that will masquerade as us */
-	struct ast_channel *masq;		
-	/*! Who we are masquerading as */
-	struct ast_channel *masqr;		
-	/*! Call Detail Record Flags */
-	int cdrflags;										   
-	/*! Whether or not we have been hung up...  Do not set this value
+	struct ast_channel *masq;			/*!< Channel that will masquerade as us */
+	struct ast_channel *masqr;			/*!< Who we are masquerading as */
+	int cdrflags;					/*!< Call Detail Record Flags */
+
+	/*! \brief Whether or not we have been hung up...  Do not set this value
 	    directly, use ast_softhangup */
 	int _softhangup;
-	/*! Non-zero, set to actual time when channel is to be hung up */
-	time_t	whentohangup;
-	/*! If anyone is blocking, this is them */
-	pthread_t blocker;			
-	/*! Lock, can be used to lock a channel for some operations */
-	ast_mutex_t lock;			
-	/*! Procedure causing blocking */
-	const char *blockproc;			
+	time_t	whentohangup;				/*!< Non-zero, set to actual time when channel is to be hung up */
+	pthread_t blocker;				/*!< If anyone is blocking, this is them */
+	ast_mutex_t lock;				/*!< Lock, can be used to lock a channel for some operations */
+	const char *blockproc;				/*!< Procedure causing blocking */
 
-	const char *appl;				/*! Current application */
-	const char *data;				/*! Data passed to current application */
+	const char *appl;				/*!< Current application */
+	const char *data;				/*!< Data passed to current application */
+	int fdno;					/*!< Which fd had an event detected on */
+	struct sched_context *sched;			/*!< Schedule context */
+	int streamid;					/*!< For streaming playback, the schedule ID */
+	struct ast_filestream *stream;			/*!< Stream itself. */
+	int vstreamid;					/*!< For streaming video playback, the schedule ID */
+	struct ast_filestream *vstream;			/*!< Video Stream itself. */
+	int oldwriteformat;				/*!< Original writer format */
 	
-	/*! Which fd had an event detected on */
-	int fdno;				
-	/*! Schedule context */
-	struct sched_context *sched;		
-	/*! For streaming playback, the schedule ID */
-	int streamid;				
-	/*! Stream itself. */
-	struct ast_filestream *stream;		
-	/*! For streaming video playback, the schedule ID */
-	int vstreamid;				
-	/*! Video Stream itself. */
-	struct ast_filestream *vstream;		
-	/*! Original writer format */
-	int oldwriteformat;			
-	
-	/*! Timing fd */
-	int timingfd;
+	int timingfd;					/*!< Timing fd */
 	int (*timingfunc)(void *data);
 	void *timingdata;
 
-	/*! State of line -- Don't write directly, use ast_setstate */
-	int _state;				
-	/*! Number of rings so far */
-	int rings;				
+	int _state;					/*!< State of line -- Don't write directly, use ast_setstate */
+	int rings;					/*!< Number of rings so far */
+	struct ast_callerid cid;			/*!< Caller ID, name, presentation etc */
+	char dtmfq[AST_MAX_EXTENSION];			/*!< Any/all queued DTMF characters */
+	struct ast_frame dtmff;				/*!< DTMF frame */
 
-	/*! Kinds of data this channel can natively handle */
-	int nativeformats;			
-	/*! Requested read format */
-	int readformat;				
-	/*! Requested write format */
-	int writeformat;			
+	char context[AST_MAX_CONTEXT];			/*!< Dialplan: Current extension context */
+	char exten[AST_MAX_EXTENSION];			/*!< Dialplan: Current extension number */
+	int priority;					/*!< Dialplan: Current extension priority */
+	char macrocontext[AST_MAX_CONTEXT];		/*!< Macro: Current non-macro context. See app_macro.c */
+	char macroexten[AST_MAX_EXTENSION];		/*!< Macro: Current non-macro extension. See app_macro.c */
+	int macropriority;				/*!< Macro: Current non-macro priority. See app_macro.c */
 
-	struct ast_callerid cid;
-		
-	/*! Current extension context */
-	char context[AST_MAX_CONTEXT];
-	/*! Current non-macro context */
-	char macrocontext[AST_MAX_CONTEXT];	
-	/*! Current non-macro extension */
-	char macroexten[AST_MAX_EXTENSION];
-	/*! Current non-macro priority */
-	int macropriority;
-	/*! Current extension number */
-	char exten[AST_MAX_EXTENSION];		
-	/* Current extension priority */
-	int priority;						
-	/*! Any/all queued DTMF characters */
-	char dtmfq[AST_MAX_EXTENSION];		
-	/*! DTMF frame */
-	struct ast_frame dtmff;			
+	struct ast_pbx *pbx;				/*!< PBX private structure for this channel */
+	int amaflags;					/*!< Set BEFORE PBX is started to determine AMA flags */
+	struct ast_cdr *cdr;				/*!< Call Detail Record */
+	int adsicpe;					/*!< Whether or not ADSI is detected on CPE */
 
-	/*! PBX private structure */
-	struct ast_pbx *pbx;
-	/*! Set BEFORE PBX is started to determine AMA flags */
-	int amaflags;			
-	/*! Call Detail Record */
-	struct ast_cdr *cdr;			
-	/*! Whether or not ADSI is detected on CPE */
-	int adsicpe;
+	struct tone_zone *zone;				/*!< Tone zone as set in indications.conf or
+								in the CHANNEL dialplan function */
 
-	/*! Tone zone as set in indications.conf */
-	struct tone_zone *zone;
+	struct ast_channel_monitor *monitor;		/*!< Channel monitoring */
 
-	/* Channel monitoring */
-	struct ast_channel_monitor *monitor;
-
 	/*! Track the read/written samples for monitor use */
 	unsigned long insmpl;
 	unsigned long outsmpl;
@@ -411,56 +364,37 @@
 	 */
 	unsigned int fin;
 	unsigned int fout;
-#define	DEBUGCHAN_FLAG  0x80000000
-#define	FRAMECOUNT_INC(x)	( ((x) & DEBUGCHAN_FLAG) | ((x++) & ~DEBUGCHAN_FLAG) )
-
-	/* Why is the channel hanged up */
-	int hangupcause;
-	
-	/* A linked list for variables */
-	struct varshead varshead;
-
-	unsigned int callgroup;
-	unsigned int pickupgroup;
-
-	/*! channel flags of AST_FLAG_ type */
-	unsigned int flags;
-	
-	/*! ISDN Transfer Capbility - AST_FLAG_DIGITAL is not enough */
-	unsigned short transfercapability;
-
+	int hangupcause;				/*!< Why is the channel hanged up. See causes.h */
+	struct varshead varshead;			/*!< A linked list for channel variables */
+	unsigned int callgroup;				/*!< Call group for call pickups */
+	unsigned int pickupgroup;			/*!< Pickup group - which calls groups can be picked up? */
+	unsigned int flags;				/*!< channel flags of AST_FLAG_ type */
+	unsigned short transfercapability;		/*!< ISDN Transfer Capbility - AST_FLAG_DIGITAL is not enough */
 	struct ast_frame *readq;
 	int alertpipe[2];
-	/*! Write translation path */
-	struct ast_trans_pvt *writetrans;
-	/*! Read translation path */
-	struct ast_trans_pvt *readtrans;
-	/*! Raw read format */
-	int rawreadformat;
-	/*! Raw write format */
-	int rawwriteformat;
 
-	/*! Chan Spy stuff */
-	struct ast_channel_spy_list *spies;
+	int nativeformats;				/*!< Kinds of data this channel can natively handle */
+	int readformat;					/*!< Requested read format */
+	int writeformat;				/*!< Requested write format */
+	struct ast_trans_pvt *writetrans;		/*!< Write translation path */
+	struct ast_trans_pvt *readtrans;		/*!< Read translation path */
+	int rawreadformat;				/*!< Raw read format */
+	int rawwriteformat;				/*!< Raw write format */
 
-	/*! Data stores on the channel */
-	AST_LIST_HEAD_NOLOCK(datastores, ast_datastore) datastores;
+	struct ast_channel_spy_list *spies;		/*!< Chan Spy stuff */
+	AST_LIST_ENTRY(ast_channel) chan_list;		/*!< For easy linking */
+	struct ast_jb jb;				/*!< The jitterbuffer state  */
 
-	/*! For easy linking */
-	AST_LIST_ENTRY(ast_channel) chan_list;
-
-	/*! The jitterbuffer state  */
-	struct ast_jb jb;
+	/*! \brief Data stores on the channel */
+	AST_LIST_HEAD_NOLOCK(datastores, ast_datastore) datastores;
 };
 
-/* \defgroup chanprop Channel tech properties:
+/*! \defgroup chanprop Channel tech properties:
 	\brief Channels have this property if they can accept input with jitter; i.e. most VoIP channels */
-/* @{ */
+/*! @{ */
 #define AST_CHAN_TP_WANTSJITTER	(1 << 0)	
 
-/* \defgroup chanprop Channel tech properties:
-	\brief Channels have this property if they can create jitter; i.e. most VoIP channels */
-/* @{ */
+/*! \brief Channels have this property if they can create jitter; i.e. most VoIP channels */
 #define AST_CHAN_TP_CREATESJITTER (1 << 1)
 
 /* This flag has been deprecated by the transfercapbilty data member in struct ast_channel */
@@ -656,7 +590,7 @@
 
 /*! \brief Requests a channel 
  * \param type type of channel to request
- * \param format requested channel format
+ * \param format requested channel format (codec)
  * \param data data to pass to the channel requester
  * \param status status
  * Request a channel of a given type, with data as optional information used 
@@ -1225,8 +1159,8 @@
 
 /* Misc. functions below */
 
-/* if fd is a valid descriptor, set *pfd with the descriptor
- * Return 1 (not -1!) if added, 0 otherwise (so we can add the
+/*! \brief if fd is a valid descriptor, set *pfd with the descriptor
+ * \return Return 1 (not -1!) if added, 0 otherwise (so we can add the
  * return value to the index into the array)
  */
 static inline int ast_add_fd(struct pollfd *pfd, int fd)
@@ -1236,7 +1170,7 @@
 	return fd >= 0;
 }
 
-/* Helper function for migrating select to poll */
+/*! \brief Helper function for migrating select to poll */
 static inline int ast_fdisset(struct pollfd *pfds, int fd, int max, int *start)
 {
 	int x;

Modified: trunk/include/asterisk/translate.h
===================================================================
--- trunk/include/asterisk/translate.h	2006-06-18 01:58:35 UTC (rev 239)
+++ trunk/include/asterisk/translate.h	2006-06-18 02:01:52 UTC (rev 240)
@@ -38,14 +38,15 @@
 
 struct ast_trans_pvt;	/* declared below */
 
-/*!
+/*! \brief
  * Descriptor of a translator. Name, callbacks, and various options
  * related to run-time operation (size of buffers, auxiliary
  * descriptors, etc).
+ *
  * A coded registers itself by filling the relevant fields
  * of a structure and passing it as an argument to
  * ast_register_translator(). The structure should not be
- * modified after a successful register(), and its address
+ * modified after a successful registration, and its address
  * must be used as an argument to ast_unregister_translator().
  *
  * As a minimum, a translator should supply name, srcfmt and dstfmt,
@@ -64,49 +65,52 @@
  * Generic plc is only available for dstfmt = SLINEAR
  */
 struct ast_translator {
-	const char name[80];		/*! Name of translator */
-	int srcfmt;			/*! Source format (note: bit position,
+	const char name[80];		/*!< Name of translator */
+	int srcfmt;			/*!< Source format (note: bit position,
 					  converted to index during registration) */
-	int dstfmt;			/*! Destination format (note: bit position,
+	int dstfmt;			/*!< Destination format (note: bit position,
 					  converted to index during registration) */
 
-	/*! initialize private data associated with the translator */
-	void *(*newpvt)(struct ast_trans_pvt *);
+	void *(*newpvt)(struct ast_trans_pvt *); /*!< initialize private data 
+					associated with the translator */
 
-	/*! Input frame callback. Store (and possibly convert) input frame. */
 	int (*framein)(struct ast_trans_pvt *pvt, struct ast_frame *in);
+					/*!< Input frame callback. Store 
+					     (and possibly convert) input frame. */
 
-	/*! Output frame callback. Generate a frame with outbuf content. */
 	struct ast_frame * (*frameout)(struct ast_trans_pvt *pvt);
+					/*!< Output frame callback. Generate a frame 
+					    with outbuf content. */
 
-	/*! cleanup private data, if needed (often unnecessary). */
 	void (*destroy)(struct ast_trans_pvt *pvt);
+					/*!< cleanup private data, if needed 
+						(often unnecessary). */
 
-	struct ast_frame * (*sample)(void);	/*! Generate an example frame */
+	struct ast_frame * (*sample)(void);	/*!< Generate an example frame */
 
-	/*! size of outbuf, in samples. Leave it 0 if you want the framein
+	/*! \brief size of outbuf, in samples. Leave it 0 if you want the framein
 	 * callback deal with the frame. Set it appropriately if you
 	 * want the code to checks if the incoming frame fits the
 	 * outbuf (this is e.g. required for plc).
 	 */
-	int buffer_samples;	/* size of outbuf, in samples */
+	int buffer_samples;	/*< size of outbuf, in samples */
 
-	/*! size of outbuf, in bytes. Mandatory. The wrapper code will also
+	/*! \brief size of outbuf, in bytes. Mandatory. The wrapper code will also
 	 * allocate an AST_FRIENDLY_OFFSET space before.
 	 */
 	int buf_size;
 
-	int desc_size;		/*! size of private descriptor in pvt->pvt, if any */
-	int plc_samples;	/* set to the plc block size if used, 0 otherwise */
-	int useplc;		/* current status of plc, changed at runtime */
+	int desc_size;		/*!< size of private descriptor in pvt->pvt, if any */
+	int plc_samples;	/*!< set to the plc block size if used, 0 otherwise */
+	int useplc;		/*!< current status of plc, changed at runtime */
 
-	void *module;		/* opaque reference to the parent module */
+	void *module;		/*!< opaque reference to the parent module */
 
-	int cost;		/*! Cost in milliseconds for encoding/decoding 1 second of sound */
-	AST_LIST_ENTRY(ast_translator) list;	/*! link field */
+	int cost;		/*!< Cost in milliseconds for encoding/decoding 1 second of sound */
+	AST_LIST_ENTRY(ast_translator) list;	/*!< link field */
 };
 
-/*
+/*! \brief
  * Default structure for translators, with the basic fields and buffers,
  * all allocated as part of the same chunk of memory. The buffer is
  * preceded by AST_FRIENDLY_OFFSET bytes in front of the user portion.
@@ -126,18 +130,18 @@
  */
 struct ast_trans_pvt {
 	struct ast_translator *t;
-	struct ast_frame f;	/* used in frameout */
-	int samples;		/* samples available in outbuf */
-	int datalen;		/* actual space used in outbuf */
-	void *pvt;		/* more private data, if any */
-	char *outbuf;		/* the useful portion of the buffer */
-	plc_state_t *plc;	/* optional plc pointer */
-	struct ast_trans_pvt *next;	/* next in translator chain */
+	struct ast_frame f;	/*!< used in frameout */
+	int samples;		/*!< samples available in outbuf */
+	int datalen;		/*!< actual space used in outbuf */
+	void *pvt;		/*!< more private data, if any */
+	char *outbuf;		/*!< the useful portion of the buffer */
+	plc_state_t *plc;	/*!< optional plc pointer */
+	struct ast_trans_pvt *next;	/*!< next in translator chain */
 	struct timeval nextin;
 	struct timeval nextout;
 };
 
-/* generic frameout function */
+/*! \brief generic frameout function */
 struct ast_frame *ast_trans_frameout(struct ast_trans_pvt *pvt,
         int datalen, int samples);
 
@@ -145,17 +149,17 @@
 
 /*!
  * \brief Register a translator
+ * This registers a codec translator with asterisk
  * \param t populated ast_translator structure
  * \param module handle to the module that owns this translator
- * This registers a codec translator with asterisk
  * \return 0 on success, -1 on failure
  */
 int ast_register_translator(struct ast_translator *t, void *module);
 
 /*!
  * \brief Unregister a translator
+ * Unregisters the given tranlator
  * \param t translator to unregister
- * Unregisters the given tranlator
  * \return 0 on success, -1 on failure
  */
 int ast_unregister_translator(struct ast_translator *t);
@@ -164,34 +168,35 @@
  * \brief Chooses the best translation path
  *
  * Given a list of sources, and a designed destination format, which should
- * I choose? Returns 0 on success, -1 if no path could be found.  Modifies
- * dests and srcs in place 
+ * I choose? 
+ * \return Returns 0 on success, -1 if no path could be found.  
+ * \note Modifies dests and srcs in place 
  */
 int ast_translator_best_choice(int *dsts, int *srcs);
 
 /*! 
  * \brief Builds a translator path
+ * Build a path (possibly NULL) from source to dest 
  * \param dest destination format
  * \param source source format
- * Build a path (possibly NULL) from source to dest 
  * \return ast_trans_pvt on success, NULL on failure
  * */
 struct ast_trans_pvt *ast_translator_build_path(int dest, int source);
 
 /*!
  * \brief Frees a translator path
+ * Frees the given translator path structure
  * \param tr translator path to get rid of
- * Frees the given translator path structure
  */
 void ast_translator_free_path(struct ast_trans_pvt *tr);
 
 /*!
  * \brief translates one or more frames
+ * Apply an input frame into the translator and receive zero or one output frames.  Consume
+ * determines whether the original frame should be freed
  * \param tr translator structure to use for translation
  * \param f frame to translate
  * \param consume Whether or not to free the original frame
- * Apply an input frame into the translator and receive zero or one output frames.  Consume
- * determines whether the original frame should be freed
  * \return an ast_frame of the new translation format on success, NULL on failure
  */
 struct ast_frame *ast_translate(struct ast_trans_pvt *tr, struct ast_frame *f, int consume);

Modified: trunk/translate.c
===================================================================
--- trunk/translate.c	2006-06-18 01:58:35 UTC (rev 239)
+++ trunk/translate.c	2006-06-18 02:01:52 UTC (rev 240)
@@ -67,13 +67,13 @@
  */
 static struct translator_path tr_matrix[MAX_FORMAT][MAX_FORMAT];
 
-/*
+/*! \todo
  * TODO: sample frames for each supported input format.
  * We build this on the fly, by taking an SLIN frame and using
  * the existing converter to play with it.
  */
 
-/* returns the index of the lowest bit set */
+/*! \brief returns the index of the lowest bit set */
 static int powerof(int d)
 {
 	int x;
@@ -146,9 +146,7 @@
 	ast_update_use_count();
 }
 
-/*
- * framein wrapper, deals with plc and bound checks.
- */
+/*! \brief framein wrapper, deals with plc and bound checks.  */
 static int framein(struct ast_trans_pvt *pvt, struct ast_frame *f)
 {
 	int16_t *dst = (int16_t *)pvt->outbuf;
@@ -200,8 +198,7 @@
         return ret;
 }
 
-/*
- * generic frameout routine.
+/*! \brief generic frameout routine.
  * If samples and datalen are 0, take whatever is in pvt
  * and reset them, otherwise take the values in the caller and
  * leave alone the pvt values.
@@ -251,7 +248,7 @@
 	}
 }
 
-/*! Build a chain of translators based upon the given source and dest formats */
+/*! \brief Build a chain of translators based upon the given source and dest formats */
 struct ast_trans_pvt *ast_translator_build_path(int dest, int source)
 {
 	struct ast_trans_pvt *head = NULL, *tail = NULL;
@@ -545,6 +542,7 @@
 static struct ast_cli_entry show_trans =
 { { "show", "translation", NULL }, show_translation, "Display translation matrix", show_trans_usage };
 
+/*! \brief register codec translator */
 int ast_register_translator(struct ast_translator *t, void *module)
 {
 	static int added_cli = 0;



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 04:07:54 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 04:07:54 +0200
Subject: [solid-pbx-svn] r241 - trunk/apps
Message-ID: <200606180207.k5I27s0C029688@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 04:07:42 +0200 (Sun, 18 Jun 2006)
New Revision: 241

Modified:
   trunk/apps/app_dumpchan.c
Log:
Update to Asterisk SVN trunk r32003

------------------------------------------------------------------------
r32003 | oej | 2006-06-04 13:00:12 +0200 (Sun, 04 Jun 2006) | 2 lines

Add formats in text form to dumpchan()

------------------------------------------------------------------------


Modified: trunk/apps/app_dumpchan.c
===================================================================
--- trunk/apps/app_dumpchan.c	2006-06-18 02:01:52 UTC (rev 240)
+++ trunk/apps/app_dumpchan.c	2006-06-18 02:07:42 UTC (rev 241)
@@ -62,8 +62,9 @@
 	struct timeval now;
 	long elapsed_seconds=0;
 	int hour=0, min=0, sec=0;
-	char cgrp[256];
-	char pgrp[256];
+	char cgrp[BUFSIZ/2];
+	char pgrp[BUFSIZ/2];
+	char formatbuf[BUFSIZ/2];
 	
 	now = ast_tvnow();
 	memset(buf,0,size);
@@ -86,9 +87,9 @@
 			 "DNIDDigits=         %s\n"
 			 "State=              %s (%d)\n"
 			 "Rings=              %d\n"
-			 "NativeFormat=       %d\n"
-			 "WriteFormat=        %d\n"
-			 "ReadFormat=         %d\n"
+			 "NativeFormat=       %d %s\n"
+			 "WriteFormat=        %d %s\n"
+			 "ReadFormat=         %d %s\n"
 			 "1stFileDescriptor=  %d\n"
 			 "Framesin=           %d %s\n"
 			 "Framesout=          %d %s\n"
@@ -112,8 +113,11 @@
 			 c->_state,
 			 c->rings,
 			 c->nativeformats,
+			 ast_getformatname_multiple(formatbuf, sizeof(formatbuf), c->nativeformats),
 			 c->writeformat,
+			 ast_getformatname_multiple(formatbuf, sizeof(formatbuf), c->writeformat),
 			 c->readformat,
+			 ast_getformatname_multiple(formatbuf, sizeof(formatbuf), c->readformat),
 			 c->fds[0], c->fin & ~DEBUGCHAN_FLAG, (c->fin & DEBUGCHAN_FLAG) ? " (DEBUGGED)" : "",
 			 c->fout & ~DEBUGCHAN_FLAG, (c->fout & DEBUGCHAN_FLAG) ? " (DEBUGGED)" : "", (long)c->whentohangup,
 			 hour,



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 04:26:49 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 04:26:49 +0200
Subject: [solid-pbx-svn] r242 - in trunk: apps channels funcs
Message-ID: <200606180226.k5I2QncM001861@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 04:25:55 +0200 (Sun, 18 Jun 2006)
New Revision: 242

Modified:
   trunk/apps/app_dumpchan.c
   trunk/channels/chan_sip.c
   trunk/funcs/func_channel.c
Log:
Update to Asterisk SVN trunk r32023

------------------------------------------------------------------------
r32017 | oej | 2006-06-04 13:09:14 +0200 (Sun, 04 Jun 2006) | 3 lines

- Typo in chan_sip (: missing)
- Only print formats once in dumpchan()

------------------------------------------------------------------------
r32018 | oej | 2006-06-04 13:47:51 +0200 (Sun, 04 Jun 2006) | 2 lines

Make tonezone writeable in CHANNEL() (from my old func_tonezone.c)

------------------------------------------------------------------------


Modified: trunk/apps/app_dumpchan.c
===================================================================
--- trunk/apps/app_dumpchan.c	2006-06-18 02:07:42 UTC (rev 241)
+++ trunk/apps/app_dumpchan.c	2006-06-18 02:25:55 UTC (rev 242)
@@ -87,9 +87,9 @@
 			 "DNIDDigits=         %s\n"
 			 "State=              %s (%d)\n"
 			 "Rings=              %d\n"
-			 "NativeFormat=       %d %s\n"
-			 "WriteFormat=        %d %s\n"
-			 "ReadFormat=         %d %s\n"
+			 "NativeFormat=       %s\n"
+			 "WriteFormat=        %s\n"
+			 "ReadFormat=         %s\n"
 			 "1stFileDescriptor=  %d\n"
 			 "Framesin=           %d %s\n"
 			 "Framesout=          %d %s\n"
@@ -112,11 +112,8 @@
 			 ast_state2str(c->_state),
 			 c->_state,
 			 c->rings,
-			 c->nativeformats,
 			 ast_getformatname_multiple(formatbuf, sizeof(formatbuf), c->nativeformats),
-			 c->writeformat,
 			 ast_getformatname_multiple(formatbuf, sizeof(formatbuf), c->writeformat),
-			 c->readformat,
 			 ast_getformatname_multiple(formatbuf, sizeof(formatbuf), c->readformat),
 			 c->fds[0], c->fin & ~DEBUGCHAN_FLAG, (c->fin & DEBUGCHAN_FLAG) ? " (DEBUGGED)" : "",
 			 c->fout & ~DEBUGCHAN_FLAG, (c->fout & DEBUGCHAN_FLAG) ? " (DEBUGGED)" : "", (long)c->whentohangup,

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 02:07:42 UTC (rev 241)
+++ trunk/channels/chan_sip.c	2006-06-18 02:25:55 UTC (rev 242)
@@ -9257,7 +9257,7 @@
 			ast_cli(fd, "  Non-Codec Capability (DTMF):   %d\n", cur->noncodeccapability);
 			ast_cli(fd, "  Their Codec Capability:   %d\n", cur->peercapability);
 			ast_cli(fd, "  Joint Codec Capability:   %d\n", cur->jointcapability);
-			ast_cli(fd, "  Format                  %s\n", ast_getformatname_multiple(formatbuf, sizeof(formatbuf), cur->owner ? cur->owner->nativeformats : 0) );
+			ast_cli(fd, "  Format:                 %s\n", ast_getformatname_multiple(formatbuf, sizeof(formatbuf), cur->owner ? cur->owner->nativeformats : 0) );
 			ast_cli(fd, "  Theoretical Address:    %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), cur->sa.sin_addr), ntohs(cur->sa.sin_port));
 			ast_cli(fd, "  Received Address:       %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), cur->recv.sin_addr), ntohs(cur->recv.sin_port));
 			ast_cli(fd, "  SIP Transfer mode:      %s\n", transfermode2str(cur->allowtransfer));

Modified: trunk/funcs/func_channel.c
===================================================================
--- trunk/funcs/func_channel.c	2006-06-18 02:07:42 UTC (rev 241)
+++ trunk/funcs/func_channel.c	2006-06-18 02:25:55 UTC (rev 242)
@@ -108,7 +108,14 @@
 		locked_string_field_set(chan, language, value);
 	else if (!strcasecmp(data, "musicclass"))
 		locked_string_field_set(chan, musicclass, value);
-	else if (!strcasecmp(data, "callgroup"))
+	else if (!strcasecmp(data, "tonezone")) {
+		struct tone_zone *new_zone;
+		if (!(new_zone = ast_get_indication_zone(data))) {
+			ast_log(LOG_ERROR, "Unknown country code for tonezone. Check indications.conf for available country codes.\n");
+			ret = -1;	
+		} else 
+			chan->zone = new_zone;
+	} else if (!strcasecmp(data, "callgroup"))
 		chan->callgroup = ast_get_group(data);
 	else if (!strcasecmp(data, "txgain")) {
 		sscanf(value, "%hhd", &gainset);
@@ -149,7 +156,7 @@
 		"R/W	musicclass 		class (from musiconhold.conf) for hold music\n"
 		"R/W	rxgain			set rxgain level on channel drivers that support it\n"
 		"R/O	state			state for channel\n"
-		"R/O	tonezone 		zone for indications played\n"
+		"R/W	tonezone 		zone for indications played\n"
 		"R/W	txgain			set txgain level on channel drivers that support it\n"
 		"R/O	videonativeformat 	format used natively for video\n"
 		"\n"



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 04:37:32 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 04:37:32 +0200
Subject: [solid-pbx-svn] r243 - trunk/res
Message-ID: <200606180237.k5I2bWWU004274@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 04:37:24 +0200 (Sun, 18 Jun 2006)
New Revision: 243

Modified:
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r32043

------------------------------------------------------------------------
r32040 | mogorman | 2006-06-04 18:56:16 +0200 (Sun, 04 Jun 2006) | 2 lines

solves some issues with jabberstatus app

------------------------------------------------------------------------


Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-18 02:25:55 UTC (rev 242)
+++ trunk/res/res_jabber.c	2006-06-18 02:37:24 UTC (rev 243)
@@ -325,7 +325,11 @@
 		return -1;
 	}
 
-	resource = strsep(&screenname, "/");
+	if(!strchr(screename, '/')) {
+		resource = NULL;
+	} else {
+		resource = strsep(&screenname, "/");
+	}
 
 	client = ast_aji_get_client(sender);
 	if (!client) {
@@ -347,16 +351,12 @@
 					while (r) {
 						if (!strcasecmp(r->resource, resource)) {
 							stat = r->status; 
-							break;
 						}
 						r = r->next;
 					}
-					if(stat != 7) break;
-					ast_log(LOG_WARNING, "Resource not found %s\n", resource);
-					break;
+					if (stat == 7) ast_log(LOG_NOTICE, "Resource not found %s\n", resource);
 				} else {
 					stat = r->status; 
-					break;
 				}
 			}
 		}



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 05:25:35 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 05:25:35 +0200
Subject: [solid-pbx-svn] r244 - trunk/res
Message-ID: <200606180325.k5I3PZ7m020861@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 05:25:30 +0200 (Sun, 18 Jun 2006)
New Revision: 244

Modified:
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r32053

------------------------------------------------------------------------
r32046 | mogorman | 2006-06-04 19:00:59 +0200 (Sun, 04 Jun 2006) | 2 lines

oops

------------------------------------------------------------------------


Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-18 02:37:24 UTC (rev 243)
+++ trunk/res/res_jabber.c	2006-06-18 03:25:30 UTC (rev 244)
@@ -325,7 +325,7 @@
 		return -1;
 	}
 
-	if(!strchr(screename, '/')) {
+	if(!strchr(screenname, '/')) {
 		resource = NULL;
 	} else {
 		resource = strsep(&screenname, "/");



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 06:25:17 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 06:25:17 +0200
Subject: [solid-pbx-svn] r245 - trunk/configs
Message-ID: <200606180425.k5I4PHak006806@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 06:25:15 +0200 (Sun, 18 Jun 2006)
New Revision: 245

Modified:
   trunk/configs/jabber.conf.sample
Log:
Update to Asterisk SVN trunk r32063

------------------------------------------------------------------------
r32063 | mogorman | 2006-06-04 19:07:09 +0200 (Sun, 04 Jun 2006) | 2 lines

oops fixing example config

------------------------------------------------------------------------


Modified: trunk/configs/jabber.conf.sample
===================================================================
--- trunk/configs/jabber.conf.sample	2006-06-18 03:25:30 UTC (rev 244)
+++ trunk/configs/jabber.conf.sample	2006-06-18 04:25:15 UTC (rev 245)
@@ -1,7 +1,7 @@
 [general]
 ;debug=yes				;;Turn on debugging by default.
-;autoprune=yes				;;Auto remove users from buddy list.
-;autoregister=yes			;;Auto register users from buddy list. 
+;noautoprune=yes			;;Disables auto remove users from buddy list.
+;noautoregister=yes			;;Disable auto register users from buddy list. 
 
 ;[asterisk]				;;label
 ;type=client				;;Client or Component connection



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 07:26:15 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 07:26:15 +0200
Subject: [solid-pbx-svn] r246 - in trunk: channels configs
Message-ID: <200606180526.k5I5QFTw027817@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 07:25:28 +0200 (Sun, 18 Jun 2006)
New Revision: 246

Modified:
   trunk/channels/chan_sip.c
   trunk/configs/jabber.conf.sample
Log:
Update to Asterisk SVN trunk r32073

------------------------------------------------------------------------
r32064 | mogorman | 2006-06-04 19:08:18 +0200 (Sun, 04 Jun 2006) | 2 lines

oops my config file was out of date not the sample

------------------------------------------------------------------------
r32065 | oej | 2006-06-04 19:35:30 +0200 (Sun, 04 Jun 2006) | 2 lines

Show max bitrate in "sip show user" and "sip show channel"

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 04:25:15 UTC (rev 245)
+++ trunk/channels/chan_sip.c	2006-06-18 05:25:28 UTC (rev 246)
@@ -8675,7 +8675,7 @@
 		ast_cli(fd, "  Call limit   : %d\n", peer->call_limit);
 		ast_cli(fd, "  Dynamic      : %s\n", (ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC)?"Yes":"No"));
 		ast_cli(fd, "  Callerid     : %s\n", ast_callerid_merge(cbuf, sizeof(cbuf), peer->cid_name, peer->cid_num, "<unspecified>"));
-		ast_cli(fd, "  MaxCallBR    : %dkbps\n", peer->maxcallbitrate);
+		ast_cli(fd, "  MaxCallBR    : %d kbps\n", peer->maxcallbitrate);
 		ast_cli(fd, "  Expire       : %d\n", peer->expire);
 		ast_cli(fd, "  Insecure     : %s\n", insecure2str(ast_test_flag(&peer->flags[0], SIP_INSECURE_PORT), ast_test_flag(&peer->flags[0], SIP_INSECURE_INVITE)));
 		ast_cli(fd, "  Nat          : %s\n", nat2str(ast_test_flag(&peer->flags[0], SIP_NAT)));
@@ -8757,7 +8757,7 @@
 		astman_append(s, "TransferMode: %s\r\n", transfermode2str(peer->allowtransfer));
 		astman_append(s, "LastMsgsSent: %d\r\n", peer->lastmsgssent);
 		astman_append(s, "Call limit: %d\r\n", peer->call_limit);
-		astman_append(s, "MaxCallBR: %dkbps\r\n", peer->maxcallbitrate);
+		astman_append(s, "MaxCallBR: %d kbps\r\n", peer->maxcallbitrate);
 		astman_append(s, "Dynamic: %s\r\n", (ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC)?"Y":"N"));
 		astman_append(s, "Callerid: %s\r\n", ast_callerid_merge(cbuf, sizeof(cbuf), peer->cid_name, peer->cid_num, ""));
 		astman_append(s, "RegExpire: %ld seconds\r\n", ast_sched_when(sched,peer->expire));
@@ -8842,6 +8842,7 @@
 			ast_cli(fd, "  Accountcode  : %s\n", user->accountcode);
 		ast_cli(fd, "  AMA flags    : %s\n", ast_cdr_flags2str(user->amaflags));
 		ast_cli(fd, "  Transfer mode: %s\n", transfermode2str(user->allowtransfer));
+		ast_cli(fd, "  MaxCallBR    : %d kbps\n", user->maxcallbitrate);
 		ast_cli(fd, "  CallingPres  : %s\n", ast_describe_caller_presentation(user->callingpres));
 		ast_cli(fd, "  Call limit   : %d\n", user->call_limit);
 		ast_cli(fd, "  Callgroup    : ");
@@ -8973,7 +8974,7 @@
 	ast_cli(fd, "  Outbound reg. attempts: %d\n", global_regattempts_max);
 	ast_cli(fd, "  Notify ringing state:   %s\n", global_notifyringing ? "Yes" : "No");
 	ast_cli(fd, "  SIP Transfer mode:      %s\n", transfermode2str(global_allowtransfer));
-	ast_cli(fd, "  Max Call Bitrate:       %dkbps\r\n", default_maxcallbitrate);
+	ast_cli(fd, "  Max Call Bitrate:       %d kbps\r\n", default_maxcallbitrate);
 	ast_cli(fd, "\nDefault Settings:\n");
 	ast_cli(fd, "-----------------\n");
 	ast_cli(fd, "  Context:                %s\n", default_context);
@@ -9258,6 +9259,7 @@
 			ast_cli(fd, "  Their Codec Capability:   %d\n", cur->peercapability);
 			ast_cli(fd, "  Joint Codec Capability:   %d\n", cur->jointcapability);
 			ast_cli(fd, "  Format:                 %s\n", ast_getformatname_multiple(formatbuf, sizeof(formatbuf), cur->owner ? cur->owner->nativeformats : 0) );
+			ast_cli(fd, "  MaxCallBR:              %d kbps\n", cur->maxcallbitrate);
 			ast_cli(fd, "  Theoretical Address:    %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), cur->sa.sin_addr), ntohs(cur->sa.sin_port));
 			ast_cli(fd, "  Received Address:       %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), cur->recv.sin_addr), ntohs(cur->recv.sin_port));
 			ast_cli(fd, "  SIP Transfer mode:      %s\n", transfermode2str(cur->allowtransfer));

Modified: trunk/configs/jabber.conf.sample
===================================================================
--- trunk/configs/jabber.conf.sample	2006-06-18 04:25:15 UTC (rev 245)
+++ trunk/configs/jabber.conf.sample	2006-06-18 05:25:28 UTC (rev 246)
@@ -1,7 +1,7 @@
 [general]
 ;debug=yes				;;Turn on debugging by default.
-;noautoprune=yes			;;Disables auto remove users from buddy list.
-;noautoregister=yes			;;Disable auto register users from buddy list. 
+;autoprune=yes				;;Auto remove users from buddy list.
+;autoregister=yes			;;Auto register users from buddy list. 
 
 ;[asterisk]				;;label
 ;type=client				;;Client or Component connection



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 08:25:39 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 08:25:39 +0200
Subject: [solid-pbx-svn] r247 - in trunk: . channels
Message-ID: <200606180625.k5I6PdT1014822@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 08:25:33 +0200 (Sun, 18 Jun 2006)
New Revision: 247

Modified:
   trunk/channel.c
   trunk/channels/chan_sip.c
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32093

------------------------------------------------------------------------
r32087 | oej | 2006-06-04 20:35:29 +0200 (Sun, 04 Jun 2006) | 3 lines

- Doxygen fix
- Debug message change

------------------------------------------------------------------------
r32088 | oej | 2006-06-04 20:55:16 +0200 (Sun, 04 Jun 2006) | 3 lines

- 5 is the highest used debug level, so let's stay there
- Change formatting of RTP debug to align better

------------------------------------------------------------------------
r32089 | oej | 2006-06-04 20:58:27 +0200 (Sun, 04 Jun 2006) | 2 lines

Fix potential bug. THanks luigi!

------------------------------------------------------------------------


Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-18 05:25:28 UTC (rev 246)
+++ trunk/channel.c	2006-06-18 06:25:33 UTC (rev 247)
@@ -2097,7 +2097,7 @@
 int ast_internal_timing_enabled(struct ast_channel *chan)
 {
 	int ret = ast_opt_internal_timing && chan->timingfd > -1;
-	if (option_debug > 20)
+	if (option_debug > 4)
 		ast_log(LOG_DEBUG, "Internal timing is %s (option_internal_timing=%d chan->timingfd=%d)\n", ret? "enabled": "disabled", ast_opt_internal_timing, chan->timingfd);
 	return ret;
 }

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 05:25:28 UTC (rev 246)
+++ trunk/channels/chan_sip.c	2006-06-18 06:25:33 UTC (rev 247)
@@ -805,7 +805,8 @@
 	int jointcapability;			/*!< Supported capability at both ends (codecs ) */
 	int peercapability;			/*!< Supported peer capability */
 	int prefcodec;				/*!< Preferred codec (outbound only) */
-	int noncodeccapability;
+	int noncodeccapability;			/*!< DTMF RFC2833 telephony-event */
+	int redircodecs;			/*!< Redirect codecs */
 	int maxcallbitrate;			/*!< Maximum Call Bitrate for Video Calls */	
 	int callingpres;			/*!< Calling presentation */
 	int authtries;				/*!< Times we've tried to authenticate */
@@ -817,7 +818,6 @@
 	struct sockaddr_in sa;			/*!< Our peer */
 	struct sockaddr_in redirip;		/*!< Where our RTP should be going if not to us */
 	struct sockaddr_in vredirip;		/*!< Where our Video RTP should be going if not to us */
-	int redircodecs;			/*!< Redirect codecs */
 	struct sockaddr_in recv;		/*!< Received as */
 	struct in_addr ourip;			/*!< Our IP */
 	struct ast_channel *owner;		/*!< Who owns us */
@@ -7329,12 +7329,8 @@
 			ast_uri_decode(referdata->replaces_callid);
 			if ((ptr = strchr(referdata->replaces_callid, ';'))) 	/* Remove options */ {
 				*ptr = '\0';
+				ptr++;
 			}
-			/*
-			 * XXX don't know what was the intention but this code is
-			 * definitely wrong, as ptr can be NULL here.
-			 */
-			ptr++;
 
 			/* Find the different tags before we destroy the string */
 			to = strcasestr(ptr, "to-tag=");

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 05:25:28 UTC (rev 246)
+++ trunk/rtp.c	2006-06-18 06:25:33 UTC (rev 247)
@@ -786,8 +786,8 @@
 	}
 
 	if(rtp_debug_test_addr(&sin))
-		ast_verbose("Got RTP packet from %s:%d (type %d, seq %d, ts %d, len %d)\n"
-			, ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
+		ast_verbose("Got  RTP packet from %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
+			ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
 
    	rtpPT = ast_rtp_lookup_pt(rtp, payloadtype);
 	if (!rtpPT.isAstFormat) {
@@ -1573,7 +1573,7 @@
 					ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr),
 					ntohs(rtp->them.sin_port), strerror(errno));
 			if (rtp_debug_test_addr(&rtp->them))
-				ast_verbose("Sent RTP packet to %s:%d (type %d, seq %u, ts %u, len %u)\n",
+				ast_verbose("Sent RTP DTMF packet to %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 					    ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr),
 					    ntohs(rtp->them.sin_port), payload, rtp->seqno, rtp->lastdigitts, res - hdrlen);
 		}
@@ -1719,8 +1719,8 @@
 		}
 				
 		if(rtp_debug_test_addr(&rtp->them))
-			ast_verbose("Sent RTP packet to %s:%d (type %d, seq %u, ts %u, len %u)\n"
-					, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), codec, rtp->seqno, rtp->lastts,res - hdrlen);
+			ast_verbose("Sent RTP packet to   %s:%d (type %d, seq %u, ts %u, len %u)\n",
+				ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), codec, rtp->seqno, rtp->lastts,res - hdrlen);
 	}
 
 	rtp->seqno++;



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 09:25:27 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 09:25:27 +0200
Subject: [solid-pbx-svn] r248 - trunk/channels
Message-ID: <200606180725.k5I7PR3U006825@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 09:25:24 +0200 (Sun, 18 Jun 2006)
New Revision: 248

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r32113

------------------------------------------------------------------------
r32111 | oej | 2006-06-04 21:18:24 +0200 (Sun, 04 Jun 2006) | 2 lines

Respond to some of Luigis questions...

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 06:25:33 UTC (rev 247)
+++ trunk/channels/chan_sip.c	2006-06-18 07:25:24 UTC (rev 248)
@@ -11219,7 +11219,8 @@
 			ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 		return -1;
 	} else {
-		/* XXX reduce nesting depth */
+		/* Save nesting depth for now, since there might be other events we will
+			support in the future */
 
 		/* Handle REFER notifications */
 
@@ -11319,13 +11320,6 @@
 		transmit_response(p, "200 OK", req);
 		return res;
 	};
-
-	/* XXX hey, we never reach this code! */
-	/* THis could be voicemail notification */
-	transmit_response(p, "200 OK", req);
-	if (!p->lastinvite) 
-		ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
-	return res;
 }
 
 /*! \brief Handle incoming OPTIONS request */
@@ -11603,15 +11597,6 @@
 		/* Skip leading whitespace */
 		replace_id = ast_skip_blanks(replace_id);
 
-		/* XXX there are several bugs in the code below,
-		 * because 'ptr' can be NULL so all the dereferences in strcasestr()
-		 * would cause panics.
-		 * I think we should do something like the code below, which also has
-		 * the advantage of not depending on the order of headers.
-		 * Please test if it works, and in case remove the block in #else / #endif
-		 */
-#if 1	/* proposed replacement */
-
 		start = replace_id;
 		while ( (ptr = strsep(&start, ";")) ) {
 			ptr = ast_skip_blanks(ptr); /* XXX maybe unnecessary ? */
@@ -11622,35 +11607,7 @@
 				fromtag = strsep(&fromtag, "&"); /* trim what ? */
 			}
 		}
-#else	/* original code, buggy */
-		if ((ptr = strchr(replace_id, ';'))) {
-			*ptr = '\0';
-			ptr++;
-		}
-		start = ptr;
 
-		to = strcasestr(ptr, "to-tag=");
-		if (to) {
-			ptr = to + 7;
-			totag = ptr;
-			if ((to = strchr(ptr, ';')))
-				*to = '\0';
-			/* XXX this code is also wrong as to can be NULL */
-			to++;
-			ptr = to;
-		}
-
-		to = strcasestr(ptr, "from-tag=");
-		if (to) {
-			ptr = to + 9;
-			fromtag = ptr;
-			if ((to = strchr(ptr, '&')))
-				*to = '\0';
-			if ((to = strchr(ptr, ';')))
-				*to = '\0';
-		}
-#endif
-
 		if (sipdebug && option_debug > 3) 
 			ast_log(LOG_DEBUG,"Invite/replaces: Will use Replace-Call-ID : %s Fromtag: %s Totag: %s\n", replace_id, fromtag ? fromtag : "<no from tag>", totag ? totag : "<no to tag>");
 



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 10:25:30 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 10:25:30 +0200
Subject: [solid-pbx-svn] r249 - trunk
Message-ID: <200606180825.k5I8PUu5015558@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 10:25:28 +0200 (Sun, 18 Jun 2006)
New Revision: 249

Modified:
   trunk/cli.c
Log:
Update to Asterisk SVN trunk r32123

------------------------------------------------------------------------
r32115 | oej | 2006-06-04 21:38:05 +0200 (Sun, 04 Jun 2006) | 2 lines

- Add information about transcoding to "show channel"

------------------------------------------------------------------------


Modified: trunk/cli.c
===================================================================
--- trunk/cli.c	2006-06-18 07:25:24 UTC (rev 248)
+++ trunk/cli.c	2006-06-18 08:25:28 UTC (rev 249)
@@ -702,6 +702,8 @@
 		"  NativeFormats: %s\n"
 		"    WriteFormat: %s\n"
 		"     ReadFormat: %s\n"
+		" WriteTranscode: %s\n"
+		"  ReadTranscode: %s\n"
 		"1st File Descriptor: %d\n"
 		"      Frames in: %d%s\n"
 		"     Frames out: %d%s\n"
@@ -725,6 +727,8 @@
 		ast_getformatname_multiple(nf, sizeof(nf), c->nativeformats), 
 		ast_getformatname_multiple(wf, sizeof(wf), c->writeformat), 
 		ast_getformatname_multiple(rf, sizeof(rf), c->readformat),
+		c->writetrans ? "Yes" : "No",
+		c->readtrans ? "Yes" : "No",
 		c->fds[0],
 		c->fin & ~DEBUGCHAN_FLAG, (c->fin & DEBUGCHAN_FLAG) ? " (DEBUGGED)" : "",
 		c->fout & ~DEBUGCHAN_FLAG, (c->fout & DEBUGCHAN_FLAG) ? " (DEBUGGED)" : "",



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 11:25:24 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 11:25:24 +0200
Subject: [solid-pbx-svn] r250 - trunk/channels
Message-ID: <200606180925.k5I9POeC032328@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 11:25:23 +0200 (Sun, 18 Jun 2006)
New Revision: 250

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r32143

------------------------------------------------------------------------
r32137 | oej | 2006-06-04 23:01:13 +0200 (Sun, 04 Jun 2006) | 3 lines

- Fix more problems in transfer code (thanks Tholo!)
- Add debug for hangup not in UP state

------------------------------------------------------------------------
r32138 | oej | 2006-06-04 23:13:48 +0200 (Sun, 04 Jun 2006) | 2 lines

Code simplification

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 08:25:28 UTC (rev 249)
+++ trunk/channels/chan_sip.c	2006-06-18 09:25:23 UTC (rev 250)
@@ -2908,8 +2908,11 @@
 		return 0;
 	}
 	/* If the call is not UP, we need to send CANCEL instead of BYE */
-	if (ast->_state != AST_STATE_UP)
+	if (ast->_state != AST_STATE_UP) {
 		needcancel = TRUE;
+		if (option_debug > 3)
+			ast_log(LOG_DEBUG, "Hanging up channel in state %s (not UP)\n", ast_state2str(ast->_state));
+	}
 
 	/* Disconnect */
 	p = ast->tech_pvt;
@@ -7318,23 +7321,23 @@
 
 	/* Check for arguments in the refer_to header */
 	if ((ptr = strchr(refer_to, '?'))) { /* Search for arguments */
-		*ptr = '\0';
-		ptr++;
+		*ptr++ = '\0';
 		if (!strncasecmp(ptr, "REPLACES=", 9)) {
-			char *to, *from;
+			char *to = NULL, *from = NULL;
 
 			/* This is an attended transfer */
 			referdata->attendedtransfer = 1;
 			strncpy(referdata->replaces_callid, ptr+9, sizeof(referdata->replaces_callid));
 			ast_uri_decode(referdata->replaces_callid);
-			if ((ptr = strchr(referdata->replaces_callid, ';'))) 	/* Remove options */ {
-				*ptr = '\0';
-				ptr++;
+			if ((ptr = strchr(referdata->replaces_callid, ';'))) 	/* Find options */ {
+				*ptr++ = '\0';
 			}
 
-			/* Find the different tags before we destroy the string */
-			to = strcasestr(ptr, "to-tag=");
-			from = strcasestr(ptr, "from-tag=");
+			if (ptr) {
+				/* Find the different tags before we destroy the string */
+				to = strcasestr(ptr, "to-tag=");
+				from = strcasestr(ptr, "from-tag=");
+			}
 
 			/* Grab the to header */
 			if (to) {
@@ -13470,14 +13473,9 @@
 		ext = tmp;
 	} else {
 		ext = strchr(tmp, '/');
-		if (ext) {
+		if (ext) 
 			*ext++ = '\0';
-			host = tmp;
-		}
-		else {
-			host = tmp;
-			ext = NULL;
-		}
+		host = tmp;
 	}
 
 	if (create_addr(p, host)) {



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 12:25:22 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 12:25:22 +0200
Subject: [solid-pbx-svn] r251 - trunk/include/asterisk
Message-ID: <200606181025.k5IAPMu3013830@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 12:25:21 +0200 (Sun, 18 Jun 2006)
New Revision: 251

Modified:
   trunk/include/asterisk/stringfields.h
Log:
Update to Asterisk SVN trunk r32163

------------------------------------------------------------------------
r32161 | russell | 2006-06-05 06:51:10 +0200 (Mon, 05 Jun 2006) | 2 lines

fix a typo in the documentation of how to use string fields

------------------------------------------------------------------------


Modified: trunk/include/asterisk/stringfields.h
===================================================================
--- trunk/include/asterisk/stringfields.h	2006-06-18 09:25:23 UTC (rev 250)
+++ trunk/include/asterisk/stringfields.h	2006-06-18 10:25:21 UTC (rev 251)
@@ -47,7 +47,7 @@
   
   sample = calloc(1, sizeof(*sample));
   if (sample) {
-	  if (!ast_string_field_init(sample)) {
+	  if (!ast_string_field_init(sample, 256)) {
 		  free(sample);
 		  sample = NULL;
 	  }



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 13:25:30 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 13:25:30 +0200
Subject: [solid-pbx-svn] r252 - trunk/channels
Message-ID: <200606181125.k5IBPUOJ000711@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 13:25:25 +0200 (Sun, 18 Jun 2006)
New Revision: 252

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r32183

------------------------------------------------------------------------
r32183 | oej | 2006-06-05 08:23:22 +0200 (Mon, 05 Jun 2006) | 2 lines

Only override callingpres set by rpid if user/peer preference is set. (Issue #7240)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 10:25:21 UTC (rev 251)
+++ trunk/channels/chan_sip.c	2006-06-18 11:25:25 UTC (rev 252)
@@ -7739,7 +7739,8 @@
 			p->amaflags = user->amaflags;
 			p->callgroup = user->callgroup;
 			p->pickupgroup = user->pickupgroup;
-			p->callingpres = user->callingpres;
+			if (user->callingpres)	/* User callingpres setting will override RPID header */
+				p->callingpres = user->callingpres;
 			p->capability = user->capability;
 			p->jointcapability = user->capability;
 			p->maxcallbitrate = user->maxcallbitrate;
@@ -7811,7 +7812,8 @@
 			ast_string_field_set(p, peersecret, peer->secret);
 			ast_string_field_set(p, peermd5secret, peer->md5secret);
 			ast_string_field_set(p, subscribecontext, peer->subscribecontext);
-			p->callingpres = peer->callingpres;
+			if (peer->callingpres)	/* Peer calling pres setting will override RPID */
+				p->callingpres = peer->callingpres;
 			if (peer->maxms && peer->lastms)
 				p->timer_t1 = peer->lastms;
 			if (ast_test_flag(&peer->flags[0], SIP_INSECURE_INVITE)) {



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 14:25:33 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 14:25:33 +0200
Subject: [solid-pbx-svn] r253 - trunk/channels
Message-ID: <200606181225.k5ICPXMQ022389@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 14:25:30 +0200 (Sun, 18 Jun 2006)
New Revision: 253

Modified:
   trunk/channels/chan_iax2.c
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r32193

------------------------------------------------------------------------
r32185 | oej | 2006-06-05 08:36:18 +0200 (Mon, 05 Jun 2006) | 2 lines

Do not use ':' as a separator between arguments (kept around for 1.4 for backwards compatibility)

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 11:25:25 UTC (rev 252)
+++ trunk/channels/chan_iax2.c	2006-06-18 12:25:30 UTC (rev 253)
@@ -9398,8 +9398,10 @@
 		return 0;
 	}
 
-	if ((colname = strchr(peername, ':')))
+	if ((colname = strchr(peername, ':')))	/*! \todo : will be removed after the 1.4 relese */
 		*colname++ = '\0';
+	else if ((colname = strchr(peername, '|')))
+		*colname++ = '\0';
 	else
 		colname = "ip";
 
@@ -9446,7 +9448,7 @@
 struct ast_custom_function iaxpeer_function = {
 	.name = "IAXPEER",
 	.synopsis = "Gets IAX peer information",
-	.syntax = "IAXPEER(<peername|CURRENTCHANNEL>[:item])",
+	.syntax = "IAXPEER(<peername|CURRENTCHANNEL>[|item])",
 	.read = function_iaxpeer,
 	.desc = "If peername specified, valid items are:\n"
 	"- ip (default)          The IP address.\n"

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 11:25:25 UTC (rev 252)
+++ trunk/channels/chan_sip.c	2006-06-18 12:25:30 UTC (rev 253)
@@ -9980,8 +9980,10 @@
 	char *colname;
 	char iabuf[INET_ADDRSTRLEN];
 
-	if ((colname = strchr(data, ':')))
+	if ((colname = strchr(data, ':')))	/*! \todo Will be deprecated after 1.4 */
 		*colname++ = '\0';
+	else if ((colname = strchr(data, '|')))
+		*colname++ = '\0';
 	else
 		colname = "ip";
 
@@ -10039,7 +10041,7 @@
 struct ast_custom_function sippeer_function = {
 	.name = "SIPPEER",
 	.synopsis = "Gets SIP peer information",
-	.syntax = "SIPPEER(<peername>[:item])",
+	.syntax = "SIPPEER(<peername>[|item])",
 	.read = function_sippeer,
 	.desc = "Valid items are:\n"
 	"- ip (default)          The IP address.\n"



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 15:25:34 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 15:25:34 +0200
Subject: [solid-pbx-svn] r254 - trunk/channels
Message-ID: <200606181325.k5IDPYnv019423@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 15:25:32 +0200 (Sun, 18 Jun 2006)
New Revision: 254

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r32213

------------------------------------------------------------------------
r32207 | oej | 2006-06-05 09:43:40 +0200 (Mon, 05 Jun 2006) | 2 lines

Issue 7208 - Handle ; in userinfo part of URI too

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 12:25:30 UTC (rev 253)
+++ trunk/channels/chan_sip.c	2006-06-18 13:25:32 UTC (rev 254)
@@ -7142,16 +7142,16 @@
 			return -1;
 		}
 		from += 4;
-		from = strsep(&from, ";");
 		if ((a = strchr(from, '@')))
 			*a++ = '\0';
 		else
 			a = from;	/* just a domain */
+		from = strsep(&from, ";");	/* Remove userinfo options */
+		a = strsep(&a, ";");		/* Remove URI options */
 		ast_string_field_set(p, fromdomain, a);
 	}
 
 	/* Skip any options and find the domain */
-	uri = strsep(&uri, ";");
 
 	/* Get the target domain */
 	if ((a = strchr(uri, '@'))) {
@@ -7164,6 +7164,9 @@
 	if (colon)
 		*colon = '\0';
 
+	uri = strsep(&uri, ";");	/* Remove userinfo options */
+	a = strsep(&a, ";");		/* Remove URI options */
+
 	ast_string_field_set(p, domain, a);
 
 	if (!AST_LIST_EMPTY(&domain_list)) {



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 16:25:30 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 16:25:30 +0200
Subject: [solid-pbx-svn] r255 - in trunk: . apps configs include/asterisk
Message-ID: <200606181425.k5IEPUp8017031@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 16:25:27 +0200 (Sun, 18 Jun 2006)
New Revision: 255

Modified:
   trunk/apps/app_voicemail.c
   trunk/configs/rtp.conf.sample
   trunk/include/asterisk/rtp.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32233

------------------------------------------------------------------------
r32229 | oej | 2006-06-05 10:06:02 +0200 (Mon, 05 Jun 2006) | 3 lines

- Add headers to e-mail with caller ID name and number to simplify automatic parsing
- Formatting fixes

------------------------------------------------------------------------
r32230 | oej | 2006-06-05 10:39:42 +0200 (Mon, 05 Jun 2006) | 3 lines

Issue #2863 - Improved RTCP support (John Martin, Fredrik Olsson)
   Thanks to everyone involved in working with this!

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/apps/app_voicemail.c	2006-06-18 14:25:27 UTC (rev 255)
@@ -1780,11 +1780,13 @@
 				if ((passdata = alloca(vmlen))) {
 					memset(passdata, 0, vmlen);
 					prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, cidnum, cidname, dur, date, passdata, vmlen, category);
-					pbx_substitute_variables_helper(ast,fromstring,passdata,vmlen);
+					pbx_substitute_variables_helper(ast, fromstring, passdata, vmlen);
 					fprintf(p, "From: %s <%s>\n",passdata,who);
-				} else ast_log(LOG_WARNING, "Cannot allocate workspace for variable substitution\n");
+				} else
+					ast_log(LOG_WARNING, "Cannot allocate workspace for variable substitution\n");
 				ast_channel_free(ast);
-			} else ast_log(LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
+			} else
+				ast_log(LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
 		} else
 			fprintf(p, "From: Asterisk PBX <%s>\n", who);
 		fprintf(p, "To: %s <%s>\n", vmu->fullname, vmu->email);
@@ -1797,11 +1799,13 @@
 				if ((passdata = alloca(vmlen))) {
 					memset(passdata, 0, vmlen);
 					prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, cidnum, cidname, dur, date, passdata, vmlen, category);
-					pbx_substitute_variables_helper(ast,emailsubject,passdata,vmlen);
-					fprintf(p, "Subject: %s\n",passdata);
-				} else ast_log(LOG_WARNING, "Cannot allocate workspace for variable substitution\n");
+					pbx_substitute_variables_helper(ast, emailsubject, passdata, vmlen);
+					fprintf(p, "Subject: %s\n", passdata);
+				} else
+					ast_log(LOG_WARNING, "Cannot allocate workspace for variable substitution\n");
 				ast_channel_free(ast);
-			} else ast_log(LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
+			} else
+				ast_log(LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
 		} else
 		if (*emailtitle) {
 			fprintf(p, emailtitle, msgnum + 1, mailbox) ;
@@ -1811,6 +1815,10 @@
 		else
 			fprintf(p, "Subject: [PBX]: New message %d in mailbox %s\n", msgnum + 1, mailbox);
 		fprintf(p, "Message-ID: <Asterisk-%d-%d-%s-%d@%s>\n", msgnum, (unsigned int)ast_random(), mailbox, getpid(), host);
+		if (!ast_strlen_zero(cidnum))
+			fprintf(p, "X-Asterisk-CallerID: %s\n", cidnum);
+		if (!ast_strlen_zero(cidname))
+			fprintf(p, "X-Asterisk-CallerIDName: %s\n", cidname);
 		fprintf(p, "MIME-Version: 1.0\n");
 		if (attach_user_voicemail) {
 			/* Something unique. */
@@ -1829,11 +1837,13 @@
 				if ((passdata = alloca(vmlen))) {
 					memset(passdata, 0, vmlen);
 					prep_email_sub_vars(ast, vmu, msgnum + 1, context, mailbox, cidnum, cidname, dur, date, passdata, vmlen, category);
-					pbx_substitute_variables_helper(ast,emailbody,passdata,vmlen);
-					fprintf(p, "%s\n",passdata);
-				} else ast_log(LOG_WARNING, "Cannot allocate workspace for variable substitution\n");
+					pbx_substitute_variables_helper(ast, emailbody, passdata, vmlen);
+					fprintf(p, "%s\n", passdata);
+				} else
+					ast_log(LOG_WARNING, "Cannot allocate workspace for variable substitution\n");
 				ast_channel_free(ast);
-			} else ast_log(LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
+			} else
+				ast_log(LOG_WARNING, "Cannot allocate the channel for variables substitution\n");
 		} else {
 			fprintf(p, "Dear %s:\n\n\tJust wanted to let you know you were just left a %s long message (number %d)\n"
 
@@ -1843,9 +1853,7 @@
 		}
 		if (attach_user_voicemail) {
 			/* Eww. We want formats to tell us their own MIME type */
-			char *ctype = "audio/x-";
-			if (!strcasecmp(format, "ogg"))
-				ctype = "application/";
+			char *ctype = (!strcasecmp(format, "ogg")) ?  "application/" : "audio/x-";
 		
 			fprintf(p, "--%s\n", bound);
 			fprintf(p, "Content-Type: %s%s; name=\"msg%04d.%s\"\n", ctype, format, msgnum, format);

Modified: trunk/configs/rtp.conf.sample
===================================================================
--- trunk/configs/rtp.conf.sample	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/configs/rtp.conf.sample	2006-06-18 14:25:27 UTC (rev 255)
@@ -18,3 +18,5 @@
 ; allowed to continue (in 'samples', 1/8000 of a second)
 ;
 ;dtmftimeout=3000
+; rtcpinterval = 5000 	; Milliseconds between rtcp reports 
+			;(min 500, max 60000, default 5000)

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/include/asterisk/rtp.h	2006-06-18 14:25:27 UTC (rev 255)
@@ -166,6 +166,12 @@
 
 void ast_rtp_stop(struct ast_rtp *rtp);
 
+/*! \brief Return RTCP quality string */
+char *ast_rtp_get_quality(struct ast_rtp *rtp);
+
+/*! \brief Send an H.261 fast update request. Some devices need this rather than the XML message  in SIP */
+int ast_rtcp_send_h261fur(void *data);
+
 void ast_rtp_init(void);
 
 int ast_rtp_reload(void);

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 13:25:32 UTC (rev 254)
+++ trunk/rtp.c	2006-06-18 14:25:27 UTC (rev 255)
@@ -59,6 +59,18 @@
 
 #define MAX_TIMESTAMP_SKEW	640
 
+#define RTP_SEQ_MOD     (1<<16) 	/*!< A sequence number can't be more than 16 bits */
+#define RTCP_DEFAULT_INTERVALMS   5000	/*!< Default milli-seconds between RTCP reports we send */
+#define RTCP_MIN_INTERVALMS       500	/*!< Min milli-seconds between RTCP reports we send */
+#define RTCP_MAX_INTERVALMS       60000	/*!< Max milli-seconds between RTCP reports we send */
+
+#define RTCP_PT_FUR     192
+#define RTCP_PT_SR      200
+#define RTCP_PT_RR      201
+#define RTCP_PT_SDES    202
+#define RTCP_PT_BYE     203
+#define RTCP_PT_APP     204
+
 #define RTP_MTU		1200
 
 #define DEFAULT_DTMF_TIMEOUT 3000	/*!< samples */
@@ -68,12 +80,23 @@
 static int rtpstart = 0;		/*!< First port for RTP sessions (set in rtp.conf) */
 static int rtpend = 0;			/*!< Last port for RTP sessions (set in rtp.conf) */
 static int rtpdebug = 0;		/*!< Are we debugging? */
+static int rtcpdebug = 0;		/*!< Are we debugging RTCP? */
+static int rtcpstats = 0;		/*!< Are we debugging RTCP? */
+static int rtcpinterval = RTCP_DEFAULT_INTERVALMS; /*!< Time between rtcp reports in millisecs */
 static int stundebug = 0;		/*!< Are we debugging stun? */
 static struct sockaddr_in rtpdebugaddr;	/*!< Debug packets to/from this host */
+static struct sockaddr_in rtcpdebugaddr;	/*!< Debug RTCP packets to/from this host */
 #ifdef SO_NO_CHECK
 static int nochecksums = 0;
 #endif
 
+/* Forward declarations */
+static int ast_rtcp_write(void *data);
+static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw);
+static int ast_rtcp_write_sr(void *data);
+static int ast_rtcp_write_rr(void *data);
+static unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp);
+
 /*! \brief The value of each payload format mapping: */
 struct rtpPayloadType {
 	int isAstFormat; 	/*!< whether the following code is an AST_FORMAT */
@@ -95,6 +118,7 @@
 	struct ast_frame f;
 	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
 	unsigned int ssrc;		/*!< Synchronization source, RFC 3550, page 10. */
+	unsigned int themssrc;		/*!< Their SSRC */
 	unsigned int rxssrc;
 	unsigned int lastts;
 	unsigned int lastdigitts;
@@ -102,6 +126,16 @@
 	unsigned int lastividtimestamp;
 	unsigned int lastovidtimestamp;
 	unsigned int lasteventseqn;
+	int lastrxseqno;                /*!< Last received sequence number */
+	unsigned short seedrxseqno;     /*!< What sequence number did they start with?*/
+	unsigned int seedrxts;          /*!< What RTP timestamp did they start with? */
+	unsigned int rxcount;           /*!< How many packets have we received? */
+	unsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/
+	unsigned int txcount;           /*!< How many packets have we sent? */
+	unsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/
+	unsigned int cycles;            /*!< Shifted count of sequence number cycles */
+	double rxjitter;                /*!< Interarrival jitter at the moment */
+	double rxtransit;               /*!< Relative transit time for previous packet */
 	unsigned int lasteventendseqn;
 	int lasttxformat;
 	int lastrxformat;
@@ -113,6 +147,8 @@
 	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
 	struct timeval rxcore;
 	struct timeval txcore;
+	double drxcore;                 /*!< The double representation of the first received packet */
+	struct timeval lastrx;          /*!< timeval when we last received a packet */
 	struct timeval dtmfmute;
 	struct ast_smoother *smoother;
 	int *ioid;
@@ -143,6 +179,27 @@
 	int s;				/*!< Socket */
 	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
 	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
+	unsigned int soc;		/*!< What they told us */
+	unsigned int spc;		/*!< What they told us */
+	unsigned int themrxlsr;		/*!< The middle 32 bits of the NTP timestamp in the last received SR*/
+	struct timeval rxlsr;		/*!< Time when we got their last SR */
+	struct timeval txlsr;		/*!< Time when we sent or last SR*/
+	unsigned int expected_prior;	/*!< no. packets in previous interval */
+	unsigned int received_prior;	/*!< no. packets received in previous interval */
+	int schedid;			/*!< Schedid returned from ast_sched_add() to schedule RTCP-transmissions*/
+	unsigned int rr_count;		/*!< number of RRs we've sent, not including report blocks in SR's */
+	unsigned int sr_count;		/*!< number of SRs we've sent */
+	unsigned int lastsrtxcount;     /*!< Transmit packet count when last SR sent */
+	double accumulated_transit;	/*!< accumulated a-dlsr-lsr */
+	double rtt;			/*!< Last reported rtt */
+	unsigned int reported_jitter;	/*!< The contents of their last jitter entry in the RR */
+	unsigned int reported_lost;	/*!< Reported lost packets in their RR */
+	char quality[AST_MAX_USER_FIELD];
+	double maxrxjitter;
+	double minrxjitter;
+	double maxrtt;
+	double minrtt;
+	int sendfur;
 };
 
 
@@ -408,6 +465,16 @@
 /*! \brief List of current sessions */
 static AST_LIST_HEAD_STATIC(protos, ast_rtp_protocol);
 
+static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw)
+{
+	unsigned int sec, usec, frac;
+	sec = tv.tv_sec + 2208988800u; /* Sec between 1900 and 1970 */
+	usec = tv.tv_usec;
+	frac = (usec << 12) + (usec << 8) - ((usec * 3650) >> 6);
+	*msw = sec;
+	*lsw = frac;
+}
+
 int ast_rtp_fd(struct ast_rtp *rtp)
 {
 	return rtp->s;
@@ -420,6 +487,15 @@
 	return -1;
 }
 
+unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp)
+{
+	unsigned int interval;
+	/*! \todo XXX Do a more reasonable calculation on this one
+	* Look in RFC 3550 Section A.7 for an example*/
+	interval = rtcpinterval;
+	return interval;
+}
+
 void ast_rtp_set_data(struct ast_rtp *rtp, void *data)
 {
 	rtp->data = data;
@@ -483,6 +559,20 @@
 	return 1;
 }
 
+static inline int rtcp_debug_test_addr(struct sockaddr_in *addr)
+{
+	if (rtcpdebug == 0)
+		return 0;
+	if (rtcpdebugaddr.sin_addr.s_addr) {
+		if (((ntohs(rtcpdebugaddr.sin_port) != 0)
+			&& (rtcpdebugaddr.sin_port != addr->sin_port))
+			|| (rtcpdebugaddr.sin_addr.s_addr != addr->sin_addr.s_addr))
+		return 0;
+	}
+	return 1;
+}
+
+
 static struct ast_frame *process_cisco_dtmf(struct ast_rtp *rtp, unsigned char *data, int len)
 {
 	unsigned int event;
@@ -632,33 +722,44 @@
 struct ast_frame *ast_rtcp_read(struct ast_rtp *rtp)
 {
 	socklen_t len;
-	int hdrlen = 8;
+	int position, i, packetwords;
 	int res;
 	struct sockaddr_in sin;
-	unsigned int rtcpdata[1024];
+	unsigned int rtcpdata[8192 + AST_FRIENDLY_OFFSET];
 	char iabuf[INET_ADDRSTRLEN];
+	unsigned int *rtcpheader;
+	int pt;
+	struct timeval now;
+	unsigned int length;
+	int rc;
+	double rtt = 0;
+	double a;
+	double dlsr;
+	double lsr;
+	unsigned int msw;
+	unsigned int lsw;
+	unsigned int comp;
+	struct ast_frame *f = &ast_null_frame;
 	
 	if (!rtp || !rtp->rtcp)
 		return &ast_null_frame;
 
 	len = sizeof(sin);
 	
-	res = recvfrom(rtp->rtcp->s, rtcpdata, sizeof(rtcpdata),
+	res = recvfrom(rtp->rtcp->s, rtcpdata + AST_FRIENDLY_OFFSET, sizeof(rtcpdata) - sizeof(unsigned int) * AST_FRIENDLY_OFFSET,
 					0, (struct sockaddr *)&sin, &len);
+	rtcpheader = (unsigned int *)(rtcpdata + AST_FRIENDLY_OFFSET);
 	
 	if (res < 0) {
 		if (errno != EAGAIN)
-			ast_log(LOG_WARNING, "RTP Read error: %s\n", strerror(errno));
+			ast_log(LOG_WARNING, "RTCP Read error: %s\n", strerror(errno));
 		if (errno == EBADF)
 			CRASH;
 		return &ast_null_frame;
 	}
 
-	if (res < hdrlen) {
-		ast_log(LOG_WARNING, "RTP Read too short\n");
-		return &ast_null_frame;
-	}
-
+	packetwords = res / 4;
+	
 	if (rtp->nat) {
 		/* Send to whoever sent to us */
 		if ((rtp->rtcp->them.sin_addr.s_addr != sin.sin_addr.s_addr) ||
@@ -670,18 +771,154 @@
 	}
 	if (option_debug)
 		ast_log(LOG_DEBUG, "Got RTCP report of %d bytes\n", res);
-	return &ast_null_frame;
+
+	/* Process a compound packet */
+	position = 0;
+	while (position < packetwords) {
+		i = position;
+		length = ntohl(rtcpheader[i]);
+		pt = (length & 0xff0000) >> 16;
+		rc = (length & 0x1f000000) >> 24;
+		length &= 0xffff;
+    
+		if ((i + length) > packetwords) {
+			ast_log(LOG_WARNING, "RTCP Read too short\n");
+			return &ast_null_frame;
+		}
+		
+	if(rtcp_debug_test_addr(&sin)){
+	  	ast_verbose("\n\nGot RTCP from %s:%d\n",ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr),ntohs(sin.sin_port));
+	  	ast_verbose("PT: %d(%s)\n",pt,(pt==200)?"Sender Report":(pt==201)?"Receiver Report":(pt==192)?"H.261 FUR":"Unknown");
+	  	ast_verbose("Reception reports: %d\n",rc);
+	  	ast_verbose("SSRC of sender: %u\n",rtcpheader[i+1]);
+	}
+    
+	i+=2; /* Advance past header and ssrc */
+		
+	switch(pt){
+	  	case RTCP_PT_SR:
+	  		gettimeofday(&rtp->rtcp->rxlsr,NULL); /* To be able to populate the dlsr */
+	  		rtp->rtcp->spc = ntohl(rtcpheader[i+3]);
+	  		rtp->rtcp->soc = ntohl(rtcpheader[i+4]);
+	  		rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i+1]) & 0xffff) >> 16); /* Going to LSR in RR*/
+    
+	  		if(rtcp_debug_test_addr(&sin)){
+	  			ast_verbose("NTP timestamp: %lu.%010lu\n",(unsigned long)ntohl(rtcpheader[i]), (unsigned long)ntohl(rtcpheader[i+1])*4096);
+	  			ast_verbose("RTP timestamp: %lu\n",(unsigned long)ntohl(rtcpheader[i+2]));
+	  			ast_verbose("SPC: %lu\tSOC: %lu\n",(unsigned long)ntohl(rtcpheader[i+3]),(unsigned long)ntohl(rtcpheader[i+4]));
+	  		}
+			i += 5;
+			if (rc < 1)
+				break;
+			/* Intentional fall through */
+	  	case RTCP_PT_RR:
+	  		/* This is the place to calculate RTT */
+				/* Don't handle multiple reception reports (rc > 1) yet */
+	  		gettimeofday(&now, NULL);
+	  		timeval2ntp(now, &msw, &lsw);
+	  		/* Use the one we sent them in our SR instead, rtcp->txlsr could have been rewritten if the dlsr is large */
+	  		if(ntohl(rtcpheader[i+4])){ /* We must have the LSR */
+	  			comp = ((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16);
+	  			a = (double)((comp & 0xffff0000) >> 16) + (double)((double)(comp & 0xffff)/1000000.);
+	  			lsr = (double)((ntohl(rtcpheader[i+4]) & 0xffff0000) >> 16) + (double)((double)(ntohl(rtcpheader[i+4]) & 0xffff)/1000000.);
+	  			dlsr = (double)(ntohl(rtcpheader[i+5])/65536.);
+	  			rtt = a - dlsr - lsr;
+	  			rtp->rtcp->accumulated_transit += rtt;
+	  			rtp->rtcp->rtt = rtt;
+	  			if(rtp->rtcp->maxrtt<rtt)
+	  				rtp->rtcp->maxrtt = rtt;
+	  			if(rtp->rtcp->minrtt>rtt)
+	  				rtp->rtcp->minrtt = rtt;
+	  		}
+	  		rtp->rtcp->reported_jitter = ntohl(rtcpheader[i+3]);
+	  		rtp->rtcp->reported_lost = ntohl(rtcpheader[i+1]) & 0xffffff;
+	  		if(rtcp_debug_test_addr(&sin)){
+	  			ast_verbose("Fraction lost: %ld\n", (((long)ntohl(rtcpheader[i+1]) & 0xff000000) >> 24));
+	  			ast_verbose("Packets lost so far: %d\n", rtp->rtcp->reported_lost);
+	  			ast_verbose("Highest sequence number: %ld\n", (long)(ntohl(rtcpheader[i+2]) & 0xffff));
+	  			ast_verbose("Sequence number cycles: %ld\n", (long)(ntohl(rtcpheader[i+2]) & 0xffff) >> 16);
+	  			ast_verbose("Interarrival jitter: %u\n", rtp->rtcp->reported_jitter);
+	  			ast_verbose("Last SR(our NTP): %lu.%010lu\n",(unsigned long)ntohl(rtcpheader[i+4])>>16,((unsigned long)ntohl(rtcpheader[i+4])<<16)*4096);
+	  			ast_verbose("DLSR: %4.4f (sec)\n",ntohl(rtcpheader[i+5])/65536.0);
+	  			if(rtt)
+	  				ast_verbose("RTT: %f(sec)\n", rtt);
+	  		}
+	  		break;
+	  	case RTCP_PT_FUR:
+	  		if(rtcp_debug_test_addr(&sin))
+	  			ast_verbose("Received an RTCP Fast Update Request\n");
+	  		rtp->f.frametype = AST_FRAME_CONTROL;
+	  		rtp->f.subclass = AST_CONTROL_VIDUPDATE;
+	  		rtp->f.datalen = 0;
+	  		rtp->f.samples = 0;
+	  		rtp->f.mallocd = 0;
+	  		rtp->f.src = "RTP";
+	  		f = &rtp->f;
+	  		break;
+	  	case RTCP_PT_SDES:
+	  		if(rtcp_debug_test_addr(&sin))
+	  			ast_verbose("Received an SDES from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			  break;
+	  	case RTCP_PT_BYE:
+	  		if(rtcp_debug_test_addr(&sin))
+	  			ast_verbose("Received a BYE from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			  break;
+	  	default:
+	  		ast_log(LOG_NOTICE, "Unknown RTCP packet (pt=%d) received from %s:%d\n", pt, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+	  		break;
+		}
+		position += (length + 1);
+	}
+			
+	return f;
 }
 
 static void calc_rxstamp(struct timeval *tv, struct ast_rtp *rtp, unsigned int timestamp, int mark)
 {
-	struct timeval ts = ast_samp2tv( timestamp, 8000);
-	if (ast_tvzero(rtp->rxcore) || mark) {
-		rtp->rxcore = ast_tvsub(ast_tvnow(), ts);
-		/* Round to 20ms for nice, pretty timestamps */
-		rtp->rxcore.tv_usec -= rtp->rxcore.tv_usec % 20000;
+	struct timeval now;
+	double transit;
+	double current_time;
+	double d;
+	double dtv;
+	double prog;
+	
+	if ((!rtp->rxcore.tv_sec && !rtp->rxcore.tv_usec) || mark) {
+		gettimeofday(&rtp->rxcore, NULL);
+		rtp->drxcore = (double)rtp->rxcore.tv_sec + (double)rtp->rxcore.tv_usec/1000000;
+		/* map timestamp to a real time */
+		rtp->seedrxts = timestamp; /* Their RTP timestamp started with this */
+		rtp->rxcore.tv_sec -= timestamp / 8000;
+		rtp->rxcore.tv_usec -= (timestamp % 8000) * 125;
+		/* Round to 0.1ms for nice, pretty timestamps */
+		rtp->rxcore.tv_usec -= rtp->rxcore.tv_usec % 100;
+		if (rtp->rxcore.tv_usec < 0) {
+			/* Adjust appropriately if necessary */
+			rtp->rxcore.tv_usec += 1000000;
+			rtp->rxcore.tv_sec -= 1;
+		}
 	}
-	*tv = ast_tvadd(rtp->rxcore, ts);
+
+	gettimeofday(&now,NULL);
+	/* rxcore is the mapping between the RTP timestamp and _our_ real time from gettimeofday() */
+	tv->tv_sec = rtp->rxcore.tv_sec + timestamp / 8000;
+	tv->tv_usec = rtp->rxcore.tv_usec + (timestamp % 8000) * 125;
+	if (tv->tv_usec >= 1000000) {
+		tv->tv_usec -= 1000000;
+		tv->tv_sec += 1;
+	}
+	prog = (double)((timestamp-rtp->seedrxts)/8000.);
+	dtv = (double)rtp->drxcore + (double)(prog);
+	current_time = (double)now.tv_sec + (double)now.tv_usec/1000000;
+	transit = current_time - dtv;
+	d = transit - rtp->rxtransit;
+	rtp->rxtransit = transit;
+	if(d<0)
+		d=-d;
+	rtp->rxjitter += (1./16.) * (d - rtp->rxjitter);
+	if(rtp->rxjitter > rtp->rtcp->maxrxjitter)
+		rtp->rtcp->maxrxjitter = rtp->rxjitter;
+	if(rtp->rxjitter < rtp->rtcp->minrxjitter)
+		rtp->rtcp->minrxjitter = rtp->rxjitter;
 }
 
 struct ast_frame *ast_rtp_read(struct ast_rtp *rtp)
@@ -692,6 +929,7 @@
 	unsigned int seqno;
 	int version;
 	int payloadtype;
+	int tseqno;
 	int hdrlen = 12;
 	int padding;
 	int mark;
@@ -716,6 +954,7 @@
 			CRASH;
 		return &ast_null_frame;
 	}
+	
 	if (res < hdrlen) {
 		ast_log(LOG_WARNING, "RTP Read too short\n");
 		return &ast_null_frame;
@@ -746,6 +985,10 @@
 		if ((rtp->them.sin_addr.s_addr != sin.sin_addr.s_addr) ||
 		    (rtp->them.sin_port != sin.sin_port)) {
 			rtp->them = sin;
+			if(rtp->rtcp) {
+				memcpy(&rtp->rtcp->them, &sin, sizeof(rtp->rtcp->them));
+				rtp->rtcp->them.sin_port = htons(ntohs(rtp->them.sin_port)+1);
+			}
 			rtp->rxseqno = 0;
 			ast_set_flag(rtp, FLAG_NAT_ACTIVE);
 			if (option_debug || rtpdebug)
@@ -785,11 +1028,35 @@
 		return &ast_null_frame;
 	}
 
+	rtp->rxcount++; /* Only count reasonably valid packets, this'll make the rtcp stats more accurate */
+
+	tseqno = rtp->lastrxseqno +1;
+
+	if(rtp->rxcount==1){
+		/* This is the first RTP packet successfully received from source */
+		rtp->seedrxseqno = seqno;
+	}
+
+	if(rtp->rtcp->schedid<1){
+		/* Schedule transmission of Receiver Report */
+		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
+	}
+
+	if(tseqno > RTP_SEQ_MOD){ /* if tseqno is greater than RTP_SEQ_MOD it would indicate that the sender cycled */
+		rtp->cycles += RTP_SEQ_MOD;
+		ast_verbose("SEQNO cycled: %u\t%d\n", rtp->cycles, seqno);
+	}
+
+	rtp->lastrxseqno = seqno;
+	
+	if(rtp->themssrc==0)
+		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
+	
 	if(rtp_debug_test_addr(&sin))
 		ast_verbose("Got  RTP packet from %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 			ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
 
-   	rtpPT = ast_rtp_lookup_pt(rtp, payloadtype);
+	rtpPT = ast_rtp_lookup_pt(rtp, payloadtype);
 	if (!rtpPT.isAstFormat) {
 		struct ast_frame *f = NULL;
 
@@ -1202,7 +1469,7 @@
 	if (pt < 0 || pt > MAX_RTP_PT) 
 		return result; /* bogus payload type */
 
-	/* Start with the negotiated codecs */
+	/* Start with negotiated codecs */
 	result = rtp->current_RTP_PT[pt];
 
 	/* If it doesn't exist, check our static RTP type list, just in case */
@@ -1225,7 +1492,7 @@
 
 	/* Check the dynamic list first */
 	for (pt = 0; pt < MAX_RTP_PT; ++pt) {
-  		if (rtp->current_RTP_PT[pt].code == code && rtp->current_RTP_PT[pt].isAstFormat == isAstFormat) {
+		if (rtp->current_RTP_PT[pt].code == code && rtp->current_RTP_PT[pt].isAstFormat == isAstFormat) {
 			rtp->rtp_lookup_code_cache_isAstFormat = isAstFormat;
 			rtp->rtp_lookup_code_cache_code = code;
 			rtp->rtp_lookup_code_cache_result = pt;
@@ -1321,9 +1588,11 @@
 		return NULL;
 	rtcp->s = rtp_socket();
 	rtcp->us.sin_family = AF_INET;
+	rtcp->them.sin_family = AF_INET;
+
 	if (rtcp->s < 0) {
 		free(rtcp);
-		ast_log(LOG_WARNING, "Unable to allocate socket: %s\n", strerror(errno));
+		ast_log(LOG_WARNING, "Unable to allocate RTCP socket: %s\n", strerror(errno));
 		return NULL;
 	}
 
@@ -1465,11 +1734,16 @@
 
 void ast_rtp_stop(struct ast_rtp *rtp)
 {
+	if(rtp->rtcp->schedid>0){
+		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
+	}
+
 	memset(&rtp->them.sin_addr, 0, sizeof(rtp->them.sin_addr));
 	memset(&rtp->them.sin_port, 0, sizeof(rtp->them.sin_port));
 	if (rtp->rtcp) {
-		memset(&rtp->rtcp->them.sin_addr, 0, sizeof(rtp->them.sin_addr));
-		memset(&rtp->rtcp->them.sin_port, 0, sizeof(rtp->them.sin_port));
+		memset(&rtp->rtcp->them.sin_addr, 0, sizeof(rtp->rtcp->them.sin_addr));
+		memset(&rtp->rtcp->them.sin_port, 0, sizeof(rtp->rtcp->them.sin_port));
 	}
 }
 
@@ -1493,8 +1767,50 @@
 	rtp->rxseqno = 0;
 }
 
+char *ast_rtp_get_quality(struct ast_rtp *rtp)
+{
+	/*
+	*ssrc          our ssrc
+	*themssrc      their ssrc
+	*lp            lost packets
+	*rxjitter      our calculated jitter(rx)
+	*rxcount       no. received packets
+	*txjitter      reported jitter of the other end
+	*txcount       transmitted packets
+	*rlp           remote lost packets
+	*/
+	
+	snprintf(rtp->rtcp->quality, sizeof(rtp->rtcp->quality), "ssrc=%u;themssrc=%u;lp=%u;rxjitter=%f;rxcount=%u;txjitter=%f;txcount=%u;rlp=%u;rtt=%f", rtp->ssrc, rtp->themssrc, rtp->rtcp->expected_prior - rtp->rtcp->received_prior, rtp->rxjitter, rtp->rxcount, (double)rtp->rtcp->reported_jitter/65536., rtp->txcount, rtp->rtcp->reported_lost, rtp->rtcp->rtt);
+	
+	return rtp->rtcp->quality;
+}
+
 void ast_rtp_destroy(struct ast_rtp *rtp)
 {
+	if(rtcp_debug_test_addr(&rtp->them) || rtcpstats){
+		/*Print some info on the call here */
+		ast_verbose("  RTP-stats\n");
+		ast_verbose("* Our Receiver:\n");
+		ast_verbose("  SSRC:		 %u\n", rtp->themssrc);
+		ast_verbose("  Received packets: %u\n", rtp->rxcount);
+		ast_verbose("  Lost packets:	 %u\n", rtp->rtcp->expected_prior - rtp->rtcp->received_prior);
+		ast_verbose("  Jitter:		 %.4f\n", rtp->rxjitter);
+		ast_verbose("  Transit:		 %.4f\n", rtp->rxtransit);
+		ast_verbose("  RR-count:	 %u\n", rtp->rtcp->rr_count);
+		ast_verbose("* Our Sender:\n");
+		ast_verbose("  SSRC:		 %u\n", rtp->ssrc);
+		ast_verbose("  Sent packets:	 %u\n", rtp->txcount);
+		ast_verbose("  Lost packets:	 %u\n", rtp->rtcp->reported_lost);
+		ast_verbose("  Jitter:		 %u\n", rtp->rtcp->reported_jitter);
+		ast_verbose("  SR-count:	 %u\n", rtp->rtcp->sr_count);
+		ast_verbose("  RTT:		 %f\n", rtp->rtcp->rtt);
+	}
+
+	if(rtp->rtcp->schedid>0){
+		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
+	}
+
 	if (rtp->smoother)
 		ast_smoother_free(rtp->smoother);
 	if (rtp->ioid)
@@ -1504,6 +1820,7 @@
 	if (rtp->rtcp) {
 		close(rtp->rtcp->s);
 		free(rtp->rtcp);
+		rtp->rtcp=NULL;
 	}
 	free(rtp);
 }
@@ -1596,7 +1913,7 @@
 			rtpheader[3] |= htonl((1 << 23));
 		}
 	}
-	/* Increment the digit timestamp by 120ms, to ensure that digits
+	/*! \note Increment the digit timestamp by 120ms, to ensure that digits
 	   sent sequentially with no intervening non-digit packets do not
 	   get sent with the same timestamp, and that sequential digits
 	   have some 'dead air' in between them
@@ -1609,6 +1926,244 @@
 	return 0;
 }
 
+/* \brief Public function: Send an H.261 fast update request, some devices need this rather than SIP XML */
+int ast_rtcp_send_h261fur(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+
+	rtp->rtcp->sendfur = 1;
+	res = ast_rtcp_write(data);
+	
+	return res;
+}
+
+/*! \brief Send RTCP sender's report */
+static int ast_rtcp_write_sr(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+	int len = 0;
+	struct timeval now;
+	unsigned int now_lsw;
+	unsigned int now_msw;
+	unsigned int *rtcpheader;
+	unsigned int lost;
+	unsigned int extended;
+	unsigned int expected;
+	unsigned int expected_interval;
+	unsigned int received_interval;
+	int lost_interval;
+	int fraction;
+	struct timeval dlsr;
+	char bdata[512];
+	char iabuf[INET_ADDRSTRLEN];
+
+	if(!rtp || !rtp->rtcp || (&rtp->rtcp->them.sin_addr == 0))
+		return 0;
+	
+	if(!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
+		ast_verbose("RTCP SR transmission error, rtcp halted %s\n",strerror(errno));
+		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
+		return 0;
+	}
+
+	gettimeofday(&now, NULL);
+	timeval2ntp(now, &now_msw, &now_lsw); /* fill thses ones in from utils.c*/
+	rtcpheader = (unsigned int *)bdata;
+	rtcpheader[1] = htonl(rtp->ssrc);               /* Our SSRC */
+	rtcpheader[2] = htonl(now_msw);                 /* now, MSW. gettimeofday() + SEC_BETWEEN_1900_AND_1970*/
+	rtcpheader[3] = htonl(now_lsw);                 /* now, LSW */
+	rtcpheader[4] = htonl(rtp->lastts);             /* FIXME shouldn't be that, it should be now */
+	rtcpheader[5] = htonl(rtp->txcount);            /* No. packets sent */
+	rtcpheader[6] = htonl(rtp->txoctetcount);       /* No. bytes sent */
+	len += 28;
+	
+	extended = rtp->cycles + rtp->lastrxseqno;
+	expected = extended - rtp->seedrxseqno + 1;
+	if (rtp->rxcount > expected) 
+		expected += rtp->rxcount - expected;
+	lost = expected - rtp->rxcount;
+	expected_interval = expected - rtp->rtcp->expected_prior;
+	rtp->rtcp->expected_prior = expected;
+	received_interval = rtp->rxcount - rtp->rtcp->received_prior;
+	rtp->rtcp->received_prior = rtp->rxcount;
+	lost_interval = expected_interval - received_interval;
+	if (expected_interval == 0 || lost_interval <= 0)
+		fraction = 0;
+	else
+		fraction = (lost_interval << 8) / expected_interval;
+	timersub(&now, &rtp->rtcp->rxlsr, &dlsr);
+	rtcpheader[7] = htonl(rtp->themssrc);
+	rtcpheader[8] = htonl(((fraction & 0xff) << 24) | (lost & 0xffffff));
+	rtcpheader[9] = htonl((rtp->cycles) | ((rtp->lastrxseqno & 0xffff)));
+	rtcpheader[10] = htonl((unsigned int)rtp->rxjitter);
+	rtcpheader[11] = htonl(rtp->rtcp->themrxlsr);
+	rtcpheader[12] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
+	len += 24;
+	
+	rtcpheader[0] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SR << 16) | ((len/4)-1));
+
+	if (rtp->rtcp->sendfur) {
+		rtcpheader[13] = htonl((2 << 30) | (0 << 24) | (RTCP_PT_FUR << 16) | 1);
+		rtcpheader[14] = htonl(rtp->ssrc);               /* Our SSRC */
+		len += 8;
+		rtp->rtcp->sendfur = 0;
+	}
+	
+	/* Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos */ 
+	/* it can change mid call, and SDES can't) */
+	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
+	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
+	rtcpheader[(len/4)+2] = htonl(0x01 << 24);                    /* Empty for the moment */
+	len += 12;
+	
+	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
+	if (res < 0) {
+		ast_log(LOG_ERROR, "RTCP SR transmission error to %s:%d, rtcp halted %s\n",ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port), strerror(errno));
+		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
+		return 0;
+	}
+	
+	/* FIXME Don't need to get a new one */
+	gettimeofday(&rtp->rtcp->txlsr, NULL);
+	rtp->rtcp->sr_count++;
+
+	rtp->rtcp->lastsrtxcount = rtp->txcount;	
+	
+	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
+		ast_verbose("* Sent RTCP SR to %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+		ast_verbose("  Our SSRC: %u\n", rtp->ssrc);
+		ast_verbose("  Sent(NTP): %u.%010u\n", (unsigned int)now.tv_sec, (unsigned int)now.tv_usec*4096);
+		ast_verbose("  Sent(RTP): %u\n", rtp->lastts);
+		ast_verbose("  Sent packets: %u\n", rtp->txcount);
+		ast_verbose("  Sent octets: %u\n", rtp->txoctetcount);
+		ast_verbose("  Report block:\n");
+		ast_verbose("  Fraction lost: %u\n", fraction);
+		ast_verbose("  Cumulative loss: %u\n", lost);
+		ast_verbose("  IA jitter: %.4f\n", rtp->rxjitter);
+		ast_verbose("  Their last SR: %u\n", rtp->rtcp->themrxlsr);
+		ast_verbose("  DLSR: %4.4f (sec)\n\n", (double)(ntohl(rtcpheader[12])/65536.0));
+	}
+	return res;
+}
+
+/*! \brief Send RTCP recepient's report */
+static int ast_rtcp_write_rr(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+	int len = 32;
+	unsigned int lost;
+	unsigned int extended;
+	unsigned int expected;
+	unsigned int expected_interval;
+	unsigned int received_interval;
+	int lost_interval;
+	struct timeval now;
+	unsigned int *rtcpheader;
+	char bdata[1024];
+	char iabuf[INET_ADDRSTRLEN];
+	struct timeval dlsr;
+	int fraction;
+
+	if (!rtp || !rtp->rtcp || (&rtp->rtcp->them.sin_addr == 0))
+		return 0;
+	  
+	if (!rtp->rtcp->them.sin_addr.s_addr){
+		ast_log(LOG_ERROR, "RTCP RR transmission error to, rtcp halted %s\n",strerror(errno));
+		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
+		return 0;
+	}
+
+	extended = rtp->cycles + rtp->lastrxseqno;
+	expected = extended - rtp->seedrxseqno + 1;
+	lost = expected - rtp->rxcount;
+	expected_interval = expected - rtp->rtcp->expected_prior;
+	rtp->rtcp->expected_prior = expected;
+	received_interval = rtp->rxcount - rtp->rtcp->received_prior;
+	rtp->rtcp->received_prior = rtp->rxcount;
+	lost_interval = expected_interval - received_interval;
+	if (expected_interval == 0 || lost_interval <= 0)
+		fraction = 0;
+	else
+		fraction = (lost_interval << 8) / expected_interval;
+	gettimeofday(&now, NULL);
+	timersub(&now, &rtp->rtcp->rxlsr, &dlsr);
+	rtcpheader = (unsigned int *)bdata;
+	rtcpheader[0] = htonl((2 << 30) | (1 << 24) | (RTCP_PT_RR << 16) | ((len/4)-1));
+	rtcpheader[1] = htonl(rtp->ssrc);
+	rtcpheader[2] = htonl(rtp->themssrc);
+	rtcpheader[3] = htonl(((fraction & 0xff) << 24) | (lost & 0xffffff));
+	rtcpheader[4] = htonl((rtp->cycles) | ((rtp->lastrxseqno & 0xffff)));
+	rtcpheader[5] = htonl((unsigned int)rtp->rxjitter);
+	rtcpheader[6] = htonl(rtp->rtcp->themrxlsr);
+	rtcpheader[7] = htonl((((dlsr.tv_sec * 1000) + (dlsr.tv_usec / 1000)) * 65536) / 1000);
+
+	if (rtp->rtcp->sendfur) {
+		rtcpheader[8] = htonl((2 << 30) | (0 << 24) | (RTCP_PT_FUR << 16) | 1); /* Header from page 36 in RFC 3550 */
+		rtcpheader[9] = htonl(rtp->ssrc);               /* Our SSRC */
+		len += 8;
+		rtp->rtcp->sendfur = 0;
+	}
+
+	/*! \note Insert SDES here. Probably should make SDES text equal to mimetypes[code].type (not subtype 'cos 
+	it can change mid call, and SDES can't) */
+	rtcpheader[len/4]     = htonl((2 << 30) | (1 << 24) | (RTCP_PT_SDES << 16) | 2);
+	rtcpheader[(len/4)+1] = htonl(rtp->ssrc);               /* Our SSRC */
+	rtcpheader[(len/4)+2] = htonl(0x01 << 24);              /* Empty for the moment */
+	len += 12;
+	
+	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
+
+	if (res < 0) {
+		ast_log(LOG_ERROR, "RTCP RR transmission error, rtcp halted: %s\n",strerror(errno));
+		/* Remove the scheduler */
+		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		rtp->rtcp->schedid = -1;
+		return 0;
+	}
+
+	rtp->rtcp->rr_count++;
+
+	if (rtcp_debug_test_addr(&rtp->rtcp->them)) {
+		ast_verbose("\n* Sending RTCP RR to %s:%d\n"
+			"  Our SSRC: %u\nTheir SSRC: %u\niFraction lost: %d\nCumulative loss: %u\n" 
+			"  IA jitter: %.4f\n" 
+			"  Their last SR: %u\n" 
+			"  DLSR: %4.4f (sec)\n\n",
+			ast_inet_ntoa(iabuf, sizeof(iabuf),
+			rtp->rtcp->them.sin_addr),
+			ntohs(rtp->rtcp->them.sin_port),
+			rtp->ssrc, rtp->themssrc, fraction, lost,
+			rtp->rxjitter,
+			rtp->rtcp->themrxlsr,
+			(double)(ntohl(rtcpheader[7])/65536.0));
+	}
+
+	return res;
+}
+
+/*! \brief Write and RTCP packet to the far end
+ * \note Decide if we are going to send an SR (with Reception Block) or RR 
+ * RR is sent if we have not sent any rtp packets in the previous interval */
+static int ast_rtcp_write(void *data)
+{
+	struct ast_rtp *rtp = data;
+	int res;
+	
+	if (rtp->txcount > rtp->rtcp->lastsrtxcount)
+		res = ast_rtcp_write_sr(data);
+	else
+		res = ast_rtcp_write_rr(data);
+	
+	return res;
+}
+
+/*! \brief generate comfort noice (CNG) */
 int ast_rtp_sendcng(struct ast_rtp *rtp, int level)
 {
 	unsigned int *rtpheader;
@@ -1637,7 +2192,7 @@
 		if (res <0) 
 			ast_log(LOG_ERROR, "RTP Comfort Noise Transmission error to %s:%d: %s\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), strerror(errno));
 		if(rtp_debug_test_addr(&rtp->them))
-			ast_verbose("Sent Comfort Noise RTP packet to %s:%d (type %d, seq %d, ts %d, len %d)\n"
+			ast_verbose("Sent Comfort Noise RTP packet to %s:%d (type %d, seq %d, ts %u, len %d)\n"
 					, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), payload, rtp->seqno, rtp->lastts,res - hdrlen);		   
 		   
 	}
@@ -1716,11 +2271,17 @@
 					ast_log(LOG_DEBUG, "RTP NAT: Can't write RTP to private address %s:%d, waiting for other end to send audio...\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port));
 				ast_set_flag(rtp, FLAG_NAT_INACTIVE_NOWARN);
 			}
+		} else {
+			rtp->txcount++;
+			rtp->txoctetcount +=(res - hdrlen);
+			
+			if (rtp->rtcp->schedid < 1) 
+			    rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
 		}
 				
 		if(rtp_debug_test_addr(&rtp->them))
-			ast_verbose("Sent RTP packet to   %s:%d (type %d, seq %u, ts %u, len %u)\n",
-				ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), codec, rtp->seqno, rtp->lastts,res - hdrlen);
+			ast_verbose("Sent RTP packet to %s:%d (type %d, seq %u, ts %u, len %u)\n",
+					ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), codec, rtp->seqno, rtp->lastts,res - hdrlen);
 	}
 
 	rtp->seqno++;
@@ -2176,6 +2737,37 @@
 	return RESULT_SUCCESS;
 }
 
+static int rtcp_do_debug_ip(int fd, int argc, char *argv[])
+{
+	struct hostent *hp;
+	struct ast_hostent ahp;
+	char iabuf[INET_ADDRSTRLEN];
+	int port = 0;
+	char *p, *arg;
+	if (argc != 5)
+		return RESULT_SHOWUSAGE;
+
+	arg = argv[4];
+	p = strstr(arg, ":");
+	if (p) {
+		*p = '\0';
+		p++;
+		port = atoi(p);
+	}
+	hp = ast_gethostbyname(arg, &ahp);
+	if (hp == NULL)
+		return RESULT_SHOWUSAGE;
+	rtcpdebugaddr.sin_family = AF_INET;
+	memcpy(&rtcpdebugaddr.sin_addr, hp->h_addr, sizeof(rtcpdebugaddr.sin_addr));
+	rtcpdebugaddr.sin_port = htons(port);
+	if (port == 0)
+		ast_cli(fd, "RTCP Debugging Enabled for IP: %s\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtcpdebugaddr.sin_addr));
+	else
+		ast_cli(fd, "RTCP Debugging Enabled for IP: %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtcpdebugaddr.sin_addr), port);
+	rtcpdebug = 1;
+	return RESULT_SUCCESS;
+}
+
 static int rtp_do_debug(int fd, int argc, char *argv[])
 {
 	if(argc != 2) {
@@ -2189,6 +2781,27 @@
 	return RESULT_SUCCESS;
 }
    
+static int rtcp_do_debug(int fd, int argc, char *argv[]){
+	if(argc != 3){
+		if(argc != 5)
+			return RESULT_SHOWUSAGE;
+		return rtcp_do_debug_ip(fd, argc, argv);
+	}
+	rtcpdebug = 1;
+	memset(&rtcpdebugaddr,0,sizeof(rtcpdebugaddr));
+	ast_cli(fd, "RTCP Debugging Enabled\n");
+	return RESULT_SUCCESS;
+}
+
+static int rtcp_do_stats(int fd, int argc, char *argv[]){
+	if(argc != 3){
+		return RESULT_SHOWUSAGE;
+	}
+	rtcpstats = 1;
+	ast_cli(fd, "RTCP Stats Enabled\n");
+	return RESULT_SUCCESS;
+}
+
 static int rtp_no_debug(int fd, int argc, char *argv[])
 {
 	if(argc !=3)
@@ -2198,6 +2811,25 @@
 	return RESULT_SUCCESS;
 }
 
+static int rtcp_no_debug(int fd, int argc, char *argv[])
+{
+	if(argc !=4)
+		return RESULT_SHOWUSAGE;
+	rtcpdebug = 0;
+	ast_cli(fd,"RTCP Debugging Disabled\n");
+	return RESULT_SUCCESS;
+}
+
+static int rtcp_no_stats(int fd, int argc, char *argv[])
+{
+	if(argc !=4)
+		return RESULT_SHOWUSAGE;
+	rtcpstats = 0;
+	ast_cli(fd,"RTCP Stats Disabled\n");
+	return RESULT_SUCCESS;
+}
+
+
 static int stun_do_debug(int fd, int argc, char *argv[])
 {
 	if(argc != 2) {
@@ -2244,6 +2876,37 @@
 static struct ast_cli_entry  cli_no_debug =
 {{ "rtp", "no", "debug", NULL } , rtp_no_debug, "Disable RTP debugging", no_debug_usage };
 
+static char rtcp_debug_usage[] =
+  "Usage: rtp rtcp debug [ip host[:port]]\n"
+  "       Enable dumping of all RTCP packets to and from host.\n";
+  
+static char rtcp_no_debug_usage[] =
+  "Usage: rtp rtcp no debug\n"
+  "       Disable all RTCP debugging\n";
+
+static char rtcp_stats_usage[] =
+  "Usage: rtp rtcp stats\n"
+  "       Enable dumping of RTCP stats.\n";
+  
+static char rtcp_no_stats_usage[] =
+  "Usage: rtp rtcp no stats\n"
+  "       Disable all RTCP stats\n";
+
+static struct ast_cli_entry  cli_debug_ip_rtcp =
+{{ "rtp", "rtcp", "debug", "ip", NULL } , rtcp_do_debug, "Enable RTCP debugging on IP", rtcp_debug_usage };
+
+static struct ast_cli_entry  cli_debug_rtcp =
+{{ "rtp", "rtcp", "debug", NULL } , rtcp_do_debug, "Enable RTCP debugging", rtcp_debug_usage };
+
+static struct ast_cli_entry  cli_no_debug_rtcp =
+{{ "rtp", "rtcp", "no", "debug", NULL } , rtcp_no_debug, "Disable RTCP debugging", rtcp_no_debug_usage };
+
+static struct ast_cli_entry  cli_stats_rtcp =
+{{ "rtp", "rtcp", "stats", NULL } , rtcp_do_stats, "Enable RTCP stats", rtcp_stats_usage };
+
+static struct ast_cli_entry  cli_no_stats_rtcp =
+{{ "rtp", "rtcp", "no", "stats", NULL } , rtcp_no_stats, "Disable RTCP stats", rtcp_no_stats_usage };
+
 static struct ast_cli_entry  cli_stun_debug =
 {{ "stun", "debug", NULL } , stun_do_debug, "Enable STUN debugging", stun_debug_usage };
 
@@ -2274,6 +2937,15 @@
 			if (rtpend > 65535)
 				rtpend = 65535;
 		}
+		if ((s = ast_variable_retrieve(cfg, "general", "rtcpinterval"))) {
+			rtcpinterval = atoi(s);
+			if (rtcpinterval == 0)
+				rtcpinterval = 0; /* Just so we're clear... it's zero */
+			if (rtcpinterval < RTCP_MIN_INTERVALMS)
+				rtcpinterval = RTCP_MIN_INTERVALMS; /* This catches negative numbers too */
+			if (rtcpinterval > RTCP_MAX_INTERVALMS)
+				rtcpinterval = RTCP_MAX_INTERVALMS;
+		}
 		if ((s = ast_variable_retrieve(cfg, "general", "rtpchecksums"))) {
 #ifdef SO_NO_CHECK
 			if (ast_false(s))
@@ -2311,7 +2983,16 @@
 	ast_cli_register(&cli_debug);
 	ast_cli_register(&cli_debug_ip);
 	ast_cli_register(&cli_no_debug);
+
+	ast_cli_register(&cli_debug_rtcp);
+	ast_cli_register(&cli_debug_ip_rtcp);
+	ast_cli_register(&cli_no_debug_rtcp);
+
+	ast_cli_register(&cli_stats_rtcp);
+	ast_cli_register(&cli_no_stats_rtcp);
+	
 	ast_cli_register(&cli_stun_debug);
 	ast_cli_register(&cli_stun_no_debug);
 	ast_rtp_reload();
 }
+



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 17:25:25 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 17:25:25 +0200
Subject: [solid-pbx-svn] r256 - trunk/configs
Message-ID: <200606181525.k5IFPPLs025931@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 17:25:24 +0200 (Sun, 18 Jun 2006)
New Revision: 256

Modified:
   trunk/configs/indications.conf.sample
Log:
Update to Asterisk SVN trunk r32253

------------------------------------------------------------------------
r32252 | oej | 2006-06-05 11:27:38 +0200 (Mon, 05 Jun 2006) | 3 lines

Issue #7231 - Missing indications from libtonezone (tzafrir)
  - "tuttter" changed to "stutter" ;-)

------------------------------------------------------------------------
r32253 | oej | 2006-06-05 11:31:02 +0200 (Mon, 05 Jun 2006) | 2 lines

Issue 7231 - Utility to convert libtonezone indications to indications.conf format

------------------------------------------------------------------------


Modified: trunk/configs/indications.conf.sample
===================================================================
--- trunk/configs/indications.conf.sample	2006-06-18 14:25:27 UTC (rev 255)
+++ trunk/configs/indications.conf.sample	2006-06-18 15:25:24 UTC (rev 256)
@@ -333,6 +333,33 @@
 info = !950/330,!1400/330,!1800/330,!0/1000,!950/330,!1400/330,!1800/330,!0/1000,!950/330,!1400/330,!1800/330,!0/1000,0
 stutter = 350+375+400
 
+[il]
+description = Israel
+ringcadence = 1000,3000
+dial = 414
+busy = 414/500,0/500
+ring = 414/1000,0/3000
+congestion = 414/250,0/250
+callwaiting = 414/100,0/100,414/100,0/100,414/600,0/3000
+dialrecall = !414/100,!0/100,!414/100,!0/100,!414/100,!0/100,414
+record = 1400/500,0/15000
+info = 1000/330,1400/330,1800/330,0/1000
+stutter = !414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,!414/160,!0/160,414
+
+
+[in]
+description = India
+ringcadence = 400,200,400,2000
+dial = 400*25
+busy = 400/750,0/750
+ring = 400*25/400,0/200,400*25/400,0/2000
+congestion = 400/250,0/250
+callwaiting = 400/200,0/100,400/200,0/7500
+dialrecall = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
+record = 1400/500,0/15000
+info = !950/330,!1400/330,!1800/330,0/1000
+stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
+
 [it]
 description = Italy
 ; Reference: http://www.itu.int/ITU-T/inr/forms/files/tones-0203.pdf
@@ -363,6 +390,19 @@
 ; STUTTER - not specified
 stutter = !425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,!425/100,!0/100,425
 
+[jp]
+description = Japan
+ringcadence = 1000,2000
+dial = 400
+busy = 400/500,0/500
+ring = 400+15/1000,0/2000
+congestion = 400/500,0/500
+callwaiting = 400+16/500,0/8000
+dialrecall = !400/200,!0/200,!400/200,!0/200,!400/200,!0/200,400
+record = 1400/500,0/15000
+info = !950/330,!1400/330,!1800/330,0
+stutter = !400/100,!0/100,!400/100,!0/100,!400/100,!0/100,!400/100,!0/100,!400/100,!0/100,!400/100,!0/100,400
+
 [mx]
 description = Mexico
 ringcadence = 2000,4000



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 17:37:34 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 17:37:34 +0200
Subject: [solid-pbx-svn] r257 - trunk/contrib/utils
Message-ID: <200606181537.k5IFbYDd027006@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 17:37:34 +0200 (Sun, 18 Jun 2006)
New Revision: 257

Added:
   trunk/contrib/utils/zones2indications.c
Log:
Add missing file

Added: trunk/contrib/utils/zones2indications.c
===================================================================
--- trunk/contrib/utils/zones2indications.c	2006-06-18 15:25:24 UTC (rev 256)
+++ trunk/contrib/utils/zones2indications.c	2006-06-18 15:37:34 UTC (rev 257)
@@ -0,0 +1,151 @@
+/*
+ * zones2indications: print libtonozone data as Asterisk indications.conf
+ * 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU Lesser General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ * 
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU Lesser General Public License for more details.
+ * 
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ *
+ * Author: Tzafrir Cohen <tzafrir.cohen at xorcom.com>
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <tonezone.h>
+#include <unistd.h>
+
+#define PROGRAM "zones2indication"
+
+void print_tone_zone_sound(struct tone_zone *zone_data, const char* name, 
+    int toneid) {
+  int i;
+  for (i=0; i<ZT_TONE_MAX; i++) {
+    if (zone_data->tones[i].toneid == toneid){
+      printf("%s = %s\n", name, zone_data->tones[i].data);
+      break;
+    }
+  }
+}
+
+void print_indications(struct tone_zone *zone_data) {
+  int i;
+  
+  printf (
+    "[%s]\n"
+    "; Source: libtonezone.\n"
+    "description = %s\n"
+    "\n",
+    zone_data->country, zone_data->description
+  );
+  
+  printf(  
+    "ringcadence = "
+  );
+  for(i=0; ; i++) {
+    if (zone_data->ringcadence[i] == 0)
+      break;
+    if (i != 0)
+      putchar(',');
+    printf("%d",zone_data->ringcadence[i]);
+  }
+  putchar('\n');
+  
+  print_tone_zone_sound(zone_data, "dial",        ZT_TONE_DIALTONE);
+  print_tone_zone_sound(zone_data, "busy",        ZT_TONE_BUSY);
+  print_tone_zone_sound(zone_data, "ring",        ZT_TONE_RINGTONE);
+  print_tone_zone_sound(zone_data, "congestion",  ZT_TONE_CONGESTION);
+  print_tone_zone_sound(zone_data, "callwaiting", ZT_TONE_CALLWAIT);
+  print_tone_zone_sound(zone_data, "dialrecall",  ZT_TONE_DIALRECALL);
+  print_tone_zone_sound(zone_data, "record",      ZT_TONE_RECORDTONE);
+  print_tone_zone_sound(zone_data, "info",        ZT_TONE_INFO);
+  print_tone_zone_sound(zone_data, "stutter",     ZT_TONE_STUTTER);
+  printf("\n\n");
+}
+
+int print_zone_by_id(int zone_num) {
+  struct tone_zone *zone_data = tone_zone_find_by_num(zone_num);
+
+  if (zone_data == NULL)
+    return 1;
+
+  print_indications(zone_data);
+
+  return 0;
+}
+
+int print_zone_by_country(char* country) {
+  struct tone_zone *zone_data = tone_zone_find(country);
+
+  if (zone_data == NULL)
+    return 1;
+
+  print_indications(zone_data);
+
+  return 0;
+}
+
+int print_all() {
+  int i;
+  /* loop over all possible zones */
+  for (i=0; ; i++) {
+    if (print_zone_by_id(i))
+      break;
+  }
+  return 0;
+}
+
+void usage() {
+  fprintf(stderr,
+      PROGRAM ": print libtonozone data as Asterisk indications.conf\n"
+      "\n"
+      "Usage:\n"
+      "  " PROGRAM " -a         Print all countries\n"
+      "  " PROGRAM " -c <code>  Select country by two-letter country code\n"
+      "  " PROGRAM " -n <num>   Select country by its internal libtonezone number\n"
+      "  " PROGRAM " -h         Print this text.\n"
+  );
+}
+
+int main(int argc, char* argv[]){
+  int country_code = -1;
+  int opt_print_all = 0;
+  int opt;
+  char* endptr = NULL;
+  
+  while((opt = getopt(argc, argv, "ac:hn:")) != -1) {
+    switch(opt) {
+      case 'a':
+        return print_all();
+      case 'c':
+        return print_zone_by_country(optarg);
+      case 'h':
+        usage();
+        return 0;
+      case 'n':
+        printf("number is %s.\n", optarg);
+        country_code = strtol(optarg, &endptr, 10);
+        return print_zone_by_id(country_code);
+        /* FIXME: what if this is not a number?
+        if (endptr != NULL) {
+          fprintf(stderr, "Error: Invalid country code %s, %d.\n",optarg, country_code);
+          usage();
+          exit(1);
+        }
+        */
+        break;
+    }
+  }
+  
+  /* If we got here, the user selected no option */
+  usage();
+  return 2;
+}



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 18:25:19 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 18:25:19 +0200
Subject: [solid-pbx-svn] r258 - in trunk: . include/asterisk
Message-ID: <200606181625.k5IGPJPf011952@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 18:25:18 +0200 (Sun, 18 Jun 2006)
New Revision: 258

Modified:
   trunk/include/asterisk/rtp.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32263

------------------------------------------------------------------------
r32255 | oej | 2006-06-05 11:42:28 +0200 (Mon, 05 Jun 2006) | 2 lines

Move definition of RTP structure to rtp.h (preparing for future changes)

------------------------------------------------------------------------


Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-18 15:37:34 UTC (rev 257)
+++ trunk/include/asterisk/rtp.h	2006-06-18 16:25:18 UTC (rev 258)
@@ -48,6 +48,8 @@
 /*! Maximum RTP-specific code */
 #define AST_RTP_MAX             AST_RTP_CISCO_DTMF
 
+#define MAX_RTP_PT			256
+
 struct ast_rtp_protocol {
 	/*! Get RTP struct, or NULL if unwilling to transfer */
 	struct ast_rtp *(* const get_rtp_info)(struct ast_channel *chan);
@@ -60,16 +62,76 @@
 	AST_LIST_ENTRY(ast_rtp_protocol) list;
 };
 
+typedef int (*ast_rtp_callback)(struct ast_rtp *rtp, struct ast_frame *f, void *data);
+
+
 /*!
  * \brief Structure representing a RTP session.
  *
  * RTP session is defined on page 9 of RFC 3550: "An association among a set of participants communicating with RTP.  A participant may be involved in multiple RTP sessions at the same time [...]"
  *
  */
-struct ast_rtp;
 
-typedef int (*ast_rtp_callback)(struct ast_rtp *rtp, struct ast_frame *f, void *data);
+/*! \brief The value of each payload format mapping: */
+struct rtpPayloadType {
+	int isAstFormat; 	/*!< whether the following code is an AST_FORMAT */
+	int code;
+};
 
+/*! \brief RTP session description */
+struct ast_rtp {
+	int s;
+	char resp;
+	struct ast_frame f;
+	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
+	unsigned int ssrc;		/*!< Synchronization source, RFC 3550, page 10. */
+	unsigned int themssrc;		/*!< Their SSRC */
+	unsigned int rxssrc;
+	unsigned int lastts;
+	unsigned int lastdigitts;
+	unsigned int lastrxts;
+	unsigned int lastividtimestamp;
+	unsigned int lastovidtimestamp;
+	unsigned int lasteventseqn;
+	int lastrxseqno;                /*!< Last received sequence number */
+	unsigned short seedrxseqno;     /*!< What sequence number did they start with?*/
+	unsigned int seedrxts;          /*!< What RTP timestamp did they start with? */
+	unsigned int rxcount;           /*!< How many packets have we received? */
+	unsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/
+	unsigned int txcount;           /*!< How many packets have we sent? */
+	unsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/
+	unsigned int cycles;            /*!< Shifted count of sequence number cycles */
+	double rxjitter;                /*!< Interarrival jitter at the moment */
+	double rxtransit;               /*!< Relative transit time for previous packet */
+	unsigned int lasteventendseqn;
+	int lasttxformat;
+	int lastrxformat;
+	int dtmfcount;
+	unsigned int dtmfduration;
+	int nat;
+	unsigned int flags;
+	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
+	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
+	struct timeval rxcore;
+	struct timeval txcore;
+	double drxcore;                 /*!< The double representation of the first received packet */
+	struct timeval lastrx;          /*!< timeval when we last received a packet */
+	struct timeval dtmfmute;
+	struct ast_smoother *smoother;
+	int *ioid;
+	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
+	unsigned short rxseqno;
+	struct sched_context *sched;
+	struct io_context *io;
+	void *data;
+	ast_rtp_callback callback;
+	struct rtpPayloadType current_RTP_PT[MAX_RTP_PT];
+	int rtp_lookup_code_cache_isAstFormat; /*!< a cache for the result of rtp_lookup_code(): */
+	int rtp_lookup_code_cache_code;
+	int rtp_lookup_code_cache_result;
+	struct ast_rtcp *rtcp;
+};
+
 /*!
  * \brief Initializate a RTP session.
  *

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 15:37:34 UTC (rev 257)
+++ trunk/rtp.c	2006-06-18 16:25:18 UTC (rev 258)
@@ -97,74 +97,12 @@
 static int ast_rtcp_write_rr(void *data);
 static unsigned int ast_rtcp_calc_interval(struct ast_rtp *rtp);
 
-/*! \brief The value of each payload format mapping: */
-struct rtpPayloadType {
-	int isAstFormat; 	/*!< whether the following code is an AST_FORMAT */
-	int code;
-};
-
-#define MAX_RTP_PT			256
-
 #define FLAG_3389_WARNING		(1 << 0)
 #define FLAG_NAT_ACTIVE			(3 << 1)
 #define FLAG_NAT_INACTIVE		(0 << 1)
 #define FLAG_NAT_INACTIVE_NOWARN	(1 << 1)
 #define FLAG_HAS_DTMF			(1 << 3)
 
-/*! \brief RTP session description */
-struct ast_rtp {
-	int s;
-	char resp;
-	struct ast_frame f;
-	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
-	unsigned int ssrc;		/*!< Synchronization source, RFC 3550, page 10. */
-	unsigned int themssrc;		/*!< Their SSRC */
-	unsigned int rxssrc;
-	unsigned int lastts;
-	unsigned int lastdigitts;
-	unsigned int lastrxts;
-	unsigned int lastividtimestamp;
-	unsigned int lastovidtimestamp;
-	unsigned int lasteventseqn;
-	int lastrxseqno;                /*!< Last received sequence number */
-	unsigned short seedrxseqno;     /*!< What sequence number did they start with?*/
-	unsigned int seedrxts;          /*!< What RTP timestamp did they start with? */
-	unsigned int rxcount;           /*!< How many packets have we received? */
-	unsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/
-	unsigned int txcount;           /*!< How many packets have we sent? */
-	unsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/
-	unsigned int cycles;            /*!< Shifted count of sequence number cycles */
-	double rxjitter;                /*!< Interarrival jitter at the moment */
-	double rxtransit;               /*!< Relative transit time for previous packet */
-	unsigned int lasteventendseqn;
-	int lasttxformat;
-	int lastrxformat;
-	int dtmfcount;
-	unsigned int dtmfduration;
-	int nat;
-	unsigned int flags;
-	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
-	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
-	struct timeval rxcore;
-	struct timeval txcore;
-	double drxcore;                 /*!< The double representation of the first received packet */
-	struct timeval lastrx;          /*!< timeval when we last received a packet */
-	struct timeval dtmfmute;
-	struct ast_smoother *smoother;
-	int *ioid;
-	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
-	unsigned short rxseqno;
-	struct sched_context *sched;
-	struct io_context *io;
-	void *data;
-	ast_rtp_callback callback;
-	struct rtpPayloadType current_RTP_PT[MAX_RTP_PT];
-	int rtp_lookup_code_cache_isAstFormat; /*!< a cache for the result of rtp_lookup_code(): */
-	int rtp_lookup_code_cache_code;
-	int rtp_lookup_code_cache_result;
-	struct ast_rtcp *rtcp;
-};
-
 /*!
  * \brief Structure defining an RTCP session.
  * 



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 19:25:47 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 19:25:47 +0200
Subject: [solid-pbx-svn] r259 - in trunk: configs pbx
Message-ID: <200606181725.k5IHPl2c005621@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 19:25:31 +0200 (Sun, 18 Jun 2006)
New Revision: 259

Modified:
   trunk/configs/extensions.conf.sample
   trunk/pbx/pbx_config.c
Log:
Update to Asterisk SVN trunk r32283

------------------------------------------------------------------------
r32281 | kpfleming | 2006-06-05 16:00:13 +0200 (Mon, 05 Jun 2006) | 2 lines

it's time... only enable global priority jumping if the config file says to do so

------------------------------------------------------------------------


Modified: trunk/configs/extensions.conf.sample
===================================================================
--- trunk/configs/extensions.conf.sample	2006-06-18 16:25:18 UTC (rev 258)
+++ trunk/configs/extensions.conf.sample	2006-06-18 17:25:31 UTC (rev 259)
@@ -50,7 +50,7 @@
 ; of Asterisk). Individual applications can also be requested to do this
 ; by passing a 'j' option in their arguments.
 ;
-priorityjumping=no
+;priorityjumping=yes
 ;
 ; You can include other config files, use the #include command
 ; (without the ';'). Note that this is different from the "include" command

Modified: trunk/pbx/pbx_config.c
===================================================================
--- trunk/pbx/pbx_config.c	2006-06-18 16:25:18 UTC (rev 258)
+++ trunk/pbx/pbx_config.c	2006-06-18 17:25:31 UTC (rev 259)
@@ -1358,7 +1358,7 @@
 	write_protect_config = ast_true(ast_variable_retrieve(cfg, "general", "writeprotect"));
 	autofallthrough_config = ast_true(ast_variable_retrieve(cfg, "general", "autofallthrough"));
 	clearglobalvars_config = ast_true(ast_variable_retrieve(cfg, "general", "clearglobalvars"));
-	ast_set2_flag(&ast_options, !ast_false(ast_variable_retrieve(cfg, "general", "priorityjumping")), AST_OPT_FLAG_PRIORITY_JUMPING);
+	ast_set2_flag(&ast_options, ast_true(ast_variable_retrieve(cfg, "general", "priorityjumping")), AST_OPT_FLAG_PRIORITY_JUMPING);
 								    
 	for (v = ast_variable_browse(cfg, "globals"); v; v = v->next) {
 		memset(realvalue, 0, sizeof(realvalue));



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 19:56:26 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 19:56:26 +0200
Subject: [solid-pbx-svn] r260 - trunk/include/asterisk
Message-ID: <200606181756.k5IHuQYB014488@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 19:56:13 +0200 (Sun, 18 Jun 2006)
New Revision: 260

Modified:
   trunk/include/asterisk/frame.h
Log:
Update to Asterisk SVN trunk r32303

------------------------------------------------------------------------
r32302 | oej | 2006-06-05 17:20:09 +0200 (Mon, 05 Jun 2006) | 2 lines

Doxygen updates

------------------------------------------------------------------------


Modified: trunk/include/asterisk/frame.h
===================================================================
--- trunk/include/asterisk/frame.h	2006-06-18 17:25:31 UTC (rev 259)
+++ trunk/include/asterisk/frame.h	2006-06-18 17:56:13 UTC (rev 260)
@@ -456,30 +456,47 @@
 
 extern void ast_frame_dump(const char *name, struct ast_frame *f, char *prefix);
 
-/*! \brief Initialize a codec preference to "no preference" */
+/*! \par AudioCodecPref Audio Codec Preferences
+	In order to negotiate audio codecs in the order they are configured
+	in <channel>.conf for a device, we set up codec preference lists
+	in addition to the codec capabilities setting. The capabilities
+	setting is a bitmask of audio and video codecs with no internal
+	order. This will reflect the offer given to the other side, where
+	the prefered codecs will be added to the top of the list in the
+	order indicated by the "allow" lines in the device configuration.
+	
+	Video codecs are not included in the preference lists since they
+	can't be transcoded and we just have to pick whatever is supported
+*/
+
+/*! \brief Initialize an audio codec preference to "no preference" See \ref AudioCodecPref */
 extern void ast_codec_pref_init(struct ast_codec_pref *pref);
 
-/*! \brief Codec located at  a particular place in the preference index */
+/*! \brief Codec located at a particular place in the preference index See \ref AudioCodecPref */
 extern int ast_codec_pref_index(struct ast_codec_pref *pref, int index);
 
-/*! \brief Remove a codec from a preference list */
+/*! \brief Remove audio a codec from a preference list */
 extern void ast_codec_pref_remove(struct ast_codec_pref *pref, int format);
 
-/*! \brief Append a codec to a preference list, removing it first if it was already there */
+/*! \brief Append a audio codec to a preference list, removing it first if it was already there 
+*/
 extern int ast_codec_pref_append(struct ast_codec_pref *pref, int format);
 
-/*! \brief Select the best format according to preference list from supplied options. 
+/*! \brief Select the best audio format according to preference list from supplied options. 
    If "find_best" is non-zero then if nothing is found, the "Best" format of 
    the format list is selected, otherwise 0 is returned. */
 extern int ast_codec_choose(struct ast_codec_pref *pref, int formats, int find_best);
 
-/*! \brief Parse an "allow" or "deny" line and update the mask and pref if provided */
+/*! \brief Parse an "allow" or "deny" line in a channel or device configuration 
+        and update the capabilities mask and pref if provided.
+	Video codecs are not added to codec preference lists, since we can not transcode
+ */
 extern void ast_parse_allow_disallow(struct ast_codec_pref *pref, int *mask, const char *list, int allowing);
 
-/*! \brief Dump codec preference list into a string */
+/*! \brief Dump audio codec preference list into a string */
 extern int ast_codec_pref_string(struct ast_codec_pref *pref, char *buf, size_t size);
 
-/*! \brief Shift a codec preference list up or down 65 bytes so that it becomes an ASCII string */
+/*! \brief Shift an audio codec preference list up or down 65 bytes so that it becomes an ASCII string */
 extern void ast_codec_pref_convert(struct ast_codec_pref *pref, char *buf, size_t size, int right);
 
 /*! \brief Returns the number of samples contained in the frame */



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 19:57:20 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 19:57:20 +0200
Subject: [solid-pbx-svn] r261 - in trunk: . channels contrib/utils include/asterisk
Message-ID: <200606181757.k5IHvK5l014872@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 19:57:15 +0200 (Sun, 18 Jun 2006)
New Revision: 261

Modified:
   trunk/channels/chan_iax2.c
   trunk/contrib/utils/zones2indications.c
   trunk/dnsmgr.c
   trunk/include/asterisk/dnsmgr.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32313

------------------------------------------------------------------------
r32304 | file | 2006-06-05 17:44:37 +0200 (Mon, 05 Jun 2006) | 2 lines

Convert chan_iax2 to use dnsmgr in order to deal with hostnames that can change their resolved IP (aka dynamic dns setups) (issue #6305 reported and fixed by ivanfm)

------------------------------------------------------------------------
r32305 | russell | 2006-06-05 17:47:36 +0200 (Mon, 05 Jun 2006) | 2 lines

clean up various formatting issues

------------------------------------------------------------------------
r32306 | russell | 2006-06-05 17:56:35 +0200 (Mon, 05 Jun 2006) | 2 lines

use the standard Asterisk copyright header

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 17:56:13 UTC (rev 260)
+++ trunk/channels/chan_iax2.c	2006-06-18 17:57:15 UTC (rev 261)
@@ -416,6 +416,7 @@
 	int callno;				/*!< Associated call number if applicable */
 	struct sockaddr_in us;			/*!< Who the server thinks we are */
 	struct iax2_registry *next;
+	struct ast_dnsmgr_entry *dnsmgr;	/*!< DNS refresh manager */
 };
 
 static struct iax2_registry *registrations;
@@ -1894,7 +1895,7 @@
 	} else if ((peer = find_peer(argv[3], 0))) {
 		if(ast_test_flag(peer, IAX_RTCACHEFRIENDS)) {
 			ast_set_flag(peer, IAX_RTAUTOCLEAR);
-			expire_registry(peer->name);
+			expire_registry(peer);
 			ast_cli(fd, "OK peer %s was removed from the cache.\n", argv[3]);
 		} else {
 			ast_cli(fd, "SORRY peer %s is not eligible for this operation.\n", argv[3]);
@@ -2532,7 +2533,7 @@
 		if (ast_test_flag(peer, IAX_RTAUTOCLEAR)) {
 			if (peer->expire > -1)
 				ast_sched_del(sched, peer->expire);
-			peer->expire = ast_sched_add(sched, (global_rtautoclear) * 1000, expire_registry, (void*)peer->name);
+			peer->expire = ast_sched_add(sched, (global_rtautoclear) * 1000, expire_registry, (void*)peer);
 		}
 		AST_LIST_LOCK(&peers);
 		AST_LIST_INSERT_HEAD(&peers, peer, entry);
@@ -4304,8 +4305,8 @@
 
 static int iax2_show_registry(int fd, int argc, char *argv[])
 {
-#define FORMAT2 "%-20.20s  %-10.10s  %-20.20s %8.8s  %s\n"
-#define FORMAT "%-20.20s  %-10.10s  %-20.20s %8d  %s\n"
+#define FORMAT2 "%-20.20s  %-6.6s  %-10.10s  %-20.20s %8.8s  %s\n"
+#define FORMAT  "%-20.20s  %-6.6s  %-10.10s  %-20.20s %8d  %s\n"
 	struct iax2_registry *reg = NULL;
 
 	char host[80];
@@ -4314,7 +4315,7 @@
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
 	AST_LIST_LOCK(&peers);
-	ast_cli(fd, FORMAT2, "Host", "Username", "Perceived", "Refresh", "State");
+	ast_cli(fd, FORMAT2, "Host", "dnsmgr", "Username", "Perceived", "Refresh", "State");
 	for (reg = registrations;reg;reg = reg->next) {
 		snprintf(host, sizeof(host), "%s:%d", ast_inet_ntoa(iabuf, sizeof(iabuf), reg->addr.sin_addr), ntohs(reg->addr.sin_port));
 		if (reg->us.sin_addr.s_addr) 
@@ -4322,6 +4323,7 @@
 		else
 			ast_copy_string(perceived, "<Unregistered>", sizeof(perceived));
 		ast_cli(fd, FORMAT, host, 
+					(reg->dnsmgr) ? "Y" : "N", 
 					reg->username, perceived, reg->refresh, regstate2str(reg->regstate));
 	}
 	AST_LIST_UNLOCK(&peers);
@@ -5447,7 +5449,6 @@
 	char *porta;
 	char *stringp=NULL;
 	
-	struct ast_hostent ahp; struct hostent *hp;
 	if (!value)
 		return -1;
 	ast_copy_string(copy, value, sizeof(copy));
@@ -5469,20 +5470,18 @@
 		ast_log(LOG_WARNING, "%s is not a valid port number at line %d\n", porta, lineno);
 		return -1;
 	}
-	hp = ast_gethostbyname(hostname, &ahp);
-	if (!hp) {
-		ast_log(LOG_WARNING, "Host '%s' not found at line %d\n", hostname, lineno);
+	if (!(reg = ast_calloc(1, sizeof(*reg))))
 		return -1;
+	if (ast_dnsmgr_lookup(hostname, &reg->addr.sin_addr, &reg->dnsmgr) < 0) {
+		free(reg);
+		return -1;
 	}
-	if (!(reg = ast_calloc(1, sizeof(*reg))))
-		return -1;
 	ast_copy_string(reg->username, username, sizeof(reg->username));
 	if (secret)
 		ast_copy_string(reg->secret, secret, sizeof(reg->secret));
 	reg->expire = -1;
 	reg->refresh = IAX_DEFAULT_REG_EXPIRE;
 	reg->addr.sin_family = AF_INET;
-	memcpy(&reg->addr.sin_addr, hp->h_addr, sizeof(&reg->addr.sin_addr));
 	reg->addr.sin_port = porta ? htons(atoi(porta)) : htons(IAX_DEFAULT_PORTNO);
 	reg->next = registrations;
 	reg->callno = 0;
@@ -5512,27 +5511,8 @@
 
 static void __expire_registry(void *data)
 {
-	char *name = data;
-	struct iax2_peer *p = NULL;
+	struct iax2_peer *p = data;
 
-	/* Go through and grab this peer... and if it needs to be removed... then do it */
-	AST_LIST_LOCK(&peers);
-	AST_LIST_TRAVERSE_SAFE_BEGIN(&peers, p, entry) {
-		if (!strcasecmp(p->name, name)) {
-			/* If we are set to auto clear then remove ourselves */
-			if (ast_test_flag(p, IAX_RTAUTOCLEAR))
-				AST_LIST_REMOVE_CURRENT(&peers, entry);
-			p->expire = -1;
-			break;
-		}
-	}
-	AST_LIST_TRAVERSE_SAFE_END
-	AST_LIST_UNLOCK(&peers);
-
-	/* Peer is already gone for whatever reason */
-	if (!p)
-		return;
-
 	ast_log(LOG_DEBUG, "Expiring registration for peer '%s'\n", p->name);
 	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: IAX2/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n", p->name);
 	/* Reset the address */
@@ -5548,16 +5528,18 @@
 
 	if (ast_test_flag(p, IAX_RTAUTOCLEAR)) {
 		/* We are already gone from the list, so we can just destroy ourselves */
+		AST_LIST_LOCK(&peers);
+		AST_LIST_REMOVE(&peers, p, entry);
+		AST_LIST_UNLOCK(&peers);
 		destroy_peer(p);
 	}
 }
 
 static int expire_registry(void *data)
 {
-#ifdef SCHED_MULTITHREADED
-	if (schedule_action(__expire_registry, data))
-#endif		
-		__expire_registry(data);
+	struct iax2_peer *p = data;
+	p->expire = -1;
+	__expire_registry(p);
 	return 0;
 }
 
@@ -5591,7 +5573,7 @@
 					if (p->expire > -1)
 						ast_sched_del(sched, p->expire);
 					ast_device_state_changed("IAX2/%s", p->name); /* Activate notification */
-					p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p->name);
+					p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p);
 					if (iax2_regfunk)
 						iax2_regfunk(p->name, 1);
 					register_peer_exten(p, 1);
@@ -5669,7 +5651,7 @@
 		p->expiry = refresh;
 	}
 	if (p->expiry && sin->sin_addr.s_addr)
-		p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p->name);
+		p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p);
 	iax_ie_append_str(&ied, IAX_IE_USERNAME, p->name);
 	iax_ie_append_int(&ied, IAX_IE_DATETIME, iax2_datetime(p->zonetag));
 	if (sin->sin_addr.s_addr) {
@@ -7741,6 +7723,31 @@
 	struct iax_ie_data ied;
 	if (option_debug && iaxdebug)
 		ast_log(LOG_DEBUG, "Sending registration request for '%s'\n", reg->username);
+
+	if (reg->dnsmgr && 
+	    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {
+		/* Maybe the IP has changed, force DNS refresh */
+		ast_dnsmgr_refresh(reg->dnsmgr, 1);
+	}
+	
+	/*
+	 * if IP has Changed, free allocated call to create a new one with new IP
+	 * call has the pointer to IP and must be updated to the new one
+	 */
+	if (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {
+		iax2_destroy(reg->callno);
+		reg->callno = 0;
+	}
+	if (!reg->addr.sin_addr.s_addr) {
+		if (option_debug && iaxdebug)
+			ast_log(LOG_DEBUG, "Unable to send registration request for '%s' without IP address\n", reg->username);
+		/* Setup the next registration attempt */
+		if (reg->expire > -1)
+			ast_sched_del(sched, reg->expire);
+		reg->expire  = ast_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);
+		return -1;
+	}
+
 	if (!reg->callno) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Allocate call number\n");
@@ -8633,6 +8640,8 @@
 			}
 			ast_mutex_unlock(&iaxsl[regl->callno]);
 		}
+		if (regl->dnsmgr)
+			ast_dnsmgr_release(regl->dnsmgr);
 		free(regl);
 	}
 	registrations = NULL;

Modified: trunk/contrib/utils/zones2indications.c
===================================================================
--- trunk/contrib/utils/zones2indications.c	2006-06-18 17:56:13 UTC (rev 260)
+++ trunk/contrib/utils/zones2indications.c	2006-06-18 17:57:15 UTC (rev 261)
@@ -1,23 +1,25 @@
 /*
- * zones2indications: print libtonozone data as Asterisk indications.conf
- * 
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU Lesser General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- * 
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU Lesser General Public License for more details.
- * 
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. 
+ * Asterisk -- An open source telephony toolkit.
  *
- * Author: Tzafrir Cohen <tzafrir.cohen at xorcom.com>
+ * Copyright (C) 1999 - 2006, Digium, Inc.
+ *
+ * Tzafrir Cohen <tzafrir.cohen at xorcom.com>
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License Version 2. See the LICENSE file
+ * at the top of the source tree.
  */
 
+/*! \file
+ * \brief print libtonozone data as Asterisk indications.conf
+ */ 
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <tonezone.h>

Modified: trunk/dnsmgr.c
===================================================================
--- trunk/dnsmgr.c	2006-06-18 17:56:13 UTC (rev 260)
+++ trunk/dnsmgr.c	2006-06-18 17:57:15 UTC (rev 261)
@@ -53,9 +53,11 @@
 static pthread_t refresh_thread = AST_PTHREADT_NULL;
 
 struct ast_dnsmgr_entry {
-	struct in_addr *result;
+	struct in_addr *result; 	/* where we will store the resulting address */
+	struct in_addr last; 		/* the last result, used to check if address has changed */
+	int changed;
 	AST_LIST_ENTRY(ast_dnsmgr_entry) list;
-	char name[1];
+	char name[1];			/* just 1 here, but we use calloc to allocate the correct size */
 };
 
 static AST_LIST_HEAD_STATIC(entry_list, ast_dnsmgr_entry);
@@ -104,6 +106,8 @@
 	AST_LIST_LOCK(&entry_list);
 	AST_LIST_REMOVE(&entry_list, entry, list);
 	AST_LIST_UNLOCK(&entry_list);
+	if (option_verbose > 4)
+		ast_verbose(VERBOSE_PREFIX_4 "removing dns manager for '%s'\n", entry->name);
 	free(entry);
 }
 
@@ -116,7 +120,7 @@
 		return 0;
 
 	if (option_verbose > 3)
-		ast_verbose(VERBOSE_PREFIX_3 "doing lookup for '%s'\n", name);
+		ast_verbose(VERBOSE_PREFIX_3 "doing dnsmgr_lookup for '%s'\n", name);
 
 	/* if it's actually an IP address and not a name,
 	   there's no need for a managed lookup */
@@ -134,12 +138,58 @@
 		return 0;
 	} else {
 		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_2 "adding manager for '%s'\n", name);
+			ast_verbose(VERBOSE_PREFIX_2 "adding dns manager for '%s'\n", name);
 		*dnsmgr = ast_dnsmgr_get(name, result);
 		return !*dnsmgr;
 	}
 }
 
+/*
+ * Refresh a dnsmgr entry
+ *
+ * XXX maybe we must lock the entry to make safer
+ */
+int ast_dnsmgr_refresh(struct ast_dnsmgr_entry *entry, int verbose)
+{
+	struct ast_hostent ahp;
+	struct hostent *hp;
+        char iabuf[INET_ADDRSTRLEN];
+        char iabuf2[INET_ADDRSTRLEN];
+        struct in_addr tmp;
+        
+	if (verbose && (option_verbose > 2))
+		ast_verbose(VERBOSE_PREFIX_2 "refreshing '%s'\n", entry->name);
+
+	if ((hp = ast_gethostbyname(entry->name, &ahp))) {
+		/* check to see if it has changed, do callback if requested (where de callback is defined ????) */
+		memcpy(&tmp, hp->h_addr, sizeof(tmp));
+		if (tmp.s_addr != entry->last.s_addr) {
+			ast_log(LOG_NOTICE, "host '%s' changed from %s to %s\n", 
+				entry->name,
+				ast_inet_ntoa(iabuf, sizeof(iabuf), entry->last),
+				ast_inet_ntoa(iabuf2, sizeof(iabuf2), tmp));
+
+			memcpy(entry->result, hp->h_addr, sizeof(entry->result));
+			memcpy(&entry->last, hp->h_addr, sizeof(entry->last));
+			entry->changed = 1;
+			return 1;
+		} 
+		
+	}
+	return 0;
+}
+
+/*
+ * Check if dnsmgr entry has changed from since last call to this function
+ */
+int ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry) 
+{
+	int ret = entry->changed;
+	entry->changed = 0;
+	
+	return ret;
+}
+
 static void *do_refresh(void *data)
 {
 	for (;;) {
@@ -155,8 +205,6 @@
 {
 	struct refresh_info *info = data;
 	struct ast_dnsmgr_entry *entry;
-	struct ast_hostent ahp;
-	struct hostent *hp;
 
 	/* if a refresh or reload is already in progress, exit now */
 	if (ast_mutex_trylock(&refresh_lock)) {
@@ -172,13 +220,7 @@
 		if (info->regex_present && regexec(&info->filter, entry->name, 0, NULL, 0))
 		    continue;
 
-		if (info->verbose && (option_verbose > 2))
-			ast_verbose(VERBOSE_PREFIX_2 "refreshing '%s'\n", entry->name);
-
-		if ((hp = ast_gethostbyname(entry->name, &ahp))) {
-			/* check to see if it has changed, do callback if requested */
-			memcpy(entry->result, hp->h_addr, sizeof(entry->result));
-		}
+		ast_dnsmgr_refresh(entry, info->verbose);
 	}
 	AST_LIST_UNLOCK(info->entries);
 

Modified: trunk/include/asterisk/dnsmgr.h
===================================================================
--- trunk/include/asterisk/dnsmgr.h	2006-06-18 17:56:13 UTC (rev 260)
+++ trunk/include/asterisk/dnsmgr.h	2006-06-18 17:57:15 UTC (rev 261)
@@ -37,6 +37,10 @@
 
 int ast_dnsmgr_lookup(const char *name, struct in_addr *result, struct ast_dnsmgr_entry **dnsmgr);
 
+int ast_dnsmgr_refresh(struct ast_dnsmgr_entry *entry, int verbose);
+
+int ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif /* c_plusplus */

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 17:56:13 UTC (rev 260)
+++ trunk/rtp.c	2006-06-18 17:57:15 UTC (rev 261)
@@ -580,9 +580,9 @@
 	}
 	if (rtp->resp && (rtp->resp != resp)) {
 		f = send_dtmf(rtp);
-	} else if(event_end & 0x80) {
+	} else if (event_end & 0x80) {
 		if (rtp->resp) {
-			if(rtp->lasteventendseqn != seqno) {
+			if (rtp->lasteventendseqn != seqno) {
 				f = send_dtmf(rtp);
 				rtp->lasteventendseqn = seqno;
 			}
@@ -724,86 +724,86 @@
 			return &ast_null_frame;
 		}
 		
-	if(rtcp_debug_test_addr(&sin)){
-	  	ast_verbose("\n\nGot RTCP from %s:%d\n",ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr),ntohs(sin.sin_port));
-	  	ast_verbose("PT: %d(%s)\n",pt,(pt==200)?"Sender Report":(pt==201)?"Receiver Report":(pt==192)?"H.261 FUR":"Unknown");
-	  	ast_verbose("Reception reports: %d\n",rc);
-	  	ast_verbose("SSRC of sender: %u\n",rtcpheader[i+1]);
-	}
+		if (rtcp_debug_test_addr(&sin)) {
+		  	ast_verbose("\n\nGot RTCP from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+		  	ast_verbose("PT: %d(%s)\n", pt, (pt == 200) ? "Sender Report" : (pt == 201) ? "Receiver Report" : (pt == 192) ? "H.261 FUR" : "Unknown");
+		  	ast_verbose("Reception reports: %d\n", rc);
+		  	ast_verbose("SSRC of sender: %u\n", rtcpheader[i + 1]);
+		}
     
-	i+=2; /* Advance past header and ssrc */
+		i += 2; /* Advance past header and ssrc */
 		
-	switch(pt){
-	  	case RTCP_PT_SR:
-	  		gettimeofday(&rtp->rtcp->rxlsr,NULL); /* To be able to populate the dlsr */
-	  		rtp->rtcp->spc = ntohl(rtcpheader[i+3]);
-	  		rtp->rtcp->soc = ntohl(rtcpheader[i+4]);
-	  		rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i+1]) & 0xffff) >> 16); /* Going to LSR in RR*/
+		switch (pt) {
+		case RTCP_PT_SR:
+			gettimeofday(&rtp->rtcp->rxlsr,NULL); /* To be able to populate the dlsr */
+			rtp->rtcp->spc = ntohl(rtcpheader[i+3]);
+			rtp->rtcp->soc = ntohl(rtcpheader[i + 4]);
+			rtp->rtcp->themrxlsr = ((ntohl(rtcpheader[i]) & 0x0000ffff) << 16) | ((ntohl(rtcpheader[i + 1]) & 0xffff) >> 16); /* Going to LSR in RR*/
     
-	  		if(rtcp_debug_test_addr(&sin)){
-	  			ast_verbose("NTP timestamp: %lu.%010lu\n",(unsigned long)ntohl(rtcpheader[i]), (unsigned long)ntohl(rtcpheader[i+1])*4096);
-	  			ast_verbose("RTP timestamp: %lu\n",(unsigned long)ntohl(rtcpheader[i+2]));
-	  			ast_verbose("SPC: %lu\tSOC: %lu\n",(unsigned long)ntohl(rtcpheader[i+3]),(unsigned long)ntohl(rtcpheader[i+4]));
-	  		}
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("NTP timestamp: %lu.%010lu\n", (unsigned long) ntohl(rtcpheader[i]), (unsigned long) ntohl(rtcpheader[i + 1]) * 4096);
+				ast_verbose("RTP timestamp: %lu\n", (unsigned long) ntohl(rtcpheader[i + 2]));
+				ast_verbose("SPC: %lu\tSOC: %lu\n", (unsigned long) ntohl(rtcpheader[i + 3]), (unsigned long) ntohl(rtcpheader[i + 4]));
+			}
 			i += 5;
 			if (rc < 1)
 				break;
 			/* Intentional fall through */
-	  	case RTCP_PT_RR:
-	  		/* This is the place to calculate RTT */
-				/* Don't handle multiple reception reports (rc > 1) yet */
-	  		gettimeofday(&now, NULL);
-	  		timeval2ntp(now, &msw, &lsw);
-	  		/* Use the one we sent them in our SR instead, rtcp->txlsr could have been rewritten if the dlsr is large */
-	  		if(ntohl(rtcpheader[i+4])){ /* We must have the LSR */
-	  			comp = ((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16);
-	  			a = (double)((comp & 0xffff0000) >> 16) + (double)((double)(comp & 0xffff)/1000000.);
-	  			lsr = (double)((ntohl(rtcpheader[i+4]) & 0xffff0000) >> 16) + (double)((double)(ntohl(rtcpheader[i+4]) & 0xffff)/1000000.);
-	  			dlsr = (double)(ntohl(rtcpheader[i+5])/65536.);
-	  			rtt = a - dlsr - lsr;
-	  			rtp->rtcp->accumulated_transit += rtt;
-	  			rtp->rtcp->rtt = rtt;
-	  			if(rtp->rtcp->maxrtt<rtt)
-	  				rtp->rtcp->maxrtt = rtt;
-	  			if(rtp->rtcp->minrtt>rtt)
-	  				rtp->rtcp->minrtt = rtt;
-	  		}
-	  		rtp->rtcp->reported_jitter = ntohl(rtcpheader[i+3]);
-	  		rtp->rtcp->reported_lost = ntohl(rtcpheader[i+1]) & 0xffffff;
-	  		if(rtcp_debug_test_addr(&sin)){
-	  			ast_verbose("Fraction lost: %ld\n", (((long)ntohl(rtcpheader[i+1]) & 0xff000000) >> 24));
-	  			ast_verbose("Packets lost so far: %d\n", rtp->rtcp->reported_lost);
-	  			ast_verbose("Highest sequence number: %ld\n", (long)(ntohl(rtcpheader[i+2]) & 0xffff));
-	  			ast_verbose("Sequence number cycles: %ld\n", (long)(ntohl(rtcpheader[i+2]) & 0xffff) >> 16);
-	  			ast_verbose("Interarrival jitter: %u\n", rtp->rtcp->reported_jitter);
-	  			ast_verbose("Last SR(our NTP): %lu.%010lu\n",(unsigned long)ntohl(rtcpheader[i+4])>>16,((unsigned long)ntohl(rtcpheader[i+4])<<16)*4096);
-	  			ast_verbose("DLSR: %4.4f (sec)\n",ntohl(rtcpheader[i+5])/65536.0);
-	  			if(rtt)
-	  				ast_verbose("RTT: %f(sec)\n", rtt);
-	  		}
-	  		break;
-	  	case RTCP_PT_FUR:
-	  		if(rtcp_debug_test_addr(&sin))
-	  			ast_verbose("Received an RTCP Fast Update Request\n");
-	  		rtp->f.frametype = AST_FRAME_CONTROL;
-	  		rtp->f.subclass = AST_CONTROL_VIDUPDATE;
-	  		rtp->f.datalen = 0;
-	  		rtp->f.samples = 0;
-	  		rtp->f.mallocd = 0;
-	  		rtp->f.src = "RTP";
-	  		f = &rtp->f;
-	  		break;
-	  	case RTCP_PT_SDES:
-	  		if(rtcp_debug_test_addr(&sin))
-	  			ast_verbose("Received an SDES from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
-			  break;
-	  	case RTCP_PT_BYE:
-	  		if(rtcp_debug_test_addr(&sin))
-	  			ast_verbose("Received a BYE from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
-			  break;
-	  	default:
-	  		ast_log(LOG_NOTICE, "Unknown RTCP packet (pt=%d) received from %s:%d\n", pt, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
-	  		break;
+		case RTCP_PT_RR:
+			/* This is the place to calculate RTT */
+			/* Don't handle multiple reception reports (rc > 1) yet */
+			gettimeofday(&now, NULL);
+			timeval2ntp(now, &msw, &lsw);
+			/* Use the one we sent them in our SR instead, rtcp->txlsr could have been rewritten if the dlsr is large */
+			if (ntohl(rtcpheader[i + 4])) { /* We must have the LSR */
+				comp = ((msw & 0xffff) << 16) | ((lsw & 0xffff0000) >> 16);
+				a = (double)((comp & 0xffff0000) >> 16) + (double)((double)(comp & 0xffff)/1000000.);
+				lsr = (double)((ntohl(rtcpheader[i + 4]) & 0xffff0000) >> 16) + (double)((double)(ntohl(rtcpheader[i + 4]) & 0xffff) / 1000000.);
+				dlsr = (double)(ntohl(rtcpheader[i + 5])/65536.);
+				rtt = a - dlsr - lsr;
+				rtp->rtcp->accumulated_transit += rtt;
+				rtp->rtcp->rtt = rtt;
+				if (rtp->rtcp->maxrtt<rtt)
+					rtp->rtcp->maxrtt = rtt;
+				if (rtp->rtcp->minrtt>rtt)
+				rtp->rtcp->minrtt = rtt;
+			}
+			rtp->rtcp->reported_jitter = ntohl(rtcpheader[i + 3]);
+			rtp->rtcp->reported_lost = ntohl(rtcpheader[i + 1]) & 0xffffff;
+			if (rtcp_debug_test_addr(&sin)) {
+				ast_verbose("Fraction lost: %ld\n", (((long) ntohl(rtcpheader[i + 1]) & 0xff000000) >> 24));
+				ast_verbose("Packets lost so far: %d\n", rtp->rtcp->reported_lost);
+				ast_verbose("Highest sequence number: %ld\n", (long) (ntohl(rtcpheader[i + 2]) & 0xffff));
+				ast_verbose("Sequence number cycles: %ld\n", (long) (ntohl(rtcpheader[i + 2]) & 0xffff) >> 16);
+				ast_verbose("Interarrival jitter: %u\n", rtp->rtcp->reported_jitter);
+				ast_verbose("Last SR(our NTP): %lu.%010lu\n",(unsigned long) ntohl(rtcpheader[i + 4]) >> 16,((unsigned long) ntohl(rtcpheader[i + 4]) << 16) * 4096);
+				ast_verbose("DLSR: %4.4f (sec)\n",ntohl(rtcpheader[i + 5])/65536.0);
+				if (rtt)
+					ast_verbose("RTT: %f(sec)\n", rtt);
+			}
+			break;
+		case RTCP_PT_FUR:
+			if (rtcp_debug_test_addr(&sin))
+				ast_verbose("Received an RTCP Fast Update Request\n");
+			rtp->f.frametype = AST_FRAME_CONTROL;
+			rtp->f.subclass = AST_CONTROL_VIDUPDATE;
+			rtp->f.datalen = 0;
+			rtp->f.samples = 0;
+			rtp->f.mallocd = 0;
+			rtp->f.src = "RTP";
+			f = &rtp->f;
+			break;
+		case RTCP_PT_SDES:
+			if (rtcp_debug_test_addr(&sin))
+				ast_verbose("Received an SDES from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			break;
+		case RTCP_PT_BYE:
+			if (rtcp_debug_test_addr(&sin))
+				ast_verbose("Received a BYE from %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			break;
+		default:
+			ast_log(LOG_NOTICE, "Unknown RTCP packet (pt=%d) received from %s:%d\n", pt, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port));
+			break;
 		}
 		position += (length + 1);
 	}
@@ -822,7 +822,7 @@
 	
 	if ((!rtp->rxcore.tv_sec && !rtp->rxcore.tv_usec) || mark) {
 		gettimeofday(&rtp->rxcore, NULL);
-		rtp->drxcore = (double)rtp->rxcore.tv_sec + (double)rtp->rxcore.tv_usec/1000000;
+		rtp->drxcore = (double) rtp->rxcore.tv_sec + (double) rtp->rxcore.tv_usec / 1000000;
 		/* map timestamp to a real time */
 		rtp->seedrxts = timestamp; /* Their RTP timestamp started with this */
 		rtp->rxcore.tv_sec -= timestamp / 8000;
@@ -850,12 +850,12 @@
 	transit = current_time - dtv;
 	d = transit - rtp->rxtransit;
 	rtp->rxtransit = transit;
-	if(d<0)
+	if (d<0)
 		d=-d;
 	rtp->rxjitter += (1./16.) * (d - rtp->rxjitter);
-	if(rtp->rxjitter > rtp->rtcp->maxrxjitter)
+	if (rtp->rxjitter > rtp->rtcp->maxrxjitter)
 		rtp->rtcp->maxrxjitter = rtp->rxjitter;
-	if(rtp->rxjitter < rtp->rtcp->minrxjitter)
+	if (rtp->rxjitter < rtp->rtcp->minrxjitter)
 		rtp->rtcp->minrxjitter = rtp->rxjitter;
 }
 
@@ -923,7 +923,7 @@
 		if ((rtp->them.sin_addr.s_addr != sin.sin_addr.s_addr) ||
 		    (rtp->them.sin_port != sin.sin_port)) {
 			rtp->them = sin;
-			if(rtp->rtcp) {
+			if (rtp->rtcp) {
 				memcpy(&rtp->rtcp->them, &sin, sizeof(rtp->rtcp->them));
 				rtp->rtcp->them.sin_port = htons(ntohs(rtp->them.sin_port)+1);
 			}
@@ -970,27 +970,27 @@
 
 	tseqno = rtp->lastrxseqno +1;
 
-	if(rtp->rxcount==1){
+	if (rtp->rxcount==1) {
 		/* This is the first RTP packet successfully received from source */
 		rtp->seedrxseqno = seqno;
 	}
 
-	if(rtp->rtcp->schedid<1){
+	if (rtp->rtcp->schedid<1) {
 		/* Schedule transmission of Receiver Report */
 		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
 	}
 
-	if(tseqno > RTP_SEQ_MOD){ /* if tseqno is greater than RTP_SEQ_MOD it would indicate that the sender cycled */
+	if (tseqno > RTP_SEQ_MOD) { /* if tseqno is greater than RTP_SEQ_MOD it would indicate that the sender cycled */
 		rtp->cycles += RTP_SEQ_MOD;
 		ast_verbose("SEQNO cycled: %u\t%d\n", rtp->cycles, seqno);
 	}
 
 	rtp->lastrxseqno = seqno;
 	
-	if(rtp->themssrc==0)
+	if (rtp->themssrc==0)
 		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
 	
-	if(rtp_debug_test_addr(&sin))
+	if (rtp_debug_test_addr(&sin))
 		ast_verbose("Got  RTP packet from %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 			ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
 
@@ -1001,7 +1001,7 @@
 		/* This is special in-band data that's not one of our codecs */
 		if (rtpPT.code == AST_RTP_DTMF) {
 			/* It's special -- rfc2833 process it */
-			if(rtp_debug_test_addr(&sin)) {
+			if (rtp_debug_test_addr(&sin)) {
 				unsigned char *data;
 				unsigned int event;
 				unsigned int event_end;
@@ -1672,7 +1672,7 @@
 
 void ast_rtp_stop(struct ast_rtp *rtp)
 {
-	if(rtp->rtcp->schedid>0){
+	if (rtp->rtcp->schedid>0) {
 		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 	}
@@ -1725,7 +1725,7 @@
 
 void ast_rtp_destroy(struct ast_rtp *rtp)
 {
-	if(rtcp_debug_test_addr(&rtp->them) || rtcpstats){
+	if (rtcp_debug_test_addr(&rtp->them) || rtcpstats) {
 		/*Print some info on the call here */
 		ast_verbose("  RTP-stats\n");
 		ast_verbose("* Our Receiver:\n");
@@ -1744,7 +1744,7 @@
 		ast_verbose("  RTT:		 %f\n", rtp->rtcp->rtt);
 	}
 
-	if(rtp->rtcp->schedid>0){
+	if (rtp->rtcp->schedid>0) {
 		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 	}
@@ -1897,10 +1897,10 @@
 	char bdata[512];
 	char iabuf[INET_ADDRSTRLEN];
 
-	if(!rtp || !rtp->rtcp || (&rtp->rtcp->them.sin_addr == 0))
+	if (!rtp || !rtp->rtcp || (&rtp->rtcp->them.sin_addr == 0))
 		return 0;
 	
-	if(!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
+	if (!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
 		ast_verbose("RTCP SR transmission error, rtcp halted %s\n",strerror(errno));
 		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
@@ -2010,7 +2010,7 @@
 	if (!rtp || !rtp->rtcp || (&rtp->rtcp->them.sin_addr == 0))
 		return 0;
 	  
-	if (!rtp->rtcp->them.sin_addr.s_addr){
+	if (!rtp->rtcp->them.sin_addr.s_addr) {
 		ast_log(LOG_ERROR, "RTCP RR transmission error to, rtcp halted %s\n",strerror(errno));
 		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
@@ -2129,7 +2129,7 @@
 		res = sendto(rtp->s, (void *)rtpheader, hdrlen + 1, 0, (struct sockaddr *)&rtp->them, sizeof(rtp->them));
 		if (res <0) 
 			ast_log(LOG_ERROR, "RTP Comfort Noise Transmission error to %s:%d: %s\n", ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), strerror(errno));
-		if(rtp_debug_test_addr(&rtp->them))
+		if (rtp_debug_test_addr(&rtp->them))
 			ast_verbose("Sent Comfort Noise RTP packet to %s:%d (type %d, seq %d, ts %u, len %d)\n"
 					, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), payload, rtp->seqno, rtp->lastts,res - hdrlen);		   
 		   
@@ -2217,7 +2217,7 @@
 			    rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
 		}
 				
-		if(rtp_debug_test_addr(&rtp->them))
+		if (rtp_debug_test_addr(&rtp->them))
 			ast_verbose("Sent RTP packet to %s:%d (type %d, seq %u, ts %u, len %u)\n",
 					ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), codec, rtp->seqno, rtp->lastts,res - hdrlen);
 	}
@@ -2708,8 +2708,8 @@
 
 static int rtp_do_debug(int fd, int argc, char *argv[])
 {
-	if(argc != 2) {
-		if(argc != 4)
+	if (argc != 2) {
+		if (argc != 4)
 			return RESULT_SHOWUSAGE;
 		return rtp_do_debug_ip(fd, argc, argv);
 	}
@@ -2719,9 +2719,9 @@
 	return RESULT_SUCCESS;
 }
    
-static int rtcp_do_debug(int fd, int argc, char *argv[]){
-	if(argc != 3){
-		if(argc != 5)
+static int rtcp_do_debug(int fd, int argc, char *argv[]) {
+	if (argc != 3) {
+		if (argc != 5)
 			return RESULT_SHOWUSAGE;
 		return rtcp_do_debug_ip(fd, argc, argv);
 	}
@@ -2731,8 +2731,8 @@
 	return RESULT_SUCCESS;
 }
 
-static int rtcp_do_stats(int fd, int argc, char *argv[]){
-	if(argc != 3){
+static int rtcp_do_stats(int fd, int argc, char *argv[]) {
+	if (argc != 3) {
 		return RESULT_SHOWUSAGE;
 	}
 	rtcpstats = 1;
@@ -2742,7 +2742,7 @@
 
 static int rtp_no_debug(int fd, int argc, char *argv[])
 {
-	if(argc !=3)
+	if (argc != 3)
 		return RESULT_SHOWUSAGE;
 	rtpdebug = 0;
 	ast_cli(fd,"RTP Debugging Disabled\n");
@@ -2751,7 +2751,7 @@
 
 static int rtcp_no_debug(int fd, int argc, char *argv[])
 {
-	if(argc !=4)
+	if (argc != 4)
 		return RESULT_SHOWUSAGE;
 	rtcpdebug = 0;
 	ast_cli(fd,"RTCP Debugging Disabled\n");
@@ -2760,7 +2760,7 @@
 
 static int rtcp_no_stats(int fd, int argc, char *argv[])
 {
-	if(argc !=4)
+	if (argc != 4)
 		return RESULT_SHOWUSAGE;
 	rtcpstats = 0;
 	ast_cli(fd,"RTCP Stats Disabled\n");
@@ -2770,7 +2770,7 @@
 
 static int stun_do_debug(int fd, int argc, char *argv[])
 {
-	if(argc != 2) {
+	if (argc != 2) {
 		return RESULT_SHOWUSAGE;
 	}
 	stundebug = 1;
@@ -2780,7 +2780,7 @@
    
 static int stun_no_debug(int fd, int argc, char *argv[])
 {
-	if(argc !=3)
+	if (argc != 3)
 		return RESULT_SHOWUSAGE;
 	stundebug = 0;
 	ast_cli(fd,"STUN Debugging Disabled\n");



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 20:25:34 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 20:25:34 +0200
Subject: [solid-pbx-svn] r262 - in trunk: . channels include/asterisk
Message-ID: <200606181825.k5IIPYBQ022471@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 20:25:30 +0200 (Sun, 18 Jun 2006)
New Revision: 262

Modified:
   trunk/channels/chan_iax2.c
   trunk/dnsmgr.c
   trunk/include/asterisk/dnsmgr.h
Log:
Update to Asterisk SVN trunk r32333

------------------------------------------------------------------------
r32327 | russell | 2006-06-05 18:17:31 +0200 (Mon, 05 Jun 2006) | 3 lines

revert the changes to allow chan_iax2 to use dnsmgr for registrations.
my concerns are listed in issue #6305

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 17:57:15 UTC (rev 261)
+++ trunk/channels/chan_iax2.c	2006-06-18 18:25:30 UTC (rev 262)
@@ -416,7 +416,6 @@
 	int callno;				/*!< Associated call number if applicable */
 	struct sockaddr_in us;			/*!< Who the server thinks we are */
 	struct iax2_registry *next;
-	struct ast_dnsmgr_entry *dnsmgr;	/*!< DNS refresh manager */
 };
 
 static struct iax2_registry *registrations;
@@ -1895,7 +1894,7 @@
 	} else if ((peer = find_peer(argv[3], 0))) {
 		if(ast_test_flag(peer, IAX_RTCACHEFRIENDS)) {
 			ast_set_flag(peer, IAX_RTAUTOCLEAR);
-			expire_registry(peer);
+			expire_registry(peer->name);
 			ast_cli(fd, "OK peer %s was removed from the cache.\n", argv[3]);
 		} else {
 			ast_cli(fd, "SORRY peer %s is not eligible for this operation.\n", argv[3]);
@@ -2533,7 +2532,7 @@
 		if (ast_test_flag(peer, IAX_RTAUTOCLEAR)) {
 			if (peer->expire > -1)
 				ast_sched_del(sched, peer->expire);
-			peer->expire = ast_sched_add(sched, (global_rtautoclear) * 1000, expire_registry, (void*)peer);
+			peer->expire = ast_sched_add(sched, (global_rtautoclear) * 1000, expire_registry, (void*)peer->name);
 		}
 		AST_LIST_LOCK(&peers);
 		AST_LIST_INSERT_HEAD(&peers, peer, entry);
@@ -4305,8 +4304,8 @@
 
 static int iax2_show_registry(int fd, int argc, char *argv[])
 {
-#define FORMAT2 "%-20.20s  %-6.6s  %-10.10s  %-20.20s %8.8s  %s\n"
-#define FORMAT  "%-20.20s  %-6.6s  %-10.10s  %-20.20s %8d  %s\n"
+#define FORMAT2 "%-20.20s  %-10.10s  %-20.20s %8.8s  %s\n"
+#define FORMAT "%-20.20s  %-10.10s  %-20.20s %8d  %s\n"
 	struct iax2_registry *reg = NULL;
 
 	char host[80];
@@ -4315,7 +4314,7 @@
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
 	AST_LIST_LOCK(&peers);
-	ast_cli(fd, FORMAT2, "Host", "dnsmgr", "Username", "Perceived", "Refresh", "State");
+	ast_cli(fd, FORMAT2, "Host", "Username", "Perceived", "Refresh", "State");
 	for (reg = registrations;reg;reg = reg->next) {
 		snprintf(host, sizeof(host), "%s:%d", ast_inet_ntoa(iabuf, sizeof(iabuf), reg->addr.sin_addr), ntohs(reg->addr.sin_port));
 		if (reg->us.sin_addr.s_addr) 
@@ -4323,7 +4322,6 @@
 		else
 			ast_copy_string(perceived, "<Unregistered>", sizeof(perceived));
 		ast_cli(fd, FORMAT, host, 
-					(reg->dnsmgr) ? "Y" : "N", 
 					reg->username, perceived, reg->refresh, regstate2str(reg->regstate));
 	}
 	AST_LIST_UNLOCK(&peers);
@@ -5449,6 +5447,7 @@
 	char *porta;
 	char *stringp=NULL;
 	
+	struct ast_hostent ahp; struct hostent *hp;
 	if (!value)
 		return -1;
 	ast_copy_string(copy, value, sizeof(copy));
@@ -5470,18 +5469,20 @@
 		ast_log(LOG_WARNING, "%s is not a valid port number at line %d\n", porta, lineno);
 		return -1;
 	}
-	if (!(reg = ast_calloc(1, sizeof(*reg))))
+	hp = ast_gethostbyname(hostname, &ahp);
+	if (!hp) {
+		ast_log(LOG_WARNING, "Host '%s' not found at line %d\n", hostname, lineno);
 		return -1;
-	if (ast_dnsmgr_lookup(hostname, &reg->addr.sin_addr, &reg->dnsmgr) < 0) {
-		free(reg);
-		return -1;
 	}
+	if (!(reg = ast_calloc(1, sizeof(*reg))))
+		return -1;
 	ast_copy_string(reg->username, username, sizeof(reg->username));
 	if (secret)
 		ast_copy_string(reg->secret, secret, sizeof(reg->secret));
 	reg->expire = -1;
 	reg->refresh = IAX_DEFAULT_REG_EXPIRE;
 	reg->addr.sin_family = AF_INET;
+	memcpy(&reg->addr.sin_addr, hp->h_addr, sizeof(&reg->addr.sin_addr));
 	reg->addr.sin_port = porta ? htons(atoi(porta)) : htons(IAX_DEFAULT_PORTNO);
 	reg->next = registrations;
 	reg->callno = 0;
@@ -5511,8 +5512,27 @@
 
 static void __expire_registry(void *data)
 {
-	struct iax2_peer *p = data;
+	char *name = data;
+	struct iax2_peer *p = NULL;
 
+	/* Go through and grab this peer... and if it needs to be removed... then do it */
+	AST_LIST_LOCK(&peers);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&peers, p, entry) {
+		if (!strcasecmp(p->name, name)) {
+			/* If we are set to auto clear then remove ourselves */
+			if (ast_test_flag(p, IAX_RTAUTOCLEAR))
+				AST_LIST_REMOVE_CURRENT(&peers, entry);
+			p->expire = -1;
+			break;
+		}
+	}
+	AST_LIST_TRAVERSE_SAFE_END
+	AST_LIST_UNLOCK(&peers);
+
+	/* Peer is already gone for whatever reason */
+	if (!p)
+		return;
+
 	ast_log(LOG_DEBUG, "Expiring registration for peer '%s'\n", p->name);
 	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: IAX2/%s\r\nPeerStatus: Unregistered\r\nCause: Expired\r\n", p->name);
 	/* Reset the address */
@@ -5528,18 +5548,16 @@
 
 	if (ast_test_flag(p, IAX_RTAUTOCLEAR)) {
 		/* We are already gone from the list, so we can just destroy ourselves */
-		AST_LIST_LOCK(&peers);
-		AST_LIST_REMOVE(&peers, p, entry);
-		AST_LIST_UNLOCK(&peers);
 		destroy_peer(p);
 	}
 }
 
 static int expire_registry(void *data)
 {
-	struct iax2_peer *p = data;
-	p->expire = -1;
-	__expire_registry(p);
+#ifdef SCHED_MULTITHREADED
+	if (schedule_action(__expire_registry, data))
+#endif		
+		__expire_registry(data);
 	return 0;
 }
 
@@ -5573,7 +5591,7 @@
 					if (p->expire > -1)
 						ast_sched_del(sched, p->expire);
 					ast_device_state_changed("IAX2/%s", p->name); /* Activate notification */
-					p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p);
+					p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p->name);
 					if (iax2_regfunk)
 						iax2_regfunk(p->name, 1);
 					register_peer_exten(p, 1);
@@ -5651,7 +5669,7 @@
 		p->expiry = refresh;
 	}
 	if (p->expiry && sin->sin_addr.s_addr)
-		p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p);
+		p->expire = ast_sched_add(sched, (p->expiry + 10) * 1000, expire_registry, (void *)p->name);
 	iax_ie_append_str(&ied, IAX_IE_USERNAME, p->name);
 	iax_ie_append_int(&ied, IAX_IE_DATETIME, iax2_datetime(p->zonetag));
 	if (sin->sin_addr.s_addr) {
@@ -7723,31 +7741,6 @@
 	struct iax_ie_data ied;
 	if (option_debug && iaxdebug)
 		ast_log(LOG_DEBUG, "Sending registration request for '%s'\n", reg->username);
-
-	if (reg->dnsmgr && 
-	    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {
-		/* Maybe the IP has changed, force DNS refresh */
-		ast_dnsmgr_refresh(reg->dnsmgr, 1);
-	}
-	
-	/*
-	 * if IP has Changed, free allocated call to create a new one with new IP
-	 * call has the pointer to IP and must be updated to the new one
-	 */
-	if (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {
-		iax2_destroy(reg->callno);
-		reg->callno = 0;
-	}
-	if (!reg->addr.sin_addr.s_addr) {
-		if (option_debug && iaxdebug)
-			ast_log(LOG_DEBUG, "Unable to send registration request for '%s' without IP address\n", reg->username);
-		/* Setup the next registration attempt */
-		if (reg->expire > -1)
-			ast_sched_del(sched, reg->expire);
-		reg->expire  = ast_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);
-		return -1;
-	}
-
 	if (!reg->callno) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Allocate call number\n");
@@ -8640,8 +8633,6 @@
 			}
 			ast_mutex_unlock(&iaxsl[regl->callno]);
 		}
-		if (regl->dnsmgr)
-			ast_dnsmgr_release(regl->dnsmgr);
 		free(regl);
 	}
 	registrations = NULL;

Modified: trunk/dnsmgr.c
===================================================================
--- trunk/dnsmgr.c	2006-06-18 17:57:15 UTC (rev 261)
+++ trunk/dnsmgr.c	2006-06-18 18:25:30 UTC (rev 262)
@@ -53,11 +53,9 @@
 static pthread_t refresh_thread = AST_PTHREADT_NULL;
 
 struct ast_dnsmgr_entry {
-	struct in_addr *result; 	/* where we will store the resulting address */
-	struct in_addr last; 		/* the last result, used to check if address has changed */
-	int changed;
+	struct in_addr *result;
 	AST_LIST_ENTRY(ast_dnsmgr_entry) list;
-	char name[1];			/* just 1 here, but we use calloc to allocate the correct size */
+	char name[1];
 };
 
 static AST_LIST_HEAD_STATIC(entry_list, ast_dnsmgr_entry);
@@ -106,8 +104,6 @@
 	AST_LIST_LOCK(&entry_list);
 	AST_LIST_REMOVE(&entry_list, entry, list);
 	AST_LIST_UNLOCK(&entry_list);
-	if (option_verbose > 4)
-		ast_verbose(VERBOSE_PREFIX_4 "removing dns manager for '%s'\n", entry->name);
 	free(entry);
 }
 
@@ -120,7 +116,7 @@
 		return 0;
 
 	if (option_verbose > 3)
-		ast_verbose(VERBOSE_PREFIX_3 "doing dnsmgr_lookup for '%s'\n", name);
+		ast_verbose(VERBOSE_PREFIX_3 "doing lookup for '%s'\n", name);
 
 	/* if it's actually an IP address and not a name,
 	   there's no need for a managed lookup */
@@ -138,58 +134,12 @@
 		return 0;
 	} else {
 		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_2 "adding dns manager for '%s'\n", name);
+			ast_verbose(VERBOSE_PREFIX_2 "adding manager for '%s'\n", name);
 		*dnsmgr = ast_dnsmgr_get(name, result);
 		return !*dnsmgr;
 	}
 }
 
-/*
- * Refresh a dnsmgr entry
- *
- * XXX maybe we must lock the entry to make safer
- */
-int ast_dnsmgr_refresh(struct ast_dnsmgr_entry *entry, int verbose)
-{
-	struct ast_hostent ahp;
-	struct hostent *hp;
-        char iabuf[INET_ADDRSTRLEN];
-        char iabuf2[INET_ADDRSTRLEN];
-        struct in_addr tmp;
-        
-	if (verbose && (option_verbose > 2))
-		ast_verbose(VERBOSE_PREFIX_2 "refreshing '%s'\n", entry->name);
-
-	if ((hp = ast_gethostbyname(entry->name, &ahp))) {
-		/* check to see if it has changed, do callback if requested (where de callback is defined ????) */
-		memcpy(&tmp, hp->h_addr, sizeof(tmp));
-		if (tmp.s_addr != entry->last.s_addr) {
-			ast_log(LOG_NOTICE, "host '%s' changed from %s to %s\n", 
-				entry->name,
-				ast_inet_ntoa(iabuf, sizeof(iabuf), entry->last),
-				ast_inet_ntoa(iabuf2, sizeof(iabuf2), tmp));
-
-			memcpy(entry->result, hp->h_addr, sizeof(entry->result));
-			memcpy(&entry->last, hp->h_addr, sizeof(entry->last));
-			entry->changed = 1;
-			return 1;
-		} 
-		
-	}
-	return 0;
-}
-
-/*
- * Check if dnsmgr entry has changed from since last call to this function
- */
-int ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry) 
-{
-	int ret = entry->changed;
-	entry->changed = 0;
-	
-	return ret;
-}
-
 static void *do_refresh(void *data)
 {
 	for (;;) {
@@ -205,6 +155,8 @@
 {
 	struct refresh_info *info = data;
 	struct ast_dnsmgr_entry *entry;
+	struct ast_hostent ahp;
+	struct hostent *hp;
 
 	/* if a refresh or reload is already in progress, exit now */
 	if (ast_mutex_trylock(&refresh_lock)) {
@@ -220,7 +172,13 @@
 		if (info->regex_present && regexec(&info->filter, entry->name, 0, NULL, 0))
 		    continue;
 
-		ast_dnsmgr_refresh(entry, info->verbose);
+		if (info->verbose && (option_verbose > 2))
+			ast_verbose(VERBOSE_PREFIX_2 "refreshing '%s'\n", entry->name);
+
+		if ((hp = ast_gethostbyname(entry->name, &ahp))) {
+			/* check to see if it has changed, do callback if requested */
+			memcpy(entry->result, hp->h_addr, sizeof(entry->result));
+		}
 	}
 	AST_LIST_UNLOCK(info->entries);
 

Modified: trunk/include/asterisk/dnsmgr.h
===================================================================
--- trunk/include/asterisk/dnsmgr.h	2006-06-18 17:57:15 UTC (rev 261)
+++ trunk/include/asterisk/dnsmgr.h	2006-06-18 18:25:30 UTC (rev 262)
@@ -37,10 +37,6 @@
 
 int ast_dnsmgr_lookup(const char *name, struct in_addr *result, struct ast_dnsmgr_entry **dnsmgr);
 
-int ast_dnsmgr_refresh(struct ast_dnsmgr_entry *entry, int verbose);
-
-int ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry);
-
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif /* c_plusplus */



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 21:25:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 21:25:45 +0200
Subject: [solid-pbx-svn] r263 - trunk/include/asterisk
Message-ID: <200606181925.k5IJPjs2016738@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 21:25:40 +0200 (Sun, 18 Jun 2006)
New Revision: 263

Modified:
   trunk/include/asterisk/alaw.h
   trunk/include/asterisk/channel.h
   trunk/include/asterisk/file.h
   trunk/include/asterisk/frame.h
   trunk/include/asterisk/ulaw.h
Log:
Update to Asterisk SVN trunk r32353

------------------------------------------------------------------------
r32349 | kpfleming | 2006-06-05 20:05:53 +0200 (Mon, 05 Jun 2006) | 2 lines

yet another massive performance and memory savings improvement

------------------------------------------------------------------------


Modified: trunk/include/asterisk/alaw.h
===================================================================
--- trunk/include/asterisk/alaw.h	2006-06-18 18:25:30 UTC (rev 262)
+++ trunk/include/asterisk/alaw.h	2006-06-18 19:25:40 UTC (rev 263)
@@ -27,7 +27,7 @@
 /*!
  * To init the ulaw to slinear conversion stuff, this needs to be run.
  */
-extern void ast_alaw_init(void);
+void ast_alaw_init(void);
 
 /*! converts signed linear to mulaw */
 /*!

Modified: trunk/include/asterisk/channel.h
===================================================================
--- trunk/include/asterisk/channel.h	2006-06-18 18:25:30 UTC (rev 262)
+++ trunk/include/asterisk/channel.h	2006-06-18 19:25:40 UTC (rev 263)
@@ -999,7 +999,7 @@
 
 /*! Pick the best codec  */
 /* Choose the best codec...  Uhhh...   Yah. */
-extern int ast_best_codec(int fmts);
+int ast_best_codec(int fmts);
 
 
 /*! Checks the value of an option */
@@ -1254,10 +1254,10 @@
 									ast_set_flag(c, AST_FLAG_BLOCKING); \
 									} }
 
-extern ast_group_t ast_get_group(char *s);
+ast_group_t ast_get_group(char *s);
 
 /*! \brief print call- and pickup groups into buffer */
-extern char *ast_print_group(char *buf, int buflen, ast_group_t group);
+char *ast_print_group(char *buf, int buflen, ast_group_t group);
 
 /*! \brief Convert enum channelreloadreason to text string for manager event
 	\param reason	Enum channelreloadreason - reason for reload (manager, cli, start etc)
@@ -1265,7 +1265,7 @@
 const char *channelreloadreason2txt(enum channelreloadreason reason);
 
 /*! \brief return an ast_variable list of channeltypes */
-extern struct ast_variable *ast_channeltype_list(void);
+struct ast_variable *ast_channeltype_list(void);
 
 #if defined(__cplusplus) || defined(c_plusplus)
 }

Modified: trunk/include/asterisk/file.h
===================================================================
--- trunk/include/asterisk/file.h	2006-06-18 18:25:30 UTC (rev 262)
+++ trunk/include/asterisk/file.h	2006-06-18 19:25:40 UTC (rev 263)
@@ -394,7 +394,7 @@
  * Initializes all the various file stuff.  Basically just registers the cli stuff
  * Returns 0 all the time
  */
-extern int ast_file_init(void);
+int ast_file_init(void);
 
 
 #define AST_RESERVED_POINTERS 20

Modified: trunk/include/asterisk/frame.h
===================================================================
--- trunk/include/asterisk/frame.h	2006-06-18 18:25:30 UTC (rev 262)
+++ trunk/include/asterisk/frame.h	2006-06-18 19:25:40 UTC (rev 263)
@@ -408,7 +408,7 @@
  * \param format id of format
  * \return A static string containing the name of the format or "UNKN" if unknown.
  */
-extern char* ast_getformatname(int format);
+char* ast_getformatname(int format);
 
 /*! \brief Get the names of a set of formats
  * \param buf a buffer for the output string
@@ -418,33 +418,33 @@
  * ex: for format=AST_FORMAT_GSM|AST_FORMAT_SPEEX|AST_FORMAT_ILBC it will return "0x602 (GSM|SPEEX|ILBC)"
  * \return The return value is buf.
  */
-extern char* ast_getformatname_multiple(char *buf, size_t size, int format);
+char* ast_getformatname_multiple(char *buf, size_t size, int format);
 
 /*!
  * \brief Gets a format from a name.
  * \param name string of format
  * \return This returns the form of the format in binary on success, 0 on error.
  */
-extern int ast_getformatbyname(const char *name);
+int ast_getformatbyname(const char *name);
 
 /*! \brief Get a name from a format 
  * Gets a name from a format
  * \param codec codec number (1,2,4,8,16,etc.)
  * \return This returns a static string identifying the format on success, 0 on error.
  */
-extern char *ast_codec2str(int codec);
+char *ast_codec2str(int codec);
 
 struct ast_smoother;
 
-extern struct ast_format_list *ast_get_format_list_index(int index);
-extern struct ast_format_list *ast_get_format_list(size_t *size);
-extern struct ast_smoother *ast_smoother_new(int bytes);
-extern void ast_smoother_set_flags(struct ast_smoother *smoother, int flags);
-extern int ast_smoother_get_flags(struct ast_smoother *smoother);
-extern void ast_smoother_free(struct ast_smoother *s);
-extern void ast_smoother_reset(struct ast_smoother *s, int bytes);
-extern int __ast_smoother_feed(struct ast_smoother *s, struct ast_frame *f, int swap);
-extern struct ast_frame *ast_smoother_read(struct ast_smoother *s);
+struct ast_format_list *ast_get_format_list_index(int index);
+struct ast_format_list *ast_get_format_list(size_t *size);
+struct ast_smoother *ast_smoother_new(int bytes);
+void ast_smoother_set_flags(struct ast_smoother *smoother, int flags);
+int ast_smoother_get_flags(struct ast_smoother *smoother);
+void ast_smoother_free(struct ast_smoother *s);
+void ast_smoother_reset(struct ast_smoother *s, int bytes);
+int __ast_smoother_feed(struct ast_smoother *s, struct ast_frame *f, int swap);
+struct ast_frame *ast_smoother_read(struct ast_smoother *s);
 #define ast_smoother_feed(s,f) __ast_smoother_feed(s, f, 0)
 #if __BYTE_ORDER == __LITTLE_ENDIAN
 #define ast_smoother_feed_be(s,f) __ast_smoother_feed(s, f, 1)
@@ -454,7 +454,7 @@
 #define ast_smoother_feed_le(s,f) __ast_smoother_feed(s, f, 1)
 #endif
 
-extern void ast_frame_dump(const char *name, struct ast_frame *f, char *prefix);
+void ast_frame_dump(const char *name, struct ast_frame *f, char *prefix);
 
 /*! \par AudioCodecPref Audio Codec Preferences
 	In order to negotiate audio codecs in the order they are configured
@@ -470,43 +470,43 @@
 */
 
 /*! \brief Initialize an audio codec preference to "no preference" See \ref AudioCodecPref */
-extern void ast_codec_pref_init(struct ast_codec_pref *pref);
+void ast_codec_pref_init(struct ast_codec_pref *pref);
 
 /*! \brief Codec located at a particular place in the preference index See \ref AudioCodecPref */
-extern int ast_codec_pref_index(struct ast_codec_pref *pref, int index);
+int ast_codec_pref_index(struct ast_codec_pref *pref, int index);
 
 /*! \brief Remove audio a codec from a preference list */
-extern void ast_codec_pref_remove(struct ast_codec_pref *pref, int format);
+void ast_codec_pref_remove(struct ast_codec_pref *pref, int format);
 
 /*! \brief Append a audio codec to a preference list, removing it first if it was already there 
 */
-extern int ast_codec_pref_append(struct ast_codec_pref *pref, int format);
+int ast_codec_pref_append(struct ast_codec_pref *pref, int format);
 
 /*! \brief Select the best audio format according to preference list from supplied options. 
    If "find_best" is non-zero then if nothing is found, the "Best" format of 
    the format list is selected, otherwise 0 is returned. */
-extern int ast_codec_choose(struct ast_codec_pref *pref, int formats, int find_best);
+int ast_codec_choose(struct ast_codec_pref *pref, int formats, int find_best);
 
 /*! \brief Parse an "allow" or "deny" line in a channel or device configuration 
         and update the capabilities mask and pref if provided.
 	Video codecs are not added to codec preference lists, since we can not transcode
  */
-extern void ast_parse_allow_disallow(struct ast_codec_pref *pref, int *mask, const char *list, int allowing);
+void ast_parse_allow_disallow(struct ast_codec_pref *pref, int *mask, const char *list, int allowing);
 
 /*! \brief Dump audio codec preference list into a string */
-extern int ast_codec_pref_string(struct ast_codec_pref *pref, char *buf, size_t size);
+int ast_codec_pref_string(struct ast_codec_pref *pref, char *buf, size_t size);
 
 /*! \brief Shift an audio codec preference list up or down 65 bytes so that it becomes an ASCII string */
-extern void ast_codec_pref_convert(struct ast_codec_pref *pref, char *buf, size_t size, int right);
+void ast_codec_pref_convert(struct ast_codec_pref *pref, char *buf, size_t size, int right);
 
 /*! \brief Returns the number of samples contained in the frame */
-extern int ast_codec_get_samples(struct ast_frame *f);
+int ast_codec_get_samples(struct ast_frame *f);
 
 /*! \brief Returns the number of bytes for the number of samples of the given format */
-extern int ast_codec_get_len(int format, int samples);
+int ast_codec_get_len(int format, int samples);
 
 /*! \brief Appends a frame to the end of a list of frames, truncating the maximum length of the list */
-extern struct ast_frame *ast_frame_enqueue(struct ast_frame *head, struct ast_frame *f, int maxlen, int dupe);
+struct ast_frame *ast_frame_enqueue(struct ast_frame *head, struct ast_frame *f, int maxlen, int dupe);
 
 
 /*! \brief Gets duration in ms of interpolation frame for a format */

Modified: trunk/include/asterisk/ulaw.h
===================================================================
--- trunk/include/asterisk/ulaw.h	2006-06-18 18:25:30 UTC (rev 262)
+++ trunk/include/asterisk/ulaw.h	2006-06-18 19:25:40 UTC (rev 263)
@@ -27,7 +27,7 @@
 /*!
  * To init the ulaw to slinear conversion stuff, this needs to be run.
  */
-extern void ast_ulaw_init(void);
+void ast_ulaw_init(void);
 
 /*! converts signed linear to mulaw */
 /*!



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:29:48 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:29:48 +0200
Subject: [solid-pbx-svn] r264 - in trunk: . build_tools
Message-ID: <200606182029.k5IKTmoM009227@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:29:47 +0200 (Sun, 18 Jun 2006)
New Revision: 264

Modified:
   trunk/Makefile
   trunk/build_tools/prep_moduledeps
Log:
Update to Asterisk SVN trunk r32373

------------------------------------------------------------------------
r32372 | kpfleming | 2006-06-05 21:16:04 +0200 (Mon, 05 Jun 2006) | 2 lines

begin adding support for new sound packages

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-18 19:25:40 UTC (rev 263)
+++ trunk/Makefile	2006-06-18 20:29:47 UTC (rev 264)
@@ -953,7 +953,7 @@
 	@cd mxml && unset CFLAGS LIBS && test -f config.h || ./configure
 	$(MAKE) -C mxml libmxml.a
 
-makeopts.xml: $(foreach dir,$(MOD_SUBDIRS),$(dir)/*.c) build_tools/cflags.xml
+makeopts.xml: $(foreach dir,$(MOD_SUBDIRS),$(dir)/*.c) build_tools/cflags.xml build_tools/sounds.xml
 	@echo "Generating list of available modules ..."
 	@build_tools/prep_moduledeps > $@
 

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-06-18 19:25:40 UTC (rev 263)
+++ trunk/build_tools/prep_moduledeps	2006-06-18 20:29:47 UTC (rev 264)
@@ -57,4 +57,5 @@
 process_dir pbx pbx PBX "PBX Modules"
 process_dir res res RES "Resource Modules"
 cat build_tools/cflags.xml
+cat build_tools/sounds.xml
 echo "</menu>"



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:31:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:31:38 +0200
Subject: [solid-pbx-svn] r265 - trunk/build_tools
Message-ID: <200606182031.k5IKVcDs009482@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:31:38 +0200 (Sun, 18 Jun 2006)
New Revision: 265

Added:
   trunk/build_tools/sounds.xml
Log:
Add missing file

Added: trunk/build_tools/sounds.xml
===================================================================
--- trunk/build_tools/sounds.xml	2006-06-18 20:29:47 UTC (rev 264)
+++ trunk/build_tools/sounds.xml	2006-06-18 20:31:38 UTC (rev 265)
@@ -0,0 +1,38 @@
+	<category name="MENUSELECT_SOUNDS" displayname="Sound Packages" positive_output="yes">
+		<member name="CORE_SOUNDS_EN_WAV" displayname="Core Sounds - English, WAV format" />
+		<member name="CORE_SOUNDS_EN_ULAW" displayname="Core Sounds - English, mu-Law format" />
+		<member name="CORE_SOUNDS_EN_ALAW" displayname="Core Sounds - English, a-Law format" />
+		<member name="CORE_SOUNDS_EN_GSM" displayname="Core Sounds - English, GSM format" >
+			<defaultenabled>yes</defaultenabled>
+		</member>
+		<member name="CORE_SOUNDS_EN_G729" displayname="Core Sounds - English, G.729 format" />
+		<member name="CORE_SOUNDS_ES_WAV" displayname="Core Sounds - Spanish, WAV format" />
+		<member name="CORE_SOUNDS_ES_ULAW" displayname="Core Sounds - Spanish, mu-Law format" />
+		<member name="CORE_SOUNDS_ES_ALAW" displayname="Core Sounds - Spanish, a-Law format" />
+		<member name="CORE_SOUNDS_ES_GSM" displayname="Core Sounds - Spanish, GSM format" />
+		<member name="CORE_SOUNDS_ES_G729" displayname="Core Sounds - Spanish, G.729 format" />
+		<member name="CORE_SOUNDS_FR_WAV" displayname="Core Sounds - French, WAV format" />
+		<member name="CORE_SOUNDS_FR_ULAW" displayname="Core Sounds - French, mu-Law format" />
+		<member name="CORE_SOUNDS_FR_ALAW" displayname="Core Sounds - French, a-Law format" />
+		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format" />
+		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format" />
+	</category>
+	<category name="MENUSELECT_SOUNDS" displayname="Sound Packages" positive_output="yes">
+		<member name="CORE_SOUNDS_EN_WAV" displayname="Core Sounds - English, WAV format" />
+		<member name="CORE_SOUNDS_EN_ULAW" displayname="Core Sounds - English, mu-Law format" />
+		<member name="CORE_SOUNDS_EN_ALAW" displayname="Core Sounds - English, a-Law format" />
+		<member name="CORE_SOUNDS_EN_GSM" displayname="Core Sounds - English, GSM format" >
+			<defaultenabled>yes</defaultenabled>
+		</member>
+		<member name="CORE_SOUNDS_EN_G729" displayname="Core Sounds - English, G.729 format" />
+		<member name="CORE_SOUNDS_ES_WAV" displayname="Core Sounds - Spanish, WAV format" />
+		<member name="CORE_SOUNDS_ES_ULAW" displayname="Core Sounds - Spanish, mu-Law format" />
+		<member name="CORE_SOUNDS_ES_ALAW" displayname="Core Sounds - Spanish, a-Law format" />
+		<member name="CORE_SOUNDS_ES_GSM" displayname="Core Sounds - Spanish, GSM format" />
+		<member name="CORE_SOUNDS_ES_G729" displayname="Core Sounds - Spanish, G.729 format" />
+		<member name="CORE_SOUNDS_FR_WAV" displayname="Core Sounds - French, WAV format" />
+		<member name="CORE_SOUNDS_FR_ULAW" displayname="Core Sounds - French, mu-Law format" />
+		<member name="CORE_SOUNDS_FR_ALAW" displayname="Core Sounds - French, a-Law format" />
+		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format" />
+		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format" />
+	</category>



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:36:10 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:36:10 +0200
Subject: [solid-pbx-svn] r266 - trunk/build_tools
Message-ID: <200606182036.k5IKaArY009749@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:36:09 +0200 (Sun, 18 Jun 2006)
New Revision: 266

Modified:
   trunk/build_tools/sounds.xml
Log:
Oops... sounds.xml was patched twice

Modified: trunk/build_tools/sounds.xml
===================================================================
--- trunk/build_tools/sounds.xml	2006-06-18 20:31:38 UTC (rev 265)
+++ trunk/build_tools/sounds.xml	2006-06-18 20:36:09 UTC (rev 266)
@@ -17,22 +17,3 @@
 		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format" />
 		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format" />
 	</category>
-	<category name="MENUSELECT_SOUNDS" displayname="Sound Packages" positive_output="yes">
-		<member name="CORE_SOUNDS_EN_WAV" displayname="Core Sounds - English, WAV format" />
-		<member name="CORE_SOUNDS_EN_ULAW" displayname="Core Sounds - English, mu-Law format" />
-		<member name="CORE_SOUNDS_EN_ALAW" displayname="Core Sounds - English, a-Law format" />
-		<member name="CORE_SOUNDS_EN_GSM" displayname="Core Sounds - English, GSM format" >
-			<defaultenabled>yes</defaultenabled>
-		</member>
-		<member name="CORE_SOUNDS_EN_G729" displayname="Core Sounds - English, G.729 format" />
-		<member name="CORE_SOUNDS_ES_WAV" displayname="Core Sounds - Spanish, WAV format" />
-		<member name="CORE_SOUNDS_ES_ULAW" displayname="Core Sounds - Spanish, mu-Law format" />
-		<member name="CORE_SOUNDS_ES_ALAW" displayname="Core Sounds - Spanish, a-Law format" />
-		<member name="CORE_SOUNDS_ES_GSM" displayname="Core Sounds - Spanish, GSM format" />
-		<member name="CORE_SOUNDS_ES_G729" displayname="Core Sounds - Spanish, G.729 format" />
-		<member name="CORE_SOUNDS_FR_WAV" displayname="Core Sounds - French, WAV format" />
-		<member name="CORE_SOUNDS_FR_ULAW" displayname="Core Sounds - French, mu-Law format" />
-		<member name="CORE_SOUNDS_FR_ALAW" displayname="Core Sounds - French, a-Law format" />
-		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format" />
-		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format" />
-	</category>



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:36:59 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:36:59 +0200
Subject: [solid-pbx-svn] r267 - trunk/channels
Message-ID: <200606182036.k5IKaxU2009835@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:36:58 +0200 (Sun, 18 Jun 2006)
New Revision: 267

Modified:
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r32403

------------------------------------------------------------------------
r32401 | kpfleming | 2006-06-05 22:10:06 +0200 (Mon, 05 Jun 2006) | 10 lines

Merged revisions 32373 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r32373 | kpfleming | 2006-06-05 14:53:16 -0500 (Mon, 05 Jun 2006) | 2 lines

ensure that the received number of bytes is included in all IAX2 incoming frame analysis checks (fixes a known vulnerability)

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 20:36:09 UTC (rev 266)
+++ trunk/channels/chan_iax2.c	2006-06-18 20:36:58 UTC (rev 267)
@@ -6314,27 +6314,28 @@
 	fd = thread->iofd;
 	memcpy(&sin, &thread->iosin, sizeof(sin));
 
-	if (res < sizeof(struct ast_iax2_mini_hdr)) {
-		ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int)sizeof(struct ast_iax2_mini_hdr));
+	if (res < sizeof(*mh)) {
+		ast_log(LOG_WARNING, "midget packet received (%d of %zd min)\n", res, sizeof(*mh));
 		return 1;
 	}
-	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {
+	if ((res >= sizeof(*vh)) && ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000))) {
 		/* This is a video frame, get call number */
 		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, 1, fd);
 		minivid = 1;
-	} else if (meta->zeros == 0) {
+	} else if ((res >= sizeof(*meta)) && (meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000)) {
 		unsigned char metatype;
 		/* This is a meta header */
 		switch(meta->metacmd) {
 		case IAX_META_TRUNK:
-			if (res < sizeof(struct ast_iax2_meta_hdr) + sizeof(struct ast_iax2_meta_trunk_hdr)) {
-				ast_log(LOG_WARNING, "midget meta trunk packet received (%d of %d min)\n", res, (int)sizeof(struct ast_iax2_mini_hdr));
+			if (res < (sizeof(*meta) + sizeof(*mth))) {
+				ast_log(LOG_WARNING, "midget meta trunk packet received (%d of %zd min)\n", res,
+					sizeof(*meta) + sizeof(*mth));
 				return 1;
 			}
 			mth = (struct ast_iax2_meta_trunk_hdr *)(meta->data);
 			ts = ntohl(mth->ts);
 			metatype = meta->cmddata;
-			res -= (sizeof(struct ast_iax2_meta_hdr) + sizeof(struct ast_iax2_meta_trunk_hdr));
+			res -= (sizeof(*meta) + sizeof(*mth));
 			ptr = mth->data;
 			tpeer = find_tpeer(&sin, fd);
 			if (!tpeer) {
@@ -6346,21 +6347,21 @@
 				tpeer->rxtrunktime = tpeer->trunkact;
 			rxtrunktime = tpeer->rxtrunktime;
 			ast_mutex_unlock(&tpeer->lock);
-			while(res >= sizeof(struct ast_iax2_meta_trunk_entry)) {
+			while(res >= sizeof(*mte)) {
 				/* Process channels */
 				unsigned short callno, trunked_ts, len;
 
-				if(metatype == IAX_META_TRUNK_MINI) {
+				if (metatype == IAX_META_TRUNK_MINI) {
 					mtm = (struct ast_iax2_meta_trunk_mini *)ptr;
-					ptr += sizeof(struct ast_iax2_meta_trunk_mini);
-					res -= sizeof(struct ast_iax2_meta_trunk_mini);
+					ptr += sizeof(*mtm);
+					res -= sizeof(*mtm);
 					len = ntohs(mtm->len);
 					callno = ntohs(mtm->mini.callno);
 					trunked_ts = ntohs(mtm->mini.ts);
-				} else if ( metatype == IAX_META_TRUNK_SUPERMINI ) {
+				} else if (metatype == IAX_META_TRUNK_SUPERMINI) {
 					mte = (struct ast_iax2_meta_trunk_entry *)ptr;
-					ptr += sizeof(struct ast_iax2_meta_trunk_entry);
-					res -= sizeof(struct ast_iax2_meta_trunk_entry);
+					ptr += sizeof(*mte);
+					res -= sizeof(*mte);
 					len = ntohs(mte->len);
 					callno = ntohs(mte->callno);
 					trunked_ts = 0;
@@ -6443,11 +6444,21 @@
 		}
 		return 1;
 	}
+
+	/* if we got here and ->zeros contains zeros, this cannot be a valid
+	   miniframe or full frame but it wasn't a valid video frame or meta
+	   frame either, so we reject it
+	*/
+	if (vh->zeros == 0) {
+		ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video or meta frame but is not properly formatted\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+		return 1;
+	}
+
 #ifdef DEBUG_SUPPORT
-	if (iaxdebug)
-		iax_showframe(NULL, fh, 1, &sin, res - sizeof(struct ast_iax2_full_hdr));
+	if (iaxdebug && (res >= sizeof(*fh)))
+		iax_showframe(NULL, fh, 1, &sin, res - sizeof(*fh));
 #endif
-	if (ntohs(mh->callno) & IAX_FLAG_FULL) {
+	if ((res >= sizeof(*fh)) && ntohs(mh->callno) & IAX_FLAG_FULL) {
 		/* Get the destination call number */
 		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;
 		/* Retrieve the type and subclass */
@@ -6498,7 +6509,7 @@
 		}
 #ifdef DEBUG_SUPPORT
 		else if (iaxdebug)
-			iax_showframe(NULL, fh, 3, &sin, res - sizeof(struct ast_iax2_full_hdr));
+			iax_showframe(NULL, fh, 3, &sin, res - sizeof(*fh));
 #endif
 	}
 
@@ -6583,12 +6594,12 @@
 				iaxs[fr->callno]->iseqno++;
 		}
 		/* A full frame */
-		if (res < sizeof(struct ast_iax2_full_hdr)) {
-			ast_log(LOG_WARNING, "midget packet received (%d of %d min)\n", res, (int)sizeof(struct ast_iax2_full_hdr));
+		if (res < sizeof(*fh)) {
+			ast_log(LOG_WARNING, "midget packet received (%d of %zd min)\n", res, sizeof(*fh));
 			ast_mutex_unlock(&iaxsl[fr->callno]);
 			return 1;
 		}
-		f.datalen = res - sizeof(struct ast_iax2_full_hdr);
+		f.datalen = res - sizeof(*fh);
 
 		/* Handle implicit ACKing unless this is an INVAL, and only if this is 
 		   from the real peer, not the transfer peer */
@@ -6646,14 +6657,14 @@
 
 		if (f.datalen) {
 			if (f.frametype == AST_FRAME_IAX) {
-				if (iax_parse_ies(&ies, thread->buf + sizeof(struct ast_iax2_full_hdr), f.datalen)) {
+				if (iax_parse_ies(&ies, thread->buf + sizeof(*fh), f.datalen)) {
 					ast_log(LOG_WARNING, "Undecodable frame received from '%s'\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr));
 					ast_mutex_unlock(&iaxsl[fr->callno]);
 					return 1;
 				}
 				f.data = NULL;
 			} else
-				f.data = thread->buf + sizeof(struct ast_iax2_full_hdr);
+				f.data = thread->buf + sizeof(*fh);
 		} else {
 			if (f.frametype == AST_FRAME_IAX)
 				f.data = NULL;
@@ -7557,9 +7568,9 @@
 			ast_mutex_unlock(&iaxsl[fr->callno]);
 			return 1;
 		}
-		f.datalen = res - sizeof(struct ast_iax2_video_hdr);
+		f.datalen = res - sizeof(*vh);
 		if (f.datalen)
-			f.data = thread->buf + sizeof(struct ast_iax2_video_hdr);
+			f.data = thread->buf + sizeof(*vh);
 		else
 			f.data = NULL;
 #ifdef IAXTESTS
@@ -7586,7 +7597,7 @@
 			return 1;
 		}
 		if (f.datalen)
-			f.data = thread->buf + sizeof(struct ast_iax2_mini_hdr);
+			f.data = thread->buf + sizeof(*mh);
 		else
 			f.data = NULL;
 #ifdef IAXTESTS



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:41:16 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:41:16 +0200
Subject: [solid-pbx-svn] r268 - in trunk: apps build_tools cdr channels codecs formats funcs pbx res utils
Message-ID: <200606182041.k5IKfGar010285@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:41:11 +0200 (Sun, 18 Jun 2006)
New Revision: 268

Modified:
   trunk/apps/Makefile
   trunk/build_tools/prep_moduledeps
   trunk/build_tools/sounds.xml
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/codecs/codec_g723_1.c
   trunk/formats/Makefile
   trunk/funcs/Makefile
   trunk/pbx/Makefile
   trunk/res/Makefile
   trunk/res/res_snmp.c
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r32413

------------------------------------------------------------------------
r32407 | kpfleming | 2006-06-05 22:46:27 +0200 (Mon, 05 Jun 2006) | 3 lines

use module names, not file names, in menuselect
work around XML parsing bug in menuselect for default sounds package

------------------------------------------------------------------------


Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/apps/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_APPS),$(patsubst %.c,%.so,$(wildcard app_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_APPS),$(patsubst %.c,%,$(wildcard app_*.c)))
 
 # If you have UnixODBC you can use ODBC voicemail
 # storage
@@ -22,6 +22,8 @@
 #CFLAGS+=-DEXTENDED_ODBC_STORAGE
 # See doc/README.odbcstorage for more information
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: $(MODS)
 
 clean-depend:

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/build_tools/prep_moduledeps	2006-06-18 20:41:11 UTC (rev 268)
@@ -38,7 +38,7 @@
 		fname=${file##${dir}/}
 		get_description ${file}
 		desc=${TDESC}
-		echo -e "\t\t<member name=\"${fname%%.c}.so\" displayname=\"${desc}\">"
+		echo -e "\t\t<member name=\"${fname%%.c}\" displayname=\"${desc}\">"
 		awk -f build_tools/get_moduledeps ${file}
 		echo -e "\t\t</member>"
 	done

Modified: trunk/build_tools/sounds.xml
===================================================================
--- trunk/build_tools/sounds.xml	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/build_tools/sounds.xml	2006-06-18 20:41:11 UTC (rev 268)
@@ -1,19 +1,33 @@
 	<category name="MENUSELECT_SOUNDS" displayname="Sound Packages" positive_output="yes">
-		<member name="CORE_SOUNDS_EN_WAV" displayname="Core Sounds - English, WAV format" />
-		<member name="CORE_SOUNDS_EN_ULAW" displayname="Core Sounds - English, mu-Law format" />
-		<member name="CORE_SOUNDS_EN_ALAW" displayname="Core Sounds - English, a-Law format" />
+		<member name="CORE_SOUNDS_EN_WAV" displayname="Core Sounds - English, WAV format">
+		</member>
+		<member name="CORE_SOUNDS_EN_ULAW" displayname="Core Sounds - English, mu-Law format">
+		</member>
+		<member name="CORE_SOUNDS_EN_ALAW" displayname="Core Sounds - English, a-Law format">
+		</member>
 		<member name="CORE_SOUNDS_EN_GSM" displayname="Core Sounds - English, GSM format" >
 			<defaultenabled>yes</defaultenabled>
 		</member>
-		<member name="CORE_SOUNDS_EN_G729" displayname="Core Sounds - English, G.729 format" />
-		<member name="CORE_SOUNDS_ES_WAV" displayname="Core Sounds - Spanish, WAV format" />
-		<member name="CORE_SOUNDS_ES_ULAW" displayname="Core Sounds - Spanish, mu-Law format" />
-		<member name="CORE_SOUNDS_ES_ALAW" displayname="Core Sounds - Spanish, a-Law format" />
-		<member name="CORE_SOUNDS_ES_GSM" displayname="Core Sounds - Spanish, GSM format" />
-		<member name="CORE_SOUNDS_ES_G729" displayname="Core Sounds - Spanish, G.729 format" />
-		<member name="CORE_SOUNDS_FR_WAV" displayname="Core Sounds - French, WAV format" />
-		<member name="CORE_SOUNDS_FR_ULAW" displayname="Core Sounds - French, mu-Law format" />
-		<member name="CORE_SOUNDS_FR_ALAW" displayname="Core Sounds - French, a-Law format" />
-		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format" />
-		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format" />
+		<member name="CORE_SOUNDS_EN_G729" displayname="Core Sounds - English, G.729 format">
+		</member>
+		<member name="CORE_SOUNDS_ES_WAV" displayname="Core Sounds - Spanish, WAV format">
+		</member>
+		<member name="CORE_SOUNDS_ES_ULAW" displayname="Core Sounds - Spanish, mu-Law format">
+		</member>
+		<member name="CORE_SOUNDS_ES_ALAW" displayname="Core Sounds - Spanish, a-Law format">
+		</member>
+		<member name="CORE_SOUNDS_ES_GSM" displayname="Core Sounds - Spanish, GSM format">
+		</member>
+		<member name="CORE_SOUNDS_ES_G729" displayname="Core Sounds - Spanish, G.729 format">
+		</member>
+		<member name="CORE_SOUNDS_FR_WAV" displayname="Core Sounds - French, WAV format">
+		</member>
+		<member name="CORE_SOUNDS_FR_ULAW" displayname="Core Sounds - French, mu-Law format">
+		</member>
+		<member name="CORE_SOUNDS_FR_ALAW" displayname="Core Sounds - French, a-Law format">
+		</member>
+		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format">
+		</member>
+		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format">
+		</member>
 	</category>

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/cdr/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_CDR),$(patsubst %.c,%.so,$(wildcard cdr_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_CDR),$(patsubst %.c,%,$(wildcard cdr_*.c)))
 
 #The problem with sparc is the best stuff is in newer versions of gcc (post 3.0) only.
 #This works for even old (2.96) versions of gcc and provides a small boost either way.
@@ -35,6 +35,8 @@
   endif
 endif
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: depend $(MODS)
 
 install: all

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/channels/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_CHANNELS),$(patsubst %.c,%.so,$(wildcard chan_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_CHANNELS),$(patsubst %.c,%,$(wildcard chan_*.c)))
 
 ifeq ($(PROC),sparc64)
   PROC=ultrasparc
@@ -23,11 +23,13 @@
 endif
 
 ifeq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/include/mISDNuser/mISDNlib.h),)
-  MODS:=$(filter-out chan_misdn.so,$(MODS))
+  SELECTED_MODS:=$(filter-out chan_misdn.so,$(SELECTED_MODS))
 else
   CFLAGS+=-Imisdn 
 endif
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: depend $(MODS) 
 
 clean-depend:

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/codecs/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,27 +11,18 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_CODECS),$(patsubst %.c,%.so,$(wildcard codec_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_CODECS),$(patsubst %.c,%,$(wildcard codec_*.c)))
 
-ifeq ($(wildcard g723.1/coder.c),)
-  MODS:=$(filter-out codec_g723_1.so,$(MODS))
-else
-  LIBG723=g723.1/libg723.a
-endif
-
-ifneq ($(wildcard g723.1b/coder2.c),)
-  MODS+=codec_g723_1b.so
-  LIBG723B=g723.1b/libg723b.a
-endif
-
 ifeq ($(wildcard ilbc/iLBC_decode.h),)
-  MODS:=$(filter-out codec_ilbc.so,$(MODS))
+  MODS:=$(filter-out codec_ilbc,$(MODS))
 else
   LIBILBC=ilbc/libilbc.a
 endif
 
 LIBLPC10=lpc10/liblpc10.a
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: depend $(MODS)
 
 clean-depend:

Modified: trunk/codecs/codec_g723_1.c
===================================================================
--- trunk/codecs/codec_g723_1.c	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/codecs/codec_g723_1.c	2006-06-18 20:41:11 UTC (rev 268)
@@ -27,6 +27,10 @@
  * \ingroup codecs
  */
 
+/*** MODULEINFO
+	<defaultenabled>no</defaultenabled>
+ ***/
+
 #define TYPE_HIGH	 0x0
 #define TYPE_LOW	 0x1
 #define TYPE_SILENCE	 0x2

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/formats/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,10 +11,12 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_FORMATS),$(patsubst %.c,%.so,$(wildcard format_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_FORMATS),$(patsubst %.c,%,$(wildcard format_*.c)))
 
 GSMLIB=../codecs/gsm/lib/libgsm.a
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: depend $(MODS)
 
 clean-depend:

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/funcs/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,19 +11,21 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_FUNCS),$(patsubst %.c,%.so,$(wildcard func_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_FUNCS),$(patsubst %.c,%,$(wildcard func_*.c)))
 
 # TODO This check needs to be handled with autoconf
 ifeq ($(OSARCH),SunOS)
   ifeq ($(shell if [ 0x`$(CROSS_COMPILE_BIN)curl-config --vernum` -ge 0x70907 ]; then echo "OK" ; fi),)
-    MODS:=$(filter-out func_curl.so,$(MODS))
+    MODS:=$(filter-out func_curl,$(MODS))
   endif
 else
   ifeq ($(shell if [[ 0x`$(CROSS_COMPILE_BIN)curl-config --vernum` -ge 0x70907 ]]; then echo "OK" ; fi),)
-    MODS:=$(filter-out func_curl.so,$(MODS)) 
+    MODS:=$(filter-out func_curl,$(MODS)) 
   endif
 endif
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: $(MODS)
 
 clean-depend:

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/pbx/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_PBX),$(patsubst %.c,%.so,$(wildcard pbx_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_PBX),$(patsubst %.c,%,$(wildcard pbx_*.c)))
 
 MOC=$(QTDIR)/bin/moc
 KDE_FLAGS=-I$(KDEDIR)/include -I$(KDEDIR)/include/kde -I$(QTDIR)/include
@@ -19,6 +19,8 @@
 
 KDE_CONSOLE_OBJS=pbx_kdeconsole_main.o pbx_kdeconsole.o 
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: depend $(MODS)
 
 clean-depend:

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/res/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -11,29 +11,31 @@
 # the GNU General Public License
 #
 
-MODS:=$(filter-out $(MENUSELECT_RES),$(patsubst %.c,%.so,$(wildcard res_*.c)))
+SELECTED_MODS:=$(filter-out $(MENUSELECT_RES),$(patsubst %.c,%,$(wildcard res_*.c)))
 
 ifeq ($(OSARCH),FreeBSD)
-  MODS:=$(filter-out $(shell if test ${BSDVERSION} -lt 500000 ; then echo "res_config_odbc.so"; fi),$(MODS))
+  SELECTED_MODS:=$(filter-out $(shell if test ${BSDVERSION} -lt 500000 ; then echo "res_config_odbc"; fi),$(SELECTED_MODS))
 endif
 
 # NETsnmp has some difficulties on some platforms (conflict with unload_module)
 # Until we figure out if the collission is version-specific or what to do
 # we have disabled res_snmp on OS/X and *BSD
 ifeq ($(OSARCH),Darwin)
-  MODS:=$(filter-out res_snmp.so,$(MODS))
+  SELECTED_MODS:=$(filter-out res_snmp,$(SELECTED_MODS))
 else
   ifeq ($(findstring BSD,$(OSARCH)),BSD)
-    MODS:=$(filter-out res_snmp.so,$(MODS))
+    SELECTED_MODS:=$(filter-out res_snmp,$(SELECTED_MODS))
   endif
 endif
 
 ifeq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/include/net-snmp/net-snmp-config.h),)
-  MODS:=$(filter-out res_snmp.so,$(MODS))
+  SELECTED_MODS:=$(filter-out res_snmp,$(SELECTED_MODS))
 else
   SNMP_LDLIBS+=$(shell net-snmp-config --agent-libs)
 endif
 
+MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
+
 all: depend $(MODS)
 
 install: all

Modified: trunk/res/res_snmp.c
===================================================================
--- trunk/res/res_snmp.c	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/res/res_snmp.c	2006-06-18 20:41:11 UTC (rev 268)
@@ -141,13 +141,3 @@
 {
     return MODULE_DESCRIPTION;
 }
-
-/*
- * Local Variables:
- * c-file-style: gnu
- * c-basic-offset: 4
- * c-file-offsets: ((case-label . 0))
- * tab-width: 4
- * indent-tabs-mode: t
- * End:
- */

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-06-18 20:36:58 UTC (rev 267)
+++ trunk/utils/Makefile	2006-06-18 20:41:11 UTC (rev 268)
@@ -26,7 +26,7 @@
   UTILS:=$(filter-out astman,$(UTILS))
 endif
 
-ifneq ($(filter pbx_ael.so,$(MENUSELECT_PBX)),)
+ifneq ($(filter pbx_ael,$(MENUSELECT_PBX)),)
   UTILS:=$(filter-out aelparse,$(UTILS))
 endif
 



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:48:04 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:48:04 +0200
Subject: [solid-pbx-svn] r269 - in trunk: . build_tools
Message-ID: <200606182048.k5IKm4Nt010888@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:48:03 +0200 (Sun, 18 Jun 2006)
New Revision: 269

Modified:
   trunk/Makefile
   trunk/build_tools/cflags.xml
Log:
Update to Asterisk SVN trunk r32443

------------------------------------------------------------------------
r32434 | russell | 2006-06-06 02:25:23 +0200 (Tue, 06 Jun 2006) | 4 lines

add the ability to do the same thing as "make dont-optimize" by enabling the
option in menuselect.  This is very useful for developers if you want to ensure
that all of your builds are done without optimizations.

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-18 20:41:11 UTC (rev 268)
+++ trunk/Makefile	2006-06-18 20:48:03 UTC (rev 269)
@@ -37,22 +37,6 @@
 # Remember the MAKELEVEL at the top
 MAKETOPLEVEL?=$(MAKELEVEL)
 
-ifeq ($(findstring dont-optimize,$(MAKECMDGOALS)),)
-# More GSM codec optimization
-# Uncomment to enable MMXTM optimizations for x86 architecture CPU's
-# which support MMX instructions.  This should be newer pentiums,
-# ppro's, etc, as well as the AMD K6 and K7.  
-#K6OPT  = -DK6OPT
-
-# Tell gcc to optimize the code
-OPTIMIZE+=-O6
-else
-  # Stack backtraces, while useful for debugging, are incompatible with optimizations
-  ifeq (${OSARCH},Linux)
-    CFLAGS+=-DSTACK_BACKTRACES
-  endif
-endif
-
 # Overwite config files on "make samples"
 OVERWRITE=y
 
@@ -147,6 +131,29 @@
 MOD_SUBDIR_CFLAGS=-include ../include/autoconfig.h -I../include -I..
 OTHER_SUBDIR_CFLAGS=-include ../include/autoconfig.h -I../include -I..
 
+ifeq ($(findstring dont-optimize,$(MAKECMDGOALS)),)
+  ifeq ($(findstring DONT_OPTIMIZE,$(MENUSELECT_CFLAGS)),)
+# More GSM codec optimization
+# Uncomment to enable MMXTM optimizations for x86 architecture CPU's
+# which support MMX instructions.  This should be newer pentiums,
+# ppro's, etc, as well as the AMD K6 and K7.  
+#K6OPT  = -DK6OPT
+
+# Tell gcc to optimize the code
+OPTIMIZE+=-O6
+  else
+    # Stack backtraces, while useful for debugging, are incompatible with optimizations
+    ifeq (${OSARCH},Linux)
+      CFLAGS+=-DSTACK_BACKTRACES
+    endif
+  endif
+else
+  # Stack backtraces, while useful for debugging, are incompatible with optimizations
+  ifeq (${OSARCH},Linux)
+    CFLAGS+=-DSTACK_BACKTRACES
+  endif
+endif
+
 #   *CLI> show memory allocations [filename]
 #   *CLI> show memory summary [filename]
 ifneq ($(findstring MALLOC_DEBUG,$(MENUSELECT_CFLAGS)),)

Modified: trunk/build_tools/cflags.xml
===================================================================
--- trunk/build_tools/cflags.xml	2006-06-18 20:41:11 UTC (rev 268)
+++ trunk/build_tools/cflags.xml	2006-06-18 20:48:03 UTC (rev 269)
@@ -7,6 +7,8 @@
 		</member>
 		<member name="DETECT_DEADLOCKS" displayname="Detect Deadlocks">
 		</member>
+		<member name="DONT_OPTIMIZE" displayname="Disable Optimizations from the Compiler">
+		</member>
 		<member name="DUMP_SCHEDULER" displayname="Dump Scheduler Contents for Debugging">
 		</member>
 		<member name="LOW_MEMORY" displayname="Optimize for Low Memory Usage">



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:48:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:48:38 +0200
Subject: [solid-pbx-svn] r270 - in trunk: . channels include/asterisk
Message-ID: <200606182048.k5IKmcsP010930@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:48:36 +0200 (Sun, 18 Jun 2006)
New Revision: 270

Modified:
   trunk/callerid.c
   trunk/channels/chan_zap.c
   trunk/include/asterisk/callerid.h
   trunk/include/asterisk/stringfields.h
Log:
Update to Asterisk SVN trunk r32463

------------------------------------------------------------------------
r32455 | russell | 2006-06-06 03:21:52 +0200 (Tue, 06 Jun 2006) | 2 lines

fix some typos in the stringfields documentation

------------------------------------------------------------------------
r32456 | russell | 2006-06-06 03:22:47 +0200 (Tue, 06 Jun 2006) | 3 lines

- use stringfields in a bunch of the fields of the zt_pvt structure in chan_zap
- constify some arguments to functions in callerid.c / callerid.h

------------------------------------------------------------------------


Modified: trunk/callerid.c
===================================================================
--- trunk/callerid.c	2006-06-18 20:48:03 UTC (rev 269)
+++ trunk/callerid.c	2006-06-18 20:48:36 UTC (rev 270)
@@ -696,7 +696,7 @@
 	free(cid);
 }
 
-static int callerid_genmsg(char *msg, int size, char *number, char *name, int flags)
+static int callerid_genmsg(char *msg, int size, const char *number, const char *name, int flags)
 {
 	time_t t;
 	struct tm tm;
@@ -827,7 +827,7 @@
 	return bytes;
 }
 
-int callerid_generate(unsigned char *buf, char *number, char *name, int flags, int callwaiting, int codec)
+int callerid_generate(unsigned char *buf, const char *number, const char *name, int flags, int callwaiting, int codec)
 {
 	int bytes=0;
 	int x, sum;
@@ -989,7 +989,7 @@
 	return 0;
 }
 
-static int __ast_callerid_generate(unsigned char *buf, char *name, char *number, int callwaiting, int codec)
+static int __ast_callerid_generate(unsigned char *buf, const char *name, const char *number, int callwaiting, int codec)
 {
 	if (ast_strlen_zero(name))
 		name = NULL;
@@ -998,12 +998,12 @@
 	return callerid_generate(buf, number, name, 0, callwaiting, codec);
 }
 
-int ast_callerid_generate(unsigned char *buf, char *name, char *number, int codec)
+int ast_callerid_generate(unsigned char *buf, const char *name, const char *number, int codec)
 {
 	return __ast_callerid_generate(buf, name, number, 0, codec);
 }
 
-int ast_callerid_callwaiting_generate(unsigned char *buf, char *name, char *number, int codec)
+int ast_callerid_callwaiting_generate(unsigned char *buf, const char *name, const char *number, int codec)
 {
 	return __ast_callerid_generate(buf, name, number, 1, codec);
 }

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-18 20:48:03 UTC (rev 269)
+++ trunk/channels/chan_zap.c	2006-06-18 20:48:36 UTC (rev 270)
@@ -618,25 +618,31 @@
 
 	struct zt_distRings drings;
 
-	char context[AST_MAX_CONTEXT];
-	char defcontext[AST_MAX_CONTEXT];
-	char exten[AST_MAX_EXTENSION];
-	char language[MAX_LANGUAGE];
-	char musicclass[MAX_MUSICCLASS];
+	AST_DECLARE_STRING_FIELDS(
+		AST_STRING_FIELD(language);
+		AST_STRING_FIELD(musicclass);
+		AST_STRING_FIELD(accountcode);
+		AST_STRING_FIELD(mailbox);
+		AST_STRING_FIELD(call_forward);
+		AST_STRING_FIELD(cid_num);
+		AST_STRING_FIELD(cid_name);
+		AST_STRING_FIELD(lastcid_num);
+		AST_STRING_FIELD(lastcid_name);
+		AST_STRING_FIELD(dnid);
+		AST_STRING_FIELD(callwait_num);
+		AST_STRING_FIELD(callwait_name);
+		AST_STRING_FIELD(finaldial);
+		AST_STRING_FIELD(context);
+		AST_STRING_FIELD(defcontext);
+		AST_STRING_FIELD(exten);
 #ifdef PRI_ANI
-	char cid_ani[AST_MAX_EXTENSION];
+		AST_STRING_FIELD(cid_ani);
 #endif
-	char cid_num[AST_MAX_EXTENSION];
+	);
 	int cid_ton;					/*!< Type Of Number (TON) */
-	char cid_name[AST_MAX_EXTENSION];
-	char lastcid_num[AST_MAX_EXTENSION];
-	char lastcid_name[AST_MAX_EXTENSION];
 	char *origcid_num;				/*!< malloced original callerid */
 	char *origcid_name;				/*!< malloced original callerid */
-	char callwait_num[AST_MAX_EXTENSION];
-	char callwait_name[AST_MAX_EXTENSION];
 	char rdnis[AST_MAX_EXTENSION];
-	char dnid[AST_MAX_EXTENSION];
 	unsigned int group;
 	int law;
 	int confno;					/*!< Our conference */
@@ -672,12 +678,8 @@
 	int cref;					/*!< Call reference number */
 	ZT_DIAL_OPERATION dop;
 	int whichwink;					/*!< SIG_FEATDMF_TA Which wink are we on? */
-	char finaldial[64];
-	char accountcode[AST_MAX_ACCOUNT_CODE];		/*!< Account code */
 	int amaflags;					/*!< AMA Flags */
 	struct tdd_state *tdd;				/*!< TDD flag */
-	char call_forward[AST_MAX_EXTENSION];
-	char mailbox[AST_MAX_EXTENSION];
 	char dialdest[256];
 	int onhooktime;
 	int msgstate;
@@ -1823,13 +1825,13 @@
 			/* Call waiting call */
 			p->callwaitrings = 0;
 			if (ast->cid.cid_num)
-				ast_copy_string(p->callwait_num, ast->cid.cid_num, sizeof(p->callwait_num));
+				ast_string_field_set(p, callwait_num, ast->cid.cid_num);
 			else
-				p->callwait_num[0] = '\0';
+				ast_string_field_set(p, callwait_num, "");
 			if (ast->cid.cid_name)
-				ast_copy_string(p->callwait_name, ast->cid.cid_name, sizeof(p->callwait_name));
+				ast_string_field_set(p, callwait_name, ast->cid.cid_name);
 			else
-				p->callwait_name[0] = '\0';
+				ast_string_field_set(p, callwait_name, "");
 			/* Call waiting tone instead */
 			if (zt_callwait(ast)) {
 				ast_mutex_unlock(&p->lock);
@@ -1843,13 +1845,13 @@
 		n = ast->cid.cid_name;
 		l = ast->cid.cid_num;
 		if (l)
-			ast_copy_string(p->lastcid_num, l, sizeof(p->lastcid_num));
+			ast_string_field_set(p, lastcid_num, l);
 		else
-			p->lastcid_num[0] = '\0';
+			ast_string_field_set(p, lastcid_num, "");
 		if (n)
-			ast_copy_string(p->lastcid_name, n, sizeof(p->lastcid_name));
+			ast_string_field_set(p, lastcid_name, n);
 		else
-			p->lastcid_name[0] = '\0';
+			ast_string_field_set(p, lastcid_name, "");
 		ast_setstate(ast, AST_STATE_RINGING);
 		index = zt_get_index(ast, p, 0);
 		if (index > -1) {
@@ -1937,7 +1939,7 @@
 				return -1;
 			}
 			snprintf(p->dop.dialstr, sizeof(p->dop.dialstr), "M*%s%s#", ozz, cic);
-			snprintf(p->finaldial, sizeof(p->finaldial), "M*%s#", c);
+			ast_string_field_build(p, finaldial, "M*%s#", c);
 			p->whichwink = 0;
 		}
 			break;
@@ -2152,6 +2154,7 @@
 		ASTOBJ_UNREF(p->smdi_iface, ast_smdi_interface_destroy);
 #endif
 	ast_mutex_destroy(&p->lock);
+	ast_string_field_free_all(p);
 	free(p);
 	*pvt = NULL;
 }
@@ -2370,19 +2373,19 @@
 	zt_confmute(p, 0);
 	restore_gains(p);
 	if (p->origcid_num) {
-		ast_copy_string(p->cid_num, p->origcid_num, sizeof(p->cid_num));
+		ast_string_field_set(p, cid_num, p->origcid_num);
 		free(p->origcid_num);
 		p->origcid_num = NULL;
-	}	
+	}
 	if (p->origcid_name) {
-		ast_copy_string(p->cid_name, p->origcid_name, sizeof(p->cid_name));
+		ast_string_field_set(p, cid_name, p->origcid_name);
 		free(p->origcid_name);
 		p->origcid_name = NULL;
 	}	
 	if (p->dsp)
 		ast_dsp_digitmode(p->dsp,DSP_DIGITMODE_DTMF | p->dtmfrelax);
-	if (p->exten)
-		p->exten[0] = '\0';
+	if (!ast_strlen_zero(p->exten))
+		ast_string_field_set(p, exten, "");
 
 	ast_log(LOG_DEBUG, "Hangup: channel: %d index = %d, normal = %d, callwait = %d, thirdcall = %d\n",
 		p->channel, index, p->subs[SUB_REAL].zfd, p->subs[SUB_CALLWAIT].zfd, p->subs[SUB_THREEWAY].zfd);
@@ -4096,8 +4099,8 @@
 								p->origcid_num = ast_strdup(p->cid_num);
 							if (!p->origcid_name)
 								p->origcid_name = ast_strdup(p->cid_name);
-							ast_copy_string(p->cid_num, cid_num, sizeof(p->cid_num));
-							ast_copy_string(p->cid_name, cid_name, sizeof(p->cid_name));
+							ast_string_field_set(p, cid_num, cid_num);
+							ast_string_field_set(p, cid_name, cid_name);
 						}
 						/* Swap things around between the three-way and real call */
 						swap_subs(p, SUB_THREEWAY, SUB_REAL);
@@ -5343,7 +5346,7 @@
 			ast_log(LOG_DEBUG, "No such possible extension '%s' in context '%s'\n", exten, chan->context);
 			chan->hangupcause = AST_CAUSE_UNALLOCATED;
 			ast_hangup(chan);
-			p->exten[0] = '\0';
+			ast_string_field_set(p, exten, "");
 			/* Since we send release complete here, we won't get one */
 			p->call = NULL;
 		}
@@ -5657,7 +5660,7 @@
 				if (!res || !ast_matchmore_extension(chan, chan->context, exten, 1, p->cid_num)) {
 					if (getforward) {
 						/* Record this as the forwarding extension */
-						ast_copy_string(p->call_forward, exten, sizeof(p->call_forward)); 
+						ast_string_field_set(p, call_forward, exten); 
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Setting call forward to '%s' on channel %d\n", p->call_forward, p->channel);
 						res = tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALRECALL);
@@ -5806,7 +5809,7 @@
 				if (option_verbose > 2)
 					ast_verbose(VERBOSE_PREFIX_3 "Cancelling call forwarding on channel %d\n", p->channel);
 				res = tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALRECALL);
-				memset(p->call_forward, 0, sizeof(p->call_forward));
+				ast_string_field_set(p, call_forward, "");
 				getforward = 0;
 				memset(exten, 0, sizeof(exten));
 				len = 0;
@@ -6109,9 +6112,9 @@
 						counter = 0;
 						counter1 = 0;
 						/* Check to see if context is what it should be, if not set to be. */
-						if (strcmp(p->context,p->defcontext) != 0) {
-							ast_copy_string(p->context, p->defcontext, sizeof(p->context));
-							ast_copy_string(chan->context,p->defcontext,sizeof(chan->context));
+						if (!strcmp(p->context, p->defcontext)) {
+							ast_string_field_set(p, context, p->defcontext);
+							ast_copy_string(chan->context, p->defcontext, sizeof(chan->context));
 						}
 		
 						for (;;) {	
@@ -6169,10 +6172,10 @@
 							}
 							if (distMatches == 3) {
 								/* The ring matches, set the context to whatever is for distinctive ring.. */
-								ast_copy_string(p->context, p->drings.ringContext[counter].contextData, sizeof(p->context));
+								ast_string_field_set(p, context, p->drings.ringContext[counter].contextData);
 								ast_copy_string(chan->context, p->drings.ringContext[counter].contextData, sizeof(chan->context));
 								if (option_verbose > 2)
-									ast_verbose( VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n",p->context);
+									ast_verbose( VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n", p->context);
 								break;
 							}
 						}
@@ -6211,9 +6214,9 @@
 				counter = 0;
 				counter1 = 0;
 				/* Check to see if context is what it should be, if not set to be. */
-				if (strcmp(p->context,p->defcontext) != 0) {
-					ast_copy_string(p->context, p->defcontext, sizeof(p->context));
-					ast_copy_string(chan->context,p->defcontext,sizeof(chan->context));
+				if (!strcmp(p->context, p->defcontext)) {
+					ast_string_field_set(p, context, p->defcontext);
+					ast_copy_string(chan->context, p->defcontext, sizeof(chan->context));
 				}
 
 				/* Take out of linear mode for Caller*ID processing */
@@ -6342,10 +6345,10 @@
 						}
 						if (distMatches == 3) {
 							/* The ring matches, set the context to whatever is for distinctive ring.. */
-							ast_copy_string(p->context, p->drings.ringContext[counter].contextData, sizeof(p->context));
+							ast_string_field_set(p, context, p->drings.ringContext[counter].contextData);
 							ast_copy_string(chan->context, p->drings.ringContext[counter].contextData, sizeof(chan->context));
 							if (option_verbose > 2)
-								ast_verbose( VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n",p->context);
+								ast_verbose(VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n", p->context);
 							break;
 						}
 					}
@@ -7004,6 +7007,10 @@
 			destroy_zt_pvt(&tmp);
 			return NULL;
 		}
+		if (ast_string_field_init(tmp, 256)) {
+			destroy_zt_pvt(&tmp);
+			return NULL;
+		}
 		ast_mutex_init(&tmp->lock);
 		ifcount++;
 		for (x = 0; x < 3; x++)
@@ -7308,7 +7315,7 @@
 		}
 #endif
 
-		ast_copy_string(tmp->accountcode, accountcode, sizeof(tmp->accountcode));
+		ast_string_field_set(tmp, accountcode, accountcode);
 		tmp->amaflags = amaflags;
 		if (!here) {
 			tmp->confno = -1;
@@ -7316,14 +7323,14 @@
 		}
 		tmp->canpark = canpark;
 		tmp->transfer = transfer;
-		ast_copy_string(tmp->defcontext,context,sizeof(tmp->defcontext));
-		ast_copy_string(tmp->language, language, sizeof(tmp->language));
-		ast_copy_string(tmp->musicclass, musicclass, sizeof(tmp->musicclass));
-		ast_copy_string(tmp->context, context, sizeof(tmp->context));
-		ast_copy_string(tmp->cid_num, cid_num, sizeof(tmp->cid_num));
+		ast_string_field_set(tmp, defcontext, context);
+		ast_string_field_set(tmp, language, language);
+		ast_string_field_set(tmp, musicclass, musicclass);
+		ast_string_field_set(tmp, context, context);
+		ast_string_field_set(tmp, cid_num, cid_num);
 		tmp->cid_ton = 0;
-		ast_copy_string(tmp->cid_name, cid_name, sizeof(tmp->cid_name));
-		ast_copy_string(tmp->mailbox, mailbox, sizeof(tmp->mailbox));
+		ast_string_field_set(tmp, cid_name, cid_name);
+		ast_string_field_set(tmp, mailbox, mailbox);
 		tmp->msgstate = -1;
 		tmp->group = cur_group;
 		tmp->callgroup=cur_callergroup;
@@ -8565,22 +8572,22 @@
 					apply_plan_to_number(plancallingnum, sizeof(plancallingnum), pri, e->ring.callingnum, e->ring.callingplan);
 					if (pri->pvts[chanpos]->use_callerid) {
 						ast_shrink_phone_number(plancallingnum);
-						ast_copy_string(pri->pvts[chanpos]->cid_num, plancallingnum, sizeof(pri->pvts[chanpos]->cid_num));
+						ast_string_field_set(pri->pvts[chanpos], cid_num, plancallingnum);
 #ifdef PRI_ANI
 						if (!ast_strlen_zero(e->ring.callingani)) {
 							apply_plan_to_number(plancallingani, sizeof(plancallingani), pri, e->ring.callingani, e->ring.callingplanani);
 							ast_shrink_phone_number(plancallingani);
-							ast_copy_string(pri->pvts[chanpos]->cid_ani, plancallingani, sizeof(pri->pvts[chanpos]->cid_ani));
+							ast_string_field_set(pri->pvts[chanpos], cid_ani, plancallingani);
 						} else {
-							pri->pvts[chanpos]->cid_ani[0] = '\0';
+							ast_string_field_set(pri->pvts[chanpos], cid_ani, "");
 						}
 #endif
-						ast_copy_string(pri->pvts[chanpos]->cid_name, e->ring.callingname, sizeof(pri->pvts[chanpos]->cid_name));
+						ast_string_field_set(pri->pvts[chanpos], cid_name, e->ring.callingname);
 						pri->pvts[chanpos]->cid_ton = e->ring.callingplan; /* this is the callingplan (TON/NPI), e->ring.callingplan>>4 would be the TON */
 					} else {
-						pri->pvts[chanpos]->cid_num[0] = '\0';
-						pri->pvts[chanpos]->cid_ani[0] = '\0';
-						pri->pvts[chanpos]->cid_name[0] = '\0';
+						ast_string_field_set(pri->pvts[chanpos], cid_num, "");
+						ast_string_field_set(pri->pvts[chanpos], cid_ani, "");
+						ast_string_field_set(pri->pvts[chanpos], cid_name, "");
 						pri->pvts[chanpos]->cid_ton = 0;
 					}
 					apply_plan_to_number(pri->pvts[chanpos]->rdnis, sizeof(pri->pvts[chanpos]->rdnis), pri,
@@ -8589,24 +8596,22 @@
 					if (pri->pvts[chanpos]->immediate) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of immediate=yes\n");
-						pri->pvts[chanpos]->exten[0] = 's';
-						pri->pvts[chanpos]->exten[1] = '\0';
+						ast_string_field_set(pri->pvts[chanpos], exten, "s");
 					}
 					/* Get called number */
 					else if (!ast_strlen_zero(e->ring.callednum)) {
-						ast_copy_string(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
-						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
+						ast_string_field_set(pri->pvts[chanpos], exten, e->ring.callednum);
+						ast_string_field_set(pri->pvts[chanpos], dnid, e->ring.callednum);
 					} else
-						pri->pvts[chanpos]->exten[0] = '\0';
+						ast_string_field_set(pri->pvts[chanpos], exten, "");
 					/* Set DNID on all incoming calls -- even immediate */
 					if (!ast_strlen_zero(e->ring.callednum))
-						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
+						ast_string_field_set(pri->pvts[chanpos], dnid, e->ring.callednum);
 					/* No number yet, but received "sending complete"? */
 					if (e->ring.complete && (ast_strlen_zero(e->ring.callednum))) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of Complete received\n");
-						pri->pvts[chanpos]->exten[0] = 's';
-						pri->pvts[chanpos]->exten[1] = '\0';
+						ast_string_field_set(pri->pvts[chanpos], exten, "s");
 					}
 					/* Make sure extension exists (or in overlap dial mode, can exist) */
 					if ((pri->overlapdial && ast_canmatch_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->cid_num)) ||
@@ -8731,7 +8736,7 @@
 									pri->pvts[chanpos]->prioffset, pri->span);
 						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_UNALLOCATED);
 						pri->pvts[chanpos]->call = NULL;
-						pri->pvts[chanpos]->exten[0] = '\0';
+						ast_string_field_set(pri->pvts[chanpos], exten, "");
 					}
 					if (crv)
 						ast_mutex_unlock(&crv->lock);
@@ -8869,8 +8874,8 @@
 					} else {
 						/* Re-use *69 field for PRI */
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
-						ast_copy_string(pri->pvts[chanpos]->lastcid_num, e->facname.callingnum, sizeof(pri->pvts[chanpos]->lastcid_num));
-						ast_copy_string(pri->pvts[chanpos]->lastcid_name, e->facname.callingname, sizeof(pri->pvts[chanpos]->lastcid_name));
+						ast_string_field_set(pri->pvts[chanpos], lastcid_num, e->facname.callingnum);
+						ast_string_field_set(pri->pvts[chanpos], lastcid_name, e->facname.callingname);
 						pri->pvts[chanpos]->subs[SUB_REAL].needcallerid =1;
 						zt_enable_ec(pri->pvts[chanpos]);
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
@@ -10389,6 +10394,7 @@
 				if (cur_outsignalling < 0) cur_outsignalling = cur_signalling;
 				for (x = start; x <= finish; x++) {
 #ifdef HAVE_LIBPRI
+					ast_verbose("channel: %d  cur_sig: %d  cur_outsig: %d  cur_radio: %d\n", x, cur_signalling, cur_outsignalling, cur_radio);
 					tmp = mkintf(x, cur_signalling, cur_outsignalling, cur_radio, pri, reload);
 #else					
 					tmp = mkintf(x, cur_signalling, cur_outsignalling, cur_radio, NULL, reload);
@@ -10405,9 +10411,9 @@
 						}
 					} else {
 						if (reload == 1)
-							ast_log(LOG_ERROR, "Unable to reconfigure channel '%s'\n", v->value);
+							ast_log(LOG_ERROR, "Unable to reconfigure channel '%d'\n", x);
 						else
-							ast_log(LOG_ERROR, "Unable to register channel '%s'\n", v->value);
+							ast_log(LOG_ERROR, "Unable to register channel '%d'\n", x);
 						ast_config_destroy(cfg);
 						ast_mutex_unlock(&iflock);
 						return -1;

Modified: trunk/include/asterisk/callerid.h
===================================================================
--- trunk/include/asterisk/callerid.h	2006-06-18 20:48:03 UTC (rev 269)
+++ trunk/include/asterisk/callerid.h	2006-06-18 20:48:36 UTC (rev 270)
@@ -86,7 +86,7 @@
  * \return It returns the size
  * (in bytes) of the data (if it returns a size of 0, there is probably an error)
 */
-int callerid_generate(unsigned char *buf, char *number, char *name, int flags, int callwaiting, int codec);
+int callerid_generate(unsigned char *buf, const char *number, const char *name, int flags, int callwaiting, int codec);
 
 /*! \brief Create a callerID state machine
  * \param cid_signalling Type of signalling in use
@@ -157,7 +157,7 @@
  *
  * Acts like callerid_generate except uses an asterisk format callerid string.
  */
-int ast_callerid_generate(unsigned char *buf, char *name, char *number, int codec);
+int ast_callerid_generate(unsigned char *buf, const char *name, const char *number, int codec);
 
 /*! \brief Generate message waiting indicator  (stutter tone) */
 int vmwi_generate(unsigned char *buf, int active, int mdmf, int codec);
@@ -165,7 +165,7 @@
 /*! \brief Generate Caller-ID spill but in a format suitable for Call Waiting(tm)'s Caller*ID(tm)
  * See ast_callerid_generate() for other details
  */
-int ast_callerid_callwaiting_generate(unsigned char *buf, char *name, char *number, int codec);
+int ast_callerid_callwaiting_generate(unsigned char *buf, const char *name, const char *number, int codec);
 
 /*! \brief Destructively parse inbuf into name and location (or number)
  * Parses callerid stream from inbuf and changes into useable form, outputed in name and location.

Modified: trunk/include/asterisk/stringfields.h
===================================================================
--- trunk/include/asterisk/stringfields.h	2006-06-18 20:48:03 UTC (rev 269)
+++ trunk/include/asterisk/stringfields.h	2006-06-18 20:48:36 UTC (rev 270)
@@ -47,7 +47,7 @@
   
   sample = calloc(1, sizeof(*sample));
   if (sample) {
-	  if (!ast_string_field_init(sample, 256)) {
+	  if (ast_string_field_init(sample, 256)) {
 		  free(sample);
 		  sample = NULL;
 	  }
@@ -132,7 +132,7 @@
   \param size Amount of storage to allocate
   \param fields Pointer to the first entry of the field array
   \param num_fields Number of fields in the array
-  \return 0 on failure, non-zero on success
+  \return 0 on success, non-zero on failure
 */
 int __ast_string_field_init(struct ast_string_field_mgr *mgr, size_t size,
 			    ast_string_field *fields, int num_fields);
@@ -205,7 +205,7 @@
   \brief Initialize a field pool and fields
   \param x Pointer to a structure containing fields
   \param size Amount of storage to allocate
-  \return 0 on failure, non-zero on success
+  \return 0 on success, non-zero on failure
 */
 #define ast_string_field_init(x, size) \
 	__ast_string_field_init(&(x)->__field_mgr, size, &(x)->__begin_field[0], ast_string_field_count(x))



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 22:55:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 22:55:41 +0200
Subject: [solid-pbx-svn] r271 - trunk
Message-ID: <200606182055.k5IKtfIo011452@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 22:55:40 +0200 (Sun, 18 Jun 2006)
New Revision: 271

Modified:
   trunk/channel.c
Log:
Update to Asterisk SVN trunk r32483

------------------------------------------------------------------------
r32478 | russell | 2006-06-06 07:27:14 +0200 (Tue, 06 Jun 2006) | 4 lines

fix a channel deadlock in ast_answer
(deadlock reported by and debuged with hads on #asterisk-dev on IRC)
(probably fixes issue #7267, maybe others)

------------------------------------------------------------------------


Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-18 20:48:36 UTC (rev 270)
+++ trunk/channel.c	2006-06-18 20:55:40 UTC (rev 271)
@@ -1502,8 +1502,10 @@
 	int res = 0;
 	ast_channel_lock(chan);
 	/* You can't answer an outbound call */
-	if (ast_test_flag(chan, AST_FLAG_OUTGOING))
+	if (ast_test_flag(chan, AST_FLAG_OUTGOING)) {
+		ast_channel_unlock(chan);
 		return 0;
+	}
 	/* Stop if we're a zombie or need a soft hangup */
 	if (ast_test_flag(chan, AST_FLAG_ZOMBIE) || ast_check_hangup(chan)) {
 		ast_channel_unlock(chan);



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:01:59 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:01:59 +0200
Subject: [solid-pbx-svn] r272 - in trunk/channels: . misdn
Message-ID: <200606182101.k5IL1xRe011989@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:01:57 +0200 (Sun, 18 Jun 2006)
New Revision: 272

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
Log:
Update to Asterisk SVN trunk r32533

------------------------------------------------------------------------
r32524 | crichter | 2006-06-06 11:40:41 +0200 (Tue, 06 Jun 2006) | 1 line

added select before write to avoid deadlock on full buffer. added some defines for deadlock debugging. added code snippet for generating silence if we don't have data to write.
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-18 20:55:40 UTC (rev 271)
+++ trunk/channels/chan_misdn.c	2006-06-18 21:01:57 UTC (rev 272)
@@ -2352,7 +2352,6 @@
 		break;
 	case TONE_FILE:
 		break;
-
 	case TONE_NONE:
 		chan_misdn_log(3,cl->bc->port," --> None\n");
 		misdn_lib_tone_generator_stop(cl->bc);
@@ -3285,7 +3284,6 @@
 				
 				ast_queue_frame(ch->ast, &fr);
 			}
-			
 		}
 	}
 	break;
@@ -3694,7 +3692,7 @@
 		int (*generate)(struct ast_channel *chan, void *tmp, int datalen, int samples);
 
 		chan_misdn_log(9,bc->port,"TONE_GEN: len:%d\n");
-		
+
 		if (!ast->generator) break;
 		
 		tmp = ast->generatordata;
@@ -3702,13 +3700,13 @@
 		generate = ast->generator->generate;
 		res = generate(ast, tmp, tone_len, tone_len);
 		ast->generatordata = tmp;
+		
 		if (res) {
 			ast_log(LOG_WARNING, "Auto-deactivating generator\n");
 			ast_deactivate_generator(ast);
 		} else {
 			bc->tone_cnt=0;
 		}
-		
 	}
 	break;
 		
@@ -3728,11 +3726,36 @@
 			
 			ast_queue_frame(ch->ast,&frame);
 		} else {
-			int ret=write(ch->pipe[1], bc->bframe, bc->bframe_len);
+			fd_set wrfs;
+			struct timeval tv;
+			tv.tv_sec=0;
+			tv.tv_usec=0;
+			
+			
+			FD_ZERO(&wrfs);
+			FD_SET(ch->pipe[1],&wrfs);
+			
+			int t=select(FD_SETSIZE,NULL,&wrfs,NULL,&tv);
 
-			if (ret<=0) {
-				chan_misdn_log(1, bc->port, "Write returned <=0 (err=%s)\n",strerror(errno));
+			if (!t) {
+				chan_misdn_log(9, bc->port, "Select Timed out\n");
+				break;
 			}
+			
+			if (t<0) {
+				chan_misdn_log(-1, bc->port, "Select Error (err=%s)\n",strerror(errno));
+				break;
+			}
+			
+			if (FD_ISSET(ch->pipe[1],&wrfs)) {
+				int ret=write(ch->pipe[1], bc->bframe, bc->bframe_len);
+				
+				if (ret<=0) {
+					chan_misdn_log(-1, bc->port, "Write returned <=0 (err=%s)\n",strerror(errno));
+				}
+			} else {
+				chan_misdn_log(1, bc->port, "Wripe Pipe full!\n");
+			}
 		}
 	}
 	break;

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-18 20:55:40 UTC (rev 271)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-18 21:01:57 UTC (rev 272)
@@ -599,7 +599,7 @@
 	cb_log(3, stack->port, "$$$ CLEARING STACK\n");
 	
 	ret=mISDN_clear_stack(stack->midev,bc->b_stid);
-	if (ret<0) {
+	if (ret<0 && errno) {
 		cb_log(-1,stack->port,"clear stack failed [%s]\n",strerror(errno));
 	}
 
@@ -1986,7 +1986,7 @@
 	
 	if (bc->generate_tone) {
 		cb_event(EVENT_TONE_GENERATE, bc, glob_mgr->user_data);
-
+		
 		if ( !bc->nojitter ) {
 			misdn_tx_jitter(bc,len);
 		}
@@ -2002,13 +2002,14 @@
 void misdn_tx_jitter(struct misdn_bchannel *bc, int len)
 {
 	char buf[4096 + mISDN_HEADER_LEN];
+	char *data=&buf[mISDN_HEADER_LEN];
 	iframe_t *txfrm= (iframe_t*)buf;
 	int jlen, r;
 	
-	jlen=cb_jb_empty(bc,&buf[mISDN_HEADER_LEN],len);
+	jlen=cb_jb_empty(bc,data,len);
 	
 	if (jlen) {
-		flip_buf_bits( &buf[mISDN_HEADER_LEN], jlen);
+		flip_buf_bits( data, jlen);
 		
 		if (jlen < len) {
 			cb_log(5,bc->port,"Jitterbuffer Underrun.\n");
@@ -2024,6 +2025,33 @@
 		cb_log(9, bc->port, "Transmitting %d samples 2 misdn\n", txfrm->len);
 		
 		r=mISDN_write( glob_mgr->midev, buf, txfrm->len + mISDN_HEADER_LEN, 8000 );
+	} else {
+#ifdef MISDN_GEN_SILENCE
+		int cnt=len/TONE_SILENCE_SIZE;
+		int rest=len%TONE_SILENCE_SIZE;
+		int i;
+
+		for (i=0; i<cnt; i++) {
+			memcpy(data, tone_silence_flip, TONE_SILENCE_SIZE );
+			data +=TONE_SILENCE_SIZE;
+		}
+
+		if (rest) {
+			memcpy(data, tone_silence_flip, rest);
+		}
+
+		txfrm->prim = DL_DATA|REQUEST;
+
+		txfrm->dinfo = 0;
+
+		txfrm->addr = bc->addr|FLG_MSG_DOWN; /*  | IF_DOWN; */
+
+		txfrm->len =len;
+		cb_log(9, bc->port, "Transmitting %d samples 2 misdn\n", txfrm->len);
+
+		r=mISDN_write( glob_mgr->midev, buf, txfrm->len + mISDN_HEADER_LEN, 8000 );
+#endif
+
 	}
 }
 
@@ -2201,15 +2229,39 @@
 #endif
 		
 		if ( (bc->bc_state == BCHAN_ACTIVATED) && frm->len > 0) {
-			if (  !do_tone(bc, frm->len)   ) {
+			int t;
+
+#ifdef MISDN_B_DEBUG
+			cb_log(0,bc->port,"do_tone START\n");
+#endif
+			t=do_tone(bc,frm->len);
+
+#ifdef MISDN_B_DEBUG
+			cb_log(0,bc->port,"do_tone STOP (%d)\n",t);
+#endif
+			if (  !t ) {
 				
 				if ( misdn_cap_is_speech(bc->capability)) {
 					if ( !bc->nojitter ) {
+#ifdef MISDN_B_DEBUG
+						cb_log(0,bc->port,"tx_jitter START\n");
+#endif
 						misdn_tx_jitter(bc,frm->len);
+#ifdef MISDN_B_DEBUG
+						cb_log(0,bc->port,"tx_jitter STOP\n");
+#endif
 					}
 				}
+
+#ifdef MISDN_B_DEBUG	
+				cb_log(0,bc->port,"EVENT_B_DATA START\n");
+#endif
 				
 				int i=cb_event( EVENT_BCHAN_DATA, bc, glob_mgr->user_data);
+#ifdef MISDN_B_DEBUG	
+				cb_log(0,bc->port,"EVENT_B_DATA STOP\n");
+#endif
+				
 				if (i<0) {
 					cb_log(10,stack->port,"cb_event returned <0\n");
 					/*clean_up_bc(bc);*/
@@ -2262,7 +2314,8 @@
 	if (!stack || !stack->nt) {
 		return 0;
 	}
-  
+
+	
 	if ((err=stack->nst.l1_l2(&stack->nst,msg))) {
     
 		if (nt_err_cnt > 0 ) {
@@ -2520,6 +2573,8 @@
 		case SSTATUS_L1_DEACTIVATED:
 			cb_log(1, 0, "MGMT: SSTATUS: L1_DEACTIVATED \n");
 			stack->l1link=0;
+
+			clear_l3(stack);
 			break;
 
 		case SSTATUS_L2_ESTABLISHED:
@@ -3096,10 +3151,20 @@
 	}
 
 	if ( ((frm->addr | ISDN_PID_BCHANNEL_BIT )>> 28 ) == 0x5) {
-		if (handle_bchan(msg)) 
+#ifdef MISDN_HANDLER_DEBUG
+		cb_log(0,0,"handle_bchan START\n");
+#endif
+		if (handle_bchan(msg)) {
+#ifdef MISDN_HANDLER_DEBUG
+			cb_log(0,0,"handle_bchan STOP\n");
+#endif
 			return 0 ;
+		}
+#ifdef MISDN_HANDLER_DEBUG
+		cb_log(0,0,"handle_bchan NOTSTOP\n");
+#endif	
 	}	
-
+	
 	if (handle_timers(msg)) 
 		return 0 ;
 	
@@ -3112,16 +3177,46 @@
 	/* Its important to handle l1 AFTER l2  */
 	if (handle_l1(msg)) 
 		return 0 ;
-
-	if (handle_frm_nt(msg)) 
+	
+#ifdef MISDN_HANDLER_DEBUG
+	cb_log(0,0,"handle_frm_nt START\n");
+#endif
+	if (handle_frm_nt(msg)) {
+#ifdef MISDN_HANDLER_DEBUG
+		cb_log(0,0,"handle_frm_nt STOP\n");
+#endif
 		return 0;
-
-	if (handle_frm(msg))
+	}
+#ifdef MISDN_HANDLER_DEBUG
+	cb_log(0,0,"handle_frm_nt NOTSTOP\n");
+	
+	cb_log(0,0,"handle_frm START\n");
+#endif
+	
+	if (handle_frm(msg)) {
+#ifdef MISDN_HANDLER_DEBUG
+		cb_log(0,0,"handle_frm STOP\n");
+#endif
+		
 		return 0;
-
-	if (handle_err(msg)) 
+	}
+#ifdef MISDN_HANDLER_DEBUG
+	cb_log(0,0,"handle_frm NOTSTOP\n");	
+	
+	cb_log(0,0,"handle_err START\n");
+#endif
+	
+	if (handle_err(msg)) {
+#ifdef MISDN_HANDLER_DEBUG
+		cb_log(0,0,"handle_err STOP\n");
+#endif
 		return 0 ;
+	}
+#ifdef MISDN_HANDLER_DEBUG
+	cb_log(0,0,"handle_err NOTSTOP\n");
+#endif
 
+	
 	cb_log(-1, 0, "Unhandled Message: prim %x len %d from addr %x, dinfo %x on this port.\n",frm->prim, frm->len, frm->addr, frm->dinfo);		
 	free_msg(msg);
 	



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:09:18 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:09:18 +0200
Subject: [solid-pbx-svn] r273 - trunk/channels
Message-ID: <200606182109.k5IL9IDw012895@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:09:17 +0200 (Sun, 18 Jun 2006)
New Revision: 273

Modified:
   trunk/channels/chan_zap.c
Log:
Update to Asterisk SVN trunk r32553

------------------------------------------------------------------------
r32545 | russell | 2006-06-06 16:24:59 +0200 (Tue, 06 Jun 2006) | 3 lines

don't return -1 if zapata.conf is not present (part of the patch from
issue #7290, tzafrir)

------------------------------------------------------------------------


Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-18 21:01:57 UTC (rev 272)
+++ trunk/channels/chan_zap.c	2006-06-18 21:09:17 UTC (rev 273)
@@ -10250,7 +10250,7 @@
 	/* We *must* have a config file otherwise stop immediately */
 	if (!cfg) {
 		ast_log(LOG_ERROR, "Unable to load config %s\n", config);
-		return -1;
+		return 0;
 	}
 	
 



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:09:50 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:09:50 +0200
Subject: [solid-pbx-svn] r274 - trunk/channels
Message-ID: <200606182109.k5IL9oou012932@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:09:50 +0200 (Sun, 18 Jun 2006)
New Revision: 274

Modified:
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r32573

------------------------------------------------------------------------
r32567 | kpfleming | 2006-06-06 17:48:42 +0200 (Tue, 06 Jun 2006) | 10 lines

Merged revisions 32566 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r32566 | kpfleming | 2006-06-06 10:48:00 -0500 (Tue, 06 Jun 2006) | 2 lines

clean up yesterday's security fix to not cause breakage when video mini frames are received

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 21:09:17 UTC (rev 273)
+++ trunk/channels/chan_iax2.c	2006-06-18 21:09:50 UTC (rev 274)
@@ -6318,12 +6318,23 @@
 		ast_log(LOG_WARNING, "midget packet received (%d of %zd min)\n", res, sizeof(*mh));
 		return 1;
 	}
-	if ((res >= sizeof(*vh)) && ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000))) {
+	if ((vh->zeros == 0) && (ntohs(vh->callno) & 0x8000)) {
+		if (res < sizeof(*vh)) {
+			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video frame but is too short\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+			return 1;
+		}
+
 		/* This is a video frame, get call number */
 		fr->callno = find_callno(ntohs(vh->callno) & ~0x8000, dcallno, &sin, new, 1, fd);
 		minivid = 1;
-	} else if ((res >= sizeof(*meta)) && (meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000)) {
+	} else if ((meta->zeros == 0) && !(ntohs(meta->metacmd) & 0x8000)) {
 		unsigned char metatype;
+
+		if (res < sizeof(*meta)) {
+			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a meta frame but is too short\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+			return 1;
+		}
+
 		/* This is a meta header */
 		switch(meta->metacmd) {
 		case IAX_META_TRUNK:
@@ -6445,20 +6456,16 @@
 		return 1;
 	}
 
-	/* if we got here and ->zeros contains zeros, this cannot be a valid
-	   miniframe or full frame but it wasn't a valid video frame or meta
-	   frame either, so we reject it
-	*/
-	if (vh->zeros == 0) {
-		ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a video or meta frame but is not properly formatted\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
-		return 1;
-	}
-
 #ifdef DEBUG_SUPPORT
 	if (iaxdebug && (res >= sizeof(*fh)))
 		iax_showframe(NULL, fh, 1, &sin, res - sizeof(*fh));
 #endif
-	if ((res >= sizeof(*fh)) && ntohs(mh->callno) & IAX_FLAG_FULL) {
+	if (ntohs(mh->callno) & IAX_FLAG_FULL) {
+		if (res < sizeof(*fh)) {
+			ast_log(LOG_WARNING, "Rejecting packet from '%s.%d' that is flagged as a full frame but is too short\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+			return 1;
+		}
+
 		/* Get the destination call number */
 		dcallno = ntohs(fh->dcallno) & ~IAX_FLAG_RETRANS;
 		/* Retrieve the type and subclass */



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:11:10 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:11:10 +0200
Subject: [solid-pbx-svn] r275 - in trunk: . channels include/asterisk
Message-ID: <200606182111.k5ILBArK013069@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:11:06 +0200 (Sun, 18 Jun 2006)
New Revision: 275

Modified:
   trunk/callerid.c
   trunk/channel.c
   trunk/channels/chan_sip.c
   trunk/frame.c
   trunk/include/asterisk/rtp.h
   trunk/include/asterisk/translate.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r32603

------------------------------------------------------------------------
r32596 | tilghman | 2006-06-06 18:05:29 +0200 (Tue, 06 Jun 2006) | 10 lines

Merged revisions 32582 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r32582 | tilghman | 2006-06-06 11:02:43 -0500 (Tue, 06 Jun 2006) | 2 lines

Bug 7268 - Callerid leaks memory on error

.......

------------------------------------------------------------------------
r32597 | oej | 2006-06-06 18:09:33 +0200 (Tue, 06 Jun 2006) | 13 lines

Merge of the "sdpcleanup" branch. Thanks to John Martin for a lot of tests
and some patches (all disclaimed).

- Don't change RTP properties if we reject a re-INVITE
- Don't add video to an outbound channel if there's no video on the inbound channel
- Don't include video in the "preferred codec" list for codec selection
- Clean up and document code that parses and adds SDP attachments

Since we do not transcode video, we can't handle video the same way as audio. This is a
bug fix patch. In future releases, we need to work on a solution for video negotiation,
not codecs but formats and framerates instead.


------------------------------------------------------------------------


Modified: trunk/callerid.c
===================================================================
--- trunk/callerid.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/callerid.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -557,6 +557,7 @@
 		res = fsk_serie(&cid->fskd, buf, &mylen, &b);
 		if (mylen < 0) {
 			ast_log(LOG_ERROR, "fsk_serie made mylen < 0 (%d)\n", mylen);
+			free(obuf);
 			return -1;
 		}
 		buf += (olen - mylen);
@@ -590,6 +591,7 @@
 			case 4: /* Retrieve message */
 				if (cid->pos >= 128) {
 					ast_log(LOG_WARNING, "Caller ID too long???\n");
+					free(obuf);
 					return -1;
 				}
 				cid->rawdata[cid->pos++] = b;
@@ -675,6 +677,7 @@
 					strcpy(cid->name, "");
 					cid->flags |= CID_UNKNOWN_NAME;
 				}
+				free(obuf);
 				return 1;
 				break;
 			default:

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/channel.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -539,7 +539,7 @@
 	}
 }
 
-/*! \brief Pick the best codec */
+/*! \brief Pick the best audio codec */
 int ast_best_codec(int fmts)
 {
 	/* This just our opinion, expressed in code.  We are asked to choose
@@ -572,8 +572,10 @@
 		/*! Down to G.723.1 which is proprietary but at least designed for voice */
 		AST_FORMAT_G723_1,
 	};
+
+	/* Strip out video */
+	fmts &= AST_FORMAT_AUDIO_MASK;
 	
-	
 	/* Find the first preferred codec in the format given */
 	for (x=0; x < (sizeof(prefs) / sizeof(prefs[0]) ); x++)
 		if (fmts & prefs[x])
@@ -2614,6 +2616,7 @@
 	int fmt;
 	int res;
 	int foo;
+	int videoformat = format & AST_FORMAT_VIDEO_MASK;
 
 	if (!cause)
 		cause = &foo;
@@ -2629,7 +2632,7 @@
 			continue;
 
 		capabilities = chan->tech->capabilities;
-		fmt = format;
+		fmt = format & AST_FORMAT_AUDIO_MASK;
 		res = ast_translator_best_choice(&fmt, &capabilities);
 		if (res < 0) {
 			ast_log(LOG_WARNING, "No translator path exists for channel type %s (native %d) to %d\n", type, chan->tech->capabilities, format);
@@ -2640,7 +2643,7 @@
 		if (!chan->tech->requester)
 			return NULL;
 		
-		if (!(c = chan->tech->requester(type, capabilities, data, cause)))
+		if (!(c = chan->tech->requester(type, capabilities | videoformat, data, cause)))
 			return NULL;
 
 		if (c->_state == AST_STATE_DOWN) {

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/channels/chan_sip.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -1260,6 +1260,7 @@
 static int sip_get_codec(struct ast_channel *chan);
 static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p);
 
+
 /*! \brief Definition of this channel for PBX channel registration */
 static const struct ast_channel_tech sip_tech = {
 	.type = "SIP",
@@ -3252,13 +3253,17 @@
 
 
 /*! \brief Initiate a call in the SIP channel
-	called from sip_request_call (calls from the pbx ) */
+	called from sip_request_call (calls from the pbx ) for outbound channels
+	and from handle_request_invite for inbound channels
+	
+*/
 static struct ast_channel *sip_new(struct sip_pvt *i, int state, const char *title)
 {
 	struct ast_channel *tmp;
 	struct ast_variable *v = NULL;
 	int fmt;
 	int what;
+	int needvideo = 0;
 	
 	ast_mutex_unlock(&i->lock);
 	/* Don't hold a sip pvt lock while we allocate a channel */
@@ -3269,17 +3274,50 @@
 		return NULL;
 	}
 	tmp->tech = &sip_tech;
+
 	/* Select our native format based on codec preference until we receive
 	   something from another device to the contrary. */
-	if (i->jointcapability)
+	if (i->jointcapability)	 	/* The joint capabilities of us and peer */
 		what = i->jointcapability;
-	else if (i->capability)
+	else if (i->capability)		/* Our configured capability for this peer */
 		what = i->capability;
 	else
-		what = global_capability;
+		what = global_capability;	/* Global codec support */
+
+	/* Set the native formats for audio  and merge in video */
 	tmp->nativeformats = ast_codec_choose(&i->prefs, what, 1) | (i->jointcapability & AST_FORMAT_VIDEO_MASK);
+	if (option_debug > 2) {
+		char buf[BUFSIZ];
+		ast_log(LOG_DEBUG, "*** Our native formats are %s \n", ast_getformatname_multiple(buf, BUFSIZ, tmp->nativeformats));
+		ast_log(LOG_DEBUG, "*** Joint capabilities are %s \n", ast_getformatname_multiple(buf, BUFSIZ, i->jointcapability));
+		ast_log(LOG_DEBUG, "*** Our capabilities are %s \n", ast_getformatname_multiple(buf, BUFSIZ, i->capability));
+		ast_log(LOG_DEBUG, "*** AST_CODEC_CHOOSE formats are %s \n", ast_getformatname_multiple(buf, BUFSIZ, ast_codec_choose(&i->prefs, what, 1)));
+		if (i->prefcodec)
+			ast_log(LOG_DEBUG, "*** Our preferred formats from the incoming channel are %s \n", ast_getformatname_multiple(buf, BUFSIZ, i->prefcodec));
+	}
+
+	/* XXX Why are we choosing a codec from the native formats?? */
 	fmt = ast_best_codec(tmp->nativeformats);
 
+	/* If we have a prefcodec setting, we have an inbound channel that set a 
+	   preferred format for this call. Otherwise, we check the jointcapability
+	   We also check for vrtp. If it's not there, we are not allowed do any video anyway.
+	 */
+	if (i->vrtp) {
+		if (i->prefcodec)
+			needvideo = i->prefcodec & AST_FORMAT_VIDEO_MASK;	/* Outbound call */
+ 		else
+			needvideo = i->jointcapability & AST_FORMAT_VIDEO_MASK;	/* Inbound call */
+	}
+
+	if (option_debug > 2) {
+		if (needvideo) 
+			ast_log(LOG_DEBUG, "This channel can handle video! HOLLYWOOD next!\n");
+		else
+			ast_log(LOG_DEBUG, "This channel will not be able to handle video.\n");
+	}
+
+
 	if (title)
 		ast_string_field_build(tmp, name, "SIP/%s-%04lx", title, ast_random() & 0xffff);
 	else if (strchr(i->fromdomain,':'))
@@ -3297,7 +3335,7 @@
 		tmp->fds[0] = ast_rtp_fd(i->rtp);
 		tmp->fds[1] = ast_rtcp_fd(i->rtp);
 	}
-	if (i->vrtp) {
+	if (needvideo && i->vrtp) {
 		tmp->fds[2] = ast_rtp_fd(i->vrtp);
 		tmp->fds[3] = ast_rtcp_fd(i->vrtp);
 	}
@@ -4038,7 +4076,9 @@
 	return 0;
 }
 
-/*! \brief Process SIP SDP, select formats and activate RTP channels */
+/*! \brief Process SIP SDP offer, select formats and activate RTP channels
+	If offer is rejected, we will not change any properties of the call
+*/
 static int process_sdp(struct sip_pvt *p, struct sip_request *req)
 {
 	const char *m;		/* SDP media offer */
@@ -4047,33 +4087,49 @@
 	char host[258];
 	char iabuf[INET_ADDRSTRLEN];
 	int len = -1;
-	int portno = -1;	/* Audio port */
-	int vportno = -1;	/* Video port */
+	int portno = -1;		/*!< RTP Audio port number */
+	int vportno = -1;		/*!< RTP Video port number */
 
 	/* Peer capability is the capability in the SDP, non codec is RFC2833 DTMF (101) */	
 	int peercapability, peernoncodeccapability;
+	int vpeercapability = 0, vpeernoncodeccapability = 0;
+	struct sockaddr_in sin;		/*!< media socket address */
+	struct sockaddr_in vsin;	/*!< Video socket address */
 
-	int vpeercapability=0, vpeernoncodeccapability=0;	/* Peer's video capabilities */
-	struct sockaddr_in sin;
 	const char *codecs;
-	struct hostent *hp;
-	struct ast_hostent ahp;
+	struct hostent *hp;		/*!< RTP Audio host IP */
+	struct hostent *vhp = NULL;	/*!< RTP video host IP */
+	struct ast_hostent audiohp;
+	struct ast_hostent videohp;
 	int codec;
 	int destiterator = 0;
 	int iterator;
 	int sendonly = 0;
-	int x, y;
+	int numberofports;
+	struct ast_channel *bridgepeer = NULL;
+	struct ast_rtp newaudiortp, newvideortp;	/* Buffers for codec handling */
+	int newjointcapability;				/* Negotiated capability */
+	int newpeercapability;
+	int newnoncodeccapability;
+	int numberofmediastreams = 0;
 	int debug = sip_debug_test_pvt(p);
-	struct ast_channel *bridgepeer = NULL;
-
+		
 	if (!p->rtp) {
 		ast_log(LOG_ERROR, "Got SDP but have no RTP session allocated.\n");
 		return -1;
 	}
 
+	/* Initialize the temporary RTP structures we use to evaluate the offer from the peer */
+	memset(&newaudiortp, 0, sizeof(newaudiortp));
+	memset(&newvideortp, 0, sizeof(newvideortp));
+	ast_rtp_pt_default(&newaudiortp);
+	ast_rtp_pt_default(&newvideortp);
+
 	/* Update our last rtprx when we receive an SDP, too */
 	p->lastrtprx = p->lastrtptx = time(NULL); /* XXX why both ? */
 
+
+	/* Try to find first media stream */
 	m = get_sdp(req, "m");
 	destiterator = req->sdp_start;
 	c = get_sdp_iterate(&destiterator, req, "c");
@@ -4081,26 +4137,41 @@
 		ast_log(LOG_WARNING, "Insufficient information for SDP (m = '%s', c = '%s')\n", m, c);
 		return -1;
 	}
+
+	/* Check for IPv4 address (not IPv6 yet) */
 	if (sscanf(c, "IN IP4 %256s", host) != 1) {
 		ast_log(LOG_WARNING, "Invalid host in c= line, '%s'\n", c);
 		return -1;
 	}
+
 	/* XXX This could block for a long time, and block the main thread! XXX */
-	hp = ast_gethostbyname(host, &ahp);
+	hp = ast_gethostbyname(host, &audiohp);
 	if (!hp) {
 		ast_log(LOG_WARNING, "Unable to lookup host in c= line, '%s'\n", c);
 		return -1;
 	}
+	vhp = hp;	/* Copy to video address as default too */
+	
 	iterator = req->sdp_start;
 	ast_set_flag(&p->flags[0], SIP_NOVIDEO);	
+
+
+	/* Find media streams in this SDP offer */
 	while ((m = get_sdp_iterate(&iterator, req, "m"))[0] != '\0') {
-		int found = 0;
-		if ((sscanf(m, "audio %d/%d RTP/AVP %n", &x, &y, &len) == 2) ||
+		int x;
+		int audio = FALSE;
+		numberofmediastreams++;
+
+		if (p->vrtp)
+			ast_rtp_pt_clear(&newvideortp);  /* Must be cleared in case no m=video line exists */
+		numberofports = 1;
+		if ((sscanf(m, "audio %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
 		    (sscanf(m, "audio %d RTP/AVP %n", &x, &len) == 1)) {
-			found = 1;
+			audio = TRUE;
+			/* Found audio stream in this media definition */
 			portno = x;
 			/* Scan through the RTP payload types specified in a "m=" line: */
-			ast_rtp_pt_clear(p->rtp);
+			ast_rtp_pt_clear(&newaudiortp);
 			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
 				if (sscanf(codecs, "%d%n", &codec, &len) != 1) {
 					ast_log(LOG_WARNING, "Error in codec string '%s'\n", codecs);
@@ -4108,14 +4179,11 @@
 				}
 				if (debug)
 					ast_verbose("Found RTP audio format %d\n", codec);
-				ast_rtp_set_m_type(p->rtp, codec);
+				ast_rtp_set_m_type(&newaudiortp, codec);
 			}
-		}
-		if (p->vrtp)
-			ast_rtp_pt_clear(p->vrtp);  /* Must be cleared in case no m=video line exists */
-
-		if (p->vrtp && (sscanf(m, "video %d RTP/AVP %n", &x, &len) == 1)) {
-			found = 1;
+		} else if ((sscanf(m, "video %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
+		    (sscanf(m, "video %d RTP/AVP %n", &x, &len) == 1)) {
+			/* If it is not audio - is it video ? */
 			ast_clear_flag(&p->flags[0], SIP_NOVIDEO);	
 			vportno = x;
 			/* Scan through the RTP payload types specified in a "m=" line: */
@@ -4126,144 +4194,210 @@
 				}
 				if (debug)
 					ast_verbose("Found RTP video format %d\n", codec);
-				ast_rtp_set_m_type(p->vrtp, codec);
+				ast_rtp_set_m_type(&newvideortp, codec);
 			}
-		}
-		if (!found )
-			ast_log(LOG_WARNING, "Unknown SDP media type in offer: %s\n", m);
-	}
-	if (portno == -1 && vportno == -1) {
-		/* No acceptable offer found in SDP */
-		return -2;
-	}
-	/* Check for Media-description-level-address for audio */
-	if (pedanticsipchecking) {
+		} else 
+			ast_log(LOG_WARNING, "Unsupported SDP media type in offer: %s\n", m);
+		if (numberofports > 1)
+			ast_log(LOG_WARNING, "SDP offered %d ports for media, not supported by Asterisk. Will try anyway...\n", numberofports);
+		
+
+		/* Check for Media-description-level-address for audio */
 		c = get_sdp_iterate(&destiterator, req, "c");
 		if (!ast_strlen_zero(c)) {
 			if (sscanf(c, "IN IP4 %256s", host) != 1) {
 				ast_log(LOG_WARNING, "Invalid secondary host in c= line, '%s'\n", c);
 			} else {
 				/* XXX This could block for a long time, and block the main thread! XXX */
-				hp = ast_gethostbyname(host, &ahp);
-				if (!hp) {
-					ast_log(LOG_WARNING, "Unable to lookup host in secondary c= line, '%s'\n", c);
-				}
+				if (audio) {
+					if ( !(hp = ast_gethostbyname(host, &audiohp)))
+						ast_log(LOG_WARNING, "Unable to lookup RTP Audio host in secondary c= line, '%s'\n", c);
+				} else if (!(vhp = ast_gethostbyname(host, &videohp)))
+					ast_log(LOG_WARNING, "Unable to lookup RTP video host in secondary c= line, '%s'\n", c);
 			}
+
 		}
 	}
+	if (portno == -1 && vportno == -1)
+		/* No acceptable offer found in SDP  - we have no ports */
+		/* Do not change RTP or VRTP if this is a re-invite */
+		return -2;
+
+	if (numberofmediastreams > 2)
+		/* We have too many media streams, fail this offer */
+		return -3;
+
 	/* RTP addresses and ports for audio and video */
 	sin.sin_family = AF_INET;
+	vsin.sin_family = AF_INET;
 	memcpy(&sin.sin_addr, hp->h_addr, sizeof(sin.sin_addr));
+	if (vhp)
+		memcpy(&vsin.sin_addr, vhp->h_addr, sizeof(vsin.sin_addr));
+		
 
 	/* Setup audio port number */
 	sin.sin_port = htons(portno);
-	if (p->rtp && sin.sin_port) {
-		ast_rtp_set_peer(p->rtp, &sin);
-		if (debug) {
-			ast_verbose("Peer audio RTP is at port %s:%d\n", ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
-		}
-	}
-	/* Check for Media-description-level-address for video */
-	if (pedanticsipchecking) {
-		c = get_sdp_iterate(&destiterator, req, "c");
-		if (!ast_strlen_zero(c)) {
-			if (sscanf(c, "IN IP4 %256s", host) != 1) {
-				ast_log(LOG_WARNING, "Invalid secondary host in c= line, '%s'\n", c);
-			} else {
-				/* XXX This could block for a long time, and block the main thread! XXX */
-				hp = ast_gethostbyname(host, &ahp);
-				if (!hp) {
-					ast_log(LOG_WARNING, "Unable to lookup host in secondary c= line, '%s'\n", c);
-				}
-			}
-		}
-	}
 	/* Setup video port number */
-	sin.sin_port = htons(vportno);
-	if (p->vrtp && sin.sin_port) {
-		ast_rtp_set_peer(p->vrtp, &sin);
-		if (debug) {
-			ast_verbose("Peer video RTP is at port %s:%d\n", ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
-		}
-	}
+	if (vportno != -1)
+		vsin.sin_port = htons(vportno);
 
 	/* Next, scan through each "a=rtpmap:" line, noting each
 	 * specified RTP payload type (with corresponding MIME subtype):
 	 */
+	/* XXX This needs to be done per media stream, since it's media stream specific */
 	iterator = req->sdp_start;
 	while ((a = get_sdp_iterate(&iterator, req, "a"))[0] != '\0') {
 		char* mimeSubtype = ast_strdupa(a); /* ensures we have enough space */
 		if (!strcasecmp(a, "sendonly")) {
-			sendonly=1;
+			sendonly = 1;
 			continue;
-		}
-		if (!strcasecmp(a, "sendrecv")) {
-		  	sendonly=0;
-		}
-		if (sscanf(a, "rtpmap: %u %[^/]/", &codec, mimeSubtype) != 2) continue;
+		}  else if (!strcasecmp(a, "sendrecv")) {
+			sendonly = 0;
+			continue;
+		} else if (option_debug) {
+			/* If we're debugging, check for unsupported sdp options */
+			if (!strcasecmp(a, "inactive")) {
+				/* Inactive media streams: Not supported */
+				if (debug)
+					ast_verbose("Got unsupported a:inactive in SDP offer \n");
+				continue;
+			} else if (!strncasecmp(a, "rtcp:", (size_t) 5)) {
+				if (debug)
+					ast_verbose("Got unsupported a:rtcp in SDP offer \n");
+				continue;
+			} else if (!strncasecmp(a, "fmtp:", (size_t) 5)) {
+				/* Format parameters:  Not supported */
+				/* Note: This is used for codec parameters, like bitrate for
+					G722 and video formats for H263 and H264 
+					See RFC2327 for an example */
+				if (debug)
+					ast_verbose("Got unsupported a:fmtp in SDP offer \n");
+				continue;
+			} else if (!strncasecmp(a, "framerate:", (size_t) 10)) {
+				/* Video stuff:  Not supported */
+				if (debug)
+					ast_verbose("Got unsupported a:framerate in SDP offer \n");
+				continue;
+			} else if (!strncasecmp(a, "maxprate:", (size_t) 9)) {
+				/* Video stuff:  Not supported */
+				if (debug)
+					ast_verbose("Got unsupported a:maxprate in SDP offer \n");
+				continue;
+			} else if (!strncasecmp(a, "crypto:", (size_t) 7)) {
+				/* SRTP stuff, not yet supported */
+				if (debug)
+					ast_verbose("Got unsupported a:crypto in SDP offer \n");
+				continue;
+			} else if (!strncasecmp(a, "ptime:", (size_t) 6)) {
+				if (debug)
+					ast_verbose("Got unsupported a:ptime in SDP offer \n");
+				continue;
+			}
+		} else if (sscanf(a, "rtpmap: %u %[^/]/", &codec, mimeSubtype) != 2) 
+			continue;
+		/* We have a rtpmap to handle */
 		if (debug)
-			ast_verbose("Found description format %s\n", mimeSubtype);
+			ast_verbose("Found description format %s for ID %d\n", mimeSubtype, codec);
+
 		/* Note: should really look at the 'freq' and '#chans' params too */
-		ast_rtp_set_rtpmap_type(p->rtp, codec, "audio", mimeSubtype);
+		ast_rtp_set_rtpmap_type(&newaudiortp, codec, "audio", mimeSubtype);
 		if (p->vrtp)
-			ast_rtp_set_rtpmap_type(p->vrtp, codec, "video", mimeSubtype);
+			ast_rtp_set_rtpmap_type(&newvideortp, codec, "video", mimeSubtype);
 	}
 
-	/* Now gather all of the codecs that were asked for: */
-	ast_rtp_get_current_formats(p->rtp,
-				&peercapability, &peernoncodeccapability);
-	if (p->vrtp)
-		ast_rtp_get_current_formats(p->vrtp,
-				&vpeercapability, &vpeernoncodeccapability);
-	p->jointcapability = p->capability & (peercapability | vpeercapability);
-	p->peercapability = (peercapability | vpeercapability);
-	p->noncodeccapability = noncodeccapability & peernoncodeccapability;
-	
+	/* Now gather all of the codecs that we are asked for: */
+	ast_rtp_get_current_formats(&newaudiortp, &peercapability, &peernoncodeccapability);
+	ast_rtp_get_current_formats(&newvideortp, &vpeercapability, &vpeernoncodeccapability);
+
+	newjointcapability = p->capability & (peercapability | vpeercapability);
+	newpeercapability = (peercapability | vpeercapability);
+	newnoncodeccapability = noncodeccapability & peernoncodeccapability;
+		
+		
+	if (debug) {
+		/* shame on whoever coded this.... */
+		char s1[BUFSIZ], s2[BUFSIZ], s3[BUFSIZ], s4[BUFSIZ];
+
+		ast_verbose("Capabilities: us - %s, peer - audio=%s/video=%s, combined - %s\n",
+			ast_getformatname_multiple(s1, BUFSIZ, p->capability),
+			ast_getformatname_multiple(s2, BUFSIZ, newpeercapability),
+			ast_getformatname_multiple(s3, BUFSIZ, vpeercapability),
+			ast_getformatname_multiple(s4, BUFSIZ, newjointcapability));
+
+		ast_verbose("Non-codec capabilities (dtmf): us - %s, peer - %s, combined - %s\n",
+			ast_rtp_lookup_mime_multiple(s1, BUFSIZ, noncodeccapability, 0),
+			ast_rtp_lookup_mime_multiple(s2, BUFSIZ, peernoncodeccapability, 0),
+			ast_rtp_lookup_mime_multiple(s3, BUFSIZ, newnoncodeccapability, 0));
+	}
+	if (!newjointcapability) {
+		ast_log(LOG_NOTICE, "No compatible codecs, not accepting this offer!\n");
+		/* Do NOT Change current setting */
+		return -1;
+	}
+
+	/* We are now ready to change the sip session and p->rtp and p->vrtp with the offered codecs, since
+		they are acceptable */
+	p->jointcapability = newjointcapability;	/* Our joint codec profile for this call */
+	p->peercapability = newpeercapability;		/* The other sides capability in latest offer */
+	p->noncodeccapability = newnoncodeccapability;	/* DTMF capabilities */
+
+	{
+		int i;
+		/* Copy payload types from source to destination */
+		for (i=0; i < MAX_RTP_PT; ++i) {
+			p->rtp->current_RTP_PT[i]= newaudiortp.current_RTP_PT[i];
+			if (p->vrtp) 
+				p->vrtp->current_RTP_PT[i]= newvideortp.current_RTP_PT[i];
+		}
+	}
+
 	if (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO) {
 		ast_clear_flag(&p->flags[0], SIP_DTMF);
-		if (p->noncodeccapability & AST_RTP_DTMF) {
+		if (newnoncodeccapability & AST_RTP_DTMF) {
 			/* XXX Would it be reasonable to drop the DSP at this point? XXX */
 			ast_set_flag(&p->flags[0], SIP_DTMF_RFC2833);
 		} else {
 			ast_set_flag(&p->flags[0], SIP_DTMF_INBAND);
 		}
 	}
-	
-	if (debug) {
-		/* shame on whoever coded this.... */
-		const unsigned slen=512;
-		char s1[slen], s2[slen], s3[slen], s4[slen];
 
-		ast_verbose("Capabilities: us - %s, peer - audio=%s/video=%s, combined - %s\n",
-			ast_getformatname_multiple(s1, slen, p->capability),
-			ast_getformatname_multiple(s2, slen, peercapability),
-			ast_getformatname_multiple(s3, slen, vpeercapability),
-			ast_getformatname_multiple(s4, slen, p->jointcapability));
+	/* Setup audio port number */
+	if (p->rtp && sin.sin_port) {
+		ast_rtp_set_peer(p->rtp, &sin);
+		if (debug)
+			ast_verbose("Peer audio RTP is at port %s:%d\n", ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+	}
 
-		ast_verbose("Non-codec capabilities: us - %s, peer - %s, combined - %s\n",
-			ast_rtp_lookup_mime_multiple(s1, slen, noncodeccapability, 0),
-			ast_rtp_lookup_mime_multiple(s2, slen, peernoncodeccapability, 0),
-			ast_rtp_lookup_mime_multiple(s3, slen, p->noncodeccapability, 0));
+	/* Setup video port number */
+	if (p->vrtp && vsin.sin_port) {
+		ast_rtp_set_peer(p->vrtp, &vsin);
+		if (debug) 
+			ast_verbose("Peer video RTP is at port %s:%d\n", ast_inet_ntoa(iabuf,sizeof(iabuf), vsin.sin_addr), ntohs(vsin.sin_port));
 	}
-	if (!p->jointcapability) {
-		ast_log(LOG_NOTICE, "No compatible codecs!\n");
-		return -1;
+
+	/* Ok, we're going with this offer */
+	if (option_debug > 1) {
+		char buf[BUFSIZ];
+		ast_log(LOG_DEBUG, "We're settling with these formats: %s\n", ast_getformatname_multiple(buf, BUFSIZ, p->jointcapability));
 	}
 
-	if (!p->owner) 	/* There's no open channel owning us */
+	if (!p->owner) 	/* There's no open channel owning us so we can return here. For a re-invite or so, we proceed */
 		return 0;
 
+
 	if (!(p->owner->nativeformats & p->jointcapability & AST_FORMAT_AUDIO_MASK)) {
-		const unsigned slen=512;
-		char s1[slen], s2[slen];
-		ast_log(LOG_DEBUG, "Oooh, we need to change our formats since our peer supports only %s and not %s\n", 
-				ast_getformatname_multiple(s1, slen, p->jointcapability),
-				ast_getformatname_multiple(s2, slen, p->owner->nativeformats));
+		if (debug) {
+			char s1[BUFSIZ], s2[BUFSIZ];
+			ast_log(LOG_DEBUG, "Oooh, we need to change our audio formats since our peer supports only %s and not %s\n", 
+				ast_getformatname_multiple(s1, BUFSIZ, p->jointcapability),
+				ast_getformatname_multiple(s2, BUFSIZ, p->owner->nativeformats));
+		}
 		p->owner->nativeformats = ast_codec_choose(&p->prefs, p->jointcapability, 1) | (p->capability & vpeercapability);
 		ast_set_read_format(p->owner, p->owner->readformat);
 		ast_set_write_format(p->owner, p->owner->writeformat);
 	}
-	if ((bridgepeer=ast_bridged_channel(p->owner))) {
+
+	if ((bridgepeer = ast_bridged_channel(p->owner))) {
 		/* We have a bridge */
 		/* Turn on/off music on hold if we are holding/unholding */
 		if (sin.sin_addr.s_addr && !sendonly) {
@@ -4277,12 +4411,15 @@
 			ast_moh_start(bridgepeer, NULL);
 			if (sendonly)
 				ast_rtp_stop(p->rtp);
+			/* RTCP needs to go ahead, even if we're on hold!!! */
+
 			/* Activate a re-invite */
 			ast_queue_frame(p->owner, &ast_null_frame);
 		}
 	}
 
 	/* Manager Hold and Unhold events must be generated, if necessary */
+	/* XXX Support for sendonly/recvonly needs to be fixed !!! */
 	if (sin.sin_addr.s_addr && !sendonly) {
 		append_history(p, "Unhold", "%s", req->data);
 
@@ -4308,10 +4445,12 @@
 		}
 		ast_set_flag(&p->flags[0], SIP_CALL_ONHOLD);
 	}
+	
 
 	return 0;
 }
 
+
 /*! \brief Add header to SIP message */
 static int add_header(struct sip_request *req, const char *var, const char *value)
 {
@@ -4885,6 +5024,7 @@
 	return 0;
 }
 
+/*! \brief Add codec offer to SDP offer/answer body in INVITE or 200 OK */
 static void add_codec_to_sdp(const struct sip_pvt *p, int codec, int sample_rate,
 			     char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
 			     int debug)
@@ -4905,6 +5045,7 @@
 		ast_build_string(a_buf, a_size, "a=fmtp:%d annexb=no\r\n", rtp_code);
 }
 
+/*! \brief Add RFC 2833 DTMF offer to SDP */
 static void add_noncodec_to_sdp(const struct sip_pvt *p, int format, int sample_rate,
 				char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
 				int debug)
@@ -4929,21 +5070,25 @@
 static int add_sdp(struct sip_request *resp, struct sip_pvt *p)
 {
 	int len = 0;
-	int pref_codec;
 	int alreadysent = 0;
+
 	struct sockaddr_in sin;
 	struct sockaddr_in vsin;
-	char v[256];
-	char s[256];
-	char o[256];
-	char c[256];
-	char t[256];
-	char b[256];
+	struct sockaddr_in dest;
+	struct sockaddr_in vdest = { 0, };
+
+	/* SDP fields */
+	char *version = 	"v=0\r\n";		/* Protocol version */
+	char *subject = 	"s=session\r\n";	/* Subject of the session */
+	char owner[256];				/* Session owner/creator */
+	char connection[256];				/* Connection data */
+	char *stime = "t=0 0\r\n"; 			/* Time the session is active */
+	char bandwidth[256] = "";			/* Max bitrate */
 	char *hold;
-	char m_audio[256];
-	char m_video[256];
-	char a_audio[1024];
-	char a_video[1024];
+	char m_audio[256];				/* Media declaration line for audio */
+	char m_video[256];				/* Media declaration line for video */
+	char a_audio[1024];				/* Attributes for audio */
+	char a_video[1024];				/* Attributes for video */
 	char *m_audio_next = m_audio;
 	char *m_video_next = m_video;
 	size_t m_audio_left = sizeof(m_audio);
@@ -4952,31 +5097,33 @@
 	char *a_video_next = a_video;
 	size_t a_audio_left = sizeof(a_audio);
 	size_t a_video_left = sizeof(a_video);
+
 	char iabuf[INET_ADDRSTRLEN];
 	int x;
 	int capability;
-	struct sockaddr_in dest;
-	struct sockaddr_in vdest = { 0, };
-	int debug;
-	
-	debug = sip_debug_test_pvt(p);
+	int needvideo = FALSE;
+	int debug = sip_debug_test_pvt(p);
 
-	len = 0;
+	m_video[0] = '\0';	/* Reset the video media string if it's not needed */
+
 	if (!p->rtp) {
 		ast_log(LOG_WARNING, "No way to add SDP without an RTP structure\n");
 		return -1;
 	}
-	capability = p->jointcapability;
-		
+
+	/* Set RTP Session ID and version */
 	if (!p->sessionid) {
 		p->sessionid = getpid();
 		p->sessionversion = p->sessionid;
 	} else
 		p->sessionversion++;
+
+	/* Get our addresses */
 	ast_rtp_get_us(p->rtp, &sin);
 	if (p->vrtp)
 		ast_rtp_get_us(p->vrtp, &vsin);
 
+	/* Is this a re-invite to move the media out, then use the original offer from caller  */
 	if (p->redirip.sin_addr.s_addr) {
 		dest.sin_port = p->redirip.sin_port;
 		dest.sin_addr = p->redirip.sin_addr;
@@ -4987,60 +5134,109 @@
 		dest.sin_port = sin.sin_port;
 	}
 
-	/* Determine video destination */
-	if (p->vrtp) {
+	/* Ok, let's start working with codec selection here */
+	capability = p->jointcapability;
+
+	if (option_debug > 1) {
+		char codecbuf[BUFSIZ];
+		ast_log(LOG_DEBUG, "** Our capability: %s Video flag: %s\n", ast_getformatname_multiple(codecbuf, sizeof(codecbuf), capability), ast_test_flag(&p->flags[0], SIP_NOVIDEO) ? "True" : "False");
+		ast_log(LOG_DEBUG, "** Our prefcodec: %s \n", ast_getformatname_multiple(codecbuf, sizeof(codecbuf), p->prefcodec));
+	}
+
+	/* Check if we need video in this call */
+	if((capability & AST_FORMAT_VIDEO_MASK) && !ast_test_flag(&p->flags[0], SIP_NOVIDEO)) {
+		if (p->vrtp) {
+			needvideo = TRUE;
+			if (option_debug > 1)
+				ast_log(LOG_DEBUG, "This call needs video offers! \n");
+		} else if (option_debug > 1)
+			ast_log(LOG_DEBUG, "This call needs video offers, but there's no video support enabled ! \n");
+	}
+		
+
+	/* Ok, we need video. Let's add what we need for video and set codecs.
+	   Video is handled differently than audio since we can not transcode. */
+	if (needvideo) {
+
+		/* Determine video destination */
 		if (p->vredirip.sin_addr.s_addr) {
+			vdest.sin_addr = p->vredirip.sin_addr;
 			vdest.sin_port = p->vredirip.sin_port;
-			vdest.sin_addr = p->vredirip.sin_addr;
 		} else {
 			vdest.sin_addr = p->ourip;
 			vdest.sin_port = vsin.sin_port;
 		}
-	}
-	if (debug) {
-		ast_verbose("We're at %s port %d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip), ntohs(sin.sin_port));	
-		if (p->vrtp)
+		ast_build_string(&m_video_next, &m_video_left, "m=video %d RTP/AVP", ntohs(vdest.sin_port));
+
+		/* Build max bitrate string */
+		if (p->maxcallbitrate)
+			snprintf(bandwidth, sizeof(bandwidth), "b=CT:%d\r\n", p->maxcallbitrate);
+		if (debug) 
 			ast_verbose("Video is at %s port %d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip), ntohs(vsin.sin_port));	
+
+		/* For video, we can't negotiate video offers. Let's compare the incoming call with what we got. */
+		if (p->prefcodec) {
+			int videocapability = (capability & p->prefcodec) & AST_FORMAT_VIDEO_MASK; /* Outbound call */
+		
+			/*! \todo XXX We need to select one codec, not many, since there's no transcoding */
+
+			/* Now, merge this video capability into capability while removing unsupported codecs */
+			if (!videocapability) {
+				needvideo = FALSE;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG, "** No compatible video codecs... Disabling video.\n");
+			} 
+
+			/* Replace video capabilities with the new videocapability */
+			capability = (capability & AST_FORMAT_AUDIO_MASK) | videocapability;
+
+			if (option_debug > 4) {
+				char codecbuf[BUFSIZ];
+				if (videocapability)
+					ast_log(LOG_DEBUG, "** Our video codec selection is: %s \n", ast_getformatname_multiple(codecbuf, sizeof(codecbuf), videocapability));
+				ast_log(LOG_DEBUG, "** Capability now set to : %s \n", ast_getformatname_multiple(codecbuf, sizeof(codecbuf), capability));
+			}
+		}
 	}
+	if (debug) 
+		ast_verbose("Audio is at %s port %d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip), ntohs(sin.sin_port));	
 
+	/* Start building generic SDP headers */
+
 	/* We break with the "recommendation" and send our IP, in order that our
 	   peer doesn't have to ast_gethostbyname() us */
 
-	snprintf(v, sizeof(v), "v=0\r\n");
-	snprintf(o, sizeof(o), "o=root %d %d IN IP4 %s\r\n", p->sessionid, p->sessionversion, ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
-	snprintf(s, sizeof(s), "s=session\r\n");
-	snprintf(c, sizeof(c), "c=IN IP4 %s\r\n", ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
-	if ((p->vrtp) &&
-	    (!ast_test_flag(&p->flags[0], SIP_NOVIDEO)) &&
-	    (capability & VIDEO_CODEC_MASK)) /* only if video response is appropriate */
-		snprintf(b, sizeof(b), "b=CT:%d\r\n", p->maxcallbitrate);	
-	snprintf(t, sizeof(t), "t=0 0\r\n");
-
+	snprintf(owner, sizeof(owner), "o=root %d %d IN IP4 %s\r\n", p->sessionid, p->sessionversion, ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
+	snprintf(connection, sizeof(connection), "c=IN IP4 %s\r\n", ast_inet_ntoa(iabuf, sizeof(iabuf), dest.sin_addr));
 	ast_build_string(&m_audio_next, &m_audio_left, "m=audio %d RTP/AVP", ntohs(dest.sin_port));
-	ast_build_string(&m_video_next, &m_video_left, "m=video %d RTP/AVP", ntohs(vdest.sin_port));
 
 	if (ast_test_flag(&p->flags[0], SIP_CALL_ONHOLD))
 		hold = "a=recvonly\r\n";
 	else
 		hold = "a=sendrecv\r\n";
 
-	/* Prefer the codec we were requested to use, first, no matter what */
+	/* Now, start adding audio codecs. These are added in this order:
+		- First what was requested by the calling channel
+		- Then preferences in order from sip.conf device config for this peer/user
+		- Then other codecs in capabilities, including video
+	*/
+
+	/* Prefer the audio codec we were requested to use, first, no matter what 
+		Note that p->prefcodec can include video codecs, so mask them out
+	 */
 	if (capability & p->prefcodec) {
-		if (p->prefcodec <= AST_FORMAT_MAX_AUDIO)
-			add_codec_to_sdp(p, p->prefcodec, 8000,
-					 &m_audio_next, &m_audio_left,
-					 &a_audio_next, &a_audio_left,
-					 debug);
-		else
-			add_codec_to_sdp(p, p->prefcodec, 90000,
-					 &m_video_next, &m_video_left,
-					 &a_video_next, &a_video_left,
-					 debug);
-		alreadysent |= p->prefcodec;
+		add_codec_to_sdp(p, p->prefcodec & AST_FORMAT_AUDIO_MASK, 8000,
+				 &m_audio_next, &m_audio_left,
+				 &a_audio_next, &a_audio_left,
+				 debug);
+		alreadysent |= p->prefcodec & AST_FORMAT_AUDIO_MASK;
 	}
 
-	/* Start by sending our preferred codecs */
+
+	/* Start by sending our preferred audio codecs */
 	for (x = 0; x < 32; x++) {
+		int pref_codec;
+
 		if (!(pref_codec = ast_codec_pref_index(&p->prefs, x)))
 			break; 
 
@@ -5050,27 +5246,21 @@
 		if (alreadysent & pref_codec)
 			continue;
 
-		if (pref_codec <= AST_FORMAT_MAX_AUDIO)
-			add_codec_to_sdp(p, pref_codec, 8000,
-					 &m_audio_next, &m_audio_left,
-					 &a_audio_next, &a_audio_left,
-					 debug);
-		else
-			add_codec_to_sdp(p, pref_codec, 90000,
-					 &m_video_next, &m_video_left,
-					 &a_video_next, &a_video_left,
-					 debug);
+		add_codec_to_sdp(p, pref_codec, 8000,
+				 &m_audio_next, &m_audio_left,
+				 &a_audio_next, &a_audio_left,
+				 debug);
 		alreadysent |= pref_codec;
 	}
 
-	/* Now send any other common codecs, and non-codec formats: */
-	for (x = 1;
-	     x <= ((ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) ? AST_FORMAT_MAX_VIDEO : AST_FORMAT_MAX_AUDIO);
-	     x <<= 1) {
-		if (!(capability & x))
+	/* Now send any other common audio and video codecs, and non-codec formats: */
+	for (x = 1; x <= (needvideo ? AST_FORMAT_MAX_VIDEO : AST_FORMAT_MAX_AUDIO); x <<= 1) {
+		if (!(capability & x))	/* Codec not requested */
 			continue;
 
-		if (alreadysent & x)
+		ast_log(LOG_DEBUG, "--- Checking codec ... %d\n", x);
+
+		if (alreadysent & x)	/* Already added to SDP */
 			continue;
 
 		if (x <= AST_FORMAT_MAX_AUDIO)
@@ -5078,13 +5268,14 @@
 					 &m_audio_next, &m_audio_left,
 					 &a_audio_next, &a_audio_left,
 					 debug);
-		else
+		else 
 			add_codec_to_sdp(p, x, 90000,
 					 &m_video_next, &m_video_left,
 					 &a_video_next, &a_video_left,
 					 debug);
 	}
 
+	/* Now add DTMF RFC2833 telephony-event as a codec */
 	for (x = 1; x <= AST_RTP_MAX; x <<= 1) {
 		if (!(p->noncodeccapability & x))
 			continue;
@@ -5095,6 +5286,9 @@
 				    debug);
 	}
 
+	if (option_debug > 2)
+		ast_log(LOG_DEBUG, "-- Done with adding codecs to SDP\n");
+
 	if(!ast_internal_timing_enabled(p->owner))
 		ast_build_string(&a_audio_next, &a_audio_left, "a=silenceSupp:off - - - -\r\n");
 
@@ -5102,39 +5296,39 @@
 		ast_log(LOG_WARNING, "SIP SDP may be truncated due to undersized buffer!!\n");
 
 	ast_build_string(&m_audio_next, &m_audio_left, "\r\n");
-	ast_build_string(&m_video_next, &m_video_left, "\r\n");
+	if (needvideo)
+		ast_build_string(&m_video_next, &m_video_left, "\r\n");
 
-	len = strlen(v) + strlen(s) + strlen(o) + strlen(c) + strlen(t) + strlen(m_audio) + strlen(a_audio) + strlen(hold);
-	if ((p->vrtp) &&
-	    (!ast_test_flag(&p->flags[0], SIP_NOVIDEO)) &&
-	    (capability & VIDEO_CODEC_MASK)) /* only if video response is appropriate */
-		len += strlen(m_video) + strlen(a_video) + strlen(b) + strlen(hold);
+	len = strlen(version) + strlen(subject) + strlen(owner) + strlen(connection) + strlen(stime) + strlen(m_audio) + strlen(a_audio) + strlen(hold);
+	if (needvideo) /* only if video response is appropriate */
+		len += strlen(m_video) + strlen(a_video) + strlen(bandwidth) + strlen(hold);
 
 	add_header(resp, "Content-Type", "application/sdp");
 	add_header_contentLength(resp, len);
-	add_line(resp, v);
-	add_line(resp, o);
-	add_line(resp, s);
-	add_line(resp, c);
-	if ((p->vrtp) &&
-	    (!ast_test_flag(&p->flags[0], SIP_NOVIDEO)) &&
-	    (capability & VIDEO_CODEC_MASK)) /* only if video response is appropriate */
-		add_line(resp, b);
-	add_line(resp, t);
+	add_line(resp, version);
+	add_line(resp, owner);
+	add_line(resp, subject);
+	add_line(resp, connection);
+	if (needvideo)	 	/* only if video response is appropriate */
+		add_line(resp, bandwidth);
+	add_line(resp, stime);
 	add_line(resp, m_audio);
 	add_line(resp, a_audio);
 	add_line(resp, hold);
-	if ((p->vrtp) &&
-	    (!ast_test_flag(&p->flags[0], SIP_NOVIDEO)) &&
-	    (capability & VIDEO_CODEC_MASK)) { /* only if video response is appropriate */
+	if (needvideo) { /* only if video response is appropriate */
 		add_line(resp, m_video);
 		add_line(resp, a_video);
-		add_line(resp, hold);
+		add_line(resp, hold);	/* Repeat hold for the video stream */
 	}
 
 	/* Update lastrtprx when we send our SDP */
 	p->lastrtprx = p->lastrtptx = time(NULL); /* XXX why both ? */
 
+	if (option_debug > 2) {
+		char buf[BUFSIZ];
+		ast_log(LOG_DEBUG, "Done building SDP. Settling with this capability: %s\n", ast_getformatname_multiple(buf, BUFSIZ, capability));
+	}
+
 	return 0;
 }
 
@@ -7744,20 +7938,24 @@
 			p->pickupgroup = user->pickupgroup;
 			if (user->callingpres)	/* User callingpres setting will override RPID header */
 				p->callingpres = user->callingpres;
-			p->capability = user->capability;
-			p->jointcapability = user->capability;
-			p->maxcallbitrate = user->maxcallbitrate;
-			if (!ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
-				ast_rtp_destroy(p->vrtp);
-				p->vrtp = NULL;
-			}
-			if (p->peercapability)
+			
+			/* Set default codec settings for this call */
+			p->capability = user->capability;		/* User codec choice */
+			p->jointcapability = user->capability;		/* Our codecs */
+			if (p->peercapability)				/* AND with peer's codecs */
 				p->jointcapability &= p->peercapability;
 			if ((ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) ||
 			    (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
 				p->noncodeccapability |= AST_RTP_DTMF;
 			else
 				p->noncodeccapability &= ~AST_RTP_DTMF;
+
+			p->maxcallbitrate = user->maxcallbitrate;
+			/* If we do not support video, remove video from call structure */
+			if (!ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
+				ast_rtp_destroy(p->vrtp);
+				p->vrtp = NULL;
+			}
 		}
 		if (user && debug)
 			ast_verbose("Found user '%s'\n", user->name);
@@ -10197,13 +10395,14 @@
 	}
 }
 
-/*! \brief Handle SIP response in dialogue */
+/*! \brief Handle SIP response to INVITE dialogue */
 static void handle_response_invite(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int seqno)
 {
 	int outgoing = ast_test_flag(&p->flags[0], SIP_OUTGOING);
+	int res = 0;
+	int reinvite = (p->owner && p->owner->_state == AST_STATE_UP);
 	
 	if (option_debug > 3) {
-		int reinvite = (p->owner && p->owner->_state == AST_STATE_UP);
 		if (reinvite)
 			ast_log(LOG_DEBUG, "SIP response %d to RE-invite on %s call %s\n", resp, outgoing ? "outgoing" : "incoming", p->callid);
 		else
@@ -10241,7 +10440,7 @@
 			}
 		}
 		if (find_sdp(req)) {
-			process_sdp(p, req);
+			res = process_sdp(p, req);
 			if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
 				/* Queue a progress frame only if we have SDP in 180 */
 				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
@@ -10257,7 +10456,7 @@
 			sip_cancel_destroy(p);
 		/* Ignore 183 Session progress without SDP */
 		if (find_sdp(req)) {
-			process_sdp(p, req);
+			res = process_sdp(p, req);
 			if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
 				/* Queue a progress frame */
 				ast_queue_control(p->owner, AST_CONTROL_PROGRESS);
@@ -10272,8 +10471,13 @@
 		if (!ast_test_flag(req, SIP_PKT_IGNORE))
 			sip_cancel_destroy(p);
 		p->authtries = 0;
-		if (find_sdp(req))
-			process_sdp(p, req);
+		if (find_sdp(req)) {
+			if ((res = process_sdp(p, req)) && !ast_test_flag(req, SIP_PKT_IGNORE))
+				if (!reinvite)
+					/* This 200 OK's SDP is not acceptable, so we need to ack, then hangup */
+					/* For re-invites, we try to recover */
+					ast_set_flag(&p->flags[0], SIP_PENDINGBYE);	
+		}
 
 		/* Parse contact header for continued conversation */
 		/* When we get 200 OK, we know which device (and IP) to contact for this call */
@@ -10298,7 +10502,7 @@
 		}
 		
 		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
-			if (p->owner->_state != AST_STATE_UP) {
+			if (!reinvite) {
 				ast_queue_control(p->owner, AST_CONTROL_ANSWER);
 			} else {	/* RE-invite */
 				ast_queue_frame(p->owner, &ast_null_frame);
@@ -13460,6 +13664,9 @@
 		*cause = AST_CAUSE_BEARERCAPABILITY_NOTAVAIL;	/* Can't find codec to connect to host */
 		return NULL;
 	}
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Asked to create a SIP channel with formats: %s\n", ast_getformatname_multiple(tmp, sizeof(tmp), oldformat));
+
 	if (!(p = sip_alloc(NULL, NULL, 0, SIP_INVITE))) {
 		ast_log(LOG_ERROR, "Unable to build sip pvt data for '%s' (Out of memory or socket error)\n", (char *)data);
 		*cause = AST_CAUSE_SWITCH_CONGESTION;
@@ -13509,7 +13716,7 @@
 #if 0
 	printf("Setting up to call extension '%s' at '%s'\n", ext ? ext : "<none>", host);
 #endif
-	p->prefcodec = format;
+	p->prefcodec = oldformat;				/* Format for this call */
 	ast_mutex_lock(&p->lock);
 	tmpc = sip_new(p, AST_STATE_DOWN, host);	/* Place the call */
 	ast_mutex_unlock(&p->lock);
@@ -14744,10 +14951,13 @@
 		changed = 1;
 	}
 	if (changed && !ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
-		if (chan->_state != AST_STATE_UP) {
+		if (chan->_state != AST_STATE_UP) {	/* We are in early state */
 			char iabuf[INET_ADDRSTRLEN];
-			ast_log(LOG_DEBUG, "Early media setting SIP '%s' - Sending early media to %s\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p->redirip.sin_addr : p->ourip));
-		} else if (!p->pendinginvite) {
+			if (recordhistory)
+				append_history(p, "ExtInv", "Initial invite sent with remote bridge proposal.");
+			if (option_debug)
+				ast_log(LOG_DEBUG, "Early remote bridge setting SIP '%s' - Sending media to %s\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p->redirip.sin_addr : p->ourip));
+		} else if (!p->pendinginvite) {		/* We are up, and have no outstanding invite */
 			if (option_debug > 2) {
 				char iabuf[INET_ADDRSTRLEN];
 				ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's audio soon redirected to IP %s\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p->redirip.sin_addr : p->ourip));
@@ -14758,6 +14968,7 @@
 				char iabuf[INET_ADDRSTRLEN];
 				ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's audio will be redirected to IP %s\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), rtp ? p->redirip.sin_addr : p->ourip));
 			}
+			/* We have a pending Invite. Send re-invite when we're done with the invite */
 			ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);	
 		}
 	}

Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/frame.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -1008,9 +1008,12 @@
 			break;
 		}
 	}
-	if(ret)
+	if(ret & AST_FORMAT_AUDIO_MASK)
 		return ret;
 
+	if (option_debug > 3)
+		ast_log(LOG_DEBUG, "Could not find preferred codec - %s\n", find_best ? "Going for the best codec" : "Returning zero codec");
+
    	return find_best ? ast_best_codec(formats) : 0;
 }
 
@@ -1034,7 +1037,10 @@
 				*mask &= ~format;
 		}
 
-		if (pref) {
+		/* Set up a preference list for audio. Do not include video in preferences 
+		   since we can not transcode video and have to use whatever is offered
+		 */
+		if (pref && (format & AST_FORMAT_AUDIO_MASK)) {
 			if (strcasecmp(this, "all")) {
 				if (allowing)
 					ast_codec_pref_append(pref, format);

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/include/asterisk/rtp.h	2006-06-18 21:11:06 UTC (rev 275)
@@ -40,13 +40,13 @@
 
 /* Codes for RTP-specific data - not defined by our AST_FORMAT codes */
 /*! DTMF (RFC2833) */
-#define AST_RTP_DTMF            (1 << 0)
+#define AST_RTP_DTMF            	(1 << 0)
 /*! 'Comfort Noise' (RFC3389) */
-#define AST_RTP_CN              (1 << 1)
+#define AST_RTP_CN              	(1 << 1)
 /*! DTMF (Cisco Proprietary) */
-#define AST_RTP_CISCO_DTMF      (1 << 2)
+#define AST_RTP_CISCO_DTMF      	(1 << 2)
 /*! Maximum RTP-specific code */
-#define AST_RTP_MAX             AST_RTP_CISCO_DTMF
+#define AST_RTP_MAX             	AST_RTP_CISCO_DTMF
 
 #define MAX_RTP_PT			256
 
@@ -62,6 +62,9 @@
 	AST_LIST_ENTRY(ast_rtp_protocol) list;
 };
 
+
+#define FLAG_3389_WARNING		(1 << 0)
+
 typedef int (*ast_rtp_callback)(struct ast_rtp *rtp, struct ast_frame *f, void *data);
 
 
@@ -71,7 +74,6 @@
  * RTP session is defined on page 9 of RFC 3550: "An association among a set of participants communicating with RTP.  A participant may be involved in multiple RTP sessions at the same time [...]"
  *
  */
-
 /*! \brief The value of each payload format mapping: */
 struct rtpPayloadType {
 	int isAstFormat; 	/*!< whether the following code is an AST_FORMAT */

Modified: trunk/include/asterisk/translate.h
===================================================================
--- trunk/include/asterisk/translate.h	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/include/asterisk/translate.h	2006-06-18 21:11:06 UTC (rev 275)
@@ -23,7 +23,8 @@
 #ifndef _ASTERISK_TRANSLATE_H
 #define _ASTERISK_TRANSLATE_H
 
-#define MAX_FORMAT 32
+//#define MAX_FORMAT 15	/* Do not include video here */
+#define MAX_FORMAT 32	/* Do include video here */
 
 #if defined(__cplusplus) || defined(c_plusplus)
 extern "C" {

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 21:09:50 UTC (rev 274)
+++ trunk/rtp.c	2006-06-18 21:11:06 UTC (rev 275)
@@ -1350,7 +1350,7 @@
 	return 1;
 }
 
-/*! \brief  Make a note of a RTP paymoad type that was seen in a SDP "m=" line.
+/*! \brief  Make a note of a RTP payload type that was seen in a SDP "m=" line.
  * By default, use the well-known value for this type (although it may 
  * still be set to a different value by a subsequent "a=rtpmap:" line)
  */
@@ -1359,9 +1359,8 @@
 	if (pt < 0 || pt > MAX_RTP_PT) 
 		return; /* bogus payload type */
 
-	if (static_RTP_PT[pt].code != 0) {
+	if (static_RTP_PT[pt].code != 0) 
 		rtp->current_RTP_PT[pt] = static_RTP_PT[pt];
-	}
 } 
 
 /*! \brief Make a note of a RTP payload type (with MIME type) that was seen in
@@ -2245,7 +2244,7 @@
 	
 	/* Make sure we have enough space for RTP header */
 	if ((_f->frametype != AST_FRAME_VOICE) && (_f->frametype != AST_FRAME_VIDEO)) {
-		ast_log(LOG_WARNING, "RTP can only send voice\n");
+		ast_log(LOG_WARNING, "RTP can only send voice and video\n");
 		return -1;
 	}
 



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:25:20 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:25:20 +0200
Subject: [solid-pbx-svn] r276 - trunk/apps
Message-ID: <200606182125.k5ILPKh9014483@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:25:19 +0200 (Sun, 18 Jun 2006)
New Revision: 276

Modified:
   trunk/apps/app_voicemail.c
Log:
Update to Asterisk SVN trunk r32613

------------------------------------------------------------------------
r32604 | kpfleming | 2006-06-06 18:54:52 +0200 (Tue, 06 Jun 2006) | 2 lines

fix some compiler warnings about variables used before initialization

------------------------------------------------------------------------
r32606 | tilghman | 2006-06-06 18:59:13 +0200 (Tue, 06 Jun 2006) | 10 lines

Merged revisions 32605 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r32605 | tilghman | 2006-06-06 11:55:23 -0500 (Tue, 06 Jun 2006) | 2 lines

Bug 7287 - A too short voicemail with ODBC_STORAGE will cause the first voicemail to be deleted erroneously

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-18 21:11:06 UTC (rev 275)
+++ trunk/apps/app_voicemail.c	2006-06-18 21:25:19 UTC (rev 276)
@@ -2625,7 +2625,8 @@
 			if (duration < vmminmessage) {
 				if (option_verbose > 2) 
 					ast_verbose( VERBOSE_PREFIX_3 "Recording was %d seconds long but needs to be at least %d - abandoning\n", duration, vmminmessage);
-				DELETE(dir,msgnum,fn);
+				ast_filedelete(tmptxtfile, NULL);
+				unlink(tmptxtfile);
 			} else {
 				fprintf(txt, "duration=%d\n", duration);
 				fclose(txt);



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:52:07 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:52:07 +0200
Subject: [solid-pbx-svn] r277 - trunk/apps
Message-ID: <200606182152.k5ILq7CE016292@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:52:07 +0200 (Sun, 18 Jun 2006)
New Revision: 277

Added:
   trunk/apps/app_followme.c
Log:
Add missing file

Added: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-18 21:25:19 UTC (rev 276)
+++ trunk/apps/app_followme.c	2006-06-18 21:52:07 UTC (rev 277)
@@ -0,0 +1,1135 @@
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * A full-featured Find-Me/Follow-Me Application
+ * 
+ * Copyright (C) 2005-2006, BJ Weschke All Rights Reserved.
+ *
+ * BJ Weschke <bweschke at btwtech.com>
+ *
+ * This code is released by the author with no restrictions on usage.
+ *
+ * See http://www.asterisk.org for more information about
+ * the Asterisk project. Please do not directly contact
+ * any of the maintainers of this project for assistance;
+ * the project provides a web site, mailing lists and IRC
+ * channels for your use.
+ *
+ */
+
+/*! \file
+ *
+ * \brief Find-Me Follow-Me application
+ *
+ * \author BJ Weschke <bweschke at btwtech.com>
+ *
+ * \ingroup applications
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <string.h>
+#include <signal.h>
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$version$")
+
+#include "asterisk/lock.h"
+#include "asterisk/file.h"
+#include "asterisk/logger.h"
+#include "asterisk/channel.h"
+#include "asterisk/pbx.h"
+#include "asterisk/options.h"
+#include "asterisk/module.h"
+#include "asterisk/translate.h"
+#include "asterisk/say.h"
+#include "asterisk/features.h"
+#include "asterisk/musiconhold.h"
+#include "asterisk/cli.h"
+#include "asterisk/manager.h"
+#include "asterisk/config.h"
+#include "asterisk/monitor.h"
+#include "asterisk/utils.h"
+#include "asterisk/causes.h"
+#include "asterisk/astdb.h"
+#include "asterisk/app.h"
+
+static char *app = "FollowMe";
+static char *synopsis = 
+"Find-Me/Follow-Me.";
+static char *descrip = 
+"  FollowMe(followmeid|options):\n"
+"This application performs Find-Me/Follow-Me functionality for the caller\n"
+"as defined in the profile matching the <followmeid> parameter in\n"
+"followme.conf. If the specified <followmeid> profile doesn't exist in\n"
+"followme.conf, execution will be returned to the dialplan and call\n"
+"execution will continue at the next priority.\n\n"
+"  Options:\n"
+"    s    - Playback the incoming status message prior to starting the follow-me step(s)\n"
+"    a    - Record the caller's name so it can be announced to the callee on each step\n" 
+"    n    - Playback the unreachable status message if we've run out of steps to reach the\n"
+"           or the callee has elected not to be reachable.\n" 
+
+
+LOCAL_USER_DECL;
+
+struct number {
+	char number[512];	/*!< Phone Number(s) and/or Extension(s) */
+	long timeout;		/*!< Dial Timeout, if used. */
+	int order;		/*!< The order to dial in */
+	AST_LIST_ENTRY(number) entry; /*!< Next Number record */
+};
+
+struct ast_call_followme {
+	ast_mutex_t lock;
+	char name[AST_MAX_EXTENSION];	/*!< Name - FollowMeID */
+	char moh[AST_MAX_CONTEXT];	/*!< Music On Hold Class to be used */
+	char context[AST_MAX_CONTEXT];  /*!< Context to dial from */
+	unsigned int active;		/*!< Profile is active (1), or disabled (0). */
+	char takecall[20];		/*!< Digit mapping to take a call */
+	char nextindp[20];		/*!< Digit mapping to decline a call */
+	char callfromprompt[AST_CONFIG_MAX_PATH];
+	char norecordingprompt[AST_CONFIG_MAX_PATH];
+	char optionsprompt[AST_CONFIG_MAX_PATH];
+	char plsholdprompt[AST_CONFIG_MAX_PATH];
+	char statusprompt[AST_CONFIG_MAX_PATH];
+	char sorryprompt[AST_CONFIG_MAX_PATH];
+
+	AST_LIST_HEAD_NOLOCK(numbers, number) numbers;	   /*!< Head of the list of follow-me numbers */
+	AST_LIST_HEAD_NOLOCK(blnumbers, number) blnumbers; /*!< Head of the list of black-listed numbers */
+	AST_LIST_HEAD_NOLOCK(wlnumbers, number) wlnumbers; /*!< Head of the list of white-listed numbers */
+	AST_LIST_ENTRY(ast_call_followme) entry;           /*!< Next Follow-Me record */
+};
+
+struct fm_args {
+	struct ast_channel *chan;
+	char *mohclass;
+	AST_LIST_HEAD_NOLOCK(cnumbers, number) cnumbers;
+	int status;
+	char context[AST_MAX_CONTEXT];
+	char namerecloc[AST_MAX_CONTEXT];
+	struct ast_channel *outbound;
+	char takecall[20];		/*!< Digit mapping to take a call */
+	char nextindp[20];		/*!< Digit mapping to decline a call */
+	char callfromprompt[AST_CONFIG_MAX_PATH];
+	char norecordingprompt[AST_CONFIG_MAX_PATH];
+	char optionsprompt[AST_CONFIG_MAX_PATH];
+	char plsholdprompt[AST_CONFIG_MAX_PATH];
+	char statusprompt[AST_CONFIG_MAX_PATH];
+	char sorryprompt[AST_CONFIG_MAX_PATH];
+	struct ast_flags followmeflags;
+};
+
+struct findme_user {
+	struct ast_channel *ochan;
+	int state;
+	char dialarg[256];
+	char yn[10];
+	int ynidx; 
+	long digts;
+	int cleared;
+	AST_LIST_ENTRY(findme_user) entry;	
+};
+
+enum {
+	FOLLOWMEFLAG_STATUSMSG = (1 << 0),
+	FOLLOWMEFLAG_RECORDNAME = (1 << 1),
+	FOLLOWMEFLAG_UNREACHABLEMSG = (1 << 2)
+};
+
+AST_APP_OPTIONS(followme_opts, {
+	AST_APP_OPTION('s', FOLLOWMEFLAG_STATUSMSG ),
+	AST_APP_OPTION('a', FOLLOWMEFLAG_RECORDNAME ),
+	AST_APP_OPTION('n', FOLLOWMEFLAG_UNREACHABLEMSG ),
+});
+
+static int ynlongest = 0;
+static char toast[80];
+static time_t start_time, answer_time, end_time;
+
+static char *featuredigittostr;
+static int featuredigittimeout = 5000;		/*!< Feature Digit Timeout */
+static const char *defaultmoh = "default";    	/*!< Default Music-On-Hold Class */
+
+static char takecall[20] = "1", nextindp[20] = "2";
+static char callfromprompt[AST_CONFIG_MAX_PATH] = "followme/call-from";
+static char norecordingprompt[AST_CONFIG_MAX_PATH] = "followme/no-recording";
+static char optionsprompt[AST_CONFIG_MAX_PATH] = "followme/followme-options";
+static char plsholdprompt[AST_CONFIG_MAX_PATH] = "followme/pls-hold-while-try";
+static char statusprompt[AST_CONFIG_MAX_PATH] = "followme/followme-status";
+static char sorryprompt[AST_CONFIG_MAX_PATH] = "followme/followme-sorry";
+
+
+static AST_LIST_HEAD_STATIC(followmes, ast_call_followme);
+AST_LIST_HEAD_NOLOCK(findme_user_listptr, findme_user);
+
+static void free_numbers(struct ast_call_followme *f)
+{
+	/* Free numbers attached to the profile */
+	struct number *prev;
+
+	while ((prev = AST_LIST_REMOVE_HEAD(&f->numbers, entry)))
+		/* Free the number */
+		free(prev);
+	AST_LIST_HEAD_INIT_NOLOCK(&f->numbers);
+
+	while ((prev = AST_LIST_REMOVE_HEAD(&f->blnumbers, entry)))
+		/* Free the blacklisted number */
+		free(prev);
+	AST_LIST_HEAD_INIT_NOLOCK(&f->blnumbers);
+
+	while ((prev = AST_LIST_REMOVE_HEAD(&f->wlnumbers, entry)))
+		/* Free the whitelisted number */
+		free(prev);
+	AST_LIST_HEAD_INIT_NOLOCK(&f->wlnumbers);
+	
+}
+
+
+static struct ast_call_followme *alloc_profile(const char *fmname)
+{
+	struct ast_call_followme *f;
+
+	f = ast_calloc(1, sizeof(*f));
+	if (f) {
+		ast_mutex_init(&f->lock);
+		ast_copy_string(f->name, fmname, sizeof(f->name));
+		ast_copy_string(f->moh, "", sizeof(f->moh));
+		ast_copy_string(f->context, "", sizeof(f->context));
+		ast_copy_string(f->takecall, takecall, sizeof(f->takecall));
+		ast_copy_string(f->nextindp, nextindp, sizeof(f->nextindp));
+		ast_copy_string(f->callfromprompt, callfromprompt, sizeof(f->callfromprompt));
+		ast_copy_string(f->norecordingprompt, norecordingprompt, sizeof(f->norecordingprompt));
+		ast_copy_string(f->optionsprompt, optionsprompt, sizeof(f->optionsprompt));
+		ast_copy_string(f->plsholdprompt, plsholdprompt, sizeof(f->plsholdprompt));
+		ast_copy_string(f->statusprompt, statusprompt, sizeof(f->statusprompt));
+		ast_copy_string(f->sorryprompt, sorryprompt, sizeof(f->sorryprompt));
+		AST_LIST_HEAD_INIT_NOLOCK(&f->numbers);
+		AST_LIST_HEAD_INIT_NOLOCK(&f->blnumbers);
+		AST_LIST_HEAD_INIT_NOLOCK(&f->wlnumbers);
+	}
+	return f;
+}
+
+static void init_profile(struct ast_call_followme *f)
+{
+	f->active = 1;
+	ast_copy_string(f->moh, defaultmoh, sizeof(f->moh));
+}
+
+   
+   
+static void profile_set_param(struct ast_call_followme *f, const char *param, const char *val, int linenum, int failunknown)
+{
+
+	if (!strcasecmp(param, "musicclass") || !strcasecmp(param, "musiconhold") || !strcasecmp(param, "music")) 
+		ast_copy_string(f->moh, val, sizeof(f->moh));
+	else if (!strcasecmp(param, "context")) {
+		ast_copy_string(f->context, val, sizeof(f->context));
+	} else if (!strcasecmp(param, "takecall")) {
+		ast_copy_string(f->takecall, val, sizeof(f->takecall));
+	} else if (!strcasecmp(param, "declinecall")) {
+		ast_copy_string(f->nextindp, val, sizeof(f->nextindp));
+	} else if (!strcasecmp(param, "call-from-prompt")) {
+		ast_copy_string(f->callfromprompt, val, sizeof(f->callfromprompt));
+	} else if (!strcasecmp(param, "followme-recording-prompt")) {
+		ast_copy_string(f->norecordingprompt, val, sizeof(f->norecordingprompt));
+	} else if (!strcasecmp(param, "followme-options-prompt")) {
+		ast_copy_string(f->optionsprompt, val, sizeof(f->optionsprompt));
+	} else if (!strcasecmp(param, "followme-pls-hold-prompt")) {
+		ast_copy_string(f->plsholdprompt, val, sizeof(f->plsholdprompt));
+	} else if (!strcasecmp(param, "followme-status-prompt")) {
+		ast_copy_string(f->statusprompt, val, sizeof(f->statusprompt));
+	} else if (!strcasecmp(param, "followme-sorry-prompt")) {
+		ast_copy_string(f->sorryprompt, val, sizeof(f->sorryprompt));
+	} else if (failunknown) {
+		if (linenum >= 0)
+			ast_log(LOG_WARNING, "Unknown keyword in profile '%s': %s at line %d of followme.conf\n", f->name, param, linenum);
+		else
+			ast_log(LOG_WARNING, "Unknown keyword in profile '%s': %s\n", f->name, param);
+	}
+}
+
+static struct number *create_followme_number(char *number, int timeout, int numorder)
+{
+	struct number *cur;
+	char *tmp;
+	
+	/* Add a new number */
+
+	cur = ast_calloc(1, sizeof(*cur));
+
+	if (cur) {
+		cur->timeout = timeout;
+		if (strchr(number, ',')) { 
+			tmp = strchr(number, ',');
+			*tmp = '\0';
+		}
+		ast_copy_string(cur->number, number, sizeof(cur->number));
+		cur->order = numorder;
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Created a number, %s, order of , %d, with a timeout of %ld.\n", cur->number, cur->order, cur->timeout);
+	}
+
+	return cur;
+}
+
+static int reload_followme(void)
+{
+	struct ast_call_followme *f;
+	struct ast_config *cfg;
+	char *cat, *tmp;
+	struct ast_variable *var;
+	struct number *cur, *nm;
+	int new, idx;
+	char numberstr[90];
+	int timeout;
+	char *timeoutstr;
+	int numorder;	
+	char *takecallstr;
+	char *declinecallstr;
+	char *tmpstr;
+
+	cfg = ast_config_load("followme.conf");
+	if (!cfg) {
+		ast_log(LOG_WARNING, "No follow me config file (followme.conf), so no follow me\n");
+		return 0;
+	}
+
+	AST_LIST_LOCK(&followmes);
+
+	/* Reset Global Var Values */
+	featuredigittimeout = 5000;
+
+	/* Mark all profiles as inactive for the moment */
+	AST_LIST_TRAVERSE(&followmes, f, entry) {
+		f->active = 0;
+	}
+	featuredigittostr = ast_variable_retrieve(cfg, "general", "featuredigittimeout");
+	
+	if (!ast_strlen_zero(featuredigittostr)) 
+		if (!scanf("%d", &featuredigittimeout))
+			featuredigittimeout = 5000;
+
+	takecallstr = ast_variable_retrieve(cfg, "general", "takecall");
+	if (!ast_strlen_zero(takecallstr))
+		ast_copy_string(takecall, takecallstr, sizeof(takecall));
+	
+	declinecallstr = ast_variable_retrieve(cfg, "general", "declinecall");
+	if (!ast_strlen_zero(declinecallstr))
+		ast_copy_string(nextindp, declinecallstr, sizeof(nextindp));
+
+	tmpstr = ast_variable_retrieve(cfg, "general", "call-from-prompt");
+	if (!ast_strlen_zero(tmpstr))
+		ast_copy_string(callfromprompt, tmpstr, sizeof(callfromprompt));
+
+	tmpstr = ast_variable_retrieve(cfg, "general", "followme-norecording-prompt");
+	if (!ast_strlen_zero(tmpstr))
+		ast_copy_string(norecordingprompt, tmpstr, sizeof(norecordingprompt));
+
+	tmpstr = ast_variable_retrieve(cfg, "general", "followme-options-prompt");
+	if (!ast_strlen_zero(tmpstr))
+		ast_copy_string(optionsprompt, tmpstr, sizeof(optionsprompt));
+
+	tmpstr = ast_variable_retrieve(cfg, "general", "followme-pls-hold-prompt");
+	if (!ast_strlen_zero(tmpstr))
+		ast_copy_string(plsholdprompt, tmpstr, sizeof(plsholdprompt));
+
+	tmpstr = ast_variable_retrieve(cfg, "general", "followme-status-prompt");
+	if (!ast_strlen_zero(tmpstr))
+		ast_copy_string(statusprompt, tmpstr, sizeof(statusprompt));
+
+	tmpstr = ast_variable_retrieve(cfg, "general", "followme-sorry-prompt");
+	if (!ast_strlen_zero(tmpstr))
+		ast_copy_string(sorryprompt, tmpstr, sizeof(sorryprompt));
+
+	/* Chug through config file */
+	cat = ast_category_browse(cfg, NULL);
+	while(cat) {
+		/* Define a new profile */
+		/* Look for an existing one */
+		AST_LIST_TRAVERSE(&followmes, f, entry) {
+			if (!strcasecmp(f->name, cat))
+				break;
+		}
+		if (option_debug)
+			ast_log(LOG_DEBUG, "New profile %s.\n", cat);
+		if (!f) {
+			/* Make one then */
+			f = alloc_profile(cat);
+			new = 1;
+		} else
+			new = 0;
+	
+		if (f) {
+			if (!new)
+				ast_mutex_lock(&f->lock);
+			/* Re-initialize the profile */
+			init_profile(f);
+			free_numbers(f);
+			var = ast_variable_browse(cfg, cat);
+			while(var) {
+				if (!strcasecmp(var->name, "number")) {
+					/* Add a new number */
+					ast_copy_string(numberstr, var->value, sizeof(numberstr));
+					if ((tmp = strchr(numberstr, ','))) {
+						*tmp = '\0';
+						tmp++;
+						timeoutstr = ast_strdupa(tmp);
+						if ((tmp = strchr(timeoutstr, ','))) {
+							*tmp = '\0';
+							tmp++;
+							numorder = atoi(tmp);
+							if (numorder < 0)
+								numorder = 0;
+						} else 
+							numorder = 0;
+						timeout = atoi(timeoutstr);
+						if (timeout < 0) 
+							timeout = 25;
+					} else {
+						timeout = 25;
+						numorder = 0;
+					}
+
+					if (!numorder) {	
+						idx = 1;
+						AST_LIST_TRAVERSE(&f->numbers, nm, entry) 
+							idx++;
+						numorder = idx;
+					}
+					cur = create_followme_number(numberstr, timeout, numorder);
+					AST_LIST_INSERT_TAIL(&f->numbers, cur, entry);
+				} else {
+					profile_set_param(f, var->name, var->value, var->lineno, 1);
+					if (option_debug)
+						ast_log(LOG_DEBUG, "Logging parameter %s with value %s from lineno %d\n", var->name, var->value, var->lineno);
+				}
+				var = var->next;
+			} /* End while(var) loop */
+
+			if (!new) 
+				ast_mutex_unlock(&f->lock);
+			if (new) {
+				AST_LIST_INSERT_HEAD(&followmes, f, entry);
+			}
+		}
+		cat = ast_category_browse(cfg, cat);
+	}
+	ast_config_destroy(cfg);
+
+	AST_LIST_UNLOCK(&followmes);
+
+	return 1;
+}
+
+static void clear_caller(struct findme_user *tmpuser)
+{
+	struct ast_channel *outbound;
+	
+	if (tmpuser && tmpuser->ochan && tmpuser->state >= 0) {
+		outbound = tmpuser->ochan;
+		if (!outbound->cdr) {
+			outbound->cdr = ast_cdr_alloc();
+			if (outbound->cdr)
+				ast_cdr_init(outbound->cdr, outbound);
+		}
+		if (outbound->cdr) {
+			char tmp[256];
+			snprintf(tmp, 256, "%s/%s", "Local", tmpuser->dialarg);
+			ast_cdr_setapp(outbound->cdr,"FollowMe",tmp);
+			ast_cdr_update(outbound);
+			ast_cdr_start(outbound->cdr);
+			ast_cdr_end(outbound->cdr);
+			/* If the cause wasn't handled properly */
+			if (ast_cdr_disposition(outbound->cdr,outbound->hangupcause))
+				ast_cdr_failed(outbound->cdr);
+		} else
+			ast_log(LOG_WARNING, "Unable to create Call Detail Record\n");
+		ast_hangup(tmpuser->ochan);
+	}
+
+}
+
+static void clear_calling_tree(struct findme_user_listptr *findme_user_list) 
+{
+	struct findme_user *tmpuser;
+	
+	AST_LIST_TRAVERSE(findme_user_list, tmpuser, entry) {
+		clear_caller(tmpuser);
+		tmpuser->cleared = 1;
+	}
+	
+}
+
+
+
+static struct ast_channel *wait_for_winner(struct findme_user_listptr *findme_user_list, struct number *nm, struct ast_channel *caller, char *namerecloc, int *status, struct fm_args *tpargs) 
+{
+	struct ast_channel *watchers[256];
+	int pos;
+	struct ast_channel *winner;
+	struct ast_frame *f;
+	int ctstatus;
+	int dg;
+	struct findme_user *tmpuser;
+	int *to = ast_calloc(1, sizeof(*to));
+	int livechannels = 0;
+	int tmpto;
+	long totalwait = 0, wtd, towas = *to;
+	char *callfromname;
+	char *pressbuttonname;
+
+	/* ------------ wait_for_winner_channel start --------------- */ 
+
+	callfromname = ast_strdupa(tpargs->callfromprompt);
+	pressbuttonname = ast_strdupa(tpargs->optionsprompt);	
+
+	if (!AST_LIST_EMPTY(findme_user_list))
+	{
+		if (!caller) {
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Original caller hungup. Cleanup.\n");
+			clear_calling_tree(findme_user_list);
+			free(to);
+			return NULL;
+		}
+		ctstatus = 0;
+		totalwait = nm->timeout * 1000;
+		wtd = 0;
+		while (!ctstatus) {
+			*to = 1000;
+			pos = 1; 
+			livechannels = 0;
+			watchers[0] = caller;
+		
+			dg = 0;	
+			winner = NULL;	
+			AST_LIST_TRAVERSE(findme_user_list, tmpuser, entry) {
+				if (tmpuser->state >= 0 && tmpuser->ochan) {
+					if (tmpuser->state == 3) {
+						tmpuser->digts += (towas - wtd);
+					}
+					if (tmpuser->digts && (tmpuser->digts > featuredigittimeout)) {
+						if (option_verbose > 2)
+							ast_verbose(VERBOSE_PREFIX_3 "We've been waiting for digits longer than we should have.\n");
+						if (!ast_strlen_zero(namerecloc)) {
+							tmpuser->state = 1;
+							tmpuser->digts = 0;
+							if (!ast_streamfile(tmpuser->ochan, callfromname, tmpuser->ochan->language)) {
+								ast_sched_runq(tmpuser->ochan->sched);
+							} else {
+								ast_log(LOG_WARNING, "Unable to playback %s.\n", callfromname);
+								free(to);
+								return NULL;
+							}							
+						} else {
+							tmpuser->state = 2;
+							tmpuser->digts = 0;
+							if (!ast_streamfile(tmpuser->ochan, tpargs->norecordingprompt, tmpuser->ochan->language))
+								ast_sched_runq(tmpuser->ochan->sched);
+							else {
+								ast_log(LOG_WARNING, "Unable to playback %s.\n", tpargs->norecordingprompt);
+								free(to);
+								return NULL;
+							}
+						}
+					}
+					if (tmpuser->ochan->stream) {
+						ast_sched_runq(tmpuser->ochan->sched);
+						tmpto = ast_sched_wait(tmpuser->ochan->sched);
+						if (tmpto > 0 && tmpto < *to)
+							*to = tmpto;
+						else if (tmpto < 0 && !tmpuser->ochan->timingfunc) {
+							ast_stopstream(tmpuser->ochan);
+							if (tmpuser->state == 1) {
+								if (option_verbose > 2)
+									ast_verbose(VERBOSE_PREFIX_3 "Playback of the call-from file appears to be done.\n");
+								if (!ast_streamfile(tmpuser->ochan, namerecloc, tmpuser->ochan->language)) {
+									tmpuser->state = 2;
+								} else {
+									ast_log(LOG_NOTICE, "Unable to playback %s. Maybe the caller didn't record their name?\n", namerecloc);
+									memset(tmpuser->yn, 0, sizeof(tmpuser->yn));
+									tmpuser->ynidx = 0;
+									if (!ast_streamfile(tmpuser->ochan, pressbuttonname, tmpuser->ochan->language))
+										tmpuser->state = 3;
+									else {
+										ast_log(LOG_WARNING, "Unable to playback %s.\n", pressbuttonname);
+										free(to);
+										return NULL;
+									} 
+								}
+							} else if (tmpuser->state == 2) {
+								if (option_verbose > 2)
+									ast_verbose(VERBOSE_PREFIX_3 "Playback of name file appears to be done.\n");
+								memset(tmpuser->yn, 0, sizeof(tmpuser->yn));
+								tmpuser->ynidx = 0;
+								if (!ast_streamfile(tmpuser->ochan, pressbuttonname, tmpuser->ochan->language)) {
+									tmpuser->state = 3;
+									
+								} else {
+									ast_log(LOG_WARNING, "Unable to playback %s.\n", pressbuttonname);										  free(to);
+									return NULL;
+								} 
+							} else if (tmpuser->state == 3) {
+								if (option_verbose > 2)
+									ast_verbose(VERBOSE_PREFIX_3 "Playback of the next step file appears to be done.\n");
+								tmpuser->digts = 0;
+							}
+						}
+					}
+				watchers[pos++] = tmpuser->ochan;
+				livechannels++;
+				}
+			}
+
+			tmpto = *to;
+			if (*to < 0) {
+				*to = 1000;
+				tmpto = 1000;
+			}
+			towas = *to;
+			winner = ast_waitfor_n(watchers, pos, to);
+			tmpto -= *to;
+			totalwait -= tmpto;
+			wtd = *to;	
+			if (totalwait <= 0) {
+				if (option_verbose > 2)	
+					ast_verbose(VERBOSE_PREFIX_3 "We've hit our timeout for this step. Drop everyone and move on to the next one. %ld\n", totalwait);
+				clear_calling_tree(findme_user_list);
+				free(to);
+				return NULL;
+			}
+			if (winner) {
+				/* Need to find out which channel this is */
+				dg = 0;
+				while ((winner != watchers[dg]) && (dg < 256))
+					dg++;
+				AST_LIST_TRAVERSE(findme_user_list, tmpuser, entry)
+					if (tmpuser->ochan == winner)
+						break;
+				f = ast_read(winner);
+				if (f) {
+					if (f->frametype == AST_FRAME_CONTROL) {
+						switch(f->subclass) {
+						case AST_CONTROL_HANGUP:
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "%s received a hangup frame.\n", winner->name);
+							if (dg == 0) {
+								if (option_verbose > 2)
+									ast_verbose( VERBOSE_PREFIX_3 "The calling channel hungup. Need to drop everyone else.\n");
+								clear_calling_tree(findme_user_list);
+								ctstatus = -1;
+							}
+							break;
+						case AST_CONTROL_ANSWER:
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "%s answered %s\n", winner->name, caller->name);
+							/* If call has been answered, then the eventual hangup is likely to be normal hangup */ 
+							winner->hangupcause = AST_CAUSE_NORMAL_CLEARING;
+							caller->hangupcause = AST_CAUSE_NORMAL_CLEARING;
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "Starting playback of %s\n", callfromname);
+							if (dg > 0) {
+								if (!ast_strlen_zero(namerecloc)) {
+									if (!ast_streamfile(winner, callfromname, winner->language)) {
+										ast_sched_runq(winner->sched);
+										tmpuser->state = 1;
+									} else {
+										ast_log(LOG_WARNING, "Unable to playback %s.\n", callfromname);
+										free(to);
+										return NULL;
+									}				
+								} else {			
+									tmpuser->state = 2;
+									if (!ast_streamfile(tmpuser->ochan, tpargs->norecordingprompt, tmpuser->ochan->language))
+										ast_sched_runq(tmpuser->ochan->sched);
+									else {
+										ast_log(LOG_WARNING, "Unable to playback %s.\n", tpargs->norecordingprompt);
+										free(to);
+										return NULL;
+									}
+								}
+							}
+							break;
+						case AST_CONTROL_BUSY:
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "%s is busy\n", winner->name);
+							break;
+						case AST_CONTROL_CONGESTION:
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "%s is circuit-busy\n", winner->name);
+							break;
+						case AST_CONTROL_RINGING:
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "%s is ringing\n", winner->name);
+							break;
+						case AST_CONTROL_PROGRESS:
+							if (option_verbose > 2)
+								ast_verbose ( VERBOSE_PREFIX_3 "%s is making progress passing it to %s\n", winner->name,caller->name);
+							break;
+						case AST_CONTROL_VIDUPDATE:
+							if (option_verbose > 2)
+								ast_verbose ( VERBOSE_PREFIX_3 "%s requested a video update, passing it to %s\n", winner->name,caller->name);
+							break;
+						case AST_CONTROL_PROCEEDING:
+							if (option_verbose > 2)
+								ast_verbose ( VERBOSE_PREFIX_3 "%s is proceeding passing it to %s\n", winner->name,caller->name);
+							break;
+						case AST_CONTROL_HOLD:
+							if (option_verbose > 2)
+								ast_verbose(VERBOSE_PREFIX_3 "Call on %s placed on hold\n", winner->name);
+							break;
+						case AST_CONTROL_UNHOLD:
+							if (option_verbose > 2)
+								ast_verbose(VERBOSE_PREFIX_3 "Call on %s left from hold\n", winner->name);
+							break;
+						case AST_CONTROL_OFFHOOK:
+						case AST_CONTROL_FLASH:
+							/* Ignore going off hook and flash */
+							break;
+						case -1:
+							if (option_verbose > 2)
+								ast_verbose( VERBOSE_PREFIX_3 "%s stopped sounds\n", winner->name);
+							break;
+						default:
+							if (option_debug)
+								ast_log(LOG_DEBUG, "Dunno what to do with control type %d\n", f->subclass);
+							break;
+						}
+					} 
+					if (tmpuser && tmpuser->state == 3 && f->frametype == AST_FRAME_DTMF) {
+						if (winner->stream)
+							ast_stopstream(winner);
+							tmpuser->digts = 0;
+						if (option_debug)
+							ast_log(LOG_DEBUG, "DTMF received: %c\n",(char) f->subclass);
+						tmpuser->yn[tmpuser->ynidx] = (char) f->subclass;
+						tmpuser->ynidx++;
+						if (option_debug)
+							ast_log(LOG_DEBUG, "DTMF string: %s\n", tmpuser->yn);
+						if (tmpuser->ynidx >= ynlongest) {
+							if (option_debug)
+								ast_log(LOG_DEBUG, "reached longest possible match - doing evals\n");
+							if (!strcmp(tmpuser->yn, tpargs->takecall)) {
+								if (option_debug)
+									ast_log(LOG_DEBUG, "Match to take the call!\n");
+								free(to);
+								return tmpuser->ochan;	
+							}
+							if (!strcmp(tmpuser->yn, tpargs->nextindp)) {
+								if (option_debug)
+									ast_log(LOG_DEBUG, "Next in dial plan step requested.\n");
+								*status = 1;
+								free(to);
+								return NULL;
+							}	
+
+						}
+					}
+					
+					ast_frfree(f);
+				} else {
+					if (winner) {
+						if (option_debug)
+							ast_log(LOG_DEBUG, "we didn't get a frame. hanging up. dg is %d\n",dg);					      
+						if (!dg) {
+							clear_calling_tree(findme_user_list);
+							free(to);
+							return NULL;
+						} else {
+							tmpuser->state = -1;
+						 	ast_hangup(winner);  
+							livechannels--;
+							if (option_debug)
+								ast_log(LOG_DEBUG, "live channels left %d\n", livechannels);
+							if (!livechannels) {
+								if (option_verbose > 2)
+									ast_verbose(VERBOSE_PREFIX_3 "no live channels left. exiting.\n");
+								free(to);
+								return NULL;
+							}
+						}
+					}
+				}					
+				
+			} else
+				if (option_debug)
+					ast_log(LOG_DEBUG, "timed out waiting for action\n");
+		}
+		
+	}
+	else
+	{
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "couldn't reach at this number.\n");
+	}
+	
+	/* --- WAIT FOR WINNER NUMBER END! -----------*/
+	free(to);
+	return NULL;
+}
+
+static void findmeexec(void *args)
+{
+	struct fm_args *tpargs;
+	struct number *nm;
+	struct ast_channel *outbound;
+	struct ast_channel *caller;
+	struct ast_channel *winner = NULL;
+	char dialarg[512];
+	int dg, idx;
+	char *rest, *number;
+	struct findme_user *tmpuser;
+	struct findme_user *fmuser;
+	struct findme_user *headuser;
+	struct findme_user_listptr *findme_user_list;
+	int status;
+
+	findme_user_list = ast_calloc(1, sizeof(*findme_user_list));		
+	AST_LIST_HEAD_INIT_NOLOCK(findme_user_list);
+
+	tpargs = (struct fm_args *)args;
+			
+	if (!tpargs->chan) 
+		return;
+	
+
+	/* We're going to figure out what the longest possible string of digits to collect is */
+	ynlongest = 0;
+	if (strlen(tpargs->takecall) > ynlongest)
+		ynlongest = strlen(tpargs->takecall);
+	if (strlen(tpargs->nextindp) > ynlongest)
+		ynlongest = strlen(tpargs->nextindp);
+
+	idx = 1;
+	caller = tpargs->chan;
+	AST_LIST_TRAVERSE(&tpargs->cnumbers, nm, entry)
+		if (nm->order == idx)
+			break;
+
+	while (nm) {
+
+		if (option_debug)	
+			ast_log(LOG_DEBUG, "Number %s timeout %ld\n",nm->number,nm->timeout);
+		time(&start_time);
+
+		number = ast_strdupa(nm->number);
+		if (option_debug)
+			ast_log(LOG_DEBUG, "examining %s\n", number);
+		do {
+			rest = strchr(number, '&');
+			if (rest) {
+				*rest = 0;
+				rest++;
+			}
+
+			if (!strcmp(tpargs->context, ""))
+				sprintf(dialarg, "%s", number);
+			else
+				sprintf(dialarg, "%s@%s", number, tpargs->context);
+					
+			tmpuser = ast_calloc(1, sizeof(*tmpuser));
+			if (!tmpuser) {
+				ast_log(LOG_WARNING, "Out of memory!\n");
+				return;
+			}
+					
+			outbound = ast_request("Local", ast_best_codec(caller->nativeformats), dialarg, &dg);
+			if (outbound) {
+				ast_set_callerid(outbound, caller->cid.cid_num, caller->cid.cid_name, caller->cid.cid_num);
+				ast_channel_inherit_variables(tpargs->chan, outbound);
+				if (option_verbose > 2)
+					ast_verbose(VERBOSE_PREFIX_3 "calling %s\n", dialarg);
+				if (!ast_call(outbound,dialarg,0)) {
+					tmpuser->ochan = outbound;
+					tmpuser->state = 0;
+					tmpuser->cleared = 0;
+					ast_copy_string(tmpuser->dialarg, dialarg, sizeof(dialarg));
+					AST_LIST_INSERT_TAIL(findme_user_list, tmpuser, entry);
+				} else {
+					if (option_verbose > 2) 
+						ast_verbose(VERBOSE_PREFIX_3 "couldn't reach at this number.\n"); 
+					if (outbound) {
+						if (!outbound->cdr) {
+							outbound->cdr = ast_cdr_alloc();
+						}
+						if (outbound->cdr) {
+							ast_cdr_init(outbound->cdr, outbound);
+							char tmp[256];
+							snprintf(tmp, 256, "%s/%s", "Local", dialarg);
+							ast_cdr_setapp(outbound->cdr,"FollowMe",tmp);
+							ast_cdr_update(outbound);
+							ast_cdr_start(outbound->cdr);
+							ast_cdr_end(outbound->cdr);
+							/* If the cause wasn't handled properly */
+							if (ast_cdr_disposition(outbound->cdr,outbound->hangupcause))
+								ast_cdr_failed(outbound->cdr);
+						} else {
+							ast_log(LOG_WARNING, "Unable to create Call Detail Record\n");
+							ast_hangup(outbound);
+							outbound = NULL;
+						}
+					}
+						
+				}
+			} else 
+				ast_log(LOG_WARNING, "Unable to allocate a channel for Local/%s cause: %s\n", dialarg, ast_cause2str(dg));
+					
+			number = rest;
+		} while (number);
+				
+		status = 0;	
+		if (!AST_LIST_EMPTY(findme_user_list))
+			winner = wait_for_winner(findme_user_list, nm, caller, tpargs->namerecloc, &status, tpargs);
+		
+					
+		AST_LIST_TRAVERSE_SAFE_BEGIN(findme_user_list, fmuser, entry) {
+			if (!fmuser->cleared && fmuser->ochan != winner)
+				clear_caller(fmuser);
+			AST_LIST_REMOVE_CURRENT(findme_user_list, entry);
+			free(fmuser);
+		}
+		AST_LIST_TRAVERSE_SAFE_END
+		fmuser = NULL;
+		tmpuser = NULL;
+		headuser = NULL;	
+		if (winner)
+			break;
+
+		if (!caller) {
+			tpargs->status = 1;
+			return;	
+		}
+
+		idx++;
+		AST_LIST_TRAVERSE(&tpargs->cnumbers, nm, entry)
+			if (nm->order == idx)
+				break;
+
+	}
+	free(findme_user_list);
+	if (!winner) 
+		tpargs->status = 1;
+	else {
+		tpargs->status = 100;
+		tpargs->outbound = winner;
+	}
+
+	
+	return;
+		
+}
+
+static int app_exec(struct ast_channel *chan, void *data)
+{
+	struct fm_args targs;
+	struct ast_bridge_config config;
+	struct ast_call_followme *f;
+	struct number *nm, *newnm;
+	int res = 0;
+	struct localuser *u;
+	char *argstr;
+	char namerecloc[255];
+	int duration = 0;
+	struct ast_channel *caller;
+	struct ast_channel *outbound;
+	
+	AST_DECLARE_APP_ARGS(args,
+		AST_APP_ARG(followmeid);
+		AST_APP_ARG(options);
+	);
+	
+	if (!(argstr = ast_strdupa((char *)data))) {
+		ast_log(LOG_ERROR, "Out of memory!\n");
+		return -1;
+	}
+
+	if (!data) {
+		ast_log(LOG_WARNING, "%s requires an argument (followmeid)\n",app);
+		return -1;
+	}
+
+	LOCAL_USER_ADD(u);
+
+	AST_STANDARD_APP_ARGS(args, argstr);
+
+	if (!ast_strlen_zero(args.followmeid)) 
+	
+			AST_LIST_LOCK(&followmes);
+			AST_LIST_TRAVERSE(&followmes, f, entry) {
+				if (!strcasecmp(f->name, args.followmeid) && (f->active))
+					break;
+			}
+			AST_LIST_UNLOCK(&followmes);
+
+			if (option_debug)
+				ast_log(LOG_DEBUG, "New profile %s.\n", args.followmeid);
+			if (!f)
+			{ 
+				ast_log(LOG_WARNING, "Profile requested, %s, not found in the configuration.", args.followmeid);
+				res = -1;
+			}
+			else
+			{
+	
+				/* XXX TODO: Reinsert the db check value to see whether or not follow-me is on or off */
+
+
+				if (args.options) {
+					ast_app_parse_options(followme_opts, &targs.followmeflags, NULL, args.options);
+				}
+
+				/* Lock the profile lock and copy out everything we need to run with before unlocking it again */
+				ast_mutex_lock(&f->lock);
+				targs.mohclass = ast_strdupa(f->moh);
+				ast_copy_string(targs.context, f->context, sizeof(targs.context));
+				ast_copy_string(targs.takecall, f->takecall, sizeof(targs.takecall));
+				ast_copy_string(targs.nextindp, f->nextindp, sizeof(targs.nextindp));
+				ast_copy_string(targs.callfromprompt, f->callfromprompt, sizeof(targs.callfromprompt));
+				ast_copy_string(targs.norecordingprompt, f->norecordingprompt, sizeof(targs.norecordingprompt));
+				ast_copy_string(targs.optionsprompt, f->optionsprompt, sizeof(targs.optionsprompt));
+				ast_copy_string(targs.plsholdprompt, f->plsholdprompt, sizeof(targs.plsholdprompt));
+				ast_copy_string(targs.statusprompt, f->statusprompt, sizeof(targs.statusprompt));
+				ast_copy_string(targs.sorryprompt, f->sorryprompt, sizeof(targs.sorryprompt));
+				/* Copy the numbers we're going to use into another list in case the master list should get modified 
+				   (and locked) while we're trying to do a follow-me */
+				AST_LIST_HEAD_INIT_NOLOCK(&targs.cnumbers);
+				AST_LIST_TRAVERSE(&f->numbers, nm, entry) {
+					newnm = create_followme_number(nm->number, nm->timeout, nm->order);
+					AST_LIST_INSERT_TAIL(&targs.cnumbers, newnm, entry);
+				}
+				ast_mutex_unlock(&f->lock);
+
+				if (targs.followmeflags.flags & FOLLOWMEFLAG_STATUSMSG) 
+					ast_stream_and_wait(chan, targs.statusprompt, chan->language, "");
+
+				snprintf(namerecloc,sizeof(namerecloc),"%s/followme.%s",ast_config_AST_SPOOL_DIR,chan->uniqueid);
+				duration = 5;
+
+				if (targs.followmeflags.flags & FOLLOWMEFLAG_RECORDNAME) 
+					if (ast_play_and_record(chan, "vm-rec-name", namerecloc, 5, "sln", &duration, 128, 0, NULL) < 0)
+						goto outrun;
+
+				/* The following call looks like we're going to playback the file, but we're actually	*/
+				/* just checking to see if we *can* play it. 						*/
+				if (ast_streamfile(chan, namerecloc, chan->language))
+					ast_copy_string(namerecloc, "", sizeof(namerecloc));					
+				else
+					ast_stopstream(chan);
+
+				if (ast_streamfile(chan, targs.plsholdprompt, chan->language))
+					goto outrun;
+				if (ast_waitstream(chan, "") < 0)
+					goto outrun;
+				if (!strcmp(targs.mohclass, ""))
+					ast_moh_start(chan, NULL);
+				else
+					ast_moh_start(chan, targs.mohclass);
+
+
+				targs.status = 0;
+				targs.chan = chan;
+
+				ast_copy_string(targs.namerecloc, namerecloc, sizeof(targs.namerecloc));
+
+				findmeexec(&targs);		
+				
+				AST_LIST_TRAVERSE_SAFE_BEGIN(&targs.cnumbers, nm, entry)	{
+					AST_LIST_REMOVE_CURRENT(&targs.cnumbers, entry);
+					free(nm);
+				}
+				AST_LIST_TRAVERSE_SAFE_END
+	
+				if (!ast_strlen_zero(namerecloc))
+					unlink(namerecloc);	
+
+				if (targs.status != 100)
+				{
+					ast_moh_stop(chan);
+					if (targs.followmeflags.flags & FOLLOWMEFLAG_UNREACHABLEMSG) 
+						ast_stream_and_wait(chan, targs.sorryprompt, chan->language, "");
+					res = 0;
+				}
+				else
+				{
+							
+					caller = chan;
+					outbound = targs.outbound;
+					/* Bridge the two channels. */
+
+					memset(&config,0,sizeof(struct ast_bridge_config));
+					ast_set_flag(&(config.features_callee), AST_FEATURE_REDIRECT);
+					ast_set_flag(&(config.features_callee), AST_FEATURE_AUTOMON);
+					ast_set_flag(&(config.features_caller), AST_FEATURE_AUTOMON);
+				
+					ast_moh_stop(caller);
+					/* Be sure no generators are left on it */
+					ast_deactivate_generator(caller);
+					/* Make sure channels are compatible */
+					res = ast_channel_make_compatible(caller, outbound);
+					if (res < 0) {
+						ast_log(LOG_WARNING, "Had to drop call because I couldn't make %s compatible with %s\n", caller->name, outbound->name);
+						ast_hangup(outbound);
+						goto outrun;
+					}
+					time(&answer_time);
+					res = ast_bridge_call(caller,outbound,&config);
+					time(&end_time);
+					snprintf(toast, sizeof(toast), "%ld", (long)(end_time - start_time));
+					pbx_builtin_setvar_helper(caller, "DIALEDTIME", toast);
+					snprintf(toast, sizeof(toast), "%ld", (long)(end_time - answer_time));
+					pbx_builtin_setvar_helper(caller, "ANSWEREDTIME", toast);
+					if (outbound)
+						ast_hangup(outbound);
+					res = 1;
+					
+				}
+				
+			}
+	outrun:
+	
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int unload_module(void *mod)
+{
+	struct ast_call_followme *f;
+	/* Free Memory. Yeah! I'm free! */
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&followmes, f, entry) {
+		free_numbers(f);
+		AST_LIST_REMOVE_CURRENT(&followmes, entry);
+		free(f);
+	}
+	AST_LIST_TRAVERSE_SAFE_END
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+static int load_module(void *mod)
+{
+	reload_followme();
+	return ast_register_application(app, app_exec, synopsis, descrip);
+}
+
+static const char *description(void)
+{
+	return "Find-Me/Follow-Me Application";
+}
+
+static int reload(void *mod)
+{
+	reload_followme();
+	return 0;	
+}
+
+static const char *key(void)
+{
+	return ASTERISK_GPL_KEY;
+}
+
+STD_MOD(MOD_1, reload, NULL, NULL);



From solid-pbx-svn-admin at lists.berlios.de  Sun Jun 18 23:54:29 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sun, 18 Jun 2006 23:54:29 +0200
Subject: [solid-pbx-svn] r278 - trunk/configs
Message-ID: <200606182154.k5ILsT2Z016407@sheep.berlios.de>

Author: casper2
Date: 2006-06-18 23:54:29 +0200 (Sun, 18 Jun 2006)
New Revision: 278

Added:
   trunk/configs/followme.conf.sample
Log:
Add missing file

Added: trunk/configs/followme.conf.sample
===================================================================
--- trunk/configs/followme.conf.sample	2006-06-18 21:52:07 UTC (rev 277)
+++ trunk/configs/followme.conf.sample	2006-06-18 21:54:29 UTC (rev 278)
@@ -0,0 +1,86 @@
+; Find-Me / Follow-Me Configuration File
+[general]
+;
+featuredigittimeout=>5000
+; The number of ms to wait for a digit input for the callee on whether to take the call or
+; not before we consider them "done" entering digits.
+;
+takecall=>1
+; The global default keypress for the callee to take taking the current call. This can be
+; a single digit or multiple digits. Default is "1".
+;
+declinecall=>2
+; The global default keypress for the callee to decline taking the current call. This can
+; be a single digit or multiple digits. Default is "2".
+;
+call-from-prompt=>followme/call-from
+; The global default for the 'Incoming call from' message.
+;
+followme-norecording-prompt=>followme/no-recording
+; The global default for the 'You have an incoming call' message when the caller elects
+; not to leave their name or the option isn't set for them to do so.
+;
+followme-options-prompt=>followme/followme-options
+; The global default for the 'Press 1 to accept this call or press 2 to decline it' message.
+;
+followme-pls-hold-prompt=>followme/pls-hold-while-try
+; The global default for 'Please hold while we try and connect your call' message.
+;
+followme-status-prompt=>followme/followme-status
+; The global default for 'The party you're calling isn't at their desk' message.
+;
+followme-sorry-prompt=>followme/followme-sorry  
+; The global default for 'I'm sorry, but we were unable to locate your party' message.
+;
+;
+[default]
+musicclass=>default
+; The moh class that should be used for the caller while they are waiting to be connected.
+context=>default
+; The context to dial the numbers from
+number=>01233456,25
+; The a follow-me number to call. The format is:
+; number=> <number to call[&2nd #[&3rd #]]> [, <timeout value in seconds> [, <order in follow-me>] ]
+; You can specify as many of these numbers as you like. They will be dialed in the 
+; order that you specify them in the config file OR as specified with the order field
+; on the number prompt. As you can see from the example, forked dialing of multiple 
+; numbers in the same step is supported with this application if you'd like to dial
+; multiple numbers in the same followme step.
+; It's also important to note that the timeout value is not the same
+; as the timeout value you would use in app_dial. This timeout value is the amount of
+; time allowed between the time the dialing step starts and the callee makes a choice
+; on whether to take the call or not. That being the case, you may want to account for
+; this time, and make this timeout longer than a timeout you might specify in app_dial.
+takecall=>1
+; The keypress for the callee to take taking the current call. This can be
+; a single digit or multiple digits. Default is the global default.
+;
+declinecall=>2
+; The keypress for the callee to decline taking the current call. This can
+; be a single digit or multiple digits. Default is the global default.
+;
+call-from-prompt=>followme/call-from
+; The 'Incoming call from' message prompt. Default is the global default.
+;
+followme-norecording-prompt=>followme/no-recording
+; The 'You have an incoming call' message prompt when the caller elects
+; not to leave their name or the option isn't set for them to do so. Default
+; is the global default.
+;
+followme-options-prompt=>followme/followme-options
+; The 'Press 1 to accept this call or press 2 to decline it' message prompt.
+; Default is the global default.
+;
+followme-pls-hold-prompt=>followme/pls-hold-while-try
+; The 'Please hold while we try and connect your call' message prompt.
+; Default is the global default.
+;
+followme-status-prompt=>followme/followme-status
+; The 'The party you're calling isn't at their desk' message prompt.
+; Default is the global default.
+;
+followme-sorry-prompt=>followme/followme-sorry  
+; The 'I'm sorry, but we were unable to locate your party' message prompt. Default
+; is the global default.
+
+



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:09:07 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:09:07 +0200
Subject: [solid-pbx-svn] r279 - trunk/res
Message-ID: <200606182209.k5IM97s8017542@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:09:05 +0200 (Mon, 19 Jun 2006)
New Revision: 279

Modified:
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r32643

------------------------------------------------------------------------
r32634 | mogorman | 2006-06-06 19:25:07 +0200 (Tue, 06 Jun 2006) | 2 lines

fixed autoregister bug.

------------------------------------------------------------------------


Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-18 21:54:29 UTC (rev 278)
+++ trunk/res/res_jabber.c	2006-06-18 22:09:05 UTC (rev 279)
@@ -1584,23 +1584,23 @@
 			});
 
 			if (!flag) {
-				if (ast_test_flag(client, AJI_AUTOPRUNE)) {
-					buddy = (struct aji_buddy *) malloc(sizeof(struct aji_buddy));
-					if (!buddy)
-						ast_log(LOG_WARNING, "Out of memory\n");
-					memset(buddy, 0, sizeof(struct aji_buddy));
-					ASTOBJ_INIT(buddy);
-					ASTOBJ_WRLOCK(buddy);
-					ast_copy_string(buddy->name, iks_find_attrib(x, "jid"), sizeof(buddy->name));
-					ast_copy_string(buddy->user, iks_find_attrib(x, "jid"), sizeof(buddy->user));
-					ast_clear_flag(buddy, AST_FLAGS_ALL);
+				buddy = (struct aji_buddy *) malloc(sizeof(struct aji_buddy));
+				if (!buddy)
+					ast_log(LOG_WARNING, "Out of memory\n");
+				memset(buddy, 0, sizeof(struct aji_buddy));
+				ASTOBJ_INIT(buddy);
+				ASTOBJ_WRLOCK(buddy);
+				ast_copy_string(buddy->name, iks_find_attrib(x, "jid"), sizeof(buddy->name));
+				ast_clear_flag(buddy, AST_FLAGS_ALL);
+				if(ast_test_flag(client, AJI_AUTOPRUNE)) {
 					ast_set_flag(buddy, AJI_AUTOPRUNE);
 					buddy->objflags |= ASTOBJ_FLAG_MARKED;
-					ASTOBJ_UNLOCK(buddy);
-					if (buddy) {
-						ASTOBJ_CONTAINER_LINK(&client->buddies, buddy);
-						ASTOBJ_UNREF(buddy, aji_buddy_destroy);
-					}
+				} else
+					ast_set_flag(buddy, AJI_AUTOREGISTER);
+				ASTOBJ_UNLOCK(buddy);
+				if (buddy) {
+					ASTOBJ_CONTAINER_LINK(&client->buddies, buddy);
+					ASTOBJ_UNREF(buddy, aji_buddy_destroy);
 				}
 			}
 		}



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:26:21 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:26:21 +0200
Subject: [solid-pbx-svn] r280 - in trunk: include/asterisk res
Message-ID: <200606182226.k5IMQLdj018749@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:26:18 +0200 (Mon, 19 Jun 2006)
New Revision: 280

Modified:
   trunk/include/asterisk/jabber.h
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r32663

------------------------------------------------------------------------
r32654 | mogorman | 2006-06-06 20:51:37 +0200 (Tue, 06 Jun 2006) | 3 lines

allow presence events to be handled before the 
roster is received.

------------------------------------------------------------------------


Modified: trunk/include/asterisk/jabber.h
===================================================================
--- trunk/include/asterisk/jabber.h	2006-06-18 22:09:05 UTC (rev 279)
+++ trunk/include/asterisk/jabber.h	2006-06-18 22:26:18 UTC (rev 280)
@@ -25,7 +25,6 @@
 enum aji_state {
 	AJI_DISCONNECTED=0,
 	AJI_CONNECTING,
-	AJI_ALMOST,
 	AJI_CONNECTED
 };
 

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-18 22:09:05 UTC (rev 279)
+++ trunk/res/res_jabber.c	2006-06-18 22:26:18 UTC (rev 280)
@@ -554,8 +554,7 @@
 		switch (type) {
 		case IKS_NODE_START:{
 				char secret[160], shasum[320], *handshake;
-				switch (client->state) {
-				case AJI_DISCONNECTED:
+				if (client->state == AJI_DISCONNECTED) {
 					sprintf(secret, "%s%s", pak->id, client->password);
 					ast_sha1_hash(shasum, secret);
 					handshake = NULL;
@@ -567,14 +566,7 @@
 					}
 					client->state = AJI_CONNECTED;
 					break;
-				case AJI_ALMOST:
-					client->state = AJI_CONNECTED;
-					break;
-				case AJI_CONNECTING:
-				case AJI_CONNECTED:
-					break;
-				};
-				break;
+				}
 			}
 
 		case IKS_NODE_NORMAL:{
@@ -1020,12 +1012,35 @@
 	struct aji_buddy *buddy = NULL;
 	struct aji_resource *tmp = NULL, *last = NULL, *found = NULL;
 	char *ver, *node;
-
+	
+	if(client->state != AJI_CONNECTED) {
+		buddy = (struct aji_buddy *) malloc(sizeof(struct aji_buddy));
+		if (!buddy) {
+			ast_log(LOG_WARNING, "Out of memory\n");
+			return ;
+		}
+		memset(buddy, 0, sizeof(struct aji_buddy));
+		ASTOBJ_INIT(buddy);
+		ASTOBJ_WRLOCK(buddy);
+		ast_copy_string(buddy->name, pak->from->partial, sizeof(buddy->name));
+		ast_clear_flag(buddy, AST_FLAGS_ALL);
+		if(ast_test_flag(client, AJI_AUTOPRUNE)) {
+			ast_set_flag(buddy, AJI_AUTOPRUNE);
+			buddy->objflags |= ASTOBJ_FLAG_MARKED;
+		} else
+			ast_set_flag(buddy, AJI_AUTOREGISTER);
+		ASTOBJ_UNLOCK(buddy);
+		if (buddy) {
+			ASTOBJ_CONTAINER_LINK(&client->buddies, buddy);
+			buddy = NULL;
+		}
+	}
 	buddy = ASTOBJ_CONTAINER_FIND(&client->buddies, pak->from->partial);
 	if (!buddy) {
 		ast_log(LOG_WARNING, "Got presence packet from %s, someone not in our roster!!!!\n", pak->from->partial);
 		return;
 	}
+	ASTOBJ_WRLOCK(buddy);
 	status = (pak->show) ? pak->show : 6;
 	priority = atoi((iks_find_cdata(pak->x, "priority")) ? iks_find_cdata(pak->x, "priority") : "0");
 	tmp = buddy->resources;
@@ -1118,6 +1133,8 @@
 		if (!tmp)
 			buddy->resources = found;
 	}
+	ASTOBJ_UNLOCK(buddy);
+	ASTOBJ_UNREF(buddy, aji_buddy_destroy);
 
 	node = iks_find_attrib(iks_find(pak->x, "c"), "node");
 	ver = iks_find_attrib(iks_find(pak->x, "c"), "ver");
@@ -1348,7 +1365,7 @@
 			ast_log(LOG_WARNING, "JABBER: Got hook event.\n");
 		} else if (res == IKS_NET_TLSFAIL) {
 			ast_log(LOG_WARNING, "JABBER:  Failure in tls.\n");
-		} else if (client->timeout == 0 && client->state != AJI_CONNECTED) {
+		} else if (client->timeout == 0 && client->state == AJI_CONNECTED) {
 			res = -1;
 			ast_log(LOG_WARNING, "JABBER:  Network Timeout\n");
 		} else if (res == IKS_NET_RWERR) {
@@ -1539,7 +1556,8 @@
 	int flag = 0;
 	iks *x = NULL;
 	struct aji_buddy *buddy;
-
+	
+	client->state = AJI_CONNECTED;
 	ASTOBJ_CONTAINER_TRAVERSE(&client->buddies, 1, {
 		ASTOBJ_RDLOCK(iterator);
 		x = iks_child(pak->query);
@@ -1585,8 +1603,10 @@
 
 			if (!flag) {
 				buddy = (struct aji_buddy *) malloc(sizeof(struct aji_buddy));
-				if (!buddy)
+				if (!buddy) {
 					ast_log(LOG_WARNING, "Out of memory\n");
+					return 0;
+				}
 				memset(buddy, 0, sizeof(struct aji_buddy));
 				ASTOBJ_INIT(buddy);
 				ASTOBJ_WRLOCK(buddy);
@@ -1663,7 +1683,7 @@
 	if (client) {
 		if (client->state == AJI_DISCONNECTED) {
 			iks_filter_add_rule(client->f, aji_filter_roster, client, IKS_RULE_TYPE, IKS_PAK_IQ, IKS_RULE_SUBTYPE, IKS_TYPE_RESULT, IKS_RULE_ID, "roster", IKS_RULE_DONE);
-			client->state = AJI_CONNECTED;
+			client->state = AJI_CONNECTING;
 			client->jid = (iks_find_cdata(pak->query, "jid")) ? iks_id_new(client->stack, iks_find_cdata(pak->query, "jid")) : client->jid;
 			iks_filter_remove_hook(client->f, aji_client_connect);
 			if(client->component == AJI_CLIENT)
@@ -1826,7 +1846,6 @@
 			status = "Disconnected";
 			break;
 		case AJI_CONNECTING:
-		case AJI_ALMOST:
 			status = "Connecting";
 			break;
 		case AJI_CONNECTED:
@@ -2170,7 +2189,7 @@
 			if(iterator->state == AJI_DISCONNECTED) {
 				if (!iterator->thread)
 					ast_pthread_create(&iterator->thread, NULL, aji_recv_loop, iterator);
-			} else if (iterator->state == AJI_CONNECTED) {
+			} else if (iterator->state == AJI_CONNECTING) {
 				aji_get_roster(iterator);
 			}
 			ASTOBJ_UNLOCK(iterator);



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:27:43 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:27:43 +0200
Subject: [solid-pbx-svn] r281 - trunk/res
Message-ID: <200606182227.k5IMRhVd018919@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:27:42 +0200 (Mon, 19 Jun 2006)
New Revision: 281

Modified:
   trunk/res/res_config_pgsql.c
Log:
Update to Asterisk SVN trunk r32673

------------------------------------------------------------------------
r32673 | russell | 2006-06-06 21:07:52 +0200 (Tue, 06 Jun 2006) | 2 lines

add missing include

------------------------------------------------------------------------


Modified: trunk/res/res_config_pgsql.c
===================================================================
--- trunk/res/res_config_pgsql.c	2006-06-18 22:26:18 UTC (rev 280)
+++ trunk/res/res_config_pgsql.c	2006-06-18 22:27:42 UTC (rev 281)
@@ -27,6 +27,7 @@
  ***/
 
 #include <stdlib.h>
+#include <stdio.h>
 #include <string.h>
 #include <libpq-fe.h>			/* PostgreSQL */
 



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:29:27 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:29:27 +0200
Subject: [solid-pbx-svn] r282 - in trunk: include/asterisk res
Message-ID: <200606182229.k5IMTRtm019446@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:29:25 +0200 (Mon, 19 Jun 2006)
New Revision: 282

Modified:
   trunk/include/asterisk/jabber.h
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r32683

------------------------------------------------------------------------
r32674 | mogorman | 2006-06-06 21:18:44 +0200 (Tue, 06 Jun 2006) | 2 lines

fix a potential segfault

------------------------------------------------------------------------
r32675 | mogorman | 2006-06-06 21:51:26 +0200 (Tue, 06 Jun 2006) | 3 lines

fixes some issues with description loggin on presence
as well as some typos.

------------------------------------------------------------------------


Modified: trunk/include/asterisk/jabber.h
===================================================================
--- trunk/include/asterisk/jabber.h	2006-06-18 22:27:42 UTC (rev 281)
+++ trunk/include/asterisk/jabber.h	2006-06-18 22:29:25 UTC (rev 282)
@@ -23,7 +23,7 @@
 #include "asterisk/astobj.h"
 
 enum aji_state {
-	AJI_DISCONNECTED=0,
+	AJI_DISCONNECTED = 0,
 	AJI_CONNECTING,
 	AJI_CONNECTED
 };
@@ -60,7 +60,7 @@
 struct aji_resource {
 	int status;
 	char resource[80];
-	char description[1000];
+	char *description;
 	struct aji_version *cap;
 	int priority;
 	struct aji_resource *next;

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-18 22:27:42 UTC (rev 281)
+++ trunk/res/res_jabber.c	2006-06-18 22:29:25 UTC (rev 282)
@@ -104,7 +104,7 @@
 
 static char test_usage[] = 
 "Usage: JABBER test [client]\n" 
-"       Sends test massage for debugging purposes.  A specific client\n"
+"       Sends test message for debugging purposes.  A specific client\n"
 "       as configured in jabber.conf can be optionally specified.\n";
 
 static struct ast_cli_entry aji_cli[] = {
@@ -169,6 +169,7 @@
 
 	while ((tmp = obj->resources)) {
 		obj->resources = obj->resources->next;
+		free(tmp->description);
 		free(tmp);
 	}
 
@@ -811,7 +812,11 @@
 	buddy = ASTOBJ_CONTAINER_FIND(&client->buddies, pak->from->partial);
 
 	resource = aji_find_resource(buddy, pak->from->resource);
-
+	if (!resource) {
+		ast_log(LOG_NOTICE,"JABBER: Received client info from %s when not requested.\n", pak->from->full);
+		ASTOBJ_UNREF(client, aji_client_destroy);
+		return IKS_FILTER_EAT;
+	}	
 	if (pak->subtype == IKS_TYPE_RESULT) {
 		if (iks_find_with_attrib(pak->query, "feature", "var", "http://www.google.com/xmpp/protocol/voice/v1")) {
 			resource->cap->jingle = 1;
@@ -837,8 +842,8 @@
 			iks_insert_attrib(google, "var", "http://www.google.com/xmpp/protocol/voice/v1");
 			iks_insert_node(iq, query);
 			iks_insert_node(query, ident);
+			iks_insert_node(query, google);
 			iks_insert_node(query, disco);
-			iks_insert_node(query, google);
 			iks_send(client->p, iq);
 		} else
 			ast_log(LOG_ERROR, "Out of Memory.\n");
@@ -1011,7 +1016,7 @@
 	int status, priority;
 	struct aji_buddy *buddy = NULL;
 	struct aji_resource *tmp = NULL, *last = NULL, *found = NULL;
-	char *ver, *node;
+	char *ver, *node, *descrip;
 	
 	if(client->state != AJI_CONNECTED) {
 		buddy = (struct aji_buddy *) malloc(sizeof(struct aji_buddy));
@@ -1044,10 +1049,13 @@
 	status = (pak->show) ? pak->show : 6;
 	priority = atoi((iks_find_cdata(pak->x, "priority")) ? iks_find_cdata(pak->x, "priority") : "0");
 	tmp = buddy->resources;
+	descrip = ast_strdup(iks_find_cdata(pak->x,"status"));
 
 	while (tmp) {
 		if (!strcasecmp(tmp->resource, pak->from->resource)) {
 			tmp->status = status;
+			if (tmp->description) free(tmp->description);
+			tmp->description = descrip;
 			found = tmp;
 			if (status == 6) {	/* Sign off Destroy resource */
 				if (last && found->next) {
@@ -1110,6 +1118,7 @@
 		}
 		ast_copy_string(found->resource, pak->from->resource, sizeof(found->resource));
 		found->status = status;
+		found->description = descrip;
 		found->priority = priority;
 		found->next = NULL;
 		last = NULL;



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:32:22 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:32:22 +0200
Subject: [solid-pbx-svn] r283 - trunk/apps
Message-ID: <200606182232.k5IMWMUu020691@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:32:10 +0200 (Mon, 19 Jun 2006)
New Revision: 283

Modified:
   trunk/apps/app_followme.c
Log:
Update to Asterisk SVN trunk r32703

------------------------------------------------------------------------
r32694 | bweschke | 2006-06-06 22:04:52 +0200 (Tue, 06 Jun 2006) | 3 lines

All better now!


------------------------------------------------------------------------
r32695 | russell | 2006-06-06 22:18:01 +0200 (Tue, 06 Jun 2006) | 2 lines

allocate an int on the stack instead of with ast_calloc

------------------------------------------------------------------------
r32696 | bweschke | 2006-06-06 22:34:00 +0200 (Tue, 06 Jun 2006) | 3 lines

 Don't leak memory.


------------------------------------------------------------------------
r32697 | russell | 2006-06-06 22:37:51 +0200 (Tue, 06 Jun 2006) | 2 lines

move a declaration to the beginning of a block

------------------------------------------------------------------------
r32698 | bweschke | 2006-06-06 22:39:11 +0200 (Tue, 06 Jun 2006) | 3 lines

 More cleanup.


------------------------------------------------------------------------
r32699 | russell | 2006-06-06 22:44:10 +0200 (Tue, 06 Jun 2006) | 2 lines

make a global list head static

------------------------------------------------------------------------
r32700 | bweschke | 2006-06-06 22:44:50 +0200 (Tue, 06 Jun 2006) | 3 lines

 More updates.


------------------------------------------------------------------------
r32701 | russell | 2006-06-06 22:45:26 +0200 (Tue, 06 Jun 2006) | 2 lines

use sizeof to get the size of a buffer

------------------------------------------------------------------------
r32702 | russell | 2006-06-06 22:47:46 +0200 (Tue, 06 Jun 2006) | 2 lines

use sizeof to determine the size of a buffer

------------------------------------------------------------------------
r32703 | russell | 2006-06-06 22:55:17 +0200 (Tue, 06 Jun 2006) | 2 lines

move a variable declaration to the beginning of a block

------------------------------------------------------------------------


Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-18 22:29:25 UTC (rev 282)
+++ trunk/apps/app_followme.c	2006-06-18 22:32:10 UTC (rev 283)
@@ -35,7 +35,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$version$")
+ASTERISK_FILE_VERSION(__FILE__, "$revision$")
 
 #include "asterisk/lock.h"
 #include "asterisk/file.h"
@@ -164,7 +164,7 @@
 
 
 static AST_LIST_HEAD_STATIC(followmes, ast_call_followme);
-AST_LIST_HEAD_NOLOCK(findme_user_listptr, findme_user);
+static AST_LIST_HEAD_NOLOCK(findme_user_listptr, findme_user);
 
 static void free_numbers(struct ast_call_followme *f)
 {
@@ -264,8 +264,7 @@
 
 	if (cur) {
 		cur->timeout = timeout;
-		if (strchr(number, ',')) { 
-			tmp = strchr(number, ',');
+		if ((tmp = strchr(number, ','))) { 
 			*tmp = '\0';
 		}
 		ast_copy_string(cur->number, number, sizeof(cur->number));
@@ -439,7 +438,7 @@
 		}
 		if (outbound->cdr) {
 			char tmp[256];
-			snprintf(tmp, 256, "%s/%s", "Local", tmpuser->dialarg);
+			snprintf(tmp, sizeof(tmp), "%s/%s", "Local", tmpuser->dialarg);
 			ast_cdr_setapp(outbound->cdr,"FollowMe",tmp);
 			ast_cdr_update(outbound);
 			ast_cdr_start(outbound->cdr);
@@ -476,10 +475,10 @@
 	int ctstatus;
 	int dg;
 	struct findme_user *tmpuser;
-	int *to = ast_calloc(1, sizeof(*to));
+	int to = 0;
 	int livechannels = 0;
 	int tmpto;
-	long totalwait = 0, wtd, towas = *to;
+	long totalwait = 0, wtd, towas = 0;
 	char *callfromname;
 	char *pressbuttonname;
 
@@ -494,14 +493,13 @@
 			if (option_verbose > 2)
 				ast_verbose(VERBOSE_PREFIX_3 "Original caller hungup. Cleanup.\n");
 			clear_calling_tree(findme_user_list);
-			free(to);
 			return NULL;
 		}
 		ctstatus = 0;
 		totalwait = nm->timeout * 1000;
 		wtd = 0;
 		while (!ctstatus) {
-			*to = 1000;
+			to = 1000;
 			pos = 1; 
 			livechannels = 0;
 			watchers[0] = caller;
@@ -523,7 +521,6 @@
 								ast_sched_runq(tmpuser->ochan->sched);
 							} else {
 								ast_log(LOG_WARNING, "Unable to playback %s.\n", callfromname);
-								free(to);
 								return NULL;
 							}							
 						} else {
@@ -533,7 +530,6 @@
 								ast_sched_runq(tmpuser->ochan->sched);
 							else {
 								ast_log(LOG_WARNING, "Unable to playback %s.\n", tpargs->norecordingprompt);
-								free(to);
 								return NULL;
 							}
 						}
@@ -541,8 +537,8 @@
 					if (tmpuser->ochan->stream) {
 						ast_sched_runq(tmpuser->ochan->sched);
 						tmpto = ast_sched_wait(tmpuser->ochan->sched);
-						if (tmpto > 0 && tmpto < *to)
-							*to = tmpto;
+						if (tmpto > 0 && tmpto < to)
+							to = tmpto;
 						else if (tmpto < 0 && !tmpuser->ochan->timingfunc) {
 							ast_stopstream(tmpuser->ochan);
 							if (tmpuser->state == 1) {
@@ -558,7 +554,6 @@
 										tmpuser->state = 3;
 									else {
 										ast_log(LOG_WARNING, "Unable to playback %s.\n", pressbuttonname);
-										free(to);
 										return NULL;
 									} 
 								}
@@ -571,7 +566,6 @@
 									tmpuser->state = 3;
 									
 								} else {
-									ast_log(LOG_WARNING, "Unable to playback %s.\n", pressbuttonname);										  free(to);
 									return NULL;
 								} 
 							} else if (tmpuser->state == 3) {
@@ -586,21 +580,20 @@
 				}
 			}
 
-			tmpto = *to;
-			if (*to < 0) {
-				*to = 1000;
+			tmpto = to;
+			if (to < 0) {
+				to = 1000;
 				tmpto = 1000;
 			}
-			towas = *to;
-			winner = ast_waitfor_n(watchers, pos, to);
-			tmpto -= *to;
+			towas = to;
+			winner = ast_waitfor_n(watchers, pos, &to);
+			tmpto -= to;
 			totalwait -= tmpto;
-			wtd = *to;	
+			wtd = to;	
 			if (totalwait <= 0) {
 				if (option_verbose > 2)	
 					ast_verbose(VERBOSE_PREFIX_3 "We've hit our timeout for this step. Drop everyone and move on to the next one. %ld\n", totalwait);
 				clear_calling_tree(findme_user_list);
-				free(to);
 				return NULL;
 			}
 			if (winner) {
@@ -640,7 +633,7 @@
 										tmpuser->state = 1;
 									} else {
 										ast_log(LOG_WARNING, "Unable to playback %s.\n", callfromname);
-										free(to);
+										ast_frfree(f);
 										return NULL;
 									}				
 								} else {			
@@ -649,7 +642,7 @@
 										ast_sched_runq(tmpuser->ochan->sched);
 									else {
 										ast_log(LOG_WARNING, "Unable to playback %s.\n", tpargs->norecordingprompt);
-										free(to);
+										ast_frfree(f);
 										return NULL;
 									}
 								}
@@ -717,14 +710,14 @@
 							if (!strcmp(tmpuser->yn, tpargs->takecall)) {
 								if (option_debug)
 									ast_log(LOG_DEBUG, "Match to take the call!\n");
-								free(to);
+								ast_frfree(f);
 								return tmpuser->ochan;	
 							}
 							if (!strcmp(tmpuser->yn, tpargs->nextindp)) {
 								if (option_debug)
 									ast_log(LOG_DEBUG, "Next in dial plan step requested.\n");
 								*status = 1;
-								free(to);
+								ast_frfree(f);
 								return NULL;
 							}	
 
@@ -738,7 +731,6 @@
 							ast_log(LOG_DEBUG, "we didn't get a frame. hanging up. dg is %d\n",dg);					      
 						if (!dg) {
 							clear_calling_tree(findme_user_list);
-							free(to);
 							return NULL;
 						} else {
 							tmpuser->state = -1;
@@ -749,7 +741,6 @@
 							if (!livechannels) {
 								if (option_verbose > 2)
 									ast_verbose(VERBOSE_PREFIX_3 "no live channels left. exiting.\n");
-								free(to);
 								return NULL;
 							}
 						}
@@ -769,13 +760,11 @@
 	}
 	
 	/* --- WAIT FOR WINNER NUMBER END! -----------*/
-	free(to);
 	return NULL;
 }
 
-static void findmeexec(void *args)
+static void findmeexec(struct fm_args *tpargs)
 {
-	struct fm_args *tpargs;
 	struct number *nm;
 	struct ast_channel *outbound;
 	struct ast_channel *caller;
@@ -792,12 +781,6 @@
 	findme_user_list = ast_calloc(1, sizeof(*findme_user_list));		
 	AST_LIST_HEAD_INIT_NOLOCK(findme_user_list);
 
-	tpargs = (struct fm_args *)args;
-			
-	if (!tpargs->chan) 
-		return;
-	
-
 	/* We're going to figure out what the longest possible string of digits to collect is */
 	ynlongest = 0;
 	if (strlen(tpargs->takecall) > ynlongest)
@@ -858,10 +841,10 @@
 							outbound->cdr = ast_cdr_alloc();
 						}
 						if (outbound->cdr) {
-							ast_cdr_init(outbound->cdr, outbound);
 							char tmp[256];
-							snprintf(tmp, 256, "%s/%s", "Local", dialarg);
-							ast_cdr_setapp(outbound->cdr,"FollowMe",tmp);
+							ast_cdr_init(outbound->cdr, outbound);
+							snprintf(tmp, sizeof(tmp), "%s/%s", "Local", dialarg);
+							ast_cdr_setapp(outbound->cdr, "FollowMe", tmp);
 							ast_cdr_update(outbound);
 							ast_cdr_start(outbound->cdr);
 							ast_cdr_end(outbound->cdr);
@@ -1099,15 +1082,18 @@
 static int unload_module(void *mod)
 {
 	struct ast_call_followme *f;
+	STANDARD_HANGUP_LOCALUSERS;
+	ast_unregister_application(app);
 	/* Free Memory. Yeah! I'm free! */
+	AST_LIST_LOCK(&followmes);
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&followmes, f, entry) {
 		free_numbers(f);
 		AST_LIST_REMOVE_CURRENT(&followmes, entry);
 		free(f);
 	}
 	AST_LIST_TRAVERSE_SAFE_END
-	STANDARD_HANGUP_LOCALUSERS;
-	return ast_unregister_application(app);
+	AST_LIST_UNLOCK(&followmes);
+	return 0;
 }
 
 static int load_module(void *mod)



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:33:54 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:33:54 +0200
Subject: [solid-pbx-svn] r284 - trunk/apps
Message-ID: <200606182233.k5IMXs9Y021077@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:33:37 +0200 (Mon, 19 Jun 2006)
New Revision: 284

Modified:
   trunk/apps/app_followme.c
Log:
Update to Asterisk SVN trunk r32723

------------------------------------------------------------------------
r32720 | russell | 2006-06-06 23:03:18 +0200 (Tue, 06 Jun 2006) | 2 lines

oops.

------------------------------------------------------------------------


Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-18 22:32:10 UTC (rev 283)
+++ trunk/apps/app_followme.c	2006-06-18 22:33:37 UTC (rev 284)
@@ -164,7 +164,7 @@
 
 
 static AST_LIST_HEAD_STATIC(followmes, ast_call_followme);
-static AST_LIST_HEAD_NOLOCK(findme_user_listptr, findme_user);
+AST_LIST_HEAD_NOLOCK(findme_user_listptr, findme_user);
 
 static void free_numbers(struct ast_call_followme *f)
 {



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:34:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:34:41 +0200
Subject: [solid-pbx-svn] r285 - trunk/channels
Message-ID: <200606182234.k5IMYfAY021367@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:34:37 +0200 (Mon, 19 Jun 2006)
New Revision: 285

Modified:
   trunk/channels/chan_zap.c
Log:
Update to Asterisk SVN trunk r32743

------------------------------------------------------------------------
r32740 | mattf | 2006-06-07 00:19:19 +0200 (Wed, 07 Jun 2006) | 2 lines

Add q.921 state information. (#7260)

------------------------------------------------------------------------


Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-18 22:33:37 UTC (rev 284)
+++ trunk/channels/chan_zap.c	2006-06-18 22:34:37 UTC (rev 285)
@@ -9375,7 +9375,9 @@
 	}
 	for (x = 0; x < NUM_DCHANS; x++) {
 		if (pris[span-1].dchans[x])
-			pri_set_debug(pris[span-1].dchans[x], PRI_DEBUG_APDU | PRI_DEBUG_Q931_DUMP | PRI_DEBUG_Q931_STATE);
+			pri_set_debug(pris[span-1].dchans[x], PRI_DEBUG_APDU |
+			                                      PRI_DEBUG_Q931_DUMP | PRI_DEBUG_Q931_STATE |
+			                                      PRI_DEBUG_Q921_STATE);
 	}
 	ast_cli(fd, "Enabled debugging on span %d\n", span);
 	return RESULT_SUCCESS;
@@ -9423,7 +9425,9 @@
 	}
 	for (x = 0; x < NUM_DCHANS; x++) {
 		if (pris[span-1].dchans[x])
-			pri_set_debug(pris[span-1].dchans[x], (PRI_DEBUG_APDU | PRI_DEBUG_Q931_DUMP | PRI_DEBUG_Q921_DUMP | PRI_DEBUG_Q921_RAW | PRI_DEBUG_Q921_STATE));
+			pri_set_debug(pris[span-1].dchans[x], PRI_DEBUG_APDU |
+			                                      PRI_DEBUG_Q931_DUMP | PRI_DEBUG_Q931_STATE |
+			                                      PRI_DEBUG_Q921_RAW | PRI_DEBUG_Q921_DUMP | PRI_DEBUG_Q921_STATE);
 	}
 	ast_cli(fd, "Enabled EXTENSIVE debugging on span %d\n", span);
 	return RESULT_SUCCESS;



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:37:55 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:37:55 +0200
Subject: [solid-pbx-svn] r286 - trunk/channels
Message-ID: <200606182237.k5IMbtem022353@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:37:53 +0200 (Mon, 19 Jun 2006)
New Revision: 286

Modified:
   trunk/channels/chan_zap.c
Log:
Update to Asterisk SVN trunk r32763

------------------------------------------------------------------------
r32759 | russell | 2006-06-07 01:22:12 +0200 (Wed, 07 Jun 2006) | 7 lines

revert my changes to convert fields of zt_pvt to use stringfields.  When I did
this, I was not keeping in mind the fact that after a stringfield is overwritten
by another string, the memory used by the old string can not be recovered.  I
would like to go back through these changes and make sure that stringfields are
not used for fields that are written to many times before these changes are
committed.

------------------------------------------------------------------------


Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-18 22:34:37 UTC (rev 285)
+++ trunk/channels/chan_zap.c	2006-06-18 22:37:53 UTC (rev 286)
@@ -618,31 +618,25 @@
 
 	struct zt_distRings drings;
 
-	AST_DECLARE_STRING_FIELDS(
-		AST_STRING_FIELD(language);
-		AST_STRING_FIELD(musicclass);
-		AST_STRING_FIELD(accountcode);
-		AST_STRING_FIELD(mailbox);
-		AST_STRING_FIELD(call_forward);
-		AST_STRING_FIELD(cid_num);
-		AST_STRING_FIELD(cid_name);
-		AST_STRING_FIELD(lastcid_num);
-		AST_STRING_FIELD(lastcid_name);
-		AST_STRING_FIELD(dnid);
-		AST_STRING_FIELD(callwait_num);
-		AST_STRING_FIELD(callwait_name);
-		AST_STRING_FIELD(finaldial);
-		AST_STRING_FIELD(context);
-		AST_STRING_FIELD(defcontext);
-		AST_STRING_FIELD(exten);
+	char context[AST_MAX_CONTEXT];
+	char defcontext[AST_MAX_CONTEXT];
+	char exten[AST_MAX_EXTENSION];
+	char language[MAX_LANGUAGE];
+	char musicclass[MAX_MUSICCLASS];
 #ifdef PRI_ANI
-		AST_STRING_FIELD(cid_ani);
+	char cid_ani[AST_MAX_EXTENSION];
 #endif
-	);
+	char cid_num[AST_MAX_EXTENSION];
 	int cid_ton;					/*!< Type Of Number (TON) */
+	char cid_name[AST_MAX_EXTENSION];
+	char lastcid_num[AST_MAX_EXTENSION];
+	char lastcid_name[AST_MAX_EXTENSION];
 	char *origcid_num;				/*!< malloced original callerid */
 	char *origcid_name;				/*!< malloced original callerid */
+	char callwait_num[AST_MAX_EXTENSION];
+	char callwait_name[AST_MAX_EXTENSION];
 	char rdnis[AST_MAX_EXTENSION];
+	char dnid[AST_MAX_EXTENSION];
 	unsigned int group;
 	int law;
 	int confno;					/*!< Our conference */
@@ -678,8 +672,12 @@
 	int cref;					/*!< Call reference number */
 	ZT_DIAL_OPERATION dop;
 	int whichwink;					/*!< SIG_FEATDMF_TA Which wink are we on? */
+	char finaldial[64];
+	char accountcode[AST_MAX_ACCOUNT_CODE];		/*!< Account code */
 	int amaflags;					/*!< AMA Flags */
 	struct tdd_state *tdd;				/*!< TDD flag */
+	char call_forward[AST_MAX_EXTENSION];
+	char mailbox[AST_MAX_EXTENSION];
 	char dialdest[256];
 	int onhooktime;
 	int msgstate;
@@ -1825,13 +1823,13 @@
 			/* Call waiting call */
 			p->callwaitrings = 0;
 			if (ast->cid.cid_num)
-				ast_string_field_set(p, callwait_num, ast->cid.cid_num);
+				ast_copy_string(p->callwait_num, ast->cid.cid_num, sizeof(p->callwait_num));
 			else
-				ast_string_field_set(p, callwait_num, "");
+				p->callwait_num[0] = '\0';
 			if (ast->cid.cid_name)
-				ast_string_field_set(p, callwait_name, ast->cid.cid_name);
+				ast_copy_string(p->callwait_name, ast->cid.cid_name, sizeof(p->callwait_name));
 			else
-				ast_string_field_set(p, callwait_name, "");
+				p->callwait_name[0] = '\0';
 			/* Call waiting tone instead */
 			if (zt_callwait(ast)) {
 				ast_mutex_unlock(&p->lock);
@@ -1845,13 +1843,13 @@
 		n = ast->cid.cid_name;
 		l = ast->cid.cid_num;
 		if (l)
-			ast_string_field_set(p, lastcid_num, l);
+			ast_copy_string(p->lastcid_num, l, sizeof(p->lastcid_num));
 		else
-			ast_string_field_set(p, lastcid_num, "");
+			p->lastcid_num[0] = '\0';
 		if (n)
-			ast_string_field_set(p, lastcid_name, n);
+			ast_copy_string(p->lastcid_name, n, sizeof(p->lastcid_name));
 		else
-			ast_string_field_set(p, lastcid_name, "");
+			p->lastcid_name[0] = '\0';
 		ast_setstate(ast, AST_STATE_RINGING);
 		index = zt_get_index(ast, p, 0);
 		if (index > -1) {
@@ -1939,7 +1937,7 @@
 				return -1;
 			}
 			snprintf(p->dop.dialstr, sizeof(p->dop.dialstr), "M*%s%s#", ozz, cic);
-			ast_string_field_build(p, finaldial, "M*%s#", c);
+			snprintf(p->finaldial, sizeof(p->finaldial), "M*%s#", c);
 			p->whichwink = 0;
 		}
 			break;
@@ -2154,7 +2152,6 @@
 		ASTOBJ_UNREF(p->smdi_iface, ast_smdi_interface_destroy);
 #endif
 	ast_mutex_destroy(&p->lock);
-	ast_string_field_free_all(p);
 	free(p);
 	*pvt = NULL;
 }
@@ -2373,19 +2370,19 @@
 	zt_confmute(p, 0);
 	restore_gains(p);
 	if (p->origcid_num) {
-		ast_string_field_set(p, cid_num, p->origcid_num);
+		ast_copy_string(p->cid_num, p->origcid_num, sizeof(p->cid_num));
 		free(p->origcid_num);
 		p->origcid_num = NULL;
-	}
+	}	
 	if (p->origcid_name) {
-		ast_string_field_set(p, cid_name, p->origcid_name);
+		ast_copy_string(p->cid_name, p->origcid_name, sizeof(p->cid_name));
 		free(p->origcid_name);
 		p->origcid_name = NULL;
 	}	
 	if (p->dsp)
 		ast_dsp_digitmode(p->dsp,DSP_DIGITMODE_DTMF | p->dtmfrelax);
-	if (!ast_strlen_zero(p->exten))
-		ast_string_field_set(p, exten, "");
+	if (p->exten)
+		p->exten[0] = '\0';
 
 	ast_log(LOG_DEBUG, "Hangup: channel: %d index = %d, normal = %d, callwait = %d, thirdcall = %d\n",
 		p->channel, index, p->subs[SUB_REAL].zfd, p->subs[SUB_CALLWAIT].zfd, p->subs[SUB_THREEWAY].zfd);
@@ -4099,8 +4096,8 @@
 								p->origcid_num = ast_strdup(p->cid_num);
 							if (!p->origcid_name)
 								p->origcid_name = ast_strdup(p->cid_name);
-							ast_string_field_set(p, cid_num, cid_num);
-							ast_string_field_set(p, cid_name, cid_name);
+							ast_copy_string(p->cid_num, cid_num, sizeof(p->cid_num));
+							ast_copy_string(p->cid_name, cid_name, sizeof(p->cid_name));
 						}
 						/* Swap things around between the three-way and real call */
 						swap_subs(p, SUB_THREEWAY, SUB_REAL);
@@ -5346,7 +5343,7 @@
 			ast_log(LOG_DEBUG, "No such possible extension '%s' in context '%s'\n", exten, chan->context);
 			chan->hangupcause = AST_CAUSE_UNALLOCATED;
 			ast_hangup(chan);
-			ast_string_field_set(p, exten, "");
+			p->exten[0] = '\0';
 			/* Since we send release complete here, we won't get one */
 			p->call = NULL;
 		}
@@ -5660,7 +5657,7 @@
 				if (!res || !ast_matchmore_extension(chan, chan->context, exten, 1, p->cid_num)) {
 					if (getforward) {
 						/* Record this as the forwarding extension */
-						ast_string_field_set(p, call_forward, exten); 
+						ast_copy_string(p->call_forward, exten, sizeof(p->call_forward)); 
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Setting call forward to '%s' on channel %d\n", p->call_forward, p->channel);
 						res = tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALRECALL);
@@ -5809,7 +5806,7 @@
 				if (option_verbose > 2)
 					ast_verbose(VERBOSE_PREFIX_3 "Cancelling call forwarding on channel %d\n", p->channel);
 				res = tone_zone_play_tone(p->subs[index].zfd, ZT_TONE_DIALRECALL);
-				ast_string_field_set(p, call_forward, "");
+				memset(p->call_forward, 0, sizeof(p->call_forward));
 				getforward = 0;
 				memset(exten, 0, sizeof(exten));
 				len = 0;
@@ -6112,9 +6109,9 @@
 						counter = 0;
 						counter1 = 0;
 						/* Check to see if context is what it should be, if not set to be. */
-						if (!strcmp(p->context, p->defcontext)) {
-							ast_string_field_set(p, context, p->defcontext);
-							ast_copy_string(chan->context, p->defcontext, sizeof(chan->context));
+						if (strcmp(p->context,p->defcontext) != 0) {
+							ast_copy_string(p->context, p->defcontext, sizeof(p->context));
+							ast_copy_string(chan->context,p->defcontext,sizeof(chan->context));
 						}
 		
 						for (;;) {	
@@ -6172,10 +6169,10 @@
 							}
 							if (distMatches == 3) {
 								/* The ring matches, set the context to whatever is for distinctive ring.. */
-								ast_string_field_set(p, context, p->drings.ringContext[counter].contextData);
+								ast_copy_string(p->context, p->drings.ringContext[counter].contextData, sizeof(p->context));
 								ast_copy_string(chan->context, p->drings.ringContext[counter].contextData, sizeof(chan->context));
 								if (option_verbose > 2)
-									ast_verbose( VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n", p->context);
+									ast_verbose( VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n",p->context);
 								break;
 							}
 						}
@@ -6214,9 +6211,9 @@
 				counter = 0;
 				counter1 = 0;
 				/* Check to see if context is what it should be, if not set to be. */
-				if (!strcmp(p->context, p->defcontext)) {
-					ast_string_field_set(p, context, p->defcontext);
-					ast_copy_string(chan->context, p->defcontext, sizeof(chan->context));
+				if (strcmp(p->context,p->defcontext) != 0) {
+					ast_copy_string(p->context, p->defcontext, sizeof(p->context));
+					ast_copy_string(chan->context,p->defcontext,sizeof(chan->context));
 				}
 
 				/* Take out of linear mode for Caller*ID processing */
@@ -6345,10 +6342,10 @@
 						}
 						if (distMatches == 3) {
 							/* The ring matches, set the context to whatever is for distinctive ring.. */
-							ast_string_field_set(p, context, p->drings.ringContext[counter].contextData);
+							ast_copy_string(p->context, p->drings.ringContext[counter].contextData, sizeof(p->context));
 							ast_copy_string(chan->context, p->drings.ringContext[counter].contextData, sizeof(chan->context));
 							if (option_verbose > 2)
-								ast_verbose(VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n", p->context);
+								ast_verbose( VERBOSE_PREFIX_3 "Distinctive Ring matched context %s\n",p->context);
 							break;
 						}
 					}
@@ -7007,10 +7004,6 @@
 			destroy_zt_pvt(&tmp);
 			return NULL;
 		}
-		if (ast_string_field_init(tmp, 256)) {
-			destroy_zt_pvt(&tmp);
-			return NULL;
-		}
 		ast_mutex_init(&tmp->lock);
 		ifcount++;
 		for (x = 0; x < 3; x++)
@@ -7315,7 +7308,7 @@
 		}
 #endif
 
-		ast_string_field_set(tmp, accountcode, accountcode);
+		ast_copy_string(tmp->accountcode, accountcode, sizeof(tmp->accountcode));
 		tmp->amaflags = amaflags;
 		if (!here) {
 			tmp->confno = -1;
@@ -7323,14 +7316,14 @@
 		}
 		tmp->canpark = canpark;
 		tmp->transfer = transfer;
-		ast_string_field_set(tmp, defcontext, context);
-		ast_string_field_set(tmp, language, language);
-		ast_string_field_set(tmp, musicclass, musicclass);
-		ast_string_field_set(tmp, context, context);
-		ast_string_field_set(tmp, cid_num, cid_num);
+		ast_copy_string(tmp->defcontext,context,sizeof(tmp->defcontext));
+		ast_copy_string(tmp->language, language, sizeof(tmp->language));
+		ast_copy_string(tmp->musicclass, musicclass, sizeof(tmp->musicclass));
+		ast_copy_string(tmp->context, context, sizeof(tmp->context));
+		ast_copy_string(tmp->cid_num, cid_num, sizeof(tmp->cid_num));
 		tmp->cid_ton = 0;
-		ast_string_field_set(tmp, cid_name, cid_name);
-		ast_string_field_set(tmp, mailbox, mailbox);
+		ast_copy_string(tmp->cid_name, cid_name, sizeof(tmp->cid_name));
+		ast_copy_string(tmp->mailbox, mailbox, sizeof(tmp->mailbox));
 		tmp->msgstate = -1;
 		tmp->group = cur_group;
 		tmp->callgroup=cur_callergroup;
@@ -8572,22 +8565,22 @@
 					apply_plan_to_number(plancallingnum, sizeof(plancallingnum), pri, e->ring.callingnum, e->ring.callingplan);
 					if (pri->pvts[chanpos]->use_callerid) {
 						ast_shrink_phone_number(plancallingnum);
-						ast_string_field_set(pri->pvts[chanpos], cid_num, plancallingnum);
+						ast_copy_string(pri->pvts[chanpos]->cid_num, plancallingnum, sizeof(pri->pvts[chanpos]->cid_num));
 #ifdef PRI_ANI
 						if (!ast_strlen_zero(e->ring.callingani)) {
 							apply_plan_to_number(plancallingani, sizeof(plancallingani), pri, e->ring.callingani, e->ring.callingplanani);
 							ast_shrink_phone_number(plancallingani);
-							ast_string_field_set(pri->pvts[chanpos], cid_ani, plancallingani);
+							ast_copy_string(pri->pvts[chanpos]->cid_ani, plancallingani, sizeof(pri->pvts[chanpos]->cid_ani));
 						} else {
-							ast_string_field_set(pri->pvts[chanpos], cid_ani, "");
+							pri->pvts[chanpos]->cid_ani[0] = '\0';
 						}
 #endif
-						ast_string_field_set(pri->pvts[chanpos], cid_name, e->ring.callingname);
+						ast_copy_string(pri->pvts[chanpos]->cid_name, e->ring.callingname, sizeof(pri->pvts[chanpos]->cid_name));
 						pri->pvts[chanpos]->cid_ton = e->ring.callingplan; /* this is the callingplan (TON/NPI), e->ring.callingplan>>4 would be the TON */
 					} else {
-						ast_string_field_set(pri->pvts[chanpos], cid_num, "");
-						ast_string_field_set(pri->pvts[chanpos], cid_ani, "");
-						ast_string_field_set(pri->pvts[chanpos], cid_name, "");
+						pri->pvts[chanpos]->cid_num[0] = '\0';
+						pri->pvts[chanpos]->cid_ani[0] = '\0';
+						pri->pvts[chanpos]->cid_name[0] = '\0';
 						pri->pvts[chanpos]->cid_ton = 0;
 					}
 					apply_plan_to_number(pri->pvts[chanpos]->rdnis, sizeof(pri->pvts[chanpos]->rdnis), pri,
@@ -8596,22 +8589,24 @@
 					if (pri->pvts[chanpos]->immediate) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of immediate=yes\n");
-						ast_string_field_set(pri->pvts[chanpos], exten, "s");
+						pri->pvts[chanpos]->exten[0] = 's';
+						pri->pvts[chanpos]->exten[1] = '\0';
 					}
 					/* Get called number */
 					else if (!ast_strlen_zero(e->ring.callednum)) {
-						ast_string_field_set(pri->pvts[chanpos], exten, e->ring.callednum);
-						ast_string_field_set(pri->pvts[chanpos], dnid, e->ring.callednum);
+						ast_copy_string(pri->pvts[chanpos]->exten, e->ring.callednum, sizeof(pri->pvts[chanpos]->exten));
+						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
 					} else
-						ast_string_field_set(pri->pvts[chanpos], exten, "");
+						pri->pvts[chanpos]->exten[0] = '\0';
 					/* Set DNID on all incoming calls -- even immediate */
 					if (!ast_strlen_zero(e->ring.callednum))
-						ast_string_field_set(pri->pvts[chanpos], dnid, e->ring.callednum);
+						ast_copy_string(pri->pvts[chanpos]->dnid, e->ring.callednum, sizeof(pri->pvts[chanpos]->dnid));
 					/* No number yet, but received "sending complete"? */
 					if (e->ring.complete && (ast_strlen_zero(e->ring.callednum))) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Going to extension s|1 because of Complete received\n");
-						ast_string_field_set(pri->pvts[chanpos], exten, "s");
+						pri->pvts[chanpos]->exten[0] = 's';
+						pri->pvts[chanpos]->exten[1] = '\0';
 					}
 					/* Make sure extension exists (or in overlap dial mode, can exist) */
 					if ((pri->overlapdial && ast_canmatch_extension(NULL, pri->pvts[chanpos]->context, pri->pvts[chanpos]->exten, 1, pri->pvts[chanpos]->cid_num)) ||
@@ -8736,7 +8731,7 @@
 									pri->pvts[chanpos]->prioffset, pri->span);
 						pri_hangup(pri->pri, e->ring.call, PRI_CAUSE_UNALLOCATED);
 						pri->pvts[chanpos]->call = NULL;
-						ast_string_field_set(pri->pvts[chanpos], exten, "");
+						pri->pvts[chanpos]->exten[0] = '\0';
 					}
 					if (crv)
 						ast_mutex_unlock(&crv->lock);
@@ -8874,8 +8869,8 @@
 					} else {
 						/* Re-use *69 field for PRI */
 						ast_mutex_lock(&pri->pvts[chanpos]->lock);
-						ast_string_field_set(pri->pvts[chanpos], lastcid_num, e->facname.callingnum);
-						ast_string_field_set(pri->pvts[chanpos], lastcid_name, e->facname.callingname);
+						ast_copy_string(pri->pvts[chanpos]->lastcid_num, e->facname.callingnum, sizeof(pri->pvts[chanpos]->lastcid_num));
+						ast_copy_string(pri->pvts[chanpos]->lastcid_name, e->facname.callingname, sizeof(pri->pvts[chanpos]->lastcid_name));
 						pri->pvts[chanpos]->subs[SUB_REAL].needcallerid =1;
 						zt_enable_ec(pri->pvts[chanpos]);
 						ast_mutex_unlock(&pri->pvts[chanpos]->lock);
@@ -10398,7 +10393,6 @@
 				if (cur_outsignalling < 0) cur_outsignalling = cur_signalling;
 				for (x = start; x <= finish; x++) {
 #ifdef HAVE_LIBPRI
-					ast_verbose("channel: %d  cur_sig: %d  cur_outsig: %d  cur_radio: %d\n", x, cur_signalling, cur_outsignalling, cur_radio);
 					tmp = mkintf(x, cur_signalling, cur_outsignalling, cur_radio, pri, reload);
 #else					
 					tmp = mkintf(x, cur_signalling, cur_outsignalling, cur_radio, NULL, reload);
@@ -10415,9 +10409,9 @@
 						}
 					} else {
 						if (reload == 1)
-							ast_log(LOG_ERROR, "Unable to reconfigure channel '%d'\n", x);
+							ast_log(LOG_ERROR, "Unable to reconfigure channel '%s'\n", v->value);
 						else
-							ast_log(LOG_ERROR, "Unable to register channel '%d'\n", x);
+							ast_log(LOG_ERROR, "Unable to register channel '%s'\n", v->value);
 						ast_config_destroy(cfg);
 						ast_mutex_unlock(&iflock);
 						return -1;



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:38:35 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:38:35 +0200
Subject: [solid-pbx-svn] r287 - in trunk/channels: . misdn
Message-ID: <200606182238.k5IMcZ5w022565@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:38:32 +0200 (Mon, 19 Jun 2006)
New Revision: 287

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
Log:
Update to Asterisk SVN trunk r32783

------------------------------------------------------------------------
r32779 | crichter | 2006-06-07 15:01:02 +0200 (Wed, 07 Jun 2006) | 1 line

changed the clean_up_bc function to work proper again. fixed the print with the conference nr. when bridged
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-18 22:37:53 UTC (rev 286)
+++ trunk/channels/chan_misdn.c	2006-06-18 22:38:32 UTC (rev 287)
@@ -2273,7 +2273,7 @@
 		}
 		
 		/* trying to make a mISDN_dsp conference */
-		chan_misdn_log(1, ch1->bc->port, "I SEND: Making conference with Number:%d\n", (ch1->bc->pid<<1) +1);
+		chan_misdn_log(1, ch1->bc->port, "I SEND: Making conference with Number:%d\n", ch1->bc->pid +1);
 
 		misdn_lib_bridge(ch1->bc,ch2->bc);
 	}
@@ -2281,7 +2281,7 @@
 	if (option_verbose > 2) 
 		ast_verbose(VERBOSE_PREFIX_3 "Native bridging %s and %s\n", c0->name, c1->name);
 
-	chan_misdn_log(1, ch1->bc->port, "* Makeing Native Bridge between %s and %s\n", ch1->bc->oad, ch2->bc->oad);
+	chan_misdn_log(1, ch1->bc->port, "* Making Native Bridge between %s and %s\n", ch1->bc->oad, ch2->bc->oad);
   
 	while(1) {
 		to=-1;

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-18 22:37:53 UTC (rev 286)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-18 22:38:32 UTC (rev 287)
@@ -591,17 +591,16 @@
 		manager_ec_disable(bc);
 	}
 
-	if (bc->bc_state == BCHAN_SETUP) 
-		mISDN_write_frame(stack->midev, buff, bc->layer_id|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
-	else
-		mISDN_write_frame(stack->midev, buff, bc->addr|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
+	
+	mISDN_write_frame(stack->midev, buff, bc->layer_id|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
 
+#if 0
 	cb_log(3, stack->port, "$$$ CLEARING STACK\n");
-	
 	ret=mISDN_clear_stack(stack->midev,bc->b_stid);
 	if (ret<0 && errno) {
 		cb_log(-1,stack->port,"clear stack failed [%s]\n",strerror(errno));
 	}
+#endif
 
 	bc->b_stid = 0;
 	bc_state_change(bc, BCHAN_CLEANED);



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:39:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:39:38 +0200
Subject: [solid-pbx-svn] r288 - in trunk: apps build_tools cdr channels codecs formats funcs pbx res
Message-ID: <200606182239.k5IMdcZA022994@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:39:34 +0200 (Mon, 19 Jun 2006)
New Revision: 288

Modified:
   trunk/apps/Makefile
   trunk/build_tools/menuselect.c
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/formats/Makefile
   trunk/funcs/Makefile
   trunk/pbx/Makefile
   trunk/res/Makefile
Log:
Update to Asterisk SVN trunk r32803

------------------------------------------------------------------------
r32798 | russell | 2006-06-07 18:03:31 +0200 (Wed, 07 Jun 2006) | 4 lines

remove the need to have to re-run make after a default menuselect.makeopts
file is generated.  This allows a fresh checkout of asterisk to be built
and installed with the standard "./configure && make && make install".

------------------------------------------------------------------------


Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/apps/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_APPS),$(patsubst %.c,%,$(wildcard app_*.c)))
 
 # If you have UnixODBC you can use ODBC voicemail

Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/build_tools/menuselect.c	2006-06-18 22:39:34 UTC (rev 288)
@@ -698,14 +698,6 @@
 	free_trees();
 	free_member_list();
 
-	if (check_deps && !existing_config && !res) {
-		fprintf(stderr, "\n***********************************************************\n");
-		fprintf(stderr, "* menuselect.makeopts file generated with default values! *\n");
-		fprintf(stderr, "* Please rerun make to build Asterisk.                    *\n");
-		fprintf(stderr, "***********************************************************\n\n");
-		res = -1;
-	}
-
 	/* In some cases, such as modifying the CFLAGS for the build,
 	 * a "make clean" needs to be forced.  Removing the .lastclean 
 	 * file does this. */

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/cdr/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_CDR),$(patsubst %.c,%,$(wildcard cdr_*.c)))
 
 #The problem with sparc is the best stuff is in newer versions of gcc (post 3.0) only.

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/channels/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_CHANNELS),$(patsubst %.c,%,$(wildcard chan_*.c)))
 
 ifeq ($(PROC),sparc64)

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/codecs/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_CODECS),$(patsubst %.c,%,$(wildcard codec_*.c)))
 
 ifeq ($(wildcard ilbc/iLBC_decode.h),)

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/formats/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_FORMATS),$(patsubst %.c,%,$(wildcard format_*.c)))
 
 GSMLIB=../codecs/gsm/lib/libgsm.a

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/funcs/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_FUNCS),$(patsubst %.c,%,$(wildcard func_*.c)))
 
 # TODO This check needs to be handled with autoconf

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/pbx/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_PBX),$(patsubst %.c,%,$(wildcard pbx_*.c)))
 
 MOC=$(QTDIR)/bin/moc

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-18 22:38:32 UTC (rev 287)
+++ trunk/res/Makefile	2006-06-18 22:39:34 UTC (rev 288)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+include ../menuselect.makeopts
+
 SELECTED_MODS:=$(filter-out $(MENUSELECT_RES),$(patsubst %.c,%,$(wildcard res_*.c)))
 
 ifeq ($(OSARCH),FreeBSD)



From solid-pbx-svn-admin at lists.berlios.de  Mon Jun 19 00:41:22 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Mon, 19 Jun 2006 00:41:22 +0200
Subject: [solid-pbx-svn] r289 - in trunk: . channels include/asterisk
Message-ID: <200606182241.k5IMfMfK023366@sheep.berlios.de>

Author: casper2
Date: 2006-06-19 00:41:08 +0200 (Mon, 19 Jun 2006)
New Revision: 289

Modified:
   trunk/channels/chan_iax2.c
   trunk/dnsmgr.c
   trunk/include/asterisk/dnsmgr.h
Log:
Update to Asterisk SVN trunk r32823

------------------------------------------------------------------------
r32817 | russell | 2006-06-07 19:44:36 +0200 (Wed, 07 Jun 2006) | 3 lines

add an updated patch that adds dnsmgr support for outgoing iax2 registrations
(issue #6305, by ivanfm, with mods)

------------------------------------------------------------------------
r32819 | russell | 2006-06-07 19:54:26 +0200 (Wed, 07 Jun 2006) | 10 lines

Merged revisions 32818 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r32818 | russell | 2006-06-07 13:53:21 -0400 (Wed, 07 Jun 2006) | 2 lines

fix some broken code with BRIDGE_OPTIMIZATION defined (issue #7292)

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 22:39:34 UTC (rev 288)
+++ trunk/channels/chan_iax2.c	2006-06-18 22:41:08 UTC (rev 289)
@@ -416,6 +416,7 @@
 	int callno;				/*!< Associated call number if applicable */
 	struct sockaddr_in us;			/*!< Who the server thinks we are */
 	struct iax2_registry *next;
+	struct ast_dnsmgr_entry *dnsmgr;	/*!< DNS refresh manager */
 };
 
 static struct iax2_registry *registrations;
@@ -4304,8 +4305,8 @@
 
 static int iax2_show_registry(int fd, int argc, char *argv[])
 {
-#define FORMAT2 "%-20.20s  %-10.10s  %-20.20s %8.8s  %s\n"
-#define FORMAT "%-20.20s  %-10.10s  %-20.20s %8d  %s\n"
+#define FORMAT2 "%-20.20s  %-6.6s  %-10.10s  %-20.20s %8.8s  %s\n"
+#define FORMAT  "%-20.20s  %-6.6s  %-10.10s  %-20.20s %8d  %s\n"
 	struct iax2_registry *reg = NULL;
 
 	char host[80];
@@ -4314,7 +4315,7 @@
 	if (argc != 3)
 		return RESULT_SHOWUSAGE;
 	AST_LIST_LOCK(&peers);
-	ast_cli(fd, FORMAT2, "Host", "Username", "Perceived", "Refresh", "State");
+	ast_cli(fd, FORMAT2, "Host", "dnsmgr", "Username", "Perceived", "Refresh", "State");
 	for (reg = registrations;reg;reg = reg->next) {
 		snprintf(host, sizeof(host), "%s:%d", ast_inet_ntoa(iabuf, sizeof(iabuf), reg->addr.sin_addr), ntohs(reg->addr.sin_port));
 		if (reg->us.sin_addr.s_addr) 
@@ -4322,6 +4323,7 @@
 		else
 			ast_copy_string(perceived, "<Unregistered>", sizeof(perceived));
 		ast_cli(fd, FORMAT, host, 
+					(reg->dnsmgr) ? "Y" : "N", 
 					reg->username, perceived, reg->refresh, regstate2str(reg->regstate));
 	}
 	AST_LIST_UNLOCK(&peers);
@@ -5447,7 +5449,6 @@
 	char *porta;
 	char *stringp=NULL;
 	
-	struct ast_hostent ahp; struct hostent *hp;
 	if (!value)
 		return -1;
 	ast_copy_string(copy, value, sizeof(copy));
@@ -5469,20 +5470,18 @@
 		ast_log(LOG_WARNING, "%s is not a valid port number at line %d\n", porta, lineno);
 		return -1;
 	}
-	hp = ast_gethostbyname(hostname, &ahp);
-	if (!hp) {
-		ast_log(LOG_WARNING, "Host '%s' not found at line %d\n", hostname, lineno);
+	if (!(reg = ast_calloc(1, sizeof(*reg))))
 		return -1;
+	if (ast_dnsmgr_lookup(hostname, &reg->addr.sin_addr, &reg->dnsmgr) < 0) {
+		free(reg);
+		return -1;
 	}
-	if (!(reg = ast_calloc(1, sizeof(*reg))))
-		return -1;
 	ast_copy_string(reg->username, username, sizeof(reg->username));
 	if (secret)
 		ast_copy_string(reg->secret, secret, sizeof(reg->secret));
 	reg->expire = -1;
 	reg->refresh = IAX_DEFAULT_REG_EXPIRE;
 	reg->addr.sin_family = AF_INET;
-	memcpy(&reg->addr.sin_addr, hp->h_addr, sizeof(&reg->addr.sin_addr));
 	reg->addr.sin_port = porta ? htons(atoi(porta)) : htons(IAX_DEFAULT_PORTNO);
 	reg->next = registrations;
 	reg->callno = 0;
@@ -6417,9 +6416,9 @@
 									iax_frame_wrap(fr, &f);
 #ifdef BRIDGE_OPTIMIZATION
 									if (iaxs[fr->callno]->bridgecallno) {
-										forward_delivery(&fr);
+										forward_delivery(fr);
 									} else {
-										duped_fr = iaxfrdup2(&fr);
+										duped_fr = iaxfrdup2(fr);
 										if (duped_fr) {
 											schedule_delivery(duped_fr, updatehistory, 1, &fr->ts);
 										}
@@ -7644,9 +7643,9 @@
 	}
 #ifdef BRIDGE_OPTIMIZATION
 	if (iaxs[fr->callno]->bridgecallno) {
-		forward_delivery(&fr);
+		forward_delivery(fr);
 	} else {
-		duped_fr = iaxfrdup2(&fr);
+		duped_fr = iaxfrdup2(fr);
 		if (duped_fr) {
 			schedule_delivery(duped_fr, updatehistory, 0, &fr->ts);
 		}
@@ -7759,6 +7758,31 @@
 	struct iax_ie_data ied;
 	if (option_debug && iaxdebug)
 		ast_log(LOG_DEBUG, "Sending registration request for '%s'\n", reg->username);
+
+	if (reg->dnsmgr && 
+	    ((reg->regstate == REG_STATE_TIMEOUT) || !reg->addr.sin_addr.s_addr)) {
+		/* Maybe the IP has changed, force DNS refresh */
+		ast_dnsmgr_refresh(reg->dnsmgr);
+	}
+	
+	/*
+	 * if IP has Changed, free allocated call to create a new one with new IP
+	 * call has the pointer to IP and must be updated to the new one
+	 */
+	if (reg->dnsmgr && ast_dnsmgr_changed(reg->dnsmgr) && (reg->callno > 0)) {
+		iax2_destroy(reg->callno);
+		reg->callno = 0;
+	}
+	if (!reg->addr.sin_addr.s_addr) {
+		if (option_debug && iaxdebug)
+			ast_log(LOG_DEBUG, "Unable to send registration request for '%s' without IP address\n", reg->username);
+		/* Setup the next registration attempt */
+		if (reg->expire > -1)
+			ast_sched_del(sched, reg->expire);
+		reg->expire  = ast_sched_add(sched, (5 * reg->refresh / 6) * 1000, iax2_do_register_s, reg);
+		return -1;
+	}
+
 	if (!reg->callno) {
 		if (option_debug)
 			ast_log(LOG_DEBUG, "Allocate call number\n");
@@ -8651,6 +8675,8 @@
 			}
 			ast_mutex_unlock(&iaxsl[regl->callno]);
 		}
+		if (regl->dnsmgr)
+			ast_dnsmgr_release(regl->dnsmgr);
 		free(regl);
 	}
 	registrations = NULL;

Modified: trunk/dnsmgr.c
===================================================================
--- trunk/dnsmgr.c	2006-06-18 22:39:34 UTC (rev 288)
+++ trunk/dnsmgr.c	2006-06-18 22:41:08 UTC (rev 289)
@@ -53,8 +53,15 @@
 static pthread_t refresh_thread = AST_PTHREADT_NULL;
 
 struct ast_dnsmgr_entry {
+	/*! where we will store the resulting address */
 	struct in_addr *result;
+	/*! the last result, used to check if address has changed */
+	struct in_addr last;
+	/*! Set to 1 if the entry changes */
+	int changed:1;
+	ast_mutex_t lock;
 	AST_LIST_ENTRY(ast_dnsmgr_entry) list;
+	/*! just 1 here, but we use calloc to allocate the correct size */
 	char name[1];
 };
 
@@ -87,6 +94,7 @@
 		return NULL;
 
 	entry->result = result;
+	ast_mutex_init(&entry->lock);
 	strcpy(entry->name, name);
 
 	AST_LIST_LOCK(&entry_list);
@@ -104,6 +112,10 @@
 	AST_LIST_LOCK(&entry_list);
 	AST_LIST_REMOVE(&entry_list, entry, list);
 	AST_LIST_UNLOCK(&entry_list);
+	if (option_verbose > 3)
+		ast_verbose(VERBOSE_PREFIX_4 "removing dns manager for '%s'\n", entry->name);
+
+	ast_mutex_destroy(&entry->lock);
 	free(entry);
 }
 
@@ -116,7 +128,7 @@
 		return 0;
 
 	if (option_verbose > 3)
-		ast_verbose(VERBOSE_PREFIX_3 "doing lookup for '%s'\n", name);
+		ast_verbose(VERBOSE_PREFIX_4 "doing dnsmgr_lookup for '%s'\n", name);
 
 	/* if it's actually an IP address and not a name,
 	   there's no need for a managed lookup */
@@ -134,12 +146,68 @@
 		return 0;
 	} else {
 		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_2 "adding manager for '%s'\n", name);
+			ast_verbose(VERBOSE_PREFIX_2 "adding dns manager for '%s'\n", name);
 		*dnsmgr = ast_dnsmgr_get(name, result);
 		return !*dnsmgr;
 	}
 }
 
+/*
+ * Refresh a dnsmgr entry
+ */
+static int dnsmgr_refresh(struct ast_dnsmgr_entry *entry, int verbose)
+{
+	struct ast_hostent ahp;
+	struct hostent *hp;
+	char iabuf[INET_ADDRSTRLEN];
+	char iabuf2[INET_ADDRSTRLEN];
+	struct in_addr tmp;
+	int changed = 0;
+        
+	ast_mutex_lock(&entry->lock);
+	if (verbose && (option_verbose > 2))
+		ast_verbose(VERBOSE_PREFIX_2 "refreshing '%s'\n", entry->name);
+
+	if ((hp = ast_gethostbyname(entry->name, &ahp))) {
+		/* check to see if it has changed, do callback if requested (where de callback is defined ????) */
+		memcpy(&tmp, hp->h_addr, sizeof(tmp));
+		if (tmp.s_addr != entry->last.s_addr) {
+			ast_log(LOG_NOTICE, "host '%s' changed from %s to %s\n", 
+				entry->name,
+				ast_inet_ntoa(iabuf, sizeof(iabuf), entry->last),
+				ast_inet_ntoa(iabuf2, sizeof(iabuf2), tmp));
+			memcpy(entry->result, hp->h_addr, sizeof(entry->result));
+			memcpy(&entry->last, hp->h_addr, sizeof(entry->last));
+			changed = entry->changed = 1;
+		} 
+		
+	}
+	ast_mutex_unlock(&entry->lock);
+	return changed;
+}
+
+int ast_dnsmgr_refresh(struct ast_dnsmgr_entry *entry)
+{
+	return dnsmgr_refresh(entry, 0);
+}
+
+/*
+ * Check if dnsmgr entry has changed from since last call to this function
+ */
+int ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry) 
+{
+	int changed;
+
+	ast_mutex_lock(&entry->lock);
+
+	changed = entry->changed;
+	entry->changed = 0;
+
+	ast_mutex_unlock(&entry->lock);
+	
+	return changed;
+}
+
 static void *do_refresh(void *data)
 {
 	for (;;) {
@@ -155,8 +223,6 @@
 {
 	struct refresh_info *info = data;
 	struct ast_dnsmgr_entry *entry;
-	struct ast_hostent ahp;
-	struct hostent *hp;
 
 	/* if a refresh or reload is already in progress, exit now */
 	if (ast_mutex_trylock(&refresh_lock)) {
@@ -172,13 +238,7 @@
 		if (info->regex_present && regexec(&info->filter, entry->name, 0, NULL, 0))
 		    continue;
 
-		if (info->verbose && (option_verbose > 2))
-			ast_verbose(VERBOSE_PREFIX_2 "refreshing '%s'\n", entry->name);
-
-		if ((hp = ast_gethostbyname(entry->name, &ahp))) {
-			/* check to see if it has changed, do callback if requested */
-			memcpy(entry->result, hp->h_addr, sizeof(entry->result));
-		}
+		dnsmgr_refresh(entry, info->verbose);
 	}
 	AST_LIST_UNLOCK(info->entries);
 

Modified: trunk/include/asterisk/dnsmgr.h
===================================================================
--- trunk/include/asterisk/dnsmgr.h	2006-06-18 22:39:34 UTC (rev 288)
+++ trunk/include/asterisk/dnsmgr.h	2006-06-18 22:41:08 UTC (rev 289)
@@ -37,6 +37,24 @@
 
 int ast_dnsmgr_lookup(const char *name, struct in_addr *result, struct ast_dnsmgr_entry **dnsmgr);
 
+/*!
+ * \brief Force a refresh of a dnsmgr entry
+ *
+ * \retval non-zero if the result is different than the previous result
+ * \retval zero if the result is the same as the previous result 
+ */
+int ast_dnsmgr_refresh(struct ast_dnsmgr_entry *entry);
+
+/*!
+ * \brief Check is see if a dnsmgr entry has changed
+ *
+ * \retval non-zero if the dnsmgr entry has changed since the last call to
+ *                  this function
+ * \retval zero     if the dnsmgr entry has not changed since the last call to
+ *                  this function
+ */
+int ast_dnsmgr_changed(struct ast_dnsmgr_entry *entry);
+
 #if defined(__cplusplus) || defined(c_plusplus)
 }
 #endif /* c_plusplus */



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:06:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:06:45 +0200
Subject: [solid-pbx-svn] r290 - in trunk: . apps build_tools cdr channels codecs doc formats funcs include include/asterisk pbx pbx/ael res stdtime utils
Message-ID: <200606231706.k5NH6j4C016594@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:05:10 +0200 (Fri, 23 Jun 2006)
New Revision: 290

Modified:
   trunk/Makefile
   trunk/abstract_jb.c
   trunk/acl.c
   trunk/app.c
   trunk/apps/app_adsiprog.c
   trunk/apps/app_alarmreceiver.c
   trunk/apps/app_chanisavail.c
   trunk/apps/app_dial.c
   trunk/apps/app_externalivr.c
   trunk/apps/app_festival.c
   trunk/apps/app_flash.c
   trunk/apps/app_followme.c
   trunk/apps/app_hasnewvoicemail.c
   trunk/apps/app_ices.c
   trunk/apps/app_meetme.c
   trunk/apps/app_mp3.c
   trunk/apps/app_nbscat.c
   trunk/apps/app_playback.c
   trunk/apps/app_queue.c
   trunk/apps/app_sms.c
   trunk/apps/app_test.c
   trunk/apps/app_voicemail.c
   trunk/apps/app_zapbarge.c
   trunk/apps/app_zapras.c
   trunk/apps/app_zapscan.c
   trunk/ast_expr2.c
   trunk/ast_expr2.fl
   trunk/ast_expr2.y
   trunk/ast_expr2f.c
   trunk/asterisk.c
   trunk/autoservice.c
   trunk/build_tools/cflags.xml
   trunk/callerid.c
   trunk/cdr.c
   trunk/cdr/cdr_csv.c
   trunk/cdr/cdr_custom.c
   trunk/cdr/cdr_odbc.c
   trunk/cdr/cdr_radius.c
   trunk/cdr/cdr_tds.c
   trunk/channel.c
   trunk/channels/chan_agent.c
   trunk/channels/chan_alsa.c
   trunk/channels/chan_features.c
   trunk/channels/chan_iax2.c
   trunk/channels/chan_jingle.c
   trunk/channels/chan_local.c
   trunk/channels/chan_mgcp.c
   trunk/channels/chan_misdn.c
   trunk/channels/chan_nbs.c
   trunk/channels/chan_oss.c
   trunk/channels/chan_phone.c
   trunk/channels/chan_sip.c
   trunk/channels/chan_skinny.c
   trunk/channels/chan_zap.c
   trunk/channels/iax2-parser.c
   trunk/channels/iax2-provision.c
   trunk/channels/misdn_config.c
   trunk/cli.c
   trunk/codecs/codec_a_mu.c
   trunk/codecs/codec_adpcm.c
   trunk/codecs/codec_alaw.c
   trunk/codecs/codec_g723_1.c
   trunk/codecs/codec_g726.c
   trunk/codecs/codec_gsm.c
   trunk/codecs/codec_ilbc.c
   trunk/codecs/codec_lpc10.c
   trunk/codecs/codec_speex.c
   trunk/codecs/codec_ulaw.c
   trunk/config.c
   trunk/configure.ac
   trunk/cryptostub.c
   trunk/db.c
   trunk/dns.c
   trunk/dnsmgr.c
   trunk/doc/smdi.txt
   trunk/dsp.c
   trunk/enum.c
   trunk/file.c
   trunk/fixedjitterbuf.c
   trunk/formats/format_g729.c
   trunk/formats/format_gsm.c
   trunk/formats/format_ilbc.c
   trunk/formats/format_ogg_vorbis.c
   trunk/formats/format_sln.c
   trunk/formats/format_wav.c
   trunk/formats/format_wav_gsm.c
   trunk/funcs/func_channel.c
   trunk/funcs/func_global.c
   trunk/http.c
   trunk/image.c
   trunk/include/asterisk.h
   trunk/include/asterisk/callerid.h
   trunk/include/autoconfig.h.in
   trunk/logger.c
   trunk/manager.c
   trunk/netsock.c
   trunk/pbx.c
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael.tab.c
   trunk/pbx/ael/ael.y
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/dundi-parser.c
   trunk/pbx/pbx_ael.c
   trunk/pbx/pbx_config.c
   trunk/pbx/pbx_dundi.c
   trunk/pbx/pbx_gtkconsole.c
   trunk/pbx/pbx_spool.c
   trunk/privacy.c
   trunk/res/res_adsi.c
   trunk/res/res_agi.c
   trunk/res/res_crypto.c
   trunk/res/res_features.c
   trunk/res/res_indications.c
   trunk/res/res_jabber.c
   trunk/res/res_musiconhold.c
   trunk/res/res_osp.c
   trunk/res/res_smdi.c
   trunk/rtp.c
   trunk/say.c
   trunk/sched.c
   trunk/srv.c
   trunk/stdtime/localtime.c
   trunk/strcompat.c
   trunk/tdd.c
   trunk/term.c
   trunk/translate.c
   trunk/udptl.c
   trunk/utils.c
   trunk/utils/ael_main.c
   trunk/utils/astman.c
   trunk/utils/smsq.c
Log:
Update to Asterisk SVN trunk r32853

------------------------------------------------------------------------
r32845 | russell | 2006-06-07 20:28:29 +0200 (Wed, 07 Jun 2006) | 2 lines

remove the WITH_SMDI define

------------------------------------------------------------------------
r32846 | kpfleming | 2006-06-07 20:54:56 +0200 (Wed, 07 Jun 2006) | 2 lines

simplify autoconfig include mechanism (make tholo happy he can use lint again :-)

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/Makefile	2006-06-23 17:05:10 UTC (rev 290)
@@ -127,9 +127,9 @@
   include makeopts
 endif
 
-TOPDIR_CFLAGS=-include include/autoconfig.h -Iinclude
-MOD_SUBDIR_CFLAGS=-include ../include/autoconfig.h -I../include -I..
-OTHER_SUBDIR_CFLAGS=-include ../include/autoconfig.h -I../include -I..
+TOPDIR_CFLAGS=-Iinclude
+MOD_SUBDIR_CFLAGS=-I../include -I..
+OTHER_SUBDIR_CFLAGS=-I../include -I..
 
 ifeq ($(findstring dont-optimize,$(MAKECMDGOALS)),)
   ifeq ($(findstring DONT_OPTIMIZE,$(MENUSELECT_CFLAGS)),)

Modified: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/abstract_jb.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,14 +26,14 @@
  * \author Slav Klenov <slav at securax.org>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <limits.h>
 
-#include "asterisk.h"
-
-ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
-
 #include "asterisk/frame.h"
 #include "asterisk/channel.h"
 #include "asterisk/logger.h"

Modified: trunk/acl.c
===================================================================
--- trunk/acl.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/acl.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/app.c
===================================================================
--- trunk/app.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/app.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/apps/app_adsiprog.c
===================================================================
--- trunk/apps/app_adsiprog.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_adsiprog.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <stdlib.h>

Modified: trunk/apps/app_alarmreceiver.c
===================================================================
--- trunk/apps/app_alarmreceiver.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_alarmreceiver.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,13 +22,17 @@
  * 
  * *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** 
  *
- * Use at your own risk. Please consult the GNU GPL license document included with Asterisk details. *
+ * Use at your own risk. Please consult the GNU GPL license document included with Asterisk.         *
  *
  * *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING *** WARNING ***
  *
  * \ingroup applications
  */ 
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <string.h>
 #include <stdlib.h>
 #include <stdio.h>

Modified: trunk/apps/app_chanisavail.c
===================================================================
--- trunk/apps/app_chanisavail.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_chanisavail.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_dial.c
===================================================================
--- trunk/apps/app_dial.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_dial.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>

Modified: trunk/apps/app_externalivr.c
===================================================================
--- trunk/apps/app_externalivr.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_externalivr.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -52,7 +52,6 @@
 #include "asterisk/utils.h"
 #include "asterisk/options.h"
 
-
 static const char *app = "ExternalIVR";
 
 static const char *synopsis = "Interfaces with an external IVR application";

Modified: trunk/apps/app_festival.c
===================================================================
--- trunk/apps/app_festival.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_festival.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdlib.h>
 #include <unistd.h>

Modified: trunk/apps/app_flash.c
===================================================================
--- trunk/apps/app_flash.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_flash.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<depend>zaptel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_followme.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,17 +26,16 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
 
+ASTERISK_FILE_VERSION(__FILE__, "$revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <unistd.h>
 #include <string.h>
 #include <signal.h>
 
-#include "asterisk.h"
-
-ASTERISK_FILE_VERSION(__FILE__, "$revision$")
-
 #include "asterisk/lock.h"
 #include "asterisk/file.h"
 #include "asterisk/logger.h"

Modified: trunk/apps/app_hasnewvoicemail.c
===================================================================
--- trunk/apps/app_hasnewvoicemail.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_hasnewvoicemail.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -32,6 +32,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_ices.c
===================================================================
--- trunk/apps/app_ices.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_ices.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup applications
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <string.h>
 #include <stdio.h>
 #include <signal.h>

Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_meetme.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<depend>zaptel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_mp3.c
===================================================================
--- trunk/apps/app_mp3.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_mp3.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup applications
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <string.h>
 #include <stdio.h>
 #include <signal.h>

Modified: trunk/apps/app_nbscat.c
===================================================================
--- trunk/apps/app_nbscat.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_nbscat.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup applications
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <string.h>
 #include <stdio.h>
 #include <signal.h>

Modified: trunk/apps/app_playback.c
===================================================================
--- trunk/apps/app_playback.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_playback.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -43,7 +43,6 @@
 #include "asterisk/utils.h"
 #include "asterisk/options.h"
 #include "asterisk/app.h"
-
 #include "asterisk/cli.h"
 #include "asterisk/localtime.h"
 #include "asterisk/say.h"

Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_queue.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -56,6 +56,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>

Modified: trunk/apps/app_sms.c
===================================================================
--- trunk/apps/app_sms.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_sms.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  * \author Adrian Kennard
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_test.c
===================================================================
--- trunk/apps/app_test.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_test.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \ingroup applications
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_voicemail.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -41,6 +41,10 @@
  *				 Bartosz Supczinski <Bartosz.Supczinski at dir.pl>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>
@@ -75,10 +79,8 @@
 #include "asterisk/cli.h"
 #include "asterisk/utils.h"
 #include "asterisk/stringfields.h"
-#ifdef WITH_SMDI
 #include "asterisk/smdi.h"
 #define SMDI_MWI_WAIT_TIMEOUT 1000 /* 1 second */
-#endif
 #ifdef USE_ODBC_STORAGE
 #include "asterisk/res_odbc.h"
 #endif
@@ -408,9 +410,7 @@
 static char serveremail[80];
 static char mailcmd[160];	/* Configurable mail cmd */
 static char externnotify[160]; 
-#ifdef WITH_SMDI
 static struct ast_smdi_interface *smdi_iface = NULL;
-#endif
 static char vmfmts[80];
 static int vmminmessage;
 static int vmmaxmessage;
@@ -2348,16 +2348,13 @@
 	char arguments[255];
 	char ext_context[256] = "";
 	int newvoicemails = 0, oldvoicemails = 0;
-#ifdef WITH_SMDI
 	struct ast_smdi_mwi_message *mwi_msg;
-#endif
 
 	if (!ast_strlen_zero(context))
 		snprintf(ext_context, sizeof(ext_context), "%s@%s", extension, context);
 	else
 		ast_copy_string(ext_context, extension, sizeof(ext_context));
 
-#ifdef WITH_SMDI
 	if (!strcasecmp(externnotify, "smdi")) {
 		if (ast_app_has_voicemail(ext_context, NULL)) 
 			ast_smdi_mwi_set(smdi_iface, extension);
@@ -2376,9 +2373,6 @@
 			ast_log(LOG_DEBUG, "Successfully executed SMDI MWI change for %s on %s\n", extension, smdi_iface->name);
 		}
 	} else if (!ast_strlen_zero(externnotify)) {
-#else
-	if (!ast_strlen_zero(externnotify)) {
-#endif
 		if (inboxcount(ext_context, &newvoicemails, &oldvoicemails)) {
 			ast_log(LOG_ERROR, "Problem in calculating number of voicemail messages available for extension %s\n", extension);
 		} else {
@@ -6136,9 +6130,7 @@
 	char *cat;
 	struct ast_variable *var;
 	char *notifystr = NULL;
-#ifdef WITH_SMDI
 	char *smdistr = NULL;
-#endif
 	char *astattach;
 	char *astsearch;
 	char *astsaycid;
@@ -6245,7 +6237,6 @@
 		if ((notifystr = ast_variable_retrieve(cfg, "general", "externnotify"))) {
 			ast_copy_string(externnotify, notifystr, sizeof(externnotify));
 			ast_log(LOG_DEBUG, "found externnotify: %s\n", externnotify);
-#ifdef WITH_SMDI
 			if (!strcasecmp(externnotify, "smdi")) {
 				ast_log(LOG_DEBUG, "Using SMDI for external voicemail notification\n");
 				if ((smdistr = ast_variable_retrieve(cfg, "general", "smdiport"))) {
@@ -6262,7 +6253,6 @@
 					ast_log(LOG_DEBUG, "Using SMDI port %s\n", smdi_iface->name);
 				}
 			}
-#endif
 		} else {
 			externnotify[0] = '\0';
 		}

Modified: trunk/apps/app_zapbarge.c
===================================================================
--- trunk/apps/app_zapbarge.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_zapbarge.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -35,6 +35,10 @@
 	<depend>zaptel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/apps/app_zapras.c
===================================================================
--- trunk/apps/app_zapras.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_zapras.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<depend>zaptel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/ioctl.h>
 #include <sys/wait.h>
 #ifdef __linux__

Modified: trunk/apps/app_zapscan.c
===================================================================
--- trunk/apps/app_zapscan.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/apps/app_zapscan.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -34,6 +34,10 @@
 	<depend>zaptel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/ast_expr2.c
===================================================================
--- trunk/ast_expr2.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/ast_expr2.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -129,6 +129,10 @@
  * $FreeBSD: src/bin/expr/expr.y,v 1.16 2000/07/22 10:59:36 se Exp $
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>

Modified: trunk/ast_expr2.fl
===================================================================
--- trunk/ast_expr2.fl	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/ast_expr2.fl	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  * \brief Dialplan Expression Lexical Scanner
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>

Modified: trunk/ast_expr2.y
===================================================================
--- trunk/ast_expr2.y	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/ast_expr2.y	2006-06-23 17:05:10 UTC (rev 290)
@@ -12,6 +12,10 @@
  * $FreeBSD: src/bin/expr/expr.y,v 1.16 2000/07/22 10:59:36 se Exp $
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>

Modified: trunk/ast_expr2f.c
===================================================================
--- trunk/ast_expr2f.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/ast_expr2f.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -1354,6 +1354,10 @@
  * \brief Dialplan Expression Lexical Scanner
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/asterisk.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -57,6 +57,10 @@
   
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/time.h>
@@ -122,7 +126,6 @@
 #include "asterisk/version.h"
 #include "asterisk/linkedlists.h"
 #include "asterisk/devicestate.h"
-#include "asterisk/compat.h"
 
 #include "asterisk/doxyref.h"		/* Doxygen documentation */
 

Modified: trunk/autoservice.c
===================================================================
--- trunk/autoservice.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/autoservice.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/build_tools/cflags.xml
===================================================================
--- trunk/build_tools/cflags.xml	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/build_tools/cflags.xml	2006-06-23 17:05:10 UTC (rev 290)
@@ -21,7 +21,4 @@
 		</member>
 		<member name="TRACE_FRAMES" displayname="Trace Frame Allocations">
 		</member>
-		<member name="WITH_SMDI" displayname="Include SMDI Support">
-			<defaultenabled>yes</defaultenabled>
-		</member>
 	</category>

Modified: trunk/callerid.c
===================================================================
--- trunk/callerid.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/callerid.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <time.h>
 #include <string.h>
 #include <stdio.h>

Modified: trunk/cdr/cdr_csv.c
===================================================================
--- trunk/cdr/cdr_csv.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cdr/cdr_csv.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -28,6 +28,10 @@
  * \ingroup cdr_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/cdr/cdr_custom.c
===================================================================
--- trunk/cdr/cdr_custom.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cdr/cdr_custom.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -30,6 +30,10 @@
  * \ingroup cdr_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/cdr/cdr_odbc.c
===================================================================
--- trunk/cdr/cdr_odbc.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cdr/cdr_odbc.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -32,6 +32,10 @@
 	<depend>unixodbc</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/cdr/cdr_radius.c
===================================================================
--- trunk/cdr/cdr_radius.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cdr/cdr_radius.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<depend>radiusclient</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Rev$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -38,10 +42,6 @@
 #include <sys/types.h>
 #include <radiusclient-ng.h>
 
-#include "asterisk.h"
-
-ASTERISK_FILE_VERSION(__FILE__, "$Rev$")
-
 #include "asterisk/channel.h"
 #include "asterisk/cdr.h"
 #include "asterisk/module.h"

Modified: trunk/cdr/cdr_tds.c
===================================================================
--- trunk/cdr/cdr_tds.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cdr/cdr_tds.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -59,6 +59,10 @@
 	<depend>freetds</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <string.h>

Modified: trunk/cdr.c
===================================================================
--- trunk/cdr.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cdr.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -53,7 +53,6 @@
 #include "asterisk/sched.h"
 #include "asterisk/config.h"
 #include "asterisk/cli.h"
-// XXX #include "asterisk/module.h"
 #include "asterisk/stringfields.h"
 
 /*! Default AMA flag for billing records (CDR's) */

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channel.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -30,10 +34,8 @@
 #include <signal.h>
 #include <errno.h>
 #include <unistd.h>
-#include <math.h>			/* For PI */
+#include <math.h>
 
-#include "asterisk.h"
-
 #ifdef HAVE_ZAPTEL
 #include <sys/ioctl.h>
 #ifdef __linux__

Modified: trunk/channels/chan_agent.c
===================================================================
--- trunk/channels/chan_agent.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_agent.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -31,6 +31,10 @@
  * \ingroup channel_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #include <errno.h>

Modified: trunk/channels/chan_alsa.c
===================================================================
--- trunk/channels/chan_alsa.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_alsa.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -31,6 +31,10 @@
 	<depend>asound</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <fcntl.h>
 #include <errno.h>

Modified: trunk/channels/chan_features.c
===================================================================
--- trunk/channels/chan_features.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_features.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \ingroup channel_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>

Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_iax2.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -28,6 +28,10 @@
  * \ingroup channel_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <sys/types.h>
@@ -50,8 +54,6 @@
 #include <sys/stat.h>
 #include <regex.h>
 
-#include "asterisk.h"
-
 #ifdef HAVE_ZAPTEL
 #include <sys/ioctl.h>
 #ifdef __linux__

Modified: trunk/channels/chan_jingle.c
===================================================================
--- trunk/channels/chan_jingle.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_jingle.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,7 +29,10 @@
 	<depend>iksemel</depend>
  ***/
 
+#include "asterisk.h"
 
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -44,9 +47,6 @@
 #include <sys/signal.h>
 #include <iksemel.h>
 
-#include "asterisk.h"
-
-ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 #include "asterisk/lock.h"
 #include "asterisk/channel.h"
 #include "asterisk/config.h"

Modified: trunk/channels/chan_local.c
===================================================================
--- trunk/channels/chan_local.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_local.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup channel_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>

Modified: trunk/channels/chan_mgcp.c
===================================================================
--- trunk/channels/chan_mgcp.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_mgcp.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -70,6 +70,10 @@
    -- fixed reload_config() / do_monitor to stay responsive during reloads
 */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>

Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_misdn.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
  * \ingroup channel_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <pthread.h>
 #include <string.h>
@@ -39,29 +43,29 @@
 #include <sys/ioctl.h>
 #include <sys/file.h>
 
-#include <asterisk/channel.h>
-#include <asterisk/config.h>
-#include <asterisk/logger.h>
-#include <asterisk/module.h>
-#include <asterisk/pbx.h>
-#include <asterisk/options.h>
-#include <asterisk/io.h>
-#include <asterisk/frame.h>
-#include <asterisk/translate.h>
-#include <asterisk/cli.h>
-#include <asterisk/musiconhold.h>
-#include <asterisk/dsp.h>
-#include <asterisk/translate.h>
-#include <asterisk/config.h>
-#include <asterisk/file.h>
-#include <asterisk/callerid.h>
-#include <asterisk/indications.h>
-#include <asterisk/app.h>
-#include <asterisk/features.h>
-#include <asterisk/stringfields.h>
+#include "asterisk/channel.h"
+#include "asterisk/config.h"
+#include "asterisk/logger.h"
+#include "asterisk/module.h"
+#include "asterisk/pbx.h"
+#include "asterisk/options.h"
+#include "asterisk/io.h"
+#include "asterisk/frame.h"
+#include "asterisk/translate.h"
+#include "asterisk/cli.h"
+#include "asterisk/musiconhold.h"
+#include "asterisk/dsp.h"
+#include "asterisk/translate.h"
+#include "asterisk/config.h"
+#include "asterisk/file.h"
+#include "asterisk/callerid.h"
+#include "asterisk/indications.h"
+#include "asterisk/app.h"
+#include "asterisk/features.h"
+#include "asterisk/stringfields.h"
 
-#include <chan_misdn_config.h>
-#include <isdn_lib.h>
+#include "chan_misdn_config.h"
+#include "isdn_lib.h"
 
 ast_mutex_t release_lock_mutex;
 

Modified: trunk/channels/chan_nbs.c
===================================================================
--- trunk/channels/chan_nbs.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_nbs.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<depend>nbs</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #include <sys/socket.h>

Modified: trunk/channels/chan_oss.c
===================================================================
--- trunk/channels/chan_oss.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_oss.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -36,9 +36,13 @@
 	<depend>ossaudio</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
-#include <ctype.h>	/* for isalnum */
-#include <math.h>	/* exp and log */
+#include <ctype.h>
+#include <math.h>
 #include <string.h>
 #include <unistd.h>
 #include <sys/ioctl.h>
@@ -47,7 +51,6 @@
 #include <stdlib.h>
 #include <errno.h>
 
-
 #ifdef __linux
 #include <linux/soundcard.h>
 #elif defined(__FreeBSD__)

Modified: trunk/channels/chan_phone.c
===================================================================
--- trunk/channels/chan_phone.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_phone.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<depend>ixjuser</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #include <ctype.h>

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_sip.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -84,6 +84,10 @@
  */
 
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <ctype.h>
 #include <string.h>

Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_skinny.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  */
 
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/chan_zap.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -34,13 +34,17 @@
  *
  * \ingroup channel_drivers
  *
- * \todo Decprecate the "musiconhold" configuration option post 1.4
+ * \todo Deprecate the "musiconhold" configuration option post 1.4
  */
 
 /*** MODULEINFO
 	<depend>zaptel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <string.h>
 #ifdef __NetBSD__
@@ -65,8 +69,6 @@
 #include <tonezone.h>
 #include <ctype.h>
 
-#include "asterisk.h"
-
 #ifdef HAVE_LIBPRI
 #include <libpri.h>
 #ifndef PRI_KEYPAD_FACILITY_TX
@@ -104,11 +106,9 @@
 #include "asterisk/transcap.h"
 #include "asterisk/stringfields.h"
 #include "asterisk/abstract_jb.h"
-#ifdef WITH_SMDI
 #include "asterisk/smdi.h"
 #include "asterisk/astobj.h"
 #define SMDI_MD_WAIT_TIMEOUT 1500 /* 1.5 seconds */
-#endif
 
 /*! Global jitterbuffer configuration - by default, jb is disabled */
 static struct ast_jb_conf default_jbconf =
@@ -286,10 +286,8 @@
 static int amaflags = 0;
 
 static int adsi = 0;
-#ifdef WITH_SMDI
 static int use_smdi = 0;
 static char smdi_port[SMDI_MAX_FILENAME_LEN] = "/dev/ttyS0";
-#endif
 static int numbufs = 4;
 
 static int cur_prewink = -1;
@@ -611,10 +609,8 @@
 	unsigned int resetting:1;
 	unsigned int setup_ack:1;
 #endif
-#ifdef WITH_SMDI
 	unsigned int use_smdi:1;		/* Whether to use SMDI on this channel */
 	struct ast_smdi_interface *smdi_iface;	/* The serial port to listen for SMDI data on */
-#endif
 
 	struct zt_distRings drings;
 
@@ -2147,10 +2143,8 @@
 		p->prev->next = p->next;
 	if (p->next)
 		p->next->prev = p->prev;
-#ifdef WITH_SMDI
 	if (p->use_smdi)
 		ASTOBJ_UNREF(p->smdi_iface, ast_smdi_interface_destroy);
-#endif
 	ast_mutex_destroy(&p->lock);
 	free(p);
 	*pvt = NULL;
@@ -5272,9 +5266,7 @@
 	int counter1;
 	int counter;
 	int samples = 0;
-#ifdef WITH_SMDI
 	struct ast_smdi_md_message *smdi_msg = NULL;
-#endif
 	int flags;
 	int i;
 	int timeout;
@@ -5930,7 +5922,6 @@
 			}
 		}
 #endif
-#ifdef WITH_SMDI
 		/* check for SMDI messages */
 		if (p->use_smdi && p->smdi_iface) {
 			smdi_msg = ast_smdi_md_message_wait(p->smdi_iface, SMDI_MD_WAIT_TIMEOUT);
@@ -5956,9 +5947,6 @@
 		 * and we're set to use a polarity reversal to trigger the start of caller id,
 		 * grab the caller id and wait for ringing to start... */
 		} else if (p->use_callerid && (chan->_state == AST_STATE_PRERING && p->cid_start == CID_START_POLARITY)) {
-#else
-		if (p->use_callerid && (chan->_state == AST_STATE_PRERING && p->cid_start == CID_START_POLARITY)) {
-#endif
 			/* If set to use DTMF CID signalling, listen for DTMF */
 			if (p->cid_signalling == CID_SIG_DTMF) {
 				int i = 0;
@@ -6377,10 +6365,8 @@
 			ast_shrink_phone_number(number);
 
 		ast_set_callerid(chan, number, name, number);
-#ifdef WITH_SMDI
 		if (smdi_msg)
 			ASTOBJ_UNREF(smdi_msg, ast_smdi_md_message_destroy);
-#endif
 		if (cs)
 			callerid_free(cs);
 		ast_setstate(chan, AST_STATE_RING);
@@ -7257,9 +7243,7 @@
 		tmp->callwaitingcallerid = callwaitingcallerid;
 		tmp->threewaycalling = threewaycalling;
 		tmp->adsi = adsi;
-#ifdef WITH_SMDI
 		tmp->use_smdi = use_smdi;
-#endif
 		tmp->permhidecallerid = hidecallerid;
 		tmp->callreturn = callreturn;
 		tmp->echocancel = echocancel;
@@ -7292,7 +7276,6 @@
 			}
 		}
 
-#ifdef WITH_SMDI
 		if (tmp->cid_signalling == CID_SIG_SMDI) {
 			if (!tmp->use_smdi) {
 				ast_log(LOG_WARNING, "SMDI callerid requires SMDI to be enabled, enabling...\n");
@@ -7306,7 +7289,6 @@
 				tmp->use_smdi = 0;
 			}
 		}
-#endif
 
 		ast_copy_string(tmp->accountcode, accountcode, sizeof(tmp->accountcode));
 		tmp->amaflags = amaflags;
@@ -10449,10 +10431,8 @@
 				cid_signalling = CID_SIG_V23;
 			else if (!strcasecmp(v->value, "dtmf"))
 				cid_signalling = CID_SIG_DTMF;
-#ifdef WITH_SMDI
 			else if (!strcasecmp(v->value, "smdi"))
 				cid_signalling = CID_SIG_SMDI;
-#endif
 			else if (!strcasecmp(v->value, "v23_jp"))
 				cid_signalling = CID_SIG_V23_JP;
 			else if (ast_true(v->value))
@@ -10477,12 +10457,10 @@
 			ast_copy_string(mailbox, v->value, sizeof(mailbox));
 		} else if (!strcasecmp(v->name, "adsi")) {
 			adsi = ast_true(v->value);
-#ifdef WITH_SMDI
 		} else if (!strcasecmp(v->name, "usesmdi")) {
 			use_smdi = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "smdiport")) {
 			ast_copy_string(smdi_port, v->value, sizeof(smdi_port));
-#endif
 		} else if (!strcasecmp(v->name, "transfer")) {
 			transfer = ast_true(v->value);
 		} else if (!strcasecmp(v->name, "canpark")) {

Modified: trunk/channels/iax2-parser.c
===================================================================
--- trunk/channels/iax2-parser.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/iax2-parser.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <string.h>

Modified: trunk/channels/iax2-provision.c
===================================================================
--- trunk/channels/iax2-provision.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/iax2-provision.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/channels/misdn_config.c
===================================================================
--- trunk/channels/misdn_config.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/channels/misdn_config.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
  * \ingroup channel_drivers
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
@@ -33,13 +37,13 @@
 
 #include "chan_misdn_config.h"
 
-#include <asterisk/config.h>
-#include <asterisk/channel.h>
-#include <asterisk/logger.h>
-#include <asterisk/lock.h>
-#include <asterisk/pbx.h>
-#include <asterisk/strings.h>
-#include <asterisk/utils.h>
+#include "asterisk/config.h"
+#include "asterisk/channel.h"
+#include "asterisk/logger.h"
+#include "asterisk/lock.h"
+#include "asterisk/pbx.h"
+#include "asterisk/strings.h"
+#include "asterisk/utils.h"
 
 #define AST_LOAD_CFG ast_config_load
 #define AST_DESTROY_CFG ast_config_destroy

Modified: trunk/cli.c
===================================================================
--- trunk/cli.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cli.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <stdlib.h>
 #include <sys/signal.h>
@@ -47,9 +51,7 @@
 #include "asterisk/utils.h"
 #include "asterisk/app.h"
 #include "asterisk/lock.h"
-/* For rl_filename_completion */
 #include "editline/readline/readline.h"
-/* For module directory */
 
 extern unsigned long global_fin, global_fout;
 	

Modified: trunk/codecs/codec_a_mu.c
===================================================================
--- trunk/codecs/codec_a_mu.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_a_mu.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <stdio.h>

Modified: trunk/codecs/codec_adpcm.c
===================================================================
--- trunk/codecs/codec_adpcm.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_adpcm.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,7 +27,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
 
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <stdio.h>

Modified: trunk/codecs/codec_alaw.c
===================================================================
--- trunk/codecs/codec_alaw.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_alaw.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <stdio.h>

Modified: trunk/codecs/codec_g723_1.c
===================================================================
--- trunk/codecs/codec_g723_1.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_g723_1.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -31,12 +31,10 @@
 	<defaultenabled>no</defaultenabled>
  ***/
 
-#define TYPE_HIGH	 0x0
-#define TYPE_LOW	 0x1
-#define TYPE_SILENCE	 0x2
-#define TYPE_DONTSEND	 0x3
-#define TYPE_MASK	 0x3
+#include "asterisk.h"
 
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <fcntl.h>
 #include <stdlib.h>
@@ -78,6 +76,12 @@
 #include "slin_g723_ex.h"
 #include "g723_slin_ex.h"
 
+#define TYPE_HIGH	 0x0
+#define TYPE_LOW	 0x1
+#define TYPE_SILENCE	 0x2
+#define TYPE_DONTSEND	 0x3
+#define TYPE_MASK	 0x3
+
 /* g723_1 has 240 samples per buffer.
  * We want a buffer which is a multiple...
  */

Modified: trunk/codecs/codec_g726.c
===================================================================
--- trunk/codecs/codec_g726.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_g726.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <stdio.h>

Modified: trunk/codecs/codec_gsm.c
===================================================================
--- trunk/codecs/codec_gsm.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_gsm.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -30,6 +30,10 @@
 	<depend>libgsm</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>

Modified: trunk/codecs/codec_ilbc.c
===================================================================
--- trunk/codecs/codec_ilbc.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_ilbc.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>

Modified: trunk/codecs/codec_lpc10.c
===================================================================
--- trunk/codecs/codec_lpc10.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_lpc10.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>

Modified: trunk/codecs/codec_speex.c
===================================================================
--- trunk/codecs/codec_speex.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_speex.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -31,6 +31,10 @@
 	<depend>libspeex</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <stdlib.h>
 #include <unistd.h>
@@ -45,6 +49,19 @@
 #include <speex/speex_preprocess.h>
 #endif
 
+#include "asterisk/lock.h"
+#include "asterisk/translate.h"
+#include "asterisk/module.h"
+#include "asterisk/config.h"
+#include "asterisk/options.h"
+#include "asterisk/logger.h"
+#include "asterisk/channel.h"
+#include "asterisk/utils.h"
+
+/* Sample frame data */
+#include "slin_speex_ex.h"
+#include "speex_slin_ex.h"
+
 /* codec variables */
 static int quality = 3;
 static int complexity = 2;

Modified: trunk/codecs/codec_ulaw.c
===================================================================
--- trunk/codecs/codec_ulaw.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/codecs/codec_ulaw.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \ingroup codecs
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <fcntl.h>
 #include <netinet/in.h>
 #include <stdio.h>

Modified: trunk/config.c
===================================================================
--- trunk/config.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/config.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
  * See doc/realtime.txt and doc/extconfig.txt
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <unistd.h>
 #include <stdlib.h>

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/configure.ac	2006-06-23 17:05:10 UTC (rev 290)
@@ -128,6 +128,9 @@
 AC_GNU_SOURCE
 
 AH_TOP(
+#ifndef ASTERISK_AUTOCONFIG_H
+#define ASTERISK_AUTOCONFIG_H
+
 #ifndef MENUSELECT
 #include "asterisk/buildopts.h"
 #endif
@@ -137,6 +140,10 @@
 #endif
 )
 
+AH_BOTTOM(
+#endif
+)
+
 # cross-compile checks
 if test x"${build}" != x"${host}"; 
 then

Modified: trunk/cryptostub.c
===================================================================
--- trunk/cryptostub.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/cryptostub.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,11 +23,13 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <stdlib.h>
 
-#include "asterisk.h"
-
 #include "asterisk/crypto.h"
 #include "asterisk/logger.h"
 

Modified: trunk/db.c
===================================================================
--- trunk/db.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/db.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,7 +27,10 @@
  * licensing even further) we elect to use DB1 which is BSD licensed 
  */
 
+#include "asterisk.h"
 
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/dns.c
===================================================================
--- trunk/dns.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/dns.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
  *
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>

Modified: trunk/dnsmgr.c
===================================================================
--- trunk/dnsmgr.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/dnsmgr.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Kevin P. Fleming <kpfleming at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <sys/socket.h>

Modified: trunk/doc/smdi.txt
===================================================================
--- trunk/doc/smdi.txt	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/doc/smdi.txt	2006-06-23 17:05:10 UTC (rev 290)
@@ -1,16 +1,6 @@
 Asterisk SMDI (Simple Message Desk Interface) integration
 ---------------------------------------------------------
 
-Support for using Asterisk as an SMDI message desk was developed by Matthew A.
-Nicholson <mnicholson at digium.com>.  To enable SMDI support in asterisk edit the
-Makefile file and uncomment the line regarding SMDI so it reads like
-this:
-
-#
-# Asterisk SMDI integration
-#
-WITH_SMDI = 1
-
 SMDI integration is configured in smdi.conf, zaptel.conf, and voicemail.conf.
 Various characteristics of the SMDI interfaces to be used (serial ports) are
 defined in smdi.conf.  SMDI integration for callerid and MWI are defined in

Modified: trunk/dsp.c
===================================================================
--- trunk/dsp.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/dsp.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -40,6 +40,10 @@
         detriment.
 */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdlib.h>
 #include <unistd.h>

Modified: trunk/enum.c
===================================================================
--- trunk/enum.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/enum.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -40,6 +40,10 @@
  * - See http://bugs.digium.com/view.php?id=6739
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <netinet/in.h>

Modified: trunk/file.c
===================================================================
--- trunk/file.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/file.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <errno.h>
 #include <unistd.h>
@@ -52,7 +56,7 @@
 #include "asterisk/pbx.h"
 #include "asterisk/linkedlists.h"
 #define	MOD_LOADER
-#include "asterisk/module.h"	/* ast_update_use_count() */
+#include "asterisk/module.h"
 
 /*
  * The following variable controls the layout of localized sound files.

Modified: trunk/fixedjitterbuf.c
===================================================================
--- trunk/fixedjitterbuf.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/fixedjitterbuf.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -24,15 +24,16 @@
  * \author Slav Klenov <slav at securax.org>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision $")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <assert.h>
 #include <string.h>
 #include <unistd.h>
 
-#include "asterisk.h"
-ASTERISK_FILE_VERSION(__FILE__, "$Revision $")
-
 #include "asterisk/utils.h"
 #include "fixedjitterbuf.h"
 

Modified: trunk/formats/format_g729.c
===================================================================
--- trunk/formats/format_g729.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_g729.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
  * \ingroup formats
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/formats/format_gsm.c
===================================================================
--- trunk/formats/format_gsm.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_gsm.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \ingroup formats
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/formats/format_ilbc.c
===================================================================
--- trunk/formats/format_ilbc.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_ilbc.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \ingroup formats
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/formats/format_ogg_vorbis.c
===================================================================
--- trunk/formats/format_ogg_vorbis.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_ogg_vorbis.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
 	<depend>ogg</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/formats/format_sln.c
===================================================================
--- trunk/formats/format_sln.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_sln.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  * \ingroup formats
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/formats/format_wav.c
===================================================================
--- trunk/formats/format_wav.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_wav.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -24,6 +24,10 @@
  * \ingroup formats
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/formats/format_wav_gsm.c
===================================================================
--- trunk/formats/format_wav_gsm.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/formats/format_wav_gsm.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \ingroup formats
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <netinet/in.h>
 #include <arpa/inet.h>

Modified: trunk/funcs/func_channel.c
===================================================================
--- trunk/funcs/func_channel.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/funcs/func_channel.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -38,6 +38,7 @@
 #include "asterisk/app.h"
 #include "asterisk/indications.h"
 #include "asterisk/stringfields.h"
+
 #define locked_copy_string(chan, dest, source, len) \
 	do { \
 		ast_channel_lock(chan); \

Modified: trunk/funcs/func_global.c
===================================================================
--- trunk/funcs/func_global.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/funcs/func_global.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,16 +23,16 @@
  * \author Tilghman Lesher <func_global__200605 at the-tilghman.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 
-#include "asterisk.h"
-
-ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
-
 #include "asterisk/module.h"
 #include "asterisk/channel.h"
 #include "asterisk/pbx.h"

Modified: trunk/http.c
===================================================================
--- trunk/http.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/http.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \ref AstHTTP - AMI over the http protocol
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <unistd.h>

Modified: trunk/image.c
===================================================================
--- trunk/image.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/image.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/include/asterisk/callerid.h
===================================================================
--- trunk/include/asterisk/callerid.h	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/include/asterisk/callerid.h	2006-06-23 17:05:10 UTC (rev 290)
@@ -54,9 +54,7 @@
 #define CID_SIG_V23	2
 #define CID_SIG_DTMF	3
 #define CID_SIG_V23_JP	4
-#ifdef WITH_SMDI
 #define CID_SIG_SMDI	5
-#endif
 
 #define CID_START_RING	1
 #define CID_START_POLARITY 2

Modified: trunk/include/asterisk.h
===================================================================
--- trunk/include/asterisk.h	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/include/asterisk.h	2006-06-23 17:05:10 UTC (rev 290)
@@ -18,6 +18,8 @@
 #ifndef _ASTERISK_H
 #define _ASTERISK_H
 
+#include "autoconfig.h"
+
 #include "asterisk/compat.h"
 
 #define DEFAULT_LANGUAGE "en"

Modified: trunk/include/autoconfig.h.in
===================================================================
--- trunk/include/autoconfig.h.in	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/include/autoconfig.h.in	2006-06-23 17:05:10 UTC (rev 290)
@@ -1,5 +1,8 @@
 /* include/autoconfig.h.in.  Generated from configure.ac by autoheader.  */
 
+#ifndef ASTERISK_AUTOCONFIG_H
+#define ASTERISK_AUTOCONFIG_H
+
 #ifndef MENUSELECT
 #include "asterisk/buildopts.h"
 #endif
@@ -566,3 +569,6 @@
 /* Define to empty if the keyword `volatile' does not work. Warning: valid
    code using `volatile' can become incorrect without. Disable with care. */
 #undef volatile
+
+#endif
+

Modified: trunk/logger.c
===================================================================
--- trunk/logger.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/logger.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <signal.h>
 #include <stdarg.h>
 #include <stdio.h>

Modified: trunk/manager.c
===================================================================
--- trunk/manager.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/manager.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -32,6 +32,10 @@
 /*! @{ 
  Doxygen group */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/netsock.c
===================================================================
--- trunk/netsock.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/netsock.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/ael/ael.flex	2006-06-23 17:05:10 UTC (rev 290)
@@ -56,11 +56,14 @@
 %option bison-locations
 
 %{
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
-#include "asterisk.h"
 #include "asterisk/logger.h"
 #include "ael/ael.tab.h"
 #include "asterisk/ael_structs.h"

Modified: trunk/pbx/ael/ael.tab.c
===================================================================
--- trunk/pbx/ael/ael.tab.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/ael/ael.tab.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -174,9 +174,14 @@
  * \brief Bison Grammar description of AEL2.
  *
  */
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+
 #include "asterisk/logger.h"
 #include "asterisk/ael_structs.h"
 

Modified: trunk/pbx/ael/ael.y
===================================================================
--- trunk/pbx/ael/ael.y	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/ael/ael.y	2006-06-23 17:05:10 UTC (rev 290)
@@ -21,9 +21,15 @@
  * \brief Bison Grammar description of AEL2.
  *
  */
+
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+
 #include "asterisk/logger.h"
 #include "asterisk/ael_structs.h"
 

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/ael/ael_lex.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -672,11 +672,14 @@
  * bison-locations is probably not needed.
  */
 #line 59 "ael.flex"
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <unistd.h>
 
-#include "asterisk.h"
 #include "asterisk/logger.h"
 #include "ael/ael.tab.h"
 #include "asterisk/ael_structs.h"

Modified: trunk/pbx/dundi-parser.c
===================================================================
--- trunk/pbx/dundi-parser.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/dundi-parser.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  *
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <string.h>

Modified: trunk/pbx/pbx_ael.c
===================================================================
--- trunk/pbx/pbx_ael.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/pbx_ael.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  * 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdlib.h>
 #include <stdio.h>

Modified: trunk/pbx/pbx_config.c
===================================================================
--- trunk/pbx/pbx_config.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/pbx_config.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdlib.h>
 #include <stdio.h>

Modified: trunk/pbx/pbx_dundi.c
===================================================================
--- trunk/pbx/pbx_dundi.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/pbx_dundi.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
 	<depend>zlib</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <unistd.h>

Modified: trunk/pbx/pbx_gtkconsole.c
===================================================================
--- trunk/pbx/pbx_gtkconsole.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/pbx_gtkconsole.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
 	<defaultenabled>no</defaultenabled>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <stdlib.h>
 #include <fcntl.h>

Modified: trunk/pbx/pbx_spool.c
===================================================================
--- trunk/pbx/pbx_spool.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx/pbx_spool.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  * 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/stat.h>
 #include <errno.h>
 #include <time.h>

Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/pbx.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <string.h>
 #include <unistd.h>

Modified: trunk/privacy.c
===================================================================
--- trunk/privacy.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/privacy.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/res/res_adsi.c
===================================================================
--- trunk/res/res_adsi.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_adsi.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,6 +25,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <time.h>
 #include <string.h>
 #include <stdio.h>

Modified: trunk/res/res_agi.c
===================================================================
--- trunk/res/res_agi.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_agi.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <netdb.h>
 #include <sys/socket.h>

Modified: trunk/res/res_crypto.c
===================================================================
--- trunk/res/res_crypto.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_crypto.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
 	<depend>ssl</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <openssl/ssl.h>
 #include <openssl/err.h>

Modified: trunk/res/res_features.c
===================================================================
--- trunk/res/res_features.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_features.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <pthread.h>
 #include <stdlib.h>
 #include <errno.h>

Modified: trunk/res/res_indications.c
===================================================================
--- trunk/res/res_indications.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_indications.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -24,6 +24,10 @@
  * Load the country specific dialtones into the asterisk PBX.
  */
  
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <unistd.h>
 #include <string.h>
 #include <ctype.h>

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_jabber.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -25,13 +25,14 @@
 	<depend>iksemel</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <iksemel.h>
 
-#include "asterisk.h"
-
-ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 #include "asterisk/channel.h"
 #include "asterisk/jabber.h"
 #include "asterisk/file.h"

Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_musiconhold.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
 	<conflict>win32</conflict>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdlib.h>
 #include <errno.h>
 #include <unistd.h>

Modified: trunk/res/res_osp.c
===================================================================
--- trunk/res/res_osp.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_osp.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -30,6 +30,10 @@
 	<depend>ssl</depend>
  ***/
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <osp/osp.h>
 #include <osp/osputils.h>

Modified: trunk/res/res_smdi.c
===================================================================
--- trunk/res/res_smdi.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/res/res_smdi.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,10 @@
  * \author Matthew A. Nicholson <mnicholson at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <errno.h>

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/rtp.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -26,6 +26,10 @@
  * \note RTP is defined in RFC 3550.
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/say.c
===================================================================
--- trunk/say.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/say.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  *  						
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <string.h>
 #include <stdlib.h>

Modified: trunk/sched.c
===================================================================
--- trunk/sched.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/sched.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com>
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #ifdef DEBUG_SCHEDULER
 #define DEBUG(a) do { \
 	if (option_debug) \

Modified: trunk/srv.c
===================================================================
--- trunk/srv.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/srv.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -29,6 +29,10 @@
  * \note Funding provided by nic.at
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <netinet/in.h>
 #include <arpa/nameser.h>

Modified: trunk/stdtime/localtime.c
===================================================================
--- trunk/stdtime/localtime.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/stdtime/localtime.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -43,6 +43,9 @@
 #define TZ_STRLEN_MAX	255
 /* #define DEBUG */
 
+#include "asterisk.h"
+ 
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
 /*LINTLIBRARY*/
 

Modified: trunk/strcompat.c
===================================================================
--- trunk/strcompat.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/strcompat.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -19,13 +19,11 @@
  * \brief Compatibility functions for strsep and strtoq missing on Solaris 
  */
 
+#include "asterisk.h"
+
 #include <sys/types.h>
 #include <stdio.h>
 
-#include "asterisk.h"
-
-#include "asterisk/compat.h"
-
 #ifndef HAVE_STRSEP
 char *strsep(char **str, const char *delims)
 {

Modified: trunk/tdd.c
===================================================================
--- trunk/tdd.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/tdd.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -27,6 +27,10 @@
  * \note Includes code and algorithms from the Zapata library.
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <time.h>
 #include <string.h>
 #include <stdio.h>

Modified: trunk/term.c
===================================================================
--- trunk/term.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/term.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/translate.c
===================================================================
--- trunk/translate.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/translate.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,11 @@
  * \author Mark Spencer <markster at digium.com> 
  */
 
+#define MOD_LOADER	/* not really a module */
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/time.h>

Modified: trunk/udptl.c
===================================================================
--- trunk/udptl.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/udptl.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -14,6 +14,10 @@
  * This version is disclaimed to DIGIUM for inclusion in the Asterisk project.
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>

Modified: trunk/utils/ael_main.c
===================================================================
--- trunk/utils/ael_main.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/utils/ael_main.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -1,3 +1,5 @@
+#include "autoconfig.h"
+
 #include <sys/types.h>
 #include <stdio.h>
 #include <stdlib.h>

Modified: trunk/utils/astman.c
===================================================================
--- trunk/utils/astman.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/utils/astman.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -22,6 +22,8 @@
  *
  */
  
+#include "autoconfig.h"
+
 #include <newt.h>
 #include <stdio.h>
 #include <sys/time.h>

Modified: trunk/utils/smsq.c
===================================================================
--- trunk/utils/smsq.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/utils/smsq.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -17,6 +17,8 @@
  * at the top of the source tree.
  */
 
+#include "autoconfig.h"
+
 #include <stdio.h>
 #include <popt.h>
 #include <sys/types.h>
@@ -28,6 +30,7 @@
 #include <stdlib.h>
 #include <unistd.h>
 #include <time.h>
+
 #include <asterisk/compat.h>
 #ifdef SOLARIS
 #define     POPT_ARGFLAG_SHOW_DEFAULT 0x00800000

Modified: trunk/utils.c
===================================================================
--- trunk/utils.c	2006-06-18 22:41:08 UTC (rev 289)
+++ trunk/utils.c	2006-06-23 17:05:10 UTC (rev 290)
@@ -23,6 +23,10 @@
  * Please consult the CODING GUIDELINES for more information.
  */
 
+#include "asterisk.h"
+
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+
 #include <ctype.h>
 #include <string.h>
 #include <unistd.h>
@@ -46,7 +50,6 @@
 #include "asterisk/md5.h"
 #include "asterisk/sha1.h"
 #include "asterisk/options.h"
-#include "asterisk/compat.h"
 
 #define AST_API_MODULE		/* ensure that inlinable API functions will be built in this module if required */
 #include "asterisk/strings.h"



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:20:33 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:20:33 +0200
Subject: [solid-pbx-svn] r291 - in trunk: . include include/asterisk utils
Message-ID: <200606231720.k5NHKXMe021198@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:20:16 +0200 (Fri, 23 Jun 2006)
New Revision: 291

Added:
   trunk/include/asterisk/autoconfig.h.in
Removed:
   trunk/include/autoconfig.h.in
Modified:
   trunk/Makefile
   trunk/acl.c
   trunk/configure.ac
   trunk/include/asterisk.h
   trunk/pbx.c
   trunk/utils/ael_main.c
   trunk/utils/astman.c
   trunk/utils/smsq.c
Log:
Update to Asterisk SVN trunk r32863

------------------------------------------------------------------------
r32860 | kpfleming | 2006-06-07 21:05:35 +0200 (Wed, 07 Jun 2006) | 3 lines

move autoconfig.h to the include/asterisk directory so it will get installed
install asterisk.h include the system's default include directory

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/Makefile	2006-06-23 17:20:16 UTC (rev 291)
@@ -635,6 +635,7 @@
 		chmod 755 $(DESTDIR)$(ASTSBINDIR)/safe_asterisk;\
 	fi
 	$(INSTALL) -d $(DESTDIR)$(ASTHEADERDIR)
+	$(INSTALL) -m 644 include/asterisk.h $(DESTDIR)$(includedir)
 	$(INSTALL) -m 644 include/asterisk/*.h $(DESTDIR)$(ASTHEADERDIR)
 	if [ -n "$(OLDHEADERS)" ]; then \
 		rm -f $(addprefix $(DESTDIR)$(ASTHEADERDIR)/,$(OLDHEADERS)) ;\

Modified: trunk/acl.c
===================================================================
--- trunk/acl.c	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/acl.c	2006-06-23 17:20:16 UTC (rev 291)
@@ -73,7 +73,6 @@
 #include "asterisk/utils.h"
 #include "asterisk/lock.h"
 #include "asterisk/srv.h"
-#include "asterisk/compat.h"
 
 struct ast_ha {
 	/* Host access rule */

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/configure.ac	2006-06-23 17:20:16 UTC (rev 291)
@@ -17,7 +17,7 @@
 AC_CONFIG_SRCDIR([asterisk.c])
 
 # specify output header file
-AC_CONFIG_HEADER(include/autoconfig.h)
+AC_CONFIG_HEADER(include/asterisk/autoconfig.h)
 
 AC_COPYRIGHT("Asterisk")
 AC_REVISION($Revision$)

Added: trunk/include/asterisk/autoconfig.h.in
===================================================================
--- trunk/include/asterisk/autoconfig.h.in	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/include/asterisk/autoconfig.h.in	2006-06-23 17:20:16 UTC (rev 291)
@@ -0,0 +1,577 @@
+/* include/asterisk/autoconfig.h.in.  Generated from configure.ac by autoheader.  */
+
+#ifndef ASTERISK_AUTOCONFIG_H
+#define ASTERISK_AUTOCONFIG_H
+
+#ifndef MENUSELECT
+#include "asterisk/buildopts.h"
+#endif
+
+#ifndef _REENTRANT
+#define _REENTRANT
+#endif
+
+
+/* Define to 1 if the `closedir' function returns void instead of `int'. */
+#undef CLOSEDIR_VOID
+
+/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
+   systems. This function is required for `alloca.c' support on those systems.
+   */
+#undef CRAY_STACKSEG_END
+
+/* Define to 1 if using `alloca.c'. */
+#undef C_ALLOCA
+
+/* Define according to your operating system type. */
+#undef Darwin
+
+/* Define according to your operating system type. */
+#undef FreeBSD
+
+/* Define to 1 if you have the `alarm' function. */
+#undef HAVE_ALARM
+
+/* Define to 1 if you have `alloca', as a function or macro. */
+#undef HAVE_ALLOCA
+
+/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
+   */
+#undef HAVE_ALLOCA_H
+
+/* Define to indicate the Advanced Linux Sound Architecture library */
+#undef HAVE_ALSA
+
+/* Define to 1 if you have the <arpa/inet.h> header file. */
+#undef HAVE_ARPA_INET_H
+
+/* Define to 1 if you have the `asprintf' function. */
+#undef HAVE_ASPRINTF
+
+/* Define to 1 if you have the `atexit' function. */
+#undef HAVE_ATEXIT
+
+/* Define to 1 if you have the `bzero' function. */
+#undef HAVE_BZERO
+
+/* Define to 1 if your system has a working `chown' function. */
+#undef HAVE_CHOWN
+
+/* Define if your system has the curl libraries. */
+#undef HAVE_CURL
+
+/* Define to indicate the curses library */
+#undef HAVE_CURSES
+
+/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_DIRENT_H
+
+/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
+#undef HAVE_DOPRNT
+
+/* Define to 1 if you have the `dup2' function. */
+#undef HAVE_DUP2
+
+/* Define to 1 if you have the `endpwent' function. */
+#undef HAVE_ENDPWENT
+
+/* Define to 1 if you have the <fcntl.h> header file. */
+#undef HAVE_FCNTL_H
+
+/* Define to 1 if you have the `floor' function. */
+#undef HAVE_FLOOR
+
+/* Define to 1 if you have the `fork' function. */
+#undef HAVE_FORK
+
+/* Define to indicate the FreeTDS library */
+#undef HAVE_FREETDS
+
+/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
+#undef HAVE_FSEEKO
+
+/* Define to 1 if you have the `ftruncate' function. */
+#undef HAVE_FTRUNCATE
+
+/* Define to 1 if you have the `getcwd' function. */
+#undef HAVE_GETCWD
+
+/* Define to 1 if you have the `gethostbyname' function. */
+#undef HAVE_GETHOSTBYNAME
+
+/* Define to 1 if you have the `gethostname' function. */
+#undef HAVE_GETHOSTNAME
+
+/* Define to 1 if you have the `getpagesize' function. */
+#undef HAVE_GETPAGESIZE
+
+/* Define to 1 if you have the `gettimeofday' function. */
+#undef HAVE_GETTIMEOFDAY
+
+/* Define to indicate the GSM library */
+#undef HAVE_GSM
+
+/* Define if your system has the GTK libraries. */
+#undef HAVE_GTK
+
+/* Define to indicate the Iksemel Jabber Library library */
+#undef HAVE_IKSEMEL
+
+/* Define to 1 if you have the `inet_ntoa' function. */
+#undef HAVE_INET_NTOA
+
+/* Define to 1 if you have the <inttypes.h> header file. */
+#undef HAVE_INTTYPES_H
+
+/* Define to 1 if you have the `isascii' function. */
+#undef HAVE_ISASCII
+
+/* Define to 1 if you have the <libintl.h> header file. */
+#undef HAVE_LIBINTL_H
+
+/* Define if your system has the KDE library */
+#undef HAVE_LIBKDE
+
+/* Define to indicate the ISDN PRI library */
+#undef HAVE_LIBPRI
+
+/* Define if your system has the pwlib libraries. */
+#undef HAVE_LIBPWLIB
+
+/* Define if your system has the Qt library */
+#undef HAVE_LIBQT
+
+/* Define if your system has the VoiceTronix (vpb) libraries. */
+#undef HAVE_LIBVPB
+
+/* Define to 1 if you have the <limits.h> header file. */
+#undef HAVE_LIMITS_H
+
+/* Define to 1 if you have the <locale.h> header file. */
+#undef HAVE_LOCALE_H
+
+/* Define to 1 if you have the `localtime_r' function. */
+#undef HAVE_LOCALTIME_R
+
+/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
+   to 0 otherwise. */
+#undef HAVE_MALLOC
+
+/* Define to 1 if you have the <malloc.h> header file. */
+#undef HAVE_MALLOC_H
+
+/* Define to 1 if you have the `memchr' function. */
+#undef HAVE_MEMCHR
+
+/* Define to 1 if you have the `memmove' function. */
+#undef HAVE_MEMMOVE
+
+/* Define to 1 if you have the <memory.h> header file. */
+#undef HAVE_MEMORY_H
+
+/* Define to 1 if you have the `memset' function. */
+#undef HAVE_MEMSET
+
+/* Define to 1 if you have the `mkdir' function. */
+#undef HAVE_MKDIR
+
+/* Define to 1 if you have a working `mmap' system call. */
+#undef HAVE_MMAP
+
+/* Define to 1 if you have the `munmap' function. */
+#undef HAVE_MUNMAP
+
+/* Define to indicate the Network Broadcast Sound library */
+#undef HAVE_NBS
+
+/* Define to indicate the ncurses library */
+#undef HAVE_NCURSES
+
+/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
+#undef HAVE_NDIR_H
+
+/* Define to 1 if you have the <netdb.h> header file. */
+#undef HAVE_NETDB_H
+
+/* Define to 1 if you have the <netinet/in.h> header file. */
+#undef HAVE_NETINET_IN_H
+
+/* Define to indicate the newt library */
+#undef HAVE_NEWT
+
+/* Define to indicate the OGG library */
+#undef HAVE_OGG
+
+/* Define to indicate the OpenSSL library */
+#undef HAVE_OPENSSL
+
+/* Define to indicate the OSP Toolkit library */
+#undef HAVE_OSPTK
+
+/* Define to indicate the Open Sound System library */
+#undef HAVE_OSS
+
+/* Define to indicate the popt library */
+#undef HAVE_POPT
+
+/* Define to 1 if you have the `pow' function. */
+#undef HAVE_POW
+
+/* Define to indicate the PostgreSQL library */
+#undef HAVE_PQ
+
+/* Define to 1 if the system has the type `ptrdiff_t'. */
+#undef HAVE_PTRDIFF_T
+
+/* Define to 1 if you have the `putenv' function. */
+#undef HAVE_PUTENV
+
+/* Define to indicate the Radius Client library */
+#undef HAVE_RADIUSCLIENT
+
+/* Define to 1 if your system has a GNU libc compatible `realloc' function,
+   and to 0 otherwise. */
+#undef HAVE_REALLOC
+
+/* Define to 1 if you have the `regcomp' function. */
+#undef HAVE_REGCOMP
+
+/* Define to 1 if you have the `re_comp' function. */
+#undef HAVE_RE_COMP
+
+/* Define to 1 if you have the `rint' function. */
+#undef HAVE_RINT
+
+/* Define to 1 if you have the `select' function. */
+#undef HAVE_SELECT
+
+/* Define to 1 if you have the `setenv' function. */
+#undef HAVE_SETENV
+
+/* Define to 1 if you have the `socket' function. */
+#undef HAVE_SOCKET
+
+/* Define to indicate the Speex library */
+#undef HAVE_SPEEX
+
+/* Define to indicate the SQLite library */
+#undef HAVE_SQLITE
+
+/* Define to 1 if you have the `sqrt' function. */
+#undef HAVE_SQRT
+
+/* Define to 1 if `stat' has the bug that it succeeds when given the
+   zero-length file name argument. */
+#undef HAVE_STAT_EMPTY_STRING_BUG
+
+/* Define to 1 if stdbool.h conforms to C99. */
+#undef HAVE_STDBOOL_H
+
+/* Define to 1 if you have the <stddef.h> header file. */
+#undef HAVE_STDDEF_H
+
+/* Define to 1 if you have the <stdint.h> header file. */
+#undef HAVE_STDINT_H
+
+/* Define to 1 if you have the <stdlib.h> header file. */
+#undef HAVE_STDLIB_H
+
+/* Define to 1 if you have the `strcasecmp' function. */
+#undef HAVE_STRCASECMP
+
+/* Define to 1 if you have the `strcasestr' function. */
+#undef HAVE_STRCASESTR
+
+/* Define to 1 if you have the `strchr' function. */
+#undef HAVE_STRCHR
+
+/* Define to 1 if you have the `strcoll' function and it is properly defined.
+   */
+#undef HAVE_STRCOLL
+
+/* Define to 1 if you have the `strcspn' function. */
+#undef HAVE_STRCSPN
+
+/* Define to 1 if you have the `strdup' function. */
+#undef HAVE_STRDUP
+
+/* Define to 1 if you have the `strerror' function. */
+#undef HAVE_STRERROR
+
+/* Define to 1 if you have the `strftime' function. */
+#undef HAVE_STRFTIME
+
+/* Define to 1 if you have the <strings.h> header file. */
+#undef HAVE_STRINGS_H
+
+/* Define to 1 if you have the <string.h> header file. */
+#undef HAVE_STRING_H
+
+/* Define to 1 if you have the `strncasecmp' function. */
+#undef HAVE_STRNCASECMP
+
+/* Define to 1 if you have the `strndup' function. */
+#undef HAVE_STRNDUP
+
+/* Define to 1 if you have the `strrchr' function. */
+#undef HAVE_STRRCHR
+
+/* Define to 1 if you have the `strsep' function. */
+#undef HAVE_STRSEP
+
+/* Define to 1 if you have the `strspn' function. */
+#undef HAVE_STRSPN
+
+/* Define to 1 if you have the `strstr' function. */
+#undef HAVE_STRSTR
+
+/* Define to 1 if you have the `strtol' function. */
+#undef HAVE_STRTOL
+
+/* Define to 1 if you have the `strtoq' function. */
+#undef HAVE_STRTOQ
+
+/* Define to 1 if `st_blksize' is member of `struct stat'. */
+#undef HAVE_STRUCT_STAT_ST_BLKSIZE
+
+/* Define to 1 if you have the <syslog.h> header file. */
+#undef HAVE_SYSLOG_H
+
+/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_DIR_H
+
+/* Define to 1 if you have the <sys/file.h> header file. */
+#undef HAVE_SYS_FILE_H
+
+/* Define to 1 if you have the <sys/ioctl.h> header file. */
+#undef HAVE_SYS_IOCTL_H
+
+/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
+   */
+#undef HAVE_SYS_NDIR_H
+
+/* Define to 1 if you have the <sys/param.h> header file. */
+#undef HAVE_SYS_PARAM_H
+
+/* Define to 1 if you have the <sys/select.h> header file. */
+#undef HAVE_SYS_SELECT_H
+
+/* Define to 1 if you have the <sys/socket.h> header file. */
+#undef HAVE_SYS_SOCKET_H
+
+/* Define to 1 if you have the <sys/stat.h> header file. */
+#undef HAVE_SYS_STAT_H
+
+/* Define to 1 if you have the <sys/time.h> header file. */
+#undef HAVE_SYS_TIME_H
+
+/* Define to 1 if you have the <sys/types.h> header file. */
+#undef HAVE_SYS_TYPES_H
+
+/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
+#undef HAVE_SYS_WAIT_H
+
+/* Define to indicate the Termcap library */
+#undef HAVE_TERMCAP
+
+/* Define to 1 if you have the <termios.h> header file. */
+#undef HAVE_TERMIOS_H
+
+/* Define to indicate the Term Info library */
+#undef HAVE_TINFO
+
+/* Define to 1 if you have the <unistd.h> header file. */
+#undef HAVE_UNISTD_H
+
+/* Define to indicate the unixODBC library */
+#undef HAVE_UNIXODBC
+
+/* Define to 1 if you have the `unsetenv' function. */
+#undef HAVE_UNSETENV
+
+/* Define to 1 if you have the `utime' function. */
+#undef HAVE_UTIME
+
+/* Define to 1 if you have the <utime.h> header file. */
+#undef HAVE_UTIME_H
+
+/* Define to 1 if `utime(file, NULL)' sets file's timestamp to the present. */
+#undef HAVE_UTIME_NULL
+
+/* Define to 1 if you have the `vasprintf' function. */
+#undef HAVE_VASPRINTF
+
+/* Define to 1 if you have the `vfork' function. */
+#undef HAVE_VFORK
+
+/* Define to 1 if you have the <vfork.h> header file. */
+#undef HAVE_VFORK_H
+
+/* Define to indicate the Vorbis library */
+#undef HAVE_VORBIS
+
+/* Define to 1 if you have the `vprintf' function. */
+#undef HAVE_VPRINTF
+
+/* Define to 1 if `fork' works. */
+#undef HAVE_WORKING_FORK
+
+/* Define to 1 if `vfork' works. */
+#undef HAVE_WORKING_VFORK
+
+/* Define to indicate the Zaptel library */
+#undef HAVE_ZAPTEL
+
+/* Define to indicate the zlib library */
+#undef HAVE_ZLIB
+
+/* Define to 1 if the system has the type `_Bool'. */
+#undef HAVE__BOOL
+
+/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
+   slash. */
+#undef LSTAT_FOLLOWS_SLASHED_SYMLINK
+
+/* Define according to your operating system type. */
+#undef Linux
+
+/* Define according to your operating system type. */
+#undef NetBSD
+
+/* Define according to your operating system type. */
+#undef OpenBSD
+
+/* Define to the address where bug reports for this package should be sent. */
+#undef PACKAGE_BUGREPORT
+
+/* Define to the full name of this package. */
+#undef PACKAGE_NAME
+
+/* Define to the full name and version of this package. */
+#undef PACKAGE_STRING
+
+/* Define to the one symbol short name of this package. */
+#undef PACKAGE_TARNAME
+
+/* Define to the version of this package. */
+#undef PACKAGE_VERSION
+
+/* Define this to be the name of the CPU of your system. */
+#undef PBX_CPU
+
+/* Define this to be the name of the OS of your system. */
+#undef PBX_OS
+
+/* Define this to be the canonical name (cpu-vendor-os) of your system. */
+#undef PBX_PLATFORM
+
+/* Define this to be the name of the vendor of your system. */
+#undef PBX_VENDOR
+
+/* Define to 1 if the C compiler supports function prototypes. */
+#undef PROTOTYPES
+
+/* Define as the return type of signal handlers (`int' or `void'). */
+#undef RETSIGTYPE
+
+/* Define to the type of arg 1 for `select'. */
+#undef SELECT_TYPE_ARG1
+
+/* Define to the type of args 2, 3 and 4 for `select'. */
+#undef SELECT_TYPE_ARG234
+
+/* Define to the type of arg 5 for `select'. */
+#undef SELECT_TYPE_ARG5
+
+/* Define to 1 if the `setvbuf' function takes the buffering type as its
+   second argument and the buffer pointer as the third, as on System V before
+   release 3. */
+#undef SETVBUF_REVERSED
+
+/* If using the C implementation of alloca, define if you know the
+   direction of stack growth for your system; otherwise it will be
+   automatically deduced at runtime.
+	STACK_DIRECTION > 0 => grows toward higher addresses
+	STACK_DIRECTION < 0 => grows toward lower addresses
+	STACK_DIRECTION = 0 => direction of growth unknown */
+#undef STACK_DIRECTION
+
+/* Define to 1 if you have the ANSI C header files. */
+#undef STDC_HEADERS
+
+/* Define according to your operating system type. */
+#undef SunOS
+
+/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
+#undef TIME_WITH_SYS_TIME
+
+/* Define to 1 if your <sys/time.h> declares `struct tm'. */
+#undef TM_IN_SYS_TIME
+
+/* Define according to your operating system type. */
+#undef Unix
+
+/* Define according to your operating system type. */
+#undef Win32
+
+/* Number of bits in a file offset, on hosts where this is settable. */
+#undef _FILE_OFFSET_BITS
+
+/* Enable GNU extensions on systems that have them.  */
+#ifndef _GNU_SOURCE
+# undef _GNU_SOURCE
+#endif
+
+/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
+#undef _LARGEFILE_SOURCE
+
+/* Define for large files, on AIX-style hosts. */
+#undef _LARGE_FILES
+
+/* Define like PROTOTYPES; this can be used by system headers. */
+#undef __PROTOTYPES
+
+/* Define to empty if `const' does not conform to ANSI C. */
+#undef const
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+#undef gid_t
+
+/* Define to `__inline__' or `__inline' if that's what the C compiler
+   calls it, or to nothing if 'inline' is not supported under any name.  */
+#ifndef __cplusplus
+#undef inline
+#endif
+
+/* Define to rpl_malloc if the replacement function should be used. */
+#undef malloc
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef mode_t
+
+/* Define to `long int' if <sys/types.h> does not define. */
+#undef off_t
+
+/* Define to `int' if <sys/types.h> does not define. */
+#undef pid_t
+
+/* Define to rpl_realloc if the replacement function should be used. */
+#undef realloc
+
+/* Define to `unsigned int' if <sys/types.h> does not define. */
+#undef size_t
+
+/* Define to `int' if <sys/types.h> doesn't define. */
+#undef uid_t
+
+/* Define as `fork' if `vfork' does not work. */
+#undef vfork
+
+/* Define to empty if the keyword `volatile' does not work. Warning: valid
+   code using `volatile' can become incorrect without. Disable with care. */
+#undef volatile
+
+#endif
+

Modified: trunk/include/asterisk.h
===================================================================
--- trunk/include/asterisk.h	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/include/asterisk.h	2006-06-23 17:20:16 UTC (rev 291)
@@ -18,7 +18,7 @@
 #ifndef _ASTERISK_H
 #define _ASTERISK_H
 
-#include "autoconfig.h"
+#include "asterisk/autoconfig.h"
 
 #include "asterisk/compat.h"
 

Deleted: trunk/include/autoconfig.h.in
===================================================================
--- trunk/include/autoconfig.h.in	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/include/autoconfig.h.in	2006-06-23 17:20:16 UTC (rev 291)
@@ -1,574 +0,0 @@
-/* include/autoconfig.h.in.  Generated from configure.ac by autoheader.  */
-
-#ifndef ASTERISK_AUTOCONFIG_H
-#define ASTERISK_AUTOCONFIG_H
-
-#ifndef MENUSELECT
-#include "asterisk/buildopts.h"
-#endif
-
-#ifndef _REENTRANT
-#define _REENTRANT
-#endif
-
-
-/* Define to 1 if the `closedir' function returns void instead of `int'. */
-#undef CLOSEDIR_VOID
-
-/* Define to one of `_getb67', `GETB67', `getb67' for Cray-2 and Cray-YMP
-   systems. This function is required for `alloca.c' support on those systems.
-   */
-#undef CRAY_STACKSEG_END
-
-/* Define to 1 if using `alloca.c'. */
-#undef C_ALLOCA
-
-/* Define according to your operating system type. */
-#undef Darwin
-
-/* Define according to your operating system type. */
-#undef FreeBSD
-
-/* Define to 1 if you have the `alarm' function. */
-#undef HAVE_ALARM
-
-/* Define to 1 if you have `alloca', as a function or macro. */
-#undef HAVE_ALLOCA
-
-/* Define to 1 if you have <alloca.h> and it should be used (not on Ultrix).
-   */
-#undef HAVE_ALLOCA_H
-
-/* Define to indicate the Advanced Linux Sound Architecture library */
-#undef HAVE_ALSA
-
-/* Define to 1 if you have the <arpa/inet.h> header file. */
-#undef HAVE_ARPA_INET_H
-
-/* Define to 1 if you have the `asprintf' function. */
-#undef HAVE_ASPRINTF
-
-/* Define to 1 if you have the `atexit' function. */
-#undef HAVE_ATEXIT
-
-/* Define to 1 if you have the `bzero' function. */
-#undef HAVE_BZERO
-
-/* Define to 1 if your system has a working `chown' function. */
-#undef HAVE_CHOWN
-
-/* Define if your system has the curl libraries. */
-#undef HAVE_CURL
-
-/* Define to indicate the curses library */
-#undef HAVE_CURSES
-
-/* Define to 1 if you have the <dirent.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_DIRENT_H
-
-/* Define to 1 if you don't have `vprintf' but do have `_doprnt.' */
-#undef HAVE_DOPRNT
-
-/* Define to 1 if you have the `dup2' function. */
-#undef HAVE_DUP2
-
-/* Define to 1 if you have the `endpwent' function. */
-#undef HAVE_ENDPWENT
-
-/* Define to 1 if you have the <fcntl.h> header file. */
-#undef HAVE_FCNTL_H
-
-/* Define to 1 if you have the `floor' function. */
-#undef HAVE_FLOOR
-
-/* Define to 1 if you have the `fork' function. */
-#undef HAVE_FORK
-
-/* Define to indicate the FreeTDS library */
-#undef HAVE_FREETDS
-
-/* Define to 1 if fseeko (and presumably ftello) exists and is declared. */
-#undef HAVE_FSEEKO
-
-/* Define to 1 if you have the `ftruncate' function. */
-#undef HAVE_FTRUNCATE
-
-/* Define to 1 if you have the `getcwd' function. */
-#undef HAVE_GETCWD
-
-/* Define to 1 if you have the `gethostbyname' function. */
-#undef HAVE_GETHOSTBYNAME
-
-/* Define to 1 if you have the `gethostname' function. */
-#undef HAVE_GETHOSTNAME
-
-/* Define to 1 if you have the `getpagesize' function. */
-#undef HAVE_GETPAGESIZE
-
-/* Define to 1 if you have the `gettimeofday' function. */
-#undef HAVE_GETTIMEOFDAY
-
-/* Define to indicate the GSM library */
-#undef HAVE_GSM
-
-/* Define if your system has the GTK libraries. */
-#undef HAVE_GTK
-
-/* Define to indicate the Iksemel Jabber Library library */
-#undef HAVE_IKSEMEL
-
-/* Define to 1 if you have the `inet_ntoa' function. */
-#undef HAVE_INET_NTOA
-
-/* Define to 1 if you have the <inttypes.h> header file. */
-#undef HAVE_INTTYPES_H
-
-/* Define to 1 if you have the `isascii' function. */
-#undef HAVE_ISASCII
-
-/* Define to 1 if you have the <libintl.h> header file. */
-#undef HAVE_LIBINTL_H
-
-/* Define if your system has the KDE library */
-#undef HAVE_LIBKDE
-
-/* Define to indicate the ISDN PRI library */
-#undef HAVE_LIBPRI
-
-/* Define if your system has the Qt library */
-#undef HAVE_LIBQT
-
-/* Define if your system has the VoiceTronix (vpb) libraries. */
-#undef HAVE_LIBVPB
-
-/* Define to 1 if you have the <limits.h> header file. */
-#undef HAVE_LIMITS_H
-
-/* Define to 1 if you have the <locale.h> header file. */
-#undef HAVE_LOCALE_H
-
-/* Define to 1 if you have the `localtime_r' function. */
-#undef HAVE_LOCALTIME_R
-
-/* Define to 1 if your system has a GNU libc compatible `malloc' function, and
-   to 0 otherwise. */
-#undef HAVE_MALLOC
-
-/* Define to 1 if you have the <malloc.h> header file. */
-#undef HAVE_MALLOC_H
-
-/* Define to 1 if you have the `memchr' function. */
-#undef HAVE_MEMCHR
-
-/* Define to 1 if you have the `memmove' function. */
-#undef HAVE_MEMMOVE
-
-/* Define to 1 if you have the <memory.h> header file. */
-#undef HAVE_MEMORY_H
-
-/* Define to 1 if you have the `memset' function. */
-#undef HAVE_MEMSET
-
-/* Define to 1 if you have the `mkdir' function. */
-#undef HAVE_MKDIR
-
-/* Define to 1 if you have a working `mmap' system call. */
-#undef HAVE_MMAP
-
-/* Define to 1 if you have the `munmap' function. */
-#undef HAVE_MUNMAP
-
-/* Define to indicate the Network Broadcast Sound library */
-#undef HAVE_NBS
-
-/* Define to indicate the ncurses library */
-#undef HAVE_NCURSES
-
-/* Define to 1 if you have the <ndir.h> header file, and it defines `DIR'. */
-#undef HAVE_NDIR_H
-
-/* Define to 1 if you have the <netdb.h> header file. */
-#undef HAVE_NETDB_H
-
-/* Define to 1 if you have the <netinet/in.h> header file. */
-#undef HAVE_NETINET_IN_H
-
-/* Define to indicate the newt library */
-#undef HAVE_NEWT
-
-/* Define to indicate the OGG library */
-#undef HAVE_OGG
-
-/* Define to indicate the OpenSSL library */
-#undef HAVE_OPENSSL
-
-/* Define to indicate the OSP Toolkit library */
-#undef HAVE_OSPTK
-
-/* Define to indicate the Open Sound System library */
-#undef HAVE_OSS
-
-/* Define to indicate the popt library */
-#undef HAVE_POPT
-
-/* Define to 1 if you have the `pow' function. */
-#undef HAVE_POW
-
-/* Define to indicate the PostgreSQL library */
-#undef HAVE_PQ
-
-/* Define to 1 if the system has the type `ptrdiff_t'. */
-#undef HAVE_PTRDIFF_T
-
-/* Define to 1 if you have the `putenv' function. */
-#undef HAVE_PUTENV
-
-/* Define to indicate the Radius Client library */
-#undef HAVE_RADIUSCLIENT
-
-/* Define to 1 if your system has a GNU libc compatible `realloc' function,
-   and to 0 otherwise. */
-#undef HAVE_REALLOC
-
-/* Define to 1 if you have the `regcomp' function. */
-#undef HAVE_REGCOMP
-
-/* Define to 1 if you have the `re_comp' function. */
-#undef HAVE_RE_COMP
-
-/* Define to 1 if you have the `rint' function. */
-#undef HAVE_RINT
-
-/* Define to 1 if you have the `select' function. */
-#undef HAVE_SELECT
-
-/* Define to 1 if you have the `setenv' function. */
-#undef HAVE_SETENV
-
-/* Define to 1 if you have the `socket' function. */
-#undef HAVE_SOCKET
-
-/* Define to indicate the Speex library */
-#undef HAVE_SPEEX
-
-/* Define to indicate the SQLite library */
-#undef HAVE_SQLITE
-
-/* Define to 1 if you have the `sqrt' function. */
-#undef HAVE_SQRT
-
-/* Define to 1 if `stat' has the bug that it succeeds when given the
-   zero-length file name argument. */
-#undef HAVE_STAT_EMPTY_STRING_BUG
-
-/* Define to 1 if stdbool.h conforms to C99. */
-#undef HAVE_STDBOOL_H
-
-/* Define to 1 if you have the <stddef.h> header file. */
-#undef HAVE_STDDEF_H
-
-/* Define to 1 if you have the <stdint.h> header file. */
-#undef HAVE_STDINT_H
-
-/* Define to 1 if you have the <stdlib.h> header file. */
-#undef HAVE_STDLIB_H
-
-/* Define to 1 if you have the `strcasecmp' function. */
-#undef HAVE_STRCASECMP
-
-/* Define to 1 if you have the `strcasestr' function. */
-#undef HAVE_STRCASESTR
-
-/* Define to 1 if you have the `strchr' function. */
-#undef HAVE_STRCHR
-
-/* Define to 1 if you have the `strcoll' function and it is properly defined.
-   */
-#undef HAVE_STRCOLL
-
-/* Define to 1 if you have the `strcspn' function. */
-#undef HAVE_STRCSPN
-
-/* Define to 1 if you have the `strdup' function. */
-#undef HAVE_STRDUP
-
-/* Define to 1 if you have the `strerror' function. */
-#undef HAVE_STRERROR
-
-/* Define to 1 if you have the `strftime' function. */
-#undef HAVE_STRFTIME
-
-/* Define to 1 if you have the <strings.h> header file. */
-#undef HAVE_STRINGS_H
-
-/* Define to 1 if you have the <string.h> header file. */
-#undef HAVE_STRING_H
-
-/* Define to 1 if you have the `strncasecmp' function. */
-#undef HAVE_STRNCASECMP
-
-/* Define to 1 if you have the `strndup' function. */
-#undef HAVE_STRNDUP
-
-/* Define to 1 if you have the `strrchr' function. */
-#undef HAVE_STRRCHR
-
-/* Define to 1 if you have the `strsep' function. */
-#undef HAVE_STRSEP
-
-/* Define to 1 if you have the `strspn' function. */
-#undef HAVE_STRSPN
-
-/* Define to 1 if you have the `strstr' function. */
-#undef HAVE_STRSTR
-
-/* Define to 1 if you have the `strtol' function. */
-#undef HAVE_STRTOL
-
-/* Define to 1 if you have the `strtoq' function. */
-#undef HAVE_STRTOQ
-
-/* Define to 1 if `st_blksize' is member of `struct stat'. */
-#undef HAVE_STRUCT_STAT_ST_BLKSIZE
-
-/* Define to 1 if you have the <syslog.h> header file. */
-#undef HAVE_SYSLOG_H
-
-/* Define to 1 if you have the <sys/dir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_DIR_H
-
-/* Define to 1 if you have the <sys/file.h> header file. */
-#undef HAVE_SYS_FILE_H
-
-/* Define to 1 if you have the <sys/ioctl.h> header file. */
-#undef HAVE_SYS_IOCTL_H
-
-/* Define to 1 if you have the <sys/ndir.h> header file, and it defines `DIR'.
-   */
-#undef HAVE_SYS_NDIR_H
-
-/* Define to 1 if you have the <sys/param.h> header file. */
-#undef HAVE_SYS_PARAM_H
-
-/* Define to 1 if you have the <sys/select.h> header file. */
-#undef HAVE_SYS_SELECT_H
-
-/* Define to 1 if you have the <sys/socket.h> header file. */
-#undef HAVE_SYS_SOCKET_H
-
-/* Define to 1 if you have the <sys/stat.h> header file. */
-#undef HAVE_SYS_STAT_H
-
-/* Define to 1 if you have the <sys/time.h> header file. */
-#undef HAVE_SYS_TIME_H
-
-/* Define to 1 if you have the <sys/types.h> header file. */
-#undef HAVE_SYS_TYPES_H
-
-/* Define to 1 if you have <sys/wait.h> that is POSIX.1 compatible. */
-#undef HAVE_SYS_WAIT_H
-
-/* Define to indicate the Termcap library */
-#undef HAVE_TERMCAP
-
-/* Define to 1 if you have the <termios.h> header file. */
-#undef HAVE_TERMIOS_H
-
-/* Define to indicate the Term Info library */
-#undef HAVE_TINFO
-
-/* Define to 1 if you have the <unistd.h> header file. */
-#undef HAVE_UNISTD_H
-
-/* Define to indicate the unixODBC library */
-#undef HAVE_UNIXODBC
-
-/* Define to 1 if you have the `unsetenv' function. */
-#undef HAVE_UNSETENV
-
-/* Define to 1 if you have the `utime' function. */
-#undef HAVE_UTIME
-
-/* Define to 1 if you have the <utime.h> header file. */
-#undef HAVE_UTIME_H
-
-/* Define to 1 if `utime(file, NULL)' sets file's timestamp to the present. */
-#undef HAVE_UTIME_NULL
-
-/* Define to 1 if you have the `vasprintf' function. */
-#undef HAVE_VASPRINTF
-
-/* Define to 1 if you have the `vfork' function. */
-#undef HAVE_VFORK
-
-/* Define to 1 if you have the <vfork.h> header file. */
-#undef HAVE_VFORK_H
-
-/* Define to indicate the Vorbis library */
-#undef HAVE_VORBIS
-
-/* Define to 1 if you have the `vprintf' function. */
-#undef HAVE_VPRINTF
-
-/* Define to 1 if `fork' works. */
-#undef HAVE_WORKING_FORK
-
-/* Define to 1 if `vfork' works. */
-#undef HAVE_WORKING_VFORK
-
-/* Define to indicate the Zaptel library */
-#undef HAVE_ZAPTEL
-
-/* Define to indicate the zlib library */
-#undef HAVE_ZLIB
-
-/* Define to 1 if the system has the type `_Bool'. */
-#undef HAVE__BOOL
-
-/* Define to 1 if `lstat' dereferences a symlink specified with a trailing
-   slash. */
-#undef LSTAT_FOLLOWS_SLASHED_SYMLINK
-
-/* Define according to your operating system type. */
-#undef Linux
-
-/* Define according to your operating system type. */
-#undef NetBSD
-
-/* Define according to your operating system type. */
-#undef OpenBSD
-
-/* Define to the address where bug reports for this package should be sent. */
-#undef PACKAGE_BUGREPORT
-
-/* Define to the full name of this package. */
-#undef PACKAGE_NAME
-
-/* Define to the full name and version of this package. */
-#undef PACKAGE_STRING
-
-/* Define to the one symbol short name of this package. */
-#undef PACKAGE_TARNAME
-
-/* Define to the version of this package. */
-#undef PACKAGE_VERSION
-
-/* Define this to be the name of the CPU of your system. */
-#undef PBX_CPU
-
-/* Define this to be the name of the OS of your system. */
-#undef PBX_OS
-
-/* Define this to be the canonical name (cpu-vendor-os) of your system. */
-#undef PBX_PLATFORM
-
-/* Define this to be the name of the vendor of your system. */
-#undef PBX_VENDOR
-
-/* Define to 1 if the C compiler supports function prototypes. */
-#undef PROTOTYPES
-
-/* Define as the return type of signal handlers (`int' or `void'). */
-#undef RETSIGTYPE
-
-/* Define to the type of arg 1 for `select'. */
-#undef SELECT_TYPE_ARG1
-
-/* Define to the type of args 2, 3 and 4 for `select'. */
-#undef SELECT_TYPE_ARG234
-
-/* Define to the type of arg 5 for `select'. */
-#undef SELECT_TYPE_ARG5
-
-/* Define to 1 if the `setvbuf' function takes the buffering type as its
-   second argument and the buffer pointer as the third, as on System V before
-   release 3. */
-#undef SETVBUF_REVERSED
-
-/* If using the C implementation of alloca, define if you know the
-   direction of stack growth for your system; otherwise it will be
-   automatically deduced at runtime.
-	STACK_DIRECTION > 0 => grows toward higher addresses
-	STACK_DIRECTION < 0 => grows toward lower addresses
-	STACK_DIRECTION = 0 => direction of growth unknown */
-#undef STACK_DIRECTION
-
-/* Define to 1 if you have the ANSI C header files. */
-#undef STDC_HEADERS
-
-/* Define according to your operating system type. */
-#undef SunOS
-
-/* Define to 1 if you can safely include both <sys/time.h> and <time.h>. */
-#undef TIME_WITH_SYS_TIME
-
-/* Define to 1 if your <sys/time.h> declares `struct tm'. */
-#undef TM_IN_SYS_TIME
-
-/* Define according to your operating system type. */
-#undef Unix
-
-/* Define according to your operating system type. */
-#undef Win32
-
-/* Number of bits in a file offset, on hosts where this is settable. */
-#undef _FILE_OFFSET_BITS
-
-/* Enable GNU extensions on systems that have them.  */
-#ifndef _GNU_SOURCE
-# undef _GNU_SOURCE
-#endif
-
-/* Define to 1 to make fseeko visible on some hosts (e.g. glibc 2.2). */
-#undef _LARGEFILE_SOURCE
-
-/* Define for large files, on AIX-style hosts. */
-#undef _LARGE_FILES
-
-/* Define like PROTOTYPES; this can be used by system headers. */
-#undef __PROTOTYPES
-
-/* Define to empty if `const' does not conform to ANSI C. */
-#undef const
-
-/* Define to `int' if <sys/types.h> doesn't define. */
-#undef gid_t
-
-/* Define to `__inline__' or `__inline' if that's what the C compiler
-   calls it, or to nothing if 'inline' is not supported under any name.  */
-#ifndef __cplusplus
-#undef inline
-#endif
-
-/* Define to rpl_malloc if the replacement function should be used. */
-#undef malloc
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef mode_t
-
-/* Define to `long int' if <sys/types.h> does not define. */
-#undef off_t
-
-/* Define to `int' if <sys/types.h> does not define. */
-#undef pid_t
-
-/* Define to rpl_realloc if the replacement function should be used. */
-#undef realloc
-
-/* Define to `unsigned int' if <sys/types.h> does not define. */
-#undef size_t
-
-/* Define to `int' if <sys/types.h> doesn't define. */
-#undef uid_t
-
-/* Define as `fork' if `vfork' does not work. */
-#undef vfork
-
-/* Define to empty if the keyword `volatile' does not work. Warning: valid
-   code using `volatile' can become incorrect without. Disable with care. */
-#undef volatile
-
-#endif
-

Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/pbx.c	2006-06-23 17:20:16 UTC (rev 291)
@@ -62,7 +62,6 @@
 #include "asterisk/musiconhold.h"
 #include "asterisk/app.h"
 #include "asterisk/devicestate.h"
-#include "asterisk/compat.h"
 #include "asterisk/stringfields.h"
 
 /*!

Modified: trunk/utils/ael_main.c
===================================================================
--- trunk/utils/ael_main.c	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/utils/ael_main.c	2006-06-23 17:20:16 UTC (rev 291)
@@ -1,4 +1,4 @@
-#include "autoconfig.h"
+#include "asterisk/autoconfig.h"
 
 #include <sys/types.h>
 #include <stdio.h>

Modified: trunk/utils/astman.c
===================================================================
--- trunk/utils/astman.c	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/utils/astman.c	2006-06-23 17:20:16 UTC (rev 291)
@@ -22,7 +22,7 @@
  *
  */
  
-#include "autoconfig.h"
+#include "asterisk/autoconfig.h"
 
 #include <newt.h>
 #include <stdio.h>

Modified: trunk/utils/smsq.c
===================================================================
--- trunk/utils/smsq.c	2006-06-23 17:05:10 UTC (rev 290)
+++ trunk/utils/smsq.c	2006-06-23 17:20:16 UTC (rev 291)
@@ -17,7 +17,7 @@
  * at the top of the source tree.
  */
 
-#include "autoconfig.h"
+#include "asterisk/autoconfig.h"
 
 #include <stdio.h>
 #include <popt.h>



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:23:42 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:23:42 +0200
Subject: [solid-pbx-svn] r292 - in trunk: apps include/asterisk
Message-ID: <200606231723.k5NHNgDn022450@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:23:38 +0200 (Fri, 23 Jun 2006)
New Revision: 292

Modified:
   trunk/apps/app_followme.c
   trunk/include/asterisk/astmm.h
Log:
Update to Asterisk SVN trunk r32873

------------------------------------------------------------------------
r32864 | kpfleming | 2006-06-07 21:06:30 +0200 (Wed, 07 Jun 2006) | 2 lines

put the proper filename into the ignore property

------------------------------------------------------------------------
r32867 | russell | 2006-06-07 21:42:37 +0200 (Wed, 07 Jun 2006) | 4 lines

fix an incorrect usage of scanf, where it should be using sscanf, instead,
which was causing asterisk to hang when loading this module
(reported by blitzrage on IRC)

------------------------------------------------------------------------
r32868 | russell | 2006-06-07 21:53:03 +0200 (Wed, 07 Jun 2006) | 2 lines

fix the build with astmm enabled

------------------------------------------------------------------------


Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-23 17:20:16 UTC (rev 291)
+++ trunk/apps/app_followme.c	2006-06-23 17:23:38 UTC (rev 292)
@@ -308,9 +308,10 @@
 	}
 	featuredigittostr = ast_variable_retrieve(cfg, "general", "featuredigittimeout");
 	
-	if (!ast_strlen_zero(featuredigittostr)) 
-		if (!scanf("%d", &featuredigittimeout))
+	if (!ast_strlen_zero(featuredigittostr)) {
+		if (!sscanf(featuredigittostr, "%d", &featuredigittimeout))
 			featuredigittimeout = 5000;
+	}
 
 	takecallstr = ast_variable_retrieve(cfg, "general", "takecall");
 	if (!ast_strlen_zero(takecallstr))

Modified: trunk/include/asterisk/astmm.h
===================================================================
--- trunk/include/asterisk/astmm.h	2006-06-23 17:20:16 UTC (rev 291)
+++ trunk/include/asterisk/astmm.h	2006-06-23 17:23:38 UTC (rev 292)
@@ -25,11 +25,14 @@
 
 #define __AST_DEBUG_MALLOC
 
+#include "asterisk.h"
+
 /* Include these now to prevent them from being needed later */
 #include <sys/types.h>
 #include <stdlib.h>
 #include <string.h>
 #include <stdio.h>
+#include <stdarg.h>
 
 /* Undefine any macros */
 #undef malloc



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:25:26 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:25:26 +0200
Subject: [solid-pbx-svn] r293 - trunk/apps
Message-ID: <200606231725.k5NHPQ1c023327@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:25:24 +0200 (Fri, 23 Jun 2006)
New Revision: 293

Modified:
   trunk/apps/app_followme.c
Log:
Update to Asterisk SVN trunk r32883

------------------------------------------------------------------------
r32878 | russell | 2006-06-07 22:02:07 +0200 (Wed, 07 Jun 2006) | 3 lines

simplify the loop that iterates through the categories in followme.conf and
don't try to read the general section as a followme profile

------------------------------------------------------------------------


Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-23 17:23:38 UTC (rev 292)
+++ trunk/apps/app_followme.c	2006-06-23 17:25:24 UTC (rev 293)
@@ -279,7 +279,7 @@
 {
 	struct ast_call_followme *f;
 	struct ast_config *cfg;
-	char *cat, *tmp;
+	char *cat = NULL, *tmp;
 	struct ast_variable *var;
 	struct number *cur, *nm;
 	int new, idx;
@@ -346,8 +346,9 @@
 		ast_copy_string(sorryprompt, tmpstr, sizeof(sorryprompt));
 
 	/* Chug through config file */
-	cat = ast_category_browse(cfg, NULL);
-	while(cat) {
+	while ((cat = ast_category_browse(cfg, cat))) {
+		if (!strcasecmp(cat, "general"))
+			continue;
 		/* Define a new profile */
 		/* Look for an existing one */
 		AST_LIST_TRAVERSE(&followmes, f, entry) {
@@ -416,7 +417,6 @@
 				AST_LIST_INSERT_HEAD(&followmes, f, entry);
 			}
 		}
-		cat = ast_category_browse(cfg, cat);
 	}
 	ast_config_destroy(cfg);
 



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:34:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:34:31 +0200
Subject: [solid-pbx-svn] r295 - trunk/sounds
Message-ID: <200606231734.k5NHYVh0027146@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:34:29 +0200 (Fri, 23 Jun 2006)
New Revision: 295

Added:
   trunk/sounds/Makefile
   trunk/sounds/sounds.xml
Log:
Add missing file

Added: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-23 17:33:38 UTC (rev 294)
+++ trunk/sounds/Makefile	2006-06-23 17:34:29 UTC (rev 295)
@@ -0,0 +1,53 @@
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
+# Makefile for sound files
+#
+# Copyright (C) 2006, Digium, Inc.
+#
+# Kevin P. Fleming <kpfleming at digium.com>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+include ../menuselect.makeopts
+
+CORE_SOUNDS_VERSION:=1.4.0
+SOUNDS_URL:="http://cork.digium.internal/apache2-default"
+MENUSELECT_CORE_SOUNDS:=$(subst -EN-,-en-,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -FR-,-fr-,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -ES-,-es-,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -WAV,-wav,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -ULAW,-ulaw,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -ALAW,-alaw,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -GSM,-gsm,$(MENUSELECT_CORE_SOUNDS))
+MENUSELECT_CORE_SOUNDS:=$(subst -G729,-g729,$(MENUSELECT_CORE_SOUNDS))
+CORE_SOUNDS:=$(MENUSELECT_CORE_SOUNDS:CORE-SOUNDS-%=asterisk-core-sounds-%-$(CORE_SOUNDS_VERSION).tar.gz)
+MENUSELECT_EXTRA_SOUNDS:=$(subst -EN-,-en-,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -FR-,-fr-,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -ES-,-es-,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -WAV,-wav,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -ULAW,-ulaw,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -ALAW,-alaw,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -GSM,-gsm,$(MENUSELECT_EXTRA_SOUNDS))
+MENUSELECT_EXTRA_SOUNDS:=$(subst -G729,-g729,$(MENUSELECT_EXTRA_SOUNDS))
+EXTRA_SOUNDS:=$(MENUSELECT_EXTRA_SOUNDS:EXTRA-SOUNDS-%=asterisk-extra-sounds-%.tar.gz)
+MENUSELECT_MOH:=$(subst -FREEPLAY-,-freeplay-,$(MENUSELECT_MOH))
+MENUSELECT_MOH:=$(subst -MP3,-mp3,$(MENUSELECT_MOH))
+MOH:=$(MENUSELECT_MOH:MOH-%=asterisk-moh-%.tar.gz)
+
+%.gz:
+	@wget --no-verbose --continue $(SOUNDS_URL)/$@
+
+all:	$(CORE_SOUNDS) $(EXTRA_SOUNDS) $(MOH)
+
+clean:
+
+install: all
+	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds
+	mkdir -p $(DESTDIR)$(ASTDATADIR)/mohmp3
+
+uninstall:
+	rm -rf $(DESTDIR)$(ASTDATADIR)/sounds
+	rm -rf $(DESTDIR)$(ASTDATADIR)/mohmp3

Added: trunk/sounds/sounds.xml
===================================================================
--- trunk/sounds/sounds.xml	2006-06-23 17:33:38 UTC (rev 294)
+++ trunk/sounds/sounds.xml	2006-06-23 17:34:29 UTC (rev 295)
@@ -0,0 +1,50 @@
+	<category name="MENUSELECT_CORE_SOUNDS" displayname="Core Sound Packages" positive_output="yes">
+		<member name="CORE-SOUNDS-EN-WAV" displayname="English, WAV format">
+		</member>
+		<member name="CORE-SOUNDS-EN-ULAW" displayname="English, mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-EN-ALAW" displayname="English, a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-EN-GSM" displayname="English, GSM format" >
+			<defaultenabled>yes</defaultenabled>
+		</member>
+		<member name="CORE-SOUNDS-EN-G729" displayname="English, G.729 format">
+		</member>
+		<member name="CORE-SOUNDS-ES-WAV" displayname="Spanish, WAV format">
+		</member>
+		<member name="CORE-SOUNDS-ES-ULAW" displayname="Spanish, mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-ES-ALAW" displayname="Spanish, a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-ES-GSM" displayname="Spanish, GSM format">
+		</member>
+		<member name="CORE-SOUNDS-ES-G729" displayname="Spanish, G.729 format">
+		</member>
+		<member name="CORE-SOUNDS-FR-WAV" displayname="French, WAV format">
+		</member>
+		<member name="CORE-SOUNDS-FR-ULAW" displayname="French, mu-Law format">
+		</member>
+		<member name="CORE-SOUNDS-FR-ALAW" displayname="French, a-Law format">
+		</member>
+		<member name="CORE-SOUNDS-FR-GSM" displayname="French, GSM format">
+		</member>
+		<member name="CORE-SOUNDS-FR-G729" displayname="French, G.729 format">
+		</member>
+	</category>
+	<category name="MENUSELECT_MOH" displayname="Music On Hold File Package" positive_output="yes">
+		<member name="MOH-FREEPLAY-MP3" displayname="FreePlay Music On Hold Files, MP3 format" >
+			<defaultenabled>yes</defaultenabled>
+		</member>
+	</category>
+	<category name="MENUSELECT_EXTRA_SOUNDS" displayname="Extras Sound Packages" positive_output="yes">
+		<member name="EXTRA-SOUNDS-EN-WAV" displayname="English, WAV format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-ULAW" displayname="English, mu-Law format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-ALAW" displayname="English, a-Law format">
+		</member>
+		<member name="EXTRA-SOUNDS-EN-GSM" displayname="English, GSM format" >
+		</member>
+		<member name="EXTRA-SOUNDS-EN-G729" displayname="English, G.729 format">
+		</member>
+	</category>



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:35:47 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:35:47 +0200
Subject: [solid-pbx-svn] r296 - in trunk: . build_tools sounds
Message-ID: <200606231735.k5NHZlgB027233@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:35:45 +0200 (Fri, 23 Jun 2006)
New Revision: 296

Modified:
   trunk/Makefile
   trunk/build_tools/menuselect.c
   trunk/build_tools/menuselect_curses.c
   trunk/sounds/Makefile
Log:
Update to Asterisk SVN trunk r32903

------------------------------------------------------------------------
r32901 | kpfleming | 2006-06-07 23:05:05 +0200 (Wed, 07 Jun 2006) | 4 lines

don't force the sounds to download... only when needed
fix a few buglets i caused in menuselect
remove downloaded sounds on 'dist-clean'

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-23 17:34:29 UTC (rev 295)
+++ trunk/Makefile	2006-06-23 17:35:45 UTC (rev 296)
@@ -380,7 +380,7 @@
 	@echo " +               make install                +"  
 	@echo " +-------------------------------------------+"  
 
-all: cleantest config.status menuselect.makeopts depend asterisk subdirs sounds
+all: cleantest config.status menuselect.makeopts depend asterisk subdirs
 
 config.status: configure
 	@CFLAGS="" ./configure
@@ -519,12 +519,13 @@
 distclean: dist-clean
 
 dist-clean: clean
+	$(MAKE) -C mxml clean
+	$(MAKE) -C build_tools dist-clean
+	$(MAKE) -C sounds dist-clean
 	rm -f menuselect.makeopts makeopts makeopts.xml
 	rm -f config.log config.status
 	rm -f include/autoconfig.h
 	rm -f include/asterisk/buildopts.h
-	$(MAKE) -C mxml clean
-	$(MAKE) -C build_tools dist-clean
 
 datafiles: all
 	if [ x`$(ID) -un` = xroot ]; then sh build_tools/mkpkgconfig $(DESTDIR)/usr/lib/pkgconfig; fi
@@ -540,6 +541,7 @@
 		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/images ; \
 	done
 	mkdir -p $(DESTDIR)$(AGI_DIR)
+	$(MAKE) -C sounds install
 
 update: 
 	@if [ -d .svn ]; then \
@@ -871,6 +873,7 @@
 	rm -rf $(DESTDIR)$(ASTDATADIR)/firmware
 	rm -rf $(DESTDIR)$(ASTMANDIR)/man8
 	for x in $(SUBDIRS); do $(MAKE) -C $$x uninstall || exit 1 ; done
+	$(MAKE) -C sounds uninstall
 
 uninstall: _uninstall
 	@echo " +--------- Asterisk Uninstall Complete -----+"  

Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-23 17:34:29 UTC (rev 295)
+++ trunk/build_tools/menuselect.c	2006-06-23 17:35:45 UTC (rev 296)
@@ -24,7 +24,7 @@
  * \brief A menu-driven system for Asterisk module selection
  */
 
-#include "autoconfig.h"
+#include "asterisk.h"
 
 #include <stdlib.h>
 #include <stdio.h>
@@ -34,8 +34,6 @@
 #include "mxml/mxml.h"
 #include "menuselect.h"
 
-#include "asterisk.h"
-
 #include "asterisk/linkedlists.h"
 
 #undef MENUSELECT_DEBUG

Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-23 17:34:29 UTC (rev 295)
+++ trunk/build_tools/menuselect_curses.c	2006-06-23 17:35:45 UTC (rev 296)
@@ -24,7 +24,7 @@
  * \brief curses frontend for Asterisk module selection
  */
 
-#include "autoconfig.h"
+#include "asterisk/autoconfig.h"
 
 #include <stdlib.h>
 #include <stdio.h>

Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-23 17:34:29 UTC (rev 295)
+++ trunk/sounds/Makefile	2006-06-23 17:35:45 UTC (rev 296)
@@ -37,12 +37,13 @@
 MENUSELECT_MOH:=$(subst -MP3,-mp3,$(MENUSELECT_MOH))
 MOH:=$(MENUSELECT_MOH:MOH-%=asterisk-moh-%.tar.gz)
 
-%.gz:
+%.tar.gz:
 	@wget --no-verbose --continue $(SOUNDS_URL)/$@
 
 all:	$(CORE_SOUNDS) $(EXTRA_SOUNDS) $(MOH)
 
-clean:
+dist-clean:
+	rm -f *.tar.gz
 
 install: all
 	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 19:33:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 19:33:41 +0200
Subject: [solid-pbx-svn] r294 - in trunk: . apps build_tools
Message-ID: <200606231733.k5NHXfBT026925@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 19:33:38 +0200 (Fri, 23 Jun 2006)
New Revision: 294

Modified:
   trunk/Makefile
   trunk/apps/app_followme.c
   trunk/build_tools/prep_moduledeps
   trunk/build_tools/sounds.xml
Log:
Update to Asterisk SVN trunk r32893

------------------------------------------------------------------------
r32884 | russell | 2006-06-07 22:08:29 +0200 (Wed, 07 Jun 2006) | 2 lines

fix a typo in an option name in config parsing

------------------------------------------------------------------------
r32885 | kpfleming | 2006-06-07 22:19:40 +0200 (Wed, 07 Jun 2006) | 2 lines

prepare for using sound files from out of the source tree

------------------------------------------------------------------------
r32886 | kpfleming | 2006-06-07 22:54:30 +0200 (Wed, 07 Jun 2006) | 2 lines

woo-hoo, now it knows how to download the sound packages... doesn't install them yet though

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-23 17:25:24 UTC (rev 293)
+++ trunk/Makefile	2006-06-23 17:33:38 UTC (rev 294)
@@ -13,6 +13,8 @@
 
 .EXPORT_ALL_VARIABLES:
 
+.PHONY: sounds
+
 # Create OPTIONS variable
 OPTIONS=
 
@@ -378,7 +380,7 @@
 	@echo " +               make install                +"  
 	@echo " +-------------------------------------------+"  
 
-all: cleantest config.status menuselect.makeopts depend asterisk subdirs
+all: cleantest config.status menuselect.makeopts depend asterisk subdirs sounds
 
 config.status: configure
 	@CFLAGS="" ./configure
@@ -533,52 +535,6 @@
 	for x in static-http/*; do \
 		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/static-http ; \
 	done
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/digits
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/priv-callerintros
-	for x in sounds/digits/*.gsm; do \
-		if $(GREP) -q "^%`basename $$x`%" sounds.txt; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds/digits ; \
-		else \
-			echo "No description for $$x"; \
-			exit 1; \
-		fi; \
-	done
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/dictate
-	for x in sounds/dictate/*.gsm; do \
-		if $(GREP) -q "^%`basename $$x`%" sounds.txt; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds/dictate ; \
-		else \
-			echo "No description for $$x"; \
-			exit 1; \
-		fi; \
-	done
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/letters
-	for x in sounds/letters/*.gsm; do \
-		if $(GREP) -q "^%`basename $$x`%" sounds.txt; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds/letters ; \
-		else \
-			echo "No description for $$x"; \
-			exit 1; \
-		fi; \
-	done
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds/phonetic
-	for x in sounds/phonetic/*.gsm; do \
-		if $(GREP) -q "^%`basename $$x`%" sounds.txt; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds/phonetic ; \
-		else \
-			echo "No description for $$x"; \
-			exit 1; \
-		fi; \
-	done
-	for x in sounds/demo-* sounds/vm-* sounds/transfer* sounds/pbx-* sounds/ss-* sounds/beep* sounds/dir-* sounds/conf-* sounds/agent-* sounds/invalid* sounds/tt-* sounds/auth-* sounds/privacy-* sounds/queue-* sounds/spy-* sounds/priv-* sounds/screen-* sounds/hello-*; do \
-		if $(GREP) -q "^%`basename $$x`%" sounds.txt; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds ; \
-		else \
-			echo "No description for $$x"; \
-			exit 1; \
-		fi; \
-	done
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/mohmp3
 	mkdir -p $(DESTDIR)$(ASTDATADIR)/images
 	for x in images/*.jpg; do \
 		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/images ; \
@@ -640,7 +596,6 @@
 	if [ -n "$(OLDHEADERS)" ]; then \
 		rm -f $(addprefix $(DESTDIR)$(ASTHEADERDIR)/,$(OLDHEADERS)) ;\
 	fi
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds
 	mkdir -p $(DESTDIR)$(ASTLOGDIR)/cdr-csv
 	mkdir -p $(DESTDIR)$(ASTLOGDIR)/cdr-custom
 	mkdir -p $(DESTDIR)$(ASTDATADIR)/keys
@@ -762,20 +717,6 @@
 	else \
 		echo "Skipping asterisk.conf creation"; \
 	fi
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds ; \
-	for x in sounds/demo-*; do \
-		if $(GREP) -q "^%`basename $$x`%" sounds.txt; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/sounds ; \
-		else \
-			echo "No description for $$x"; \
-			exit 1; \
-		fi; \
-	done
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/mohmp3 ; \
-	for x in sounds/*.mp3; do \
-		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTDATADIR)/mohmp3 ; \
-	done
-	rm -f $(DESTDIR)$(ASTDATADIR)/mohmp3/sample-hold.mp3
 	mkdir -p $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/INBOX
 	:> $(DESTDIR)$(ASTSPOOLDIR)/voicemail/default/1234/unavail.gsm
 	for x in vm-theperson digits/1 digits/2 digits/3 digits/4 vm-isunavail; do \
@@ -905,6 +846,9 @@
 %_env:
 	$(MAKE) -C $(shell echo $@ | sed "s/_env//g") env
 
+sounds:
+	$(MAKE) -C sounds all
+
 env:
 	env
 
@@ -924,7 +868,6 @@
 	rm -f $(DESTDIR)$(ASTSBINDIR)/astgenkey
 	rm -f $(DESTDIR)$(ASTSBINDIR)/autosupport
 	rm -rf $(DESTDIR)$(ASTHEADERDIR)
-	rm -rf $(DESTDIR)$(ASTDATADIR)/sounds
 	rm -rf $(DESTDIR)$(ASTDATADIR)/firmware
 	rm -rf $(DESTDIR)$(ASTMANDIR)/man8
 	for x in $(SUBDIRS); do $(MAKE) -C $$x uninstall || exit 1 ; done
@@ -961,7 +904,7 @@
 	@cd mxml && unset CFLAGS LIBS && test -f config.h || ./configure
 	$(MAKE) -C mxml libmxml.a
 
-makeopts.xml: $(foreach dir,$(MOD_SUBDIRS),$(dir)/*.c) build_tools/cflags.xml build_tools/sounds.xml
+makeopts.xml: $(foreach dir,$(MOD_SUBDIRS),$(dir)/*.c) build_tools/cflags.xml sounds/sounds.xml
 	@echo "Generating list of available modules ..."
 	@build_tools/prep_moduledeps > $@
 

Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-23 17:25:24 UTC (rev 293)
+++ trunk/apps/app_followme.c	2006-06-23 17:33:38 UTC (rev 294)
@@ -234,7 +234,7 @@
 		ast_copy_string(f->nextindp, val, sizeof(f->nextindp));
 	} else if (!strcasecmp(param, "call-from-prompt")) {
 		ast_copy_string(f->callfromprompt, val, sizeof(f->callfromprompt));
-	} else if (!strcasecmp(param, "followme-recording-prompt")) {
+	} else if (!strcasecmp(param, "followme-norecording-prompt")) {
 		ast_copy_string(f->norecordingprompt, val, sizeof(f->norecordingprompt));
 	} else if (!strcasecmp(param, "followme-options-prompt")) {
 		ast_copy_string(f->optionsprompt, val, sizeof(f->optionsprompt));

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-06-23 17:25:24 UTC (rev 293)
+++ trunk/build_tools/prep_moduledeps	2006-06-23 17:33:38 UTC (rev 294)
@@ -57,5 +57,5 @@
 process_dir pbx pbx PBX "PBX Modules"
 process_dir res res RES "Resource Modules"
 cat build_tools/cflags.xml
-cat build_tools/sounds.xml
+cat sounds/sounds.xml
 echo "</menu>"

Modified: trunk/build_tools/sounds.xml
===================================================================
--- trunk/build_tools/sounds.xml	2006-06-23 17:25:24 UTC (rev 293)
+++ trunk/build_tools/sounds.xml	2006-06-23 17:33:38 UTC (rev 294)
@@ -1,33 +0,0 @@
-	<category name="MENUSELECT_SOUNDS" displayname="Sound Packages" positive_output="yes">
-		<member name="CORE_SOUNDS_EN_WAV" displayname="Core Sounds - English, WAV format">
-		</member>
-		<member name="CORE_SOUNDS_EN_ULAW" displayname="Core Sounds - English, mu-Law format">
-		</member>
-		<member name="CORE_SOUNDS_EN_ALAW" displayname="Core Sounds - English, a-Law format">
-		</member>
-		<member name="CORE_SOUNDS_EN_GSM" displayname="Core Sounds - English, GSM format" >
-			<defaultenabled>yes</defaultenabled>
-		</member>
-		<member name="CORE_SOUNDS_EN_G729" displayname="Core Sounds - English, G.729 format">
-		</member>
-		<member name="CORE_SOUNDS_ES_WAV" displayname="Core Sounds - Spanish, WAV format">
-		</member>
-		<member name="CORE_SOUNDS_ES_ULAW" displayname="Core Sounds - Spanish, mu-Law format">
-		</member>
-		<member name="CORE_SOUNDS_ES_ALAW" displayname="Core Sounds - Spanish, a-Law format">
-		</member>
-		<member name="CORE_SOUNDS_ES_GSM" displayname="Core Sounds - Spanish, GSM format">
-		</member>
-		<member name="CORE_SOUNDS_ES_G729" displayname="Core Sounds - Spanish, G.729 format">
-		</member>
-		<member name="CORE_SOUNDS_FR_WAV" displayname="Core Sounds - French, WAV format">
-		</member>
-		<member name="CORE_SOUNDS_FR_ULAW" displayname="Core Sounds - French, mu-Law format">
-		</member>
-		<member name="CORE_SOUNDS_FR_ALAW" displayname="Core Sounds - French, a-Law format">
-		</member>
-		<member name="CORE_SOUNDS_FR_GSM" displayname="Core Sounds - French, GSM format">
-		</member>
-		<member name="CORE_SOUNDS_FR_G729" displayname="Core Sounds - French, G.729 format">
-		</member>
-	</category>



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 20:25:36 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 20:25:36 +0200
Subject: [solid-pbx-svn] r297 - in trunk: . configs include/asterisk res sounds
Message-ID: <200606231825.k5NIPaNH012124@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 20:25:32 +0200 (Fri, 23 Jun 2006)
New Revision: 297

Modified:
   trunk/Makefile
   trunk/configs/jabber.conf.sample
   trunk/configs/musiconhold.conf.sample
   trunk/include/asterisk/jabber.h
   trunk/res/res_jabber.c
   trunk/sounds/Makefile
   trunk/sounds/sounds.xml
Log:
Update to Asterisk SVN trunk r32923

------------------------------------------------------------------------
r32916 | kpfleming | 2006-06-08 00:03:02 +0200 (Thu, 08 Jun 2006) | 2 lines

ok, now it knows how to auto-download and install

------------------------------------------------------------------------
r32917 | kpfleming | 2006-06-08 00:37:31 +0200 (Thu, 08 Jun 2006) | 5 lines

moh files will now be distributed in native format, not mp3, so...
update sounds/Makefile to download/unpack the proper files
remove all evidence of mpg123 from the main Makefile
change the sample musiconhold.conf file to use native mode instead of mp3

------------------------------------------------------------------------
r32918 | mogorman | 2006-06-08 00:43:20 +0200 (Thu, 08 Jun 2006) | 4 lines

solves some bugs with memory allocation, and adds
a message stack.


------------------------------------------------------------------------
r32919 | kpfleming | 2006-06-08 00:55:46 +0200 (Thu, 08 Jun 2006) | 2 lines

ok, new sounds/moh handling stuff should be done... bring on the bug reports!

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/Makefile	2006-06-23 18:25:32 UTC (rev 297)
@@ -196,7 +196,6 @@
       endif
     endif
   endif
-  MPG123TARG=linux
 endif
 
 GREP=grep
@@ -239,12 +238,10 @@
   ifneq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/local/include/spandsp),)
     ASTCFLAGS+=-I$(CROSS_COMPILE_TARGET)/usr/local/include/spandsp
   endif
-  MPG123TARG=freebsd
 endif # FreeBSD
 
 ifeq ($(OSARCH),NetBSD)
   AST_CFLAGS+=-pthread -I$(CROSS_COMPILE_TARGET)/usr/pkg/include
-  MPG123TARG=netbsd
 endif
 
 ifeq ($(OSARCH),OpenBSD)
@@ -512,7 +509,6 @@
 	rm -f include/asterisk/version.h
 	rm -f .tags-sources tags TAGS
 	@if [ -f editline/Makefile ]; then $(MAKE) -C editline distclean ; fi
-	@if [ -d mpg123-0.59r ]; then $(MAKE) -C mpg123-0.59r clean; fi
 	$(MAKE) -C db1-ast clean
 	$(MAKE) -C stdtime clean
 
@@ -615,7 +611,6 @@
 	else \
 		echo "You need to do cvs update -d not just cvs update" ; \
 	fi 
-	if [ -f mpg123-0.59r/mpg123 ]; then $(MAKE) -C mpg123-0.59r install; fi
 
 install-subdirs:
 	@for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
@@ -773,12 +768,6 @@
 	(cat contrib/asterisk-ng-doxygen; echo "HAVE_DOT=$(HAVEDOT)"; \
 	echo "PROJECT_NUMBER=$(ASTERISKVERSION)") | doxygen - 
 
-mpg123:
-	@wget -V >/dev/null || (echo "You need wget" ; false )
-	[ -f mpg123-0.59r.tar.gz ] || wget http://www.mpg123.de/mpg123/mpg123-0.59r.tar.gz
-	[ -d mpg123-0.59r ] || tar xfz mpg123-0.59r.tar.gz
-	$(MAKE) -C mpg123-0.59r $(MPG123TARG)
-
 config:
 	@if [ "${OSARCH}" = "Linux" ]; then \
 		if [ -f /etc/redhat-release -o -f /etc/fedora-release ]; then \

Modified: trunk/configs/jabber.conf.sample
===================================================================
--- trunk/configs/jabber.conf.sample	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/configs/jabber.conf.sample	2006-06-23 18:25:32 UTC (rev 297)
@@ -15,3 +15,4 @@
 ;buddy=mogorman at astjab.org		;;Manual addition of buddy to list.
 ;statusmessage="I am available"		;;Have custom status message for
 					;;Asterisk.
+;timeout=100				;;Timeout on the message stack.

Modified: trunk/configs/musiconhold.conf.sample
===================================================================
--- trunk/configs/musiconhold.conf.sample	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/configs/musiconhold.conf.sample	2006-06-23 18:25:32 UTC (rev 297)
@@ -2,10 +2,10 @@
 ; Music on Hold -- Sample Configuration
 ;
 
-[default]
-mode=quietmp3
-directory=/var/lib/asterisk/mohmp3
-
+;[samplemp3]
+;mode=quietmp3
+;directory=/var/lib/asterisk/mohmp3
+;
 ; valid mode options:
 ; quietmp3 	-- default 
 ; mp3 		-- loud
@@ -55,11 +55,11 @@
 ; understand when it loads.
 ;
 
-;[native]
-;mode=files
-;directory=/var/lib/asterisk/moh-native
+[default]
+mode=files
+directory=/var/lib/asterisk/moh
 ;
 ;[native-random]
 ;mode=files
-;directory=/var/lib/asterisk/moh-native
+;directory=/var/lib/asterisk/moh
 ;random=yes 	; Play the files in a random order

Modified: trunk/include/asterisk/jabber.h
===================================================================
--- trunk/include/asterisk/jabber.h	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/include/asterisk/jabber.h	2006-06-23 18:25:32 UTC (rev 297)
@@ -66,6 +66,14 @@
 	struct aji_resource *next;
 };
 
+struct aji_message {
+	char *from;
+	char *message;
+	char id[25];
+	time_t arrived;
+	struct aji_message *next;
+};
+
 struct aji_buddy {
 	ASTOBJ_COMPONENTS(struct aji_buddy);
 	char user[160];
@@ -108,10 +116,13 @@
 	int keepalive;
 	int allowguest;
 	int timeout;
+	int message_timeout;
 	int authorized;
 	unsigned int flags;
 	enum aji_type component;
 	struct aji_buddy_container buddies;
+ 	ast_mutex_t message_lock; 
+	struct aji_message *messages;
 	void *jingle;
 	pthread_t thread;
 };

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/res/res_jabber.c	2006-06-23 18:25:32 UTC (rev 297)
@@ -61,6 +61,7 @@
 static void aji_log_hook(void *data, const char *xmpp, size_t size, int is_incoming);
 static int aji_act_hook(void *data, int type, iks *node);
 static void aji_handle_iq(struct aji_client *client, iks *node);
+static void aji_handle_message(struct aji_client *client, ikspak *pak);
 static void aji_handle_presence(struct aji_client *client, ikspak *pak);
 static void aji_handle_subscribe(struct aji_client *client, ikspak *pak);
 static void *aji_recv_loop(void *data);
@@ -154,8 +155,16 @@
  */
 static void aji_client_destroy(struct aji_client *obj)
 {
+	struct aji_message *tmp;
 	ASTOBJ_CONTAINER_DESTROYALL(&obj->buddies, aji_buddy_destroy);
 	ASTOBJ_CONTAINER_DESTROY(&obj->buddies);
+
+	while ((tmp = obj->messages)) {
+		obj->messages = obj->messages->next;
+		if(tmp->from) free(tmp->from);
+		if(tmp->message) free(tmp->message);
+		free(tmp);
+	}
 	free(obj);
 }
 
@@ -596,6 +605,7 @@
 			ast_verbose(VERBOSE_PREFIX_3 "JABBER: I Don't know what to do with you NONE\n");
 		break;
 	case IKS_PAK_MESSAGE:
+		aji_handle_message(client, pak);
 		if (option_verbose > 30)
 			ast_verbose(VERBOSE_PREFIX_3 "JABBER: I Don't know what to do with you MESSAGE\n");
 		break;
@@ -619,7 +629,7 @@
 			ast_verbose(VERBOSE_PREFIX_3 "JABBER: I Dont know %i\n", pak->type);
 		break;
 	}
-
+	
 	iks_filter_packet(client->f, pak);
 
 	if (node)
@@ -813,12 +823,13 @@
 	buddy = ASTOBJ_CONTAINER_FIND(&client->buddies, pak->from->partial);
 
 	resource = aji_find_resource(buddy, pak->from->resource);
-	if (!resource) {
-		ast_log(LOG_NOTICE,"JABBER: Received client info from %s when not requested.\n", pak->from->full);
-		ASTOBJ_UNREF(client, aji_client_destroy);
-		return IKS_FILTER_EAT;
-	}	
+
 	if (pak->subtype == IKS_TYPE_RESULT) {
+		if (!resource) {
+			ast_log(LOG_NOTICE,"JABBER: Received client info from %s when not requested.\n", pak->from->full);
+			ASTOBJ_UNREF(client, aji_client_destroy);
+			return IKS_FILTER_EAT;
+		}
 		if (iks_find_with_attrib(pak->query, "feature", "var", "http://www.google.com/xmpp/protocol/voice/v1")) {
 			resource->cap->jingle = 1;
 		} else
@@ -835,7 +846,7 @@
 			iks_insert_attrib(iq, "to", pak->from->full);
 			iks_insert_attrib(iq, "type", "result");
 			iks_insert_attrib(iq, "id", pak->id);
-			iks_insert_attrib(query, "xmlns", "xmlns='http://jabber.org/protocol/disco#info");
+			iks_insert_attrib(query, "xmlns", "http://jabber.org/protocol/disco#info");
 			iks_insert_attrib(ident, "category", "client");
 			iks_insert_attrib(ident, "type", "pc");
 			iks_insert_attrib(ident, "name", "asterisk");
@@ -1012,6 +1023,47 @@
  * \param client structure and the node.
  * \return void.
  */
+static void aji_handle_message(struct aji_client *client, ikspak *pak)
+{
+	struct aji_message *insert, *tmp, *delete, *last;
+	int flag = 0;
+	insert = ast_malloc(sizeof(struct aji_message));
+	memset(insert, 0, sizeof(struct aji_message));
+	insert->arrived = time(NULL);
+	insert->next = NULL;
+	insert->message = ast_strdup(iks_find_cdata(pak->x, "body"));
+	ast_copy_string(insert->id, pak->id, sizeof(insert->message));
+	insert->from = ast_strdup(pak->from->full);
+	ast_mutex_lock(&(client)->message_lock);
+	insert->next = client->messages;
+	client->messages = insert;
+	insert = NULL;
+	tmp = client->messages;
+	last = tmp;
+	while(tmp) {
+		if(flag) { /*timestamp exceeded delete rest */
+			delete = tmp;
+			tmp = tmp->next;
+			if(delete->message) free(delete->message);
+			if(delete->from) free(delete->from);
+			free(delete);
+			delete = NULL;
+		} else if(difftime(time(NULL), tmp->arrived) >= client->message_timeout) {
+			flag = 1;
+			last->next = NULL;
+			delete = tmp;
+			tmp = tmp->next;
+			if(delete->message) free(delete->message);
+			if(delete->from) free(delete->from);
+			free(delete);
+			delete = NULL;
+		} else {
+			last = tmp;
+			tmp = tmp->next;
+		}
+	}
+	ast_mutex_unlock(&(client)->message_lock);
+}
 static void aji_handle_presence(struct aji_client *client, ikspak *pak)
 {
 	int status, priority;
@@ -1020,26 +1072,7 @@
 	char *ver, *node, *descrip;
 	
 	if(client->state != AJI_CONNECTED) {
-		buddy = (struct aji_buddy *) malloc(sizeof(struct aji_buddy));
-		if (!buddy) {
-			ast_log(LOG_WARNING, "Out of memory\n");
-			return ;
-		}
-		memset(buddy, 0, sizeof(struct aji_buddy));
-		ASTOBJ_INIT(buddy);
-		ASTOBJ_WRLOCK(buddy);
-		ast_copy_string(buddy->name, pak->from->partial, sizeof(buddy->name));
-		ast_clear_flag(buddy, AST_FLAGS_ALL);
-		if(ast_test_flag(client, AJI_AUTOPRUNE)) {
-			ast_set_flag(buddy, AJI_AUTOPRUNE);
-			buddy->objflags |= ASTOBJ_FLAG_MARKED;
-		} else
-			ast_set_flag(buddy, AJI_AUTOREGISTER);
-		ASTOBJ_UNLOCK(buddy);
-		if (buddy) {
-			ASTOBJ_CONTAINER_LINK(&client->buddies, buddy);
-			buddy = NULL;
-		}
+		aji_create_buddy(pak->from->partial,client);
 	}
 	buddy = ASTOBJ_CONTAINER_FIND(&client->buddies, pak->from->partial);
 	if (!buddy) {
@@ -1113,6 +1146,7 @@
 
 	if (!found && status != 6) {
 		found = (struct aji_resource *) malloc(sizeof(struct aji_resource));
+		memset(found, 0, sizeof(struct aji_resource));
 		if (!found) {
 			ast_log(LOG_ERROR, "Out of memory!\n");
 			return;
@@ -1369,6 +1403,7 @@
 				sleep(4);
 			}
 		}
+
 		res = iks_recv(client->p, 1);
 		client->timeout--;
 		if (res == IKS_HOOK) {
@@ -1716,13 +1751,13 @@
 {
 	int connected = 0;
 
-	connected = iks_connect_via(client->p, client->serverhost, client->port, client->jid->server);
+	connected = iks_connect_via(client->p, S_OR(client->serverhost, client->jid->server), client->port, client->jid->server);
 
 	if (connected == IKS_NET_NOCONN) {
 		ast_log(LOG_ERROR, "JABBER ERROR: No Connection\n");
 		return IKS_HOOK;
 	} else 	if (connected == IKS_NET_NODNS) {
-		ast_log(LOG_ERROR, "JABBER ERROR: No DNS\n");
+		ast_log(LOG_ERROR, "JABBER ERROR: No DNS %s for client to  %s\n", client->name, S_OR(client->serverhost, client->jid->server));
 		return IKS_HOOK;
 	} else
 		iks_recv(client->p, 30);
@@ -1880,7 +1915,7 @@
 	struct aji_client *client;
 	struct aji_resource *resource;
 	const char *name = "asterisk";
-
+	struct aji_message *tmp;
 	if (argc > 3)
 		return RESULT_SHOWUSAGE;
 	else if (argc == 3)
@@ -1908,7 +1943,16 @@
 		}
 		ASTOBJ_UNLOCK(iterator);
 	});
+	tmp = client->messages;
+	ast_mutex_lock(&(client)->message_lock);
+	ast_verbose("\nOooh a working message stack!\n");
+	while(tmp) {
+	ast_verbose("	Message from: %s with id %s @ %s	%s\n",tmp->from, tmp->id, ctime(&tmp->arrived), tmp->message);
+	tmp = tmp->next;
+	}
+	ast_mutex_unlock(&(client)->message_lock);
 
+
 	ASTOBJ_UNREF(client, aji_client_destroy);
 
 	return RESULT_SUCCESS;
@@ -1949,14 +1993,15 @@
 	ast_copy_flags(client, &globalflags, AST_FLAGS_ALL);
 	client->port = 5222;
 	client->usetls = 1;
+	client->usesasl = 1;
 	client->forcessl = 0;
 	client->keepalive = 1;
 	client->timeout = 20;
+	client->message_timeout = 100;
 	client->component = AJI_CLIENT;
 	ast_copy_string(client->statusmessage, "Online and Available", sizeof(client->statusmessage));
 
 	if (flag) client->authorized = 0;
-	client->usesasl = 0;
 	if (flag) client->state = AJI_DISCONNECTED;
 	while (var) {
 		if (!strcasecmp(var->name, "username"))
@@ -1969,6 +2014,8 @@
 			ast_copy_string(client->statusmessage, var->value, sizeof(client->statusmessage));
 		else if (!strcasecmp(var->name, "port"))
 			client->port = atoi(var->value);
+		else if (!strcasecmp(var->name, "timeout"))
+			client->message_timeout = atoi(var->value);
 		else if (!strcasecmp(var->name, "debug"))
 			client->debug = (ast_false(var->value)) ? 0 : 1;
 		else if (!strcasecmp(var->name, "type")){
@@ -2209,6 +2256,9 @@
 
 static int unload_module(void *mod)
 {
+	ast_cli_unregister_multiple(aji_cli, sizeof(aji_cli) / sizeof(aji_cli[0]));
+	ast_unregister_application(app_ajisend);
+
 	ASTOBJ_CONTAINER_TRAVERSE(&clients, 1, {
 		ASTOBJ_RDLOCK(iterator);
 		if (option_verbose > 2)
@@ -2222,9 +2272,6 @@
 	ASTOBJ_CONTAINER_DESTROYALL(&clients, aji_client_destroy);
 	ASTOBJ_CONTAINER_DESTROY(&clients);
 
-	STANDARD_HANGUP_LOCALUSERS;
-	ast_cli_unregister_multiple(aji_cli, sizeof(aji_cli) / sizeof(aji_cli[0]));
-	ast_unregister_application(app_ajisend);
 	ast_log(LOG_NOTICE, "res_jabber unloaded.\n");
 	return 0;
 }

Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/sounds/Makefile	2006-06-23 18:25:32 UTC (rev 297)
@@ -13,8 +13,12 @@
 
 include ../menuselect.makeopts
 
+PWD:=$(shell pwd)
+SOUNDS_DIR:=$(DESTDIR)$(ASTDATADIR)/sounds
+MOH_DIR:=$(DESTDIR)$(ASTDATADIR)/moh
 CORE_SOUNDS_VERSION:=1.4.0
-SOUNDS_URL:="http://cork.digium.internal/apache2-default"
+SOUNDS_URL:=http://ftp.digium.com/pub/telephony/sounds/releases
+MOH_URL:=http://ftp.digium.com/pub/telephony/sounds
 MENUSELECT_CORE_SOUNDS:=$(subst -EN-,-en-,$(MENUSELECT_CORE_SOUNDS))
 MENUSELECT_CORE_SOUNDS:=$(subst -FR-,-fr-,$(MENUSELECT_CORE_SOUNDS))
 MENUSELECT_CORE_SOUNDS:=$(subst -ES-,-es-,$(MENUSELECT_CORE_SOUNDS))
@@ -24,6 +28,7 @@
 MENUSELECT_CORE_SOUNDS:=$(subst -GSM,-gsm,$(MENUSELECT_CORE_SOUNDS))
 MENUSELECT_CORE_SOUNDS:=$(subst -G729,-g729,$(MENUSELECT_CORE_SOUNDS))
 CORE_SOUNDS:=$(MENUSELECT_CORE_SOUNDS:CORE-SOUNDS-%=asterisk-core-sounds-%-$(CORE_SOUNDS_VERSION).tar.gz)
+CORE_SOUND_TAGS:=$(MENUSELECT_CORE_SOUNDS:CORE-SOUNDS-%=$(SOUNDS_DIR)/.asterisk-core-sounds-%-$(CORE_SOUNDS_VERSION))
 MENUSELECT_EXTRA_SOUNDS:=$(subst -EN-,-en-,$(MENUSELECT_EXTRA_SOUNDS))
 MENUSELECT_EXTRA_SOUNDS:=$(subst -FR-,-fr-,$(MENUSELECT_EXTRA_SOUNDS))
 MENUSELECT_EXTRA_SOUNDS:=$(subst -ES-,-es-,$(MENUSELECT_EXTRA_SOUNDS))
@@ -34,21 +39,64 @@
 MENUSELECT_EXTRA_SOUNDS:=$(subst -G729,-g729,$(MENUSELECT_EXTRA_SOUNDS))
 EXTRA_SOUNDS:=$(MENUSELECT_EXTRA_SOUNDS:EXTRA-SOUNDS-%=asterisk-extra-sounds-%.tar.gz)
 MENUSELECT_MOH:=$(subst -FREEPLAY-,-freeplay-,$(MENUSELECT_MOH))
-MENUSELECT_MOH:=$(subst -MP3,-mp3,$(MENUSELECT_MOH))
+MENUSELECT_MOH:=$(subst -WAV,-wav,$(MENUSELECT_MOH))
+MENUSELECT_MOH:=$(subst -ULAW,-ulaw,$(MENUSELECT_MOH))
+MENUSELECT_MOH:=$(subst -ALAW,-alaw,$(MENUSELECT_MOH))
+MENUSELECT_MOH:=$(subst -GSM,-gsm,$(MENUSELECT_MOH))
+MENUSELECT_MOH:=$(subst -G729,-g729,$(MENUSELECT_MOH))
 MOH:=$(MENUSELECT_MOH:MOH-%=asterisk-moh-%.tar.gz)
+MOH_TAGS:=$(MENUSELECT_MOH:MOH-%=$(MOH_DIR)/.asterisk-moh-%)
 
-%.tar.gz:
+$(SOUNDS_DIR)/.asterisk-core-sounds-en-%:
+	@PACKAGE=$(subst $(SOUNDS_DIR)/.asterisk,asterisk,$@).tar.gz; \
+	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(SOUNDS_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then exit 1; fi; \
+	rm -f $(subst -$(CORE_SOUNDS_VERSION),,$@)-* && \
+	(cd $(SOUNDS_DIR); tar xzf $(PWD)/$${PACKAGE}) && \
+	touch $@
+
+$(SOUNDS_DIR)/.asterisk-core-sounds-fr-%: $(SOUNDS_DIR)/fr
+	@PACKAGE=$(subst $(SOUNDS_DIR)/.asterisk,asterisk,$@).tar.gz; \
+	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(SOUNDS_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then exit 1; fi; \
+	rm -f $(subst -$(CORE_SOUNDS_VERSION),,$@)-* && \
+	(cd $(SOUNDS_DIR)/fr; tar xzf $(PWD)/$${PACKAGE}) && \
+	touch $@
+
+$(SOUNDS_DIR)/.asterisk-core-sounds-fr-%: $(SOUNDS_DIR)/es
+	@PACKAGE=$(subst $(SOUNDS_DIR)/.asterisk,asterisk,$@).tar.gz; \
+	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(SOUNDS_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then exit 1; fi; \
+	rm -f $(subst -$(CORE_SOUNDS_VERSION),,$@)-* && \
+	(cd $(SOUNDS_DIR)/es; tar xzf $(PWD)/$${PACKAGE}) && \
+	touch $@
+
+$(MOH_DIR)/.asterisk-moh-%:
+	@PACKAGE=$(subst $(MOH_DIR)/.asterisk,asterisk,$@).tar.gz; \
+	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(MOH_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then exit 1; fi; \
+	(cd $(MOH_DIR); tar xzf $(PWD)/$${PACKAGE}) && \
+	touch $@
+
+asterisk-core-%.tar.gz:
 	@wget --no-verbose --continue $(SOUNDS_URL)/$@
 
+asterisk-extra-%.tar.gz:
+	@wget --no-verbose --continue $(MOH_URL)/$@
+
+asterisk-moh-%.tar.gz:
+	@wget --no-verbose --continue $(MOH_URL)/$@
+
 all:	$(CORE_SOUNDS) $(EXTRA_SOUNDS) $(MOH)
 
 dist-clean:
 	rm -f *.tar.gz
 
-install: all
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/sounds
-	mkdir -p $(DESTDIR)$(ASTDATADIR)/mohmp3
+$(SOUNDS_DIR) $(MOH_DIR) $(SOUNDS_DIR)/%:
+	mkdir -p $@
 
+install: $(SOUNDS_DIR) $(MOH_DIR) $(CORE_SOUND_TAGS) $(MOH_TAGS)
+
 uninstall:
-	rm -rf $(DESTDIR)$(ASTDATADIR)/sounds
-	rm -rf $(DESTDIR)$(ASTDATADIR)/mohmp3
+	rm -rf $(SOUNDS_DIR)
+	rm -rf $(MOH_DIR)

Modified: trunk/sounds/sounds.xml
===================================================================
--- trunk/sounds/sounds.xml	2006-06-23 17:35:45 UTC (rev 296)
+++ trunk/sounds/sounds.xml	2006-06-23 18:25:32 UTC (rev 297)
@@ -31,10 +31,18 @@
 		<member name="CORE-SOUNDS-FR-G729" displayname="French, G.729 format">
 		</member>
 	</category>
-	<category name="MENUSELECT_MOH" displayname="Music On Hold File Package" positive_output="yes">
-		<member name="MOH-FREEPLAY-MP3" displayname="FreePlay Music On Hold Files, MP3 format" >
+	<category name="MENUSELECT_MOH" displayname="Music On Hold File Packages" positive_output="yes">
+		<member name="MOH-FREEPLAY-WAV" displayname="FreePlay Music On Hold Files, WAV format" >
 			<defaultenabled>yes</defaultenabled>
 		</member>
+		<member name="MOH-FREEPLAY-ULAW" displayname="FreePlay Music On Hold Files, mu-Law format" >
+		</member>
+		<member name="MOH-FREEPLAY-ALAW" displayname="FreePlay Music On Hold Files, a-Law format" >
+		</member>
+		<member name="MOH-FREEPLAY-GSM" displayname="FreePlay Music On Hold Files, GSM format" >
+		</member>
+		<member name="MOH-FREEPLAY-G729" displayname="FreePlay Music On Hold Files, G.729 format" >
+		</member>
 	</category>
 	<category name="MENUSELECT_EXTRA_SOUNDS" displayname="Extras Sound Packages" positive_output="yes">
 		<member name="EXTRA-SOUNDS-EN-WAV" displayname="English, WAV format">



From solid-pbx-svn-admin at lists.berlios.de  Fri Jun 23 21:25:37 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Fri, 23 Jun 2006 21:25:37 +0200
Subject: [solid-pbx-svn] r298 - trunk/sounds
Message-ID: <200606231925.k5NJPbKM011135@sheep.berlios.de>

Author: casper2
Date: 2006-06-23 21:25:27 +0200 (Fri, 23 Jun 2006)
New Revision: 298

Modified:
   trunk/sounds/Makefile
Log:
Update to Asterisk SVN trunk r32943

------------------------------------------------------------------------
r32935 | russell | 2006-06-08 01:09:41 +0200 (Thu, 08 Jun 2006) | 3 lines

move the common wget arguments to a variable and remove --no-verbose so
users will see download progress

------------------------------------------------------------------------


Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-23 18:25:32 UTC (rev 297)
+++ trunk/sounds/Makefile	2006-06-23 19:25:27 UTC (rev 298)
@@ -46,10 +46,11 @@
 MENUSELECT_MOH:=$(subst -G729,-g729,$(MENUSELECT_MOH))
 MOH:=$(MENUSELECT_MOH:MOH-%=asterisk-moh-%.tar.gz)
 MOH_TAGS:=$(MENUSELECT_MOH:MOH-%=$(MOH_DIR)/.asterisk-moh-%)
+WGET_ARGS:=--continue
 
 $(SOUNDS_DIR)/.asterisk-core-sounds-en-%:
 	@PACKAGE=$(subst $(SOUNDS_DIR)/.asterisk,asterisk,$@).tar.gz; \
-	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(SOUNDS_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then wget $(WGET_ARGS) $(SOUNDS_URL)/$${PACKAGE}; fi; \
 	if ! test -f $${PACKAGE}; then exit 1; fi; \
 	rm -f $(subst -$(CORE_SOUNDS_VERSION),,$@)-* && \
 	(cd $(SOUNDS_DIR); tar xzf $(PWD)/$${PACKAGE}) && \
@@ -57,7 +58,7 @@
 
 $(SOUNDS_DIR)/.asterisk-core-sounds-fr-%: $(SOUNDS_DIR)/fr
 	@PACKAGE=$(subst $(SOUNDS_DIR)/.asterisk,asterisk,$@).tar.gz; \
-	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(SOUNDS_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then wget $(WGET_ARGS) $(SOUNDS_URL)/$${PACKAGE}; fi; \
 	if ! test -f $${PACKAGE}; then exit 1; fi; \
 	rm -f $(subst -$(CORE_SOUNDS_VERSION),,$@)-* && \
 	(cd $(SOUNDS_DIR)/fr; tar xzf $(PWD)/$${PACKAGE}) && \
@@ -65,7 +66,7 @@
 
 $(SOUNDS_DIR)/.asterisk-core-sounds-fr-%: $(SOUNDS_DIR)/es
 	@PACKAGE=$(subst $(SOUNDS_DIR)/.asterisk,asterisk,$@).tar.gz; \
-	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(SOUNDS_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then wget $(WGET_ARGS) $(SOUNDS_URL)/$${PACKAGE}; fi; \
 	if ! test -f $${PACKAGE}; then exit 1; fi; \
 	rm -f $(subst -$(CORE_SOUNDS_VERSION),,$@)-* && \
 	(cd $(SOUNDS_DIR)/es; tar xzf $(PWD)/$${PACKAGE}) && \
@@ -73,19 +74,19 @@
 
 $(MOH_DIR)/.asterisk-moh-%:
 	@PACKAGE=$(subst $(MOH_DIR)/.asterisk,asterisk,$@).tar.gz; \
-	if ! test -f $${PACKAGE}; then wget --no-verbose --continue $(MOH_URL)/$${PACKAGE}; fi; \
+	if ! test -f $${PACKAGE}; then wget $(WGET_ARGS) $(MOH_URL)/$${PACKAGE}; fi; \
 	if ! test -f $${PACKAGE}; then exit 1; fi; \
 	(cd $(MOH_DIR); tar xzf $(PWD)/$${PACKAGE}) && \
 	touch $@
 
 asterisk-core-%.tar.gz:
-	@wget --no-verbose --continue $(SOUNDS_URL)/$@
+	@wget $(WGET_ARGS) $(SOUNDS_URL)/$@
 
 asterisk-extra-%.tar.gz:
-	@wget --no-verbose --continue $(MOH_URL)/$@
+	@wget $(WGET_ARGS) $(MOH_URL)/$@
 
 asterisk-moh-%.tar.gz:
-	@wget --no-verbose --continue $(MOH_URL)/$@
+	@wget $(WGET_ARGS) $(MOH_URL)/$@
 
 all:	$(CORE_SOUNDS) $(EXTRA_SOUNDS) $(MOH)
 



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:08:13 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:08:13 +0200
Subject: [solid-pbx-svn] r299 - trunk
Message-ID: <200606240208.k5O28DTM021879@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:08:06 +0200 (Sat, 24 Jun 2006)
New Revision: 299

Modified:
   trunk/pbx.c
Log:
Update to Asterisk SVN trunk r32953

------------------------------------------------------------------------
r32953 | markster | 2006-06-08 07:24:50 +0200 (Thu, 08 Jun 2006) | 2 lines

Cleanup formatting a little...

------------------------------------------------------------------------


Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-23 19:25:27 UTC (rev 298)
+++ trunk/pbx.c	2006-06-24 02:08:06 UTC (rev 299)
@@ -1684,8 +1684,8 @@
 			}
 			if (option_verbose > 2) {
 				char tmp[80], tmp2[80], tmp3[EXT_DATA_SIZE];
-				ast_verbose( VERBOSE_PREFIX_3 "Executing [%s:%d] %s(\"%s\", \"%s\") %s\n",
-					context, priority,
+				ast_verbose( VERBOSE_PREFIX_3 "Executing [%s@%s:%d] %s(\"%s\", \"%s\") %s\n",
+					exten, context, priority,
 					term_color(tmp, app->name, COLOR_BRCYAN, 0, sizeof(tmp)),
 					term_color(tmp2, c->name, COLOR_BRMAGENTA, 0, sizeof(tmp2)),
 					term_color(tmp3, passdata, COLOR_BRMAGENTA, 0, sizeof(tmp3)),



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:11:15 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:11:15 +0200
Subject: [solid-pbx-svn] r300 - in trunk: build_tools include
Message-ID: <200606240211.k5O2BFLd022927@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:11:07 +0200 (Sat, 24 Jun 2006)
New Revision: 300

Modified:
   trunk/build_tools/menuselect.c
   trunk/include/asterisk.h
Log:
Update to Asterisk SVN trunk r32973

------------------------------------------------------------------------
r32970 | oej | 2006-06-08 09:26:05 +0200 (Thu, 08 Jun 2006) | 2 lines

Enable doxygen

------------------------------------------------------------------------
r32971 | oej | 2006-06-08 09:29:46 +0200 (Thu, 08 Jun 2006) | 2 lines

Doxygen formatting

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-24 02:08:06 UTC (rev 299)
+++ trunk/build_tools/menuselect.c	2006-06-24 02:11:07 UTC (rev 300)
@@ -16,7 +16,7 @@
  * at the top of the source tree.
  */
 
-/*
+/*!
  * \file
  *
  * \author Russell Bryant <russell at digium.com>

Modified: trunk/include/asterisk.h
===================================================================
--- trunk/include/asterisk.h	2006-06-24 02:08:06 UTC (rev 299)
+++ trunk/include/asterisk.h	2006-06-24 02:11:07 UTC (rev 300)
@@ -50,31 +50,20 @@
 extern char ast_config_AST_CTL[AST_CONFIG_MAX_PATH];
 extern char ast_config_AST_SYSTEM_NAME[20];
 
-/* Provided by asterisk.c */
-int ast_set_priority(int);
-/* Provided by module.c */
-int load_modules(const int preload_only);
-/* Provided by pbx.c */
-int load_pbx(void);
-/* Provided by logger.c */
-int init_logger(void);
-void close_logger(void);
-/* Provided by frame.c */
-int init_framer(void);
-/* Provided by logger.c */
-int reload_logger(int);
-/* Provided by term.c */
-int term_init(void);
-/* Provided by db.c */
-int astdb_init(void);
-/* Provided by channel.c */
-void ast_channels_init(void);
-/* Provided by cli.c */
-void ast_builtins_init(void);
-/* Provided by dnsmgr.c */
-int dnsmgr_init(void);
-void dnsmgr_start_refresh(void);
-int dnsmgr_reload(void);
+int ast_set_priority(int);			/*!< Provided by asterisk.c */
+int load_modules(const int preload_only);	/*!< Provided by module.c */
+int load_pbx(void);				/*!< Provided by pbx.c */
+int init_logger(void)				/*!< Provided by logger.c */;
+void close_logger(void)				/*!< Provided by logger.c */;
+int reload_logger(int);				/*!< Provided by logger.c */
+int init_framer(void);				/*!< Provided by frame.c */
+int term_init(void);				/*!< Provided by term.c */
+int astdb_init(void);				/*!< Provided by db.c */
+void ast_channels_init(void);			/*!< Provided by channel.c */
+void ast_builtins_init(void);			/*!< Provided by cli.c */
+int dnsmgr_init(void);				/*!< Provided by dnsmgr.c */ 
+void dnsmgr_start_refresh(void);		/*!< Provided by dnsmgr.c */
+int dnsmgr_reload(void);			/*!< Provided by dnsmgr.c */
 
 /*!
  * \brief Reload asterisk modules.
@@ -130,6 +119,7 @@
 
 /*!
  * \brief support for event profiling
+ *
  * (note, this must be documented a lot more)
  * ast_add_profile allocates a generic 'counter' with a given name,
  * which can be shown with the command 'show profile <name>'



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:12:30 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:12:30 +0200
Subject: [solid-pbx-svn] r301 - in trunk: apps formats include/asterisk
Message-ID: <200606240212.k5O2CUaE023007@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:12:10 +0200 (Sat, 24 Jun 2006)
New Revision: 301

Modified:
   trunk/apps/app_followme.c
   trunk/formats/format_h263.c
   trunk/formats/format_h264.c
   trunk/include/asterisk/doxyref.h
Log:
Update to Asterisk SVN trunk r32993

------------------------------------------------------------------------
r32990 | oej | 2006-06-08 10:10:58 +0200 (Thu, 08 Jun 2006) | 2 lines

Doxygen update

------------------------------------------------------------------------
r32991 | oej | 2006-06-08 10:13:32 +0200 (Thu, 08 Jun 2006) | 2 lines

Add video.txt to doxygen

------------------------------------------------------------------------
r32992 | oej | 2006-06-08 10:15:43 +0200 (Thu, 08 Jun 2006) | 2 lines

Update doxygen for video formats

------------------------------------------------------------------------


Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-24 02:11:07 UTC (rev 300)
+++ trunk/apps/app_followme.c	2006-06-24 02:12:10 UTC (rev 301)
@@ -23,6 +23,8 @@
  *
  * \author BJ Weschke <bweschke at btwtech.com>
  *
+ * \arg See \ref Config_followme
+ *
  * \ingroup applications
  */
 

Modified: trunk/formats/format_h263.c
===================================================================
--- trunk/formats/format_h263.c	2006-06-24 02:11:07 UTC (rev 300)
+++ trunk/formats/format_h263.c	2006-06-24 02:12:10 UTC (rev 301)
@@ -21,6 +21,7 @@
  * \brief Save to raw, headerless h263 data.
  * \arg File name extension: h263
  * \ingroup formats
+ * \arg See \ref AstVideo
  */
  
 #include <unistd.h>

Modified: trunk/formats/format_h264.c
===================================================================
--- trunk/formats/format_h264.c	2006-06-24 02:11:07 UTC (rev 300)
+++ trunk/formats/format_h264.c	2006-06-24 02:12:10 UTC (rev 301)
@@ -21,6 +21,7 @@
  * \brief Save to raw, headerless h264 data.
  * \arg File name extension: h264
  * \ingroup formats
+ * \arg See \ref AstVideo
  */
  
 #include <unistd.h>
@@ -47,6 +48,8 @@
 /* Some Ideas for this code came from makeh264e.c by Jeffrey Chilton */
 
 /* Portions of the conversion code are by guido at sienanet.it */
+/*! \todo Check this buf size estimate, it may be totally wrong for large frame video */
+
 #define BUF_SIZE	4096	/* Two Real h264 Frames */
 struct h264_desc {
 	unsigned int lastts;

Modified: trunk/include/asterisk/doxyref.h
===================================================================
--- trunk/include/asterisk/doxyref.h	2006-06-24 02:11:07 UTC (rev 300)
+++ trunk/include/asterisk/doxyref.h	2006-06-24 02:12:10 UTC (rev 301)
@@ -36,6 +36,7 @@
  *  \arg \ref AstCDR
  *  \arg \ref AstREADME
  *  \arg \ref AstVar
+ *  \arg \ref AstVideo
  *  \arg \ref AstENUM : The IETF way to redirect from phone numbers to VoIP calls
  *  \arg \ref AstHTTP
  *  \arg \ref AstSpeech
@@ -129,9 +130,14 @@
  *  \verbinclude CREDITS
  */
 
+/*! \page AstVideo Video support in Asterisk
+ * \section sectAstVideo Video support in Asterisk
+ *  \verbinclude video.txt
+ */
+
 /*! \page AstVar Global channel variables
  * \section globchan Global Channel Variables
- *  \verbinclude variables.txt
+ *  \verbinclude channelvariables.txt
  */
 
 /*! \page AstENUM ENUM
@@ -164,6 +170,7 @@
  * \arg \link Config_mm Meetme (conference bridge) configuration  \endlink
  * \arg \link Config_qu Queue system configuration  \endlink
  * \arg \link Config_vm Voicemail configuration  \endlink
+ * \arg \link Config_followme Followme configuration  \endlink
  * \section cdrconf CDR configuration files
  * \arg \link Config_cdr CDR configuration  \endlink
  * \arg \link cdr_custom Custom CDR driver configuration \endlink
@@ -202,6 +209,12 @@
  * \verbinclude features.conf.sample
  */
 
+/*! \page Config_followme followme.conf 
+ * \section followmeconf Followme.conf
+ * - See app_followme.c
+ * \verbinclude followme.conf.sample
+ */
+
 /*! \page Config_ext Extensions.conf - the Dial Plan
  * \section dialplan Extensions.conf 
  * \verbinclude extensions.conf.sample



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:13:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:13:41 +0200
Subject: [solid-pbx-svn] r302 - trunk/channels
Message-ID: <200606240213.k5O2Dftx023228@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:13:37 +0200 (Sat, 24 Jun 2006)
New Revision: 302

Modified:
   trunk/channels/chan_misdn.c
Log:
Update to Asterisk SVN trunk r33013

------------------------------------------------------------------------
r33011 | crichter | 2006-06-08 11:51:13 +0200 (Thu, 08 Jun 2006) | 1 line

Fixed detection of dtmfs with bridged channels.
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-24 02:12:10 UTC (rev 301)
+++ trunk/channels/chan_misdn.c	2006-06-24 02:13:37 UTC (rev 302)
@@ -163,9 +163,11 @@
 
 	int norxtone;
 	int notxtone; 
-
+	
 	int incoming_early_audio;
 
+	int ignore_dtmf;
+
 	int pipe[2];
 	char ast_rd_buf[4096];
 	struct ast_frame frame;
@@ -2286,7 +2288,13 @@
 		ast_verbose(VERBOSE_PREFIX_3 "Native bridging %s and %s\n", c0->name, c1->name);
 
 	chan_misdn_log(1, ch1->bc->port, "* Making Native Bridge between %s and %s\n", ch1->bc->oad, ch2->bc->oad);
-  
+ 
+	if (! (flags&AST_BRIDGE_DTMF_CHANNEL_0) )
+		ch1->ignore_dtmf=1;
+
+	if (! (flags&AST_BRIDGE_DTMF_CHANNEL_1) )
+		ch2->ignore_dtmf=1;
+
 	while(1) {
 		to=-1;
 		who = ast_waitfor_n(carr, 2, &to);
@@ -2304,8 +2312,16 @@
       
 			break;
 		}
-    
-    
+		
+		if ( f->frametype == AST_FRAME_DTMF ) {
+			chan_misdn_log(1,0,"Read DTMF %d from %s\n",f->subclass, who->exten);
+
+			*fo=f;
+			*rc=who;
+			break;
+		}
+		
+		
 		if (who == c0) {
 			ast_write(c1,f);
 		}
@@ -2314,8 +2330,13 @@
 		}
     
 	}
-  
-	return 0;
+	
+	chan_misdn_log(1, ch1->bc->port, "I SEND: Splitting conference with Number:%d\n", ch1->bc->pid +1);
+	
+	misdn_lib_split_bridge(ch1->bc,ch2->bc);
+	
+	
+	return AST_BRIDGE_COMPLETE;
 }
 
 /** AST INDICATIONS END **/
@@ -3181,9 +3202,12 @@
 		fr.mallocd =0 ;
 		fr.offset= 0 ;
 		
-		chan_misdn_log(2, bc->port, " --> DTMF:%c\n", bc->dtmf);
-		
-		ast_queue_frame(ch->ast, &fr);
+		if (!ch->ignore_dtmf) {
+			chan_misdn_log(2, bc->port, " --> DTMF:%c\n", bc->dtmf);
+			ast_queue_frame(ch->ast, &fr);
+		} else {
+			chan_misdn_log(2, bc->port, " --> Ingoring DTMF:%c due to bridge flags\n", bc->dtmf);
+		}
 	}
 	break;
 	case EVENT_STATUS:



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:15:51 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:15:51 +0200
Subject: [solid-pbx-svn] r303 - trunk
Message-ID: <200606240215.k5O2FpqQ024076@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:15:37 +0200 (Sat, 24 Jun 2006)
New Revision: 303

Modified:
   trunk/fixedjitterbuf.c
   trunk/frame.c
Log:
Update to Asterisk SVN trunk r33043

------------------------------------------------------------------------
r33035 | kpfleming | 2006-06-08 18:36:34 +0200 (Thu, 08 Jun 2006) | 2 lines

try to get keyword substitution working for this file

------------------------------------------------------------------------
r33037 | kpfleming | 2006-06-08 18:59:44 +0200 (Thu, 08 Jun 2006) | 2 lines

handle out-of-memory conditions in ast_frisolate() properly (reported by Slav Kenov on asterisk-dev)

------------------------------------------------------------------------


Modified: trunk/fixedjitterbuf.c
===================================================================
--- trunk/fixedjitterbuf.c	2006-06-24 02:13:37 UTC (rev 302)
+++ trunk/fixedjitterbuf.c	2006-06-24 02:15:37 UTC (rev 303)
@@ -26,7 +26,7 @@
 
 #include "asterisk.h"
 
-ASTERISK_FILE_VERSION(__FILE__, "$Revision $")
+ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
 #include <stdio.h>
 #include <stdlib.h>

Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-24 02:13:37 UTC (rev 302)
+++ trunk/frame.c	2006-06-24 02:15:37 UTC (rev 303)
@@ -328,14 +328,22 @@
 		out = fr;
 	
 	if (!(fr->mallocd & AST_MALLOCD_SRC)) {
-		if (fr->src)
-			out->src = strdup(fr->src);
+		if (fr->src) {
+			if (!(out->src = ast_strdup(fr->src))) {
+				if (out != fr)
+					free(out);
+				return NULL;
+			}
+		}
 	} else
 		out->src = fr->src;
 	
 	if (!(fr->mallocd & AST_MALLOCD_DATA))  {
 		if (!(newdata = ast_malloc(fr->datalen + AST_FRIENDLY_OFFSET))) {
-			free(out);
+			if (out->src != fr->src)
+				free((void *) out->src);
+			if (out != fr)
+				free(out);
 			return NULL;
 		}
 		newdata += AST_FRIENDLY_OFFSET;



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:16:59 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:16:59 +0200
Subject: [solid-pbx-svn] r304 - in trunk: . channels include/asterisk
Message-ID: <200606240216.k5O2GxpL024284@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:16:55 +0200 (Sat, 24 Jun 2006)
New Revision: 304

Modified:
   trunk/asterisk.c
   trunk/channels/chan_sip.c
   trunk/include/asterisk/doxyref.h
Log:
Update to Asterisk SVN trunk r33073

------------------------------------------------------------------------
r33066 | oej | 2006-06-08 20:03:08 +0200 (Thu, 08 Jun 2006) | 2 lines

Doxygen updates

------------------------------------------------------------------------
r33069 | oej | 2006-06-08 20:13:06 +0200 (Thu, 08 Jun 2006) | 2 lines

Issue #7294 - Asterisk sends INVITE instead of BYE. Fix by Philippe Sultan. Thanks!

------------------------------------------------------------------------


Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-24 02:15:37 UTC (rev 303)
+++ trunk/asterisk.c	2006-06-24 02:16:55 UTC (rev 304)
@@ -361,9 +361,8 @@
 
 static struct profile_data *prof_data;
 
-/*
- * allocates a counter with a given name and scale.
- * Returns the identifier of the counter.
+/*! \brief allocates a counter with a given name and scale.
+ * \return Returns the identifier of the counter.
  */
 int ast_add_profile(const char *name, uint64_t scale)
 {
@@ -492,7 +491,7 @@
 "       Shows the revision numbers of the files used to build this copy of Asterisk.\n"
 "       Optional regular expression pattern is used to filter the file list.\n";
 
-/*! CLI command to list module versions */
+/*! \brief CLI command to list module versions */
 static int handle_show_version_files(int fd, int argc, char *argv[])
 {
 #define FORMAT "%-25.25s %-40.40s\n"
@@ -604,14 +603,14 @@
 	return write(fd, s, strlen(s) + 1);
 }
 
-/*! NULL handler so we can collect the child exit status */
+/*! \brief NULL handler so we can collect the child exit status */
 static void null_sig_handler(int signal)
 {
 
 }
 
 AST_MUTEX_DEFINE_STATIC(safe_system_lock);
-/*! Keep track of how many threads are currently trying to wait*() on
+/*! \brief Keep track of how many threads are currently trying to wait*() on
  *  a child process */
 static unsigned int safe_system_level = 0;
 static void *safe_system_prev_handler;
@@ -684,7 +683,7 @@
 }
 
 /*!
- * mute or unmute a console from logging
+ * \brief mute or unmute a console from logging
  */
 void ast_console_toggle_mute(int fd) {
 	int x;
@@ -704,7 +703,7 @@
 }
 
 /*!
- * log the string to all attached console clients
+ * \brief log the string to all attached console clients
  */
 static void ast_network_puts_mutable(const char *string)
 {
@@ -718,7 +717,7 @@
 }
 
 /*!
- * log the string to the console, and all attached
+ * \brief log the string to the console, and all attached
  * console clients
  */
 void ast_console_puts_mutable(const char *string)
@@ -729,7 +728,7 @@
 }
 
 /*!
- * write the string to all attached console clients
+ * \brief write the string to all attached console clients
  */
 static void ast_network_puts(const char *string)
 {
@@ -982,7 +981,8 @@
 		return 1;
 }
 
-/*! Urgent handler
+/*! \brief Urgent handler
+
  Called by soft_hangup to interrupt the poll, read, or other
  system call.  We don't actually need to do anything though.  
  Remember: Cannot EVER ast_log from within a signal handler 
@@ -1025,7 +1025,7 @@
 	signal(sig, child_handler);
 }
 
-/*! Set an X-term or screen title */
+/*! \brief Set an X-term or screen title */
 static void set_title(char *text)
 {
 	if (getenv("TERM") && strstr(getenv("TERM"), "xterm"))
@@ -1038,7 +1038,7 @@
 		fprintf(stdout, "\033]1;%s\007", text);
 }
 
-/*! We set ourselves to a high priority, that we might pre-empt everything
+/*! \brief We set ourselves to a high priority, that we might pre-empt everything
    else.  If your PBX has heavy activity on it, this is a good thing.  */
 int ast_set_priority(int pri)
 {

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-24 02:15:37 UTC (rev 303)
+++ trunk/channels/chan_sip.c	2006-06-24 02:16:55 UTC (rev 304)
@@ -14950,7 +14950,7 @@
 		changed |= ast_rtp_get_peer(vrtp, &p->vredirip);
 	else
 		memset(&p->vredirip, 0, sizeof(p->vredirip));
-	if (p->redircodecs != codecs) {
+	if (codecs && (p->redircodecs != codecs)) {
 		p->redircodecs = codecs;
 		changed = 1;
 	}

Modified: trunk/include/asterisk/doxyref.h
===================================================================
--- trunk/include/asterisk/doxyref.h	2006-06-24 02:15:37 UTC (rev 303)
+++ trunk/include/asterisk/doxyref.h	2006-06-24 02:16:55 UTC (rev 304)
@@ -486,6 +486,6 @@
  * http.
  *  \section ami AMI - The manager Interface
  *  \arg \link Config_ami Configuration file \endlink
- *  \verbinclude http.txt
+ *  \verbinclude ajam.txt
  */
 



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:18:16 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:18:16 +0200
Subject: [solid-pbx-svn] r305 - trunk
Message-ID: <200606240218.k5O2IGPu024887@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:18:12 +0200 (Sat, 24 Jun 2006)
New Revision: 305

Modified:
   trunk/UPGRADE.txt
Log:
Update to Asterisk SVN trunk r33093

------------------------------------------------------------------------
r33089 | kpfleming | 2006-06-08 21:48:36 +0200 (Thu, 08 Jun 2006) | 2 lines

document the new sound/moh file installation process

------------------------------------------------------------------------


Modified: trunk/UPGRADE.txt
===================================================================
--- trunk/UPGRADE.txt	2006-06-24 02:16:55 UTC (rev 304)
+++ trunk/UPGRADE.txt	2006-06-24 02:18:12 UTC (rev 305)
@@ -43,6 +43,39 @@
 builds, the file can be copied to '~/.asterisk.makeopts' or 
 '/etc/asterisk.makeopts'.
 
+Sound (prompt) and Music On Hold files:
+
+Beginning with Asterisk 1.4, the sound files and music on hold files supplied for
+use with Asterisk have been replaced with new versions produced from high quality
+master recordings, and are available in three languages (English, French and
+Spanish) and in five formats (WAV (uncompressed), mu-Law, a-Law, GSM and G.729).
+In addition, the music on hold files provided by FreePlay Music are now available
+in the same five formats, but no longer available in MP3 format.
+
+The Asterisk 1.4 tarball packages will only include English prompts in GSM format,
+(as were supplied with previous releases) and the FreePlay MOH files in WAV format.
+All of the other variations can be installed by running 'make menuselect' and
+selecting the packages you wish to install; when you run 'make install', those
+packages will be downloaded and installed along with the standard files included
+in the tarball.
+
+If for some reason you expect to not have Internet access at the time you will be
+running 'make install', you can make your package selections using menuselect and
+then run 'make sounds' to download (only) the sound packages; this will leave the
+sound packages in the 'sounds' subdirectory to be used later during installation.
+
+WARNING: Asterisk 1.4 supports a new layout for sound files in multiple languages;
+instead of the alternate-language files being stored in subdirectories underneath
+the existing files (for French, that would be digits/fr, letters/fr, phonetic/fr,
+etc.) the new layout creates one directory under /var/lib/asterisk/sounds for the
+language itself, then places all the sound files for that language under that
+directory and its subdirectories. This is the layout that will be created if you
+select non-English languages to be installed via menuselect, HOWEVER Asterisk does
+not default to this layout and will not find the files in the places it expects them
+to be. If you wish to use this layout, make sure you put 'languageprefix=yes' in your
+/etc/asterisk/asterisk.conf file, so that Asterisk will know how the files were
+installed.
+
 PBX Core:
 
 * The (very old and undocumented) ability to use BYEXTENSION for dialing
@@ -265,11 +298,3 @@
 	ASTETCDIR	/usr/local/etc/asterisk
 	ASTBINDIR	/usr/local/bin/asterisk
 	ASTSBINDIR	/usr/local/sbin/asterisk
-
-Sounds:
-
-* The phonetic sounds directory has been removed from the asterisk-sounds
-  package because they are now included directly in Asterisk.  However, it is
-  important to note that the phonetic sounds that existed in asterisk-sounds 
-  used a different naming convention than the sounds in Asterisk.  For example,
-  instead of alpha.gsm and bravo.gsm, Asterisk has a_p.gsm and b_p.gsm.



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:20:20 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:20:20 +0200
Subject: [solid-pbx-svn] r306 - in trunk: . build_tools channels
Message-ID: <200606240220.k5O2KK5Y026216@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:20:03 +0200 (Sat, 24 Jun 2006)
New Revision: 306

Modified:
   trunk/build_tools/menuselect.c
   trunk/channels/chan_sip.c
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r33113

------------------------------------------------------------------------
r33108 | oej | 2006-06-08 22:05:36 +0200 (Thu, 08 Jun 2006) | 2 lines

Avoid using the name "early media" for media that is not early

------------------------------------------------------------------------
r33109 | oej | 2006-06-08 22:06:04 +0200 (Thu, 08 Jun 2006) | 2 lines

Improve SIP history

------------------------------------------------------------------------
r33110 | oej | 2006-06-08 22:07:05 +0200 (Thu, 08 Jun 2006) | 2 lines

Don't crash if chan2 does not exist (one-legged call situations, like echo)

------------------------------------------------------------------------
r33111 | oej | 2006-06-08 22:14:54 +0200 (Thu, 08 Jun 2006) | 2 lines

At least reply if we get a fatal error in handling a packet.

------------------------------------------------------------------------
r33112 | oej | 2006-06-08 22:16:19 +0200 (Thu, 08 Jun 2006) | 2 lines

Make menuselect compile on os/x...

------------------------------------------------------------------------
r33113 | oej | 2006-06-08 22:30:20 +0200 (Thu, 08 Jun 2006) | 2 lines

Debug logging fixes

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-24 02:18:12 UTC (rev 305)
+++ trunk/build_tools/menuselect.c	2006-06-24 02:20:03 UTC (rev 306)
@@ -24,13 +24,13 @@
  * \brief A menu-driven system for Asterisk module selection
  */
 
-#include "asterisk.h"
-
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 
+#include "asterisk.h"
+
 #include "mxml/mxml.h"
 #include "menuselect.h"
 

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-24 02:18:12 UTC (rev 305)
+++ trunk/channels/chan_sip.c	2006-06-24 02:20:03 UTC (rev 306)
@@ -1112,7 +1112,6 @@
 static int update_call_counter(struct sip_pvt *fup, int event);
 static int hangup_sip2cause(int cause);
 static const char *hangup_cause2sip(int cause);
-static int sip_fixup(struct ast_channel *oldchan, struct ast_channel *newchan);
 static struct sip_pvt *find_call(struct sip_request *req, struct sockaddr_in *sin, const int intended_method);
 int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno);
 
@@ -1701,7 +1700,7 @@
 
 	if (option_debug)
 		ast_log(LOG_DEBUG, "Auto destroying call '%s'\n", p->callid);
-	append_history(p, "AutoDestroy", "");
+	append_history(p, "AutoDestroy", "%s", p->callid);
 	if (p->owner) {
 		ast_log(LOG_WARNING, "Autodestruct on dialog '%s' with owner in place (Method: %s)\n", p->callid, sip_methods[p->method].text);
 		ast_queue_hangup(p->owner);
@@ -2880,8 +2879,6 @@
 		ast_log(LOG_DEBUG, "Asked to hangup channel that was not connected\n");
 		return 0;
 	}
-	if (option_debug && sipdebug)
-		ast_log(LOG_DEBUG, "Hangup call %s, SIP callid %s)\n", ast->name, p->callid);
 
 	if (ast_test_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER)) {
 		if (option_debug >3)
@@ -3089,8 +3086,16 @@
 	int ret = -1;
 	struct sip_pvt *p;
 
+	if (newchan && ast_test_flag(newchan, AST_FLAG_ZOMBIE))
+		ast_log(LOG_DEBUG, "New channel is zombie\n");
+	if (oldchan && ast_test_flag(oldchan, AST_FLAG_ZOMBIE))
+		ast_log(LOG_DEBUG, "Old channel is zombie\n");
+
 	if (!newchan || !newchan->tech_pvt) {
-		ast_log(LOG_WARNING, "No SIP tech_pvt! Fixup of %s failed.\n", oldchan->name);
+		if (!newchan)
+			ast_log(LOG_WARNING, "No new channel! Fixup of %s failed.\n", oldchan->name);
+		else
+			ast_log(LOG_WARNING, "No SIP tech_pvt! Fixup of %s failed.\n", oldchan->name);
 		return -1;
 	}
 	p = newchan->tech_pvt;
@@ -11893,6 +11898,7 @@
 			copy_request(&p->initreq, req);
 			if (debug)
 				ast_verbose("Using INVITE request as basis request - %s\n", p->callid);
+			append_history(p, "Invite", "New call: %s", p->callid);
 			parse_ok_contact(p, req);
 		} else {	/* Re-invite on existing call */
 			/* Handle SDP here if we already have an owner */
@@ -12442,7 +12448,7 @@
 		return -1;
 	}
 
-	if (sipdebug && option_debug > 3)
+	if (current.chan2 && sipdebug && option_debug > 3)
 		ast_log(LOG_DEBUG, "Got SIP transfer, applying to bridged peer '%s'\n", current.chan2->name);
 
 	/* Stop music on hold on this channel */
@@ -13237,7 +13243,7 @@
 		/* becaues this is deadlock-prone, we need to try and unlock if failed */
 		if (p->owner && ast_channel_trylock(p->owner)) {
 			if (option_debug)
-				ast_log(LOG_DEBUG, "Failed to grab lock, trying again...\n");
+				ast_log(LOG_DEBUG, "Failed to grab owner channel lock, trying again. (SIP call %s)\n", p->callid);
 			ast_mutex_unlock(&p->lock);
 			ast_mutex_unlock(&netlock);
 			/* Sleep for a very short amount of time */
@@ -13245,15 +13251,19 @@
 			if (--lockretry)
 				goto retrylock;
 		}
+		p->recv = sin;
+
+		if (recordhistory) /* This is a request or response, note what it was for */
+			append_history(p, "Rx", "%s / %s / %s", req.data, get_header(&req, "CSeq"), req.rlPart2);
+
 		if (!lockretry) {
-			ast_log(LOG_ERROR, "We could NOT get the channel lock for %s! \n", p->owner->name);
-			ast_log(LOG_ERROR, "SIP MESSAGE JUST IGNORED: %s \n", req.data);
-			ast_log(LOG_ERROR, "BAD! BAD! BAD!\n");
+			ast_log(LOG_ERROR, "We could NOT get the channel lock for %s! \n", p->owner->name ? p->owner->name : "- no channel name ??? - ");
+			ast_log(LOG_ERROR, "SIP transaction failed: %s \n", p->callid);
+			transmit_response(p, "503 Server error", &req);	/* We must respond according to RFC 3261 sec 12.2 */
+					/* XXX We could add retry-after to make sure they come back */
+			append_history(p, "LockFail", "Owner lock failed, transaction failed.");
 			return 1;
 		}
-		p->recv = sin;
-		if (recordhistory) /* This is a request or response, note what it was for */
-			append_history(p, "Rx", "%s / %s / %s", req.data, get_header(&req, "CSeq"), req.rlPart2);
 		nounlock = 0;
 		if (handle_request(p, &req, &sin, &recount, &nounlock) == -1) {
 			/* Request failed */

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-24 02:18:12 UTC (rev 305)
+++ trunk/rtp.c	2006-06-24 02:20:03 UTC (rev 306)
@@ -1225,6 +1225,7 @@
 	struct ast_rtp *vdestp, *vsrcp=NULL;		/* Video RTP channels */
 	struct ast_rtp_protocol *destpr, *srcpr=NULL;
 	int srccodec;
+
 	/* Lock channels */
 	ast_channel_lock(dest);
 	if (src) {
@@ -1279,14 +1280,14 @@
 	/* Consider empty media as non-existant */
 	if (srcp && !srcp->them.sin_addr.s_addr)
 		srcp = NULL;
-	/* Bridge early media */
+	/* Bridge media early */
 	if (destpr->set_rtp_peer(dest, srcp, vsrcp, srccodec, srcp ? ast_test_flag(srcp, FLAG_NAT_ACTIVE) : 0))
-		ast_log(LOG_WARNING, "Channel '%s' failed to send early media to '%s'\n", dest->name, src ? src->name : "<unspecified>");
+		ast_log(LOG_WARNING, "Channel '%s' failed to setup early bridge to '%s'\n", dest->name, src ? src->name : "<unspecified>");
 	ast_channel_unlock(dest);
 	if (src)
 		ast_channel_unlock(src);
 	if (option_debug)
-		ast_log(LOG_DEBUG, "Setting early  media SDP of '%s' with that of '%s'\n", dest->name, src ? src->name : "<unspecified>");
+		ast_log(LOG_DEBUG, "Setting early bridge SDP of '%s' with that of '%s'\n", dest->name, src ? src->name : "<unspecified>");
 	return 1;
 }
 
@@ -1343,9 +1344,9 @@
 	else
 		srccodec = 0;
 	if (media) {
-		/* Bridge early media */
+		/* Bridge early */
 		if (destpr->set_rtp_peer(dest, srcp, vsrcp, srccodec, ast_test_flag(srcp, FLAG_NAT_ACTIVE)))
-			ast_log(LOG_WARNING, "Channel '%s' failed to send early media to '%s'\n", dest->name, src->name);
+			ast_log(LOG_WARNING, "Channel '%s' failed to setup early bridge to '%s'\n", dest->name, src->name);
 	}
 	ast_channel_unlock(dest);
 	ast_channel_unlock(src);



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:21:35 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:21:35 +0200
Subject: [solid-pbx-svn] r307 - in trunk: build_tools include/asterisk
Message-ID: <200606240221.k5O2LZCJ027017@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:21:24 +0200 (Sat, 24 Jun 2006)
New Revision: 307

Modified:
   trunk/build_tools/menuselect.c
   trunk/include/asterisk/compat.h
Log:
Update to Asterisk SVN trunk r33123

------------------------------------------------------------------------
r33114 | russell | 2006-06-08 22:49:59 +0200 (Thu, 08 Jun 2006) | 3 lines

always include inttypes.h and sys/types.h in asterisk/compat.h to fix a build
problem on mac and place asterisk.h back at the top of menuselect.c

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-24 02:20:03 UTC (rev 306)
+++ trunk/build_tools/menuselect.c	2006-06-24 02:21:24 UTC (rev 307)
@@ -24,13 +24,13 @@
  * \brief A menu-driven system for Asterisk module selection
  */
 
+#include "asterisk.h"
+
 #include <stdlib.h>
 #include <stdio.h>
 #include <string.h>
 #include <unistd.h>
 
-#include "asterisk.h"
-
 #include "mxml/mxml.h"
 #include "menuselect.h"
 

Modified: trunk/include/asterisk/compat.h
===================================================================
--- trunk/include/asterisk/compat.h	2006-06-24 02:20:03 UTC (rev 306)
+++ trunk/include/asterisk/compat.h	2006-06-24 02:21:24 UTC (rev 307)
@@ -16,6 +16,9 @@
 #ifndef _COMPAT_H
 #define _COMPAT_H
 
+#include <inttypes.h>
+#include <sys/types.h>
+
 #ifndef HAVE_STRSEP
 char* strsep(char** str, const char* delims);
 #endif
@@ -81,18 +84,6 @@
 #endif
 #endif /* __CYGWIN__ */
 
-#ifdef __linux__
-#include <inttypes.h>
-#endif
-
-#ifdef __Darwin__
-#include <inttypes.h>
-#endif
-
-#ifdef __FreeBSD__
-#include <sys/types.h>
-#endif
-
 #ifdef __CYGWIN__
 typedef unsigned long long uint64_t;
 #endif



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:22:21 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:22:21 +0200
Subject: [solid-pbx-svn] r308 - in trunk: . channels include/asterisk
Message-ID: <200606240222.k5O2MLr3027548@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:22:09 +0200 (Sat, 24 Jun 2006)
New Revision: 308

Modified:
   trunk/channels/chan_sip.c
   trunk/include/asterisk/rtp.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r33133

------------------------------------------------------------------------
r33133 | kpfleming | 2006-06-09 01:10:45 +0200 (Fri, 09 Jun 2006) | 2 lines

move 'struct ast_rtp' back to rtp.c where it belongs

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-24 02:21:24 UTC (rev 307)
+++ trunk/channels/chan_sip.c	2006-06-24 02:22:09 UTC (rev 308)
@@ -4116,7 +4116,7 @@
 	int sendonly = 0;
 	int numberofports;
 	struct ast_channel *bridgepeer = NULL;
-	struct ast_rtp newaudiortp, newvideortp;	/* Buffers for codec handling */
+	struct ast_rtp *newaudiortp, *newvideortp;	/* Buffers for codec handling */
 	int newjointcapability;				/* Negotiated capability */
 	int newpeercapability;
 	int newnoncodeccapability;
@@ -4129,11 +4129,14 @@
 	}
 
 	/* Initialize the temporary RTP structures we use to evaluate the offer from the peer */
-	memset(&newaudiortp, 0, sizeof(newaudiortp));
-	memset(&newvideortp, 0, sizeof(newvideortp));
-	ast_rtp_pt_default(&newaudiortp);
-	ast_rtp_pt_default(&newvideortp);
+	newaudiortp = alloca(ast_rtp_alloc_size());
+	memset(newaudiortp, 0, ast_rtp_alloc_size());
+	ast_rtp_pt_default(newaudiortp);
 
+	newvideortp = alloca(ast_rtp_alloc_size());
+	memset(newvideortp, 0, ast_rtp_alloc_size());
+	ast_rtp_pt_default(newvideortp);
+
 	/* Update our last rtprx when we receive an SDP, too */
 	p->lastrtprx = p->lastrtptx = time(NULL); /* XXX why both ? */
 
@@ -4172,7 +4175,7 @@
 		numberofmediastreams++;
 
 		if (p->vrtp)
-			ast_rtp_pt_clear(&newvideortp);  /* Must be cleared in case no m=video line exists */
+			ast_rtp_pt_clear(newvideortp);  /* Must be cleared in case no m=video line exists */
 		numberofports = 1;
 		if ((sscanf(m, "audio %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
 		    (sscanf(m, "audio %d RTP/AVP %n", &x, &len) == 1)) {
@@ -4180,7 +4183,7 @@
 			/* Found audio stream in this media definition */
 			portno = x;
 			/* Scan through the RTP payload types specified in a "m=" line: */
-			ast_rtp_pt_clear(&newaudiortp);
+			ast_rtp_pt_clear(newaudiortp);
 			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
 				if (sscanf(codecs, "%d%n", &codec, &len) != 1) {
 					ast_log(LOG_WARNING, "Error in codec string '%s'\n", codecs);
@@ -4188,7 +4191,7 @@
 				}
 				if (debug)
 					ast_verbose("Found RTP audio format %d\n", codec);
-				ast_rtp_set_m_type(&newaudiortp, codec);
+				ast_rtp_set_m_type(newaudiortp, codec);
 			}
 		} else if ((sscanf(m, "video %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
 		    (sscanf(m, "video %d RTP/AVP %n", &x, &len) == 1)) {
@@ -4203,7 +4206,7 @@
 				}
 				if (debug)
 					ast_verbose("Found RTP video format %d\n", codec);
-				ast_rtp_set_m_type(&newvideortp, codec);
+				ast_rtp_set_m_type(newvideortp, codec);
 			}
 		} else 
 			ast_log(LOG_WARNING, "Unsupported SDP media type in offer: %s\n", m);
@@ -4309,14 +4312,14 @@
 			ast_verbose("Found description format %s for ID %d\n", mimeSubtype, codec);
 
 		/* Note: should really look at the 'freq' and '#chans' params too */
-		ast_rtp_set_rtpmap_type(&newaudiortp, codec, "audio", mimeSubtype);
+		ast_rtp_set_rtpmap_type(newaudiortp, codec, "audio", mimeSubtype);
 		if (p->vrtp)
-			ast_rtp_set_rtpmap_type(&newvideortp, codec, "video", mimeSubtype);
+			ast_rtp_set_rtpmap_type(newvideortp, codec, "video", mimeSubtype);
 	}
 
 	/* Now gather all of the codecs that we are asked for: */
-	ast_rtp_get_current_formats(&newaudiortp, &peercapability, &peernoncodeccapability);
-	ast_rtp_get_current_formats(&newvideortp, &vpeercapability, &vpeernoncodeccapability);
+	ast_rtp_get_current_formats(newaudiortp, &peercapability, &peernoncodeccapability);
+	ast_rtp_get_current_formats(newvideortp, &vpeercapability, &vpeernoncodeccapability);
 
 	newjointcapability = p->capability & (peercapability | vpeercapability);
 	newpeercapability = (peercapability | vpeercapability);
@@ -4350,15 +4353,9 @@
 	p->peercapability = newpeercapability;		/* The other sides capability in latest offer */
 	p->noncodeccapability = newnoncodeccapability;	/* DTMF capabilities */
 
-	{
-		int i;
-		/* Copy payload types from source to destination */
-		for (i=0; i < MAX_RTP_PT; ++i) {
-			p->rtp->current_RTP_PT[i]= newaudiortp.current_RTP_PT[i];
-			if (p->vrtp) 
-				p->vrtp->current_RTP_PT[i]= newvideortp.current_RTP_PT[i];
-		}
-	}
+	ast_rtp_pt_copy(p->rtp, newaudiortp);
+	if (p->vrtp)
+		ast_rtp_pt_copy(p->vrtp, newvideortp);
 
 	if (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO) {
 		ast_clear_flag(&p->flags[0], SIP_DTMF);

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-24 02:21:24 UTC (rev 307)
+++ trunk/include/asterisk/rtp.h	2006-06-24 02:22:09 UTC (rev 308)
@@ -80,59 +80,11 @@
 	int code;
 };
 
-/*! \brief RTP session description */
-struct ast_rtp {
-	int s;
-	char resp;
-	struct ast_frame f;
-	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
-	unsigned int ssrc;		/*!< Synchronization source, RFC 3550, page 10. */
-	unsigned int themssrc;		/*!< Their SSRC */
-	unsigned int rxssrc;
-	unsigned int lastts;
-	unsigned int lastdigitts;
-	unsigned int lastrxts;
-	unsigned int lastividtimestamp;
-	unsigned int lastovidtimestamp;
-	unsigned int lasteventseqn;
-	int lastrxseqno;                /*!< Last received sequence number */
-	unsigned short seedrxseqno;     /*!< What sequence number did they start with?*/
-	unsigned int seedrxts;          /*!< What RTP timestamp did they start with? */
-	unsigned int rxcount;           /*!< How many packets have we received? */
-	unsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/
-	unsigned int txcount;           /*!< How many packets have we sent? */
-	unsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/
-	unsigned int cycles;            /*!< Shifted count of sequence number cycles */
-	double rxjitter;                /*!< Interarrival jitter at the moment */
-	double rxtransit;               /*!< Relative transit time for previous packet */
-	unsigned int lasteventendseqn;
-	int lasttxformat;
-	int lastrxformat;
-	int dtmfcount;
-	unsigned int dtmfduration;
-	int nat;
-	unsigned int flags;
-	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
-	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
-	struct timeval rxcore;
-	struct timeval txcore;
-	double drxcore;                 /*!< The double representation of the first received packet */
-	struct timeval lastrx;          /*!< timeval when we last received a packet */
-	struct timeval dtmfmute;
-	struct ast_smoother *smoother;
-	int *ioid;
-	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
-	unsigned short rxseqno;
-	struct sched_context *sched;
-	struct io_context *io;
-	void *data;
-	ast_rtp_callback callback;
-	struct rtpPayloadType current_RTP_PT[MAX_RTP_PT];
-	int rtp_lookup_code_cache_isAstFormat; /*!< a cache for the result of rtp_lookup_code(): */
-	int rtp_lookup_code_cache_code;
-	int rtp_lookup_code_cache_result;
-	struct ast_rtcp *rtcp;
-};
+/*!
+ * \brief Get the amount of space required to hold an RTP session
+ * \return number of bytes required
+ */
+size_t ast_rtp_alloc_size(void);
 
 /*!
  * \brief Initializate a RTP session.
@@ -196,6 +148,10 @@
 void ast_rtp_pt_clear(struct ast_rtp* rtp);
 /*! \brief Set payload types to defaults */
 void ast_rtp_pt_default(struct ast_rtp* rtp);
+
+/*! \brief Copy payload types between RTP structures */
+void ast_rtp_pt_copy(struct ast_rtp *dest, const struct ast_rtp *src);
+
 void ast_rtp_set_m_type(struct ast_rtp* rtp, int pt);
 void ast_rtp_set_rtpmap_type(struct ast_rtp* rtp, int pt,
 			 char* mimeType, char* mimeSubtype);

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-24 02:21:24 UTC (rev 307)
+++ trunk/rtp.c	2006-06-24 02:22:09 UTC (rev 308)
@@ -94,6 +94,60 @@
 static int nochecksums = 0;
 #endif
 
+/*! \brief RTP session description */
+struct ast_rtp {
+	int s;
+	char resp;
+	struct ast_frame f;
+	unsigned char rawdata[8192 + AST_FRIENDLY_OFFSET];
+	unsigned int ssrc;		/*!< Synchronization source, RFC 3550, page 10. */
+	unsigned int themssrc;		/*!< Their SSRC */
+	unsigned int rxssrc;
+	unsigned int lastts;
+	unsigned int lastdigitts;
+	unsigned int lastrxts;
+	unsigned int lastividtimestamp;
+	unsigned int lastovidtimestamp;
+	unsigned int lasteventseqn;
+	int lastrxseqno;                /*!< Last received sequence number */
+	unsigned short seedrxseqno;     /*!< What sequence number did they start with?*/
+	unsigned int seedrxts;          /*!< What RTP timestamp did they start with? */
+	unsigned int rxcount;           /*!< How many packets have we received? */
+	unsigned int rxoctetcount;      /*!< How many octets have we received? should be rxcount *160*/
+	unsigned int txcount;           /*!< How many packets have we sent? */
+	unsigned int txoctetcount;      /*!< How many octets have we sent? (txcount*160)*/
+	unsigned int cycles;            /*!< Shifted count of sequence number cycles */
+	double rxjitter;                /*!< Interarrival jitter at the moment */
+	double rxtransit;               /*!< Relative transit time for previous packet */
+	unsigned int lasteventendseqn;
+	int lasttxformat;
+	int lastrxformat;
+	int dtmfcount;
+	unsigned int dtmfduration;
+	int nat;
+	unsigned int flags;
+	struct sockaddr_in us;		/*!< Socket representation of the local endpoint. */
+	struct sockaddr_in them;	/*!< Socket representation of the remote endpoint. */
+	struct timeval rxcore;
+	struct timeval txcore;
+	double drxcore;                 /*!< The double representation of the first received packet */
+	struct timeval lastrx;          /*!< timeval when we last received a packet */
+	struct timeval dtmfmute;
+	struct ast_smoother *smoother;
+	int *ioid;
+	unsigned short seqno;		/*!< Sequence number, RFC 3550, page 13. */
+	unsigned short rxseqno;
+	struct sched_context *sched;
+	struct io_context *io;
+	void *data;
+	ast_rtp_callback callback;
+	struct rtpPayloadType current_RTP_PT[MAX_RTP_PT];
+	int rtp_lookup_code_cache_isAstFormat; /*!< a cache for the result of rtp_lookup_code(): */
+	int rtp_lookup_code_cache_code;
+	int rtp_lookup_code_cache_result;
+	struct ast_rtcp *rtcp;
+};
+
 /* Forward declarations */
 static int ast_rtcp_write(void *data);
 static void timeval2ntp(struct timeval tv, unsigned int *msw, unsigned int *lsw);
@@ -307,6 +361,11 @@
 		req->id.id[x] = ast_random();
 }
 
+size_t ast_rtp_alloc_size(void)
+{
+	return sizeof(struct ast_rtp);
+}
+
 void ast_rtp_stun_request(struct ast_rtp *rtp, struct sockaddr_in *suggestion, const char *username)
 {
 	struct stun_header *req;
@@ -1189,10 +1248,10 @@
 	rtp->rtp_lookup_code_cache_result = 0;
 }
 
-static void ast_rtp_pt_copy(struct ast_rtp *dest, struct ast_rtp *src)
+void ast_rtp_pt_copy(struct ast_rtp *dest, const struct ast_rtp *src)
 {
-	int i;
-	/* Copy payload types from source to destination */
+	unsigned int i;
+
 	for (i=0; i < MAX_RTP_PT; ++i) {
 		dest->current_RTP_PT[i].isAstFormat = 
 			src->current_RTP_PT[i].isAstFormat;



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:22:55 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:22:55 +0200
Subject: [solid-pbx-svn] r309 - trunk/include
Message-ID: <200606240222.k5O2MtJC028109@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:22:54 +0200 (Sat, 24 Jun 2006)
New Revision: 309

Modified:
   trunk/include/asterisk.h
Log:
Update to Asterisk SVN trunk r33153

------------------------------------------------------------------------
r33152 | jcollie | 2006-06-09 04:20:25 +0200 (Fri, 09 Jun 2006) | 1 line

Move a couple semicolons to a more traditional location.  Was pointed out by Steven <critch at basesys.com> on the -dev list.
------------------------------------------------------------------------


Modified: trunk/include/asterisk.h
===================================================================
--- trunk/include/asterisk.h	2006-06-24 02:22:09 UTC (rev 308)
+++ trunk/include/asterisk.h	2006-06-24 02:22:54 UTC (rev 309)
@@ -53,8 +53,8 @@
 int ast_set_priority(int);			/*!< Provided by asterisk.c */
 int load_modules(const int preload_only);	/*!< Provided by module.c */
 int load_pbx(void);				/*!< Provided by pbx.c */
-int init_logger(void)				/*!< Provided by logger.c */;
-void close_logger(void)				/*!< Provided by logger.c */;
+int init_logger(void);				/*!< Provided by logger.c */
+void close_logger(void);			/*!< Provided by logger.c */
 int reload_logger(int);				/*!< Provided by logger.c */
 int init_framer(void);				/*!< Provided by frame.c */
 int term_init(void);				/*!< Provided by term.c */



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:25:36 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:25:36 +0200
Subject: [solid-pbx-svn] r310 - trunk/channels
Message-ID: <200606240225.k5O2Pa1s031195@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:25:23 +0200 (Sat, 24 Jun 2006)
New Revision: 310

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33173

------------------------------------------------------------------------
r33173 | oej | 2006-06-09 11:38:13 +0200 (Fri, 09 Jun 2006) | 2 lines

Enabling and disabling debug messages...

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-24 02:22:54 UTC (rev 309)
+++ trunk/channels/chan_sip.c	2006-06-24 02:25:23 UTC (rev 310)
@@ -2897,6 +2897,9 @@
 		else 
 			ast_log(LOG_DEBUG, "Hangup call %s, SIP callid %s)\n", ast->name, p->callid);
 	}
+	if (option_debug && ast_test_flag(ast, AST_FLAG_ZOMBIE)) {
+		ast_log(LOG_DEBUG, "Hanging up zombie call. Be scared.\n");
+	}
 
 	ast_mutex_lock(&p->lock);
 	if (option_debug && sipdebug)
@@ -5264,8 +5267,6 @@
 		if (!(capability & x))	/* Codec not requested */
 			continue;
 
-		ast_log(LOG_DEBUG, "--- Checking codec ... %d\n", x);
-
 		if (alreadysent & x)	/* Already added to SDP */
 			continue;
 



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:27:56 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:27:56 +0200
Subject: [solid-pbx-svn] r311 - in trunk: . apps include/asterisk
Message-ID: <200606240227.k5O2Ru7f001587@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:27:40 +0200 (Sat, 24 Jun 2006)
New Revision: 311

Modified:
   trunk/apps/app_dial.c
   trunk/include/asterisk/rtp.h
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r33183

------------------------------------------------------------------------
r33174 | oej | 2006-06-09 11:47:44 +0200 (Fri, 09 Jun 2006) | 2 lines

Rename ast_rtp_early_media to ast_rtp_early_bridge to avoid confusion.

------------------------------------------------------------------------


Modified: trunk/apps/app_dial.c
===================================================================
--- trunk/apps/app_dial.c	2006-06-24 02:25:23 UTC (rev 310)
+++ trunk/apps/app_dial.c	2006-06-24 02:27:40 UTC (rev 311)
@@ -580,8 +580,8 @@
 							       OPT_CALLEE_MONITOR | OPT_CALLER_MONITOR |
 							       OPT_CALLEE_PARK | OPT_CALLER_PARK |
 							       DIAL_NOFORWARDHTML);
-						/* Setup early media if appropriate */
-						ast_rtp_early_media(in, peer);
+						/* Setup RTP early bridge if appropriate */
+						ast_rtp_early_bridge(in, peer);
 					}
 					/* If call has been answered, then the eventual hangup is likely to be normal hangup */
 					in->hangupcause = AST_CAUSE_NORMAL_CLEARING;
@@ -610,7 +610,7 @@
 						ast_verbose(VERBOSE_PREFIX_3 "%s is ringing\n", c->name);
 					/* Setup early media if appropriate */
 					if (single)
-						ast_rtp_early_media(in, c);
+						ast_rtp_early_bridge(in, c);
 					if (!(*sentringing) && !ast_test_flag(outgoing, OPT_MUSICBACK)) {
 						ast_indicate(in, AST_CONTROL_RINGING);
 						(*sentringing)++;
@@ -621,7 +621,7 @@
 						ast_verbose (VERBOSE_PREFIX_3 "%s is making progress passing it to %s\n", c->name, in->name);
 					/* Setup early media if appropriate */
 					if (single)
-						ast_rtp_early_media(in, c);
+						ast_rtp_early_bridge(in, c);
 					if (!ast_test_flag(outgoing, OPT_RINGBACK))
 						ast_indicate(in, AST_CONTROL_PROGRESS);
 					break;
@@ -634,7 +634,7 @@
 					if (option_verbose > 2)
 						ast_verbose (VERBOSE_PREFIX_3 "%s is proceeding passing it to %s\n", c->name, in->name);
 					if (single)
-						ast_rtp_early_media(in, c);
+						ast_rtp_early_bridge(in, c);
 					if (!ast_test_flag(outgoing, OPT_RINGBACK))
 						ast_indicate(in, AST_CONTROL_PROCEEDING);
 					break;
@@ -1612,7 +1612,7 @@
 		sentringing = 0;
 		ast_indicate(chan, -1);
 	}
-	ast_rtp_early_media(chan, NULL);
+	ast_rtp_early_bridge(chan, NULL);
 	hanguptree(outgoing, NULL);
 	pbx_builtin_setvar_helper(chan, "DIALSTATUS", status);
 	if (option_debug)

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-24 02:25:23 UTC (rev 310)
+++ trunk/include/asterisk/rtp.h	2006-06-24 02:27:40 UTC (rev 311)
@@ -182,7 +182,9 @@
 
 int ast_rtp_make_compatible(struct ast_channel *dest, struct ast_channel *src, int media);
 
-int ast_rtp_early_media(struct ast_channel *dest, struct ast_channel *src);
+/*! \brief If possible, create an early bridge directly between the devices without
+           having to send a re-invite later */
+int ast_rtp_early_bridge(struct ast_channel *dest, struct ast_channel *src);
 
 void ast_rtp_stop(struct ast_rtp *rtp);
 

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-24 02:25:23 UTC (rev 310)
+++ trunk/rtp.c	2006-06-24 02:27:40 UTC (rev 311)
@@ -1278,7 +1278,7 @@
 	return cur;
 }
 
-int ast_rtp_early_media(struct ast_channel *dest, struct ast_channel *src)
+int ast_rtp_early_bridge(struct ast_channel *dest, struct ast_channel *src)
 {
 	struct ast_rtp *destp, *srcp=NULL;		/* Audio RTP Channels */
 	struct ast_rtp *vdestp, *vsrcp=NULL;		/* Video RTP channels */



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:28:49 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:28:49 +0200
Subject: [solid-pbx-svn] r312 - trunk/channels/misdn
Message-ID: <200606240228.k5O2Sndp005651@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:28:47 +0200 (Sat, 24 Jun 2006)
New Revision: 312

Modified:
   trunk/channels/misdn/isdn_lib.c
Log:
Update to Asterisk SVN trunk r33203

------------------------------------------------------------------------
r33195 | crichter | 2006-06-09 12:31:30 +0200 (Fri, 09 Jun 2006) | 1 line

when we don't want the call we need to release_complete it.. ignoring it breaks the ETSI rules .. 
------------------------------------------------------------------------


Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-24 02:27:40 UTC (rev 311)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-24 02:28:47 UTC (rev 312)
@@ -2389,6 +2389,9 @@
 					break;
 				case RESPONSE_IGNORE_SETUP:
 					/* I think we should send CC_RELEASE_CR, but am not sure*/
+
+					bc->out_cause=16;
+					misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
 					empty_chan_in_stack(stack, bc->channel);
 					empty_bc(bc);
 					bc_state_change(bc,BCHAN_CLEANED);



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:31:52 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:31:52 +0200
Subject: [solid-pbx-svn] r313 - trunk/channels
Message-ID: <200606240231.k5O2VqKk009726@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:31:50 +0200 (Sat, 24 Jun 2006)
New Revision: 313

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33223

------------------------------------------------------------------------
r33215 | oej | 2006-06-09 15:35:41 +0200 (Fri, 09 Jun 2006) | 2 lines

Remove the return value from functions that return something that is never checked anywhere.

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-24 02:28:47 UTC (rev 312)
+++ trunk/channels/chan_sip.c	2006-06-24 02:31:50 UTC (rev 313)
@@ -235,6 +235,11 @@
 };
 
 
+enum sip_result {
+	AST_SUCCESS = 0,
+	AST_FAILURE = -1,
+};
+
 /* Do _NOT_ make any changes to this enum, or the array following it;
    if you think you are doing the right thing, you are probably
    not doing the right thing. If you think there are changes
@@ -1101,12 +1106,12 @@
 static struct sip_pvt *sip_alloc(ast_string_field callid, struct sockaddr_in *sin,
 				 int useglobal_nat, const int intended_method);
 static int __sip_autodestruct(void *data);
-static int sip_scheddestroy(struct sip_pvt *p, int ms);
-static int sip_cancel_destroy(struct sip_pvt *p);
+static void sip_scheddestroy(struct sip_pvt *p, int ms);
+static void sip_cancel_destroy(struct sip_pvt *p);
 static void sip_destroy(struct sip_pvt *p);
 static void __sip_destroy(struct sip_pvt *p, int lockowner);
-static int __sip_ack(struct sip_pvt *p, int seqno, int resp, int sipmethod, int reset);
-static int __sip_pretend_ack(struct sip_pvt *p);
+static void __sip_ack(struct sip_pvt *p, int seqno, int resp, int sipmethod, int reset);
+static void __sip_pretend_ack(struct sip_pvt *p);
 static int __sip_semi_ack(struct sip_pvt *p, int seqno, int resp, int sipmethod);
 static int auto_congest(void *nothing);
 static int update_call_counter(struct sip_pvt *fup, int event);
@@ -1152,7 +1157,6 @@
 static int restart_monitor(void);
 static int sip_send_mwi_to_peer(struct sip_peer *peer);
 static void sip_destroy(struct sip_pvt *p);
-static int sip_scheddestroy(struct sip_pvt *p, int ms);
 static int sip_addrcmp(char *name, struct sockaddr_in *sin);	/* Support for peer matching */
 
 /*--- CLI and manager command helpers */
@@ -1162,7 +1166,7 @@
 static void sip_dump_history(struct sip_pvt *dialog);	/* Dump history to LOG_DEBUG at end of dialog, before destroying data */
 static inline int sip_debug_test_addr(const struct sockaddr_in *addr);
 static inline int sip_debug_test_pvt(struct sip_pvt *p);
-static int append_history_full(struct sip_pvt *p, const char *fmt, ...);
+static void append_history_full(struct sip_pvt *p, const char *fmt, ...);
 
 /*--- Device object handling */
 static struct sip_peer *temp_peer(const char *name);
@@ -1463,7 +1467,7 @@
 
 /*! \brief NAT fix - decide which IP address to use for ASterisk server?
  * Only used for outbound registrations */
-static int ast_sip_ouraddrfor(struct in_addr *them, struct in_addr *us)
+static enum sip_result ast_sip_ouraddrfor(struct in_addr *them, struct in_addr *us)
 {
 	/*
 	 * Using the localaddr structure built up with localnet statements
@@ -1499,14 +1503,14 @@
 		}
 	} else if (bindaddr.sin_addr.s_addr)
 		*us = bindaddr.sin_addr;
-	return 0;
+	return AST_FAILURE;
 }
 
 /*! \brief Append to SIP dialog history 
 	\return Always returns 0 */
 #define append_history(p, event, fmt , args... )	append_history_full(p, "%-15s " fmt, event, ## args)
 
-static int append_history_full(struct sip_pvt *p, const char *fmt, ...)
+static void append_history_full(struct sip_pvt *p, const char *fmt, ...)
 	__attribute__ ((format (printf, 2, 3)));
 
 /*! \brief Append to SIP dialog history with arg list  */
@@ -1530,17 +1534,17 @@
 }
 
 /*! \brief Append to SIP dialog history with arg list  */
-static int append_history_full(struct sip_pvt *p, const char *fmt, ...)
+static void append_history_full(struct sip_pvt *p, const char *fmt, ...)
 {
 	va_list ap;
 
 	if (!recordhistory || !p)
-		return 0;
+		return;
 	va_start(ap, fmt);
 	append_history_va(p, fmt, ap);
 	va_end(ap);
 
-	return 0;
+	return;
 }
 
 /*! \brief Retransmit SIP message if no answer (Called from scheduler) */
@@ -1643,13 +1647,13 @@
 /*! \brief Transmit packet with retransmits 
 	\return 0 on success, -1 on failure to allocate packet 
 */
-static int __sip_reliable_xmit(struct sip_pvt *p, int seqno, int resp, char *data, int len, int fatal, int sipmethod)
+static enum sip_result __sip_reliable_xmit(struct sip_pvt *p, int seqno, int resp, char *data, int len, int fatal, int sipmethod)
 {
 	struct sip_pkt *pkt;
 	int siptimer_a = DEFAULT_RETRANS;
 
 	if (!(pkt = ast_calloc(1, sizeof(*pkt) + len + 1)))
-		return -1;
+		return AST_FAILURE;
 	memcpy(pkt->data, data, len);
 	pkt->method = sipmethod;
 	pkt->packetlen = len;
@@ -1676,7 +1680,7 @@
 		/* Note this is a pending invite */
 		p->pendinginvite = seqno;
 	}
-	return 0;
+	return AST_SUCCESS;
 }
 
 /*! \brief Kill a SIP dialog (called by scheduler) */
@@ -1711,7 +1715,7 @@
 }
 
 /*! \brief Schedule destruction of SIP call */
-static int sip_scheddestroy(struct sip_pvt *p, int ms)
+static void sip_scheddestroy(struct sip_pvt *p, int ms)
 {
 	if (sip_debug_test_pvt(p))
 		ast_verbose("Scheduling destruction of SIP dialog '%s' in %d ms (Method: %s)\n", p->callid, ms, sip_methods[p->method].text);
@@ -1721,28 +1725,26 @@
 	if (p->autokillid > -1)
 		ast_sched_del(sched, p->autokillid);
 	p->autokillid = ast_sched_add(sched, ms, __sip_autodestruct, p);
-	return 0;
 }
 
 /*! \brief Cancel destruction of SIP dialog */
-static int sip_cancel_destroy(struct sip_pvt *p)
+static void sip_cancel_destroy(struct sip_pvt *p)
 {
 	if (p->autokillid > -1) {
 		ast_sched_del(sched, p->autokillid);
 		append_history(p, "CancelDestroy", "");
 		p->autokillid = -1;
 	}
-	return 0;
 }
 
 /*! \brief Acknowledges receipt of a packet and stops retransmission */
-static int __sip_ack(struct sip_pvt *p, int seqno, int resp, int sipmethod, int reset)
+static void __sip_ack(struct sip_pvt *p, int seqno, int resp, int sipmethod, int reset)
 {
 	struct sip_pkt *cur, *prev = NULL;
-	int res = -1;
 
 	/* Just in case... */
 	char *msg;
+	int res = FALSE;
 
 	msg = sip_methods[sipmethod].text;
 
@@ -1756,6 +1758,7 @@
 				p->pendinginvite = 0;
 			}
 			/* this is our baby */
+			res = TRUE;
 			UNLINK(cur, p->packets, prev);
 			if (cur->retransid > -1) {
 				if (sipdebug && option_debug > 3)
@@ -1764,19 +1767,17 @@
 			}
 			if (!reset)
 				free(cur);
-			res = 0;
 			break;
 		}
 	}
 	ast_mutex_unlock(&p->lock);
 	if (option_debug)
 		ast_log(LOG_DEBUG, "Stopping retransmission on '%s' of %s %d: Match %s\n", p->callid, resp ? "Response" : "Request", seqno, res ? "Not Found" : "Found");
-	return res;
 }
 
-/*! \brief Pretend to ack all packets */
-/* maybe the lock on p is not strictly necessary but there might be a race */
-static int __sip_pretend_ack(struct sip_pvt *p)
+/*! \brief Pretend to ack all packets
+ * maybe the lock on p is not strictly necessary but there might be a race */
+static void __sip_pretend_ack(struct sip_pvt *p)
 {
 	struct sip_pkt *cur = NULL;
 
@@ -1784,13 +1785,12 @@
 		int method;
 		if (cur == p->packets) {
 			ast_log(LOG_WARNING, "Have a packet that doesn't want to give up! %s\n", sip_methods[cur->method].text);
-			return -1;
+			return;
 		}
 		cur = p->packets;
 		method = (cur->method) ? cur->method : find_sip_method(cur->data);
 		__sip_ack(p, cur->seqno, ast_test_flag(cur, FLAG_RESPONSE), method, FALSE);
 	}
-	return 0;
 }
 
 /*! \brief Acks receipt of packet, keep it around (used for provisional responses) */
@@ -7675,7 +7675,7 @@
 	return -1;
 }
 /*! \brief check Via: header for hostname, port and rport request/answer */
-static int check_via(struct sip_pvt *p, struct sip_request *req)
+static void check_via(struct sip_pvt *p, struct sip_request *req)
 {
 	char via[256];
 	char iabuf[INET_ADDRSTRLEN];
@@ -7700,7 +7700,7 @@
 		c = ast_skip_blanks(c+1);
 		if (strcasecmp(via, "SIP/2.0/UDP")) {
 			ast_log(LOG_WARNING, "Don't know how to respond via '%s'\n", via);
-			return -1;
+			return;
 		}
 		pt = strchr(c, ':');
 		if (pt)
@@ -7708,7 +7708,7 @@
 		hp = ast_gethostbyname(c, &ahp);
 		if (!hp) {
 			ast_log(LOG_WARNING, "'%s' is not a valid host\n", c);
-			return -1;
+			return;
 		}
 		memset(&p->sa, 0, sizeof(p->sa));
 		p->sa.sin_family = AF_INET;
@@ -7720,7 +7720,6 @@
 			ast_verbose("Sending to %s : %d (%s)\n", ast_inet_ntoa(iabuf, sizeof(iabuf), dst->sin_addr), ntohs(dst->sin_port), sip_nat_mode(p));
 		}
 	}
-	return 0;
 }
 
 /*! \brief  Get caller id name from SIP headers */



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:32:40 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:32:40 +0200
Subject: [solid-pbx-svn] r314 - trunk/channels
Message-ID: <200606240232.k5O2WeTZ009762@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:32:33 +0200 (Sat, 24 Jun 2006)
New Revision: 314

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33243

------------------------------------------------------------------------
r33236 | oej | 2006-06-09 17:57:28 +0200 (Fri, 09 Jun 2006) | 2 lines

Don't force context for domain= setting (imported from 1.2)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-24 02:31:50 UTC (rev 313)
+++ trunk/channels/chan_sip.c	2006-06-24 02:32:33 UTC (rev 314)
@@ -14706,10 +14706,10 @@
 			if (context)
 				*context++ = '\0';
 
+			if (option_debug && ast_strlen_zero(context))
+				ast_log(LOG_DEBUG, "No context specified at line %d for domain '%s'\n", v->lineno, domain);
 			if (ast_strlen_zero(domain))
 				ast_log(LOG_WARNING, "Empty domain specified at line %d\n", v->lineno);
-			else if (ast_strlen_zero(context))
-				ast_log(LOG_WARNING, "Empty context specified at line %d for domain '%s'\n", v->lineno, domain);
 			else
 				add_sip_domain(ast_strip(domain), SIP_DOMAIN_CONFIG, context ? ast_strip(context) : "");
 		} else if (!strcasecmp(v->name, "register")) {



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:33:34 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:33:34 +0200
Subject: [solid-pbx-svn] r315 - in trunk: include/asterisk res
Message-ID: <200606240233.k5O2XYj6009815@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:33:31 +0200 (Sat, 24 Jun 2006)
New Revision: 315

Modified:
   trunk/include/asterisk/jabber.h
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r33263

------------------------------------------------------------------------
r33263 | mogorman | 2006-06-09 18:08:33 +0200 (Fri, 09 Jun 2006) | 2 lines

convert one of my linked lists to ast_linklist

------------------------------------------------------------------------


Modified: trunk/include/asterisk/jabber.h
===================================================================
--- trunk/include/asterisk/jabber.h	2006-06-24 02:32:33 UTC (rev 314)
+++ trunk/include/asterisk/jabber.h	2006-06-24 02:33:31 UTC (rev 315)
@@ -21,6 +21,7 @@
 
 #include <iksemel.h>
 #include "asterisk/astobj.h"
+#include "asterisk/linkedlists.h"
 
 enum aji_state {
 	AJI_DISCONNECTED = 0,
@@ -71,7 +72,7 @@
 	char *message;
 	char id[25];
 	time_t arrived;
-	struct aji_message *next;
+	AST_LIST_ENTRY(aji_message) list;
 };
 
 struct aji_buddy {
@@ -121,8 +122,7 @@
 	unsigned int flags;
 	enum aji_type component;
 	struct aji_buddy_container buddies;
- 	ast_mutex_t message_lock; 
-	struct aji_message *messages;
+	AST_LIST_HEAD(messages,aji_message) messages;
 	void *jingle;
 	pthread_t thread;
 };

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-24 02:32:33 UTC (rev 314)
+++ trunk/res/res_jabber.c	2006-06-24 02:33:31 UTC (rev 315)
@@ -158,13 +158,17 @@
 	struct aji_message *tmp;
 	ASTOBJ_CONTAINER_DESTROYALL(&obj->buddies, aji_buddy_destroy);
 	ASTOBJ_CONTAINER_DESTROY(&obj->buddies);
-
-	while ((tmp = obj->messages)) {
-		obj->messages = obj->messages->next;
-		if(tmp->from) free(tmp->from);
-		if(tmp->message) free(tmp->message);
-		free(tmp);
+	iks_filter_delete(obj->f);
+	iks_parser_delete(obj->p);
+	iks_stack_delete(obj->stack);
+	AST_LIST_LOCK(&client->messages);
+	while(tmp = AST_LIST_REMOVE_HEAD(&client->messages, list)) {
+		if (tmp->from)
+			free(tmp->from);
+		if (tmp->message)
+			free(tmp->message);
 	}
+	AST_LIST_HEAD_DESTROY(&client->messages);
 	free(obj);
 }
 
@@ -1025,44 +1029,33 @@
  */
 static void aji_handle_message(struct aji_client *client, ikspak *pak)
 {
-	struct aji_message *insert, *tmp, *delete, *last;
+	struct aji_message *insert, *tmp;
 	int flag = 0;
-	insert = ast_malloc(sizeof(struct aji_message));
-	memset(insert, 0, sizeof(struct aji_message));
-	insert->arrived = time(NULL);
-	insert->next = NULL;
+	insert = ast_calloc(1,sizeof(struct aji_message));
+	time(&insert->arrived);
 	insert->message = ast_strdup(iks_find_cdata(pak->x, "body"));
 	ast_copy_string(insert->id, pak->id, sizeof(insert->message));
 	insert->from = ast_strdup(pak->from->full);
-	ast_mutex_lock(&(client)->message_lock);
-	insert->next = client->messages;
-	client->messages = insert;
-	insert = NULL;
-	tmp = client->messages;
-	last = tmp;
-	while(tmp) {
-		if(flag) { /*timestamp exceeded delete rest */
-			delete = tmp;
-			tmp = tmp->next;
-			if(delete->message) free(delete->message);
-			if(delete->from) free(delete->from);
-			free(delete);
-			delete = NULL;
-		} else if(difftime(time(NULL), tmp->arrived) >= client->message_timeout) {
+	AST_LIST_LOCK(&client->messages);
+	AST_LIST_TRAVERSE_SAFE_BEGIN(&client->messages, tmp, list) {
+		if(flag) {
+			AST_LIST_REMOVE_CURRENT(&client->messages,list);
+			if (tmp->from)
+				free(tmp->from);
+			if (tmp->message)
+				free(tmp->message);
+		} else if (difftime(time(NULL), tmp->arrived) >= client->message_timeout) {
 			flag = 1;
-			last->next = NULL;
-			delete = tmp;
-			tmp = tmp->next;
-			if(delete->message) free(delete->message);
-			if(delete->from) free(delete->from);
-			free(delete);
-			delete = NULL;
-		} else {
-			last = tmp;
-			tmp = tmp->next;
+			AST_LIST_REMOVE_CURRENT(&client->messages,list);
+			if (tmp->from)
+				free(tmp->from);
+			if (tmp->message)
+				free(tmp->message);
 		}
 	}
-	ast_mutex_unlock(&(client)->message_lock);
+	AST_LIST_TRAVERSE_SAFE_END;
+	AST_LIST_INSERT_HEAD(&client->messages,insert,list);
+	AST_LIST_UNLOCK(&client->messages);
 }
 static void aji_handle_presence(struct aji_client *client, ikspak *pak)
 {
@@ -1939,20 +1932,16 @@
 			}
 			ast_verbose("	Priority: %d\n", resource->priority);
 			ast_verbose("	Status: %d\n", resource->status); 
-			ast_verbose("	Message: %s\n", resource->description); 
+			ast_verbose("	Message: %s\n", S_OR(resource->description,"")); 
 		}
 		ASTOBJ_UNLOCK(iterator);
 	});
-	tmp = client->messages;
-	ast_mutex_lock(&(client)->message_lock);
 	ast_verbose("\nOooh a working message stack!\n");
-	while(tmp) {
-	ast_verbose("	Message from: %s with id %s @ %s	%s\n",tmp->from, tmp->id, ctime(&tmp->arrived), tmp->message);
-	tmp = tmp->next;
+	AST_LIST_LOCK(&client->messages);
+	AST_LIST_TRAVERSE(&client->messages, tmp, list) {
+		ast_verbose("	Message from: %s with id %s @ %s	%s\n",tmp->from, tmp->id, ctime(&tmp->arrived), tmp->message);
 	}
-	ast_mutex_unlock(&(client)->message_lock);
-
-
+	AST_LIST_UNLOCK(&client->messages);
 	ASTOBJ_UNREF(client, aji_client_destroy);
 
 	return RESULT_SUCCESS;
@@ -1998,6 +1987,7 @@
 	client->keepalive = 1;
 	client->timeout = 20;
 	client->message_timeout = 100;
+	AST_LIST_HEAD_INIT(&client->messages);
 	client->component = AJI_CLIENT;
 	ast_copy_string(client->statusmessage, "Online and Available", sizeof(client->statusmessage));
 



From solid-pbx-svn-admin at lists.berlios.de  Sat Jun 24 04:34:15 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Sat, 24 Jun 2006 04:34:15 +0200
Subject: [solid-pbx-svn] r316 - trunk/apps
Message-ID: <200606240234.k5O2YFa8009870@sheep.berlios.de>

Author: casper2
Date: 2006-06-24 04:34:02 +0200 (Sat, 24 Jun 2006)
New Revision: 316

Modified:
   trunk/apps/app_meetme.c
Log:
Update to Asterisk SVN trunk r33273

------------------------------------------------------------------------
r33265 | file | 2006-06-09 18:33:34 +0200 (Fri, 09 Jun 2006) | 9 lines

Blocked revisions 33264 via svnmerge

.......
r33264 | file | 2006-06-09 13:31:29 -0300 (Fri, 09 Jun 2006) | 2 lines

Add missing newlines (issue #7323 reported by darkskiez)

.......

------------------------------------------------------------------------
r33266 | file | 2006-06-09 18:36:54 +0200 (Fri, 09 Jun 2006) | 2 lines

Add more missing newlines (issue #7323 reported by darkskiez)

------------------------------------------------------------------------


Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-06-24 02:33:31 UTC (rev 315)
+++ trunk/apps/app_meetme.c	2006-06-24 02:34:02 UTC (rev 316)
@@ -2316,7 +2316,7 @@
 				if (user)
 					user->adminflags |= ADMINFLAG_KICKME;
 				else
-					ast_log(LOG_NOTICE, "Specified User not found!");
+					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			case 118: /* v: Lower all users listen volume */
 				AST_LIST_TRAVERSE(&cnf->userlist, user, list)
@@ -2342,31 +2342,31 @@
 				if (user)
 					reset_volumes(user);
 				else
-					ast_log(LOG_NOTICE, "Specified User not found!");
+					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			case 85: /* U: Raise user's listen volume */
 				if (user)
 					tweak_listen_volume(user, VOL_UP);
 				else
-					ast_log(LOG_NOTICE, "Specified User not found!");
+					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			case 117: /* u: Lower user's listen volume */
 				if (user)
 					tweak_listen_volume(user, VOL_DOWN);
 				else
-					ast_log(LOG_NOTICE, "Specified User not found!");
+					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			case 84: /* T: Raise user's talk volume */
 				if (user)
 					tweak_talk_volume(user, VOL_UP);
 				else
-					ast_log(LOG_NOTICE, "Specified User not found!");
+					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			case 116: /* t: Lower user's talk volume */
 				if (user) 
 					tweak_talk_volume(user, VOL_DOWN);
 				else 
-					ast_log(LOG_NOTICE, "Specified User not found!");
+					ast_log(LOG_NOTICE, "Specified User not found!\n");
 				break;
 			}
 		} else {



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 00:55:44 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 00:55:44 +0200
Subject: [solid-pbx-svn] r317 - in trunk: apps channels res
Message-ID: <200606272255.k5RMti0G013419@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 00:55:25 +0200 (Wed, 28 Jun 2006)
New Revision: 317

Modified:
   trunk/apps/app_dial.c
   trunk/channels/chan_iax2.c
   trunk/res/res_jabber.c
Log:
Update to Asterisk SVN trunk r33303

------------------------------------------------------------------------
r33295 | file | 2006-06-09 20:12:46 +0200 (Fri, 09 Jun 2006) | 10 lines

Merged revisions 33294 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33294 | file | 2006-06-09 15:08:00 -0300 (Fri, 09 Jun 2006) | 2 lines

Handle hangup during recording of screened name (issue #7304 reported by kulldominique)

.......

------------------------------------------------------------------------
r33296 | file | 2006-06-09 20:20:28 +0200 (Fri, 09 Jun 2006) | 2 lines

Wait until we have the lock before getting the pvt structure pointer (issue #7313 reported by arkadia)

------------------------------------------------------------------------
r33298 | file | 2006-06-09 20:29:58 +0200 (Fri, 09 Jun 2006) | 10 lines

Merged revisions 33297 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33297 | file | 2006-06-09 15:26:42 -0300 (Fri, 09 Jun 2006) | 2 lines

Remove an unneeded double lock (issue #7310 reported by arkadia)

.......

------------------------------------------------------------------------
r33299 | mogorman | 2006-06-09 20:37:26 +0200 (Fri, 09 Jun 2006) | 2 lines

oops moved block without renaming a variable correctly.

------------------------------------------------------------------------
r33301 | file | 2006-06-09 20:54:01 +0200 (Fri, 09 Jun 2006) | 9 lines

Blocked revisions 33300 via svnmerge

.......
r33300 | file | 2006-06-09 15:52:51 -0300 (Fri, 09 Jun 2006) | 2 lines

Allow the format outputted by meetme list to be used for meetme commands (like kick) (issue #7322 reported by darkskiez)

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_dial.c
===================================================================
--- trunk/apps/app_dial.c	2006-06-24 02:34:02 UTC (rev 316)
+++ trunk/apps/app_dial.c	2006-06-27 22:55:25 UTC (rev 317)
@@ -1021,11 +1021,20 @@
 				   "At the tone, please say your name:"
 
 				*/
-				ast_play_and_record(chan, "priv-recordintro", privintro, 4, "gsm", &duration, 128, 2000, 0);  /* NOTE: I've reduced the total time to 4 sec */
+				res = ast_play_and_record(chan, "priv-recordintro", privintro, 4, "gsm", &duration, 128, 2000, 0);  /* NOTE: I've reduced the total time to 4 sec */
 										/* don't think we'll need a lock removed, we took care of
 										   conflicts by naming the privintro file */
-				if( !ast_streamfile(chan, "vm-dialout", chan->language) )
-					ast_waitstream(chan, "");
+				if (res == -1) {
+					/* Delete the file regardless since they hung up during recording */
+                                        ast_filedelete(privintro, NULL);
+                                        if( ast_fileexists(privintro,NULL,NULL ) > 0 )
+                                                ast_log(LOG_NOTICE,"privacy: ast_filedelete didn't do its job on %s\n", privintro);
+                                        else if (option_verbose > 2)
+                                                ast_verbose( VERBOSE_PREFIX_3 "Successfully deleted %s intro file\n", privintro);
+					goto out;
+				}
+                                if( !ast_streamfile(chan, "vm-dialout", chan->language) )
+                                        ast_waitstream(chan, "");
 			}
 		}
 	}
@@ -1283,7 +1292,6 @@
 					res2 = ast_play_and_wait(peer,"priv-callpending");
 				if (!valid_priv_reply(&opts, res2))
 					res2 = 0;
-				
 				/* priv-callpending script: 
 				   "I have a caller waiting, who introduces themselves as:"
 				*/

Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-24 02:34:02 UTC (rev 316)
+++ trunk/channels/chan_iax2.c	2006-06-27 22:55:25 UTC (rev 317)
@@ -2238,7 +2238,7 @@
 static void __get_from_jb(void *p) 
 {
 	int callno = PTR_TO_CALLNO(p);
-	struct chan_iax2_pvt *pvt = iaxs[callno];
+	struct chan_iax2_pvt *pvt = NULL;
 	struct iax_frame *fr;
 	jb_frame frame;
 	int ret;
@@ -5817,11 +5817,9 @@
 	if (iaxs[callno]) {
 		iaxs[callno]->authfail = failcode;
 		if (delayreject) {
-			ast_mutex_lock(&iaxsl[callno]);
 			if (iaxs[callno]->authid > -1)
 				ast_sched_del(sched, iaxs[callno]->authid);
 			iaxs[callno]->authid = ast_sched_add(sched, 1000, auth_reject, (void *)(long)callno);
-			ast_mutex_unlock(&iaxsl[callno]);
 		} else
 			auth_reject((void *)(long)callno);
 	}

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-24 02:34:02 UTC (rev 316)
+++ trunk/res/res_jabber.c	2006-06-27 22:55:25 UTC (rev 317)
@@ -161,14 +161,14 @@
 	iks_filter_delete(obj->f);
 	iks_parser_delete(obj->p);
 	iks_stack_delete(obj->stack);
-	AST_LIST_LOCK(&client->messages);
-	while(tmp = AST_LIST_REMOVE_HEAD(&client->messages, list)) {
+	AST_LIST_LOCK(&obj->messages);
+	while ((tmp = AST_LIST_REMOVE_HEAD(&obj->messages, list))) {
 		if (tmp->from)
 			free(tmp->from);
 		if (tmp->message)
 			free(tmp->message);
 	}
-	AST_LIST_HEAD_DESTROY(&client->messages);
+	AST_LIST_HEAD_DESTROY(&obj->messages);
 	free(obj);
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 00:57:59 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 00:57:59 +0200
Subject: [solid-pbx-svn] r318 - trunk/apps
Message-ID: <200606272257.k5RMvxsD014262@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 00:57:51 +0200 (Wed, 28 Jun 2006)
New Revision: 318

Modified:
   trunk/apps/app_meetme.c
Log:
Update to Asterisk SVN trunk r33333

------------------------------------------------------------------------
r33328 | file | 2006-06-09 21:05:30 +0200 (Fri, 09 Jun 2006) | 2 lines

Don't double check existence of a variable (issue #7300 reported by foamdino)

------------------------------------------------------------------------


Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-06-27 22:55:25 UTC (rev 317)
+++ trunk/apps/app_meetme.c	2006-06-27 22:57:51 UTC (rev 318)
@@ -2388,12 +2388,12 @@
 	char *userid = astman_get_header(m, "Usernum");
 	int userno;
 
-	if (!confid || ast_strlen_zero(confid)) {
+	if (ast_strlen_zero(confid)) {
 		astman_send_error(s, m, "Meetme conference not specified");
 		return 0;
 	}
 
-	if (!userid || ast_strlen_zero(userid)) {
+	if (ast_strlen_zero(userid)) {
 		astman_send_error(s, m, "Meetme user number not specified");
 		return 0;
 	}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 01:08:33 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 01:08:33 +0200
Subject: [solid-pbx-svn] r319 - in trunk: . apps cdr channels codecs/gsm/src include include/asterisk pbx pbx/ael res
Message-ID: <200606272308.k5RN8XDm016165@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 01:07:52 +0200 (Wed, 28 Jun 2006)
New Revision: 319

Modified:
   trunk/abstract_jb.c
   trunk/apps/app_followme.c
   trunk/apps/app_voicemail.c
   trunk/asterisk.c
   trunk/cdr/cdr_csv.c
   trunk/cdr/cdr_custom.c
   trunk/cdr/cdr_radius.c
   trunk/channels/chan_sip.c
   trunk/codecs/gsm/src/preprocess.c
   trunk/include/asterisk.h
   trunk/include/asterisk/endian.h
   trunk/include/asterisk/rtp.h
   trunk/include/asterisk/stringfields.h
   trunk/logger.c
   trunk/pbx/Makefile
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael_lex.c
   trunk/plc.c
   trunk/res/res_musiconhold.c
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r33353

------------------------------------------------------------------------
r33348 | oej | 2006-06-09 22:09:55 +0200 (Fri, 09 Jun 2006) | 2 lines

Another try at hanging up the transferer channel after the masq

------------------------------------------------------------------------
r33349 | oej | 2006-06-09 22:13:47 +0200 (Fri, 09 Jun 2006) | 2 lines

Move payloadtype back home to rtp.c 

------------------------------------------------------------------------
r33350 | kpfleming | 2006-06-09 22:26:25 +0200 (Fri, 09 Jun 2006) | 2 lines

various minor portability fixes (mostly from tholo for OpenBSD)

------------------------------------------------------------------------
r33351 | kpfleming | 2006-06-09 22:40:10 +0200 (Fri, 09 Jun 2006) | 2 lines

there is no reason to define our own 'maximum path length' when the POSIX headers already define one for us

------------------------------------------------------------------------


Modified: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/abstract_jb.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -32,7 +32,6 @@
 
 #include <stdio.h>
 #include <stdlib.h>
-#include <limits.h>
 
 #include "asterisk/frame.h"
 #include "asterisk/channel.h"

Modified: trunk/apps/app_followme.c
===================================================================
--- trunk/apps/app_followme.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/apps/app_followme.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -92,12 +92,12 @@
 	unsigned int active;		/*!< Profile is active (1), or disabled (0). */
 	char takecall[20];		/*!< Digit mapping to take a call */
 	char nextindp[20];		/*!< Digit mapping to decline a call */
-	char callfromprompt[AST_CONFIG_MAX_PATH];
-	char norecordingprompt[AST_CONFIG_MAX_PATH];
-	char optionsprompt[AST_CONFIG_MAX_PATH];
-	char plsholdprompt[AST_CONFIG_MAX_PATH];
-	char statusprompt[AST_CONFIG_MAX_PATH];
-	char sorryprompt[AST_CONFIG_MAX_PATH];
+	char callfromprompt[PATH_MAX];
+	char norecordingprompt[PATH_MAX];
+	char optionsprompt[PATH_MAX];
+	char plsholdprompt[PATH_MAX];
+	char statusprompt[PATH_MAX];
+	char sorryprompt[PATH_MAX];
 
 	AST_LIST_HEAD_NOLOCK(numbers, number) numbers;	   /*!< Head of the list of follow-me numbers */
 	AST_LIST_HEAD_NOLOCK(blnumbers, number) blnumbers; /*!< Head of the list of black-listed numbers */
@@ -115,12 +115,12 @@
 	struct ast_channel *outbound;
 	char takecall[20];		/*!< Digit mapping to take a call */
 	char nextindp[20];		/*!< Digit mapping to decline a call */
-	char callfromprompt[AST_CONFIG_MAX_PATH];
-	char norecordingprompt[AST_CONFIG_MAX_PATH];
-	char optionsprompt[AST_CONFIG_MAX_PATH];
-	char plsholdprompt[AST_CONFIG_MAX_PATH];
-	char statusprompt[AST_CONFIG_MAX_PATH];
-	char sorryprompt[AST_CONFIG_MAX_PATH];
+	char callfromprompt[PATH_MAX];
+	char norecordingprompt[PATH_MAX];
+	char optionsprompt[PATH_MAX];
+	char plsholdprompt[PATH_MAX];
+	char statusprompt[PATH_MAX];
+	char sorryprompt[PATH_MAX];
 	struct ast_flags followmeflags;
 };
 
@@ -156,12 +156,12 @@
 static const char *defaultmoh = "default";    	/*!< Default Music-On-Hold Class */
 
 static char takecall[20] = "1", nextindp[20] = "2";
-static char callfromprompt[AST_CONFIG_MAX_PATH] = "followme/call-from";
-static char norecordingprompt[AST_CONFIG_MAX_PATH] = "followme/no-recording";
-static char optionsprompt[AST_CONFIG_MAX_PATH] = "followme/followme-options";
-static char plsholdprompt[AST_CONFIG_MAX_PATH] = "followme/pls-hold-while-try";
-static char statusprompt[AST_CONFIG_MAX_PATH] = "followme/followme-status";
-static char sorryprompt[AST_CONFIG_MAX_PATH] = "followme/followme-sorry";
+static char callfromprompt[PATH_MAX] = "followme/call-from";
+static char norecordingprompt[PATH_MAX] = "followme/no-recording";
+static char optionsprompt[PATH_MAX] = "followme/followme-options";
+static char plsholdprompt[PATH_MAX] = "followme/pls-hold-while-try";
+static char statusprompt[PATH_MAX] = "followme/followme-status";
+static char sorryprompt[PATH_MAX] = "followme/followme-sorry";
 
 
 static AST_LIST_HEAD_STATIC(followmes, ast_call_followme);

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/apps/app_voicemail.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -313,7 +313,7 @@
 #define DELETE(a,b,c) (vm_delete(c))
 #endif
 
-static char VM_SPOOL_DIR[AST_CONFIG_MAX_PATH];
+static char VM_SPOOL_DIR[PATH_MAX];
 
 static char ext_pass_cmd[128];
 
@@ -655,8 +655,8 @@
 	char inbuf[256];
 	char orig[256];
 	char currcontext[256] ="";
-	char tmpin[AST_CONFIG_MAX_PATH];
-	char tmpout[AST_CONFIG_MAX_PATH];
+	char tmpin[PATH_MAX];
+	char tmpout[PATH_MAX];
 	struct stat statbuf;
 
 	if (!change_password_realtime(vmu, newpassword))

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/asterisk.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -203,26 +203,26 @@
 static int ast_el_read_history(char *);
 static int ast_el_write_history(char *);
 
-char ast_config_AST_CONFIG_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_CONFIG_FILE[AST_CONFIG_MAX_PATH];
-char ast_config_AST_MODULE_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_SPOOL_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_MONITOR_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_VAR_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_DATA_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_LOG_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_AGI_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_DB[AST_CONFIG_MAX_PATH];
-char ast_config_AST_KEY_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
-char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
-char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_RUN_USER[AST_CONFIG_MAX_PATH];
-char ast_config_AST_RUN_GROUP[AST_CONFIG_MAX_PATH];
-char ast_config_AST_CTL_PERMISSIONS[AST_CONFIG_MAX_PATH];
-char ast_config_AST_CTL_OWNER[AST_CONFIG_MAX_PATH] = "\0";
-char ast_config_AST_CTL_GROUP[AST_CONFIG_MAX_PATH] = "\0";
-char ast_config_AST_CTL[AST_CONFIG_MAX_PATH] = "asterisk.ctl";
+char ast_config_AST_CONFIG_DIR[PATH_MAX];
+char ast_config_AST_CONFIG_FILE[PATH_MAX];
+char ast_config_AST_MODULE_DIR[PATH_MAX];
+char ast_config_AST_SPOOL_DIR[PATH_MAX];
+char ast_config_AST_MONITOR_DIR[PATH_MAX];
+char ast_config_AST_VAR_DIR[PATH_MAX];
+char ast_config_AST_DATA_DIR[PATH_MAX];
+char ast_config_AST_LOG_DIR[PATH_MAX];
+char ast_config_AST_AGI_DIR[PATH_MAX];
+char ast_config_AST_DB[PATH_MAX];
+char ast_config_AST_KEY_DIR[PATH_MAX];
+char ast_config_AST_PID[PATH_MAX];
+char ast_config_AST_SOCKET[PATH_MAX];
+char ast_config_AST_RUN_DIR[PATH_MAX];
+char ast_config_AST_RUN_USER[PATH_MAX];
+char ast_config_AST_RUN_GROUP[PATH_MAX];
+char ast_config_AST_CTL_PERMISSIONS[PATH_MAX];
+char ast_config_AST_CTL_OWNER[PATH_MAX] = "\0";
+char ast_config_AST_CTL_GROUP[PATH_MAX] = "\0";
+char ast_config_AST_CTL[PATH_MAX] = "asterisk.ctl";
 char ast_config_AST_SYSTEM_NAME[20] = "";
 
 extern const char *ast_build_hostname;
@@ -661,7 +661,7 @@
 		/* Close file descriptors and launch system command */
 		for (x = STDERR_FILENO + 1; x < 4096; x++)
 			close(x);
-		execl("/bin/sh", "/bin/sh", "-c", s, NULL);
+		execl("/bin/sh", "/bin/sh", "-c", s, (char *) NULL);
 		exit(1);
 	} else if (pid > 0) {
 		for(;;) {

Modified: trunk/cdr/cdr_csv.c
===================================================================
--- trunk/cdr/cdr_csv.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/cdr/cdr_csv.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -265,7 +265,7 @@
 
 static int writefile(char *s, char *acc)
 {
-	char tmp[AST_CONFIG_MAX_PATH];
+	char tmp[PATH_MAX];
 	FILE *f;
 	if (strchr(acc, '/') || (acc[0] == '.')) {
 		ast_log(LOG_WARNING, "Account code '%s' insecure for writing file\n", acc);
@@ -286,7 +286,7 @@
 {
 	/* Make sure we have a big enough buf */
 	char buf[1024];
-	char csvmaster[AST_CONFIG_MAX_PATH];
+	char csvmaster[PATH_MAX];
 	snprintf(csvmaster, sizeof(csvmaster),"%s/%s/%s", ast_config_AST_LOG_DIR, CSV_LOG_DIR, CSV_MASTER);
 #if 0
 	printf("[CDR] %s ('%s' -> '%s') Dur: %ds Bill: %ds Disp: %s Flags: %s Account: [%s]\n", cdr->channel, cdr->src, cdr->dst, cdr->duration, cdr->billsec, ast_cdr_disp2str(cdr->disposition), ast_cdr_flags2str(cdr->amaflags), cdr->accountcode);

Modified: trunk/cdr/cdr_custom.c
===================================================================
--- trunk/cdr/cdr_custom.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/cdr/cdr_custom.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -67,7 +67,7 @@
 
 static FILE *mf = NULL;
 
-static char master[AST_CONFIG_MAX_PATH];
+static char master[PATH_MAX];
 static char format[1024]="";
 
 static int load_config(int reload) 

Modified: trunk/cdr/cdr_radius.c
===================================================================
--- trunk/cdr/cdr_radius.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/cdr/cdr_radius.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -88,7 +88,7 @@
 static char *name = "radius";
 static char *cdr_config = "cdr.conf";
 
-static char radiuscfg[AST_CONFIG_MAX_PATH] = "/etc/radiusclient-ng/radiusclient.conf";
+static char radiuscfg[PATH_MAX] = "/etc/radiusclient-ng/radiusclient.conf";
 
 static struct ast_flags global_flags = { RADIUS_FLAG_USEGMTIME | RADIUS_FLAG_LOGUNIQUEID | RADIUS_FLAG_LOGUSERFIELD };
 

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/channels/chan_sip.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -1708,6 +1708,8 @@
 	if (p->owner) {
 		ast_log(LOG_WARNING, "Autodestruct on dialog '%s' with owner in place (Method: %s)\n", p->callid, sip_methods[p->method].text);
 		ast_queue_hangup(p->owner);
+	} else if (p->refer) {
+		transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
 	} else {
 		sip_destroy(p);
 	}
@@ -2882,12 +2884,13 @@
 
 	if (ast_test_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER)) {
 		if (option_debug >3)
-			ast_log(LOG_DEBUG, "SIP Transfer: Not hanging up right now... Rescheduling hangup.\n");
+			ast_log(LOG_DEBUG, "SIP Transfer: Not hanging up right now... Rescheduling hangup for %s.\n", p->callid);
 		if (p->autokillid > -1)
 			sip_cancel_destroy(p);
 		sip_scheddestroy(p, 32000);
 		ast_clear_flag(&p->flags[0], SIP_DEFER_BYE_ON_TRANSFER);	/* Really hang up next time */
 		ast_clear_flag(&p->flags[0], SIP_NEEDDESTROY);
+		p->owner->tech_pvt = NULL;
 		p->owner = NULL;  /* Owner will be gone after we return, so take it away */
 		return 0;
 	}
@@ -3105,7 +3108,7 @@
 
 	ast_mutex_lock(&p->lock);
 	append_history(p, "Masq", "Old channel: %s\n", oldchan->name);
-	append_history(p, "Masq (cont)", "...new owner: %s\n", p->owner->name);
+	append_history(p, "Masq (cont)", "...new owner: %s\n", newchan->name);
 	if (p->owner != oldchan)
 		ast_log(LOG_WARNING, "old channel wasn't %p but was %p\n", oldchan, p->owner);
 	else {
@@ -3114,16 +3117,6 @@
 	}
 	if (option_debug > 2)
 		ast_log(LOG_DEBUG, "SIP Fixup: New owner for dialogue %s: %s (Old parent: %s)\n", p->callid, p->owner->name, oldchan->name);
-	if (p->refer) {
-		if (option_debug > 2) {
-			if (oldchan->tech_pvt) {
-				struct sip_pvt *old = oldchan->tech_pvt;
-				ast_log(LOG_DEBUG, "Releasing connection between %s and pvt %s\n", oldchan->name, old->callid);
-			} else
-				ast_log(LOG_DEBUG, "Hmmm. No sip_pvt to release for %s\n", oldchan->name);
-		}
-		oldchan->tech_pvt = NULL;	/* Release connection between old channel and it's pvt so we can hang up in peace */
-	}
 
 	ast_mutex_unlock(&p->lock);
 	return ret;
@@ -10868,15 +10861,17 @@
 				/* They got the notify, this is the end */
 				if (p->owner) {
 					if (!p->refer) {
-						ast_log(LOG_WARNING, "Notify answer on an owned channel?\n");
+						ast_log(LOG_WARNING, "Notify answer on an owned channel? - %s\n", p->owner->name);
 						ast_queue_hangup(p->owner);
 					}
 				} else {
 					if (p->subscribed == NONE) 
 						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY); 
 				}
-			} else if (sipmethod == SIP_REGISTER)
+			} else if (sipmethod == SIP_REGISTER) 
 				res = handle_response_register(p, resp, rest, req, ignore, seqno);
+			else if (sipmethod == SIP_BYE)
+				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY); 
 			break;
 		case 202:   /* Transfer accepted */
 			if (sipmethod == SIP_REFER) 
@@ -11071,7 +11066,7 @@
 		if (ast_test_flag(req, SIP_PKT_DEBUG))
 			ast_verbose("SIP Response message for INCOMING dialog %s arrived\n", msg);
 
-		if (resp == 200) {
+		if (sipmethod == SIP_INVITE && resp == 200) {
 			/* Tags in early session is replaced by the tag in 200 OK, which is 
 		  	the final reply to our INVITE */
 			char tag[128];
@@ -11091,14 +11086,16 @@
 				/* They got the notify, this is the end */
 				if (p->owner) {
 					ast_log(LOG_WARNING, "Notify answer on an owned channel?\n");
-					ast_queue_hangup(p->owner);
+					//ast_queue_hangup(p->owner);
 				} else {
-					if (!p->subscribed)
+					if (!p->subscribed && !p->refer)
 						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 				}
-				/* Wait for 487, then destroy */
-			} else if (sipmethod == SIP_MESSAGE)
+			} else if (sipmethod == SIP_BYE)
+				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
+			else if (sipmethod == SIP_MESSAGE)
 				/* We successfully transmitted a message */
+				/* XXX Why destroy this pvt after message transfer? Bad */
 				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 			break;
 		case 202:   /* Transfer accepted */
@@ -11126,6 +11123,8 @@
 			if (sipmethod == SIP_INVITE) {
 				/* Re-invite failed */
 				handle_response_invite(p, resp, rest, req, seqno);
+			} else if (sipmethod == SIP_BYE) {
+				ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 			} else if (sipdebug) {
 				ast_log	(LOG_DEBUG, "Remote host can't match request %s to call '%s'. Giving up\n", sip_methods[sipmethod].text, p->callid);
 			}

Modified: trunk/codecs/gsm/src/preprocess.c
===================================================================
--- trunk/codecs/gsm/src/preprocess.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/codecs/gsm/src/preprocess.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -36,20 +36,14 @@
 	word		 * s,
 	word 		 * so )		/* [0..159] 	IN/OUT	*/
 {
-
-	word       z1 = S->z1;
-	longword L_z2 = S->L_z2;
-	word 	   mp = S->mp;
-
+	word       	z1 = S->z1;
+	longword 	L_z2 = S->L_z2;
+	word 	   	mp = S->mp;
 	word 	   	s1;
-
-
 	word		SO;
-
 	ulongword	utmp;		/* for L_ADD */
+	register int	k = 160;
 
-	register int		k = 160;
-
 	while (k--) {
 
 	/*  4.2.1   Downscaling of the input signal

Modified: trunk/include/asterisk/endian.h
===================================================================
--- trunk/include/asterisk/endian.h	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/include/asterisk/endian.h	2006-06-27 23:07:52 UTC (rev 319)
@@ -33,9 +33,6 @@
 #ifdef __linux__
 #include <endian.h>
 #elif defined(__OpenBSD__) || defined(__FreeBSD__) || defined(__NetBSD__) || defined(__APPLE__)
-#if defined(__OpenBSD__)
-#include <machine/types.h>
-#endif /* __OpenBSD__ */
 #include <machine/endian.h>
 #define __BYTE_ORDER BYTE_ORDER
 #define __LITTLE_ENDIAN LITTLE_ENDIAN

Modified: trunk/include/asterisk/rtp.h
===================================================================
--- trunk/include/asterisk/rtp.h	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/include/asterisk/rtp.h	2006-06-27 23:07:52 UTC (rev 319)
@@ -67,20 +67,7 @@
 
 typedef int (*ast_rtp_callback)(struct ast_rtp *rtp, struct ast_frame *f, void *data);
 
-
 /*!
- * \brief Structure representing a RTP session.
- *
- * RTP session is defined on page 9 of RFC 3550: "An association among a set of participants communicating with RTP.  A participant may be involved in multiple RTP sessions at the same time [...]"
- *
- */
-/*! \brief The value of each payload format mapping: */
-struct rtpPayloadType {
-	int isAstFormat; 	/*!< whether the following code is an AST_FORMAT */
-	int code;
-};
-
-/*!
  * \brief Get the amount of space required to hold an RTP session
  * \return number of bytes required
  */

Modified: trunk/include/asterisk/stringfields.h
===================================================================
--- trunk/include/asterisk/stringfields.h	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/include/asterisk/stringfields.h	2006-06-27 23:07:52 UTC (rev 319)
@@ -171,7 +171,7 @@
   \brief Declare a string field
   \param name The field name
 */
-#define AST_STRING_FIELD(name) const ast_string_field name;
+#define AST_STRING_FIELD(name) const ast_string_field name
 
 /*!
   \brief Declare the fields needed in a structure
@@ -181,7 +181,7 @@
 	ast_string_field __begin_field[0]; \
 	field_list \
 	ast_string_field __end_field[0]; \
-	struct ast_string_field_mgr __field_mgr;
+	struct ast_string_field_mgr __field_mgr
 
 /*!
   \brief Get the number of string fields in a structure

Modified: trunk/include/asterisk.h
===================================================================
--- trunk/include/asterisk.h	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/include/asterisk.h	2006-06-27 23:07:52 UTC (rev 319)
@@ -22,32 +22,32 @@
 
 #include "asterisk/compat.h"
 
+#include <limits.h>
+
 #define DEFAULT_LANGUAGE "en"
 
 #define DEFAULT_SAMPLE_RATE 8000
 #define DEFAULT_SAMPLES_PER_MS  ((DEFAULT_SAMPLE_RATE)/1000)
 
-#define AST_CONFIG_MAX_PATH 255
-
 /* provided in asterisk.c */
-extern char ast_config_AST_CONFIG_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_CONFIG_FILE[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_MODULE_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_SPOOL_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_MONITOR_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_VAR_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_DATA_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_LOG_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_AGI_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_DB[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_KEY_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_PID[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_SOCKET[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_RUN_DIR[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_CTL_PERMISSIONS[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_CTL_OWNER[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_CTL_GROUP[AST_CONFIG_MAX_PATH];
-extern char ast_config_AST_CTL[AST_CONFIG_MAX_PATH];
+extern char ast_config_AST_CONFIG_DIR[PATH_MAX];
+extern char ast_config_AST_CONFIG_FILE[PATH_MAX];
+extern char ast_config_AST_MODULE_DIR[PATH_MAX];
+extern char ast_config_AST_SPOOL_DIR[PATH_MAX];
+extern char ast_config_AST_MONITOR_DIR[PATH_MAX];
+extern char ast_config_AST_VAR_DIR[PATH_MAX];
+extern char ast_config_AST_DATA_DIR[PATH_MAX];
+extern char ast_config_AST_LOG_DIR[PATH_MAX];
+extern char ast_config_AST_AGI_DIR[PATH_MAX];
+extern char ast_config_AST_DB[PATH_MAX];
+extern char ast_config_AST_KEY_DIR[PATH_MAX];
+extern char ast_config_AST_PID[PATH_MAX];
+extern char ast_config_AST_SOCKET[PATH_MAX];
+extern char ast_config_AST_RUN_DIR[PATH_MAX];
+extern char ast_config_AST_CTL_PERMISSIONS[PATH_MAX];
+extern char ast_config_AST_CTL_OWNER[PATH_MAX];
+extern char ast_config_AST_CTL_GROUP[PATH_MAX];
+extern char ast_config_AST_CTL[PATH_MAX];
 extern char ast_config_AST_SYSTEM_NAME[20];
 
 int ast_set_priority(int);			/*!< Provided by asterisk.c */

Modified: trunk/logger.c
===================================================================
--- trunk/logger.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/logger.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -382,8 +382,8 @@
 
 int reload_logger(int rotate)
 {
-	char old[AST_CONFIG_MAX_PATH] = "";
-	char new[AST_CONFIG_MAX_PATH];
+	char old[PATH_MAX] = "";
+	char new[PATH_MAX];
 	int event_rotate = rotate, queue_rotate = rotate;
 	struct logchannel *f;
 	FILE *myf;

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/pbx/Makefile	2006-06-27 23:07:52 UTC (rev 319)
@@ -65,7 +65,7 @@
 	$(CC) $(CFLAGS) -I. -c -o ael/aelbison.o ael/ael.tab.c
 
 ael/ael_lex.c:
-	(cd ael; flex ael.flex)
+	(cd ael; flex ael.flex; sed -i -e "/begin standard C headers/i#include \"asterisk.h\"" ael_lex.c)
 
 ael/ael.tab.c ael/ael.tab.h:
 	(cd ael; bison -v -d ael.y)

Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/pbx/ael/ael.flex	2006-06-27 23:07:52 UTC (rev 319)
@@ -56,8 +56,6 @@
 %option bison-locations
 
 %{
-#include "asterisk.h"
-
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
 #include <sys/types.h>
@@ -65,6 +63,7 @@
 #include <unistd.h>
 
 #include "asterisk/logger.h"
+#include "asterisk/utils.h"
 #include "ael/ael.tab.h"
 #include "asterisk/ael_structs.h"
 
@@ -402,13 +401,10 @@
 		if ( !error ) {	/* valid file name */
 			*p2 = 0;
 			/* relative vs. absolute */
-			if ( *(p1+1) != '/' ) {
-				/* XXX must check overflows */
-				strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
-				strcat(fnamebuf,"/");
-				strcat(fnamebuf,p1+1);
-			} else
-				strcpy(fnamebuf,p1+1);
+			if (*(p1+1) != '/')
+				snprintf(fnamebuf, sizeof(fnamebuf), "%s/%s", ast_config_AST_CONFIG_DIR, p1 + 1);
+			else
+				ast_copy_string(fnamebuf, p1 + 1, sizeof(fnamebuf));
 			in1 = fopen( fnamebuf, "r" );
 			if ( ! in1 ) {
 				ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/pbx/ael/ael_lex.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -16,6 +16,7 @@
 
 /* First, we deal with  platform-specific or compiler-specific issues. */
 
+#include "asterisk.h"
 /* begin standard C headers. */
 #include <stdio.h>
 #include <string.h>
@@ -672,8 +673,6 @@
  * bison-locations is probably not needed.
  */
 #line 59 "ael.flex"
-#include "asterisk.h"
-
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
 #include <sys/types.h>
@@ -681,6 +680,7 @@
 #include <unistd.h>
 
 #include "asterisk/logger.h"
+#include "asterisk/utils.h"
 #include "ael/ael.tab.h"
 #include "asterisk/ael_structs.h"
 
@@ -778,7 +778,7 @@
 #define	STORE_POS
 #define	STORE_LOC
 #endif
-#line 779 "ael_lex.c"
+#line 781 "ael_lex.c"
 
 #define INITIAL 0
 #define paren 1
@@ -1018,10 +1018,10 @@
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 171 "ael.flex"
+#line 173 "ael.flex"
 
 
-#line 1022 "ael_lex.c"
+#line 1024 "ael_lex.c"
 
     yylval = yylval_param;
 
@@ -1112,218 +1112,218 @@
 
 case 1:
 YY_RULE_SETUP
-#line 173 "ael.flex"
+#line 175 "ael.flex"
 { STORE_POS; return LC;}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 174 "ael.flex"
+#line 176 "ael.flex"
 { STORE_POS; return RC;}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 175 "ael.flex"
+#line 177 "ael.flex"
 { STORE_POS; return LP;}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 176 "ael.flex"
+#line 178 "ael.flex"
 { STORE_POS; return RP;}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 177 "ael.flex"
+#line 179 "ael.flex"
 { STORE_POS; return SEMI;}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 178 "ael.flex"
+#line 180 "ael.flex"
 { STORE_POS; return EQ;}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 179 "ael.flex"
+#line 181 "ael.flex"
 { STORE_POS; return COMMA;}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 180 "ael.flex"
+#line 182 "ael.flex"
 { STORE_POS; return COLON;}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 181 "ael.flex"
+#line 183 "ael.flex"
 { STORE_POS; return AMPER;}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 182 "ael.flex"
+#line 184 "ael.flex"
 { STORE_POS; return BAR;}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 183 "ael.flex"
+#line 185 "ael.flex"
 { STORE_POS; return EXTENMARK;}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 184 "ael.flex"
+#line 186 "ael.flex"
 { STORE_POS; return AT;}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 185 "ael.flex"
+#line 187 "ael.flex"
 {/*comment*/}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 186 "ael.flex"
+#line 188 "ael.flex"
 { STORE_POS; return KW_CONTEXT;}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 187 "ael.flex"
+#line 189 "ael.flex"
 { STORE_POS; return KW_ABSTRACT;}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 188 "ael.flex"
+#line 190 "ael.flex"
 { STORE_POS; return KW_MACRO;};
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 189 "ael.flex"
+#line 191 "ael.flex"
 { STORE_POS; return KW_GLOBALS;}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 190 "ael.flex"
+#line 192 "ael.flex"
 { STORE_POS; return KW_IGNOREPAT;}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 191 "ael.flex"
+#line 193 "ael.flex"
 { STORE_POS; return KW_SWITCH;}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 192 "ael.flex"
+#line 194 "ael.flex"
 { STORE_POS; return KW_IF;}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 193 "ael.flex"
+#line 195 "ael.flex"
 { STORE_POS; return KW_IFTIME;}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 194 "ael.flex"
+#line 196 "ael.flex"
 { STORE_POS; return KW_RANDOM;}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 195 "ael.flex"
+#line 197 "ael.flex"
 { STORE_POS; return KW_REGEXTEN;}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 196 "ael.flex"
+#line 198 "ael.flex"
 { STORE_POS; return KW_HINT;}
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 197 "ael.flex"
+#line 199 "ael.flex"
 { STORE_POS; return KW_ELSE;}
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
-#line 198 "ael.flex"
+#line 200 "ael.flex"
 { STORE_POS; return KW_GOTO;}
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
-#line 199 "ael.flex"
+#line 201 "ael.flex"
 { STORE_POS; return KW_JUMP;}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 200 "ael.flex"
+#line 202 "ael.flex"
 { STORE_POS; return KW_RETURN;}
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 201 "ael.flex"
+#line 203 "ael.flex"
 { STORE_POS; return KW_BREAK;}
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
-#line 202 "ael.flex"
+#line 204 "ael.flex"
 { STORE_POS; return KW_CONTINUE;}
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
-#line 203 "ael.flex"
+#line 205 "ael.flex"
 { STORE_POS; return KW_FOR;}
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 204 "ael.flex"
+#line 206 "ael.flex"
 { STORE_POS; return KW_WHILE;}
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
-#line 205 "ael.flex"
+#line 207 "ael.flex"
 { STORE_POS; return KW_CASE;}
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 206 "ael.flex"
+#line 208 "ael.flex"
 { STORE_POS; return KW_DEFAULT;}
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 207 "ael.flex"
+#line 209 "ael.flex"
 { STORE_POS; return KW_PATTERN;}
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
-#line 208 "ael.flex"
+#line 210 "ael.flex"
 { STORE_POS; return KW_CATCH;}
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
-#line 209 "ael.flex"
+#line 211 "ael.flex"
 { STORE_POS; return KW_SWITCHES;}
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
-#line 210 "ael.flex"
+#line 212 "ael.flex"
 { STORE_POS; return KW_ESWITCHES;}
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
-#line 211 "ael.flex"
+#line 213 "ael.flex"
 { STORE_POS; return KW_INCLUDES;}
 	YY_BREAK
 case 40:
 /* rule 40 can match eol */
 YY_RULE_SETUP
-#line 213 "ael.flex"
+#line 215 "ael.flex"
 { my_lineno++; my_col = 1; }
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 214 "ael.flex"
+#line 216 "ael.flex"
 { my_col += yyleng; }
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 215 "ael.flex"
+#line 217 "ael.flex"
 { my_col += (yyleng*8)-(my_col%8); }
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
-#line 217 "ael.flex"
+#line 219 "ael.flex"
 {
 		STORE_POS;
 		yylval->str = strdup(yytext);
@@ -1341,7 +1341,7 @@
 case 44:
 /* rule 44 can match eol */
 YY_RULE_SETUP
-#line 233 "ael.flex"
+#line 235 "ael.flex"
 {
 		if ( pbcpop(')') ) {	/* error */
 			STORE_LOC;
@@ -1367,7 +1367,7 @@
 case 45:
 /* rule 45 can match eol */
 YY_RULE_SETUP
-#line 255 "ael.flex"
+#line 257 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if (c == '(')
@@ -1379,7 +1379,7 @@
 case 46:
 /* rule 46 can match eol */
 YY_RULE_SETUP
-#line 263 "ael.flex"
+#line 265 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c))  { /* error */
@@ -1404,7 +1404,7 @@
 case 47:
 /* rule 47 can match eol */
 YY_RULE_SETUP
-#line 285 "ael.flex"
+#line 287 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if (c == '(')
@@ -1416,7 +1416,7 @@
 case 48:
 /* rule 48 can match eol */
 YY_RULE_SETUP
-#line 293 "ael.flex"
+#line 295 "ael.flex"
 {
 		if ( pbcpop(')') ) { /* error */
 			STORE_LOC;
@@ -1444,7 +1444,7 @@
 case 49:
 /* rule 49 can match eol */
 YY_RULE_SETUP
-#line 317 "ael.flex"
+#line 319 "ael.flex"
 {
 		if( parencount != 0) { /* printf("Folding in a comma!\n"); */
 			yymore();
@@ -1462,7 +1462,7 @@
 case 50:
 /* rule 50 can match eol */
 YY_RULE_SETUP
-#line 331 "ael.flex"
+#line 333 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c) ) { /* error */
@@ -1483,7 +1483,7 @@
 case 51:
 /* rule 51 can match eol */
 YY_RULE_SETUP
-#line 348 "ael.flex"
+#line 350 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		yymore();
@@ -1493,7 +1493,7 @@
 case 52:
 /* rule 52 can match eol */
 YY_RULE_SETUP
-#line 354 "ael.flex"
+#line 356 "ael.flex"
 {
 		char c = yytext[yyleng-1];
 		if ( pbcpop(c) ) { /* error */
@@ -1509,7 +1509,7 @@
 case 53:
 /* rule 53 can match eol */
 YY_RULE_SETUP
-#line 366 "ael.flex"
+#line 368 "ael.flex"
 {
 		STORE_LOC;
 		yylval->str = strdup(yytext);
@@ -1522,7 +1522,7 @@
 case 54:
 /* rule 54 can match eol */
 YY_RULE_SETUP
-#line 375 "ael.flex"
+#line 377 "ael.flex"
 {
 		FILE *in1;
 		char fnamebuf[1024],*p1,*p2;
@@ -1550,13 +1550,10 @@
 		if ( !error ) {	/* valid file name */
 			*p2 = 0;
 			/* relative vs. absolute */
-			if ( *(p1+1) != '/' ) {
-				/* XXX must check overflows */
-				strcpy(fnamebuf,ast_config_AST_CONFIG_DIR);
-				strcat(fnamebuf,"/");
-				strcat(fnamebuf,p1+1);
-			} else
-				strcpy(fnamebuf,p1+1);
+			if (*(p1+1) != '/')
+				snprintf(fnamebuf, sizeof(fnamebuf), "%s/%s", ast_config_AST_CONFIG_DIR, p1 + 1);
+			else
+				ast_copy_string(fnamebuf, p1 + 1, sizeof(fnamebuf));
 			in1 = fopen( fnamebuf, "r" );
 			if ( ! in1 ) {
 				ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);
@@ -1589,7 +1586,7 @@
 case YY_STATE_EOF(paren):
 case YY_STATE_EOF(semic):
 case YY_STATE_EOF(argg):
-#line 437 "ael.flex"
+#line 436 "ael.flex"
 {
 		if ( --include_stack_index < 0 ) {
 			yyterminate();
@@ -1605,10 +1602,10 @@
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 450 "ael.flex"
+#line 449 "ael.flex"
 ECHO;
 	YY_BREAK
-#line 1609 "ael_lex.c"
+#line 1608 "ael_lex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -2738,7 +2735,7 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 450 "ael.flex"
+#line 449 "ael.flex"
 
 
 

Modified: trunk/plc.c
===================================================================
--- trunk/plc.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/plc.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -33,7 +33,6 @@
 #include <stdlib.h>
 #include <string.h>
 #include <math.h>
-#include <limits.h>
 
 #include "asterisk.h"
 

Modified: trunk/res/res_musiconhold.c
===================================================================
--- trunk/res/res_musiconhold.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/res/res_musiconhold.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -756,7 +756,7 @@
 
 	DIR *files_DIR;
 	struct dirent *files_dirent;
-	char path[512];
+	char path[PATH_MAX];
 	char filepath[PATH_MAX];
 	char *ext;
 	struct stat statbuf;
@@ -774,7 +774,7 @@
 
 	class->total_files = 0;
 	dirnamelen = strlen(class->dir) + 2;
-	getcwd(path, 512);
+	getcwd(path, sizeof(path));
 	chdir(class->dir);
 	while ((files_dirent = readdir(files_DIR))) {
 		/* The file name must be at least long enough to have the file type extension */

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-27 22:57:51 UTC (rev 318)
+++ trunk/rtp.c	2006-06-27 23:07:52 UTC (rev 319)
@@ -94,6 +94,19 @@
 static int nochecksums = 0;
 #endif
 
+/*!
+ * \brief Structure representing a RTP session.
+ *
+ * RTP session is defined on page 9 of RFC 3550: "An association among a set of participants communicating with RTP.  A participant may be involved in multiple RTP sessions at the same time [...]"
+ *
+ */
+/*! \brief The value of each payload format mapping: */
+struct rtpPayloadType {
+	int isAstFormat; 	/*!< whether the following code is an AST_FORMAT */
+	int code;
+};
+
+
 /*! \brief RTP session description */
 struct ast_rtp {
 	int s;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 01:10:58 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 01:10:58 +0200
Subject: [solid-pbx-svn] r320 - in trunk: . channels
Message-ID: <200606272310.k5RNAwMS016598@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 01:10:55 +0200 (Wed, 28 Jun 2006)
New Revision: 320

Modified:
   trunk/channels/chan_sip.c
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r33373

------------------------------------------------------------------------
r33371 | oej | 2006-06-09 23:09:42 +0200 (Fri, 09 Jun 2006) | 3 lines

- RTP debug message formatting
- Add rtcp report to SIP history

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-27 23:07:52 UTC (rev 319)
+++ trunk/channels/chan_sip.c	2006-06-27 23:10:55 UTC (rev 320)
@@ -2972,6 +2972,14 @@
 			if (!p->pendinginvite) {
 				/* Send a hangup */
 				transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
+
+				/* Get RTCP quality before end of call */
+				if (recordhistory) {
+					if (p->rtp)
+						append_history(p, "RTCPaudio", "Quality:%s", ast_rtp_get_quality(p->rtp));
+					if (p->vrtp)
+						append_history(p, "RTCPvideo", "Quality:%s", ast_rtp_get_quality(p->vrtp));
+				}
 			} else {
 				/* Note we will need a BYE when this all settles out
 				   but we can't send one while we have "INVITE" outstanding. */
@@ -3669,14 +3677,15 @@
 
 	if (intended_method != SIP_OPTIONS)	/* Peerpoke has it's own system */
 		p->timer_t1 = 500;	/* Default SIP retransmission timer T1 (RFC 3261) */
+
 	if (sin) {
 		p->sa = *sin;
 		if (ast_sip_ouraddrfor(&p->sa.sin_addr,&p->ourip))
 			p->ourip = __ourip;
-	} else {
+	} else
 		p->ourip = __ourip;
-	}
-	
+
+	/* Copy global flags to this PVT at setup. */
 	ast_copy_flags(&p->flags[0], &global_flags[0], SIP_FLAGS_TO_COPY);
 	ast_copy_flags(&p->flags[1], &global_flags[1], SIP_PAGE2_FLAGS_TO_COPY);
 
@@ -3686,6 +3695,7 @@
 
 	if (sip_methods[intended_method].need_rtp) {
 		p->rtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
+		/* If the global videosupport flag is on, we always create a RTP interface for video */
 		if (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT))
 			p->vrtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
 		if (!p->rtp || (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && !p->vrtp)) {
@@ -9555,7 +9565,7 @@
 		ast_log(LOG_DEBUG, "  * SIP Call\n");
 	if (dialog->history)
 		AST_LIST_TRAVERSE(dialog->history, hist, list)
-			ast_log(LOG_DEBUG, "  %d. %s\n", ++x, hist->event);
+			ast_log(LOG_DEBUG, "  %-3.3d. %s\n", ++x, hist->event);
 	if (!x)
 		ast_log(LOG_DEBUG, "Call '%s' has no history\n", dialog->callid);
 	ast_log(LOG_DEBUG, "\n---------- END SIP HISTORY for '%s' \n", dialog->callid);
@@ -12630,6 +12640,14 @@
 	copy_request(&p->initreq, req);
 	check_via(p, req);
 	ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
+
+	/* Get RTCP quality before end of call */
+	if (recordhistory) {
+		if (p->rtp)
+			append_history(p, "RTCPaudio", "Quality:%s", ast_rtp_get_quality(p->rtp));
+		if (p->vrtp)
+			append_history(p, "RTCPvideo", "Quality:%s", ast_rtp_get_quality(p->vrtp));
+	}
 	if (p->rtp) {
 		/* Immediately stop RTP */
 		ast_rtp_stop(p->rtp);
@@ -13704,6 +13722,8 @@
 
 	if (create_addr(p, host)) {
 		*cause = AST_CAUSE_UNREGISTERED;
+		if (option_debug > 2)
+			ast_log(LOG_DEBUG, "Cant create SIP call - target device not registred\n");
 		sip_destroy(p);
 		return NULL;
 	}

Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-27 23:07:52 UTC (rev 319)
+++ trunk/rtp.c	2006-06-27 23:10:55 UTC (rev 320)
@@ -432,7 +432,7 @@
 		attr = (struct stun_attr *)data;
 		if (ntohs(attr->len) > len) {
 			if (option_debug)
-				ast_log(LOG_DEBUG, "Inconsistant Attribute (length %d exceeds remaining msg len %zd)\n", ntohs(attr->len), len);
+				ast_log(LOG_DEBUG, "Inconsistent Attribute (length %d exceeds remaining msg len %zd)\n", ntohs(attr->len), len);
 			break;
 		}
 		if (stun_process_attr(&st, attr)) {
@@ -1067,7 +1067,7 @@
 		rtp->themssrc = ntohl(rtpheader[2]); /* Record their SSRC to put in future RR */
 	
 	if (rtp_debug_test_addr(&sin))
-		ast_verbose("Got  RTP packet from %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
+		ast_verbose("Got  RTP packet from    %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 			ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp,res - hdrlen);
 
 	rtpPT = ast_rtp_lookup_pt(rtp, payloadtype);
@@ -1090,7 +1090,7 @@
 				event_end >>= 24;
 				duration = ntohl(*((unsigned int *)(data)));
 				duration &= 0xFFFF;
-				ast_verbose("Got rfc2833 RTP packet from %s:%d (type %d, seq %d, ts %d, len %d, mark %d, event %08x, end %d, duration %d) \n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp, res - hdrlen, (mark?1:0), event, ((event_end & 0x80)?1:0), duration);
+				ast_verbose("Got  RTP RFC2833 from   %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u, mark %d, event %08x, end %d, duration %-5.5d) \n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port), payloadtype, seqno, timestamp, res - hdrlen, (mark?1:0), event, ((event_end & 0x80)?1:0), duration);
 			}
 			if (rtp->lasteventseqn <= seqno || rtp->resp == 0 || (rtp->lasteventseqn >= 65530 && seqno <= 6)) {
 				f = process_rfc2833(rtp, rtp->rawdata + AST_FRIENDLY_OFFSET + hdrlen, res - hdrlen, seqno);
@@ -2294,7 +2294,7 @@
 		}
 				
 		if (rtp_debug_test_addr(&rtp->them))
-			ast_verbose("Sent RTP packet to %s:%d (type %d, seq %u, ts %u, len %u)\n",
+			ast_verbose("Sent RTP packet to      %s:%d (type %-2.2d, seq %-6.6u, ts %-6.6u, len %-6.6u)\n",
 					ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->them.sin_addr), ntohs(rtp->them.sin_port), codec, rtp->seqno, rtp->lastts,res - hdrlen);
 	}
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 01:20:35 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 01:20:35 +0200
Subject: [solid-pbx-svn] r321 - in trunk: channels doc
Message-ID: <200606272320.k5RNKZee019361@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 01:20:12 +0200 (Wed, 28 Jun 2006)
New Revision: 321

Modified:
   trunk/channels/chan_sip.c
   trunk/doc/channelvariables.txt
Log:
Update to Asterisk SVN trunk r33383

------------------------------------------------------------------------
r33374 | oej | 2006-06-09 23:28:52 +0200 (Fri, 09 Jun 2006) | 2 lines

Store RTCP reports in channel variables and SIP history

------------------------------------------------------------------------
r33375 | oej | 2006-06-09 23:30:31 +0200 (Fri, 09 Jun 2006) | 3 lines

Add RTP QoS report variables to doc. Catch it in the "h" extension, store it in the CDR
or in a database or... whatever you want to.

------------------------------------------------------------------------
r33376 | oej | 2006-06-09 23:32:48 +0200 (Fri, 09 Jun 2006) | 2 lines

Issue #7325 - Parse string after URI decoding (casper)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-27 23:10:55 UTC (rev 320)
+++ trunk/channels/chan_sip.c	2006-06-27 23:20:12 UTC (rev 321)
@@ -2970,16 +2970,26 @@
 			}
 		} else {	/* Call is in UP state, send BYE */
 			if (!p->pendinginvite) {
+				char *audioqos = "";
+				char *videoqos = "";
+				if (p->rtp)
+					audioqos = ast_rtp_get_quality(p->rtp);
+				if (p->vrtp)
+					videoqos = ast_rtp_get_quality(p->vrtp);
 				/* Send a hangup */
 				transmit_request_with_auth(p, SIP_BYE, 0, XMIT_RELIABLE, 1);
 
 				/* Get RTCP quality before end of call */
 				if (recordhistory) {
 					if (p->rtp)
-						append_history(p, "RTCPaudio", "Quality:%s", ast_rtp_get_quality(p->rtp));
+						append_history(p, "RTCPaudio", "Quality:%s", audioqos);
 					if (p->vrtp)
-						append_history(p, "RTCPvideo", "Quality:%s", ast_rtp_get_quality(p->vrtp));
+						append_history(p, "RTCPvideo", "Quality:%s", videoqos);
 				}
+				if (p->rtp)
+					pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
+				if (p->vrtp)
+					pbx_builtin_setvar_helper(p->owner, "RTPVIDEOQOS", videoqos);
 			} else {
 				/* Note we will need a BYE when this all settles out
 				   but we can't send one while we have "INVITE" outstanding. */
@@ -7319,11 +7329,12 @@
 	/* Find the request URI */
 	if (req->rlPart2)
 		ast_copy_string(tmp, req->rlPart2, sizeof(tmp));
-	uri = get_in_brackets(tmp);
 	
 	if (pedanticsipchecking)
 		ast_uri_decode(tmp);
 
+	uri = get_in_brackets(tmp);
+
 	if (strncmp(uri, "sip:", 4)) {
 		ast_log(LOG_WARNING, "Huh?  Not a SIP header (%s)?\n", uri);
 		return -1;
@@ -12633,6 +12644,7 @@
 	int res;
 	struct ast_channel *bridged_to;
 	char iabuf[INET_ADDRSTRLEN];
+	char *audioqos = NULL, *videoqos = NULL;
 	
 	if (p->pendinginvite && !ast_test_flag(&p->flags[0], SIP_OUTGOING) && !ast_test_flag(req, SIP_PKT_IGNORE))
 		transmit_response_reliable(p, "487 Request Terminated", &p->initreq);
@@ -12641,18 +12653,28 @@
 	check_via(p, req);
 	ast_set_flag(&p->flags[0], SIP_ALREADYGONE);	
 
+	if (p->rtp)
+		audioqos = ast_rtp_get_quality(p->rtp);
+	if (p->vrtp)
+		videoqos = ast_rtp_get_quality(p->vrtp);
+
 	/* Get RTCP quality before end of call */
 	if (recordhistory) {
 		if (p->rtp)
-			append_history(p, "RTCPaudio", "Quality:%s", ast_rtp_get_quality(p->rtp));
+			append_history(p, "RTCPaudio", "Quality:%s", audioqos);
 		if (p->vrtp)
-			append_history(p, "RTCPvideo", "Quality:%s", ast_rtp_get_quality(p->vrtp));
+			append_history(p, "RTCPvideo", "Quality:%s", videoqos);
 	}
+
 	if (p->rtp) {
+		if (p->owner)
+			pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
 		/* Immediately stop RTP */
 		ast_rtp_stop(p->rtp);
 	}
 	if (p->vrtp) {
+		if (p->owner)
+			pbx_builtin_setvar_helper(p->owner, "RTPVIDEOQOS", videoqos);
 		/* Immediately stop VRTP */
 		ast_rtp_stop(p->vrtp);
 	}

Modified: trunk/doc/channelvariables.txt
===================================================================
--- trunk/doc/channelvariables.txt	2006-06-27 23:10:55 UTC (rev 320)
+++ trunk/doc/channelvariables.txt	2006-06-27 23:20:12 UTC (rev 321)
@@ -710,6 +710,8 @@
 ${SIPURI}		* SIP uri
 ${SIP_CODEC} 		Set the SIP codec for a call	
 ${SIP_URI_OPTIONS}	* additional options to add to the URI for an outgoing call
+${RTPAUDIOQOS}		RTCP QoS report for the audio of this call
+${RTPVIDEOQOS}		RTCP QoS report for the video of this call
 
 The Agent channel uses the following variables:
 ---------------------------------------------------------



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 01:32:46 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 01:32:46 +0200
Subject: [solid-pbx-svn] r322 - in trunk: apps codecs/lpc10
Message-ID: <200606272332.k5RNWkwU023770@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 01:32:41 +0200 (Wed, 28 Jun 2006)
New Revision: 322

Modified:
   trunk/apps/app_osplookup.c
   trunk/codecs/lpc10/lpc10.h
   trunk/codecs/lpc10/lpcini.c
Log:
Update to Asterisk SVN trunk r33403

------------------------------------------------------------------------
r33398 | kpfleming | 2006-06-10 01:13:52 +0200 (Sat, 10 Jun 2006) | 2 lines

get rid of some more compiler warnings (thanks tholo for making me fix the lpc10 stuff... that had been a problem for far too long)

------------------------------------------------------------------------


Modified: trunk/apps/app_osplookup.c
===================================================================
--- trunk/apps/app_osplookup.c	2006-06-27 23:20:12 UTC (rev 321)
+++ trunk/apps/app_osplookup.c	2006-06-27 23:32:41 UTC (rev 322)
@@ -162,7 +162,7 @@
 		}
 	}
 	ast_log(LOG_DEBUG, "OSPAuth: source '%s'\n", source);
-	ast_log(LOG_DEBUG, "OSPAuth: token size '%d'\n", strlen(token));
+	ast_log(LOG_DEBUG, "OSPAuth: token size '%zd'\n", strlen(token));
 
 	res = ast_osp_auth(provider, &handle, source, chan->cid.cid_num, chan->exten, token, &timelimit);
 	if (res > 0) {
@@ -294,11 +294,11 @@
 	pbx_builtin_setvar_helper(chan, "OSPCALLING", result.calling);
 	ast_log(LOG_DEBUG, "OSPLookup: OSPCALLING '%s'\n", result.calling);
 	pbx_builtin_setvar_helper(chan, "OSPOUTTOKEN", result.token);
-	ast_log(LOG_DEBUG, "OSPLookup: OSPOUTTOKEN size '%d'\n", strlen(result.token));
+	ast_log(LOG_DEBUG, "OSPLookup: OSPOUTTOKEN size '%zd'\n", strlen(result.token));
 	if (!ast_strlen_zero(result.token)) {
 		snprintf(buffer, sizeof(buffer), "P-OSP-Auth-Token: %s", result.token);
 		pbx_builtin_setvar_helper(chan, "_SIPADDHEADER", buffer);
-		ast_log(LOG_DEBUG, "OSPLookup: SIPADDHEADER size '%d'\n", strlen(buffer));
+		ast_log(LOG_DEBUG, "OSPLookup: SIPADDHEADER size '%zd'\n", strlen(buffer));
 	}
 	snprintf(buffer, sizeof(buffer), "%d", result.numresults);
 	pbx_builtin_setvar_helper(chan, "OSPRESULTS", buffer);
@@ -440,11 +440,11 @@
 	pbx_builtin_setvar_helper(chan, "OSPCALLING", result.calling);
 	ast_log(LOG_DEBUG, "OSPNext: OSPCALLING '%s'\n", result.calling);
 	pbx_builtin_setvar_helper(chan, "OSPOUTTOKEN", result.token);
-	ast_log(LOG_DEBUG, "OSPNext: OSPOUTTOKEN size '%d'\n", strlen(result.token));
+	ast_log(LOG_DEBUG, "OSPNext: OSPOUTTOKEN size '%zd'\n", strlen(result.token));
 	if (!ast_strlen_zero(result.token)) {
 		snprintf(buffer, sizeof(buffer), "P-OSP-Auth-Token: %s", result.token);
 		pbx_builtin_setvar_helper(chan, "_SIPADDHEADER", buffer);
-		ast_log(LOG_DEBUG, "OSPNext: SIPADDHEADER size '%d'\n", strlen(buffer));
+		ast_log(LOG_DEBUG, "OSPNext: SIPADDHEADER size '%zd'\n", strlen(buffer));
 	}
 	snprintf(buffer, sizeof(buffer), "%d", result.numresults);
 	pbx_builtin_setvar_helper(chan, "OSPRESULTS", buffer);

Modified: trunk/codecs/lpc10/lpc10.h
===================================================================
--- trunk/codecs/lpc10/lpc10.h	2006-06-27 23:20:12 UTC (rev 321)
+++ trunk/codecs/lpc10/lpc10.h	2006-06-27 23:32:41 UTC (rev 322)
@@ -31,6 +31,8 @@
 #ifndef __LPC10_H__
 #define __LPC10_H__
 
+#define P_R_O_T_O_T_Y_P_E_S
+
 #define LPC10_SAMPLES_PER_FRAME 180
 #define LPC10_BITS_IN_COMPRESSED_FRAME 54
 

Modified: trunk/codecs/lpc10/lpcini.c
===================================================================
--- trunk/codecs/lpc10/lpcini.c	2006-06-27 23:20:12 UTC (rev 321)
+++ trunk/codecs/lpc10/lpcini.c	2006-06-27 23:32:41 UTC (rev 322)
@@ -29,13 +29,6 @@
 
 */
 
-#ifdef P_R_O_T_O_T_Y_P_E_S
-extern int lpcini_(void);
-/* comlen contrl_ 12 */
-/*:ref: initlpcenc_ 14 0 */
-/*:ref: initlpcdec_ 14 0 */
-#endif
-
 /*  -- translated by f2c (version 19951025).
    You must link the resulting object file with the libraries:
 	-lf2c -lm   (in that order)
@@ -44,6 +37,13 @@
 #include <stdlib.h>
 #include "f2c.h"
 
+#ifdef P_R_O_T_O_T_Y_P_E_S
+extern int lpcini_(void);
+/* comlen contrl_ 12 */
+/*:ref: initlpcenc_ 14 0 */
+/*:ref: initlpcdec_ 14 0 */
+#endif
+
 /* Common Block Declarations */
 
 struct {



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 01:45:51 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 01:45:51 +0200
Subject: [solid-pbx-svn] r323 - in trunk: pbx pbx/ael utils
Message-ID: <200606272345.k5RNjpsi027629@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 01:45:44 +0200 (Wed, 28 Jun 2006)
New Revision: 323

Modified:
   trunk/pbx/ael/ael.flex
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/pbx_gtkconsole.c
   trunk/utils/Makefile
   trunk/utils/ael_main.c
Log:
Update to Asterisk SVN trunk r33423

------------------------------------------------------------------------
r33421 | russell | 2006-06-10 06:34:48 +0200 (Sat, 10 Jun 2006) | 2 lines

convert a few more uses of AST_CONFIG_MAX_PATH to use PATH_MAX

------------------------------------------------------------------------
r33422 | russell | 2006-06-10 06:38:04 +0200 (Sat, 10 Jun 2006) | 2 lines

don't redefine PATH_MAX

------------------------------------------------------------------------
r33423 | russell | 2006-06-10 06:41:34 +0200 (Sat, 10 Jun 2006) | 2 lines

don't use ast_copy_string when building for an external tool

------------------------------------------------------------------------


Modified: trunk/pbx/ael/ael.flex
===================================================================
--- trunk/pbx/ael/ael.flex	2006-06-27 23:32:41 UTC (rev 322)
+++ trunk/pbx/ael/ael.flex	2006-06-27 23:45:44 UTC (rev 323)
@@ -404,7 +404,11 @@
 			if (*(p1+1) != '/')
 				snprintf(fnamebuf, sizeof(fnamebuf), "%s/%s", ast_config_AST_CONFIG_DIR, p1 + 1);
 			else
+#ifdef STANDALONE
+				strncpy(fnamebuf, p1 + 1, sizeof(fnamebuf) - 1);
+#else
 				ast_copy_string(fnamebuf, p1 + 1, sizeof(fnamebuf));
+#endif
 			in1 = fopen( fnamebuf, "r" );
 			if ( ! in1 ) {
 				ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-06-27 23:32:41 UTC (rev 322)
+++ trunk/pbx/ael/ael_lex.c	2006-06-27 23:45:44 UTC (rev 323)
@@ -1553,7 +1553,11 @@
 			if (*(p1+1) != '/')
 				snprintf(fnamebuf, sizeof(fnamebuf), "%s/%s", ast_config_AST_CONFIG_DIR, p1 + 1);
 			else
+#ifdef STANDALONE
+				strncpy(fnamebuf, p1 + 1, sizeof(fnamebuf) - 1);
+#else
 				ast_copy_string(fnamebuf, p1 + 1, sizeof(fnamebuf));
+#endif
 			in1 = fopen( fnamebuf, "r" );
 			if ( ! in1 ) {
 				ast_log(LOG_ERROR,"File=%s, line=%d, column=%d: Couldn't find the include file: %s; ignoring the Include directive!\n", my_file, my_lineno, my_col, fnamebuf);
@@ -1586,7 +1590,7 @@
 case YY_STATE_EOF(paren):
 case YY_STATE_EOF(semic):
 case YY_STATE_EOF(argg):
-#line 436 "ael.flex"
+#line 440 "ael.flex"
 {
 		if ( --include_stack_index < 0 ) {
 			yyterminate();
@@ -1602,10 +1606,10 @@
 	YY_BREAK
 case 55:
 YY_RULE_SETUP
-#line 449 "ael.flex"
+#line 453 "ael.flex"
 ECHO;
 	YY_BREAK
-#line 1608 "ael_lex.c"
+#line 1612 "ael_lex.c"
 
 	case YY_END_OF_BUFFER:
 		{
@@ -1836,7 +1840,7 @@
 
 		/* Read in more data. */
 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			yyg->yy_n_chars, num_to_read );
+			yyg->yy_n_chars, (size_t) num_to_read );
 
 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
 		}
@@ -2735,7 +2739,7 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 449 "ael.flex"
+#line 453 "ael.flex"
 
 
 

Modified: trunk/pbx/pbx_gtkconsole.c
===================================================================
--- trunk/pbx/pbx_gtkconsole.c	2006-06-27 23:32:41 UTC (rev 322)
+++ trunk/pbx/pbx_gtkconsole.c	2006-06-27 23:45:44 UTC (rev 323)
@@ -244,7 +244,7 @@
 
 static void file_ok_sel(GtkWidget *w, GtkFileSelection *fs)
 {
-	char tmp[AST_CONFIG_MAX_PATH];
+	char tmp[PATH_MAX];
 	char *module = gtk_file_selection_get_filename(fs);
 	char buf[256];
 	snprintf(tmp, sizeof(tmp), "%s/", ast_config_AST_MODULE_DIR);
@@ -264,7 +264,7 @@
 
 static void add_module(void)
 {
-	char tmp[AST_CONFIG_MAX_PATH];
+	char tmp[PATH_MAX];
 	GtkWidget *filew;
 	snprintf(tmp, sizeof(tmp), "%s/*.so", ast_config_AST_MODULE_DIR);
 	filew = gtk_file_selection_new("Load Module");

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-06-27 23:32:41 UTC (rev 322)
+++ trunk/utils/Makefile	2006-06-27 23:45:44 UTC (rev 323)
@@ -74,7 +74,7 @@
 	$(CC) $(CFLAGS) -o $@ $^
 
 aelflex.o: ../pbx/ael/ael_lex.c ../include/asterisk/ael_structs.h ../pbx/ael/ael.tab.h
-	$(CC) $(CFLAGS) -I../pbx/ -c -o $@ $<
+	$(CC) $(CFLAGS) -I../pbx/ -DSTANDALONE -c -o $@ $<
 
 aelbison.o: ../pbx/ael/ael.tab.c ../pbx/ael/ael.tab.h ../include/asterisk/ael_structs.h
 	$(CC) $(CFLAGS) -I../pbx/ -c -o $@ $<

Modified: trunk/utils/ael_main.c
===================================================================
--- trunk/utils/ael_main.c	2006-06-27 23:32:41 UTC (rev 322)
+++ trunk/utils/ael_main.c	2006-06-27 23:45:44 UTC (rev 323)
@@ -18,12 +18,10 @@
 #include "asterisk/module.h"
 #include "asterisk/ael_structs.h"
 
-#define AST_CONFIG_MAX_PATH 255
-
 int conts=0, extens=0, priors=0;
 char last_exten[18000];
-char ast_config_AST_CONFIG_DIR[AST_CONFIG_MAX_PATH];
-char ast_config_AST_VAR_DIR[AST_CONFIG_MAX_PATH];
+char ast_config_AST_CONFIG_DIR[PATH_MAX];
+char ast_config_AST_VAR_DIR[PATH_MAX];
 
 void ast_add_profile(void);
 void ast_cli_register_multiple(void);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 01:50:48 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 01:50:48 +0200
Subject: [solid-pbx-svn] r324 - trunk/apps
Message-ID: <200606272350.k5RNombf028829@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 01:50:40 +0200 (Wed, 28 Jun 2006)
New Revision: 324

Modified:
   trunk/apps/app_speech_utils.c
   trunk/apps/app_zapbarge.c
   trunk/apps/app_zapscan.c
Log:
Update to Asterisk SVN trunk r33453

------------------------------------------------------------------------
r33446 | russell | 2006-06-11 16:44:58 +0200 (Sun, 11 Jun 2006) | 2 lines

don't leak a frame when breaking out of the main loop of this app

------------------------------------------------------------------------
r33447 | russell | 2006-06-11 16:48:25 +0200 (Sun, 11 Jun 2006) | 2 lines

don't leak a frame when exiting when the user presses '#'

------------------------------------------------------------------------
r33448 | russell | 2006-06-11 16:52:04 +0200 (Sun, 11 Jun 2006) | 2 lines

don't leak a frame when breaking out of the loop on a timeout

------------------------------------------------------------------------
r33450 | russell | 2006-06-11 16:59:09 +0200 (Sun, 11 Jun 2006) | 9 lines

Blocked revisions 33449 via svnmerge

.......
r33449 | russell | 2006-06-11 10:56:55 -0400 (Sun, 11 Jun 2006) | 2 lines

backport a couple of frame leak fixes from the trunk (revisions 33446, 33447)

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_speech_utils.c
===================================================================
--- trunk/apps/app_speech_utils.c	2006-06-27 23:45:44 UTC (rev 323)
+++ trunk/apps/app_speech_utils.c	2006-06-27 23:50:40 UTC (rev 324)
@@ -576,6 +576,8 @@
 			time(&current);
 			if ((current-start) >= timeout) {
 				done = 1;
+				if (f)
+					ast_frfree(f);
 				break;
 			}
 		}

Modified: trunk/apps/app_zapbarge.c
===================================================================
--- trunk/apps/app_zapbarge.c	2006-06-27 23:45:44 UTC (rev 323)
+++ trunk/apps/app_zapbarge.c	2006-06-27 23:50:40 UTC (rev 324)
@@ -221,6 +221,7 @@
 				break;
 			if ((f->frametype == AST_FRAME_DTMF) && (f->subclass == '#')) {
 				ret = 0;
+				ast_frfree(f);
 				break;
 			} else if (fd != chan->fds[0]) {
 				if (f->frametype == AST_FRAME_VOICE) {

Modified: trunk/apps/app_zapscan.c
===================================================================
--- trunk/apps/app_zapscan.c	2006-06-27 23:45:44 UTC (rev 323)
+++ trunk/apps/app_zapscan.c	2006-06-27 23:50:40 UTC (rev 324)
@@ -276,6 +276,8 @@
 					ast_log(LOG_WARNING, "Failed to read frame: %s\n", strerror(errno));
 			}
         }
+	if (f)
+		ast_frfree(f);
         if (fd != chan->fds[0])
 			close(fd);
         else {



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:14:00 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:14:00 +0200
Subject: [solid-pbx-svn] r325 - in trunk: apps res/snmp
Message-ID: <200606280014.k5S0E0pT000144@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:13:48 +0200 (Wed, 28 Jun 2006)
New Revision: 325

Modified:
   trunk/apps/app_test.c
   trunk/apps/app_url.c
   trunk/res/snmp/agent.c
Log:
Update to Asterisk SVN trunk r33483

------------------------------------------------------------------------
r33479 | russell | 2006-06-11 17:04:36 +0200 (Sun, 11 Jun 2006) | 12 lines

Merged revisions 33466 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33466 | russell | 2006-06-11 11:02:40 -0400 (Sun, 11 Jun 2006) | 4 lines

Free frames read from the channel when measuring noise.  This resulted in about
9 or 10 seconds of leaked frames in both the TestClient and TestServer
applications

.......

------------------------------------------------------------------------
r33481 | russell | 2006-06-11 17:09:06 +0200 (Sun, 11 Jun 2006) | 10 lines

Merged revisions 33480 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33480 | russell | 2006-06-11 11:08:12 -0400 (Sun, 11 Jun 2006) | 2 lines

fix a case where an HTML frame would be leaked

.......

------------------------------------------------------------------------
r33482 | kpfleming | 2006-06-11 17:10:26 +0200 (Sun, 11 Jun 2006) | 2 lines

make latest header file changes for this file too

------------------------------------------------------------------------


Modified: trunk/apps/app_test.c
===================================================================
--- trunk/apps/app_test.c	2006-06-27 23:50:40 UTC (rev 324)
+++ trunk/apps/app_test.c	2006-06-28 00:13:48 UTC (rev 325)
@@ -105,6 +105,7 @@
 				samples++;
 			}
 		}
+		ast_frfree(f);
 	}
 
 	if (rformat) {

Modified: trunk/apps/app_url.c
===================================================================
--- trunk/apps/app_url.c	2006-06-27 23:50:40 UTC (rev 324)
+++ trunk/apps/app_url.c	2006-06-28 00:13:48 UTC (rev 325)
@@ -143,6 +143,7 @@
 					if (local_option_jump || ast_opt_priority_jumping)
 			 			ast_goto_if_exists(chan, chan->context, chan->exten, chan->priority + 101);
 					res = 0;
+					ast_frfree(f);
 					goto out;
 					break;
 				default:

Modified: trunk/res/snmp/agent.c
===================================================================
--- trunk/res/snmp/agent.c	2006-06-27 23:50:40 UTC (rev 324)
+++ trunk/res/snmp/agent.c	2006-06-28 00:13:48 UTC (rev 325)
@@ -14,24 +14,14 @@
  * \author Thorsten Lockert <tholo at voop.as>
  */
 
-#include <net-snmp/net-snmp-config.h>
-#include <net-snmp/net-snmp-includes.h>
-#include <net-snmp/agent/net-snmp-agent-includes.h>
-
-/*
- * These conflict with ones in Asterisk header files, so
- * get rid of  them.  They'll be back after the next few
- * includes...
- */
-#undef HAVE_GETLOADAVG
-#undef HAVE_STRCASESTR
-
-#include <pthread.h>
-
 #include "asterisk.h"
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
 
+#include <net-snmp/net-snmp-config.h>
+#include <net-snmp/net-snmp-includes.h>
+#include <net-snmp/agent/net-snmp-agent-includes.h>
+
 #include "asterisk/channel.h"
 #include "asterisk/logger.h"
 #include "asterisk/options.h"



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:17:48 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:17:48 +0200
Subject: [solid-pbx-svn] r326 - in trunk: apps channels
Message-ID: <200606280017.k5S0HmMW000769@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:16:18 +0200 (Wed, 28 Jun 2006)
New Revision: 326

Modified:
   trunk/apps/app_alarmreceiver.c
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33513

------------------------------------------------------------------------
r33511 | russell | 2006-06-11 22:39:19 +0200 (Sun, 11 Jun 2006) | 10 lines

Merged revisions 33510 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33510 | russell | 2006-06-11 16:38:39 -0400 (Sun, 11 Jun 2006) | 2 lines

fix two places that would cause a frame to be leaked

.......

------------------------------------------------------------------------
r33512 | oej | 2006-06-11 22:42:11 +0200 (Sun, 11 Jun 2006) | 6 lines

- Complete addition of forward declarations and grouping of functions
- Change/add comments
- Declare internal function as static
- Remove functionname: in descriptions of functions
- Move Enums to top of file

------------------------------------------------------------------------


Modified: trunk/apps/app_alarmreceiver.c
===================================================================
--- trunk/apps/app_alarmreceiver.c	2006-06-28 00:13:48 UTC (rev 325)
+++ trunk/apps/app_alarmreceiver.c	2006-06-28 00:16:18 UTC (rev 326)
@@ -210,6 +210,7 @@
 
 			i += wf.datalen / 8;
 			if (i > duration) {
+				ast_frfree(f);
 				break;
 			}
 			if (ast_write(chan, &wf)){
@@ -217,6 +218,7 @@
 					ast_verbose(VERBOSE_PREFIX_4 "AlarmReceiver: Failed to write frame on %s\n", chan->name);
 				ast_log(LOG_WARNING, "AlarmReceiver Failed to write frame on %s\n",chan->name);
 				res = -1;
+				ast_frfree(f);
 				break;
 			}
 		}

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 00:13:48 UTC (rev 325)
+++ trunk/channels/chan_sip.c	2006-06-28 00:16:18 UTC (rev 326)
@@ -265,6 +265,13 @@
 	MWI_NOTIFICATION
 };
 
+enum parse_register_result {
+	PARSE_REGISTER_FAILED,
+	PARSE_REGISTER_UPDATE,
+	PARSE_REGISTER_QUERY,
+};
+
+
 static const struct cfsubscription_types {
 	enum subscriptiontype type;
 	const char * const event;
@@ -280,30 +287,47 @@
 	{ MWI_NOTIFICATION,	"message-summary", "application/simple-message-summary", "mwi" } /* RFC 3842: Mailbox notification */
 };
 
+/*! \brief SIP Request methods known by Asterisk */
 enum sipmethod {
-	SIP_UNKNOWN,
-	SIP_RESPONSE,
+	SIP_UNKNOWN,		/* Unknown response */
+	SIP_RESPONSE,		/* Not request, response to outbound request */
 	SIP_REGISTER,
 	SIP_OPTIONS,
 	SIP_NOTIFY,
 	SIP_INVITE,
 	SIP_ACK,
-	SIP_PRACK,
+	SIP_PRACK,		/* Not supported at all */
 	SIP_BYE,
 	SIP_REFER,
 	SIP_SUBSCRIBE,
 	SIP_MESSAGE,
-	SIP_UPDATE,
+	SIP_UPDATE,		/* We can send UPDATE; but not accept it */
 	SIP_INFO,
 	SIP_CANCEL,
-	SIP_PUBLISH,
+	SIP_PUBLISH,		/* Not supported at all */
 };
 
+/*! \brief Authentication types - proxy or www authentication 
+	\note Endpoints, like Asterisk, should always use WWW authentication to
+	allow multiple authentications in the same call - to the proxy and
+	to the end point.
+*/
 enum sip_auth_type {
 	PROXY_AUTH,
 	WWW_AUTH,
 };
 
+/*! \brief Authentication result from check_auth* functions */
+enum check_auth_result {
+	AUTH_SUCCESSFUL = 0,
+	AUTH_CHALLENGE_SENT = 1,
+	AUTH_SECRET_FAILED = -1,
+	AUTH_USERNAME_MISMATCH = -2,
+	AUTH_NOT_FOUND = -3,
+	AUTH_FAKE_AUTH = -4,
+	AUTH_UNKNOWN_DOMAIN = -5,
+};
+
 /* States for outbound registrations (with register= lines in sip.conf */
 enum sipregistrystate {
 	REG_STATE_UNREGISTERED = 0,	/*!< We are not registred */
@@ -1048,19 +1072,9 @@
 
 static struct ast_config *notify_types;		/*!< The list of manual NOTIFY types we know how to send */
 
-enum check_auth_result {
-	AUTH_SUCCESSFUL = 0,
-	AUTH_CHALLENGE_SENT = 1,
-	AUTH_SECRET_FAILED = -1,
-	AUTH_USERNAME_MISMATCH = -2,
-	AUTH_NOT_FOUND = -3,
-	AUTH_FAKE_AUTH = -4,
-	AUTH_UNKNOWN_DOMAIN = -5,
-};
-
 /*---------------------------- Forward declarations of functions in chan_sip.c */
-/*! \note Sorted up from start to build_rpid.... Will continue categorization in order to
-	split up chan_sip.c into several files  */
+/*! \note This is added to help splitting up chan_sip.c into several files
+	in coming releases */
 
 /*--- PBX interface functions */
 static struct ast_channel *sip_request_call(const char *type, int format, void *data, int *cause);
@@ -1077,9 +1091,12 @@
 static int sip_senddigit(struct ast_channel *ast, char digit);
 
 /*--- Transmitting responses and requests */
+static int sipsock_read(int *id, int fd, short events, void *ignore);
 static int __sip_xmit(struct sip_pvt *p, char *data, int len);
 static int __sip_reliable_xmit(struct sip_pvt *p, int seqno, int resp, char *data, int len, int fatal, int sipmethod);
 static int __transmit_response(struct sip_pvt *p, const char *msg, const struct sip_request *req, enum xmittype reliable);
+static int retrans_pkt(void *data);
+static int transmit_sip_request(struct sip_pvt *p, struct sip_request *req);
 static int transmit_response(struct sip_pvt *p, const char *msg, const struct sip_request *req);
 static int transmit_response_reliable(struct sip_pvt *p, const char *msg, const struct sip_request *req);
 static int transmit_response_with_date(struct sip_pvt *p, const char *msg, const struct sip_request *req);
@@ -1087,20 +1104,26 @@
 static int transmit_response_with_unsupported(struct sip_pvt *p, const char *msg, const struct sip_request *req, const char *unsupported);
 static int transmit_response_with_auth(struct sip_pvt *p, const char *msg, const struct sip_request *req, const char *rand, enum xmittype reliable, const char *header, int stale);
 static int transmit_response_with_allow(struct sip_pvt *p, const char *msg, const struct sip_request *req, enum xmittype reliable);
+static void transmit_fake_auth_response(struct sip_pvt *p, struct sip_request *req, int reliable);
 static int transmit_request(struct sip_pvt *p, int sipmethod, int inc, enum xmittype reliable, int newbranch);
-static int transmit_request_with_auth(struct sip_pvt *p, int sipmethod, int inc, enum xmittype reliable, int newbranch);
-static int transmit_invite(struct sip_pvt *p, int sipmethod, int sendsdp, int init);
+static int transmit_request_with_auth(struct sip_pvt *p, int sipmethod, int seqno, enum xmittype reliable, int newbranch);
+static int transmit_invite(struct sip_pvt *p, int sipmethod, int sdp, int init);
 static int transmit_reinvite_with_sdp(struct sip_pvt *p);
-static int transmit_info_with_digit(struct sip_pvt *p, char digit);
+static int transmit_info_with_digit(struct sip_pvt *p, const char digit);
 static int transmit_info_with_vidupdate(struct sip_pvt *p);
 static int transmit_message_with_text(struct sip_pvt *p, const char *text);
 static int transmit_refer(struct sip_pvt *p, const char *dest);
+static int transmit_notify_with_mwi(struct sip_pvt *p, int newmsgs, int oldmsgs, char *vmexten);
+static int transmit_notify_with_sipfrag(struct sip_pvt *p, int cseq, char *message, int terminate);
 static int transmit_state_notify(struct sip_pvt *p, int state, int full);
 static int transmit_register(struct sip_registry *r, int sipmethod, const char *auth, const char *authheader);
-static int retrans_pkt(void *data);
 static int send_response(struct sip_pvt *p, struct sip_request *req, enum xmittype reliable, int seqno);
 static int send_request(struct sip_pvt *p, struct sip_request *req, enum xmittype reliable, int seqno);
 static void copy_request(struct sip_request *dst, const struct sip_request *src);
+static void receive_message(struct sip_pvt *p, struct sip_request *req);
+static void parse_moved_contact(struct sip_pvt *p, struct sip_request *req);
+static int sip_send_mwi_to_peer(struct sip_peer *peer);
+static int does_peer_need_mwi(struct sip_peer *peer);
 
 /*--- Dialog management */
 static struct sip_pvt *sip_alloc(ast_string_field callid, struct sockaddr_in *sin,
@@ -1118,7 +1141,19 @@
 static int hangup_sip2cause(int cause);
 static const char *hangup_cause2sip(int cause);
 static struct sip_pvt *find_call(struct sip_request *req, struct sockaddr_in *sin, const int intended_method);
-int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno);
+static void free_old_route(struct sip_route *route);
+static void list_route(struct sip_route *route);
+static void build_route(struct sip_pvt *p, struct sip_request *req, int backwards);
+static enum check_auth_result check_auth(struct sip_pvt *p, struct sip_request *req, const char *username,
+					 const char *secret, const char *md5secret, int sipmethod,
+					 char *uri, enum xmittype reliable, int ignore);
+static enum check_auth_result register_verify(struct sip_pvt *p, struct sockaddr_in *sin,
+					      struct sip_request *req, char *uri);
+static struct sip_pvt *get_sip_pvt_byid_locked(const char *callid, const char *totag, const char *fromtag);
+static void check_pendings(struct sip_pvt *p);
+static void *sip_park_thread(void *stuff);
+static int sip_park(struct ast_channel *chan1, struct ast_channel *chan2, struct sip_request *req, int seqno);
+static int sip_sipredirect(struct sip_pvt *p, const char *dest);
 
 /*--- Codec handling / SDP */
 static void try_suggested_sip_codec(struct sip_pvt *p);
@@ -1144,29 +1179,112 @@
 static enum check_auth_result check_auth(struct sip_pvt *p, struct sip_request *req, const char *username,
 					 const char *secret, const char *md5secret, int sipmethod,
 					 char *uri, enum xmittype reliable, int ignore);
+static enum check_auth_result check_user_full(struct sip_pvt *p, struct sip_request *req,
+					      int sipmethod, char *uri, enum xmittype reliable,
+					      struct sockaddr_in *sin, struct sip_peer **authpeer);
+static int check_user(struct sip_pvt *p, struct sip_request *req, int sipmethod, char *uri, enum xmittype reliable, struct sockaddr_in *sin);
+static int do_proxy_auth(struct sip_pvt *p, struct sip_request *req, char *header, char *respheader, int sipmethod, int init);
+static int build_reply_digest(struct sip_pvt *p, int method, char* digest, int digest_len);
 
 /*--- Domain handling */
 static int check_sip_domain(const char *domain, char *context, size_t len); /* Check if domain is one of our local domains */
+static int add_sip_domain(const char *domain, const enum domain_mode mode, const char *context);
+static void clear_sip_domains(void);
 
-static void free_old_route(struct sip_route *route);
+/*--- SIP realm authentication */
+static struct sip_auth *add_realm_authentication(struct sip_auth *authlist, char *configuration, int lineno);
+static int clear_realm_authentication(struct sip_auth *authlist);
+static struct sip_auth *find_realm_authentication(struct sip_auth *authlist, const char *realm);
 
 /*--- Misc functions */
 static int sip_do_reload(enum channelreloadreason reason);
+static int reload_config(enum channelreloadreason reason);
 static int expire_register(void *data);
 static int sip_sipredirect(struct sip_pvt *p, const char *dest);
+static void *do_monitor(void *data);
 static int restart_monitor(void);
 static int sip_send_mwi_to_peer(struct sip_peer *peer);
 static void sip_destroy(struct sip_pvt *p);
 static int sip_addrcmp(char *name, struct sockaddr_in *sin);	/* Support for peer matching */
+static int sip_refer_allocate(struct sip_pvt *p);
+static void ast_quiet_chan(struct ast_channel *chan);
+static int attempt_transfer(struct sip_dual *transferer, struct sip_dual *target);
 
-/*--- CLI and manager command helpers */
+/*--- Device monitoring and Device/extension state handling */
+static int cb_extensionstate(char *context, char* exten, int state, void *data);
+static int sip_devicestate(void *data);
+static int sip_poke_noanswer(void *data);
+static int sip_poke_peer(struct sip_peer *peer);
+static void sip_poke_all_peers(void);
+
+
+/*--- Applications, functions, CLI and manager command helpers */
 static const char *sip_nat_mode(const struct sip_pvt *p);
+static int sip_show_inuse(int fd, int argc, char *argv[]);
+static char *transfermode2str(enum transfermodes mode);
+static char *nat2str(int nat);
+static int peer_status(struct sip_peer *peer, char *status, int statuslen);
+static int sip_show_users(int fd, int argc, char *argv[]);
+static int _sip_show_peers(int fd, int *total, struct mansession *s, struct message *m, int argc, char *argv[]);
+static int manager_sip_show_peers( struct mansession *s, struct message *m );
+static int sip_show_peers(int fd, int argc, char *argv[]);
+static int sip_show_objects(int fd, int argc, char *argv[]);
+static void  print_group(int fd, unsigned int group, int crlf);
+static const char *dtmfmode2str(int mode);
+static const char *insecure2str(int port, int invite);
+static void cleanup_stale_contexts(char *new, char *old);
+static void print_codec_to_cli(int fd, struct ast_codec_pref *pref);
+static const char *domain_mode_to_text(const enum domain_mode mode);
+static int sip_show_domains(int fd, int argc, char *argv[]);
+static int _sip_show_peer(int type, int fd, struct mansession *s, struct message *m, int argc, char *argv[]);
+static int manager_sip_show_peer( struct mansession *s, struct message *m);
+static int sip_show_peer(int fd, int argc, char *argv[]);
+static int _sip_show_peer(int type, int fd, struct mansession *s, struct message *m, int argc, char *argv[]);
+static int sip_show_user(int fd, int argc, char *argv[]);
+static int sip_show_registry(int fd, int argc, char *argv[]);
+static int sip_show_settings(int fd, int argc, char *argv[]);
+static const char *subscription_type2str(enum subscriptiontype subtype);
+static const struct cfsubscription_types *find_subscription_type(enum subscriptiontype subtype);
+static int __sip_show_channels(int fd, int argc, char *argv[], int subscriptions);
+static int sip_show_channels(int fd, int argc, char *argv[]);
+static int sip_show_subscriptions(int fd, int argc, char *argv[]);
+static int __sip_show_channels(int fd, int argc, char *argv[], int subscriptions);
+static char *complete_sipch(const char *line, const char *word, int pos, int state);
+static char *complete_sip_peer(const char *word, int state, int flags2);
+static char *complete_sip_show_peer(const char *line, const char *word, int pos, int state);
+static char *complete_sip_debug_peer(const char *line, const char *word, int pos, int state);
+static char *complete_sip_user(const char *word, int state, int flags2);
+static char *complete_sip_show_user(const char *line, const char *word, int pos, int state);
+static char *complete_sipnotify(const char *line, const char *word, int pos, int state);
+static char *complete_sip_prune_realtime_peer(const char *line, const char *word, int pos, int state);
+static char *complete_sip_prune_realtime_user(const char *line, const char *word, int pos, int state);
+static int sip_show_channel(int fd, int argc, char *argv[]);
+static int sip_show_history(int fd, int argc, char *argv[]);
+static int sip_do_debug_ip(int fd, int argc, char *argv[]);
+static int sip_do_debug_peer(int fd, int argc, char *argv[]);
+static int sip_do_debug(int fd, int argc, char *argv[]);
+static int sip_no_debug(int fd, int argc, char *argv[]);
+static int sip_notify(int fd, int argc, char *argv[]);
+static int sip_do_history(int fd, int argc, char *argv[]);
+static int sip_no_history(int fd, int argc, char *argv[]);
+static int func_header_read(struct ast_channel *chan, char *function, char *data, char *buf, size_t len);
+static int func_check_sipdomain(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len);
+static int function_sippeer(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len);
+static int function_sipchaninfo_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len);
+static int sip_dtmfmode(struct ast_channel *chan, void *data);
+static int sip_addheader(struct ast_channel *chan, void *data);
+static int sip_do_reload(enum channelreloadreason reason);
+static int sip_reload(int fd, int argc, char *argv[]);
 
-/*--- Debugging */
+/*--- Debugging 
+	Functions for enabling debug per IP or fully, or enabling history logging for
+	a SIP dialog
+*/
 static void sip_dump_history(struct sip_pvt *dialog);	/* Dump history to LOG_DEBUG at end of dialog, before destroying data */
 static inline int sip_debug_test_addr(const struct sockaddr_in *addr);
 static inline int sip_debug_test_pvt(struct sip_pvt *p);
 static void append_history_full(struct sip_pvt *p, const char *fmt, ...);
+static void sip_dump_history(struct sip_pvt *dialog);
 
 /*--- Device object handling */
 static struct sip_peer *temp_peer(const char *name);
@@ -1183,17 +1301,31 @@
 static void sip_destroy_user(struct sip_user *user);
 static struct sip_peer *find_peer(const char *peer, struct sockaddr_in *sin, int realtime);
 static struct sip_user *find_user(const char *name, int realtime);
+static int sip_poke_peer_s(void *data);
+static enum parse_register_result parse_register_contact(struct sip_pvt *pvt, struct sip_peer *p, struct sip_request *req);
+static int expire_register(void *data);
+static void reg_source_db(struct sip_peer *peer);
+static void destroy_association(struct sip_peer *peer);
+static int handle_common_options(struct ast_flags *flags, struct ast_flags *mask, struct ast_variable *v);
+
 /* Realtime device support */
 static void realtime_update_peer(const char *peername, struct sockaddr_in *sin, const char *username, const char *fullcontact, int expirey);
 static struct sip_user *realtime_user(const char *username);
 static void update_peer(struct sip_peer *p, int expiry);
 static struct sip_peer *realtime_peer(const char *peername, struct sockaddr_in *sin);
+static int sip_prune_realtime(int fd, int argc, char *argv[]);
 
 /*--- Internal UA client handling (outbound registrations) */
-static int __sip_do_register(struct sip_registry *r);
 static int ast_sip_ouraddrfor(struct in_addr *them, struct in_addr *us);
 static void sip_registry_destroy(struct sip_registry *reg);
 static int sip_register(char *value, int lineno);
+static char *regstate2str(enum sipregistrystate regstate);
+static int sip_reregister(void *data);
+static int __sip_do_register(struct sip_registry *r);
+static int sip_reg_timeout(void *data);
+static int do_register_auth(struct sip_pvt *p, struct sip_request *req, char *header, char *respheader);
+static int reply_digest(struct sip_pvt *p, struct sip_request *req, char *header, int sipmethod,  char *digest, int digest_len);
+static void sip_send_all_registers(void);
 
 /*--- Parsing SIP requests and responses */
 static void append_date(struct sip_request *req);	/* Append date to SIP packet */
@@ -1213,11 +1345,24 @@
 static const char *get_header(const struct sip_request *req, const char *name);
 static int lws2sws(char *msgbuf, int len);
 static void extract_uri(struct sip_pvt *p, struct sip_request *req);
+static int get_refer_info(struct sip_pvt *transferer, struct sip_request *outgoing_req);
+static int get_also_info(struct sip_pvt *p, struct sip_request *oreq);
+static int parse_ok_contact(struct sip_pvt *pvt, struct sip_request *req);
+static int set_address_from_contact(struct sip_pvt *pvt);
+static void check_via(struct sip_pvt *p, struct sip_request *req);
+static char *get_calleridname(const char *input, char *output, size_t outputsize);
+static int get_rpid_num(const char *input, char *output, int maxlen);
+static int get_rdnis(struct sip_pvt *p, struct sip_request *oreq);
+static int get_destination(struct sip_pvt *p, struct sip_request *oreq);
+static int get_msg_text(char *buf, int len, struct sip_request *req);
+static const char *gettag(const struct sip_request *req, const char *header, char *tagbuf, int tagbufsize);
+static void free_old_route(struct sip_route *route);
 
 /*--- Constructing requests and responses */
 static void initialize_initreq(struct sip_pvt *p, struct sip_request *req);
 static int init_req(struct sip_request *req, int sipmethod, const char *recip);
 static int reqprep(struct sip_request *req, struct sip_pvt *p, int sipmethod, int seqno, int newbranch);
+static void initreqprep(struct sip_request *req, struct sip_pvt *p, int sipmethod);
 static int init_resp(struct sip_request *resp, const char *msg);
 static int respprep(struct sip_request *resp, struct sip_pvt *p, const char *msg, const struct sip_request *req);
 static const struct sockaddr_in *sip_real_dst(const struct sip_pvt *p);
@@ -1244,6 +1389,7 @@
 static void build_rpid(struct sip_pvt *p);
 
 /*------Request handling functions */
+static int handle_request(struct sip_pvt *p, struct sip_request *req, struct sockaddr_in *sin, int *recount, int *nounlock);
 static int handle_request_invite(struct sip_pvt *p, struct sip_request *req, int debug, int seqno, struct sockaddr_in *sin, int *recount, char *e);
 static int handle_request_refer(struct sip_pvt *p, struct sip_request *req, int debug, int ignore, int seqno, int *nounlock);
 static int handle_request_bye(struct sip_pvt *p, struct sip_request *req);
@@ -1254,11 +1400,16 @@
 static void handle_request_info(struct sip_pvt *p, struct sip_request *req);
 static int handle_request_options(struct sip_pvt *p, struct sip_request *req);
 static int handle_invite_replaces(struct sip_pvt *p, struct sip_request *req, int debug, int ignore, int seqno, struct sockaddr_in *sin);
+static int handle_request_notify(struct sip_pvt *p, struct sip_request *req, struct sockaddr_in *sin, int seqno, char *e);
+static int handle_invite_replaces(struct sip_pvt *p, struct sip_request *req, int debug, int ignore, int seqno, struct sockaddr_in *sin);
+static int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno);
 
 /*------Response handling functions */
 static void handle_response_invite(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int seqno);
 static void handle_response_refer(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int seqno);
 static int handle_response_peerpoke(struct sip_pvt *p, int resp, struct sip_request *req);
+static int handle_response_register(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int ignore, int seqno);
+static void handle_response(struct sip_pvt *p, int resp, char *rest, struct sip_request *req, int ignore, int seqno);
 
 /*----- RTP interface functions */
 static int sip_set_rtp_peer(struct ast_channel *chan, struct ast_rtp *rtp, struct ast_rtp *vrtp, int codecs, int nat_active);
@@ -5994,9 +6145,9 @@
 }
 
 /*! \brief Transmit SIP request */
-static int transmit_sip_request(struct sip_pvt *p,struct sip_request *req)
+static int transmit_sip_request(struct sip_pvt *p, struct sip_request *req)
 {
-	if (!p->initreq.headers) 
+	if (!p->initreq.headers) 	/* Initialize first request before sending */
 		initialize_initreq(p, req);
 	return send_request(p, req, 0, p->ocseq);
 }
@@ -6051,7 +6202,7 @@
 	}
 }
 
-/*! \brief Update registration with SIP Proxy*/
+/*! \brief Update registration with SIP Proxy */
 static int sip_reregister(void *data) 
 {
 	/* if we are here, we know that we need to reregister. */
@@ -6320,7 +6471,11 @@
 	return p->refer ? 1 : 0;
 }
 
-/*! \brief Transmit SIP REFER message */
+/*! \brief Transmit SIP REFER message (initiated by the transfer() dialplan application
+	\note this is currently broken as we have no way of telling the dialplan
+	engine whether a transfer succeeds or fails.
+	\todo Fix the transfer() dialplan function so that a transfer may fail
+*/
 static int transmit_refer(struct sip_pvt *p, const char *dest)
 {
 	struct sip_request req;
@@ -6390,9 +6545,10 @@
 
 
 /*! \brief Send SIP INFO dtmf message, see Cisco documentation on cisco.com */
-static int transmit_info_with_digit(struct sip_pvt *p, char digit)
+static int transmit_info_with_digit(struct sip_pvt *p, const char digit)
 {
 	struct sip_request req;
+
 	reqprep(&req, p, SIP_INFO, 0, 1);
 	add_digit(&req, digit);
 	return send_request(p, &req, 1, p->ocseq);
@@ -6402,6 +6558,7 @@
 static int transmit_info_with_vidupdate(struct sip_pvt *p)
 {
 	struct sip_request req;
+
 	reqprep(&req, p, SIP_INFO, 0, 1);
 	add_vidupdate(&req);
 	return send_request(p, &req, 1, p->ocseq);
@@ -6411,6 +6568,7 @@
 static int transmit_request(struct sip_pvt *p, int sipmethod, int seqno, enum xmittype reliable, int newbranch)
 {
 	struct sip_request resp;
+
 	reqprep(&resp, p, sipmethod, seqno, newbranch);
 	add_header_contentLength(&resp, 0);
 	return send_request(p, &resp, reliable, seqno ? seqno : p->ocseq);
@@ -6450,15 +6608,14 @@
 	return send_request(p, &resp, reliable, seqno ? seqno : p->ocseq);	
 }
 
-/*! \brief Remove registration data from realtime database and AST/DB when registration expires */
+/*! \brief Remove registration data from realtime database or AST/DB when registration expires */
 static void destroy_association(struct sip_peer *peer)
 {
 	if (!ast_test_flag(&global_flags[1], SIP_PAGE2_IGNOREREGEXPIRE)) {
-		if (ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT)) {
+		if (ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT))
 			ast_update_realtime("sippeers", "name", peer->name, "fullcontact", "", "ipaddr", "", "port", "", "regseconds", "0", "username", "", NULL);
-		} else {
+		else 
 			ast_db_del("SIP/Registry", peer->name);
-		}
 	}
 }
 
@@ -6645,12 +6802,6 @@
 }
 
 
-enum parse_register_result {
-	PARSE_REGISTER_FAILED,
-	PARSE_REGISTER_UPDATE,
-	PARSE_REGISTER_QUERY,
-};
-
 /*! \brief Parse contact header and save registration */
 static enum parse_register_result parse_register_contact(struct sip_pvt *pvt, struct sip_peer *p, struct sip_request *req)
 {
@@ -7431,12 +7582,12 @@
 {
 	struct sip_pvt *sip_pvt_ptr;
 
-	/* Search interfaces and find the match */
 	ast_mutex_lock(&iflock);
 
 	if (option_debug > 3 && totag)
 		ast_log(LOG_DEBUG, "Looking for callid %s (fromtag %s totag %s)\n", callid, fromtag ? fromtag : "<no fromtag>", totag ? totag : "<no totag>");
 
+	/* Search interfaces and find the match */
 	for (sip_pvt_ptr = iflist; sip_pvt_ptr; sip_pvt_ptr = sip_pvt_ptr->next) {
 		if (!strcmp(sip_pvt_ptr->callid, callid)) {
 			int match = 1;
@@ -8195,7 +8346,8 @@
 }
 
 /*! \brief  CLI Command to show calls within limits set by call_limit */
-static int sip_show_inuse(int fd, int argc, char *argv[]) {
+static int sip_show_inuse(int fd, int argc, char *argv[])
+{
 #define FORMAT  "%-25.25s %-15.15s %-15.15s \n"
 #define FORMAT2 "%-25.25s %-15.15s %-15.15s \n"
 	char ilimits[40];
@@ -8345,8 +8497,6 @@
 "Variables: \n"
 "  ActionID: <id>	Action ID for this transaction. Will be returned.\n";
 
-static int _sip_show_peers(int fd, int *total, struct mansession *s, struct message *m, int argc, char *argv[]);
-
 /*! \brief  Show SIP peers in the manager API */
 /*    Inspired from chan_iax2 */
 static int manager_sip_show_peers( struct mansession *s, struct message *m )
@@ -8519,7 +8669,7 @@
 #undef FORMAT2
 }
 
-/*! \brief  sip_show_objects: List all allocated SIP Objects */
+/*! \brief List all allocated SIP Objects (realtime or static) */
 static int sip_show_objects(int fd, int argc, char *argv[])
 {
 	char tmp[256];
@@ -8533,14 +8683,14 @@
 	ASTOBJ_CONTAINER_DUMP(fd, tmp, sizeof(tmp), &regl);
 	return RESULT_SUCCESS;
 }
-/*! \brief  print_group: Print call group and pickup group */
-static void  print_group(int fd, unsigned int group, int crlf) 
+/*! \brief Print call group and pickup group */
+static void  print_group(int fd, unsigned int group, int crlf)
 {
 	char buf[256];
 	ast_cli(fd, crlf ? "%s\r\n" : "%s\n", ast_print_group(buf, sizeof(buf), group) );
 }
 
-/*! \brief  dtmfmode2str: Convert DTMF mode to printable string */
+/*! \brief Convert DTMF mode to printable string */
 static const char *dtmfmode2str(int mode)
 {
 	switch (mode) {
@@ -8556,7 +8706,7 @@
 	return "<error>";
 }
 
-/*! \brief  insecure2str: Convert Insecure setting to printable string */
+/*! \brief Convert Insecure setting to printable string */
 static const char *insecure2str(int port, int invite)
 {
 	if (port && invite)
@@ -8569,7 +8719,7 @@
 		return "no";
 }
 
-/*! \brief cleanup_stale_contexts:  Destroy disused contexts between reloads
+/*! \brief Destroy disused contexts between reloads
 	Only used in reload_config so the code for regcontext doesn't get ugly
 */
 static void cleanup_stale_contexts(char *new, char *old)
@@ -8595,7 +8745,7 @@
 	}
 }
 
-/*! \brief  sip_prune_realtime: Remove temporary realtime objects from memory (CLI) */
+/*! \brief Remove temporary realtime objects from memory (CLI) */
 static int sip_prune_realtime(int fd, int argc, char *argv[])
 {
 	struct sip_peer *peer;
@@ -8742,8 +8892,8 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  print_codec_to_cli: Print codec list from preference to CLI/manager */
-static void print_codec_to_cli(int fd, struct ast_codec_pref *pref) 
+/*! \brief Print codec list from preference to CLI/manager */
+static void print_codec_to_cli(int fd, struct ast_codec_pref *pref)
 {
 	int x, codec;
 
@@ -8759,6 +8909,7 @@
 		ast_cli(fd, "none");
 }
 
+/*! \brief Print domain mode to cli */
 static const char *domain_mode_to_text(const enum domain_mode mode)
 {
 	switch (mode) {
@@ -8771,11 +8922,11 @@
 	return "";
 }
 
-/*! \brief  sip_show_domains: CLI command to list local domains */
-#define FORMAT "%-40.40s %-20.20s %-16.16s\n"
+/*! \brief CLI command to list local domains */
 static int sip_show_domains(int fd, int argc, char *argv[])
 {
 	struct domain *d;
+#define FORMAT "%-40.40s %-20.20s %-16.16s\n"
 
 	if (AST_LIST_EMPTY(&domain_list)) {
 		ast_cli(fd, "SIP Domain support not enabled.\n\n");
@@ -8799,10 +8950,8 @@
 "  Peer: <name>           The peer name you want to check.\n"
 "  ActionID: <id>	  Optional action ID for this AMI transaction.\n";
 
-static int _sip_show_peer(int type, int fd, struct mansession *s, struct message *m, int argc, char *argv[]);
-
-/*! \brief  manager_sip_show_peer: Show SIP peers in the manager API  */
-static int manager_sip_show_peer( struct mansession *s, struct message *m )
+/*! \brief Show SIP peers in the manager API  */
+static int manager_sip_show_peer( struct mansession *s, struct message *m)
 {
 	char *id = astman_get_header(m,"ActionID");
 	char *a[4];
@@ -8828,12 +8977,13 @@
 
 
 
-/*! \brief  sip_show_peer: Show one peer in detail */
+/*! \brief Show one peer in detail */
 static int sip_show_peer(int fd, int argc, char *argv[])
 {
 	return _sip_show_peer(0, fd, NULL, NULL, argc, argv);
 }
 
+/*! \brief Show one peer in detail (main function) */
 static int _sip_show_peer(int type, int fd, struct mansession *s, struct message *m, int argc, char *argv[])
 {
 	char status[30] = "";
@@ -9037,7 +9187,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  sip_show_user: Show one user in detail */
+/*! \brief Show one user in detail */
 static int sip_show_user(int fd, int argc, char *argv[])
 {
 	char cbuf[256];
@@ -9133,7 +9283,7 @@
 #undef FORMAT2
 }
 
-/*! \brief  sip_show_settings: List global settings for the SIP channel */
+/*! \brief List global settings for the SIP channel */
 static int sip_show_settings(int fd, int argc, char *argv[])
 {
 	char tmp[BUFSIZ];
@@ -9224,8 +9374,9 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  subscription_type2str: Show subscription type in string format */
-static const char *subscription_type2str(enum subscriptiontype subtype) {
+/*! \brief Show subscription type in string format */
+static const char *subscription_type2str(enum subscriptiontype subtype)
+{
 	int i;
 
 	for (i = 1; (i < (sizeof(subscription_types) / sizeof(subscription_types[0]))); i++) {
@@ -9236,8 +9387,9 @@
 	return subscription_types[0].text;
 }
 
-/*! \brief  find_subscription_type: Find subscription type in array */
-static const struct cfsubscription_types *find_subscription_type(enum subscriptiontype subtype) {
+/*! \brief Find subscription type in array */
+static const struct cfsubscription_types *find_subscription_type(enum subscriptiontype subtype)
+{
 	int i;
 
 	for (i = 1; (i < (sizeof(subscription_types) / sizeof(subscription_types[0]))); i++) {
@@ -9248,21 +9400,19 @@
 	return &subscription_types[0];
 }
 
-/* Forward declaration */
-static int __sip_show_channels(int fd, int argc, char *argv[], int subscriptions);
-
-/*! \brief  sip_show_channels: Show active SIP channels */
+/*! \brief Show active SIP channels */
 static int sip_show_channels(int fd, int argc, char *argv[])  
 {
         return __sip_show_channels(fd, argc, argv, 0);
 }
  
-/*! \brief  sip_show_subscriptions: Show active SIP subscriptions */
+/*! \brief Show active SIP subscriptions */
 static int sip_show_subscriptions(int fd, int argc, char *argv[])
 {
         return __sip_show_channels(fd, argc, argv, 1);
 }
 
+/*! \brief SIP show channels CLI (main function) */
 static int __sip_show_channels(int fd, int argc, char *argv[], int subscriptions)
 {
 #define FORMAT3 "%-15.15s  %-10.10s  %-11.11s  %-15.15s  %-13.13s  %-15.15s %-10.10s\n"
@@ -9323,7 +9473,7 @@
 #undef FORMAT3
 }
 
-/*! \brief  complete_sipch: Support routine for 'sip show channel' CLI */
+/*! \brief Support routine for 'sip show channel' CLI */
 static char *complete_sipch(const char *line, const char *word, int pos, int state)
 {
 	int which=0;
@@ -9342,7 +9492,7 @@
 	return c;
 }
 
-/*! \brief  complete_sip_peer: Do completion on peer name */
+/*! \brief Do completion on peer name */
 static char *complete_sip_peer(const char *word, int state, int flags2)
 {
 	char *result = NULL;
@@ -9359,7 +9509,7 @@
 	return result;
 }
 
-/*! \brief  complete_sip_show_peer: Support routine for 'sip show peer' CLI */
+/*! \brief Support routine for 'sip show peer' CLI */
 static char *complete_sip_show_peer(const char *line, const char *word, int pos, int state)
 {
 	if (pos == 3)
@@ -9368,7 +9518,7 @@
 	return NULL;
 }
 
-/*! \brief  complete_sip_debug_peer: Support routine for 'sip debug peer' CLI */
+/*! \brief Support routine for 'sip debug peer' CLI */
 static char *complete_sip_debug_peer(const char *line, const char *word, int pos, int state)
 {
 	if (pos == 3)
@@ -9377,7 +9527,7 @@
 	return NULL;
 }
 
-/*! \brief  complete_sip_user: Do completion on user name */
+/*! \brief Do completion on user name */
 static char *complete_sip_user(const char *word, int state, int flags2)
 {
 	char *result = NULL;
@@ -9397,7 +9547,7 @@
 	return result;
 }
 
-/*! \brief  complete_sip_show_user: Support routine for 'sip show user' CLI */
+/*! \brief Support routine for 'sip show user' CLI */
 static char *complete_sip_show_user(const char *line, const char *word, int pos, int state)
 {
 	if (pos == 3)
@@ -9406,7 +9556,7 @@
 	return NULL;
 }
 
-/*! \brief  complete_sipnotify: Support routine for 'sip notify' CLI */
+/*! \brief Support routine for 'sip notify' CLI */
 static char *complete_sipnotify(const char *line, const char *word, int pos, int state)
 {
 	char *c = NULL;
@@ -9436,7 +9586,7 @@
 	return NULL;
 }
 
-/*! \brief  complete_sip_prune_realtime_peer: Support routine for 'sip prune realtime peer' CLI */
+/*! \brief Support routine for 'sip prune realtime peer' CLI */
 static char *complete_sip_prune_realtime_peer(const char *line, const char *word, int pos, int state)
 {
 	if (pos == 4)
@@ -9444,7 +9594,7 @@
 	return NULL;
 }
 
-/*! \brief  complete_sip_prune_realtime_user: Support routine for 'sip prune realtime user' CLI */
+/*! \brief Support routine for 'sip prune realtime user' CLI */
 static char *complete_sip_prune_realtime_user(const char *line, const char *word, int pos, int state)
 {
 	if (pos == 4)
@@ -9453,7 +9603,7 @@
 	return NULL;
 }
 
-/*! \brief  sip_show_channel: Show details of one call */
+/*! \brief Show details of one active dialog */
 static int sip_show_channel(int fd, int argc, char *argv[])
 {
 	struct sip_pvt *cur;
@@ -9522,7 +9672,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  sip_show_history: Show history details of one call */
+/*! \brief Show history details of one dialog */
 static int sip_show_history(int fd, int argc, char *argv[])
 {
 	struct sip_pvt *cur;
@@ -9559,9 +9709,8 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  dump_history: Dump SIP history to debug log file at end of 
-  lifespan for SIP dialog */
-void sip_dump_history(struct sip_pvt *dialog)
+/*! \brief Dump SIP history to debug log file at end of lifespan for SIP dialog */
+static void sip_dump_history(struct sip_pvt *dialog)
 {
 	int x = 0;
 	struct sip_history *hist;
@@ -9583,7 +9732,7 @@
 }
 
 
-/*! \brief  handle_request_info: Receive SIP INFO Message
+/*! \brief  Receive SIP INFO Message
 \note    Doesn't read the duration of the DTMF signal */
 static void handle_request_info(struct sip_pvt *p, struct sip_request *req)
 {
@@ -9674,7 +9823,7 @@
 	return;
 }
 
-/*! \brief  sip_do_debug: Enable SIP Debugging in CLI */
+/*! \brief Enable SIP Debugging in CLI */
 static int sip_do_debug_ip(int fd, int argc, char *argv[])
 {
 	struct hostent *hp;
@@ -9729,7 +9878,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  sip_do_debug: Turn on SIP debugging (CLI command) */
+/*! \brief Turn on SIP debugging (CLI command) */
 static int sip_do_debug(int fd, int argc, char *argv[])
 {
 	int oldsipdebug = sipdebug_console;
@@ -9749,7 +9898,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  sip_notify: Send SIP notify to peer */
+/*! \brief Cli command to send SIP notify to peer */
 static int sip_notify(int fd, int argc, char *argv[])
 {
 	struct ast_variable *varlist;
@@ -9804,7 +9953,18 @@
 
 	return RESULT_SUCCESS;
 }
-/*! \brief  sip_do_history: Enable SIP History logging (CLI) */
+
+/*! \brief Disable SIP Debugging in CLI */
+static int sip_no_debug(int fd, int argc, char *argv[])
+{
+	if (argc != 3)
+		return RESULT_SHOWUSAGE;
+	ast_clear_flag(&global_flags[1], SIP_PAGE2_DEBUG_CONSOLE);
+	ast_cli(fd, "SIP Debugging Disabled\n");
+	return RESULT_SUCCESS;
+}
+
+/*! \brief Enable SIP History logging (CLI) */
 static int sip_do_history(int fd, int argc, char *argv[])
 {
 	if (argc != 2) {
@@ -9815,7 +9975,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  sip_no_history: Disable SIP History logging (CLI) */
+/*! \brief Disable SIP History logging (CLI) */
 static int sip_no_history(int fd, int argc, char *argv[])
 {
 	if (argc != 3) {
@@ -9826,20 +9986,9 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief Disable SIP Debugging in CLI */
-static int sip_no_debug(int fd, int argc, char *argv[])
 
-{
-	if (argc != 3)
-		return RESULT_SHOWUSAGE;
-	ast_clear_flag(&global_flags[1], SIP_PAGE2_DEBUG_CONSOLE);
-	ast_cli(fd, "SIP Debugging Disabled\n");
-	return RESULT_SUCCESS;
-}
-
-
 /*! \brief Authenticate for outbound registration */
-static int do_register_auth(struct sip_pvt *p, struct sip_request *req, char *header, char *respheader) 
+static int do_register_auth(struct sip_pvt *p, struct sip_request *req, char *header, char *respheader)
 {
 	char digest[1024];
 	p->authtries++;
@@ -9860,7 +10009,7 @@
 }
 
 /*! \brief Add authentication on outbound SIP packet */
-static int do_proxy_auth(struct sip_pvt *p, struct sip_request *req, char *header, char *respheader, int sipmethod, int init) 
+static int do_proxy_auth(struct sip_pvt *p, struct sip_request *req, char *header, char *respheader, int sipmethod, int init)
 {
 	char digest[1024];
 
@@ -9885,8 +10034,7 @@
 \return	Returns -1 if we have no auth 
 \note	This is used for register= servers in sip.conf, SIP proxies we register
 	with  for receiving calls from.  */
-static int reply_digest(struct sip_pvt *p, struct sip_request *req,
-	char *header, int sipmethod,  char *digest, int digest_len)
+static int reply_digest(struct sip_pvt *p, struct sip_request *req, char *header, int sipmethod,  char *digest, int digest_len)
 {
 	char tmp[512];
 	char *c;
@@ -10123,7 +10271,7 @@
 
 
 
-/*! \brief  func_header_read: Read SIP header (dialplan function) */
+/*! \brief Read SIP header (dialplan function) */
 static int func_header_read(struct ast_channel *chan, char *function, char *data, char *buf, size_t len) 
 {
 	struct sip_pvt *p;
@@ -10286,7 +10434,7 @@
 };
 
 /*! \brief ${SIPCHANINFO()} Dialplan function - reads sip channel data */
-static int function_sipchaninfo_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len) 
+static int function_sipchaninfo_read(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
 {
 	struct sip_pvt *p;
 	char iabuf[INET_ADDRSTRLEN];
@@ -11190,7 +11338,11 @@
 }
 
 
-/*! \brief Park SIP call support function */
+/*! \brief Park SIP call support function 
+	Starts in a new thread, then parks the call
+	XXX Should we add a wait period after streaming audio and before hangup?? Sometimes the
+		audio can't be heard before hangup
+*/
 static void *sip_park_thread(void *stuff)
 {
 	struct ast_channel *transferee, *transferer;	/* Chan1: The transferee, Chan2: The transferer */
@@ -11314,7 +11466,9 @@
 	return -1;
 }
 
-/*! \brief Turn off generator data */
+/*! \brief Turn off generator data 
+	XXX Does this function belong in the SIP channel?
+*/
 static void ast_quiet_chan(struct ast_channel *chan) 
 {
 	if (chan && chan->_state == AST_STATE_UP) {
@@ -11416,7 +11570,7 @@
  * \return Returns the pointer to the provided tag buffer,
  *         or NULL if the tag was not found.
  */
-static const char *gettag(const struct sip_request *req, const char *header, char *tagbuf, int tagbufsize) 
+static const char *gettag(const struct sip_request *req, const char *header, char *tagbuf, int tagbufsize)
 {
 	const char *thetag;
 
@@ -12153,7 +12307,7 @@
 
 /*! \brief  Find all call legs and bridge transferee with target 
  *	called from handle_request_refer */
-int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno)
+static int local_attended_transfer(struct sip_pvt *transferer, struct sip_dual *current, struct sip_request *req, int seqno)
 {
 	struct sip_dual target;		/* Chan 1: Call from tranferer to Asterisk */
 					/* Chan 2: Call from Asterisk to target */
@@ -12720,6 +12874,7 @@
 	transmit_response(p, "202 Accepted", req);
 	return 1;
 }
+
 /*! \brief  Handle incoming SUBSCRIBE request */
 static int handle_request_subscribe(struct sip_pvt *p, struct sip_request *req, struct sockaddr_in *sin, int seqno, char *e)
 {
@@ -13780,7 +13935,7 @@
 }
 
 /*!
-  \brief Handle flag-type options common to users and peers
+  \brief Handle flag-type options common to configuration of devices - users and peers
   \param flags array of two struct ast_flags
   \param mask array of two struct ast_flags
   \param v linked list of config variables to process
@@ -14935,7 +15090,7 @@
 	return 0;
 }
 
-/*! \brief Returns null if we can't reinvite (part of RTP interface) */
+/*! \brief Returns null if we can't reinvite audio (part of RTP interface) */
 static struct ast_rtp *sip_get_rtp_peer(struct ast_channel *chan)
 {
 	struct sip_pvt *p;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:21:28 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:21:28 +0200
Subject: [solid-pbx-svn] r327 - trunk/apps
Message-ID: <200606280021.k5S0LSp5001591@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:20:56 +0200 (Wed, 28 Jun 2006)
New Revision: 327

Modified:
   trunk/apps/app_festival.c
   trunk/apps/app_ices.c
Log:
Update to Asterisk SVN trunk r33523

------------------------------------------------------------------------
r33514 | russell | 2006-06-11 22:46:05 +0200 (Sun, 11 Jun 2006) | 10 lines

Merged revisions 33513 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33513 | russell | 2006-06-11 16:45:06 -0400 (Sun, 11 Jun 2006) | 2 lines

fix a couple places that would leak a frame

.......

------------------------------------------------------------------------
r33516 | russell | 2006-06-11 22:49:16 +0200 (Sun, 11 Jun 2006) | 12 lines

Merged revisions 33515 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33515 | russell | 2006-06-11 16:48:41 -0400 (Sun, 11 Jun 2006) | 4 lines

fix a place that would leak a frame (all of these fixes are in applications
that call ast_read() on a channel but have code paths in them that would not 
free the frame)

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_festival.c
===================================================================
--- trunk/apps/app_festival.c	2006-06-28 00:16:18 UTC (rev 326)
+++ trunk/apps/app_festival.c	2006-06-28 00:20:56 UTC (rev 327)
@@ -242,11 +242,13 @@
 					myf.f.data = myf.frdata;
 					if (ast_write(chan, &myf.f) < 0) {
 						res = -1;
+						ast_frfree(f);
 						break;
 					}
 					if (res < needed) { /* last frame */
 						ast_log(LOG_DEBUG, "Last frame\n");
 						res=0;
+						ast_frfree(f);
 						break;
 					}
 				} else {

Modified: trunk/apps/app_ices.c
===================================================================
--- trunk/apps/app_ices.c	2006-06-28 00:16:18 UTC (rev 326)
+++ trunk/apps/app_ices.c	2006-06-28 00:20:56 UTC (rev 327)
@@ -177,6 +177,7 @@
 					if (errno != EAGAIN) {
 						ast_log(LOG_WARNING, "Write failed to pipe: %s\n", strerror(errno));
 						res = -1;
+						ast_frfree(f);
 						break;
 					}
 				}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:29:12 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:29:12 +0200
Subject: [solid-pbx-svn] r328 - in trunk: . apps include/asterisk
Message-ID: <200606280029.k5S0TCn4002481@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:29:07 +0200 (Wed, 28 Jun 2006)
New Revision: 328

Modified:
   trunk/apps/app_meetme.c
   trunk/include/asterisk/lock.h
   trunk/pbx.c
Log:
Update to Asterisk SVN trunk r33553

------------------------------------------------------------------------
r33546 | russell | 2006-06-11 23:09:08 +0200 (Sun, 11 Jun 2006) | 11 lines

Blocked revisions 33545 via svnmerge

.......
r33545 | russell | 2006-06-11 17:08:04 -0400 (Sun, 11 Jun 2006) | 4 lines

fix up five little places where frames would not be free'd and remove an
unnecessary mutex_unlock where there is no way for it to be locked at
that time

.......

------------------------------------------------------------------------
r33547 | russell | 2006-06-11 23:12:56 +0200 (Sun, 11 Jun 2006) | 3 lines

fix up some places where frames are not free'd and remove an unnecessary
unlock of the confs list where it is not possible for it to be locked

------------------------------------------------------------------------
r33549 | russell | 2006-06-11 23:23:16 +0200 (Sun, 11 Jun 2006) | 10 lines

Merged revisions 33548 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33548 | russell | 2006-06-11 17:21:23 -0400 (Sun, 11 Jun 2006) | 2 lines

fix another place where a frame does not get free'd

.......

------------------------------------------------------------------------
r33550 | russell | 2006-06-11 23:42:13 +0200 (Sun, 11 Jun 2006) | 2 lines

suppress warnings when building with DEBUG_CHANNEL_LOCKS (issue #7330, casper)

------------------------------------------------------------------------


Modified: trunk/apps/app_meetme.c
===================================================================
--- trunk/apps/app_meetme.c	2006-06-28 00:20:56 UTC (rev 327)
+++ trunk/apps/app_meetme.c	2006-06-28 00:29:07 UTC (rev 328)
@@ -1444,16 +1444,19 @@
 					if (!ast_goto_if_exists(chan, exitcontext, tmp, 1)) {
 						ast_log(LOG_DEBUG, "Got DTMF %c, goto context %s\n", tmp[0], exitcontext);
 						ret = 0;
+						ast_frfree(f);
 						break;
 					} else if (option_debug > 1)
 						ast_log(LOG_DEBUG, "Exit by single digit did not work in meetme. Extension %s does not exist in context %s\n", tmp, exitcontext);
 				} else if ((f->frametype == AST_FRAME_DTMF) && (f->subclass == '#') && (confflags & CONFFLAG_POUNDEXIT)) {
 					ret = 0;
+					ast_frfree(f);
 					break;
 				} else if (((f->frametype == AST_FRAME_DTMF) && (f->subclass == '*') && (confflags & CONFFLAG_STARMENU)) || ((f->frametype == AST_FRAME_DTMF) && menu_active)) {
 					if (ioctl(fd, ZT_SETCONF, &ztc_empty)) {
 						ast_log(LOG_WARNING, "Error setting conference\n");
 						close(fd);
+						ast_frfree(f);
 						goto outrun;
 					}
 
@@ -1599,7 +1602,7 @@
 					if (ioctl(fd, ZT_SETCONF, &ztc)) {
 						ast_log(LOG_WARNING, "Error setting conference\n");
 						close(fd);
-						AST_LIST_UNLOCK(&confs);
+						ast_frfree(f);
 						goto outrun;
 					}
 

Modified: trunk/include/asterisk/lock.h
===================================================================
--- trunk/include/asterisk/lock.h	2006-06-28 00:20:56 UTC (rev 327)
+++ trunk/include/asterisk/lock.h	2006-06-28 00:29:07 UTC (rev 328)
@@ -782,6 +782,8 @@
 #define ast_channel_trylock(x)		ast_mutex_trylock(&x->lock)
 #else
 
+struct ast_channel;
+
 /*! \brief Lock AST channel (and print debugging output)
 \note You need to enable DEBUG_CHANNEL_LOCKS for this function */
 int ast_channel_lock(struct ast_channel *chan);

Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-28 00:20:56 UTC (rev 327)
+++ trunk/pbx.c	2006-06-28 00:29:07 UTC (rev 328)
@@ -4456,8 +4456,10 @@
 			break;
 		if (f->frametype == AST_FRAME_CONTROL) {
 			if ((f->subclass == AST_CONTROL_BUSY)  ||
-				(f->subclass == AST_CONTROL_CONGESTION) )
-					break;
+			    (f->subclass == AST_CONTROL_CONGESTION) ) {
+				ast_frfree(f);
+				break;
+			}
 		}
 		ast_frfree(f);
 	}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:29:59 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:29:59 +0200
Subject: [solid-pbx-svn] r329 - trunk/build_tools
Message-ID: <200606280029.k5S0TxrE002625@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:29:55 +0200 (Wed, 28 Jun 2006)
New Revision: 329

Modified:
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r33583

------------------------------------------------------------------------
r33576 | russell | 2006-06-12 00:11:38 +0200 (Mon, 12 Jun 2006) | 4 lines

optimize the display of the module selection menus by only clearing the screen
and starting over if a selection has changed or the menu needs to be scrolled.
For moving the cursor up and down the menu, it works a lot faster now.

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-28 00:29:07 UTC (rev 328)
+++ trunk/build_tools/menuselect_curses.c	2006-06-28 00:29:55 UTC (rev 329)
@@ -67,7 +67,7 @@
 void winch_handler(int sig);
 void show_help(WINDOW *win);
 void draw_main_menu(WINDOW *menu, int curopt);
-void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt);
+void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt, int changed);
 int run_category_menu(WINDOW *menu, int cat_num);
 int run_category_menu(WINDOW *menu, int cat_num);
 void draw_title_window(WINDOW *title);
@@ -122,18 +122,72 @@
 	wrefresh(menu);
 }
 
-void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt)
+void display_mem_info(WINDOW *menu, struct member *mem, int start, int end)
 {
+	char buf[64];
+	struct depend *dep;
+	struct conflict *con;
+
+	wmove(menu, end - start + 2, max_x / 2 - 16);
+	wclrtoeol(menu);
+	wmove(menu, end - start + 3, max_x / 2 - 16);
+	wclrtoeol(menu);
+	wmove(menu, end - start + 4, max_x / 2 - 16);
+	wclrtoeol(menu);
+
+	if (mem->displayname) {
+		wmove(menu, end - start + 2, max_x / 2 - 16);
+		waddstr(menu, mem->displayname);
+	}
+	if (!AST_LIST_EMPTY(&mem->deps)) {
+		wmove(menu, end - start + 3, max_x / 2 - 16);
+		strcpy(buf, "Depends on: ");
+		AST_LIST_TRAVERSE(&mem->deps, dep, list) {
+			strncat(buf, dep->name, sizeof(buf) - strlen(buf) - 1);
+			if (AST_LIST_NEXT(dep, list))
+				strncat(buf, ", ", sizeof(buf) - strlen(buf) - 1);
+		}
+		waddstr(menu, buf);
+	}
+	if (!AST_LIST_EMPTY(&mem->conflicts)) {
+		wmove(menu, end - start + 4, max_x / 2 - 16);
+		strcpy(buf, "Conflicts with: ");
+		AST_LIST_TRAVERSE(&mem->conflicts, con, list) {
+			strncat(buf, con->name, sizeof(buf) - strlen(buf) - 1);
+			if (AST_LIST_NEXT(con, list))
+				strncat(buf, ", ", sizeof(buf) - strlen(buf) - 1);
+		}
+		waddstr(menu, buf);
+	}
+
+}
+
+void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt, int changed)
+{
 	int i = 0;
 	int j = 0;
-	struct member *mem, *curmem = NULL;
-	struct depend *dep;
-	struct conflict *con;
+	struct member *mem;
 	char buf[64];
 	const char *desc = NULL;
 
+	if (!changed) {
+		/* If all we have to do is move the cursor, 
+		 * then don't clear the screen and start over */
+		AST_LIST_TRAVERSE(&cat->members, mem, list) {
+			i++;
+			if (curopt + 1 == i) {
+				display_mem_info(menu, mem, start, end);
+				break;
+			}
+		}
+		wmove(menu, curopt - start, max_x / 2 - 9);
+		wrefresh(menu);
+		return;
+	}
+
 	wclear(menu);
 
+	i = 0;
 	AST_LIST_TRAVERSE(&cat->members, mem, list) {
 		if (i < start) {
 			i++;
@@ -148,38 +202,13 @@
 		waddstr(menu, buf);
 		
 		if (curopt + 1 == i)
-			curmem = mem;
+			display_mem_info(menu, mem, start, end);
 
 		if (i == end)
 			break;
 	}
 
-	if (curmem->displayname) {
-		wmove(menu, end - start + 2, max_x / 2 - 16);
-		waddstr(menu, curmem->displayname);
-	}
-	if (!AST_LIST_EMPTY(&curmem->deps)) {
-		wmove(menu, end - start + 3, max_x / 2 - 16);
-		strcpy(buf, "Depends on: ");
-		AST_LIST_TRAVERSE(&curmem->deps, dep, list) {
-			strncat(buf, dep->name, sizeof(buf) - strlen(buf) - 1);
-			if (AST_LIST_NEXT(dep, list))
-				strncat(buf, ", ", sizeof(buf) - strlen(buf) - 1);
-		}
-		waddstr(menu, buf);
-	}
-	if (!AST_LIST_EMPTY(&curmem->conflicts)) {
-		wmove(menu, end - start + 4, max_x / 2 - 16);
-		strcpy(buf, "Conflicts with: ");
-		AST_LIST_TRAVERSE(&curmem->conflicts, con, list) {
-			strncat(buf, con->name, sizeof(buf) - strlen(buf) - 1);
-			if (AST_LIST_NEXT(con, list))
-				strncat(buf, ", ", sizeof(buf) - strlen(buf) - 1);
-		}
-		waddstr(menu, buf);
-	}
 	wmove(menu, curopt - start, max_x / 2 - 9);
-
 	wrefresh(menu);
 }
 
@@ -192,6 +221,7 @@
 	int c;
 	int curopt = 0;
 	int maxopt;
+	int changed = 1;
 
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		if (i++ == cat_num)
@@ -202,9 +232,10 @@
 
 	maxopt = count_members(cat) - 1;
 
-	draw_category_menu(menu, cat, start, end, curopt);
+	draw_category_menu(menu, cat, start, end, curopt, changed);
 
 	while ((c = getch())) {
+		changed = 0;
 		switch (c) {
 		case KEY_UP:
 			if (curopt > 0) {
@@ -212,6 +243,7 @@
 				if (curopt < start) {
 					start--;
 					end--;
+					changed = 1;
 				}
 			}
 			break;
@@ -221,6 +253,7 @@
 				if (curopt > end - 1) {
 					start++;
 					end++;
+					changed = 1;
 				}
 			}
 			break;
@@ -238,6 +271,7 @@
 		case '\n':
 		case ' ':
 			toggle_enabled(cat, curopt);
+			changed = 1;
 			break;
 		case 'h':
 		case 'H':
@@ -245,15 +279,17 @@
 			break;
 		case KEY_F(7):
 			set_all(cat, 0);
+			changed = 1;
 			break;
 		case KEY_F(8):
 			set_all(cat, 1);
+			changed = 1;
 		default:
 			break;	
 		}
 		if (c == 'x' || c == 'X' || c == 'Q' || c == 'q')
 			break;	
-		draw_category_menu(menu, cat, start, end, curopt);
+		draw_category_menu(menu, cat, start, end, curopt, changed);
 	}
 
 	wrefresh(menu);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:31:40 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:31:40 +0200
Subject: [solid-pbx-svn] r330 - trunk/channels
Message-ID: <200606280031.k5S0VeSb003146@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:31:36 +0200 (Wed, 28 Jun 2006)
New Revision: 330

Modified:
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r33603

------------------------------------------------------------------------
r33595 | file | 2006-06-12 04:54:32 +0200 (Mon, 12 Jun 2006) | 2 lines

Change a bit of logic in peer expiry back to the way it used to be

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 00:29:55 UTC (rev 329)
+++ trunk/channels/chan_iax2.c	2006-06-28 00:31:36 UTC (rev 330)
@@ -5520,9 +5520,6 @@
 	AST_LIST_LOCK(&peers);
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&peers, p, entry) {
 		if (!strcasecmp(p->name, name)) {
-			/* If we are set to auto clear then remove ourselves */
-			if (ast_test_flag(p, IAX_RTAUTOCLEAR))
-				AST_LIST_REMOVE_CURRENT(&peers, entry);
 			p->expire = -1;
 			break;
 		}
@@ -5548,8 +5545,8 @@
 		iax2_regfunk(p->name, 0);
 
 	if (ast_test_flag(p, IAX_RTAUTOCLEAR)) {
-		/* We are already gone from the list, so we can just destroy ourselves */
-		destroy_peer(p);
+		ast_set_flag(p, IAX_DELME);
+		prune_peers();
 	}
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:32:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:32:45 +0200
Subject: [solid-pbx-svn] r331 - in trunk: channels res
Message-ID: <200606280032.k5S0WjWU003421@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:32:39 +0200 (Wed, 28 Jun 2006)
New Revision: 331

Modified:
   trunk/channels/chan_sip.c
   trunk/res/res_agi.c
Log:
Update to Asterisk SVN trunk r33623

------------------------------------------------------------------------
r33614 | oej | 2006-06-12 17:17:18 +0200 (Mon, 12 Jun 2006) | 7 lines

- Remove redundant forward declaration
- Change variable name to make register_verify more readable (p -> peer not pvt in this function)
- Get Contact: header only once instead of twice
- Add some comments to register_verify

Caused by issue #7327... :-)

------------------------------------------------------------------------
r33616 | tilghman | 2006-06-12 17:30:32 +0200 (Mon, 12 Jun 2006) | 12 lines

Merged revisions 33615 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33615 | tilghman | 2006-06-12 10:27:18 -0500 (Mon, 12 Jun 2006) | 4 lines

Move set priority up, because at this point in the code, stdout is no longer
the console.  If we're unable to set priority, the error goes to Asterisk as
if it were an AGI command (issue 7335).

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 00:31:36 UTC (rev 330)
+++ trunk/channels/chan_sip.c	2006-06-28 00:32:39 UTC (rev 331)
@@ -1144,9 +1144,6 @@
 static void free_old_route(struct sip_route *route);
 static void list_route(struct sip_route *route);
 static void build_route(struct sip_pvt *p, struct sip_request *req, int backwards);
-static enum check_auth_result check_auth(struct sip_pvt *p, struct sip_request *req, const char *username,
-					 const char *secret, const char *md5secret, int sipmethod,
-					 char *uri, enum xmittype reliable, int ignore);
 static enum check_auth_result register_verify(struct sip_pvt *p, struct sockaddr_in *sin,
 					      struct sip_request *req, char *uri);
 static struct sip_pvt *get_sip_pvt_byid_locked(const char *callid, const char *totag, const char *fromtag);
@@ -6802,26 +6799,28 @@
 }
 
 
-/*! \brief Parse contact header and save registration */
-static enum parse_register_result parse_register_contact(struct sip_pvt *pvt, struct sip_peer *p, struct sip_request *req)
+/*! \brief Parse contact header and save registration (peer registration) */
+static enum parse_register_result parse_register_contact(struct sip_pvt *pvt, struct sip_peer *peer, struct sip_request *req)
 {
 	char contact[BUFSIZ]; 
 	char data[BUFSIZ];
 	char iabuf[INET_ADDRSTRLEN];
 	const char *expires = get_header(req, "Expires");
 	int expiry = atoi(expires);
-	char *c, *n, *pt;
+	char *curi, *n, *pt;
 	int port;
 	const char *useragent;
 	struct hostent *hp;
 	struct ast_hostent ahp;
 	struct sockaddr_in oldsin;
 
+	ast_copy_string(contact, get_header(req, "Contact"), sizeof(contact));
+
 	if (ast_strlen_zero(expires)) {	/* No expires header */
-		expires = strcasestr(get_header(req, "Contact"), ";expires=");
+		expires = strcasestr(contact, ";expires=");
 		if (expires) {
 			/* XXX bug here, we overwrite the string */
-			expires = strsep((char **)&expires, ";"); /* trim ; and beyond */
+			expires = strsep((char **) &expires, ";"); /* trim ; and beyond */
 			if (sscanf(expires + 9, "%d", &expiry) != 1)
 				expiry = default_expiry;
 		} else {
@@ -6829,57 +6828,61 @@
 			expiry = default_expiry;
 		}
 	}
+
 	/* Look for brackets */
-	ast_copy_string(contact, get_header(req, "Contact"), sizeof(contact));
-	c = contact;
+	curi = contact;
 	if (strchr(contact, '<') == NULL)	/* No <, check for ; and strip it */
-		strsep(&c, ";");	/* This is Header options, not URI options */
-	c = get_in_brackets(contact);
+		strsep(&curi, ";");	/* This is Header options, not URI options */
+	curi = get_in_brackets(contact);
 
 	/* if they did not specify Contact: or Expires:, they are querying
 	   what we currently have stored as their contact address, so return
 	   it
 	*/
-	if (ast_strlen_zero(c) && ast_strlen_zero(expires)) {
+	if (ast_strlen_zero(curi) && ast_strlen_zero(expires)) {
 		/* If we have an active registration, tell them when the registration is going to expire */
-		if (p->expire > -1 && !ast_strlen_zero(p->fullcontact))
-			pvt->expiry = ast_sched_when(sched, p->expire);
+		if (peer->expire > -1 && !ast_strlen_zero(peer->fullcontact))
+			pvt->expiry = ast_sched_when(sched, peer->expire);
 		return PARSE_REGISTER_QUERY;
-	} else if (!strcasecmp(c, "*") || !expiry) {	/* Unregister this peer */
+	} else if (!strcasecmp(curi, "*") || !expiry) {	/* Unregister this peer */
 		/* This means remove all registrations and return OK */
-		memset(&p->addr, 0, sizeof(p->addr));
-		if (p->expire > -1)
-			ast_sched_del(sched, p->expire);
-		p->expire = -1;
+		memset(&peer->addr, 0, sizeof(peer->addr));
+		if (peer->expire > -1)
+			ast_sched_del(sched, peer->expire);
+		peer->expire = -1;
 
-		destroy_association(p);
+		destroy_association(peer);
 		
-		register_peer_exten(p, 0);
-		p->fullcontact[0] = '\0';
-		p->useragent[0] = '\0';
-		p->sipoptions = 0;
-		p->lastms = 0;
+		register_peer_exten(peer, 0);	/* Add extension from regexten= setting in sip.conf */
+		peer->fullcontact[0] = '\0';
+		peer->useragent[0] = '\0';
+		peer->sipoptions = 0;
+		peer->lastms = 0;
 
 		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Unregistered SIP '%s'\n", p->name);
-			manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Unregistered\r\n", p->name);
+			ast_verbose(VERBOSE_PREFIX_3 "Unregistered SIP '%s'\n", peer->name);
+			manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Unregistered\r\n", peer->name);
 		return PARSE_REGISTER_UPDATE;
 	}
-	ast_copy_string(p->fullcontact, c, sizeof(p->fullcontact));
+
+	/* Store whatever we got as a contact from the client */
+	ast_copy_string(peer->fullcontact, curi, sizeof(peer->fullcontact));
+
 	/* For the 200 OK, we should use the received contact */
-	ast_string_field_build(pvt, our_contact, "<%s>", c);
+	ast_string_field_build(pvt, our_contact, "<%s>", curi);
+
 	/* Make sure it's a SIP URL */
-	if (strncasecmp(c, "sip:", 4)) {
-		ast_log(LOG_NOTICE, "'%s' is not a valid SIP contact (missing sip:) trying to use anyway\n", c);
+	if (strncasecmp(curi, "sip:", 4)) {
+		ast_log(LOG_NOTICE, "'%s' is not a valid SIP contact (missing sip:) trying to use anyway\n", curi);
 	} else
-		c += 4;
+		curi += 4;
 	/* Ditch q */
-	c = strsep(&c, ";");
+	curi = strsep(&curi, ";");
 	/* Grab host */
-	n = strchr(c, '@');
+	n = strchr(curi, '@');
 	if (!n) {
-		n = c;
-		c = NULL;
+		n = curi;
+		curi = NULL;
 	} else
 		*n++ = '\0';
 	pt = strchr(n, ':');
@@ -6888,60 +6891,59 @@
 		port = atoi(pt);
 	} else
 		port = DEFAULT_SIP_PORT;
-	oldsin = p->addr;
-	if (!ast_test_flag(&p->flags[0], SIP_NAT_ROUTE)) {
+	oldsin = peer->addr;
+	if (!ast_test_flag(&peer->flags[0], SIP_NAT_ROUTE)) {
 		/* XXX This could block for a long time XXX */
 		hp = ast_gethostbyname(n, &ahp);
 		if (!hp)  {
 			ast_log(LOG_WARNING, "Invalid host '%s'\n", n);
 			return PARSE_REGISTER_FAILED;
 		}
-		p->addr.sin_family = AF_INET;
-		memcpy(&p->addr.sin_addr, hp->h_addr, sizeof(p->addr.sin_addr));
-		p->addr.sin_port = htons(port);
+		peer->addr.sin_family = AF_INET;
+		memcpy(&peer->addr.sin_addr, hp->h_addr, sizeof(peer->addr.sin_addr));
+		peer->addr.sin_port = htons(port);
 	} else {
 		/* Don't trust the contact field.  Just use what they came to us
 		   with */
-		p->addr = pvt->recv;
+		peer->addr = pvt->recv;
 	}
 
 	/* Save SIP options profile */
-	p->sipoptions = pvt->sipoptions;
+	peer->sipoptions = pvt->sipoptions;
 
-	if (c)	/* Overwrite the default username from config at registration */
-		ast_copy_string(p->username, c, sizeof(p->username));
+	if (curi)	/* Overwrite the default username from config at registration */
+		ast_copy_string(peer->username, curi, sizeof(peer->username));
 	else
-		p->username[0] = '\0';
+		peer->username[0] = '\0';
 
-	if (p->expire > -1)
-		ast_sched_del(sched, p->expire);
+	if (peer->expire > -1)
+		ast_sched_del(sched, peer->expire);
 	if (expiry > max_expiry)
 		expiry = max_expiry;
 	if (expiry < min_expiry)
 		expiry = min_expiry;
-	p->expire = ast_test_flag(&p->flags[0], SIP_REALTIME) ? -1 :
-		ast_sched_add(sched, (expiry + 10) * 1000, expire_register, p);
+	peer->expire = ast_test_flag(&peer->flags[0], SIP_REALTIME) ? -1 :
+		ast_sched_add(sched, (expiry + 10) * 1000, expire_register, peer);
 	pvt->expiry = expiry;
-	snprintf(data, sizeof(data), "%s:%d:%d:%s:%s", ast_inet_ntoa(iabuf, sizeof(iabuf), p->addr.sin_addr), ntohs(p->addr.sin_port), expiry, p->username, p->fullcontact);
-	if (!ast_test_flag(&p->flags[1], SIP_PAGE2_RT_FROMCONTACT)) 
-		ast_db_put("SIP/Registry", p->name, data);
-	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", p->name);
-	if (inaddrcmp(&p->addr, &oldsin)) {
-		sip_poke_peer(p);
+	snprintf(data, sizeof(data), "%s:%d:%d:%s:%s", ast_inet_ntoa(iabuf, sizeof(iabuf), peer->addr.sin_addr), ntohs(peer->addr.sin_port), expiry, peer->username, peer->fullcontact);
+	if (!ast_test_flag(&peer->flags[1], SIP_PAGE2_RT_FROMCONTACT)) 
+		ast_db_put("SIP/Registry", peer->name, data);
+	manager_event(EVENT_FLAG_SYSTEM, "PeerStatus", "Peer: SIP/%s\r\nPeerStatus: Registered\r\n", peer->name);
+
+	/* Is this a new IP address for us? */
+	if (inaddrcmp(&peer->addr, &oldsin)) {
+		sip_poke_peer(peer);
 		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Registered SIP '%s' at %s port %d expires %d\n", p->name, ast_inet_ntoa(iabuf, sizeof(iabuf), p->addr.sin_addr), ntohs(p->addr.sin_port), expiry);
-		register_peer_exten(p, 1);
+			ast_verbose(VERBOSE_PREFIX_3 "Registered SIP '%s' at %s port %d expires %d\n", peer->name, ast_inet_ntoa(iabuf, sizeof(iabuf), peer->addr.sin_addr), ntohs(peer->addr.sin_port), expiry);
+		register_peer_exten(peer, 1);
 	}
 	
-	/* Save SIP options profile */
-	p->sipoptions = pvt->sipoptions;
-
 	/* Save User agent */
 	useragent = get_header(req, "User-Agent");
-	if (useragent && strcasecmp(useragent, p->useragent)) {
-		ast_copy_string(p->useragent, useragent, sizeof(p->useragent));
+	if (useragent && strcasecmp(useragent, peer->useragent)) {
+		ast_copy_string(peer->useragent, useragent, sizeof(peer->useragent));
 		if (option_verbose > 3)
-			ast_verbose(VERBOSE_PREFIX_3 "Saved useragent \"%s\" for peer %s\n",p->useragent,p->name);  
+			ast_verbose(VERBOSE_PREFIX_3 "Saved useragent \"%s\" for peer %s\n", peer->useragent, peer->name);  
 	}
 	return PARSE_REGISTER_UPDATE;
 }
@@ -7270,7 +7272,11 @@
 	transmit_response_with_auth(p, "401 Unauthorized", req, p->randdata, reliable, "WWW-Authenticate", 0);
 }
 
-/*! \brief Verify registration of user */
+/*! \brief Verify registration of user 
+	- Registration is done in several steps, first a REGISTER without auth
+	  to get a challenge (nonce) then a second one with auth
+	- Registration requests are only matched with peers that are marked as "dynamic"
+ */
 static enum check_auth_result register_verify(struct sip_pvt *p, struct sockaddr_in *sin,
 					      struct sip_request *req, char *uri)
 {
@@ -7331,6 +7337,9 @@
 			transmit_response(p, "100 Trying", req);
 			if (!(res = check_auth(p, req, peer->name, peer->secret, peer->md5secret, SIP_REGISTER, uri, XMIT_UNRELIABLE, ast_test_flag(req, SIP_PKT_IGNORE)))) {
 				sip_cancel_destroy(p);
+
+				/* We have a succesful registration attemp with proper authentication,
+				   now, update the peer */
 				switch (parse_register_contact(p, peer, req)) {
 				case PARSE_REGISTER_FAILED:
 					ast_log(LOG_WARNING, "Failed to parse contact info\n");

Modified: trunk/res/res_agi.c
===================================================================
--- trunk/res/res_agi.c	2006-06-28 00:31:36 UTC (rev 330)
+++ trunk/res/res_agi.c	2006-06-28 00:32:39 UTC (rev 331)
@@ -309,6 +309,9 @@
 		setenv("AST_KEY_DIR", ast_config_AST_KEY_DIR, 1);
 		setenv("AST_RUN_DIR", ast_config_AST_RUN_DIR, 1);
 
+		/* Don't run AGI scripts with realtime priority -- it causes audio stutter */
+		ast_set_priority(0);
+
 		/* Redirect stdin and out, provide enhanced audio channel if desired */
 		dup2(fromast[0], STDIN_FILENO);
 		dup2(toast[1], STDOUT_FILENO);
@@ -328,9 +331,6 @@
 		for (x=STDERR_FILENO + 2;x<1024;x++) 
 			close(x);
 
-		/* Don't run AGI scripts with realtime priority -- it causes audio stutter */
-		ast_set_priority(0);
-
 		/* Execute script */
 		execv(script, argv);
 		/* Can't use ast_log since FD's are closed */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:33:57 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:33:57 +0200
Subject: [solid-pbx-svn] r332 - trunk/channels
Message-ID: <200606280033.k5S0XvRe003514@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:33:52 +0200 (Wed, 28 Jun 2006)
New Revision: 332

Modified:
   trunk/channels/chan_local.c
Log:
Update to Asterisk SVN trunk r33643

------------------------------------------------------------------------
r33643 | kpfleming | 2006-06-12 18:07:32 +0200 (Mon, 12 Jun 2006) | 10 lines

Merged revisions 33638 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33638 | kpfleming | 2006-06-12 11:03:29 -0500 (Mon, 12 Jun 2006) | 2 lines

only allow chan_local to masquerade the outbound channel onto its owner, instead of the other way around (this will ensure that group variables on the outbound channel as preserved)

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_local.c
===================================================================
--- trunk/channels/chan_local.c	2006-06-28 00:32:39 UTC (rev 331)
+++ trunk/channels/chan_local.c	2006-06-28 00:33:52 UTC (rev 332)
@@ -215,7 +215,13 @@
 		return;
 	if (!p->chan || !p->owner)
 		return;
-	if (isoutbound&& p->chan->_bridge /* Not ast_bridged_channel!  Only go one step! */ && !p->owner->readq) {
+
+	/* only do the masquerade if we are being called on the outbound channel,
+	   if it has been bridged to another channel and if there are no pending
+	   frames on the owner channel (because they would be transferred to the
+	   outbound channel during the masquerade)
+	*/
+	if (isoutbound && p->chan->_bridge /* Not ast_bridged_channel!  Only go one step! */ && !p->owner->readq) {
 		/* Masquerade bridged channel into owner */
 		/* Lock everything we need, one by one, and give up if
 		   we can't get everything.  Remember, we'll get another
@@ -232,6 +238,11 @@
 				ast_mutex_unlock(&(p->chan->_bridge)->lock);
 			}
 		}
+	/* We only allow masquerading in one 'direction'... it's important to preserve the state
+	   (group variables, etc.) that live on p->chan->_bridge (and were put there by the dialplan)
+	   when the local channels go away.
+	*/
+#if 0
 	} else if (!isoutbound && p->owner && p->owner->_bridge && p->chan && !p->chan->readq) {
 		/* Masquerade bridged channel into chan */
 		if (!ast_mutex_trylock(&(p->owner->_bridge)->lock)) {
@@ -246,6 +257,7 @@
 			}
 			ast_mutex_unlock(&(p->owner->_bridge)->lock);
 		}
+#endif
 	}
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:35:37 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:35:37 +0200
Subject: [solid-pbx-svn] r333 - trunk/build_tools
Message-ID: <200606280035.k5S0ZbTn003808@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:35:02 +0200 (Wed, 28 Jun 2006)
New Revision: 333

Modified:
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r33673

------------------------------------------------------------------------
r33669 | russell | 2006-06-12 21:26:40 +0200 (Mon, 12 Jun 2006) | 2 lines

the menu must be redrawn after displaying the help info

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-28 00:33:52 UTC (rev 332)
+++ trunk/build_tools/menuselect_curses.c	2006-06-28 00:35:02 UTC (rev 333)
@@ -276,6 +276,7 @@
 		case 'h':
 		case 'H':
 			show_help(menu);
+			changed = 1;
 			break;
 		case KEY_F(7):
 			set_all(cat, 0);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:37:06 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:37:06 +0200
Subject: [solid-pbx-svn] r334 - trunk/channels
Message-ID: <200606280037.k5S0b6bE004227@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:36:51 +0200 (Wed, 28 Jun 2006)
New Revision: 334

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33683

------------------------------------------------------------------------
r33676 | oej | 2006-06-12 22:01:05 +0200 (Mon, 12 Jun 2006) | 2 lines

Fix typo (Thanks Vechers!)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 00:35:02 UTC (rev 333)
+++ trunk/channels/chan_sip.c	2006-06-28 00:36:51 UTC (rev 334)
@@ -1651,7 +1651,7 @@
 		}
 	} else if (bindaddr.sin_addr.s_addr)
 		*us = bindaddr.sin_addr;
-	return AST_FAILURE;
+	return AST_SUCCESS;
 }
 
 /*! \brief Append to SIP dialog history 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:41:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:41:31 +0200
Subject: [solid-pbx-svn] r335 - in trunk: . channels include/asterisk
Message-ID: <200606280041.k5S0fVjS004682@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:40:26 +0200 (Wed, 28 Jun 2006)
New Revision: 335

Modified:
   trunk/channels/chan_sip.c
   trunk/configure.ac
   trunk/include/asterisk/autoconfig.h.in
Log:
Update to Asterisk SVN trunk r33693

------------------------------------------------------------------------
r33689 | oej | 2006-06-12 22:07:35 +0200 (Mon, 12 Jun 2006) | 2 lines

Formatting fix and doxygen update

------------------------------------------------------------------------
r33690 | tilghman | 2006-06-12 22:21:04 +0200 (Mon, 12 Jun 2006) | 2 lines

Bug 7339 - check for duplication of strnlen function

------------------------------------------------------------------------
r33691 | kpfleming | 2006-06-12 22:33:01 +0200 (Mon, 12 Jun 2006) | 2 lines

bootstrap to include latest configure script change

------------------------------------------------------------------------
r33692 | russell | 2006-06-12 22:36:46 +0200 (Mon, 12 Jun 2006) | 2 lines

update aclocal.m4 as generated by a newer version of aclocal

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 00:36:51 UTC (rev 334)
+++ trunk/channels/chan_sip.c	2006-06-28 00:40:26 UTC (rev 335)
@@ -1614,14 +1614,13 @@
 }
 
 /*! \brief NAT fix - decide which IP address to use for ASterisk server?
- * Only used for outbound registrations */
+ *
+ * Using the localaddr structure built up with localnet statements in sip.conf
+ * apply it to their address to see if we need to substitute our
+ * externip or can get away with our internal bindaddr
+ */
 static enum sip_result ast_sip_ouraddrfor(struct in_addr *them, struct in_addr *us)
 {
-	/*
-	 * Using the localaddr structure built up with localnet statements
-	 * apply it to their address to see if we need to substitute our
-	 * externip or can get away with our internal bindaddr
-	 */
 	struct sockaddr_in theirs, ours;
 
 	/* Get our local information */
@@ -1646,7 +1645,6 @@
 		if (option_debug) {
 			char iabuf[INET_ADDRSTRLEN];
 			ast_inet_ntoa(iabuf, sizeof(iabuf), *(struct in_addr *)&them->s_addr);
-		
 			ast_log(LOG_DEBUG, "Target address %s is not local, substituting externip\n", iabuf);
 		}
 	} else if (bindaddr.sin_addr.s_addr)
@@ -3838,7 +3836,7 @@
 
 	if (sin) {
 		p->sa = *sin;
-		if (ast_sip_ouraddrfor(&p->sa.sin_addr,&p->ourip))
+		if (ast_sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
 			p->ourip = __ourip;
 	} else
 		p->ourip = __ourip;
@@ -13766,7 +13764,7 @@
 	}
 
 	/* Recalculate our side, and recalculate Call ID */
-	if (ast_sip_ouraddrfor(&p->sa.sin_addr,&p->ourip))
+	if (ast_sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
 		p->ourip = __ourip;
 	build_via(p);
 	build_callid_pvt(p);
@@ -13916,7 +13914,7 @@
 	if (ast_strlen_zero(p->peername) && ext)
 		ast_string_field_set(p, peername, ext);
 	/* Recalculate our side, and recalculate Call ID */
-	if (ast_sip_ouraddrfor(&p->sa.sin_addr,&p->ourip))
+	if (ast_sip_ouraddrfor(&p->sa.sin_addr, &p->ourip))
 		p->ourip = __ourip;
 	build_via(p);
 	build_callid_pvt(p);

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-28 00:36:51 UTC (rev 334)
+++ trunk/configure.ac	2006-06-28 00:40:26 UTC (rev 335)
@@ -660,7 +660,7 @@
 AC_FUNC_STRTOD
 AC_FUNC_UTIME_NULL
 AC_FUNC_VPRINTF
-AC_CHECK_FUNCS([atexit bzero dup2 endpwent floor ftruncate getcwd gethostbyname gethostname gettimeofday inet_ntoa isascii localtime_r memchr memmove memset mkdir munmap pow putenv re_comp regcomp rint select setenv socket sqrt strcasecmp strchr strcspn strdup strerror strncasecmp strndup strrchr strsep strspn strstr strtol unsetenv utime strtoq strcasestr asprintf vasprintf])
+AC_CHECK_FUNCS([atexit bzero dup2 endpwent floor ftruncate getcwd gethostbyname gethostname gettimeofday inet_ntoa isascii localtime_r memchr memmove memset mkdir munmap pow putenv re_comp regcomp rint select setenv socket sqrt strcasecmp strchr strcspn strdup strerror strncasecmp strndup strnlen strrchr strsep strspn strstr strtol unsetenv utime strtoq strcasestr asprintf vasprintf])
 
 AC_CONFIG_FILES([build_tools/menuselect-deps makeopts])
 AC_OUTPUT

Modified: trunk/include/asterisk/autoconfig.h.in
===================================================================
--- trunk/include/asterisk/autoconfig.h.in	2006-06-28 00:36:51 UTC (rev 334)
+++ trunk/include/asterisk/autoconfig.h.in	2006-06-28 00:40:26 UTC (rev 335)
@@ -314,6 +314,9 @@
 /* Define to 1 if you have the `strndup' function. */
 #undef HAVE_STRNDUP
 
+/* Define to 1 if you have the `strnlen' function. */
+#undef HAVE_STRNLEN
+
 /* Define to 1 if you have the `strrchr' function. */
 #undef HAVE_STRRCHR
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:47:27 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:47:27 +0200
Subject: [solid-pbx-svn] r336 - trunk/res
Message-ID: <200606280047.k5S0lRTd005850@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:47:20 +0200 (Wed, 28 Jun 2006)
New Revision: 336

Modified:
   trunk/res/res_agi.c
Log:
Update to Asterisk SVN trunk r33703

------------------------------------------------------------------------
r33694 | russell | 2006-06-12 22:40:56 +0200 (Mon, 12 Jun 2006) | 10 lines

Merged revisions 33693 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33693 | russell | 2006-06-12 16:40:11 -0400 (Mon, 12 Jun 2006) | 2 lines

fix a place where a frame would be free'd twice

.......

------------------------------------------------------------------------


Modified: trunk/res/res_agi.c
===================================================================
--- trunk/res/res_agi.c	2006-06-28 00:40:26 UTC (rev 335)
+++ trunk/res/res_agi.c	2006-06-28 00:47:20 UTC (rev 336)
@@ -1007,7 +1007,6 @@
                                         }
                                         if (totalsilence > silence) {
                                              /* Ended happily with silence */
-                                        	ast_frfree(f);
                                                 gotsilence = 1;
                                                 break;
                                         }



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:49:00 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:49:00 +0200
Subject: [solid-pbx-svn] r337 - trunk/channels
Message-ID: <200606280049.k5S0n0U9006131@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:48:50 +0200 (Wed, 28 Jun 2006)
New Revision: 337

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33713

------------------------------------------------------------------------
r33706 | russell | 2006-06-12 23:01:48 +0200 (Mon, 12 Jun 2006) | 5 lines

only set the QOS variables if the pvt has an owner so that they are not
created as global variables.  (The fact that these were getting created on
my system probably means that these are in the wrong place so oej, you may
want to look at this again.)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 00:47:20 UTC (rev 336)
+++ trunk/channels/chan_sip.c	2006-06-28 00:48:50 UTC (rev 337)
@@ -3132,9 +3132,9 @@
 					if (p->vrtp)
 						append_history(p, "RTCPvideo", "Quality:%s", videoqos);
 				}
-				if (p->rtp)
+				if (p->rtp && p->owner)
 					pbx_builtin_setvar_helper(p->owner, "RTPAUDIOQOS", audioqos);
-				if (p->vrtp)
+				if (p->vrtp && p->owner)
 					pbx_builtin_setvar_helper(p->owner, "RTPVIDEOQOS", videoqos);
 			} else {
 				/* Note we will need a BYE when this all settles out



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:50:03 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:50:03 +0200
Subject: [solid-pbx-svn] r338 - in trunk: . apps include/asterisk
Message-ID: <200606280050.k5S0o33X006192@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:49:47 +0200 (Wed, 28 Jun 2006)
New Revision: 338

Modified:
   trunk/apps/app_mixmonitor.c
   trunk/channel.c
   trunk/include/asterisk/chanspy.h
Log:
Update to Asterisk SVN trunk r33733

------------------------------------------------------------------------
r33725 | file | 2006-06-12 23:37:29 +0200 (Mon, 12 Jun 2006) | 10 lines

Merged revisions 33724 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33724 | file | 2006-06-12 18:34:38 -0300 (Mon, 12 Jun 2006) | 2 lines

Greatly simply the mixmonitor thread, and move channel reference directly to spy structure so that the core can modify it.

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_mixmonitor.c
===================================================================
--- trunk/apps/app_mixmonitor.c	2006-06-28 00:48:50 UTC (rev 337)
+++ trunk/apps/app_mixmonitor.c	2006-06-28 00:49:47 UTC (rev 338)
@@ -92,12 +92,11 @@
 static const char *mixmonitor_spy_type = "MixMonitor";
 
 struct mixmonitor {
-	struct ast_channel *chan;
-	char *filename;
+	struct ast_channel_spy *spy;
+	struct ast_filestream *fs;
 	char *post_process;
+	char *name;
 	unsigned int flags;
-	int readvol;
-	int writevol;
 };
 
 enum {
@@ -123,18 +122,20 @@
 	AST_APP_OPTION_ARG('W', MUXFLAG_VOLUME, OPT_ARG_VOLUME),
 });
 
-static void stopmon(struct ast_channel *chan, struct ast_channel_spy *spy) 
+static void stopmon(struct ast_channel_spy *spy) 
 {
+	struct ast_channel *chan = spy->chan;
+
 	/* If our status has changed to DONE, then the channel we're spying on is gone....
 	   DON'T TOUCH IT!!!  RUN AWAY!!! */
 	if (spy->status == CHANSPY_DONE)
 		return;
-
+  
 	if (!chan)
 		return;
 
 	ast_channel_lock(chan);
-	ast_channel_spy_remove(chan, spy);
+	ast_channel_spy_remove(spy->chan, spy);
 	ast_channel_unlock(chan);
 }
 
@@ -149,7 +150,7 @@
 	ast_channel_lock(chan);
 	res = ast_channel_spy_add(chan, spy);
 	ast_channel_unlock(chan);
-		
+
 	if (!res && ast_test_flag(chan, AST_FLAG_NBRIDGE) && (peer = ast_bridged_channel(chan)))
 		ast_softhangup(peer, AST_SOFTHANGUP_UNBRIDGE);	
 
@@ -161,91 +162,31 @@
 static void *mixmonitor_thread(void *obj) 
 {
 	struct mixmonitor *mixmonitor = obj;
-	struct ast_channel_spy spy;
-	struct ast_filestream *fs = NULL;
-	char *ext, *name;
-	unsigned int oflags;
-	struct ast_frame *f;
-	char post_process[1024] = "";
+	struct ast_frame *f = NULL;
 	
 	ast_atomic_fetchadd_int(&__mod_desc->usecnt, +1);
-
-	name = ast_strdupa(mixmonitor->chan->name);
-
-	oflags = O_CREAT|O_WRONLY;
-	oflags |= ast_test_flag(mixmonitor, MUXFLAG_APPEND) ? O_APPEND : O_TRUNC;
-		
-	if ((ext = strrchr(mixmonitor->filename, '.'))) {
-		*(ext++) = '\0';
-	} else {
-		ext = "raw";
-	}
-
-	fs = ast_writefile(mixmonitor->filename, ext, NULL, oflags, 0, 0644);
-	if (!fs) {
-		ast_log(LOG_ERROR, "Cannot open %s.%s\n", mixmonitor->filename, ext);
-		goto out;
-	}
-
-	if (ast_test_flag(mixmonitor, MUXFLAG_APPEND))
-		ast_seekstream(fs, 0, SEEK_END);
 	
-	memset(&spy, 0, sizeof(spy));
-	ast_set_flag(&spy, CHANSPY_FORMAT_AUDIO);
-	ast_set_flag(&spy, CHANSPY_MIXAUDIO);
-	spy.type = mixmonitor_spy_type;
-	spy.status = CHANSPY_RUNNING;
-	spy.read_queue.format = AST_FORMAT_SLINEAR;
-	spy.write_queue.format = AST_FORMAT_SLINEAR;
-	if (mixmonitor->readvol) {
-		ast_set_flag(&spy, CHANSPY_READ_VOLADJUST);
-		spy.read_vol_adjustment = mixmonitor->readvol;
-	}
-	if (mixmonitor->writevol) {
-		ast_set_flag(&spy, CHANSPY_WRITE_VOLADJUST);
-		spy.write_vol_adjustment = mixmonitor->writevol;
-	}
-	ast_mutex_init(&spy.lock);
-
-	if (startmon(mixmonitor->chan, &spy)) {
-		ast_log(LOG_WARNING, "Unable to add '%s' spy to channel '%s'\n",
-			spy.type, mixmonitor->chan->name);
-		goto out2;
-	}
-
 	if (option_verbose > 1)
-		ast_verbose(VERBOSE_PREFIX_2 "Begin MixMonitor Recording %s\n", name);
+		ast_verbose(VERBOSE_PREFIX_2 "Begin MixMonitor Recording %s\n", mixmonitor->name);
 	
-	if (mixmonitor->post_process) {
-		char *p;
+	ast_mutex_lock(&mixmonitor->spy->lock);
 
-		for (p = mixmonitor->post_process; *p ; p++) {
-			if (*p == '^' && *(p+1) == '{') {
-				*p = '$';
-			}
-		}
-		pbx_substitute_variables_helper(mixmonitor->chan, mixmonitor->post_process, post_process, sizeof(post_process) - 1);
-	}
-
-	while (1) {
-		struct ast_frame *next;
+	while (mixmonitor->spy->chan) {
+		struct ast_frame *next = NULL;
 		int write;
 
-		ast_mutex_lock(&spy.lock);
-
-		ast_channel_spy_trigger_wait(&spy);
+		ast_channel_spy_trigger_wait(mixmonitor->spy);
 		
-		if (ast_check_hangup(mixmonitor->chan) || spy.status != CHANSPY_RUNNING) {
-			ast_mutex_unlock(&spy.lock);
+		if (!mixmonitor->spy->chan || mixmonitor->spy->status != CHANSPY_RUNNING) {
 			break;
 		}
 		
 		while (1) {
-			if (!(f = ast_channel_spy_read_frame(&spy, SAMPLES_PER_FRAME)))
+			if (!(f = ast_channel_spy_read_frame(mixmonitor->spy, SAMPLES_PER_FRAME)))
 				break;
 
 			write = (!ast_test_flag(mixmonitor, MUXFLAG_BRIDGED) ||
-				 ast_bridged_channel(mixmonitor->chan));
+				 ast_bridged_channel(mixmonitor->spy->chan));
 
 			/* it is possible for ast_channel_spy_read_frame() to return a chain
 			   of frames if a queue flush was necessary, so process them
@@ -253,32 +194,33 @@
 			for (; f; f = next) {
 				next = f->next;
 				if (write)
-					ast_writestream(fs, f);
+					ast_writestream(mixmonitor->fs, f);
 				ast_frfree(f);
 			}
 		}
+	}
 
-		ast_mutex_unlock(&spy.lock);
-	}
+	ast_mutex_unlock(&mixmonitor->spy->lock);
 	
-	stopmon(mixmonitor->chan, &spy);
+	stopmon(mixmonitor->spy);
 
 	if (option_verbose > 1)
-		ast_verbose(VERBOSE_PREFIX_2 "End MixMonitor Recording %s\n", name);
+		ast_verbose(VERBOSE_PREFIX_2 "End MixMonitor Recording %s\n", mixmonitor->name);
 
-	if (!ast_strlen_zero(post_process)) {
+	if (!ast_strlen_zero(mixmonitor->post_process)) {
 		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_2 "Executing [%s]\n", post_process);
-		ast_safe_system(post_process);
+			ast_verbose(VERBOSE_PREFIX_2 "Executing [%s]\n", mixmonitor->post_process);
+		ast_safe_system(mixmonitor->post_process);
 	}
 
-out2:
-	ast_mutex_destroy(&spy.lock);
+	ast_mutex_destroy(&mixmonitor->spy->lock);
+		
+	ast_closestream(mixmonitor->fs);
 
-	if (fs)
-		ast_closestream(fs);
-
-out:
+	/* Deallocate everything */
+	free(mixmonitor->spy);
+	free(mixmonitor->post_process);
+	free(mixmonitor->name);
 	free(mixmonitor);
 
 	ast_atomic_fetchadd_int(&__mod_desc->usecnt, -1);
@@ -292,31 +234,92 @@
 	pthread_attr_t attr;
 	pthread_t thread;
 	struct mixmonitor *mixmonitor;
-	int len;
+	char *file_name, *postprocess, *ext, postprocess2[1024] = "";
+	unsigned int oflags;
 
-	len = sizeof(*mixmonitor) + strlen(filename) + 1;
-	if (!ast_strlen_zero(post_process))
-		len += strlen(post_process) + 1;
+	if (!(mixmonitor = ast_calloc(1, sizeof(*mixmonitor)))) {
+		ast_log(LOG_ERROR, "Memory Error!\n");
+		return;
+	}
 
-	if (!(mixmonitor = ast_calloc(1, len))) {
+	if (!(mixmonitor->spy = ast_calloc(1, sizeof(*mixmonitor->spy)))) {
+                ast_log(LOG_ERROR, "Memory Error!\n");
+		free(mixmonitor);
+                return;
+        }
+
+	/* Copy over flags and channel name */
+	mixmonitor->flags = flags;
+	mixmonitor->name = ast_strdup(chan->name);
+
+	/* Determine creation flags and filename plus extension for filestream */
+	oflags = O_CREAT | O_WRONLY;
+	oflags |= ast_test_flag(mixmonitor, MUXFLAG_APPEND) ? O_APPEND : O_TRUNC;
+	file_name = ast_strdupa(filename);
+	if ((ext = strrchr(file_name, '.'))) {
+		*(ext++) = '\0';
+	} else {
+		ext = "raw";
+	}
+
+	/* Move onto actually creating the filestream */
+	mixmonitor->fs = ast_writefile(file_name, ext, NULL, oflags, 0, 0644);
+	if (!mixmonitor->fs) {
+		ast_log(LOG_ERROR, "Cannot open %s.%s\n", file_name, ext);
+		free(mixmonitor->name);
+		free(mixmonitor->spy);
+		free(mixmonitor);
 		return;
 	}
 
-	mixmonitor->chan = chan;
-	mixmonitor->filename = (char *) mixmonitor + sizeof(*mixmonitor);
-	strcpy(mixmonitor->filename, filename);
+	/* If a post process system command is given attach it to the structure */
 	if (!ast_strlen_zero(post_process)) {
-		mixmonitor->post_process = mixmonitor->filename + strlen(filename) + 1;
-		strcpy(mixmonitor->post_process, post_process);
+		char *p = NULL;
+		postprocess = ast_strdupa(post_process);
+		for (p = postprocess; *p ; p++) {
+			if (*p == '^' && *(p+1) == '{') {
+				*p = '$';
+			}
+		}
+		pbx_substitute_variables_helper(chan, postprocess, postprocess2, sizeof(postprocess2) - 1);
+		mixmonitor->post_process = strdup(postprocess2);
 	}
-	mixmonitor->readvol = readvol;
-	mixmonitor->writevol = writevol;
-	mixmonitor->flags = flags;
 
+	/* Setup the actual spy before creating our thread */
+	ast_set_flag(mixmonitor->spy, CHANSPY_FORMAT_AUDIO);
+	ast_set_flag(mixmonitor->spy, CHANSPY_MIXAUDIO);
+	mixmonitor->spy->type = mixmonitor_spy_type;
+	mixmonitor->spy->status = CHANSPY_RUNNING;
+	mixmonitor->spy->read_queue.format = AST_FORMAT_SLINEAR;
+	mixmonitor->spy->write_queue.format = AST_FORMAT_SLINEAR;
+	if (readvol) {
+		ast_set_flag(mixmonitor->spy, CHANSPY_READ_VOLADJUST);
+		mixmonitor->spy->read_vol_adjustment = readvol;
+	}
+	if (writevol) {
+		ast_set_flag(mixmonitor->spy, CHANSPY_WRITE_VOLADJUST);
+		mixmonitor->spy->write_vol_adjustment = writevol;
+	}
+	ast_mutex_init(&mixmonitor->spy->lock);
+
+	if (startmon(chan, mixmonitor->spy)) {
+		ast_log(LOG_WARNING, "Unable to add '%s' spy to channel '%s'\n",
+			mixmonitor->spy->type, chan->name);
+		/* Since we couldn't add ourselves - bail out! */
+		ast_mutex_destroy(&mixmonitor->spy->lock);
+		free(mixmonitor->post_process);
+		ast_closestream(mixmonitor->fs);
+		free(mixmonitor->name);
+		free(mixmonitor->spy);
+		free(mixmonitor);
+		return;
+	}
+
 	pthread_attr_init(&attr);
 	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
 	ast_pthread_create(&thread, &attr, mixmonitor_thread, mixmonitor);
 	pthread_attr_destroy(&attr);
+
 }
 
 static int mixmonitor_exec(struct ast_channel *chan, void *data)

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-28 00:48:50 UTC (rev 337)
+++ trunk/channel.c	2006-06-28 00:49:47 UTC (rev 338)
@@ -1124,6 +1124,9 @@
 
 int ast_channel_spy_add(struct ast_channel *chan, struct ast_channel_spy *spy)
 {
+	/* Link the owner channel to the spy */
+	spy->chan = chan;
+
 	if (!ast_test_flag(spy, CHANSPY_FORMAT_AUDIO)) {
 		ast_log(LOG_WARNING, "Could not add channel spy '%s' to channel '%s', only audio format spies are supported.\n",
 			spy->type, chan->name);
@@ -1193,7 +1196,14 @@
 
 void ast_channel_spy_trigger_wait(struct ast_channel_spy *spy)
 {
-	ast_cond_wait(&spy->trigger, &spy->lock);
+	struct timeval tv;
+	struct timespec ts;
+
+	tv = ast_tvadd(ast_tvnow(), ast_samp2tv(50000, 1000));
+	ts.tv_sec = tv.tv_sec;
+	ts.tv_nsec = tv.tv_usec * 1000;
+
+	ast_cond_timedwait(&spy->trigger, &spy->lock, &ts);
 }
 
 void ast_channel_spy_remove(struct ast_channel *chan, struct ast_channel_spy *spy)
@@ -1207,6 +1217,8 @@
 
 	ast_mutex_lock(&spy->lock);
 
+	spy->chan = NULL;
+
 	for (f = spy->read_queue.head; f; f = spy->read_queue.head) {
 		spy->read_queue.head = f->next;
 		ast_frfree(f);
@@ -1244,6 +1256,7 @@
 	/* Marking the spies as done is sufficient.  Chanspy or spy users will get the picture. */
 	AST_LIST_TRAVERSE(&chan->spies->list, spy, list) {
 		ast_mutex_lock(&spy->lock);
+		spy->chan = NULL;
 		if (spy->status == CHANSPY_RUNNING)
 			spy->status = CHANSPY_DONE;
 		if (ast_test_flag(spy, CHANSPY_TRIGGER_MODE) != CHANSPY_TRIGGER_NONE)

Modified: trunk/include/asterisk/chanspy.h
===================================================================
--- trunk/include/asterisk/chanspy.h	2006-06-28 00:48:50 UTC (rev 337)
+++ trunk/include/asterisk/chanspy.h	2006-06-28 00:49:47 UTC (rev 338)
@@ -58,6 +58,7 @@
 	AST_LIST_ENTRY(ast_channel_spy) list;
 	ast_mutex_t lock;
 	ast_cond_t trigger;
+	struct ast_channel *chan;
 	struct ast_channel_spy_queue read_queue;
 	struct ast_channel_spy_queue write_queue;
 	unsigned int flags;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:51:00 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:51:00 +0200
Subject: [solid-pbx-svn] r339 - trunk
Message-ID: <200606280051.k5S0p0nV006251@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:50:53 +0200 (Wed, 28 Jun 2006)
New Revision: 339

Modified:
   trunk/asterisk.c
Log:
Update to Asterisk SVN trunk r33763

------------------------------------------------------------------------
r33754 | russell | 2006-06-13 05:56:09 +0200 (Tue, 13 Jun 2006) | 13 lines

Merged revisions 33753 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33753 | russell | 2006-06-12 23:55:11 -0400 (Mon, 12 Jun 2006) | 5 lines

revert a change that caused more problems than it fixed and fix the real
problem in this code.  fds was declared as an array of zero size which caused
some weird problems, some of which would only be seen when compiling without
optimizations.  (fixes issues #7071, #7326, and #7305)

.......

------------------------------------------------------------------------


Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-28 00:49:47 UTC (rev 338)
+++ trunk/asterisk.c	2006-06-28 00:50:53 UTC (rev 339)
@@ -2092,17 +2092,12 @@
 
 	if (ast_opt_exec && data) {  /* hack to print output then exit if asterisk -rx is used */
 		char tempchar;
-#ifdef __Darwin__
-		struct pollfd fds[0];
-		fds[0].fd = ast_consock;
-		fds[0].events = POLLIN;
-		fds[0].revents = 0;
-		while (poll(fds, 1, 100) > 0) {
+		struct pollfd fds;
+		fds.fd = ast_consock;
+		fds.events = POLLIN;
+		fds.revents = 0;
+		while (poll(&fds, 1, 100) > 0)
 			ast_el_read_char(el, &tempchar);
-		}
-#else
-		while (!ast_el_read_char(el, &tempchar));
-#endif
 		return;
 	}
 	for (;;) {



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:51:39 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:51:39 +0200
Subject: [solid-pbx-svn] r340 - trunk/apps
Message-ID: <200606280051.k5S0pdW3006302@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:51:34 +0200 (Wed, 28 Jun 2006)
New Revision: 340

Modified:
   trunk/apps/app_festival.c
Log:
Update to Asterisk SVN trunk r33783

------------------------------------------------------------------------
r33782 | russell | 2006-06-13 06:21:10 +0200 (Tue, 13 Jun 2006) | 11 lines

Merged revisions 33781 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33781 | russell | 2006-06-13 00:20:10 -0400 (Tue, 13 Jun 2006) | 3 lines

add a missing close of an open fd, destroy of open config, and removal of the
calling channel from the localusers list

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_festival.c
===================================================================
--- trunk/apps/app_festival.c	2006-06-28 00:50:53 UTC (rev 339)
+++ trunk/apps/app_festival.c	2006-06-28 00:51:34 UTC (rev 340)
@@ -491,6 +491,9 @@
                        if ( read_data == -1 )
                        {
                                ast_log(LOG_WARNING,"Unable to read from cache/festival fd");
+			       close(fd);
+			       ast_config_destroy(cfg);
+			       LOCAL_USER_REMOVE(u);
                                return -1;
                        }
                        n += read_data;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:56:25 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:56:25 +0200
Subject: [solid-pbx-svn] r341 - trunk/apps
Message-ID: <200606280056.k5S0uPkk007298@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:56:09 +0200 (Wed, 28 Jun 2006)
New Revision: 341

Modified:
   trunk/apps/app_playback.c
   trunk/apps/app_voicemail.c
Log:
Update to Asterisk SVN trunk r33793

------------------------------------------------------------------------
r33784 | russell | 2006-06-13 06:32:45 +0200 (Tue, 13 Jun 2006) | 10 lines

Blocked revisions 33783 via svnmerge

.......
r33783 | russell | 2006-06-13 00:31:19 -0400 (Tue, 13 Jun 2006) | 3 lines

fix various places where the code returns without unlocking vmlock or
destroying loaded configuration

.......

------------------------------------------------------------------------
r33785 | russell | 2006-06-13 06:37:36 +0200 (Tue, 13 Jun 2006) | 3 lines

fix a place where code returns without unlocking the vm users list and various
places where code returns without destroying loaded configuration

------------------------------------------------------------------------
r33786 | russell | 2006-06-13 06:40:15 +0200 (Tue, 13 Jun 2006) | 2 lines

destroy the loaded say.conf on module unload

------------------------------------------------------------------------


Modified: trunk/apps/app_playback.c
===================================================================
--- trunk/apps/app_playback.c	2006-06-28 00:51:34 UTC (rev 340)
+++ trunk/apps/app_playback.c	2006-06-28 00:56:09 UTC (rev 341)
@@ -472,6 +472,9 @@
 
 	STANDARD_HANGUP_LOCALUSERS;
 
+	if (say_cfg)
+		ast_config_destroy(say_cfg);
+
 	return res;	
 }
 

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 00:51:34 UTC (rev 340)
+++ trunk/apps/app_voicemail.c	2006-06-28 00:56:09 UTC (rev 341)
@@ -6456,6 +6456,8 @@
 							}
 						} else {
 							free(z);
+							AST_LIST_UNLOCK(&users);
+							ast_config_destroy(cfg);
 							return -1;
 						}
 						var = var->next;
@@ -6710,8 +6712,10 @@
 		return 0;
 	}
 
-	if (!(origtime = ast_variable_retrieve(msg_cfg, "message", "origtime")))
+	if (!(origtime = ast_variable_retrieve(msg_cfg, "message", "origtime"))) {
+		ast_config_destroy(msg_cfg);
 		return 0;
+	}
 
 	cid = ast_variable_retrieve(msg_cfg, "message", "callerid");
 
@@ -6719,6 +6723,8 @@
 	if (!strncasecmp("macro",context,5)) /* Macro names in contexts are useless for our needs */
 		context = ast_variable_retrieve(msg_cfg, "message","macrocontext");
 
+	ast_config_destroy(msg_cfg);
+
 	switch (option) {
 	case 3:
 		if (!res)
@@ -6856,8 +6862,6 @@
 		break;
 	}
 
-	ast_config_destroy(msg_cfg);
-
 	if (!res) {
 		make_file(vms->fn, sizeof(vms->fn), vms->curdir, msg);
 		vms->heard[msg] = 1;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:57:26 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:57:26 +0200
Subject: [solid-pbx-svn] r342 - trunk
Message-ID: <200606280057.k5S0vQHY007797@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:57:20 +0200 (Wed, 28 Jun 2006)
New Revision: 342

Modified:
   trunk/pbx.c
Log:
Update to Asterisk SVN trunk r33823

------------------------------------------------------------------------
r33814 | russell | 2006-06-13 14:41:37 +0200 (Tue, 13 Jun 2006) | 10 lines

Merged revisions 33813 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33813 | russell | 2006-06-13 08:40:40 -0400 (Tue, 13 Jun 2006) | 2 lines

remove duplicate mutex_unlock

.......

------------------------------------------------------------------------


Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-28 00:56:09 UTC (rev 341)
+++ trunk/pbx.c	2006-06-28 00:57:20 UTC (rev 342)
@@ -3430,7 +3430,6 @@
 
 	for (tmp = *local_contexts; tmp; tmp = tmp->next) {
 		if (!strcasecmp(tmp->name, name)) {
-			ast_mutex_unlock(&conlock);
 			ast_log(LOG_WARNING, "Tried to register context '%s', already in use\n", name);
 			if (!extcontexts)
 				ast_mutex_unlock(&conlock);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 02:58:29 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 02:58:29 +0200
Subject: [solid-pbx-svn] r343 - trunk/apps
Message-ID: <200606280058.k5S0wTGk008007@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 02:58:21 +0200 (Wed, 28 Jun 2006)
New Revision: 343

Modified:
   trunk/apps/app_mixmonitor.c
Log:
Update to Asterisk SVN trunk r33843

------------------------------------------------------------------------
r33842 | kpfleming | 2006-06-13 15:40:58 +0200 (Tue, 13 Jun 2006) | 10 lines

Merged revisions 33841 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33841 | kpfleming | 2006-06-13 08:30:06 -0500 (Tue, 13 Jun 2006) | 2 lines

memory allocation optimizations

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_mixmonitor.c
===================================================================
--- trunk/apps/app_mixmonitor.c	2006-06-28 00:57:20 UTC (rev 342)
+++ trunk/apps/app_mixmonitor.c	2006-06-28 00:58:21 UTC (rev 343)
@@ -92,7 +92,7 @@
 static const char *mixmonitor_spy_type = "MixMonitor";
 
 struct mixmonitor {
-	struct ast_channel_spy *spy;
+	struct ast_channel_spy spy;
 	struct ast_filestream *fs;
 	char *post_process;
 	char *name;
@@ -135,7 +135,7 @@
 		return;
 
 	ast_channel_lock(chan);
-	ast_channel_spy_remove(spy->chan, spy);
+	ast_channel_spy_remove(chan, spy);
 	ast_channel_unlock(chan);
 }
 
@@ -169,24 +169,24 @@
 	if (option_verbose > 1)
 		ast_verbose(VERBOSE_PREFIX_2 "Begin MixMonitor Recording %s\n", mixmonitor->name);
 	
-	ast_mutex_lock(&mixmonitor->spy->lock);
+	ast_mutex_lock(&mixmonitor->spy.lock);
 
-	while (mixmonitor->spy->chan) {
-		struct ast_frame *next = NULL;
+	while (mixmonitor->spy.chan) {
+		struct ast_frame *next;
 		int write;
 
-		ast_channel_spy_trigger_wait(mixmonitor->spy);
+		ast_channel_spy_trigger_wait(&mixmonitor->spy);
 		
-		if (!mixmonitor->spy->chan || mixmonitor->spy->status != CHANSPY_RUNNING) {
+		if (!mixmonitor->spy.chan || mixmonitor->spy.status != CHANSPY_RUNNING) {
 			break;
 		}
 		
 		while (1) {
-			if (!(f = ast_channel_spy_read_frame(mixmonitor->spy, SAMPLES_PER_FRAME)))
+			if (!(f = ast_channel_spy_read_frame(&mixmonitor->spy, SAMPLES_PER_FRAME)))
 				break;
 
 			write = (!ast_test_flag(mixmonitor, MUXFLAG_BRIDGED) ||
-				 ast_bridged_channel(mixmonitor->spy->chan));
+				 ast_bridged_channel(mixmonitor->spy.chan));
 
 			/* it is possible for ast_channel_spy_read_frame() to return a chain
 			   of frames if a queue flush was necessary, so process them
@@ -200,27 +200,23 @@
 		}
 	}
 
-	ast_mutex_unlock(&mixmonitor->spy->lock);
+	ast_mutex_unlock(&mixmonitor->spy.lock);
 	
-	stopmon(mixmonitor->spy);
+	stopmon(&mixmonitor->spy);
 
 	if (option_verbose > 1)
 		ast_verbose(VERBOSE_PREFIX_2 "End MixMonitor Recording %s\n", mixmonitor->name);
 
-	if (!ast_strlen_zero(mixmonitor->post_process)) {
+	if (mixmonitor->post_process) {
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_2 "Executing [%s]\n", mixmonitor->post_process);
 		ast_safe_system(mixmonitor->post_process);
 	}
 
-	ast_mutex_destroy(&mixmonitor->spy->lock);
+	ast_mutex_destroy(&mixmonitor->spy.lock);
 		
 	ast_closestream(mixmonitor->fs);
 
-	/* Deallocate everything */
-	free(mixmonitor->spy);
-	free(mixmonitor->post_process);
-	free(mixmonitor->name);
 	free(mixmonitor);
 
 	ast_atomic_fetchadd_int(&__mod_desc->usecnt, -1);
@@ -234,23 +230,42 @@
 	pthread_attr_t attr;
 	pthread_t thread;
 	struct mixmonitor *mixmonitor;
-	char *file_name, *postprocess, *ext, postprocess2[1024] = "";
+	char *file_name, *ext;
+	char postprocess2[1024] = "";
 	unsigned int oflags;
+	size_t len;
 
-	if (!(mixmonitor = ast_calloc(1, sizeof(*mixmonitor)))) {
-		ast_log(LOG_ERROR, "Memory Error!\n");
+	len = sizeof(*mixmonitor) + strlen(chan->name) + 1;
+
+	/* If a post process system command is given attach it to the structure */
+	if (!ast_strlen_zero(post_process)) {
+		char *p1, *p2;
+
+		p1 = ast_strdupa(post_process);
+		for (p2 = p1; *p2 ; p2++) {
+			if (*p2 == '^' && *(p2+1) == '{') {
+				*p2 = '$';
+			}
+		}
+
+		pbx_substitute_variables_helper(chan, p1, postprocess2, sizeof(postprocess2) - 1);
+		if (!ast_strlen_zero(postprocess2))
+			len += strlen(postprocess2) + 1;
+	}
+
+	/* Pre-allocate mixmonitor structure and spy */
+	if (!(mixmonitor = calloc(1, len))) {
 		return;
 	}
 
-	if (!(mixmonitor->spy = ast_calloc(1, sizeof(*mixmonitor->spy)))) {
-                ast_log(LOG_ERROR, "Memory Error!\n");
-		free(mixmonitor);
-                return;
-        }
-
 	/* Copy over flags and channel name */
 	mixmonitor->flags = flags;
-	mixmonitor->name = ast_strdup(chan->name);
+	mixmonitor->name = (char *) mixmonitor + sizeof(*mixmonitor);
+	strcpy(mixmonitor->name, chan->name);
+	if (!ast_strlen_zero(postprocess2)) {
+		mixmonitor->post_process = mixmonitor->name + strlen(mixmonitor->name) + 1;
+		strcpy(mixmonitor->post_process, postprocess2);
+	}
 
 	/* Determine creation flags and filename plus extension for filestream */
 	oflags = O_CREAT | O_WRONLY;
@@ -266,51 +281,33 @@
 	mixmonitor->fs = ast_writefile(file_name, ext, NULL, oflags, 0, 0644);
 	if (!mixmonitor->fs) {
 		ast_log(LOG_ERROR, "Cannot open %s.%s\n", file_name, ext);
-		free(mixmonitor->name);
-		free(mixmonitor->spy);
 		free(mixmonitor);
 		return;
 	}
 
-	/* If a post process system command is given attach it to the structure */
-	if (!ast_strlen_zero(post_process)) {
-		char *p = NULL;
-		postprocess = ast_strdupa(post_process);
-		for (p = postprocess; *p ; p++) {
-			if (*p == '^' && *(p+1) == '{') {
-				*p = '$';
-			}
-		}
-		pbx_substitute_variables_helper(chan, postprocess, postprocess2, sizeof(postprocess2) - 1);
-		mixmonitor->post_process = strdup(postprocess2);
-	}
-
 	/* Setup the actual spy before creating our thread */
-	ast_set_flag(mixmonitor->spy, CHANSPY_FORMAT_AUDIO);
-	ast_set_flag(mixmonitor->spy, CHANSPY_MIXAUDIO);
-	mixmonitor->spy->type = mixmonitor_spy_type;
-	mixmonitor->spy->status = CHANSPY_RUNNING;
-	mixmonitor->spy->read_queue.format = AST_FORMAT_SLINEAR;
-	mixmonitor->spy->write_queue.format = AST_FORMAT_SLINEAR;
+	ast_set_flag(&mixmonitor->spy, CHANSPY_FORMAT_AUDIO);
+	ast_set_flag(&mixmonitor->spy, CHANSPY_MIXAUDIO);
+	mixmonitor->spy.type = mixmonitor_spy_type;
+	mixmonitor->spy.status = CHANSPY_RUNNING;
+	mixmonitor->spy.read_queue.format = AST_FORMAT_SLINEAR;
+	mixmonitor->spy.write_queue.format = AST_FORMAT_SLINEAR;
 	if (readvol) {
-		ast_set_flag(mixmonitor->spy, CHANSPY_READ_VOLADJUST);
-		mixmonitor->spy->read_vol_adjustment = readvol;
+		ast_set_flag(&mixmonitor->spy, CHANSPY_READ_VOLADJUST);
+		mixmonitor->spy.read_vol_adjustment = readvol;
 	}
 	if (writevol) {
-		ast_set_flag(mixmonitor->spy, CHANSPY_WRITE_VOLADJUST);
-		mixmonitor->spy->write_vol_adjustment = writevol;
+		ast_set_flag(&mixmonitor->spy, CHANSPY_WRITE_VOLADJUST);
+		mixmonitor->spy.write_vol_adjustment = writevol;
 	}
-	ast_mutex_init(&mixmonitor->spy->lock);
+	ast_mutex_init(&mixmonitor->spy.lock);
 
-	if (startmon(chan, mixmonitor->spy)) {
+	if (startmon(chan, &mixmonitor->spy)) {
 		ast_log(LOG_WARNING, "Unable to add '%s' spy to channel '%s'\n",
-			mixmonitor->spy->type, chan->name);
+			mixmonitor->spy.type, chan->name);
 		/* Since we couldn't add ourselves - bail out! */
-		ast_mutex_destroy(&mixmonitor->spy->lock);
-		free(mixmonitor->post_process);
+		ast_mutex_destroy(&mixmonitor->spy.lock);
 		ast_closestream(mixmonitor->fs);
-		free(mixmonitor->name);
-		free(mixmonitor->spy);
 		free(mixmonitor);
 		return;
 	}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:01:46 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:01:46 +0200
Subject: [solid-pbx-svn] r344 - trunk/utils
Message-ID: <200606280101.k5S11kcj008708@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:01:35 +0200 (Wed, 28 Jun 2006)
New Revision: 344

Modified:
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r33873

------------------------------------------------------------------------
r33869 | kpfleming | 2006-06-13 17:11:29 +0200 (Tue, 13 Jun 2006) | 2 lines

minor fix

------------------------------------------------------------------------


Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-06-28 00:58:21 UTC (rev 343)
+++ trunk/utils/Makefile	2006-06-28 01:01:35 UTC (rev 344)
@@ -74,10 +74,10 @@
 	$(CC) $(CFLAGS) -o $@ $^
 
 aelflex.o: ../pbx/ael/ael_lex.c ../include/asterisk/ael_structs.h ../pbx/ael/ael.tab.h
-	$(CC) $(CFLAGS) -I../pbx/ -DSTANDALONE -c -o $@ $<
+	$(CC) $(CFLAGS) -I../pbx -DSTANDALONE -c -o $@ $<
 
 aelbison.o: ../pbx/ael/ael.tab.c ../pbx/ael/ael.tab.h ../include/asterisk/ael_structs.h
-	$(CC) $(CFLAGS) -I../pbx/ -c -o $@ $<
+	$(CC) $(CFLAGS) -I../pbx -c -o $@ $<
 
 pbx_ael.o: ../pbx/pbx_ael.c
 	$(CC) $(CFLAGS) -c -o $@ $<



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:02:49 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:02:49 +0200
Subject: [solid-pbx-svn] r345 - in trunk: . channels
Message-ID: <200606280102.k5S12nTj008860@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:02:35 +0200 (Wed, 28 Jun 2006)
New Revision: 345

Modified:
   trunk/channel.c
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r33893

------------------------------------------------------------------------
r33890 | mogorman | 2006-06-13 20:35:53 +0200 (Tue, 13 Jun 2006) | 4 lines

adds support for t38 pass through patch brought up to trunk from
bug 5090 by josh colp.  Thanks to everyone who help get this patch through
especially to the author Steven Underwood.

------------------------------------------------------------------------


Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-28 01:01:35 UTC (rev 344)
+++ trunk/channel.c	2006-06-28 01:02:35 UTC (rev 345)
@@ -2385,6 +2385,10 @@
 		res = (chan->tech->write_video == NULL) ? 0 :
 			chan->tech->write_video(chan, fr);
 		break;
+	case AST_FRAME_MODEM:
+		res = (chan->tech->write == NULL) ? 0 :
+			chan->tech->write(chan, fr);
+		break;
 	case AST_FRAME_VOICE:
 		if (chan->tech->write == NULL)
 			break;	/*! \todo XXX should return 0 maybe ? */

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 01:01:35 UTC (rev 344)
+++ trunk/channels/chan_sip.c	2006-06-28 01:02:35 UTC (rev 345)
@@ -122,6 +122,7 @@
 #include "asterisk/sched.h"
 #include "asterisk/io.h"
 #include "asterisk/rtp.h"
+#include "asterisk/udptl.h"
 #include "asterisk/acl.h"
 #include "asterisk/manager.h"
 #include "asterisk/callerid.h"
@@ -722,9 +723,13 @@
 #define SIP_PAGE2_ALLOWOVERLAP		(1 << 11)	/*!< Allow overlap dialing ? */
 #define SIP_PAGE2_SUBSCRIBEMWIONLY	(1 << 12)	/*!< Only issue MWI notification if subscribed to */
 #define SIP_PAGE2_INC_RINGING		(1 << 13)	/*!< Did this connection increment the counter of in-use calls? */
+#define SIP_PAGE2_T38SUPPORT		(7 << 14)	/*!< T38 Fax Passthrough Support */
+#define SIP_PAGE2_T38SUPPORT_UDPTL	(1 << 14)	/*!< 14: T38 Fax Passthrough Support */
+#define SIP_PAGE2_T38SUPPORT_RTP	(2 << 14)	/*!< 15: T38 Fax Passthrough Support */
+#define SIP_PAGE2_T38SUPPORT_TCP	(4 << 14)	/*!< 16: T38 Fax Passthrough Support */
 
 #define SIP_PAGE2_FLAGS_TO_COPY \
-	(SIP_PAGE2_ALLOWSUBSCRIBE | SIP_PAGE2_ALLOWOVERLAP | SIP_PAGE2_VIDEOSUPPORT)
+	(SIP_PAGE2_ALLOWSUBSCRIBE | SIP_PAGE2_ALLOWOVERLAP | SIP_PAGE2_VIDEOSUPPORT | SIP_PAGE2_T38SUPPORT)
 
 /* SIP packet flags */
 #define SIP_PKT_DEBUG		(1 << 0)	/*!< Debug this packet */
@@ -733,10 +738,55 @@
 #define SIP_PKT_IGNORE_RESP	(1 << 3)	/*!< Resp ignore - ??? */
 #define SIP_PKT_IGNORE_REQ	(1 << 4)	/*!< Req ignore - ??? */
 
+/* T.38 set of flags */
+#define T38FAX_FILL_BIT_REMOVAL		(1 << 0)	/*!< Default: 0 (unset)*/
+#define T38FAX_TRANSCODING_MMR			(1 << 1)	/*!< Default: 0 (unset)*/
+#define T38FAX_TRANSCODING_JBIG		(1 << 2)	/*!< Default: 0 (unset)*/
+/* Rate management */
+#define T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF	(0 << 3)
+#define T38FAX_RATE_MANAGEMENT_LOCAL_TCF	(1 << 3)	/*!< Unset for transferredTCF (UDPTL), set for localTCF (TPKT) */
+/* UDP Error correction */
+#define T38FAX_UDP_EC_NONE			(0 << 4)	/*!< two bits, if unset NO t38UDPEC field in T38 SDP*/
+#define T38FAX_UDP_EC_FEC			(1 << 4)	/*!< Set for t38UDPFEC */
+#define T38FAX_UDP_EC_REDUNDANCY		(2 << 4)	/*!< Set for t38UDPRedundancy */
+/* T38 Spec version */
+#define T38FAX_VERSION				(3 << 6)	/*!< two bits, 2 values so far, up to 4 values max */
+#define T38FAX_VERSION_0			(0 << 6)	/*!< Version 0 */
+#define T38FAX_VERSION_1			(1 << 6)	/*!< Version 1 */
+/* Maximum Fax Rate */
+#define T38FAX_RATE_2400			(1 << 8)	/*!< 2400 bps t38FaxRate */
+#define T38FAX_RATE_4800			(1 << 9)	/*!< 4800 bps t38FaxRate */
+#define T38FAX_RATE_7200			(1 << 10)	/*!< 7200 bps t38FaxRate */
+#define T38FAX_RATE_9600			(1 << 11)	/*!< 9600 bps t38FaxRate */
+#define T38FAX_RATE_12000			(1 << 12)	/*!< 12000 bps t38FaxRate */
+#define T38FAX_RATE_14400			(1 << 13)	/*!< 14400 bps t38FaxRate */
+
+/*!< This is default: NO MMR and JBIG trancoding, NO fill bit removal, transferredTCF TCF, UDP FEC, Version 0 and 9600 max fax rate */
+static int global_t38_capability = T38FAX_VERSION_0 | T38FAX_RATE_2400 | T38FAX_RATE_4800 | T38FAX_RATE_7200 | T38FAX_RATE_9600;
+
 #define sipdebug		ast_test_flag(&global_flags[1], SIP_PAGE2_DEBUG)
 #define sipdebug_config		ast_test_flag(&global_flags[1], SIP_PAGE2_DEBUG_CONFIG)
 #define sipdebug_console	ast_test_flag(&global_flags[1], SIP_PAGE2_DEBUG_CONSOLE)
 
+/*! \brief T38 Sates for a call */
+enum t38state {
+	T38_DISABLED = 0,		/*! Not enabled */
+	T38_LOCAL_DIRECT,		/*! Offered from local */
+	T38_LOCAL_REINVITE,		/*! Offered from local - REINVITE */
+	T38_PEER_DIRECT,		/*! Offered from peer */
+	T38_PEER_REINVITE,		/*! Offered from peer - REINVITE */
+	T38_ENABLED			/*! Negotiated (enabled) */
+};
+
+/*! \brief T.38 channel settings (at some point we need to make this alloc'ed */
+struct t38properties {
+	struct ast_flags t38support;	/*!< Flag for udptl, rtp or tcp support for this session */
+	int capability;			/*!< Our T38 capability */
+	int peercapability;		/*!< Peers T38 capability */
+	int jointcapability;		/*!< Supported T38 capability at both ends */
+	enum t38state state;		/*!< T.38 state */
+};
+
 /*! \brief Parameters to know status of transfer */
 enum referstatus {
 	REFER_IDLE,		/*!< No REFER is in progress */
@@ -841,6 +891,9 @@
 	int noncodeccapability;			/*!< DTMF RFC2833 telephony-event */
 	int redircodecs;			/*!< Redirect codecs */
 	int maxcallbitrate;			/*!< Maximum Call Bitrate for Video Calls */	
+	struct t38properties t38;		/*!< T38 settings */
+	struct sockaddr_in udptlredirip;	/*!< Where our T.38 UDPTL should be going if not to us */
+	struct ast_udptl *udptl;		/*!< T.38 UDPTL session */
 	int callingpres;			/*!< Calling presentation */
 	int authtries;				/*!< Times we've tried to authenticate */
 	int expiry;				/*!< How long we take to expire */
@@ -1413,8 +1466,14 @@
 static struct ast_rtp *sip_get_rtp_peer(struct ast_channel *chan);
 static struct ast_rtp *sip_get_vrtp_peer(struct ast_channel *chan);
 static int sip_get_codec(struct ast_channel *chan);
-static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p);
+static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p, int *faxdetect);
 
+/*------ T38 Support --------- */
+static int sip_handle_t38_reinvite(struct ast_channel *chan, struct sip_pvt *pvt, int reinvite); /*!< T38 negotiation helper function */
+static int transmit_response_with_t38_sdp(struct sip_pvt *p, char *msg, struct sip_request *req, int retrans);
+static int transmit_reinvite_with_t38_sdp(struct sip_pvt *p);
+static struct ast_udptl *sip_get_udptl_peer(struct ast_channel *chan);
+static int sip_set_udptl_peer(struct ast_channel *chan, struct ast_udptl *udptl);
 
 /*! \brief Definition of this channel for PBX channel registration */
 static const struct ast_channel_tech sip_tech = {
@@ -1456,6 +1515,13 @@
 	get_codec: sip_get_codec,
 };
 
+/*! \brief Interface structure with callbacks used to connect to UDPTL module*/
+static struct ast_udptl_protocol sip_udptl = {
+	type: "SIP",
+	get_udptl_info: sip_get_udptl_peer,
+	set_udptl_peer: sip_set_udptl_peer,
+};
+
 /*! \brief Convert transfer status to string */
 static char *referstatus2str(enum referstatus rstatus)
 {
@@ -2391,6 +2457,24 @@
 		r->vrtp = NULL;
 	}
 	r->prefs = peer->prefs;
+	if (ast_test_flag(&r->flags[1], SIP_PAGE2_T38SUPPORT)) {
+		r->t38.capability = global_t38_capability;
+		if (r->udptl) {
+			if (ast_udptl_get_error_correction_scheme(r->udptl) == UDPTL_ERROR_CORRECTION_FEC )
+				r->t38.capability |= T38FAX_UDP_EC_FEC;
+			else if (ast_udptl_get_error_correction_scheme(r->udptl) == UDPTL_ERROR_CORRECTION_REDUNDANCY )
+				r->t38.capability |= T38FAX_UDP_EC_REDUNDANCY;
+			else if (ast_udptl_get_error_correction_scheme(r->udptl) == UDPTL_ERROR_CORRECTION_NONE )
+				r->t38.capability |= T38FAX_UDP_EC_NONE;
+			r->t38.capability |= T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;
+			if (option_debug > 1)
+				ast_log(LOG_DEBUG,"Our T38 capability (%d)\n", r->t38.capability);
+		}
+		r->t38.jointcapability = r->t38.capability;
+	} else if (r->udptl) {
+		ast_udptl_destroy(r->udptl);
+		r->udptl = NULL;
+	}
 	natflags = ast_test_flag(&r->flags[0], SIP_NAT) & SIP_NAT_ROUTE;
 	if (r->rtp) {
 		if (option_debug)
@@ -2404,6 +2488,11 @@
 		ast_rtp_setnat(r->vrtp, natflags);
 		ast_rtp_setdtmf(r->vrtp, 0);
 	}
+	if (r->udptl) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Setting NAT on UDPTL to %s\n", natflags ? "On" : "Off");
+		ast_udptl_setnat(r->udptl, natflags);
+	}
 	ast_string_field_set(r, peername, peer->username);
 	ast_string_field_set(r, authname, peer->username);
 	ast_string_field_set(r, username, peer->username);
@@ -2567,7 +2656,12 @@
 		} else if (!strcasecmp(ast_var_name(current),"SIPTRANSFER_REPLACES")) {
 			/* We're replacing a call. */
 			p->options->replaces = ast_var_value(current);
+		} else if (!strcasecmp(ast_var_name(current),"T38CALL")) {
+			p->t38.state = T38_LOCAL_DIRECT;
+			if (option_debug)
+				ast_log(LOG_DEBUG,"T38State change to %d on channel %s\n", p->t38.state, ast->name);
 		}
+
 	}
 	
 	res = 0;
@@ -2592,6 +2686,9 @@
 	if ( res != -1 ) {
 		p->callingpres = ast->cid.cid_pres;
 		p->jointcapability = p->capability;
+		p->t38.jointcapability = p->t38.capability;
+		if (option_debug)
+			ast_log(LOG_DEBUG,"Our T38 capability (%d), joint T38 capability (%d)\n", p->t38.capability, p->t38.jointcapability);
 		transmit_invite(p, SIP_INVITE, 1, 2);
 		if (p->maxtime) {
 			/* Initialize auto-congest time */
@@ -2659,6 +2756,8 @@
 		ast_rtp_destroy(p->rtp);
 	if (p->vrtp)
 		ast_rtp_destroy(p->vrtp);
+	if (p->udptl)
+		ast_udptl_destroy(p->udptl);
 	if (p->refer)
 		free(p->refer);
 	if (p->route) {
@@ -3186,7 +3285,14 @@
 		ast_setstate(ast, AST_STATE_UP);
 		if (option_debug)
 			ast_log(LOG_DEBUG, "SIP answering channel: %s\n", ast->name);
-		res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
+		if (p->t38.state == T38_PEER_DIRECT) {
+			p->t38.state = T38_ENABLED;
+			if (option_debug > 1)
+				ast_log(LOG_DEBUG,"T38State change to %d on channel %s\n", p->t38.state, ast->name);
+			res = transmit_response_with_t38_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
+		} else {
+			res = transmit_response_with_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
+		}
 	}
 	ast_mutex_unlock(&p->lock);
 	return res;
@@ -3241,6 +3347,21 @@
 	case AST_FRAME_IMAGE:
 		return 0;
 		break;
+	case AST_FRAME_MODEM:
+		if (p) {
+			ast_mutex_lock(&p->lock);
+			if (p->udptl) {
+				if ((ast->_state != AST_STATE_UP) &&
+					!ast_test_flag(&p->flags[0], SIP_PROGRESS_SENT) && 
+				    !ast_test_flag(&p->flags[0], SIP_OUTGOING)) {
+					transmit_response_with_t38_sdp(p, "183 Session Progress", &p->initreq, XMIT_RELIABLE);
+					ast_set_flag(&p->flags[0], SIP_PROGRESS_SENT);
+				}
+				res = ast_udptl_write(p->udptl, frame);
+			}
+			ast_mutex_unlock(&p->lock);
+		}
+		break;
 	default: 
 		ast_log(LOG_WARNING, "Can't send %d type frames with SIP write\n", frame->frametype);
 		return 0;
@@ -3508,6 +3629,9 @@
 		tmp->fds[2] = ast_rtp_fd(i->vrtp);
 		tmp->fds[3] = ast_rtcp_fd(i->vrtp);
 	}
+	if (i->udptl) {
+		tmp->fds[5] = ast_udptl_fd(i->udptl);
+	}
 	if (state == AST_STATE_RING)
 		tmp->rings = 1;
 	tmp->adsicpe = AST_ADSI_UNAVAILABLE;
@@ -3701,7 +3825,7 @@
 }
 
 /*! \brief Read RTP from network */
-static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p)
+static struct ast_frame *sip_rtp_read(struct ast_channel *ast, struct sip_pvt *p, int *faxdetect)
 {
 	/* Retrieve audio/etc from channel.  Assumes p->lock is already held. */
 	struct ast_frame *f;
@@ -3724,6 +3848,9 @@
 	case 3:
 		f = ast_rtcp_read(p->vrtp);	/* RTCP Control Channel for video */
 		break;
+	case 5:
+		f = ast_udptl_read(p->udptl);	/* UDPTL for T.38 */
+		break;
 	default:
 		f = &ast_null_frame;
 	}
@@ -3744,8 +3871,15 @@
 			}
 			if ((ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_INBAND) && p->vad) {
 				f = ast_dsp_process(p->owner, p->vad, f);
-				if (option_debug && f && (f->frametype == AST_FRAME_DTMF)) 
-					ast_log(LOG_DEBUG, "* Detected inband DTMF '%c'\n", f->subclass);
+				if (f && f->frametype == AST_FRAME_DTMF) {
+					if (ast_test_flag(&p->t38.t38support, SIP_PAGE2_T38SUPPORT_UDPTL) && f->subclass == 'f') {
+						if (option_debug)
+							ast_log(LOG_DEBUG, "Fax CNG detected on %s\n", ast->name);
+						*faxdetect = 1;
+					} else if (option_debug) {
+						ast_log(LOG_DEBUG, "* Detected inband DTMF '%c'\n", f->subclass);
+					}
+				}
 			}
 		}
 	}
@@ -3757,10 +3891,31 @@
 {
 	struct ast_frame *fr;
 	struct sip_pvt *p = ast->tech_pvt;
+	int faxdetected = 0;
 
 	ast_mutex_lock(&p->lock);
-	fr = sip_rtp_read(ast, p);
+	fr = sip_rtp_read(ast, p, &faxdetected);
 	p->lastrtprx = time(NULL);
+
+	/* If we are NOT bridged to another channel, and we have detected fax tone we issue T38 re-invite to a peer */
+	/* If we are bridged then it is the responsibility of the SIP device to issue T38 re-invite if it detects CNG or fax preamble */
+	if (faxdetected && ast_test_flag(&p->t38.t38support, SIP_PAGE2_T38SUPPORT_UDPTL) && (p->t38.state == T38_DISABLED) && !(ast_bridged_channel(ast))) {
+		if (!ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
+			if (!p->pendinginvite) {
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG, "Sending reinvite on SIP (%s) for T.38 negotiation.\n",ast->name);
+				p->t38.state = T38_LOCAL_REINVITE;
+				transmit_reinvite_with_t38_sdp(p);
+				if (option_debug > 1)
+					ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s", p->t38.state, ast->name);
+			}
+		} else if (!ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
+			if (option_debug > 2)
+				ast_log(LOG_DEBUG, "Deferring reinvite on SIP (%s) - it will be re-negotiated for T.38\n", ast->name);
+			ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);
+		}
+	}
+
 	ast_mutex_unlock(&p->lock);
 	return fr;
 }
@@ -3854,6 +4009,8 @@
 		/* If the global videosupport flag is on, we always create a RTP interface for video */
 		if (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT))
 			p->vrtp = ast_rtp_new_with_bindaddr(sched, io, 1, 0, bindaddr.sin_addr);
+		if (ast_test_flag(&p->flags[1], SIP_PAGE2_T38SUPPORT))
+			p->udptl = ast_udptl_new_with_bindaddr(sched, io, 0, bindaddr.sin_addr);
 		if (!p->rtp || (ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && !p->vrtp)) {
 			ast_log(LOG_WARNING, "Unable to create RTP audio %s session: %s\n",
 				ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) ? "and video" : "", strerror(errno));
@@ -3871,6 +4028,9 @@
 			ast_rtp_settos(p->vrtp, global_tos_video);
 			ast_rtp_setdtmf(p->vrtp, 0);
 		}
+		if (p->udptl) {
+			ast_udptl_settos(p->udptl, global_tos_audio);
+		}
 		p->rtptimeout = global_rtptimeout;
 		p->rtpholdtimeout = global_rtpholdtimeout;
 		p->rtpkeepalive = global_rtpkeepalive;
@@ -3887,6 +4047,8 @@
 			ast_rtp_setnat(p->rtp, natflags);
 		if (p->vrtp)
 			ast_rtp_setnat(p->vrtp, natflags);
+		if (p->udptl)
+			ast_udptl_setnat(p->udptl, natflags);
 	}
 
 	if (p->method != SIP_REGISTER)
@@ -3903,6 +4065,17 @@
 	if ((ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_RFC2833) ||
 	    (ast_test_flag(&p->flags[0], SIP_DTMF) == SIP_DTMF_AUTO))
 		p->noncodeccapability |= AST_RTP_DTMF;
+	if (p->udptl) {
+		p->t38.capability = global_t38_capability;
+		if (ast_udptl_get_error_correction_scheme(p->udptl) == UDPTL_ERROR_CORRECTION_REDUNDANCY)
+			p->t38.capability |= T38FAX_UDP_EC_REDUNDANCY;
+		else if (ast_udptl_get_error_correction_scheme(p->udptl) == UDPTL_ERROR_CORRECTION_FEC)
+			p->t38.capability |= T38FAX_UDP_EC_FEC;
+		else if (ast_udptl_get_error_correction_scheme(p->udptl) == UDPTL_ERROR_CORRECTION_NONE)
+			p->t38.capability |= T38FAX_UDP_EC_NONE;
+		p->t38.capability |= T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;
+		p->t38.jointcapability = p->t38.capability;
+	}
 	ast_string_field_set(p, context, default_context);
 
 	/* Add to active dialog list */
@@ -4260,6 +4433,10 @@
 	int len = -1;
 	int portno = -1;		/*!< RTP Audio port number */
 	int vportno = -1;		/*!< RTP Video port number */
+	int udptlportno = -1;
+	int peert38capability = 0;
+	char s[256];
+	int old = 0;
 
 	/* Peer capability is the capability in the SDP, non codec is RFC2833 DTMF (101) */	
 	int peercapability, peernoncodeccapability;
@@ -4370,6 +4547,20 @@
 					ast_verbose("Found RTP video format %d\n", codec);
 				ast_rtp_set_m_type(newvideortp, codec);
 			}
+		} else if (p->udptl && (sscanf(m, "image %d udptl t38 %n", &x, &len) == 1)) {
+			if (debug)
+				ast_verbose("Got T.38 offer in SDP\n");
+			udptlportno = x;
+			
+			if (p->owner && p->lastinvite) {
+				p->t38.state = T38_PEER_REINVITE; /* T38 Offered in re-invite from remote party */
+				if (option_debug > 1)
+					ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>" );
+			} else {
+				p->t38.state = T38_PEER_DIRECT; /* T38 Offered directly from peer in first invite */
+				if (option_debug > 1)
+					ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+			}
 		} else 
 			ast_log(LOG_WARNING, "Unsupported SDP media type in offer: %s\n", m);
 		if (numberofports > 1)
@@ -4392,7 +4583,7 @@
 
 		}
 	}
-	if (portno == -1 && vportno == -1)
+	if (portno == -1 && vportno == -1 && udptlportno == -1)
 		/* No acceptable offer found in SDP  - we have no ports */
 		/* Do not change RTP or VRTP if this is a re-invite */
 		return -2;
@@ -4408,13 +4599,36 @@
 	if (vhp)
 		memcpy(&vsin.sin_addr, vhp->h_addr, sizeof(vsin.sin_addr));
 		
-
-	/* Setup audio port number */
-	sin.sin_port = htons(portno);
+	if (p->rtp) {
+		if (portno > 0) {
+			sin.sin_port = htons(portno);
+			ast_rtp_set_peer(p->rtp, &sin);
+			if (debug)
+				ast_verbose("Peer audio RTP is at port %s:%d\n", ast_inet_ntoa(iabuf,sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+		} else {
+			ast_rtp_stop(p->rtp);
+			if (debug)
+				ast_verbose("Peer doesn't provide audio\n");
+		}
+	}
 	/* Setup video port number */
 	if (vportno != -1)
 		vsin.sin_port = htons(vportno);
 
+	/* Setup UDPTL port number */
+	if (p->udptl) {
+		if (udptlportno > 0) {
+			sin.sin_port = htons(udptlportno);
+			ast_udptl_set_peer(p->udptl, &sin);
+			if (debug)
+				ast_log(LOG_DEBUG,"Peer T.38 UDPTL is at port %s:%d\n",ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+		} else {
+			ast_udptl_stop(p->udptl);
+			if (debug)
+				ast_log(LOG_DEBUG, "Peer doesn't provide T.38 UDPTL\n");
+		}
+	}
+
 	/* Next, scan through each "a=rtpmap:" line, noting each
 	 * specified RTP payload type (with corresponding MIME subtype):
 	 */
@@ -4478,6 +4692,123 @@
 		if (p->vrtp)
 			ast_rtp_set_rtpmap_type(newvideortp, codec, "video", mimeSubtype);
 	}
+	
+	if (udptlportno != -1) {
+		int found = 0, x;
+		
+		old = 0;
+		
+		/* Scan trough the a= lines for T38 attributes and set apropriate fileds */
+		iterator = req->sdp_start;
+		while ((a = get_sdp_iterate(&iterator, req, "a"))[0] != '\0') {
+			if ((sscanf(a, "T38FaxMaxBuffer:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"MaxBufferSize:%d\n",x);
+			}
+			if ((sscanf(a, "T38MaxBitRate:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"T38MaxBitRate: %d\n",x);
+				switch (x) {
+				case 14400:
+					peert38capability |= T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
+					break;
+				case 12000:
+					peert38capability |= T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
+					break;
+				case 9600:
+					peert38capability |= T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
+					break;
+				case 7200:
+					peert38capability |= T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400;
+					break;
+				case 4800:
+					peert38capability |= T38FAX_RATE_4800 | T38FAX_RATE_2400;
+					break;
+				case 2400:
+					peert38capability |= T38FAX_RATE_2400;
+					break;
+				}
+			}
+			if ((sscanf(a, "T38FaxVersion:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"FaxVersion: %d\n",x);
+				if (x == 0)
+					peert38capability |= T38FAX_VERSION_0;
+				else if (x == 1)
+					peert38capability |= T38FAX_VERSION_1;
+			}
+			if ((sscanf(a, "T38FaxMaxDatagram:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"FaxMaxDatagram: %d\n",x);
+				ast_udptl_set_far_max_datagram(p->udptl, x);
+				ast_udptl_set_local_max_datagram(p->udptl, x);
+			}
+			if ((sscanf(a, "T38FaxFillBitRemoval:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"FillBitRemoval: %d\n",x);
+				if (x == 1)
+					peert38capability |= T38FAX_FILL_BIT_REMOVAL;
+			}
+			if ((sscanf(a, "T38FaxTranscodingMMR:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"Transcoding MMR: %d\n",x);
+				if (x == 1)
+					peert38capability |= T38FAX_TRANSCODING_MMR;
+			}
+			if ((sscanf(a, "T38FaxTranscodingJBIG:%d", &x) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"Transcoding JBIG: %d\n",x);
+				if (x == 1)
+					peert38capability |= T38FAX_TRANSCODING_JBIG;
+			}
+			if ((sscanf(a, "T38FaxRateManagement:%s", s) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"RateMangement: %s\n", s);
+				if (!strcasecmp(s, "localTCF"))
+					peert38capability |= T38FAX_RATE_MANAGEMENT_LOCAL_TCF;
+				else if (!strcasecmp(s, "transferredTCF"))
+					peert38capability |= T38FAX_RATE_MANAGEMENT_TRANSFERED_TCF;
+			}
+			if ((sscanf(a, "T38FaxUdpEC:%s", s) == 1)) {
+				found = 1;
+				if (option_debug > 2)
+					ast_log(LOG_DEBUG,"UDP EC: %s\n", s);
+				if (!strcasecmp(s, "t38UDPRedundancy")) {
+					peert38capability |= T38FAX_UDP_EC_REDUNDANCY;
+					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_REDUNDANCY);
+				} else if (!strcasecmp(s, "t38UDPFEC")) {
+					peert38capability |= T38FAX_UDP_EC_FEC;
+					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_FEC);
+				} else {
+					peert38capability |= T38FAX_UDP_EC_NONE;
+					ast_udptl_set_error_correction_scheme(p->udptl, UDPTL_ERROR_CORRECTION_NONE);
+				}
+			}
+		}
+		if (found) { /* Some cisco equipment returns nothing beside c= and m= lines in 200 OK T38 SDP */
+			p->t38.peercapability = peert38capability;
+			p->t38.jointcapability = (peert38capability & 255); /* Put everything beside supported speeds settings */
+			peert38capability &= (T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400);
+			p->t38.jointcapability |= (peert38capability & p->t38.capability); /* Put the lower of our's and peer's speed */
+		}
+		if (debug)
+			ast_log(LOG_DEBUG,"Our T38 capability = (%d), peer T38 capability (%d), joint T38 capability (%d)\n",
+				p->t38.capability,
+				p->t38.peercapability,
+				p->t38.jointcapability);
+	} else {
+		p->t38.state = T38_DISABLED;
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+	}
 
 	/* Now gather all of the codecs that we are asked for: */
 	ast_rtp_get_current_formats(newaudiortp, &peercapability, &peernoncodeccapability);
@@ -5213,6 +5544,142 @@
 		ast_build_string(a_buf, a_size, "a=fmtp:%d annexb=no\r\n", rtp_code);
 }
 
+/*! \brief Get Max T.38 Transmision rate from T38 capabilities */
+static int t38_get_rate(int t38cap)
+{
+	int maxrate = (t38cap & (T38FAX_RATE_14400 | T38FAX_RATE_12000 | T38FAX_RATE_9600 | T38FAX_RATE_7200 | T38FAX_RATE_4800 | T38FAX_RATE_2400));
+	
+	if (maxrate & T38FAX_RATE_14400) {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38MaxFaxRate 14400 found\n");
+		return 14400;
+	} else if (maxrate & T38FAX_RATE_12000) {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38MaxFaxRate 12000 found\n");
+		return 12000;
+	} else if (maxrate & T38FAX_RATE_9600) {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38MaxFaxRate 9600 found\n");
+		return 9600;
+	} else if (maxrate & T38FAX_RATE_7200) {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38MaxFaxRate 7200 found\n");
+		return 7200;
+	} else if (maxrate & T38FAX_RATE_4800) {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38MaxFaxRate 4800 found\n");
+		return 4800;
+	} else if (maxrate & T38FAX_RATE_2400) {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "T38MaxFaxRate 2400 found\n");
+		return 2400;
+	} else {
+		if (option_debug > 1)
+			ast_log(LOG_DEBUG, "Strange, T38MaxFaxRate NOT found in peers T38 SDP.\n");
+		return 0;
+	}
+}
+
+/*! \brief Add T.38 Session Description Protocol message */
+static int add_t38_sdp(struct sip_request *resp, struct sip_pvt *p)
+{
+	int len = 0;
+	int x = 0;
+	struct sockaddr_in udptlsin;
+	char v[256] = "";
+	char s[256] = "";
+	char o[256] = "";
+	char c[256] = "";
+	char t[256] = "";
+	char m_modem[256];
+	char a_modem[1024];
+	char *m_modem_next = m_modem;
+	size_t m_modem_left = sizeof(m_modem);
+	char *a_modem_next = a_modem;
+	size_t a_modem_left = sizeof(a_modem);
+	char iabuf[INET_ADDRSTRLEN];
+	struct sockaddr_in udptldest = { 0, };
+	int debug;
+	
+	debug = sip_debug_test_pvt(p);
+	len = 0;
+	if (!p->udptl) {
+		ast_log(LOG_WARNING, "No way to add SDP without an UDPTL structure\n");
+		return -1;
+	}
+	
+	if (!p->sessionid) {
+		p->sessionid = getpid();
+		p->sessionversion = p->sessionid;
+	} else
+		p->sessionversion++;
+	
+	/* Our T.38 end is */
+	ast_udptl_get_us(p->udptl, &udptlsin);
+	
+	/* Determine T.38 UDPTL destination */
+	if (p->udptlredirip.sin_addr.s_addr) {
+		udptldest.sin_port = p->udptlredirip.sin_port;
+		udptldest.sin_addr = p->udptlredirip.sin_addr;
+	} else {
+		udptldest.sin_addr = p->ourip;
+		udptldest.sin_port = udptlsin.sin_port;
+	}
+	
+	if (debug) {
+		ast_log(LOG_DEBUG, "T.38 UDPTL is at %s port %d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip), ntohs(udptlsin.sin_port));
+	}
+	
+	/* We break with the "recommendation" and send our IP, in order that our
+	   peer doesn't have to ast_gethostbyname() us */
+	
+	if (debug) {
+		ast_log(LOG_DEBUG, "Our T38 capability (%d), peer T38 capability (%d), joint capability (%d)\n",
+			p->t38.capability,
+			p->t38.peercapability,
+			p->t38.jointcapability);
+	}
+	snprintf(v, sizeof(v), "v=0\r\n");
+	snprintf(o, sizeof(o), "o=root %d %d IN IP4 %s\r\n", p->sessionid, p->sessionversion, ast_inet_ntoa(iabuf, sizeof(iabuf), udptldest.sin_addr));
+	snprintf(s, sizeof(s), "s=session\r\n");
+	snprintf(c, sizeof(c), "c=IN IP4 %s\r\n", ast_inet_ntoa(iabuf, sizeof(iabuf), udptldest.sin_addr));
+	snprintf(t, sizeof(t), "t=0 0\r\n");
+	ast_build_string(&m_modem_next, &m_modem_left, "m=image %d udptl t38\r\n", ntohs(udptldest.sin_port));
+	
+	if ((p->t38.jointcapability & T38FAX_VERSION) == T38FAX_VERSION_0)
+		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxVersion:0\r\n");
+	if ((p->t38.jointcapability & T38FAX_VERSION) == T38FAX_VERSION_1)
+		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxVersion:1\r\n");
+	if ((x = t38_get_rate(p->t38.jointcapability)))
+		ast_build_string(&a_modem_next, &a_modem_left, "a=T38MaxBitRate:%d\r\n",x);
+	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxFillBitRemoval:%d\r\n", (p->t38.jointcapability & T38FAX_FILL_BIT_REMOVAL) ? 1 : 0);
+	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxTranscodingMMR:%d\r\n", (p->t38.jointcapability & T38FAX_TRANSCODING_MMR) ? 1 : 0);
+	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxTranscodingJBIG:%d\r\n", (p->t38.jointcapability & T38FAX_TRANSCODING_JBIG) ? 1 : 0);
+	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxRateManagement:%s\r\n", (p->t38.jointcapability & T38FAX_RATE_MANAGEMENT_LOCAL_TCF) ? "localTCF" : "transferredTCF");
+	x = ast_udptl_get_local_max_datagram(p->udptl);
+	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxMaxBuffer:%d\r\n",x);
+	ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxMaxDatagram:%d\r\n",x);
+	if (p->t38.jointcapability != T38FAX_UDP_EC_NONE)
+		ast_build_string(&a_modem_next, &a_modem_left, "a=T38FaxUdpEC:%s\r\n", (p->t38.jointcapability & T38FAX_UDP_EC_REDUNDANCY) ? "t38UDPRedundancy" : "t38UDPFEC");
+	if (p->udptl)
+		len = strlen(m_modem) + strlen(a_modem);
+	add_header(resp, "Content-Type", "application/sdp");
+	add_header_contentLength(resp, len);
+	add_line(resp, v);
+	add_line(resp, o);
+	add_line(resp, s);
+	add_line(resp, c);
+	add_line(resp, t);
+	add_line(resp, m_modem);
+	add_line(resp, a_modem);
+	
+	/* Update lastrtprx when we send our SDP */
+	p->lastrtprx = p->lastrtptx = time(NULL);
+	
+	return 0;
+}
+
+
 /*! \brief Add RFC 2833 DTMF offer to SDP */
 static void add_noncodec_to_sdp(const struct sip_pvt *p, int format, int sample_rate,
 				char **m_buf, size_t *m_size, char **a_buf, size_t *a_size,
@@ -5310,6 +5777,11 @@
 		ast_log(LOG_DEBUG, "** Our capability: %s Video flag: %s\n", ast_getformatname_multiple(codecbuf, sizeof(codecbuf), capability), ast_test_flag(&p->flags[0], SIP_NOVIDEO) ? "True" : "False");
 		ast_log(LOG_DEBUG, "** Our prefcodec: %s \n", ast_getformatname_multiple(codecbuf, sizeof(codecbuf), p->prefcodec));
 	}
+	
+	if ((ast_test_flag(&p->t38.t38support, SIP_PAGE2_T38SUPPORT_RTP))) {
+		ast_build_string(&m_audio_next, &m_audio_left, " %d", 191);
+		ast_build_string(&a_audio_next, &a_audio_left, "a=rtpmap:%d %s/%d\r\n", 191, "t38", 8000);
+	}
 
 	/* Check if we need video in this call */
 	if((capability & AST_FORMAT_VIDEO_MASK) && !ast_test_flag(&p->flags[0], SIP_NOVIDEO)) {
@@ -5498,6 +5970,26 @@
 	return 0;
 }
 
+/*--- transmit_response_with_t38_sdp: Used for 200 OK and 183 early media ---*/
+static int transmit_response_with_t38_sdp(struct sip_pvt *p, char *msg, struct sip_request *req, int retrans)
+{
+	struct sip_request resp;
+	int seqno;
+	
+	if (sscanf(get_header(req, "CSeq"), "%d ", &seqno) != 1) {
+		ast_log(LOG_WARNING, "Unable to get seqno from '%s'\n", get_header(req, "CSeq"));
+		return -1;
+	}
+	respprep(&resp, p, msg, req);
+	if (p->udptl) {
+		ast_udptl_offered_from_local(p->udptl, 0);
+		add_t38_sdp(&resp, p);
+	} else {
+		ast_log(LOG_ERROR, "Can't add SDP to response, since we have no UDPTL session allocated. Call-ID %s\n", p->callid);
+	}
+	return send_response(p, &resp, retrans, seqno);
+}
+
 /*! \brief copy SIP request (mostly used to save request for responses) */
 static void copy_request(struct sip_request *dst, const struct sip_request *src)
 {
@@ -5599,6 +6091,31 @@
 	return send_request(p, &req, 1, p->ocseq);
 }
 
+/*--- transmit_reinvite_with_t38_sdp: Transmit reinvite with T38 SDP ---*/
+/*     A re-invite is basically a new INVITE with the same CALL-ID and TAG as the
+       INVITE that opened the SIP dialogue
+       We reinvite so that the T38 processing can take place.
+       SIP Signalling stays with * in the path.
+*/
+static int transmit_reinvite_with_t38_sdp(struct sip_pvt *p)
+{
+	struct sip_request req;
+
+	reqprep(&req, p, ast_test_flag(&p->flags[0], SIP_REINVITE_UPDATE) ?  SIP_UPDATE : SIP_INVITE, 0, 1);
+	
+	add_header(&req, "Allow", ALLOWED_METHODS);
+	add_header(&req, "Supported", SUPPORTED_EXTENSIONS);
+	if (sipdebug)
+		add_header(&req, "X-asterisk-info", "SIP re-invite (T38 switchover)");
+	ast_udptl_offered_from_local(p->udptl, 1);
+	add_t38_sdp(&req, p);
+	/* Use this as the basis */
+	initialize_initreq(p, &req);
+	p->lastinvite = p->ocseq;
+	ast_set_flag(&p->flags[0], SIP_OUTGOING);
+	return send_request(p, &req, 1, p->ocseq);
+}
+
 /*! \brief Check Contact: URI of SIP message */
 static void extract_uri(struct sip_pvt *p, struct sip_request *req)
 {
@@ -5928,8 +6445,15 @@
 			}
 		}
 	}
-	if (sdp && p->rtp) {
-		add_sdp(&req, p);
+	if (sdp) {
+		if (p->udptl && p->t38.state == T38_LOCAL_DIRECT) {
+			ast_udptl_offered_from_local(p->udptl, 1);
+			if (option_debug)
+				ast_log(LOG_DEBUG, "T38 is in state %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+			add_t38_sdp(&req, p);
+		} else if (p->rtp) {
+			add_sdp(&req, p);
+		}
 	} else {
 		add_header_contentLength(&req, 0);
 	}
@@ -8081,6 +8605,11 @@
 				ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", usenatroute ? "On" : "Off");
 			ast_rtp_setnat(p->vrtp, usenatroute);
 		}
+		if (p->udptl) {
+			if (option_debug)
+				ast_log(LOG_DEBUG, "Setting NAT on UDPTL to %s\n", usenatroute ? "On" : "Off");
+			ast_udptl_setnat(p->udptl, usenatroute);
+		}
 		if (!(res = check_auth(p, req, user->name, user->secret, user->md5secret, sipmethod, uri, reliable, ast_test_flag(req, SIP_PKT_IGNORE)))) {
 			sip_cancel_destroy(p);
 			ast_copy_flags(&p->flags[0], &user->flags[0], SIP_FLAGS_TO_COPY);
@@ -8127,7 +8656,8 @@
 				p->noncodeccapability |= AST_RTP_DTMF;
 			else
 				p->noncodeccapability &= ~AST_RTP_DTMF;
-
+			if (p->t38.peercapability)
+				p->t38.jointcapability &= p->t38.peercapability;
 			p->maxcallbitrate = user->maxcallbitrate;
 			/* If we do not support video, remove video from call structure */
 			if (!ast_test_flag(&p->flags[1], SIP_PAGE2_VIDEOSUPPORT) && p->vrtp) {
@@ -8188,6 +8718,10 @@
 				ast_log(LOG_DEBUG, "Setting NAT on VRTP to %s\n", usenatroute ? "On" : "Off");
 				ast_rtp_setnat(p->vrtp, usenatroute);
 			}
+			if (p->udptl) {
+				ast_log(LOG_DEBUG, "Setting NAT on UDPTL to %s\n", usenatroute ? "On" : "Off");
+				ast_udptl_setnat(p->udptl, usenatroute);
+			}
 			ast_string_field_set(p, peersecret, peer->secret);
 			ast_string_field_set(p, peermd5secret, peer->md5secret);
 			ast_string_field_set(p, subscribecontext, peer->subscribecontext);
@@ -8259,6 +8793,8 @@
 					p->noncodeccapability |= AST_RTP_DTMF;
 				else
 					p->noncodeccapability &= ~AST_RTP_DTMF;
+				if (p->t38.peercapability)
+					p->t38.jointcapability &= p->t38.peercapability;
 			}
 			ASTOBJ_UNREF(peer, sip_destroy_peer);
 		} else { 
@@ -9059,6 +9595,9 @@
 		ast_cli(fd, "  Insecure     : %s\n", insecure2str(ast_test_flag(&peer->flags[0], SIP_INSECURE_PORT), ast_test_flag(&peer->flags[0], SIP_INSECURE_INVITE)));
 		ast_cli(fd, "  Nat          : %s\n", nat2str(ast_test_flag(&peer->flags[0], SIP_NAT)));
 		ast_cli(fd, "  ACL          : %s\n", (peer->ha?"Yes":"No"));
+		ast_cli(fd, "  T38 pt UDPTL : %s\n", ast_test_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_UDPTL)?"Yes":"No");
+		ast_cli(fd, "  T38 pt RTP   : %s\n", ast_test_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_RTP)?"Yes":"No");
+		ast_cli(fd, "  T38 pt TCP   : %s\n", ast_test_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_TCP)?"Yes":"No");
 		ast_cli(fd, "  CanReinvite  : %s\n", ast_test_flag(&peer->flags[0], SIP_CAN_REINVITE)?"Yes":"No");
 		ast_cli(fd, "  PromiscRedir : %s\n", ast_test_flag(&peer->flags[0], SIP_PROMISCREDIR)?"Yes":"No");
 		ast_cli(fd, "  User=Phone   : %s\n", ast_test_flag(&peer->flags[0], SIP_USEREQPHONE)?"Yes":"No");
@@ -9328,6 +9867,9 @@
 	ast_cli(fd, "  IP ToS SIP:             %s\n", ast_tos2str(global_tos_sip));
 	ast_cli(fd, "  IP ToS RTP audio:       %s\n", ast_tos2str(global_tos_audio));
 	ast_cli(fd, "  IP ToS RTP video:       %s\n", ast_tos2str(global_tos_video));
+	ast_cli(fd, "  T38 fax pt UDPTL:       %s\n", ast_test_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT_UDPTL) ? "Yes" : "No");
+	ast_cli(fd, "  T38 fax pt RTP:         %s\n", ast_test_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT_RTP) ? "Yes" : "No");
+	ast_cli(fd, "  T38 fax pt TCP:         %s\n", ast_test_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT_TCP) ? "Yes" : "No");
 	if (!realtimepeers && !realtimeusers)
 		ast_cli(fd, "  SIP realtime:           Disabled\n" );
 	else
@@ -10480,6 +11022,11 @@
 		ast_copy_string(buf, p->useragent, len);
 	} else  if (!strcasecmp(data, "peername")) {
 		ast_copy_string(buf, p->peername, len);
+	} else if (!strcasecmp(data, "t38passthrough")) {
+		if (p->t38.state == T38_DISABLED)
+			ast_copy_string(buf, "0", sizeof("0"));
+		else    /* T38 is offered or enabled in this call */
+			ast_copy_string(buf, "1", sizeof("1"));
 	} else {
 		ast_channel_unlock(chan);
 		return -1;
@@ -10502,6 +11049,7 @@
 	"- uri                   The URI from the Contact: header.\n"
 	"- useragent             The useragent.\n"
 	"- peername              The name of the peer.\n"
+	"- t38passthrough        1 if T38 is offered or enabled in this channel, otherwise 0\n"
 };
 
 /*! \brief Parse 302 Moved temporalily response */
@@ -10676,6 +11224,51 @@
 			build_route(p, req, 1);
 		}
 		
+		if (p->owner && (p->owner->_state == AST_STATE_UP)) { /* if this is a re-invite */
+			struct ast_channel *bridgepeer = NULL;
+			struct sip_pvt *bridgepvt = NULL;
+
+			bridgepeer = ast_bridged_channel(p->owner);
+			if (!bridgepeer->tech) {
+				ast_log(LOG_WARNING, "Ooooh.. no tech!  That's REALLY bad\n");
+				break;
+			}
+			if (!strcasecmp(bridgepeer->tech->type,"SIP")) {
+				bridgepvt = (struct sip_pvt*)(bridgepeer->tech_pvt);
+				if (bridgepvt->udptl) {
+					if (p->t38.state == T38_PEER_REINVITE) {
+						sip_handle_t38_reinvite(bridgepeer, p, 0);
+					} else if (p->t38.state == T38_DISABLED && bridgepeer && (bridgepvt->t38.state == T38_ENABLED)) {
+						ast_log(LOG_WARNING, "RTP re-inivte after T38 session not handled yet !\n");
+						/* Insted of this we should somehow re-invite the other side of the bridge to RTP */
+						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+					}
+				} else {
+					ast_log(LOG_WARNING, "Strange... The other side of the bridge don't have udptl struct\n");
+					ast_mutex_lock(&bridgepvt->lock);
+					bridgepvt->t38.state = T38_DISABLED;
+					ast_mutex_unlock(&bridgepvt->lock);
+					if (option_debug)
+						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", bridgepvt->t38.state, bridgepeer->tech->type);
+					p->t38.state = T38_DISABLED;
+					if (option_debug > 1)
+						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+				}
+			} else {
+				/* Other side is not a SIP channel */
+				ast_log(LOG_WARNING, "Strange... The other side of the bridge is not a SIP channel\n");
+				p->t38.state = T38_DISABLED;
+				if (option_debug > 1)
+					ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+			}
+		}
+		if ((p->t38.state == T38_LOCAL_REINVITE) || (p->t38.state == T38_LOCAL_DIRECT)) {
+			/* If there was T38 reinvite and we are supposed to answer with 200 OK than this should set us to T38 negotiated mode */
+			p->t38.state = T38_ENABLED;
+			if (option_debug)
+				ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+		}
+
 		if (!ast_test_flag(req, SIP_PKT_IGNORE) && p->owner) {
 			if (!reinvite) {
 				ast_queue_control(p->owner, AST_CONTROL_ANSWER);
@@ -11168,6 +11761,10 @@
 					/* Immediately stop VRTP */
 					ast_rtp_stop(p->vrtp);
 				}
+				if (p->udptl) {
+					/* Immediately stop UDPTL */
+					ast_udptl_stop(p->udptl);
+				}
 				/* XXX Locking issues?? XXX */
 				switch(resp) {
 				case 300: /* Multiple Choices */
@@ -12284,8 +12881,74 @@
 		case AST_STATE_UP:
 			if (option_debug > 1)
 				ast_log(LOG_DEBUG, "%s: New call is UP.... \n", c->name);
-			transmit_response_with_sdp(p, "200 OK", req, XMIT_CRITICAL);
-
+			if (p->t38.state == T38_PEER_REINVITE) {
+				struct ast_channel *bridgepeer = NULL;
+				struct sip_pvt *bridgepvt = NULL;
+				
+				if ((bridgepeer = ast_bridged_channel(p->owner))) {
+					/* We have a bridge, and this is re-invite to switchover to T38 so we send re-invite with T38 SDP, to other side of bridge*/
+					/*! XXX: we should also check here does the other side supports t38 at all !!! XXX */
+					if (!strcasecmp(bridgepeer->tech->type, "SIP")) { /* If we are bridged to SIP channel */
+						bridgepvt = (struct sip_pvt*)bridgepeer->tech_pvt;
+						if (bridgepvt->t38.state == T38_DISABLED) {
+							if (bridgepvt->udptl) { /* If everything is OK with other side's udptl struct */
+								/* Send re-invite to the bridged channel */
+								sip_handle_t38_reinvite(bridgepeer, p, 1);
+							} else { /* Something is wrong with peers udptl struct */
+								ast_log(LOG_WARNING, "Strange... The other side of the bridge don't have udptl struct\n");
+								ast_mutex_lock(&bridgepvt->lock);
+								bridgepvt->t38.state = T38_DISABLED;
+								ast_mutex_unlock(&bridgepvt->lock);
+								if (option_debug > 1)
+									ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", bridgepvt->t38.state, bridgepeer->name);
+								if (ast_test_flag(req, SIP_PKT_IGNORE))
+									transmit_response(p, "488 Not acceptable here", req);
+								else
+									transmit_response_reliable(p, "488 Not acceptable here", req);
+								ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+							}
+						}
+					} else {
+						/* Other side is not a SIP channel */
+						if (ast_test_flag(req, SIP_PKT_IGNORE))
+							transmit_response(p, "488 Not acceptable here", req);
+						else
+							transmit_response_reliable(p, "488 Not acceptable here", req);
+						p->t38.state = T38_DISABLED;
+						if (option_debug > 1)
+							ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+					}
+				} else {
+					/* we are not bridged in a call */
+					transmit_response_with_t38_sdp(p, "200 OK", req, XMIT_CRITICAL);
+					p->t38.state = T38_ENABLED;
+					if (option_debug)
+						ast_log(LOG_DEBUG,"T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
+				}
+			} else if (p->t38.state == T38_DISABLED) { /* Channel doesn't have T38 offered or enabled */
+				/* If we are bridged to a channel that has T38 enabled than this is a case of RTP re-invite after T38 session */
+				/* so handle it here (re-invite other party to RTP) */
+				struct ast_channel *bridgepeer = NULL;
+				struct sip_pvt *bridgepvt = NULL;
+				if ((bridgepeer = ast_bridged_channel(p->owner))) {
+					if (!strcasecmp(bridgepeer->tech->type, sip_tech.type)) {
+						bridgepvt = (struct sip_pvt*)bridgepeer->tech_pvt;
+						if (bridgepvt->t38.state == T38_ENABLED) {
+							ast_log(LOG_WARNING, "RTP re-invite after T38 session not handled yet !\n");
+							/* Insted of this we should somehow re-invite the other side of the bridge to RTP */
+							if (ast_test_flag(req, SIP_PKT_IGNORE))
+								transmit_response(p, "488 Not Acceptable Here (unsupported)", req);
+							else
+								transmit_response_reliable(p, "488 Not Acceptable Here (unsupported)", req);
+							ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);
+						} else {
+							/* No bridged peer with T38 enabled*/
+							transmit_response_with_sdp(p, "200 OK", req, XMIT_CRITICAL);
+						}
+					}
+				}
+			}
 			break;
 		default:
 			ast_log(LOG_WARNING, "Don't know how to handle INVITE in state %d\n", c->_state);
@@ -12784,6 +13447,10 @@
 		/* Immediately stop VRTP */
 		ast_rtp_stop(p->vrtp);
 	}
+	if (p->udptl) {
+		/* Immediately stop UDPTL */
+		ast_udptl_stop(p->udptl);
+	}
 	if (p->owner)
 		ast_queue_hangup(p->owner);
 	else
@@ -12839,6 +13506,10 @@
 		/* Immediately stop VRTP */
 		ast_rtp_stop(p->vrtp);
 	}
+	if (p->udptl) {
+		/* Immediately stop UDPTL */
+		ast_udptl_stop(p->udptl);
+	}
 	if (!ast_strlen_zero(get_header(req, "Also"))) {
 		ast_log(LOG_NOTICE, "Client '%s' using deprecated BYE/Also transfer method.  Ask vendor to support REFER instead\n",
 			ast_inet_ntoa(iabuf, sizeof(iabuf), p->recv.sin_addr));
@@ -14067,6 +14738,15 @@
 	} else if (!strcasecmp(v->name, "allowsubscribe")) {
 		ast_set_flag(&mask[1], SIP_PAGE2_ALLOWSUBSCRIBE);
 		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_ALLOWSUBSCRIBE);
+	} else if (!strcasecmp(v->name, "t38pt_udptl")) {
+		ast_set_flag(&mask[1], SIP_PAGE2_T38SUPPORT_UDPTL);
+		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_T38SUPPORT_UDPTL);
+	} else if (!strcasecmp(v->name, "t38pt_rtp")) {
+		ast_set_flag(&mask[1], SIP_PAGE2_T38SUPPORT_RTP);
+		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_T38SUPPORT_RTP);
+	} else if (!strcasecmp(v->name, "t38pt_tcp")) {
+		ast_set_flag(&mask[1], SIP_PAGE2_T38SUPPORT_TCP);
+		ast_set2_flag(&flags[1], ast_true(v->value), SIP_PAGE2_T38SUPPORT_TCP);
 	}
 
 	return res;
@@ -14313,7 +14993,22 @@
 			user->maxcallbitrate = atoi(v->value);
 			if (user->maxcallbitrate < 0)
 				user->maxcallbitrate = default_maxcallbitrate;
- 		}
+ 		} else if (!strcasecmp(v->name, "t38pt_udptl")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&user->flags[1], SIP_PAGE2_T38SUPPORT_UDPTL);
+			} else
+				ast_clear_flag(&user->flags[1], SIP_PAGE2_T38SUPPORT_UDPTL);
+		} else if (!strcasecmp(v->name, "t38pt_rtp")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&user->flags[1], SIP_PAGE2_T38SUPPORT_RTP);
+			} else
+				ast_clear_flag(&user->flags[1], SIP_PAGE2_T38SUPPORT_RTP);
+		} else if (!strcasecmp(v->name, "t38pt_tcp")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&user->flags[1], SIP_PAGE2_T38SUPPORT_TCP);
+			} else
+				ast_clear_flag(&user->flags[1], SIP_PAGE2_T38SUPPORT_TCP);
+		}
 	}
 	ast_copy_flags(&user->flags[0], &userflags[0], mask[0].flags);
 	ast_copy_flags(&user->flags[1], &userflags[1], mask[1].flags);
@@ -14595,6 +15290,21 @@
 			peer->maxcallbitrate = atoi(v->value);
 			if (peer->maxcallbitrate < 0)
 				peer->maxcallbitrate = default_maxcallbitrate;
+		} else if (!strcasecmp(v->name, "t38pt_udptl")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_UDPTL);
+			} else
+				ast_clear_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_UDPTL);
+		} else if (!strcasecmp(v->name, "t38pt_rtp")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_RTP);
+			} else
+				ast_clear_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_RTP);
+		} else if (!strcasecmp(v->name, "t38pt_tcp")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_TCP);
+			} else
+				ast_clear_flag(&peer->flags[1], SIP_PAGE2_T38SUPPORT_TCP);
 		}
 	}
 	if (!ast_test_flag(&global_flags[1], SIP_PAGE2_IGNOREREGEXPIRE) && ast_test_flag(&peer->flags[1], SIP_PAGE2_DYNAMIC) && realtime) {
@@ -14956,6 +15666,18 @@
 			default_maxcallbitrate = atoi(v->value);
 			if (default_maxcallbitrate < 0)
 				default_maxcallbitrate = DEFAULT_MAX_CALL_BITRATE;
+		} else if (!strcasecmp(v->name, "t38pt_udptl")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT_UDPTL);
+			}
+		} else if (!strcasecmp(v->name, "t38pt_rtp")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT_RTP);
+			}
+		} else if (!strcasecmp(v->name, "t38pt_tcp")) {
+			if (ast_true(v->value)) {
+				ast_set_flag(&global_flags[1], SIP_PAGE2_T38SUPPORT_TCP);
+			}
 		}
 	}
 
@@ -15097,6 +15819,131 @@
 	return 0;
 }
 
+static struct ast_udptl *sip_get_udptl_peer(struct ast_channel *chan)
+{
+	struct sip_pvt *p;
+	struct ast_udptl *udptl = NULL;
+	
+	p = chan->tech_pvt;
+	if (!p)
+		return NULL;
+	
+	ast_mutex_lock(&p->lock);
+	if (p->udptl && ast_test_flag(&p->flags[0], SIP_CAN_REINVITE))
+		udptl = p->udptl;
+	ast_mutex_unlock(&p->lock);
+	return udptl;
+}
+
+static int sip_set_udptl_peer(struct ast_channel *chan, struct ast_udptl *udptl)
+{
+	struct sip_pvt *p;
+	
+	p = chan->tech_pvt;
+	if (!p)
+		return -1;
+	ast_mutex_lock(&p->lock);
+	if (udptl)
+		ast_udptl_get_peer(udptl, &p->udptlredirip);
+	else
+		memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
+	if (!ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
+		if (!p->pendinginvite) {
+			if (option_debug > 2) {
+				char iabuf[INET_ADDRSTRLEN];
+				ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), udptl ? p->udptlredirip.sin_addr : p->ourip), udptl ? ntohs(p->udptlredirip.sin_port) : 0);
+			}
+			transmit_reinvite_with_t38_sdp(p);
+		} else if (!ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
+			if (option_debug > 2) {
+				char iabuf[INET_ADDRSTRLEN];
+				ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf),udptl ? p->udptlredirip.sin_addr : p->ourip), udptl ? ntohs(p->udptlredirip.sin_port) : 0);
+			}
+			ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);
+		}
+	}
+	/* Reset lastrtprx timer */
+	p->lastrtprx = p->lastrtptx = time(NULL);
+	ast_mutex_unlock(&p->lock);
+	return 0;
+}
+
+static int sip_handle_t38_reinvite(struct ast_channel *chan, struct sip_pvt *pvt, int reinvite)
+{
+	struct sip_pvt *p;
+	int flag = 0;
+	
+	p = chan->tech_pvt;
+	if (!p || !pvt->udptl)
+		return -1;
+	
+	/* Setup everything on the other side like offered/responded from first side */
+	ast_mutex_lock(&p->lock);
+	p->t38.jointcapability = p->t38.peercapability = pvt->t38.jointcapability;
+	ast_udptl_set_far_max_datagram(p->udptl, ast_udptl_get_local_max_datagram(pvt->udptl));
+	ast_udptl_set_local_max_datagram(p->udptl, ast_udptl_get_local_max_datagram(pvt->udptl));
+	ast_udptl_set_error_correction_scheme(p->udptl, ast_udptl_get_error_correction_scheme(pvt->udptl));
+	
+	if (reinvite) {		/* If we are handling sending re-invite to the other side of the bridge */
+		if (ast_test_flag(&p->flags[0], SIP_CAN_REINVITE) && ast_test_flag(&pvt->flags[0], SIP_CAN_REINVITE)) {
+			ast_udptl_get_peer(pvt->udptl, &p->udptlredirip);
+			flag =1;
+		} else {
+			memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
+		}
+		if (!ast_test_flag(&p->flags[0], SIP_GOTREFER)) {
+			if (!p->pendinginvite) {
+				if (option_debug > 2) {
+					char iabuf[INET_ADDRSTRLEN];
+					if (flag)
+						ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
+					else
+						ast_log(LOG_DEBUG, "Sending reinvite on SIP '%s' - It's UDPTL soon redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip));
+				}
+				transmit_reinvite_with_t38_sdp(p);
+			} else if (!ast_test_flag(&p->flags[0], SIP_PENDINGBYE)) {
+				if (option_debug > 2) {
+					char iabuf[INET_ADDRSTRLEN];
+					if (flag)
+						ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
+					else
+						ast_log(LOG_DEBUG, "Deferring reinvite on SIP '%s' - It's UDPTL will be redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip));
+				}
+				ast_set_flag(&p->flags[0], SIP_NEEDREINVITE);
+			}
+		}
+		/* Reset lastrtprx timer */
+		p->lastrtprx = p->lastrtptx = time(NULL);
+		ast_mutex_unlock(&p->lock);
+		return 0;
+	} else {	/* If we are handling sending 200 OK to the other side of the bridge */
+		if (ast_test_flag(&p->flags[0], SIP_CAN_REINVITE) && ast_test_flag(&pvt->flags[0], SIP_CAN_REINVITE)) {
+			ast_udptl_get_peer(pvt->udptl, &p->udptlredirip);
+			flag = 1;
+		} else {
+			memset(&p->udptlredirip, 0, sizeof(p->udptlredirip));
+		}
+		if (option_debug > 2) {
+			char iabuf[INET_ADDRSTRLEN];
+			if (flag)
+				ast_log(LOG_DEBUG, "Responding 200 OK on SIP '%s' - It's UDPTL soon redirected to IP %s:%d\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), p->udptlredirip.sin_addr), ntohs(p->udptlredirip.sin_port));
+			else
+				ast_log(LOG_DEBUG, "Responding 200 OK on SIP '%s' - It's UDPTL soon redirected to us (IP %s)\n", p->callid, ast_inet_ntoa(iabuf, sizeof(iabuf), p->ourip));
+		}
+		pvt->t38.state = T38_ENABLED;
+		p->t38.state = T38_ENABLED;
+		if (option_debug > 1) {
+			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", pvt->t38.state, pvt->owner ? pvt->owner->name : "<none>");
+			ast_log(LOG_DEBUG, "T38 changed state to %d on channel %s\n", p->t38.state, chan ? chan->name : "<none>");
+		}
+		transmit_response_with_t38_sdp(p, "200 OK", &p->initreq, XMIT_CRITICAL);
+		p->lastrtprx = p->lastrtptx = time(NULL);
+		ast_mutex_unlock(&p->lock);
+		return 0;
+	}
+}
+
+
 /*! \brief Returns null if we can't reinvite audio (part of RTP interface) */
 static struct ast_rtp *sip_get_rtp_peer(struct ast_channel *chan)
 {
@@ -15526,6 +16373,9 @@
 	/* Tell the RTP subdriver that we're here */
 	ast_rtp_proto_register(&sip_rtp);
 
+	/* Tell the UDPTL subdriver that we're here */
+	ast_udptl_proto_register(&sip_udptl);
+
 	/* Register dialplan applications */
 	ast_register_application(app_dtmfmode, sip_dtmfmode, synopsis_dtmfmode, descrip_dtmfmode);
 	ast_register_application(app_sipaddheader, sip_addheader, synopsis_sipaddheader, descrip_sipaddheader);
@@ -15570,6 +16420,8 @@
 
 	ast_rtp_proto_unregister(&sip_rtp);
 
+	ast_udptl_proto_unregister(&sip_udptl);
+
 	ast_manager_unregister("SIPpeers");
 	ast_manager_unregister("SIPshowpeer");
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:03:27 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:03:27 +0200
Subject: [solid-pbx-svn] r346 - in trunk: . configs
Message-ID: <200606280103.k5S13RiJ008948@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:03:22 +0200 (Wed, 28 Jun 2006)
New Revision: 346

Modified:
   trunk/CREDITS
   trunk/configs/sip.conf.sample
   trunk/frame.c
Log:
Update to Asterisk SVN trunk r33913

------------------------------------------------------------------------
r33911 | mogorman | 2006-06-13 21:22:34 +0200 (Tue, 13 Jun 2006) | 1 line

added thanks to voipsupply and steve underwood
------------------------------------------------------------------------
r33912 | file | 2006-06-13 21:38:41 +0200 (Tue, 13 Jun 2006) | 2 lines

Allow AST_FRAME_MODEM frames to be dumped, and document T.38 passthrough support

------------------------------------------------------------------------
r33913 | mogorman | 2006-06-13 21:58:39 +0200 (Tue, 13 Jun 2006) | 1 line

I am the king of typos....
------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-28 01:02:35 UTC (rev 345)
+++ trunk/CREDITS	2006-06-28 01:03:22 UTC (rev 346)
@@ -27,6 +27,9 @@
 * Thanks to QuickNet Technologies for their donation of an Internet
 PhoneJack and Linejack card to the project.  (http://www.quicknet.net)
 
+* Thanks to VoipSupply for their donation of Sipuras to the project for
+	t38 testing. (http://www.voipsupply.com)
+
 === MISCELLANEOUS PATCHES ===
 Jim Dixon - Zapata Telephony and app_rpt
 	http://www.zapatatelephony.org/app_rpt.html
@@ -124,6 +127,8 @@
 
 John Martin, Aupix - Improved video support in the SIP channel
 
+Steve Underwood - Provided T.38 pass through support.
+
 === OTHER CONTRIBUTIONS ===
 John Todd - Monkey sounds and associated teletorture prompt
 Michael Jerris - bug marshaling

Modified: trunk/configs/sip.conf.sample
===================================================================
--- trunk/configs/sip.conf.sample	2006-06-28 01:02:35 UTC (rev 345)
+++ trunk/configs/sip.conf.sample	2006-06-28 01:03:22 UTC (rev 346)
@@ -151,7 +151,14 @@
 ; separated by '&'.  Patterns may be used in regexten.
 ;
 ;regcontext=sipregistrations
+;----------------------------------------- T.38 FAX PASSTHROUGH SUPPORT -----------------------
 ;
+; These settings are available in the [general] section as well as in device configurations
+;
+; t38pt_udptl = yes            ; Default false
+; t38pt_rtp = yes              ; Default false
+; t38pt_tcp = yes              ; Default false, not yet used
+;
 ;----------------------------------------- OUTBOUND SIP REGISTRATIONS  ------------------------
 ; Asterisk can register as a SIP user agent to a SIP proxy (provider)
 ; Format for the register statement is:

Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-28 01:02:35 UTC (rev 345)
+++ trunk/frame.c	2006-06-28 01:03:22 UTC (rev 346)
@@ -816,6 +816,20 @@
 			break;
 		}
 		break;
+	case AST_FRAME_MODEM:
+		strcpy(ftype, "Modem");
+		switch (f->subclass) {
+		case AST_MODEM_T38:
+			strcpy(subclass, "T.38");
+			break;
+		case AST_MODEM_V150:
+			strcpy(subclass, "V.150");
+			break;
+		default:
+			snprintf(subclass, sizeof(subclass), "Unknown MODEM frame '%d'\n", f->subclass);
+			break;
+		}
+		break;
 	default:
 		snprintf(ftype, sizeof(ftype), "Unknown Frametype '%d'", f->frametype);
 	}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:04:01 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:04:01 +0200
Subject: [solid-pbx-svn] r347 - in trunk: . channels
Message-ID: <200606280104.k5S141jj009037@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:03:57 +0200 (Wed, 28 Jun 2006)
New Revision: 347

Modified:
   trunk/channels/chan_agent.c
   trunk/translate.c
Log:
Update to Asterisk SVN trunk r33933

------------------------------------------------------------------------
r33933 | kpfleming | 2006-06-13 22:59:15 +0200 (Tue, 13 Jun 2006) | 2 lines

use a compiler builtin (which uses processor instructions) for this operation

------------------------------------------------------------------------


Modified: trunk/channels/chan_agent.c
===================================================================
--- trunk/channels/chan_agent.c	2006-06-28 01:03:22 UTC (rev 346)
+++ trunk/channels/chan_agent.c	2006-06-28 01:03:57 UTC (rev 347)
@@ -1338,12 +1338,13 @@
 	return chan;
 }
 
-static int powerof(unsigned int v)
+static force_inline int powerof(unsigned int d)
 {
-	int x;
-	for (x=0;x<32;x++) {
-		if (v & (1 << x)) return x;
-	}
+	int x = ffs(d);
+
+	if (x)
+		return x - 1;
+
 	return 0;
 }
 

Modified: trunk/translate.c
===================================================================
--- trunk/translate.c	2006-06-28 01:03:22 UTC (rev 346)
+++ trunk/translate.c	2006-06-28 01:03:57 UTC (rev 347)
@@ -79,13 +79,15 @@
  */
 
 /*! \brief returns the index of the lowest bit set */
-static int powerof(int d)
+static force_inline int powerof(unsigned int d)
 {
-	int x;
-	for (x = 0; x < MAX_FORMAT; x++)
-		if ((1 << x) & d)
-			return x;
-	ast_log(LOG_WARNING, "Powerof %d: No power??\n", d);
+	int x = ffs(d);
+
+	if (x)
+		return x - 1;
+
+	ast_log(LOG_WARNING, "No bits set? %d\n", d);
+
 	return -1;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:17:10 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:17:10 +0200
Subject: [solid-pbx-svn] r348 - in trunk: . include/asterisk
Message-ID: <200606280117.k5S1HAR7011678@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:16:37 +0200 (Wed, 28 Jun 2006)
New Revision: 348

Modified:
   trunk/configure.ac
   trunk/include/asterisk/autoconfig.h.in
   trunk/include/asterisk/lock.h
Log:
Update to Asterisk SVN trunk r33953

------------------------------------------------------------------------
r33953 | kpfleming | 2006-06-13 23:35:29 +0200 (Tue, 13 Jun 2006) | 2 lines

use atomic operations provided by the compiler if they are available (yay for gcc 4.1 users!)

------------------------------------------------------------------------


Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-28 01:03:57 UTC (rev 347)
+++ trunk/configure.ac	2006-06-28 01:16:37 UTC (rev 348)
@@ -662,6 +662,14 @@
 AC_FUNC_VPRINTF
 AC_CHECK_FUNCS([atexit bzero dup2 endpwent floor ftruncate getcwd gethostbyname gethostname gettimeofday inet_ntoa isascii localtime_r memchr memmove memset mkdir munmap pow putenv re_comp regcomp rint select setenv socket sqrt strcasecmp strchr strcspn strdup strerror strncasecmp strndup strnlen strrchr strsep strspn strstr strtol unsetenv utime strtoq strcasestr asprintf vasprintf])
 
+echo -n "checking for compiler atomic operations... "
+AC_COMPILE_IFELSE(
+AC_LANG_PROGRAM([], [int foo1; int foo2 = __sync_fetch_and_add(&foo1, 1);]),
+AC_MSG_RESULT(yes)
+AC_DEFINE([HAVE_GCC_ATOMICS], 1, [Define to 1 if your GCC C compiler provides atomic operations.]),
+AC_MSG_RESULT(no)
+)
+
 AC_CONFIG_FILES([build_tools/menuselect-deps makeopts])
 AC_OUTPUT
 

Modified: trunk/include/asterisk/autoconfig.h.in
===================================================================
--- trunk/include/asterisk/autoconfig.h.in	2006-06-28 01:03:57 UTC (rev 347)
+++ trunk/include/asterisk/autoconfig.h.in	2006-06-28 01:16:37 UTC (rev 348)
@@ -94,6 +94,9 @@
 /* Define to 1 if you have the `ftruncate' function. */
 #undef HAVE_FTRUNCATE
 
+/* Define to 1 if your GCC C compiler provides atomic operations. */
+#undef HAVE_GCC_ATOMICS
+
 /* Define to 1 if you have the `getcwd' function. */
 #undef HAVE_GETCWD
 

Modified: trunk/include/asterisk/lock.h
===================================================================
--- trunk/include/asterisk/lock.h	2006-06-28 01:03:57 UTC (rev 347)
+++ trunk/include/asterisk/lock.h	2006-06-28 01:16:37 UTC (rev 348)
@@ -738,14 +738,19 @@
 
 #include "asterisk/inline_api.h"
 
-/*! \brief Atomically add v to *pp and return * the previous value of *p.
+/*! \brief Atomically add v to *p and return * the previous value of *p.
  * This can be used to handle reference counts, and the return value
  * can be used to generate unique identifiers.
  */
 
-#if defined ( __i386__)
+#if defined(HAVE_GCC_ATOMICS)
 AST_INLINE_API(int ast_atomic_fetchadd_int(volatile int *p, int v),
 {
+	return __sync_fetch_and_add(p, v);
+})
+#elif defined ( __i386__)
+AST_INLINE_API(int ast_atomic_fetchadd_int(volatile int *p, int v),
+{
 	__asm __volatile (
 	"       lock   xaddl   %0, %1 ;        "
 	: "+r" (v),                     /* 0 (result) */   
@@ -763,12 +768,18 @@
 /*! \brief decrement *p by 1 and return true if the variable has reached 0.
  * Useful e.g. to check if a refcount has reached 0.
  */
+#if defined(HAVE_GCC_ATOMICS)
 AST_INLINE_API(int ast_atomic_dec_and_test(volatile int *p),
 {
+	return __sync_sub_and_fetch(p, 1) == 0;
+})
+#else
+AST_INLINE_API(int ast_atomic_dec_and_test(volatile int *p),
+{
 	int a = ast_atomic_fetchadd_int(p, -1);
 	return a == 1; /* true if the value is 0 now (so it was 1 previously) */
-}
-)
+})
+#endif
 
 #ifndef DEBUG_CHANNEL_LOCKS
 /*! \brief Lock a channel. If DEBUG_CHANNEL_LOCKS is defined 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:18:44 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:18:44 +0200
Subject: [solid-pbx-svn] r349 - trunk/apps
Message-ID: <200606280118.k5S1IiXn011907@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:18:39 +0200 (Wed, 28 Jun 2006)
New Revision: 349

Modified:
   trunk/apps/app_rpt.c
Log:
Update to Asterisk SVN trunk r33973

------------------------------------------------------------------------
r33973 | jdixon | 2006-06-14 01:46:41 +0200 (Wed, 14 Jun 2006) | 3 lines

Allowed proper tx/rx signal exclusivity for simplex repeater modes
on 2 wire interfaces

------------------------------------------------------------------------


Modified: trunk/apps/app_rpt.c
===================================================================
--- trunk/apps/app_rpt.c	2006-06-28 01:16:37 UTC (rev 348)
+++ trunk/apps/app_rpt.c	2006-06-28 01:18:39 UTC (rev 349)
@@ -21,7 +21,7 @@
 /*! \file
  *
  * \brief Radio Repeater / Remote Base program 
- *  version 0.47 05/23/06
+ *  version 0.48 06/13/06
  * 
  * \author Jim Dixon, WB6NIL <jim at lambdatel.com>
  *
@@ -123,12 +123,10 @@
 
 /* Un-comment the following to include support for MDC-1200 digital tone
    signalling protocol (using KA6SQG's GPL'ed implementation) */
-/* file must be downloaded separately, not part of Asterisk distribution */
 /* #include "mdc_decode.c" */
 
 /* Un-comment the following to include support for notch filters in the
    rx audio stream (using Tony Fisher's mknotch (mkfilter) implementation) */
-/* file must be downloaded separately, not part of Asterisk distribution */
 /* #include "rpt_notch.c" */
 
 /* maximum digits in DTMF buffer, and seconds after * for DTMF command timeout */
@@ -244,7 +242,7 @@
 #include "asterisk/say.h"
 #include "asterisk/localtime.h"
 
-static  char *tdesc = "Radio Repeater / Remote Base  version 0.47  05/23/2006";
+static  char *tdesc = "Radio Repeater / Remote Base  version 0.48  06/13/2006";
 
 static char *app = "Rpt";
 
@@ -6831,17 +6829,23 @@
 				/* if RX key */
 				if (f->subclass == AST_CONTROL_RADIO_KEY)
 				{
-					if (debug == 7) printf("@@@@ rx key\n");
-					myrpt->keyed = 1;
+					if ((!lasttx) || (myrpt->p.duplex > 1))
+					{
+						if (debug == 7) printf("@@@@ rx key\n");
+						myrpt->keyed = 1;
+					}
 				}
 				/* if RX un-key */
 				if (f->subclass == AST_CONTROL_RADIO_UNKEY)
 				{
-					if (debug == 7) printf("@@@@ rx un-key\n");
-					if(myrpt->keyed) {
-						rpt_telemetry(myrpt,UNKEY,NULL);
+					if ((!lasttx) || (myrpt->p.duplex > 1))
+					{
+						if (debug == 7) printf("@@@@ rx un-key\n");
+						if(myrpt->keyed) {
+							rpt_telemetry(myrpt,UNKEY,NULL);
+						}
+						myrpt->keyed = 0;
 					}
-					myrpt->keyed = 0;
 				}
 			}
 			ast_frfree(f);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:20:35 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:20:35 +0200
Subject: [solid-pbx-svn] r350 - in trunk: . build_tools
Message-ID: <200606280120.k5S1KZTN012334@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:20:10 +0200 (Wed, 28 Jun 2006)
New Revision: 350

Modified:
   trunk/build_tools/menuselect.h
   trunk/configure.ac
   trunk/file.c
Log:
Update to Asterisk SVN trunk r34003

------------------------------------------------------------------------
r33994 | kpfleming | 2006-06-14 04:21:47 +0200 (Wed, 14 Jun 2006) | 10 lines

Merged revisions 33993 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r33993 | kpfleming | 2006-06-13 21:20:22 -0500 (Tue, 13 Jun 2006) | 2 lines

don't output 'no format found' when we _did_ find the format but couldn't open the desired file for some other reason

.......

------------------------------------------------------------------------
r33995 | kpfleming | 2006-06-14 04:23:29 +0200 (Wed, 14 Jun 2006) | 2 lines

use the proper test for compiler atomics

------------------------------------------------------------------------
r33997 | russell | 2006-06-14 05:00:15 +0200 (Wed, 14 Jun 2006) | 2 lines

indicate which options are just binary and don't really need a full integer

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.h
===================================================================
--- trunk/build_tools/menuselect.h	2006-06-28 01:18:39 UTC (rev 349)
+++ trunk/build_tools/menuselect.h	2006-06-28 01:20:10 UTC (rev 350)
@@ -53,11 +53,11 @@
 	/*! Default setting */
 	const char *defaultenabled;
 	/*! This module is currently selected */
-	int enabled;
+	int enabled:1;
 	/*! This module has failed dependencies */
-	int depsfailed;
+	int depsfailed:1;
 	/*! This module has failed conflicts */
-	int conflictsfailed;
+	int conflictsfailed:1;
 	/*! dependencies of this module */
 	AST_LIST_HEAD_NOLOCK(, depend) deps;
 	/*! conflicts of this module */
@@ -72,9 +72,9 @@
 	/*! the name displayed in the menu */
 	const char *displayname;
 	/*! Display what is selected, as opposed to not selected */
-	int positive_output;
+	int positive_output:1;
 	/*! Force a clean of the source tree if anything in this category changes */
-	int force_clean_on_change;
+	int force_clean_on_change:1;
 	/*! the list of possible values to be set in this variable */
 	AST_LIST_HEAD_NOLOCK(, member) members;
 	/*! for linking */

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-28 01:18:39 UTC (rev 349)
+++ trunk/configure.ac	2006-06-28 01:20:10 UTC (rev 350)
@@ -663,7 +663,7 @@
 AC_CHECK_FUNCS([atexit bzero dup2 endpwent floor ftruncate getcwd gethostbyname gethostname gettimeofday inet_ntoa isascii localtime_r memchr memmove memset mkdir munmap pow putenv re_comp regcomp rint select setenv socket sqrt strcasecmp strchr strcspn strdup strerror strncasecmp strndup strnlen strrchr strsep strspn strstr strtol unsetenv utime strtoq strcasestr asprintf vasprintf])
 
 echo -n "checking for compiler atomic operations... "
-AC_COMPILE_IFELSE(
+AC_LINK_IFELSE(
 AC_LANG_PROGRAM([], [int foo1; int foo2 = __sync_fetch_and_add(&foo1, 1);]),
 AC_MSG_RESULT(yes)
 AC_DEFINE([HAVE_GCC_ATOMICS], 1, [Define to 1 if your GCC C compiler provides atomic operations.]),

Modified: trunk/file.c
===================================================================
--- trunk/file.c	2006-06-28 01:18:39 UTC (rev 349)
+++ trunk/file.c	2006-06-28 01:20:10 UTC (rev 350)
@@ -870,6 +870,7 @@
 	struct ast_filestream *fs = NULL;
 	char *buf = NULL;
 	size_t size = 0;
+	int format_found = 0;
 
 	if (AST_LIST_LOCK(&formats)) {
 		ast_log(LOG_WARNING, "Unable to lock format list\n");
@@ -896,6 +897,8 @@
 
 		if (!exts_compare(f->exts, type))
 			continue;
+		else
+			format_found = 1;
 
 		fn = build_filename(filename, type);
 		fd = open(fn, flags | myflags, mode);
@@ -978,7 +981,8 @@
 	}
 
 	AST_LIST_UNLOCK(&formats);
-	if (!fs)
+
+	if (!format_found)
 		ast_log(LOG_WARNING, "No such format '%s'\n", type);
 
 	return fs;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:21:40 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:21:40 +0200
Subject: [solid-pbx-svn] r351 - trunk/build_tools
Message-ID: <200606280121.k5S1LelH012647@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:21:34 +0200 (Wed, 28 Jun 2006)
New Revision: 351

Modified:
   trunk/build_tools/menuselect.h
Log:
Update to Asterisk SVN trunk r34023

------------------------------------------------------------------------
r34022 | russell | 2006-06-14 05:19:47 +0200 (Wed, 14 Jun 2006) | 2 lines

make the compiler's life easier.  Thanks Kevin :)

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.h
===================================================================
--- trunk/build_tools/menuselect.h	2006-06-28 01:20:10 UTC (rev 350)
+++ trunk/build_tools/menuselect.h	2006-06-28 01:21:34 UTC (rev 351)
@@ -53,11 +53,11 @@
 	/*! Default setting */
 	const char *defaultenabled;
 	/*! This module is currently selected */
-	int enabled:1;
+	unsigned int enabled:1;
 	/*! This module has failed dependencies */
-	int depsfailed:1;
+	unsigned int depsfailed:1;
 	/*! This module has failed conflicts */
-	int conflictsfailed:1;
+	unsigned int conflictsfailed:1;
 	/*! dependencies of this module */
 	AST_LIST_HEAD_NOLOCK(, depend) deps;
 	/*! conflicts of this module */
@@ -72,9 +72,9 @@
 	/*! the name displayed in the menu */
 	const char *displayname;
 	/*! Display what is selected, as opposed to not selected */
-	int positive_output:1;
+	unsigned int positive_output:1;
 	/*! Force a clean of the source tree if anything in this category changes */
-	int force_clean_on_change:1;
+	unsigned int force_clean_on_change:1;
 	/*! the list of possible values to be set in this variable */
 	AST_LIST_HEAD_NOLOCK(, member) members;
 	/*! for linking */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:22:07 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:22:07 +0200
Subject: [solid-pbx-svn] r352 - trunk
Message-ID: <200606280122.k5S1M7vk012902@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:22:05 +0200 (Wed, 28 Jun 2006)
New Revision: 352

Modified:
   trunk/CREDITS
Log:
Update to Asterisk SVN trunk r34043

------------------------------------------------------------------------
r34043 | kpfleming | 2006-06-14 06:03:45 +0200 (Wed, 14 Jun 2006) | 2 lines

add Grandstream to credits too

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-28 01:21:34 UTC (rev 351)
+++ trunk/CREDITS	2006-06-28 01:22:05 UTC (rev 352)
@@ -27,9 +27,12 @@
 * Thanks to QuickNet Technologies for their donation of an Internet
 PhoneJack and Linejack card to the project.  (http://www.quicknet.net)
 
-* Thanks to VoipSupply for their donation of Sipuras to the project for
-	t38 testing. (http://www.voipsupply.com)
+* Thanks to VoipSupply for their donation of Sipura ATAs to the project for
+T.38 testing. (http://www.voipsupply.com)
 
+* Thanks to Grandstream for their donation of ATAs to the project for
+T.38 testing. (http://www.grandstream.com)
+
 === MISCELLANEOUS PATCHES ===
 Jim Dixon - Zapata Telephony and app_rpt
 	http://www.zapatatelephony.org/app_rpt.html



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:22:55 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:22:55 +0200
Subject: [solid-pbx-svn] r353 - trunk/channels
Message-ID: <200606280122.k5S1MtOc012995@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:22:51 +0200 (Wed, 28 Jun 2006)
New Revision: 353

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r34073

------------------------------------------------------------------------
r34065 | oej | 2006-06-14 13:40:31 +0200 (Wed, 14 Jun 2006) | 2 lines

Formatting fixes

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 01:22:05 UTC (rev 352)
+++ trunk/channels/chan_sip.c	2006-06-28 01:22:51 UTC (rev 353)
@@ -3891,7 +3891,7 @@
 {
 	struct ast_frame *fr;
 	struct sip_pvt *p = ast->tech_pvt;
-	int faxdetected = 0;
+	int faxdetected = FALSE;
 
 	ast_mutex_lock(&p->lock);
 	fr = sip_rtp_read(ast, p, &faxdetected);
@@ -4028,9 +4028,8 @@
 			ast_rtp_settos(p->vrtp, global_tos_video);
 			ast_rtp_setdtmf(p->vrtp, 0);
 		}
-		if (p->udptl) {
+		if (p->udptl)
 			ast_udptl_settos(p->udptl, global_tos_audio);
-		}
 		p->rtptimeout = global_rtptimeout;
 		p->rtpholdtimeout = global_rtpholdtimeout;
 		p->rtpkeepalive = global_rtpkeepalive;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:23:39 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:23:39 +0200
Subject: [solid-pbx-svn] r354 - in trunk: . apps channels include/asterisk
Message-ID: <200606280123.k5S1NdAi013116@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:23:32 +0200 (Wed, 28 Jun 2006)
New Revision: 354

Modified:
   trunk/abstract_jb.c
   trunk/apps/app_amd.c
   trunk/apps/app_chanspy.c
   trunk/apps/app_dumpchan.c
   trunk/channels/chan_agent.c
   trunk/fixedjitterbuf.c
   trunk/include/asterisk/abstract_jb.h
   trunk/include/asterisk/plc.h
   trunk/include/asterisk/udptl.h
   trunk/jitterbuf.c
   trunk/plc.c
   trunk/udptl.c
Log:
Update to Asterisk SVN trunk r34093

------------------------------------------------------------------------
r34090 | kpfleming | 2006-06-14 16:12:56 +0200 (Wed, 14 Jun 2006) | 10 lines

Merged revisions 34087 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34087 | kpfleming | 2006-06-14 09:07:53 -0500 (Wed, 14 Jun 2006) | 2 lines

clarify file headers that mention disclaimer usage

.......

------------------------------------------------------------------------
r34093 | oej | 2006-06-14 16:46:19 +0200 (Wed, 14 Jun 2006) | 3 lines

- Use our standard of doxygen comments, not javadoc style
- small reformatting changes

------------------------------------------------------------------------


Modified: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/abstract_jb.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -6,8 +6,6 @@
  * Contributors:
  * Slav Klenov <slav at securax.org>
  *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact
  * any of the maintainers of this project for assistance;
@@ -17,6 +15,9 @@
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
+ *
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 /*! \file

Modified: trunk/apps/app_amd.c
===================================================================
--- trunk/apps/app_amd.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/apps/app_amd.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -5,8 +5,6 @@
  *
  * Claude Klimos (claude.klimos at aheeva.com)
  *
- * Disclaimed to Digium
- *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact
  * any of the maintainers of this project for assistance;
@@ -16,6 +14,9 @@
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
+ *
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 #include <stdio.h>

Modified: trunk/apps/app_chanspy.c
===================================================================
--- trunk/apps/app_chanspy.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/apps/app_chanspy.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -4,7 +4,8 @@
  * Copyright (C) 2005 Anthony Minessale II (anthmct at yahoo.com)
  * Copyright (C) 2005 - 2006, Digium, Inc.
  *
- * Disclaimed to Digium
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact

Modified: trunk/apps/app_dumpchan.c
===================================================================
--- trunk/apps/app_dumpchan.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/apps/app_dumpchan.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -5,7 +5,8 @@
  *
  * Anthony Minessale <anthmct at yahoo.com>
  *
- * disclaimed to Digium
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact

Modified: trunk/channels/chan_agent.c
===================================================================
--- trunk/channels/chan_agent.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/channels/chan_agent.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -144,16 +144,14 @@
 
 static char moh[80] = "default";
 
-#define AST_MAX_AGENT	80		/**< Agent ID or Password max length */
+#define AST_MAX_AGENT	80                          /*!< Agent ID or Password max length */
 #define AST_MAX_BUF	256
 #define AST_MAX_FILENAME_LEN	256
 
-/** Persistent Agents astdb family */
-static const char pa_family[] = "/Agents";
-/** The maximum length of each persistent member agent database entry */
-#define PA_MAX_LEN 2048
-/** queues.conf [general] option */
-static int persistent_agents = 0;
+static const char pa_family[] = "/Agents";          /*!< Persistent Agents astdb family */
+#define PA_MAX_LEN 2048                             /*!< The maximum length of each persistent member agent database entry */
+
+static int persistent_agents = 0;                   /*!< queues.conf [general] option */
 static void dump_agents(void);
 
 static ast_group_t group;
@@ -177,37 +175,35 @@
 
 #define GETAGENTBYCALLERID	"AGENTBYCALLERID"
 
-/**
- * Structure representing an agent.
- */
+/*! \brief * Structure representing an agent.  */
 struct agent_pvt {
-	ast_mutex_t lock;              /**< Channel private lock */
-	int dead;                      /**< Poised for destruction? */
-	int pending;                   /**< Not a real agent -- just pending a match */
-	int abouttograb;               /**< About to grab */
-	int autologoff;                /**< Auto timeout time */
-	int ackcall;                   /**< ackcall */
-	time_t loginstart;             /**< When agent first logged in (0 when logged off) */
-	time_t start;                  /**< When call started */
-	struct timeval lastdisc;       /**< When last disconnected */
-	int wrapuptime;                /**< Wrapup time in ms */
-	ast_group_t group;             /**< Group memberships */
-	int acknowledged;              /**< Acknowledged */
-	char moh[80];                  /**< Which music on hold */
-	char agent[AST_MAX_AGENT];     /**< Agent ID */
-	char password[AST_MAX_AGENT];  /**< Password for Agent login */
+	ast_mutex_t lock;              /*!< Channel private lock */
+	int dead;                      /*!< Poised for destruction? */
+	int pending;                   /*!< Not a real agent -- just pending a match */
+	int abouttograb;               /*!< About to grab */
+	int autologoff;                /*!< Auto timeout time */
+	int ackcall;                   /*!< ackcall */
+	time_t loginstart;             /*!< When agent first logged in (0 when logged off) */
+	time_t start;                  /*!< When call started */
+	struct timeval lastdisc;       /*!< When last disconnected */
+	int wrapuptime;                /*!< Wrapup time in ms */
+	ast_group_t group;             /*!< Group memberships */
+	int acknowledged;              /*!< Acknowledged */
+	char moh[80];                  /*!< Which music on hold */
+	char agent[AST_MAX_AGENT];     /*!< Agent ID */
+	char password[AST_MAX_AGENT];  /*!< Password for Agent login */
 	char name[AST_MAX_AGENT];
-	ast_mutex_t app_lock;          /**< Synchronization between owning applications */
-	volatile pthread_t owning_app; /**< Owning application thread id */
-	volatile int app_sleep_cond;   /**< Sleep condition for the login app */
-	struct ast_channel *owner;     /**< Agent */
-	char loginchan[80];            /**< channel they logged in from */
-	char logincallerid[80];        /**< Caller ID they had when they logged in */
-	struct ast_channel *chan;      /**< Channel we use */
-	AST_LIST_ENTRY(agent_pvt) list;	/**< Next Agent in the linked list. */
+	ast_mutex_t app_lock;          /*!< Synchronization between owning applications */
+	volatile pthread_t owning_app; /*!< Owning application thread id */
+	volatile int app_sleep_cond;   /*!< Sleep condition for the login app */
+	struct ast_channel *owner;     /*!< Agent */
+	char loginchan[80];            /*!< channel they logged in from */
+	char logincallerid[80];        /*!< Caller ID they had when they logged in */
+	struct ast_channel *chan;      /*!< Channel we use */
+	AST_LIST_ENTRY(agent_pvt) list;	/*!< Next Agent in the linked list. */
 };
 
-static AST_LIST_HEAD_STATIC(agents, agent_pvt);	/**< Holds the list of agents (loaded form agents.conf). */
+static AST_LIST_HEAD_STATIC(agents, agent_pvt);	/*!< Holds the list of agents (loaded form agents.conf). */
 
 #define CHECK_FORMATS(ast, p) do { \
 	if (p->chan) {\
@@ -226,7 +222,7 @@
 	} \
 } while(0)
 
-/* Cleanup moves all the relevant FD's from the 2nd to the first, but retains things
+/*! \brief Cleanup moves all the relevant FD's from the 2nd to the first, but retains things
    properly for a timingfd XXX This might need more work if agents were logged in as agents or other
    totally impractical combinations XXX */
 
@@ -241,6 +237,7 @@
 	} \
 } while(0)
 
+/*--- Forward declarations */
 static struct ast_channel *agent_request(const char *type, int format, void *data, int *cause);
 static int agent_devicestate(void *data);
 static void agent_logoff_maintenance(struct agent_pvt *p, char *loginchan, long logintime, const char *uniqueid, char *logcommand);
@@ -257,6 +254,7 @@
 static struct ast_channel *agent_bridgedchannel(struct ast_channel *chan, struct ast_channel *bridge);
 static void set_agentbycallerid(const char *callerid, const char *agent);
 
+/*! \brief Channel interface description for PBX integration */
 static const struct ast_channel_tech agent_tech = {
 	.type = "Agent",
 	.description = tdesc,
@@ -277,13 +275,13 @@
 	.bridged_channel = agent_bridgedchannel,
 };
 
-/**
+/*!
  * Adds an agent to the global list of agents.
  *
- * @param agent A string with the username, password and real name of an agent. As defined in agents.conf. Example: "13,169,John Smith"
- * @param pending If it is pending or not.
+ * \param agent A string with the username, password and real name of an agent. As defined in agents.conf. Example: "13,169,John Smith"
+ * \param pending If it is pending or not.
  * @return The just created agent.
- * @sa agent_pvt, agents.
+ * \sa agent_pvt, agents.
  */
 static struct agent_pvt *add_agent(char *agent, int pending)
 {
@@ -369,10 +367,10 @@
 	return p;
 }
 
-/**
+/*!
  * Deletes an agent after doing some clean up.
  * Further documentation: How safe is this function ? What state should the agent be to be cleaned.
- * @param p Agent to be deleted.
+ * \param p Agent to be deleted.
  * @returns Always 0.
  */
 static int agent_cleanup(struct agent_pvt *p)
@@ -976,7 +974,7 @@
 }
 
 
-/**
+/*!
  * Read configuration data. The file named agents.conf.
  *
  * @returns Always 0, or so it seems.
@@ -1348,13 +1346,13 @@
 	return 0;
 }
 
-/**
+/*!
  * Lists agents and their status to the Manager API.
  * It is registered on load_module() and it gets called by the manager backend.
- * @param s
- * @param m
+ * \param s
+ * \param m
  * @returns 
- * @sa action_agent_logoff(), action_agent_callback_login(), load_module().
+ * \sa action_agent_logoff(), action_agent_callback_login(), load_module().
  */
 static int action_agents(struct mansession *s, struct message *m)
 {
@@ -1517,13 +1515,13 @@
 	return RESULT_SUCCESS;
 }
 
-/**
+/*!
  * Sets an agent as no longer logged in in the Manager API.
  * It is registered on load_module() and it gets called by the manager backend.
- * @param s
- * @param m
+ * \param s
+ * \param m
  * @returns 
- * @sa action_agents(), action_agent_callback_login(), load_module().
+ * \sa action_agents(), action_agent_callback_login(), load_module().
  */
 static int action_agent_logoff(struct mansession *s, struct message *m)
 {
@@ -1569,7 +1567,7 @@
 	return NULL;
 }
 
-/**
+/*!
  * Show agents in cli.
  */
 static int agents_show(int fd, int argc, char **argv)
@@ -2159,39 +2157,39 @@
  	return -1;
 }
 
-/**
+/*!
  * Called by the AgentLogin application (from the dial plan).
  * 
- * @param chan
- * @param data
+ * \param chan
+ * \param data
  * @returns
- * @sa callback_login_exec(), agentmonitoroutgoing_exec(), load_module().
+ * \sa callback_login_exec(), agentmonitoroutgoing_exec(), load_module().
  */
 static int login_exec(struct ast_channel *chan, void *data)
 {
 	return __login_exec(chan, data, 0);
 }
 
-/**
+/*!
  *  Called by the AgentCallbackLogin application (from the dial plan).
  * 
- * @param chan
- * @param data
+ * \param chan
+ * \param data
  * @returns
- * @sa login_exec(), agentmonitoroutgoing_exec(), load_module().
+ * \sa login_exec(), agentmonitoroutgoing_exec(), load_module().
  */
 static int callback_exec(struct ast_channel *chan, void *data)
 {
 	return __login_exec(chan, data, 1);
 }
 
-/**
+/*!
  * Sets an agent as logged in by callback in the Manager API.
  * It is registered on load_module() and it gets called by the manager backend.
- * @param s
- * @param m
+ * \param s
+ * \param m
  * @returns 
- * @sa action_agents(), action_agent_logoff(), load_module().
+ * \sa action_agents(), action_agent_logoff(), load_module().
  */
 static int action_agent_callback_login(struct mansession *s, struct message *m)
 {
@@ -2267,13 +2265,13 @@
 	return 0;
 }
 
-/**
- *  Called by the AgentMonitorOutgoing application (from the dial plan).
+/*!
+ *  \brief Called by the AgentMonitorOutgoing application (from the dial plan).
  *
- * @param chan
- * @param data
- * @returns
- * @sa login_exec(), callback_login_exec(), load_module().
+ * \param chan
+ * \param data
+ * \returns
+ * \sa login_exec(), callback_login_exec(), load_module().
  */
 static int agentmonitoroutgoing_exec(struct ast_channel *chan, void *data)
 {
@@ -2319,6 +2317,7 @@
 			ast_log(LOG_WARNING, "There is no callerid on that call, so I can't figure out which agent (if it's an agent) is placing outgoing call.\n");
 	}
 	/* check if there is n + 101 priority */
+	/*! \todo XXX Needs to check option priorityjump etc etc */
 	if (res) {
 		if (ast_exists_extension(chan, chan->context, chan->exten, chan->priority + 101, chan->cid.cid_num)) {
 			chan->priority+=100;
@@ -2331,8 +2330,8 @@
 	return 0;
 }
 
-/**
- * Dump AgentCallbackLogin agents to the database for persistence
+/*!
+ * \brief Dump AgentCallbackLogin agents to the ASTdb database for persistence
  */
 static void dump_agents(void)
 {
@@ -2346,7 +2345,7 @@
 		if (!ast_strlen_zero(cur_agent->loginchan)) {
 			snprintf(buf, sizeof(buf), "%s;%s", cur_agent->loginchan, cur_agent->logincallerid);
 			if (ast_db_put(pa_family, cur_agent->agent, buf))
-				ast_log(LOG_WARNING, "failed to create persistent entry!\n");
+				ast_log(LOG_WARNING, "failed to create persistent entry in ASTdb for %s!\n", buf);
 			else if (option_debug)
 				ast_log(LOG_DEBUG, "Saved Agent: %s on %s\n", cur_agent->agent, cur_agent->loginchan);
 		} else {
@@ -2356,8 +2355,8 @@
 	}
 }
 
-/**
- * Reload the persistent agents from astdb.
+/*!
+ * \brief Reload the persistent agents from astdb.
  */
 static void reload_agents(void)
 {
@@ -2410,7 +2409,7 @@
 	}
 }
 
-/*! \brief Part of PBX channel interface ---*/
+/*! \brief Part of PBX channel interface */
 static int agent_devicestate(void *data)
 {
 	struct agent_pvt *p;
@@ -2499,11 +2498,10 @@
 	}
 
 	if (!strcasecmp(args.item, "status")) {
-		if (agent->chan || !ast_strlen_zero(agent->loginchan)) {
-			ast_copy_string(buf, "LOGGEDIN", len);
-		} else {
-			ast_copy_string(buf, "LOGGEDOUT", len);
-		}
+		char *status = "LOGGEDOUT";
+		if (agent->chan || !ast_strlen_zero(agent->loginchan)) 
+			status = "LOGGEDIN";	
+		ast_copy_string(buf, status, len);
 	} else if (!strcasecmp(args.item, "password")) {
 		ast_copy_string(buf, agent->password, len);
 	} else if (!strcasecmp(args.item, "name")) {
@@ -2540,11 +2538,12 @@
 };
 
 
-/**
- * Initialize the Agents module.
- * This function is being called by Asterisk when loading the module. Among other thing it registers applications, cli commands and reads the cofiguration file.
+/*!
+ * \brief Initialize the Agents module.
+ * This function is being called by Asterisk when loading the module. 
+ * Among other things it registers applications, cli commands and reads the cofiguration file.
  *
- * @returns int Always 0.
+ * \returns int Always 0.
  */
 static int load_module(void *mod)
 {
@@ -2558,16 +2557,20 @@
 	ast_register_application(app, login_exec, synopsis, descrip);
 	ast_register_application(app2, callback_exec, synopsis2, descrip2);
 	ast_register_application(app3, agentmonitoroutgoing_exec, synopsis3, descrip3);
+
 	/* Manager commands */
 	ast_manager_register2("Agents", EVENT_FLAG_AGENT, action_agents, "Lists agents and their status", mandescr_agents);
 	ast_manager_register2("AgentLogoff", EVENT_FLAG_AGENT, action_agent_logoff, "Sets an agent as no longer logged in", mandescr_agent_logoff);
 	ast_manager_register2("AgentCallbackLogin", EVENT_FLAG_AGENT, action_agent_callback_login, "Sets an agent as logged in by callback", mandescr_agent_callback_login);
+
 	/* CLI Commands */
 	ast_cli_register(&cli_show_agents);
 	ast_cli_register(&cli_show_agents_online);
 	ast_cli_register(&cli_agent_logoff);
+
 	/* Dialplan Functions */
 	ast_custom_function_register(&agent_function);
+
 	/* Read in the config */
 	read_agent_config();
 	if (persistent_agents)

Modified: trunk/fixedjitterbuf.c
===================================================================
--- trunk/fixedjitterbuf.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/fixedjitterbuf.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -4,8 +4,6 @@
  * Contributors:
  * Slav Klenov <slav at securax.org>
  *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact
  * any of the maintainers of this project for assistance;
@@ -15,6 +13,9 @@
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
+ *
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 /*! \file 

Modified: trunk/include/asterisk/abstract_jb.h
===================================================================
--- trunk/include/asterisk/abstract_jb.h	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/include/asterisk/abstract_jb.h	2006-06-28 01:23:32 UTC (rev 354)
@@ -6,8 +6,6 @@
  * Contributors:
  * Slav Klenov <slav at securax.org>
  *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
- *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact
  * any of the maintainers of this project for assistance;
@@ -17,6 +15,9 @@
  * This program is free software, distributed under the terms of
  * the GNU General Public License Version 2. See the LICENSE file
  * at the top of the source tree.
+ *
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 /*! \file

Modified: trunk/include/asterisk/plc.h
===================================================================
--- trunk/include/asterisk/plc.h	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/include/asterisk/plc.h	2006-06-28 01:23:32 UTC (rev 354)
@@ -24,7 +24,9 @@
  * Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
  *
  * This version may be optionally licenced under the GNU LGPL licence.
- * This version is disclaimed to DIGIUM for inclusion in the Asterisk project.
+ *
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 

Modified: trunk/include/asterisk/udptl.h
===================================================================
--- trunk/include/asterisk/udptl.h	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/include/asterisk/udptl.h	2006-06-28 01:23:32 UTC (rev 354)
@@ -11,7 +11,8 @@
  * This program is free software, distributed under the terms of
  * the GNU General Public License
  *
- * This version is disclaimed to DIGIUM for inclusion in the Asterisk project.
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 #ifndef _ASTERISK_UDPTL_H

Modified: trunk/jitterbuf.c
===================================================================
--- trunk/jitterbuf.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/jitterbuf.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -6,7 +6,8 @@
  * Contributors:
  * Steve Kann <stevek at stevek.com>
  *
- * Copyright on this file is disclaimed to Digium for inclusion in Asterisk
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact

Modified: trunk/plc.c
===================================================================
--- trunk/plc.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/plc.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -19,7 +19,8 @@
  *
  * This version may be optionally licenced under the GNU LGPL licence.
  *
- * This version is disclaimed to DIGIUM for inclusion in the Asterisk project.
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 /*! \file

Modified: trunk/udptl.c
===================================================================
--- trunk/udptl.c	2006-06-28 01:22:51 UTC (rev 353)
+++ trunk/udptl.c	2006-06-28 01:23:32 UTC (rev 354)
@@ -11,7 +11,8 @@
  * This program is free software, distributed under the terms of
  * the GNU General Public License
  *
- * This version is disclaimed to DIGIUM for inclusion in the Asterisk project.
+ * A license has been granted to Digium (via disclaimer) for the use of
+ * this code.
  */
 
 #include "asterisk.h"



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:24:50 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:24:50 +0200
Subject: [solid-pbx-svn] r355 - trunk/channels
Message-ID: <200606280124.k5S1Oo66013188@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:24:19 +0200 (Wed, 28 Jun 2006)
New Revision: 355

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r34133

------------------------------------------------------------------------
r34126 | oej | 2006-06-14 17:15:29 +0200 (Wed, 14 Jun 2006) | 2 lines

Add some debug logging

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 01:23:32 UTC (rev 354)
+++ trunk/channels/chan_sip.c	2006-06-28 01:24:19 UTC (rev 355)
@@ -11631,7 +11631,8 @@
 					if (!p->refer) {
 						ast_log(LOG_WARNING, "Notify answer on an owned channel? - %s\n", p->owner->name);
 						ast_queue_hangup(p->owner);
-					}
+					} else if (option_debug > 3) 
+						ast_log(LOG_DEBUG, "Got OK on REFER Notify message\n");
 				} else {
 					if (p->subscribed == NONE) 
 						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY); 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:25:48 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:25:48 +0200
Subject: [solid-pbx-svn] r356 - in trunk: apps channels
Message-ID: <200606280125.k5S1Pmg4013245@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:25:41 +0200 (Wed, 28 Jun 2006)
New Revision: 356

Modified:
   trunk/apps/app_queue.c
   trunk/channels/chan_iax2.c
   trunk/channels/chan_local.c
Log:
Update to Asterisk SVN trunk r34163

------------------------------------------------------------------------
r34161 | kpfleming | 2006-06-15 00:35:49 +0200 (Thu, 15 Jun 2006) | 15 lines

Merged revisions 34159-34160 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34159 | kpfleming | 2006-06-14 17:17:37 -0500 (Wed, 14 Jun 2006) | 2 lines

use existing dial string parser for strings supplied to iax2_devicestate, because they can be complete dial strings, not just device names

.......
r34160 | kpfleming | 2006-06-14 17:22:21 -0500 (Wed, 14 Jun 2006) | 2 lines

coding style cleanups on queue interface handling code that was committed for the last release

.......

------------------------------------------------------------------------
r34162 | kpfleming | 2006-06-15 00:39:19 +0200 (Thu, 15 Jun 2006) | 2 lines

make Local channel return sensible device state values

------------------------------------------------------------------------


Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-28 01:24:19 UTC (rev 355)
+++ trunk/apps/app_queue.c	2006-06-28 01:25:41 UTC (rev 356)
@@ -510,8 +510,7 @@
 	technology = ast_strdupa(sc->dev);
 	loc = strchr(technology, '/');
 	if (loc) {
-		*loc = '\0';
-		loc++;
+		*loc++ = '\0';
 	} else {
 		free(sc);
 		return NULL;
@@ -524,43 +523,44 @@
 	}
 	AST_LIST_UNLOCK(&interfaces);
 
-	if (curint) {
+	if (!curint) {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Device '%s/%s' changed to state '%d' (%s) but we don't care because they're not a member of any queue.\n", technology, loc, sc->state, devstate2str(sc->state));
+		free(sc);
+		return NULL;
+        }
 
-		if (option_debug)
-			ast_log(LOG_DEBUG, "Device '%s/%s' changed to state '%d' (%s)\n", technology, loc, sc->state, devstate2str(sc->state));
-		AST_LIST_LOCK(&queues);
-		AST_LIST_TRAVERSE(&queues, q, list) {
-			ast_mutex_lock(&q->lock);
-			cur = q->members;
-			while(cur) {
-				if (!strcasecmp(sc->dev, cur->interface)) {
-					if (cur->status != sc->state) {
-						cur->status = sc->state;
-						if (!q->maskmemberstatus) {
-							manager_event(EVENT_FLAG_AGENT, "QueueMemberStatus",
-								"Queue: %s\r\n"
-								"Location: %s\r\n"
-								"Membership: %s\r\n"
-								"Penalty: %d\r\n"
-								"CallsTaken: %d\r\n"
-								"LastCall: %d\r\n"
-								"Status: %d\r\n"
-								"Paused: %d\r\n",
-							q->name, cur->interface, cur->dynamic ? "dynamic" : "static",
-							cur->penalty, cur->calls, (int)cur->lastcall, cur->status, cur->paused);
-						}
-					}
-				}
-				cur = cur->next;
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Device '%s/%s' changed to state '%d' (%s)\n", technology, loc, sc->state, devstate2str(sc->state));
+	AST_LIST_LOCK(&queues);
+	AST_LIST_TRAVERSE(&queues, q, list) {
+		ast_mutex_lock(&q->lock);
+		for (cur = q->members; cur; cur = cur->next) {
+			if (strcasecmp(sc->dev, cur->interface))
+				continue;
+
+			if (cur->status != sc->state) {
+				cur->status = sc->state;
+				if (q->maskmemberstatus)
+					continue;
+
+				manager_event(EVENT_FLAG_AGENT, "QueueMemberStatus",
+					      "Queue: %s\r\n"
+					      "Location: %s\r\n"
+					      "Membership: %s\r\n"
+					      "Penalty: %d\r\n"
+					      "CallsTaken: %d\r\n"
+					      "LastCall: %d\r\n"
+					      "Status: %d\r\n"
+					      "Paused: %d\r\n",
+					      q->name, cur->interface, cur->dynamic ? "dynamic" : "static",
+					      cur->penalty, cur->calls, (int)cur->lastcall, cur->status, cur->paused);
 			}
-			ast_mutex_unlock(&q->lock);
 		}
-		AST_LIST_UNLOCK(&queues);
-	} else {
-		if (option_debug)
-			ast_log(LOG_DEBUG, "Device '%s/%s' changed to state '%d' (%s) but we don't care because they're not a member of any queue.\n", technology, loc, sc->state, devstate2str(sc->state));
+		ast_mutex_unlock(&q->lock);
 	}
-	free(sc);
+	AST_LIST_UNLOCK(&queues);
+
 	return NULL;
 }
 
@@ -571,17 +571,19 @@
 	struct statechange *sc;
 	pthread_t t;
 	pthread_attr_t attr;
-	
-	if ((sc = ast_calloc(1, sizeof(*sc) + strlen(dev) + 1))) {
-		sc->state = state;
-		strcpy(sc->dev, dev);
-		pthread_attr_init(&attr);
-		pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
-		if (ast_pthread_create(&t, &attr, changethread, sc)) {
-			ast_log(LOG_WARNING, "Failed to create update thread!\n");
-			free(sc);
-		}
+
+	if (!(sc = ast_calloc(1, sizeof(*sc) + strlen(dev) + 1)))
+		return 0;
+
+	sc->state = state;
+	strcpy(sc->dev, dev);
+	pthread_attr_init(&attr);
+	pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
+	if (ast_pthread_create(&t, &attr, changethread, sc)) {
+		ast_log(LOG_WARNING, "Failed to create update thread!\n");
+		free(sc);
 	}
+
 	return 0;
 }
 
@@ -660,7 +662,7 @@
 
 static int add_to_interfaces(char *interface) 
 {
-	struct ast_member_interfaces *curint, *newint;
+	struct ast_member_interfaces *curint;
 
 	AST_LIST_LOCK(&interfaces);
 	AST_LIST_TRAVERSE(&interfaces, curint, list) {
@@ -668,18 +670,21 @@
 			break; 
 	}
 
-	if (!curint) {
-		if (option_debug)
-			ast_log(LOG_DEBUG, "Adding %s to the list of interfaces that make up all of our queue members.\n", interface);
+	if (curint) {
+		AST_LIST_UNLOCK(&interfaces);
+		return 0;
+	}
 
-	        if ((newint = ast_calloc(1, sizeof(*newint)))) {
-			ast_copy_string(newint->interface, interface, sizeof(newint->interface));
-			AST_LIST_INSERT_HEAD(&interfaces, newint, list);
-		}
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Adding %s to the list of interfaces that make up all of our queue members.\n", interface);
+	
+	if ((curint = ast_calloc(1, sizeof(*curint)))) {
+		ast_copy_string(curint->interface, interface, sizeof(curint->interface));
+		AST_LIST_INSERT_HEAD(&interfaces, curint, list);
 	}
 	AST_LIST_UNLOCK(&interfaces);
 
- return 0;
+	return 0;
 }
 
 static int interface_exists_global(char *interface)
@@ -691,31 +696,33 @@
 	AST_LIST_LOCK(&queues);
 	AST_LIST_TRAVERSE(&queues, q, list) {
 		ast_mutex_lock(&q->lock);
-		for (mem = q->members; mem; mem = mem->next)
-			if (!strcasecmp(interface, mem->interface)) {
-				ast_mutex_unlock(&q->lock);
+		for (mem = q->members; mem && !ret; mem = mem->next) {
+			if (!strcasecmp(interface, mem->interface))
 				ret = 1;
-				break;
-			}
+		}
 		ast_mutex_unlock(&q->lock);
+		if (ret)
+			break;
 	}
 	AST_LIST_UNLOCK(&queues);
 
 	return ret;
 }
 
-
 static int remove_from_interfaces(char *interface)
 {
 	struct ast_member_interfaces *curint;
 
 	AST_LIST_LOCK(&interfaces);
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&interfaces, curint, list) {
-		if (!strcasecmp(curint->interface, interface) && !interface_exists_global(interface)) {
-			if (option_debug)
-				ast_log(LOG_DEBUG, "Removing %s from the list of interfaces that make up all of our queue members.\n", interface);
-			AST_LIST_REMOVE_CURRENT(&interfaces, list);
-			free(curint);
+		if (!strcasecmp(curint->interface, interface)) {
+			if (!interface_exists_global(interface)) {
+				if (option_debug)
+					ast_log(LOG_DEBUG, "Removing %s from the list of interfaces that make up all of our queue members.\n", interface);
+				AST_LIST_REMOVE_CURRENT(&interfaces, list);
+				free(curint);
+			}
+			break;
 		}
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
@@ -729,14 +736,9 @@
 	struct ast_member_interfaces *curint;
 
 	AST_LIST_LOCK(&interfaces);
-	AST_LIST_TRAVERSE_SAFE_BEGIN(&interfaces, curint, list) {
-		AST_LIST_REMOVE_CURRENT(&interfaces, list);
+	while ((curint = AST_LIST_REMOVE_HEAD(&interfaces, list)))
 		free(curint);
-	}
-	AST_LIST_TRAVERSE_SAFE_END;
 	AST_LIST_UNLOCK(&interfaces);
-
- 	return;
 }
 
 /*! \brief Configure a queue parameter.

Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 01:24:19 UTC (rev 355)
+++ trunk/channels/chan_iax2.c	2006-06-28 01:25:41 UTC (rev 356)
@@ -9511,51 +9511,39 @@
 /*! \brief Part of the device state notification system ---*/
 static int iax2_devicestate(void *data) 
 {
-	char *dest = (char *) data;
+	struct parsed_dial_string pds;
+	char *tmp = ast_strdupa(data);
 	struct iax2_peer *p;
-	int found = 0;
-	char *ext, *host;
-	char tmp[256];
 	int res = AST_DEVICE_INVALID;
 
-	ast_copy_string(tmp, dest, sizeof(tmp));
-	host = strchr(tmp, '@');
-	if (host) {
-		*host = '\0';
-		host++;
-		ext = tmp;
-	} else {
-		host = tmp;
-		ext = NULL;
-	}
-
+	parse_dial_string(tmp, &pds);
+	if (ast_strlen_zero(pds.peer))
+		return res;
+	
 	if (option_debug > 2)
-		ast_log(LOG_DEBUG, "Checking device state for device %s\n", dest);
+		ast_log(LOG_DEBUG, "Checking device state for device %s\n", pds.peer);
 
 	/* SLD: FIXME: second call to find_peer during registration */
-	p = find_peer(host, 1);
-	if (p) {
-		found++;
-		res = AST_DEVICE_UNAVAILABLE;
-		if (option_debug > 2) 
-			ast_log(LOG_DEBUG, "iax2_devicestate(%s): Found peer. What's device state of %s? addr=%d, defaddr=%d maxms=%d, lastms=%d\n",
-				host, dest, p->addr.sin_addr.s_addr, p->defaddr.sin_addr.s_addr, p->maxms, p->lastms);
+	if (!(p = find_peer(pds.peer, 1)))
+		return res;
 
-		if ((p->addr.sin_addr.s_addr || p->defaddr.sin_addr.s_addr) &&
-		    (!p->maxms || ((p->lastms > -1) && (p->historicms <= p->maxms)))) {
-			/* Peer is registered, or have default IP address
-			   and a valid registration */
-			if (p->historicms == 0 || p->historicms <= p->maxms)
-				/* let the core figure out whether it is in use or not */
-				res = AST_DEVICE_UNKNOWN;	
-		}
-	} else {
-		if (option_debug > 2) 
-			ast_log(LOG_DEBUG, "Devicestate: Can't find peer %s.\n", host);
-	}
+	res = AST_DEVICE_UNAVAILABLE;
+	if (option_debug > 2) 
+		ast_log(LOG_DEBUG, "iax2_devicestate: Found peer. What's device state of %s? addr=%d, defaddr=%d maxms=%d, lastms=%d\n",
+			pds.peer, p->addr.sin_addr.s_addr, p->defaddr.sin_addr.s_addr, p->maxms, p->lastms);
 	
-	if (p && ast_test_flag(p, IAX_TEMPONLY))
+	if ((p->addr.sin_addr.s_addr || p->defaddr.sin_addr.s_addr) &&
+	    (!p->maxms || ((p->lastms > -1) && (p->historicms <= p->maxms)))) {
+		/* Peer is registered, or have default IP address
+		   and a valid registration */
+		if (p->historicms == 0 || p->historicms <= p->maxms)
+			/* let the core figure out whether it is in use or not */
+			res = AST_DEVICE_UNKNOWN;	
+	}
+
+	if (ast_test_flag(p, IAX_TEMPONLY))
 		destroy_peer(p);
+
 	return res;
 }
 

Modified: trunk/channels/chan_local.c
===================================================================
--- trunk/channels/chan_local.c	2006-06-28 01:24:19 UTC (rev 355)
+++ trunk/channels/chan_local.c	2006-06-28 01:25:41 UTC (rev 356)
@@ -138,9 +138,9 @@
 		ast_log(LOG_DEBUG, "Checking if extension %s@%s exists (devicestate)\n", exten, context);
 	res = ast_exists_extension(NULL, context, exten, 1, NULL);
 	if (!res)
-		return AST_DEVICE_NOT_INUSE;
+		return AST_DEVICE_INVALID;
 	else
-		return AST_DEVICE_INUSE;
+		return AST_DEVICE_UNKNOWN;
 }
 
 static int local_queue_frame(struct local_pvt *p, int isoutbound, struct ast_frame *f, struct ast_channel *us)



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:26:24 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:26:24 +0200
Subject: [solid-pbx-svn] r357 - trunk/apps
Message-ID: <200606280126.k5S1QOsZ013309@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:26:20 +0200 (Wed, 28 Jun 2006)
New Revision: 357

Modified:
   trunk/apps/app_queue.c
Log:
Update to Asterisk SVN trunk r34193

------------------------------------------------------------------------
r34193 | kpfleming | 2006-06-15 01:20:08 +0200 (Thu, 15 Jun 2006) | 2 lines

various coding style cleanup and minor fixes

------------------------------------------------------------------------


Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-28 01:25:41 UTC (rev 356)
+++ trunk/apps/app_queue.c	2006-06-28 01:26:20 UTC (rev 357)
@@ -424,20 +424,24 @@
 static char *int2strat(int strategy)
 {
 	int x;
-	for (x=0;x<sizeof(strategies) / sizeof(strategies[0]);x++) {
+
+	for (x = 0; x < sizeof(strategies) / sizeof(strategies[0]); x++) {
 		if (strategy == strategies[x].strategy)
 			return strategies[x].name;
 	}
+
 	return "<unknown>";
 }
 
 static int strat2int(const char *strategy)
 {
 	int x;
-	for (x=0;x<sizeof(strategies) / sizeof(strategies[0]);x++) {
+
+	for (x = 0; x < sizeof(strategies) / sizeof(strategies[0]); x++) {
 		if (!strcasecmp(strategy, strategies[x].name))
 			return strategies[x].strategy;
 	}
+
 	return -1;
 }
 
@@ -591,8 +595,6 @@
 {
 	struct member *cur;
 	
-	/* Add a new member */
-
 	if ((cur = ast_calloc(1, sizeof(*cur)))) {
 		cur->penalty = penalty;
 		cur->paused = paused;
@@ -619,6 +621,7 @@
 static void init_queue(struct ast_call_queue *q)
 {
 	int i;
+
 	q->dead = 0;
 	q->retry = DEFAULT_RETRY;
 	q->timeout = -1;
@@ -646,7 +649,7 @@
 	ast_copy_string(q->sound_lessthan, "queue-less-than", sizeof(q->sound_lessthan));
 	ast_copy_string(q->sound_reporthold, "queue-reporthold", sizeof(q->sound_reporthold));
 	ast_copy_string(q->sound_periodicannounce[0], "queue-periodic-announce", sizeof(q->sound_periodicannounce[0]));
-	for (i=1;i<MAX_PERIODIC_ANNOUNCEMENTS;i++) {
+	for (i = 1; i < MAX_PERIODIC_ANNOUNCEMENTS; i++) {
 		q->sound_periodicannounce[i][0]='\0';
 	}
 }
@@ -753,6 +756,7 @@
 	int i = 0;
 	char *c, *lastc;
 	char buff[80];
+
 	if (!strcasecmp(param, "music") || !strcasecmp(param, "musiconhold")) {
 		ast_copy_string(q->moh, val, sizeof(q->moh));
 	} else if (!strcasecmp(param, "announce")) {
@@ -902,24 +906,20 @@
 	struct member *m, *prev_m;
 	int penalty = 0;
 
-	if(penalty_str) {
+	if (penalty_str) {
 		penalty = atoi(penalty_str);
-		if(penalty < 0)
+		if (penalty < 0)
 			penalty = 0;
 	}
 
 	/* Find the member, or the place to put a new one. */
-	prev_m = NULL;
-	m = q->members;
-	while (m && strcmp(m->interface, interface)) {
-		prev_m = m;
-		m = m->next;
-	}
+	for (m = q->members, prev_m = NULL;
+	     m && strcmp(m->interface, interface);
+	     prev_m = m, m = m->next);
 
 	/* Create a new one if not found, else update penalty */
 	if (!m) {
-		m = create_queue_member(interface, penalty, 0);
-		if (m) {
+		if ((m = create_queue_member(interface, penalty, 0))) {
 			m->dead = 0;
 			add_to_interfaces(interface);
 			if (prev_m) {
@@ -974,9 +974,8 @@
 
 	/* Find the queue in the in-core list (we will create a new one if not found). */
 	AST_LIST_TRAVERSE(&queues, q, list) {
-		if (!strcasecmp(q->name, queuename)) {
+		if (!strcasecmp(q->name, queuename))
 			break;
-		}
 	}
 
 	/* Static queues override realtime. */
@@ -1028,38 +1027,32 @@
 	}
 	init_queue(q);		/* Ensure defaults for all parameters not set explicitly. */
 
-	v = queue_vars;
 	memset(tmpbuf, 0, sizeof(tmpbuf));
-	while(v) {
+	for (v = queue_vars; v; v = v->next) {
 		/* Convert to dashes `-' from underscores `_' as the latter are more SQL friendly. */
-		if((tmp = strchr(v->name, '_')) != NULL) {
+		if ((tmp = strchr(v->name, '_'))) {
 			ast_copy_string(tmpbuf, v->name, sizeof(tmpbuf));
 			tmp_name = tmpbuf;
 			tmp = tmp_name;
-			while((tmp = strchr(tmp, '_')) != NULL)
+			while ((tmp = strchr(tmp, '_')))
 				*tmp++ = '-';
 		} else
 			tmp_name = v->name;
 		queue_set_param(q, tmp_name, v->value, -1, 0);
-		v = v->next;
 	}
 
 	if (q->strategy == QUEUE_STRATEGY_ROUNDROBIN)
 		rr_dep_warning();
 
 	/* Temporarily set non-dynamic members dead so we can detect deleted ones. */
-	m = q->members;
-	while (m) {
+	for (m = q->members; m; m = m->next) {
 		if (!m->dynamic)
 			m->dead = 1;
-		m = m->next;
 	}
 
-	interface = ast_category_browse(member_config, NULL);
-	while (interface) {
+	interface = NULL;
+	while (ast_category_browse(member_config, interface))
 		rt_handle_member_record(q, interface, ast_variable_retrieve(member_config, interface, "penalty"));
-		interface = ast_category_browse(member_config, interface);
-	}
 
 	/* Delete all realtime members that have been deleted in DB. */
 	m = q->members;
@@ -1087,7 +1080,7 @@
 
 static struct ast_call_queue *load_realtime_queue(char *queuename)
 {
-	struct ast_variable *queue_vars = NULL;
+	struct ast_variable *queue_vars;
 	struct ast_config *member_config = NULL;
 	struct ast_call_queue *q;
 
@@ -1141,8 +1134,7 @@
 	int inserted = 0;
 	enum queue_member_status stat;
 
-	q = load_realtime_queue(queuename);
-	if (!q)
+	if (!(q = load_realtime_queue(queuename)))
 		return res;
 
 	AST_LIST_LOCK(&queues);
@@ -1163,7 +1155,7 @@
 		inserted = 0;
 		prev = NULL;
 		cur = q->head;
-		while(cur) {
+		while (cur) {
 			/* We have higher priority than the current user, enter
 			 * before him, after all the other users with priority
 			 * higher or equal to our priority. */
@@ -1183,7 +1175,6 @@
 		ast_copy_string(qe->context, q->context, sizeof(qe->context));
 		q->count++;
 		res = 0;
-		/* XXX missing CalledIDnum ? */
 		manager_event(EVENT_FLAG_CALL, "Join", 
 			      "Channel: %s\r\nCallerID: %s\r\nCallerIDName: %s\r\nQueue: %s\r\nPosition: %d\r\nCount: %d\r\nUniqueid: %s\r\n",
 			      qe->chan->name, 
@@ -1195,6 +1186,7 @@
 	}
 	ast_mutex_unlock(&q->lock);
 	AST_LIST_UNLOCK(&queues);
+
 	return res;
 }
 
@@ -1204,12 +1196,8 @@
 
 	ast_stopstream(chan);
 	res = ast_streamfile(chan, filename, chan->language);
-
 	if (!res)
 		res = ast_waitstream(chan, AST_DIGIT_ANY);
-	else
-		res = 0;
-
 	ast_stopstream(chan);
 
 	return res;
@@ -1243,6 +1231,7 @@
 		/* Return 1 on a successful goto */
 		return 1;
 	}
+
 	return 0;
 }
 
@@ -1253,11 +1242,11 @@
 
 	/* Check to see if this is ludicrous -- if we just announced position, don't do it again*/
 	time(&now);
-	if ( (now - qe->last_pos) < 15 )
+	if ((now - qe->last_pos) < 15)
 		return 0;
 
 	/* If either our position has changed, or we are over the freq timer, say position */
-	if ( (qe->last_pos_said == qe->pos) && ((now - qe->last_pos) < qe->parent->announcefrequency) )
+	if ((qe->last_pos_said == qe->pos) && ((now - qe->last_pos) < qe->parent->announcefrequency))
 		return 0;
 
 	ast_moh_stop(qe->chan);
@@ -1280,14 +1269,14 @@
 			goto playout;
 	}
 	/* Round hold time to nearest minute */
-	avgholdmins = abs(( (qe->parent->holdtime + 30) - (now - qe->start) ) / 60);
+	avgholdmins = abs(((qe->parent->holdtime + 30) - (now - qe->start)) / 60);
 
 	/* If they have specified a rounding then round the seconds as well */
-	if(qe->parent->roundingseconds) {
-		avgholdsecs = (abs(( (qe->parent->holdtime + 30) - (now - qe->start) )) - 60 * avgholdmins) / qe->parent->roundingseconds;
-		avgholdsecs*= qe->parent->roundingseconds;
+	if (qe->parent->roundingseconds) {
+		avgholdsecs = (abs(((qe->parent->holdtime + 30) - (now - qe->start))) - 60 * avgholdmins) / qe->parent->roundingseconds;
+		avgholdsecs *= qe->parent->roundingseconds;
 	} else {
-		avgholdsecs=0;
+		avgholdsecs = 0;
 	}
 
 	if (option_verbose > 2)
@@ -1301,17 +1290,17 @@
 		if (res && valid_exit(qe, res))
 			goto playout;
 
-		if (avgholdmins>0) {
+		if (avgholdmins > 0) {
 			if (avgholdmins < 2) {
 				res = play_file(qe->chan, qe->parent->sound_lessthan);
 				if (res && valid_exit(qe, res))
 					goto playout;
 
-				res = ast_say_number(qe->chan, 2, AST_DIGIT_ANY, qe->chan->language, (char *)NULL);
+				res = ast_say_number(qe->chan, 2, AST_DIGIT_ANY, qe->chan->language, NULL);
 				if (res && valid_exit(qe, res))
 					goto playout;
 			} else {
-				res = ast_say_number(qe->chan, avgholdmins, AST_DIGIT_ANY, qe->chan->language, (char*) NULL);
+				res = ast_say_number(qe->chan, avgholdmins, AST_DIGIT_ANY, qe->chan->language, NULL);
 				if (res && valid_exit(qe, res))
 					goto playout;
 			}
@@ -1321,7 +1310,7 @@
 				goto playout;
 		}
 		if (avgholdsecs>0) {
-			res = ast_say_number(qe->chan, avgholdsecs, AST_DIGIT_ANY, qe->chan->language, (char*) NULL);
+			res = ast_say_number(qe->chan, avgholdsecs, AST_DIGIT_ANY, qe->chan->language, NULL);
 			if (res && valid_exit(qe, res))
 				goto playout;
 
@@ -1377,14 +1366,12 @@
 	struct queue_ent *cur, *prev = NULL;
 	int pos = 0;
 
-	q = qe->parent;
-	if (!q)
+	if (!(q = qe->parent))
 		return;
 	ast_mutex_lock(&q->lock);
 
 	prev = NULL;
-	cur = q->head;
-	while(cur) {
+	for (cur = q->head; cur; cur = cur->next) {
 		if (cur == qe) {
 			q->count--;
 
@@ -1404,9 +1391,9 @@
 			cur->pos = ++pos;
 			prev = cur;
 		}
-		cur = cur->next;
 	}
 	ast_mutex_unlock(&q->lock);
+
 	if (q->dead && !q->count) {	
 		/* It's dead and nobody is in it, so kill it */
 		AST_LIST_LOCK(&queues);
@@ -1421,12 +1408,12 @@
 {
 	struct callattempt *oo;
 
-	while(outgoing) {
+	while (outgoing) {
 		/* Hangup any existing lines we have open */
 		if (outgoing->chan && (outgoing->chan != exception))
 			ast_hangup(outgoing->chan);
 		oo = outgoing;
-		outgoing=outgoing->q_next;
+		outgoing = outgoing->q_next;
 		free(oo);
 	}
 }
@@ -1439,22 +1426,22 @@
 		be sure it's still valid */
 	ast_mutex_lock(&q->lock);
 	for (cur = q->members; cur; cur = cur->next) {
-		if (member == cur) {
-			cur->status = status;
-			if (!q->maskmemberstatus) {
-				manager_event(EVENT_FLAG_AGENT, "QueueMemberStatus",
-					"Queue: %s\r\n"
-					"Location: %s\r\n"
-					"Membership: %s\r\n"
-					"Penalty: %d\r\n"
-					"CallsTaken: %d\r\n"
-					"LastCall: %d\r\n"
-					"Status: %d\r\n"
-					"Paused: %d\r\n",
-				q->name, cur->interface, cur->dynamic ? "dynamic" : "static",
-				cur->penalty, cur->calls, (int)cur->lastcall, cur->status, cur->paused);
-			}
-			break;
+		if (member != cur)
+			continue;
+
+		cur->status = status;
+		if (!q->maskmemberstatus) {
+			manager_event(EVENT_FLAG_AGENT, "QueueMemberStatus",
+				      "Queue: %s\r\n"
+				      "Location: %s\r\n"
+				      "Membership: %s\r\n"
+				      "Penalty: %d\r\n"
+				      "CallsTaken: %d\r\n"
+				      "LastCall: %d\r\n"
+				      "Status: %d\r\n"
+				      "Paused: %d\r\n",
+				      q->name, cur->interface, cur->dynamic ? "dynamic" : "static",
+				      cur->penalty, cur->calls, (int)cur->lastcall, cur->status, cur->paused);
 		}
 	}
 	ast_mutex_unlock(&q->lock);
@@ -1490,13 +1477,14 @@
 		ast_mutex_lock(&q->lock);
 		if (q->count && q->members) {
 			for (mem = q->members; mem; mem = mem->next) {
-				if (!strcmp(mem->interface, member->interface)) {
-					ast_log(LOG_DEBUG, "Found matching member %s in queue '%s'\n", mem->interface, q->name);
-					if (q->weight > rq->weight) {
-						ast_log(LOG_DEBUG, "Queue '%s' (weight %d, calls %d) is preferred over '%s' (weight %d, calls %d)\n", q->name, q->weight, q->count, rq->name, rq->weight, rq->count);
-						found = 1;
-						break;
-					}
+				if (strcmp(mem->interface, member->interface))
+					continue;
+
+				ast_log(LOG_DEBUG, "Found matching member %s in queue '%s'\n", mem->interface, q->name);
+				if (q->weight > rq->weight) {
+					ast_log(LOG_DEBUG, "Queue '%s' (weight %d, calls %d) is preferred over '%s' (weight %d, calls %d)\n", q->name, q->weight, q->count, rq->name, rq->weight, rq->count);
+					found = 1;
+					break;
 				}
 			}
 		}
@@ -1568,9 +1556,6 @@
 	/* Request the peer */
 	tmp->chan = ast_request(tech, qe->chan->nativeformats, location, &status);
 	if (!tmp->chan) {			/* If we can't, just go on to the next call */
-#if 0
-		ast_log(LOG_NOTICE, "Unable to create channel of type '%s' for Queue\n", cur->tech);
-#endif			
 		if (qe->chan->cdr)
 			ast_cdr_busy(qe->chan->cdr);
 		tmp->stillgoing = 0;
@@ -1600,8 +1585,7 @@
 	tmp->chan->adsicpe = qe->chan->adsicpe;
 
 	/* Place the call, but don't wait on the answer */
-	res = ast_call(tmp->chan, location, 0);
-	if (res) {
+	if ((res = ast_call(tmp->chan, location, 0))) {
 		/* Again, keep going even if there's an error */
 		if (option_debug)
 			ast_log(LOG_DEBUG, "ast call on peer returned %d\n", res);
@@ -1628,6 +1612,7 @@
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Called %s\n", tmp->interface);
 	}
+
 	return 1;
 }
 
@@ -1638,11 +1623,12 @@
 
 	for (cur = outgoing; cur; cur = cur->q_next) {
 		if (cur->stillgoing &&					/* Not already done */
-			!cur->chan &&					/* Isn't already going */
-			(!best || cur->metric < best->metric)) {	/* We haven't found one yet, or it's better */
-				best = cur;
+		    !cur->chan &&					/* Isn't already going */
+		    (!best || cur->metric < best->metric)) {		/* We haven't found one yet, or it's better */
+			best = cur;
 		}
 	}
+
 	return best;
 }
 
@@ -1676,6 +1662,7 @@
 		if (best->chan) /* break out with result = 1 */
 			ret = 1;
 	}
+
 	return ret;
 }
 
@@ -1699,6 +1686,7 @@
 		}
 	}
 	qe->parent->wrapped = 0;
+
 	return 0;
 }
 
@@ -1717,15 +1705,8 @@
 
 		/* Stop playback */
 		ast_stopstream(chan);
-	} else {
-		res = 0;
 	}
 	
-	/*if (res) {
-		ast_log(LOG_WARNING, "ast_streamfile failed on %s \n", chan->name);
-		res = 0;
-	}*/
-
 	return res;
 }
 
@@ -1786,7 +1767,6 @@
 /*! \brief RNA == Ring No Answer. Common code that is executed when we try a queue member and they don't answer. */
 static void rna(int rnatime, struct queue_ent *qe, char *membername)
 {
-
 	if (option_verbose > 2)
 		ast_verbose( VERBOSE_PREFIX_3 "Nobody picked up in %d ms\n", rnatime);
 	ast_queue_log(qe->parent->name, qe->chan->uniqueid, membername, "RINGNOANSWER", "%d", rnatime);
@@ -1822,7 +1802,7 @@
 	long starttime = 0;
 	long endtime = 0;	
 
-	starttime = (long)time(NULL);
+	starttime = (long) time(NULL);
 	
 	while(*to && !peer) {
 		int numlines, retry, pos = 1;
@@ -1867,9 +1847,10 @@
 			} else if (o->chan && (o->chan == winner)) {
 				ast_copy_string(on, o->member->interface, sizeof(on));
 				if (!ast_strlen_zero(o->chan->call_forward)) {
-					char tmpchan[256]="";
+					char tmpchan[256];
 					char *stuff;
 					char *tech;
+
 					ast_copy_string(tmpchan, o->chan->call_forward, sizeof(tmpchan));
 					if ((stuff = strchr(tmpchan, '/'))) {
 						*stuff++ = '\0';
@@ -1983,9 +1964,8 @@
 					}
 					ast_frfree(f);
 				} else {
-					endtime = (long)time(NULL);
-					endtime -= starttime;
-					rna(endtime*1000, qe, on);
+					endtime = (long) time(NULL) - starttime;
+					rna(endtime * 1000, qe, on);
 					do_hang(o);
 					if (qe->parent->strategy != QUEUE_STRATEGY_RINGALL) {
 						if (qe->parent->timeoutrestart)
@@ -1997,15 +1977,9 @@
 		}
 		if (winner == in) {
 			f = ast_read(in);
-#if 0
-			if (f && (f->frametype != AST_FRAME_VOICE))
-					printf("Frame type: %d, %d\n", f->frametype, f->subclass);
-			else if (!f || (f->frametype != AST_FRAME_VOICE))
-				printf("Hangup received on %s\n", in->name);
-#endif
 			if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_HANGUP))) {
 				/* Got hung up */
-				*to=-1;
+				*to = -1;
 				if (f)
 					ast_frfree(f);
 				return NULL;
@@ -2013,15 +1987,15 @@
 			if ((f->frametype == AST_FRAME_DTMF) && caller_disconnect && (f->subclass == '*')) {
 				if (option_verbose > 3)
 					ast_verbose(VERBOSE_PREFIX_3 "User hit %c to disconnect call.\n", f->subclass);
-				*to=0;
+				*to = 0;
 				ast_frfree(f);
 				return NULL;
 			}
 			if ((f->frametype == AST_FRAME_DTMF) && (f->subclass != '*') && valid_exit(qe, f->subclass)) {
 				if (option_verbose > 3)
 					ast_verbose(VERBOSE_PREFIX_3 "User pressed digit: %c\n", f->subclass);
-				*to=0;
-				*digit=f->subclass;
+				*to = 0;
+				*digit = f->subclass;
 				ast_frfree(f);
 				return NULL;
 			}
@@ -2032,7 +2006,6 @@
 	}
 
 	return peer;
-	
 }
 
 static int is_our_turn(struct queue_ent *qe)
@@ -2058,29 +2031,27 @@
 		}	
 
 	} else {
-
 		/* This needs a lock. How many members are available to be served? */
-	
 		ast_mutex_lock(&qe->parent->lock);
 			
 		ch = qe->parent->head;
-		cur = qe->parent->members;
 	
-		while (cur) {
-			if (cur->status == 1) 
-				avl++;
-			cur = cur->next;
+		if (qe->parent->strategy == QUEUE_STRATEGY_RINGALL) {
+			if (option_debug)
+				ast_log(LOG_DEBUG, "Even though there are %d available members, the strategy is ringall so only the head call is allowed in\n", avl);
+			avl = 1;
+		} else {
+			cur = qe->parent->members;
+			while (cur) {
+				if (cur->status == 1) 
+					avl++;
+				cur = cur->next;
+			}
 		}
 
 		if (option_debug)
 			ast_log(LOG_DEBUG, "There are %d available members.\n", avl);
 	
-		if (qe->parent->strategy == QUEUE_STRATEGY_RINGALL) {
-			if (option_debug)
-				ast_log(LOG_DEBUG, "Even though there are %d available members, the strategy is ringall so only the head call is allowed in!\n", avl);
-			avl = 1;
-		}
-	
 		while ((idx < avl) && (ch) && (ch != qe)) {
 			idx++;
 			ch = ch->next;			
@@ -2153,6 +2124,7 @@
 		if ((res = ast_waitfordigit(qe->chan, RECHECK * 1000)))
 			break;
 	}
+
 	return res;
 }
 
@@ -2235,7 +2207,7 @@
 static int try_calling(struct queue_ent *qe, const char *options, char *announceoverride, const char *url, int *go_on, const char *agi)
 {
 	struct member *cur;
-	struct callattempt *outgoing=NULL; /* the queue we are building */
+	struct callattempt *outgoing = NULL; /* the list of calls we are building */
 	int to;
 	char oldexten[AST_MAX_EXTENSION]="";
 	char oldcontext[AST_MAX_CONTEXT]="";
@@ -2265,7 +2237,6 @@
 	struct ast_app *mixmonapp = NULL;
 	char *p;
 
-
 	memset(&bridge_config, 0, sizeof(bridge_config));
 	time(&now);
 		
@@ -2312,8 +2283,9 @@
 	if (!ast_strlen_zero(announceoverride))
 		announce = announceoverride;
 
-	for (;cur; cur = cur->next) {
+	for (; cur; cur = cur->next) {
 		struct callattempt *tmp = ast_calloc(1, sizeof(*tmp));
+
 		if (!tmp) {
 			ast_mutex_unlock(&qe->parent->lock);
 			if (use_weight) 
@@ -2321,13 +2293,6 @@
 			goto out;
 		}
 		tmp->stillgoing = -1;
-		if (option_debug) {
-			if (url)
-				ast_log(LOG_DEBUG, "Queue with URL=%s_\n", url);
-			else 
-				ast_log(LOG_DEBUG, "Simple queue (no URL)\n");
-		}
-
 		tmp->member = cur;		/* Never directly dereference!  Could change on reload */
 		tmp->oldstatus = cur->status;
 		tmp->lastcall = cur->lastcall;
@@ -2387,6 +2352,7 @@
 		outgoing = NULL;
 		if (announce || qe->parent->reportholdtime || qe->parent->memberdelay) {
 			int res2;
+
 			res2 = ast_autoservice_start(qe->chan);
 			if (!res2) {
 				if (qe->parent->memberdelay) {
@@ -2518,14 +2484,13 @@
 				}
 
 				if (!monitor_options)
-					monitor_options = ast_strdupa("");
+					monitor_options = "";
 				
 				if (strchr(monitor_options, '|')) {
 					ast_log(LOG_WARNING, "MONITOR_OPTIONS cannot contain a '|'! Not recording.\n");
 					mixmonapp = NULL;
 				}
 
-
 				if (mixmonapp) {
 					if (!ast_strlen_zero(monitor_exec) && !ast_strlen_zero(monitor_options)) 
 						snprintf(mixmonargs, sizeof(mixmonargs)-1, "%s|b%s|%s", tmpid2, monitor_options, monitor_exec);
@@ -2571,7 +2536,7 @@
 				      "Holdtime: %ld\r\n"
 				      "BridgedChannel: %s\r\n",
 				      queuename, qe->chan->uniqueid, peer->name, member->interface,
-				      (long)time(NULL) - qe->start,peer->uniqueid);
+				      (long) time(NULL) - qe->start,peer->uniqueid);
 		ast_copy_string(oldcontext, qe->chan->context, sizeof(oldcontext));
 		ast_copy_string(oldexten, qe->chan->exten, sizeof(oldexten));
 		time(&callstart);
@@ -2580,10 +2545,11 @@
 
 		if (strcasecmp(oldcontext, qe->chan->context) || strcasecmp(oldexten, qe->chan->exten)) {
 			ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "TRANSFER", "%s|%s|%ld|%ld", 
-					  qe->chan->exten, qe->chan->context, (long)(callstart - qe->start), (long)(time(NULL) - callstart));
+				      qe->chan->exten, qe->chan->context, (long) (callstart - qe->start),
+				      (long) (time(NULL) - callstart));
 		} else if (qe->chan->_softhangup) {
 			ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "COMPLETECALLER", "%ld|%ld",
-				      (long)(callstart - qe->start), (long)(time(NULL) - callstart));
+				      (long) (callstart - qe->start), (long) (time(NULL) - callstart));
 			if (qe->parent->eventwhencalled)
 				manager_event(EVENT_FLAG_AGENT, "AgentComplete",
 					      "Queue: %s\r\n"
@@ -2594,9 +2560,10 @@
 					      "TalkTime: %ld\r\n"
 					      "Reason: caller\r\n",
 					      queuename, qe->chan->uniqueid, peer->name, member->interface,
-					      (long)(callstart - qe->start), (long)(time(NULL) - callstart));
+					      (long) (callstart - qe->start), (long) (time(NULL) - callstart));
 		} else {
-			ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "COMPLETEAGENT", "%ld|%ld", (long)(callstart - qe->start), (long)(time(NULL) - callstart));
+			ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "COMPLETEAGENT", "%ld|%ld",
+				      (long) (callstart - qe->start), (long) (time(NULL) - callstart));
 			if (qe->parent->eventwhencalled)
 				manager_event(EVENT_FLAG_AGENT, "AgentComplete",
 					      "Queue: %s\r\n"
@@ -2606,7 +2573,7 @@
 					      "TalkTime: %ld\r\n"
 					      "Reason: agent\r\n",
 					      queuename, qe->chan->uniqueid, peer->name, (long)(callstart - qe->start),
-					      (long)(time(NULL) - callstart));
+					      (long) (time(NULL) - callstart));
 		}
 
 		if (bridge != AST_PBX_NO_HANGUP_PEER)
@@ -2616,6 +2583,7 @@
 	}
 out:
 	hangupcalls(outgoing, NULL);
+
 	return res;
 }
 
@@ -2631,11 +2599,14 @@
 {
 	struct member *mem;
 
-	if (q)
-		for (mem = q->members; mem; mem = mem->next)
-			if (!strcasecmp(interface, mem->interface))
-				return mem;
+	if (!q)
+		return NULL;
 
+	for (mem = q->members; mem; mem = mem->next) {
+		if (!strcasecmp(interface, mem->interface))
+			return mem;
+	}
+
 	return NULL;
 }
 
@@ -2688,42 +2659,46 @@
 	AST_LIST_LOCK(&queues);
 	AST_LIST_TRAVERSE(&queues, q, list) {
 		ast_mutex_lock(&q->lock);
-		if (!strcmp(q->name, queuename)) {
-			if ((last_member = interface_exists(q, interface))) {
-				if ((look = q->members) == last_member) {
-					q->members = last_member->next;
-				} else {
-					while (look != NULL) {
-						if (look->next == last_member) {
-							look->next = last_member->next;
-							break;
-						} else {
-							 look = look->next;
-						}
-					}
-				}
-				manager_event(EVENT_FLAG_AGENT, "QueueMemberRemoved",
-						"Queue: %s\r\n"
-						"Location: %s\r\n",
-					q->name, last_member->interface);
-				free(last_member);
+		if (strcmp(q->name, queuename)) {
+			ast_mutex_unlock(&q->lock);
+			continue;
+		}
 
-				if (queue_persistent_members)
-					dump_queue_members(q);
-
-				res = RES_OKAY;
+		if ((last_member = interface_exists(q, interface))) {
+			if ((look = q->members) == last_member) {
+				q->members = last_member->next;
 			} else {
-				res = RES_EXISTS;
+				while (look != NULL) {
+					if (look->next == last_member) {
+						look->next = last_member->next;
+						break;
+					} else {
+						look = look->next;
+					}
+				}
 			}
-			ast_mutex_unlock(&q->lock);
-			break;
+			manager_event(EVENT_FLAG_AGENT, "QueueMemberRemoved",
+				      "Queue: %s\r\n"
+				      "Location: %s\r\n",
+				      q->name, last_member->interface);
+			free(last_member);
+			
+			if (queue_persistent_members)
+				dump_queue_members(q);
+			
+			res = RES_OKAY;
+		} else {
+			res = RES_EXISTS;
 		}
 		ast_mutex_unlock(&q->lock);
+		break;
 	}
-	if (res == RES_OKAY) {
+
+	if (res == RES_OKAY)
 		remove_from_interfaces(interface);
-	}
+
 	AST_LIST_UNLOCK(&queues);
+
 	return res;
 }
 
@@ -2736,47 +2711,44 @@
 
 	/* \note Ensure the appropriate realtime queue is loaded.  Note that this
 	 * short-circuits if the queue is already in memory. */
-	q = load_realtime_queue(queuename);
+	if (!(q = load_realtime_queue(queuename)))
+		return res;
 
 	AST_LIST_LOCK(&queues);
 
-	if (q) {
-		ast_mutex_lock(&q->lock);
-		if (interface_exists(q, interface) == NULL) {
-
-			add_to_interfaces(interface);
-
-			new_member = create_queue_member(interface, penalty, paused);
-
-			if (new_member != NULL) {
-				new_member->dynamic = 1;
-				new_member->next = q->members;
-				q->members = new_member;
-				manager_event(EVENT_FLAG_AGENT, "QueueMemberAdded",
-						"Queue: %s\r\n"
-						"Location: %s\r\n"
-						"Membership: %s\r\n"
-						"Penalty: %d\r\n"
-						"CallsTaken: %d\r\n"
-						"LastCall: %d\r\n"
-						"Status: %d\r\n"
-						"Paused: %d\r\n",
-						q->name, new_member->interface, new_member->dynamic ? "dynamic" : "static",
-						new_member->penalty, new_member->calls, (int)new_member->lastcall, new_member->status, new_member->paused);
-
-				if (dump)
-					dump_queue_members(q);
-
-				res = RES_OKAY;
-			} else {
-				res = RES_OUTOFMEMORY;
-			}
+	ast_mutex_lock(&q->lock);
+	if (interface_exists(q, interface) == NULL) {
+		add_to_interfaces(interface);
+		if ((new_member = create_queue_member(interface, penalty, paused))) {
+			new_member->dynamic = 1;
+			new_member->next = q->members;
+			q->members = new_member;
+			manager_event(EVENT_FLAG_AGENT, "QueueMemberAdded",
+				      "Queue: %s\r\n"
+				      "Location: %s\r\n"
+				      "Membership: %s\r\n"
+				      "Penalty: %d\r\n"
+				      "CallsTaken: %d\r\n"
+				      "LastCall: %d\r\n"
+				      "Status: %d\r\n"
+				      "Paused: %d\r\n",
+				      q->name, new_member->interface, new_member->dynamic ? "dynamic" : "static",
+				      new_member->penalty, new_member->calls, (int) new_member->lastcall,
+				      new_member->status, new_member->paused);
+			
+			if (dump)
+				dump_queue_members(q);
+			
+			res = RES_OKAY;
 		} else {
-			res = RES_EXISTS;
+			res = RES_OUTOFMEMORY;
 		}
-		ast_mutex_unlock(&q->lock);
+	} else {
+		res = RES_EXISTS;
 	}
+	ast_mutex_unlock(&q->lock);
 	AST_LIST_UNLOCK(&queues);
+
 	return res;
 }
 
@@ -2817,10 +2789,7 @@
 	}
 	AST_LIST_UNLOCK(&queues);
 
-	if (found)
-		return RESULT_SUCCESS;
-	else
-		return RESULT_FAILURE;
+	return found ? RESULT_SUCCESS : RESULT_FAILURE;
 }
 
 /* Reload dynamic queue members persisted into the astdb */
@@ -2960,6 +2929,7 @@
 
 	LOCAL_USER_REMOVE(lu);
 	pbx_builtin_setvar_helper(chan, "PQMSTATUS", "PAUSED");
+
 	return 0;
 }
 
@@ -3012,6 +2982,7 @@
 
 	LOCAL_USER_REMOVE(lu);
 	pbx_builtin_setvar_helper(chan, "UPQMSTATUS", "UNPAUSED");
+
 	return 0;
 }
 
@@ -3075,6 +3046,7 @@
 	}
 
 	LOCAL_USER_REMOVE(lu);
+
 	return res;
 }
 
@@ -3147,6 +3119,7 @@
 	}
 
 	LOCAL_USER_REMOVE(lu);
+
 	return res;
 }
 
@@ -3160,10 +3133,8 @@
 	int prio;
 	int max_penalty;
 	enum queue_result reason = QUEUE_UNKNOWN;
-
 	/* whether to exit Queue application after the timeout hits */
 	int go_on = 0;
-
 	char *parse;
 	AST_DECLARE_APP_ARGS(args,
 		 AST_APP_ARG(queuename);
@@ -3173,7 +3144,6 @@
 		 AST_APP_ARG(queuetimeoutstr);
 		 AST_APP_ARG(agi);
 	);
-	
 	/* Our queue entry */
 	struct queue_ent qe;
 	
@@ -3261,7 +3231,8 @@
 			if (res < 0) {
 				/* Record this abandoned call */
 				record_abandoned(&qe);
-				ast_queue_log(args.queuename, chan->uniqueid, "NONE", "ABANDON", "%d|%d|%ld", qe.pos, qe.opos, (long)time(NULL) - qe.start);
+				ast_queue_log(args.queuename, chan->uniqueid, "NONE", "ABANDON", "%d|%d|%ld",
+					      qe.pos, qe.opos, (long) time(NULL) - qe.start);
 				if (option_verbose > 2) {
 					ast_verbose(VERBOSE_PREFIX_3 "User disconnected from queue %s while waiting their turn\n", args.queuename);
 				}
@@ -3277,6 +3248,7 @@
 		}
 		if (!res) {
 			int makeannouncement = 0;
+
 			for (;;) {
 				/* This is the wait loop for the head caller*/
 				/* To exit, they may get their call answered; */
@@ -3318,10 +3290,13 @@
 					if (res < 0) {
 						if (!qe.handled) {
 							record_abandoned(&qe);
-							ast_queue_log(args.queuename, chan->uniqueid, "NONE", "ABANDON", "%d|%d|%ld", qe.pos, qe.opos, (long)time(NULL) - qe.start);
+							ast_queue_log(args.queuename, chan->uniqueid, "NONE", "ABANDON",
+								      "%d|%d|%ld", qe.pos, qe.opos,
+								      (long) time(NULL) - qe.start);
 						}
 					} else if (valid_exit(&qe, res)) {
-						 ast_queue_log(args.queuename, chan->uniqueid, "NONE", "EXITWITHKEY", "%s|%d", qe.digits, qe.pos);
+						 ast_queue_log(args.queuename, chan->uniqueid, "NONE", "EXITWITHKEY",
+							       "%s|%d", qe.digits, qe.pos);
 					}
 					break;
 				}
@@ -3409,6 +3384,7 @@
 		res = 0;
 	}
 	LOCAL_USER_REMOVE(lu);
+
 	return res;
 }
 
@@ -3429,15 +3405,12 @@
 	LOCAL_USER_ADD(lu);
 	
 	AST_LIST_LOCK(&queues);
-
-	/* Find the right queue */
 	AST_LIST_TRAVERSE(&queues, q, list) {
 		if (!strcasecmp(q->name, data)) {
 			ast_mutex_lock(&q->lock);
 			break;
 		}
 	}
-
 	AST_LIST_UNLOCK(&queues);
 
 	if (q) {
@@ -3453,6 +3426,7 @@
 
 	snprintf(buf, len, "%d", count);
 	LOCAL_USER_REMOVE(lu);
+
 	return 0;
 }
 
@@ -3472,15 +3446,12 @@
 	LOCAL_USER_ADD(lu);
 	
 	AST_LIST_LOCK(&queues);
-
-	/* Find the right queue */
 	AST_LIST_TRAVERSE(&queues, q, list) {
 		if (!strcasecmp(q->name, data)) {
 			ast_mutex_lock(&q->lock);
 			break;
 		}
 	}
-
 	AST_LIST_UNLOCK(&queues);
 
 	if (q) {
@@ -3511,19 +3482,17 @@
 	LOCAL_USER_ADD(u);
 
 	AST_LIST_LOCK(&queues);
-
-	/* Find the right queue */
 	AST_LIST_TRAVERSE(&queues, q, list) {
 		if (!strcasecmp(q->name, data)) {
 			ast_mutex_lock(&q->lock);
 			break;
 		}
 	}
-
 	AST_LIST_UNLOCK(&queues);
 
 	if (q) {
 		int buflen = 0, count = 0;
+
 		for (m = q->members; m; m = m->next) {
 			/* strcat() is always faster than printf() */
 			if (count++) {
@@ -3545,6 +3514,7 @@
 	/* We should already be terminated, but let's make sure. */
 	buf[len - 1] = '\0';
 	LOCAL_USER_REMOVE(u);
+
 	return 0;
 }
 
@@ -3597,8 +3567,7 @@
 	char interface[80];
 	int penalty;
 	
-	cfg = ast_config_load("queues.conf");
-	if (!cfg) {
+	if (!(cfg = ast_config_load("queues.conf"))) {
 		ast_log(LOG_NOTICE, "No call queueing config file (queues.conf), so no call queues\n");
 		return;
 	}
@@ -3606,9 +3575,9 @@
 	AST_LIST_LOCK(&queues);
 	use_weight=0;
 	/* Mark all queues as dead for the moment */
-	AST_LIST_TRAVERSE(&queues, q, list) {
+	AST_LIST_TRAVERSE(&queues, q, list)
 		q->dead = 1;
-	}
+
 	/* Chug through config file */
 	cat = NULL;
 	while ((cat = ast_category_browse(cfg, cat)) ) {
@@ -3795,11 +3764,12 @@
 		else
 			ast_build_string(&max, &max_left, "unlimited");
 		sl = 0;
-		if(q->callscompleted > 0)
-			sl = 100*((float)q->callscompletedinsl/(float)q->callscompleted);
+		if (q->callscompleted > 0)
+			sl = 100 * ((float) q->callscompletedinsl / (float) q->callscompleted);
 		if (s)
 			astman_append(s, "%-12.12s has %d calls (max %s) in '%s' strategy (%ds holdtime), W:%d, C:%d, A:%d, SL:%2.1f%% within %ds%s",
-				q->name, q->count, max_buf, int2strat(q->strategy), q->holdtime, q->weight, q->callscompleted, q->callsabandoned,sl,q->servicelevel, term);
+				      q->name, q->count, max_buf, int2strat(q->strategy), q->holdtime, q->weight,
+				      q->callscompleted, q->callsabandoned,sl,q->servicelevel, term);
 		else
 			ast_cli(fd, "%-12.12s has %d calls (max %s) in '%s' strategy (%ds holdtime), W:%d, C:%d, A:%d, SL:%2.1f%% within %ds%s",
 				q->name, q->count, max_buf, int2strat(q->strategy), q->holdtime, q->weight, q->callscompleted, q->callsabandoned,sl,q->servicelevel, term);
@@ -3821,7 +3791,7 @@
 				ast_build_string(&max, &max_left, " (%s)", devstate2str(mem->status));
 				if (mem->calls) {
 					ast_build_string(&max, &max_left, " has taken %d calls (last was %ld secs ago)",
-							 mem->calls, (long)(time(NULL) - mem->lastcall));
+							 mem->calls, (long) (time(NULL) - mem->lastcall));
 				} else
 					ast_build_string(&max, &max_left, " has taken no calls yet");
 				if (s)
@@ -3841,11 +3811,13 @@
 				ast_cli(fd, "   Callers: %s", term);
 			for (qe = q->head; qe; qe = qe->next) {
 				if (s)
-					astman_append(s, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s", pos++, qe->chan->name,
-						(long)(now - qe->start) / 60, (long)(now - qe->start) % 60, qe->prio, term);
+					astman_append(s, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s",
+						      pos++, qe->chan->name, (long) (now - qe->start) / 60,
+						      (long) (now - qe->start) % 60, qe->prio, term);
 				else
-					ast_cli(fd, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s", pos++, qe->chan->name,
-						(long)(now - qe->start) / 60, (long)(now - qe->start) % 60, qe->prio, term);
+					ast_cli(fd, "      %d. %s (wait: %ld:%2.2ld, prio: %d)%s", pos++,
+						qe->chan->name, (long) (now - qe->start) / 60,
+						(long) (now - qe->start) % 60, qe->prio, term);
 			}
 		} else if (s)
 			astman_append(s, "   No Callers%s", term);
@@ -3898,6 +3870,7 @@
 static int manager_queues_show( struct mansession *s, struct message *m )
 {
 	char *a[] = { "show", "queues" };
+
 	__queues_show(s, 1, -1, 2, a, 0);
 	astman_append(s, "\r\n\r\n");	/* Properly terminate Manager output */
 
@@ -3921,73 +3894,73 @@
 	astman_send_ack(s, m, "Queue status will follow");
 	time(&now);
 	AST_LIST_LOCK(&queues);
-	if (!ast_strlen_zero(id)) {
-		snprintf(idText,256,"ActionID: %s\r\n",id);
-	}
+	if (!ast_strlen_zero(id))
+		snprintf(idText, sizeof(idText), "ActionID: %s\r\n", id);
+
 	AST_LIST_TRAVERSE(&queues, q, list) {
 		ast_mutex_lock(&q->lock);
 
 		/* List queue properties */
 		if (ast_strlen_zero(queuefilter) || !strcmp(q->name, queuefilter)) {
-			if(q->callscompleted > 0)
-				sl = 100*((float)q->callscompletedinsl/(float)q->callscompleted);
+			if (q->callscompleted > 0)
+				sl = 100 * ((float) q->callscompletedinsl / (float) q->callscompleted);
 			astman_append(s, "Event: QueueParams\r\n"
-						"Queue: %s\r\n"
-						"Max: %d\r\n"
-						"Calls: %d\r\n"
-						"Holdtime: %d\r\n"
-						"Completed: %d\r\n"
-						"Abandoned: %d\r\n"
-						"ServiceLevel: %d\r\n"
-						"ServicelevelPerf: %2.1f\r\n"
-						"Weight: %d\r\n"
-						"%s"
-						"\r\n",
-							q->name, q->maxlen, q->count, q->holdtime, q->callscompleted,
-							q->callsabandoned, q->servicelevel, sl, q->weight, idText);
+				      "Queue: %s\r\n"
+				      "Max: %d\r\n"
+				      "Calls: %d\r\n"
+				      "Holdtime: %d\r\n"
+				      "Completed: %d\r\n"
+				      "Abandoned: %d\r\n"
+				      "ServiceLevel: %d\r\n"
+				      "ServicelevelPerf: %2.1f\r\n"
+				      "Weight: %d\r\n"
+				      "%s"
+				      "\r\n",
+				      q->name, q->maxlen, q->count, q->holdtime, q->callscompleted,
+				      q->callsabandoned, q->servicelevel, sl, q->weight, idText);
 			/* List Queue Members */
 			for (mem = q->members; mem; mem = mem->next) {
 				if (ast_strlen_zero(memberfilter) || !strcmp(mem->interface, memberfilter)) {
 					astman_append(s, "Event: QueueMember\r\n"
-						"Queue: %s\r\n"
-						"Location: %s\r\n"
-						"Membership: %s\r\n"
-						"Penalty: %d\r\n"
-						"CallsTaken: %d\r\n"
-						"LastCall: %d\r\n"
-						"Status: %d\r\n"
-						"Paused: %d\r\n"
-						"%s"
-						"\r\n",
-							q->name, mem->interface, mem->dynamic ? "dynamic" : "static",
-							mem->penalty, mem->calls, (int)mem->lastcall, mem->status, mem->paused, idText);
+						      "Queue: %s\r\n"
+						      "Location: %s\r\n"
+						      "Membership: %s\r\n"
+						      "Penalty: %d\r\n"
+						      "CallsTaken: %d\r\n"
+						      "LastCall: %d\r\n"
+						      "Status: %d\r\n"
+						      "Paused: %d\r\n"
+						      "%s"
+						      "\r\n",
+						      q->name, mem->interface, mem->dynamic ? "dynamic" : "static",
+						      mem->penalty, mem->calls, (int)mem->lastcall, mem->status, mem->paused, idText);
 				}
 			}
 			/* List Queue Entries */
 			pos = 1;
 			for (qe = q->head; qe; qe = qe->next) {
 				astman_append(s, "Event: QueueEntry\r\n"
-					"Queue: %s\r\n"
-					"Position: %d\r\n"
-					"Channel: %s\r\n"
-					"CallerID: %s\r\n"
-					"CallerIDName: %s\r\n"
-					"Wait: %ld\r\n"
-					"%s"
-					"\r\n", 
-					q->name, pos++, qe->chan->name, 
-					S_OR(qe->chan->cid.cid_num, "unknown"),
-					S_OR(qe->chan->cid.cid_name, "unknown"),
-					(long)(now - qe->start), idText);
+					      "Queue: %s\r\n"
+					      "Position: %d\r\n"
+					      "Channel: %s\r\n"
+					      "CallerID: %s\r\n"
+					      "CallerIDName: %s\r\n"
+					      "Wait: %ld\r\n"
+					      "%s"
+					      "\r\n", 
+					      q->name, pos++, qe->chan->name, 
+					      S_OR(qe->chan->cid.cid_num, "unknown"),
+					      S_OR(qe->chan->cid.cid_name, "unknown"),
+					      (long) (now - qe->start), idText);
 			}
 		}
 		ast_mutex_unlock(&q->lock);
 	}
 
 	astman_append(s,
-		"Event: QueueStatusComplete\r\n"
-		"%s"
-		"\r\n",idText);
+		      "Event: QueueStatusComplete\r\n"
+		      "%s"
+		      "\r\n",idText);
 
 	AST_LIST_UNLOCK(&queues);
 
@@ -4039,6 +4012,7 @@
 		astman_send_error(s, m, "Out of memory");
 		break;
 	}
+
 	return 0;
 }
 
@@ -4068,6 +4042,7 @@
 		astman_send_error(s, m, "Out of memory");
 		break;
 	}
+
 	return 0;
 }
 
@@ -4227,6 +4202,7 @@
 			ast_mutex_unlock(&q->lock);
 		}
 	}
+
 	return NULL;
 }
 
@@ -4264,7 +4240,6 @@
 {
 	int res;
 
-	clear_and_free_interfaces();
 	res = ast_cli_unregister(&cli_show_queue);
 	res |= ast_cli_unregister(&cli_show_queues);
 	res |= ast_cli_unregister(&cli_add_queue_member);
@@ -4284,6 +4259,8 @@
 	res |= ast_custom_function_unregister(&queuewaitingcount_function);
 	res |= ast_unregister_application(app);
 
+	clear_and_free_interfaces();
+
 	STANDARD_HANGUP_LOCALUSERS;
 
 	return res;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:26:51 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:26:51 +0200
Subject: [solid-pbx-svn] r358 - trunk/apps
Message-ID: <200606280126.k5S1Qpxs013406@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:26:50 +0200 (Wed, 28 Jun 2006)
New Revision: 358

Modified:
   trunk/apps/app_queue.c
Log:
Update to Asterisk SVN trunk r34203

------------------------------------------------------------------------
r34194 | kpfleming | 2006-06-15 01:24:26 +0200 (Thu, 15 Jun 2006) | 2 lines

use the proper named constants for checking device state, and don't treat UNKNOWN as not available in autofill mode

------------------------------------------------------------------------


Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-28 01:26:20 UTC (rev 357)
+++ trunk/apps/app_queue.c	2006-06-28 01:26:50 UTC (rev 358)
@@ -2041,11 +2041,13 @@
 				ast_log(LOG_DEBUG, "Even though there are %d available members, the strategy is ringall so only the head call is allowed in\n", avl);
 			avl = 1;
 		} else {
-			cur = qe->parent->members;
-			while (cur) {
-				if (cur->status == 1) 
+			for (cur = qe->parent->members; cur; cur = cur->next) {
+				switch (cur->status) {
+				case AST_DEVICE_NOT_INUSE:
+				case AST_DEVICE_UNKNOWN:
 					avl++;
-				cur = cur->next;
+					break;
+				}
 			}
 		}
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:27:19 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:27:19 +0200
Subject: [solid-pbx-svn] r359 - trunk/channels
Message-ID: <200606280127.k5S1RJuC013436@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:27:17 +0200 (Wed, 28 Jun 2006)
New Revision: 359

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r34223

------------------------------------------------------------------------
r34217 | oej | 2006-06-15 08:35:55 +0200 (Thu, 15 Jun 2006) | 5 lines

- Do not require a space at the end of the m= string in a T38 re-invite
  Bug reported in the t38 issue report, but by mistake ignored before commit.
  Thanks to everyone informing me about this, and Corydon for helping me sort
  out sscanf :-)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 01:26:50 UTC (rev 358)
+++ trunk/channels/chan_sip.c	2006-06-28 01:27:17 UTC (rev 359)
@@ -4546,9 +4546,9 @@
 					ast_verbose("Found RTP video format %d\n", codec);
 				ast_rtp_set_m_type(newvideortp, codec);
 			}
-		} else if (p->udptl && (sscanf(m, "image %d udptl t38 %n", &x, &len) == 1)) {
+		} else if (p->udptl && ((sscanf(m, "image %d udptl t38%n", &x, &len) == 1)) {
 			if (debug)
-				ast_verbose("Got T.38 offer in SDP\n");
+				ast_verbose("Got T.38 offer in SDP in dialog %s\n", p->callid);
 			udptlportno = x;
 			
 			if (p->owner && p->lastinvite) {



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:27:53 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:27:53 +0200
Subject: [solid-pbx-svn] r360 - in trunk: apps res
Message-ID: <200606280127.k5S1RrSK013497@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:27:49 +0200 (Wed, 28 Jun 2006)
New Revision: 360

Modified:
   trunk/apps/app_voicemail.c
   trunk/res/res_odbc.c
   trunk/res/res_osp.c
Log:
Update to Asterisk SVN trunk r34243

------------------------------------------------------------------------
r34240 | tilghman | 2006-06-15 14:26:50 +0200 (Thu, 15 Jun 2006) | 2 lines

ast_calloc already reports out of memory conditions (issue 7343)

------------------------------------------------------------------------
r34241 | tilghman | 2006-06-15 14:30:45 +0200 (Thu, 15 Jun 2006) | 2 lines

ast_calloc() already reports OOM conditions

------------------------------------------------------------------------
r34243 | tilghman | 2006-06-15 14:41:24 +0200 (Thu, 15 Jun 2006) | 11 lines

Merged revisions 34242 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34242 | tilghman | 2006-06-15 07:40:10 -0500 (Thu, 15 Jun 2006) | 3 lines

VoicemailMain exits on any key, when the language is set to Italian, instead of
properly handling the key (issue 7353).

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 01:27:17 UTC (rev 359)
+++ trunk/apps/app_voicemail.c	2006-06-28 01:27:49 UTC (rev 360)
@@ -4203,7 +4203,7 @@
 			ast_play_and_wait(chan, "vm-vecchi") ||
 			ast_play_and_wait(chan, "vm-messages");
 	}
-	return res ? -1 : 0;
+	return res;
 }
 
 /* POLISH syntax */

Modified: trunk/res/res_odbc.c
===================================================================
--- trunk/res/res_odbc.c	2006-06-28 01:27:17 UTC (rev 359)
+++ trunk/res/res_odbc.c	2006-06-28 01:27:49 UTC (rev 360)
@@ -256,7 +256,6 @@
 					new = ast_calloc(1, sizeof(*new));
 
 					if (!new) {
-						ast_log(LOG_ERROR, "Memory error while loading configuration.\n");
 						res = -1;
 						break;
 					}
@@ -397,7 +396,6 @@
 			class->count++;
 			obj = ast_calloc(1, sizeof(*obj));
 			if (!obj) {
-				ast_log(LOG_ERROR, "Out of memory\n");
 				AST_LIST_UNLOCK(&class->odbc_obj);
 				return NULL;
 			}
@@ -417,7 +415,6 @@
 			/* No entry: build one */
 			obj = ast_calloc(1, sizeof(*obj));
 			if (!obj) {
-				ast_log(LOG_ERROR, "Out of memory\n");
 				AST_LIST_UNLOCK(&class->odbc_obj);
 				return NULL;
 			}
@@ -589,7 +586,6 @@
 					}
 
 					if (!new) {
-						ast_log(LOG_ERROR, "Memory error while loading configuration.\n");
 						res = -1;
 						break;
 					}

Modified: trunk/res/res_osp.c
===================================================================
--- trunk/res/res_osp.c	2006-06-28 01:27:17 UTC (rev 359)
+++ trunk/res/res_osp.c	2006-06-28 01:27:49 UTC (rev 360)
@@ -182,7 +182,6 @@
 
 	p = ast_calloc(1, sizeof(*p));
 	if (!p) {
-		ast_log(LOG_ERROR, "Out of memory\n");
 		return(-1);
 	}
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:28:43 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:28:43 +0200
Subject: [solid-pbx-svn] r361 - trunk/channels
Message-ID: <200606280128.k5S1ShpD013665@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:28:27 +0200 (Wed, 28 Jun 2006)
New Revision: 361

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r34253

------------------------------------------------------------------------
r34247 | oej | 2006-06-15 15:00:55 +0200 (Thu, 15 Jun 2006) | 2 lines

Hoppsan!

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 01:27:49 UTC (rev 360)
+++ trunk/channels/chan_sip.c	2006-06-28 01:28:27 UTC (rev 361)
@@ -4546,7 +4546,7 @@
 					ast_verbose("Found RTP video format %d\n", codec);
 				ast_rtp_set_m_type(newvideortp, codec);
 			}
-		} else if (p->udptl && ((sscanf(m, "image %d udptl t38%n", &x, &len) == 1)) {
+		} else if (p->udptl && ((sscanf(m, "image %d udptl t38%n", &x, &len) == 1))) {
 			if (debug)
 				ast_verbose("Got T.38 offer in SDP in dialog %s\n", p->callid);
 			udptlportno = x;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:29:42 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:29:42 +0200
Subject: [solid-pbx-svn] r362 - trunk/apps
Message-ID: <200606280129.k5S1Tgmw013848@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:29:16 +0200 (Wed, 28 Jun 2006)
New Revision: 362

Modified:
   trunk/apps/app_queue.c
Log:
Update to Asterisk SVN trunk r34283

------------------------------------------------------------------------
r34275 | kpfleming | 2006-06-15 15:35:04 +0200 (Thu, 15 Jun 2006) | 11 lines

Merged revisions 34274 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34274 | kpfleming | 2006-06-15 08:30:22 -0500 (Thu, 15 Jun 2006) | 3 lines

don't use prefixed structure names for internal structures
don't use a plural structure name for a singular object

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-28 01:28:27 UTC (rev 361)
+++ trunk/apps/app_queue.c	2006-06-28 01:29:16 UTC (rev 362)
@@ -289,7 +289,7 @@
 LOCAL_USER_DECL;
 
 struct queue_ent {
-	struct ast_call_queue *parent;	/*!< What queue is our parent */
+	struct call_queue *parent;	/*!< What queue is our parent */
 	char moh[80];			/*!< Name of musiconhold to be used */
 	char announce[80];		/*!< Announcement to play for member when call is answered */
 	char context[AST_MAX_CONTEXT];	/*!< Context when user exits queue */
@@ -322,20 +322,20 @@
 	struct member *next;		/*!< Next member */
 };
 
-struct ast_member_interfaces {
+struct member_interface {
 	char interface[80];
-	AST_LIST_ENTRY(ast_member_interfaces) list;    /*!< Next call queue */
+	AST_LIST_ENTRY(member_interface) list;    /*!< Next call queue */
 };
 
-static AST_LIST_HEAD_STATIC(interfaces, ast_member_interfaces);
+static AST_LIST_HEAD_STATIC(interfaces, member_interface);
 
-/* values used in multi-bit flags in ast_call_queue */
+/* values used in multi-bit flags in call_queue */
 #define QUEUE_EMPTY_NORMAL 1
 #define QUEUE_EMPTY_STRICT 2
 #define ANNOUNCEHOLDTIME_ALWAYS 1
 #define ANNOUNCEHOLDTIME_ONCE 2
 
-struct ast_call_queue {
+struct call_queue {
 	ast_mutex_t lock;	
 	char name[80];			/*!< Name */
 	char moh[80];			/*!< Music On Hold class to be used */
@@ -392,10 +392,10 @@
 	
 	struct member *members;		/*!< Head of the list of members */
 	struct queue_ent *head;		/*!< Head of the list of callers */
-	AST_LIST_ENTRY(ast_call_queue) list;	/*!< Next call queue */
+	AST_LIST_ENTRY(call_queue) list;	/*!< Next call queue */
 };
 
-static AST_LIST_HEAD_STATIC(queues, ast_call_queue);
+static AST_LIST_HEAD_STATIC(queues, call_queue);
 
 static int set_member_paused(char *queuename, char *interface, int paused);
 
@@ -446,7 +446,7 @@
 }
 
 /*! \brief Insert the 'new' entry after the 'prev' entry of queue 'q' */
-static inline void insert_entry(struct ast_call_queue *q, struct queue_ent *prev, struct queue_ent *new, int *pos)
+static inline void insert_entry(struct call_queue *q, struct queue_ent *prev, struct queue_ent *new, int *pos)
 {
 	struct queue_ent *cur;
 
@@ -471,7 +471,7 @@
 	QUEUE_NORMAL
 };
 
-static enum queue_member_status get_member_status(const struct ast_call_queue *q, int max_penalty)
+static enum queue_member_status get_member_status(const struct call_queue *q, int max_penalty)
 {
 	struct member *member;
 	enum queue_member_status result = QUEUE_NO_MEMBERS;
@@ -504,10 +504,10 @@
 
 static void *changethread(void *data)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct statechange *sc = data;
 	struct member *cur;
-	struct ast_member_interfaces *curint;
+	struct member_interface *curint;
 	char *loc;
 	char *technology;
 
@@ -607,9 +607,9 @@
 	return cur;
 }
 
-static struct ast_call_queue *alloc_queue(const char *queuename)
+static struct call_queue *alloc_queue(const char *queuename)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 
 	if ((q = ast_calloc(1, sizeof(*q)))) {
 		ast_mutex_init(&q->lock);
@@ -618,7 +618,7 @@
 	return q;
 }
 
-static void init_queue(struct ast_call_queue *q)
+static void init_queue(struct call_queue *q)
 {
 	int i;
 
@@ -654,7 +654,7 @@
 	}
 }
 
-static void clear_queue(struct ast_call_queue *q)
+static void clear_queue(struct call_queue *q)
 {
 	q->holdtime = 0;
 	q->callscompleted = 0;
@@ -665,7 +665,7 @@
 
 static int add_to_interfaces(char *interface) 
 {
-	struct ast_member_interfaces *curint;
+	struct member_interface *curint;
 
 	AST_LIST_LOCK(&interfaces);
 	AST_LIST_TRAVERSE(&interfaces, curint, list) {
@@ -692,7 +692,7 @@
 
 static int interface_exists_global(char *interface)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *mem;
 	int ret = 0;
 
@@ -714,7 +714,7 @@
 
 static int remove_from_interfaces(char *interface)
 {
-	struct ast_member_interfaces *curint;
+	struct member_interface *curint;
 
 	AST_LIST_LOCK(&interfaces);
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&interfaces, curint, list) {
@@ -736,7 +736,7 @@
 
 static void clear_and_free_interfaces(void)
 {
-	struct ast_member_interfaces *curint;
+	struct member_interface *curint;
 
 	AST_LIST_LOCK(&interfaces);
 	while ((curint = AST_LIST_REMOVE_HEAD(&interfaces, list)))
@@ -751,7 +751,7 @@
    The failunknown flag is set for config files (and static realtime) to show
    errors for unknown parameters. It is cleared for dynamic realtime to allow
    extra fields in the tables. */
-static void queue_set_param(struct ast_call_queue *q, const char *param, const char *val, int linenum, int failunknown)
+static void queue_set_param(struct call_queue *q, const char *param, const char *val, int linenum, int failunknown)
 {
 	int i = 0;
 	char *c, *lastc;
@@ -901,7 +901,7 @@
 	}
 }
 
-static void rt_handle_member_record(struct ast_call_queue *q, char *interface, const char *penalty_str)
+static void rt_handle_member_record(struct call_queue *q, char *interface, const char *penalty_str)
 {
 	struct member *m, *prev_m;
 	int penalty = 0;
@@ -934,7 +934,7 @@
 	}
 }
 
-static void free_members(struct ast_call_queue *q, int all)
+static void free_members(struct call_queue *q, int all)
 {
 	/* Free non-dynamic members */
 	struct member *curm, *next, *prev = NULL;
@@ -953,7 +953,7 @@
 	}
 }
 
-static void destroy_queue(struct ast_call_queue *q)
+static void destroy_queue(struct call_queue *q)
 {
 	free_members(q, 1);
 	ast_mutex_destroy(&q->lock);
@@ -963,10 +963,10 @@
 /*!\brief Reload a single queue via realtime.
    \return Return the queue, or NULL if it doesn't exist.
    \note Should be called with the global qlock locked. */
-static struct ast_call_queue *find_queue_by_name_rt(const char *queuename, struct ast_variable *queue_vars, struct ast_config *member_config)
+static struct call_queue *find_queue_by_name_rt(const char *queuename, struct ast_variable *queue_vars, struct ast_config *member_config)
 {
 	struct ast_variable *v;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *m, *prev_m, *next_m;
 	char *interface;
 	char *tmp, *tmp_name;
@@ -1078,11 +1078,11 @@
 	return q;
 }
 
-static struct ast_call_queue *load_realtime_queue(char *queuename)
+static struct call_queue *load_realtime_queue(char *queuename)
 {
 	struct ast_variable *queue_vars;
 	struct ast_config *member_config = NULL;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 
 	/* Find the queue in the in-core list first. */
 	AST_LIST_LOCK(&queues);
@@ -1127,7 +1127,7 @@
 
 static int join_queue(char *queuename, struct queue_ent *qe, enum queue_result *reason)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct queue_ent *cur, *prev = NULL;
 	int res = -1;
 	int pos = 0;
@@ -1362,7 +1362,7 @@
 
 static void leave_queue(struct queue_ent *qe)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct queue_ent *cur, *prev = NULL;
 	int pos = 0;
 
@@ -1418,7 +1418,7 @@
 	}
 }
 
-static int update_status(struct ast_call_queue *q, struct member *member, int status)
+static int update_status(struct call_queue *q, struct member *member, int status)
 {
 	struct member *cur;
 
@@ -1448,7 +1448,7 @@
 	return 0;
 }
 
-static int update_dial_status(struct ast_call_queue *q, struct member *member, int status)
+static int update_dial_status(struct call_queue *q, struct member *member, int status)
 {
 	if (status == AST_CAUSE_BUSY)
 		status = AST_DEVICE_BUSY;
@@ -1463,9 +1463,9 @@
 
 /* traverse all defined queues which have calls waiting and contain this member
    return 0 if no other queue has precedence (higher weight) or 1 if found  */
-static int compare_weight(struct ast_call_queue *rq, struct member *member)
+static int compare_weight(struct call_queue *rq, struct member *member)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *mem;
 	int found = 0;
 	
@@ -2130,7 +2130,7 @@
 	return res;
 }
 
-static int update_queue(struct ast_call_queue *q, struct member *member)
+static int update_queue(struct call_queue *q, struct member *member)
 {
 	struct member *cur;
 
@@ -2151,7 +2151,7 @@
 	return 0;
 }
 
-static int calc_metric(struct ast_call_queue *q, struct member *mem, int pos, struct queue_ent *qe, struct callattempt *tmp)
+static int calc_metric(struct call_queue *q, struct member *mem, int pos, struct queue_ent *qe, struct callattempt *tmp)
 {
 	if (mem->penalty > qe->max_penalty)
 		return -1;
@@ -2597,7 +2597,7 @@
 	return ast_waitfordigit(qe->chan, retrywait);
 }
 
-static struct member * interface_exists(struct ast_call_queue *q, char *interface)
+static struct member *interface_exists(struct call_queue *q, char *interface)
 {
 	struct member *mem;
 
@@ -2618,7 +2618,7 @@
  * <pm_family>/<queuename> = <interface>;<penalty>;<paused>[|...]
  *
  */
-static void dump_queue_members(struct ast_call_queue *pm_queue)
+static void dump_queue_members(struct call_queue *pm_queue)
 {
 	struct member *cur_member;
 	char value[PM_MAX_LEN];
@@ -2654,7 +2654,7 @@
 
 static int remove_from_queue(char *queuename, char *interface)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *last_member, *look;
 	int res = RES_NOSUCHQUEUE;
 
@@ -2707,7 +2707,7 @@
 
 static int add_to_queue(char *queuename, char *interface, int penalty, int paused, int dump)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *new_member;
 	int res = RES_NOSUCHQUEUE;
 
@@ -2757,7 +2757,7 @@
 static int set_member_paused(char *queuename, char *interface, int paused)
 {
 	int found = 0;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *mem;
 
 	/* Special event for when all queues are paused - individual events still generated */
@@ -2807,7 +2807,7 @@
 	int paused = 0;
 	struct ast_db_entry *db_tree;
 	struct ast_db_entry *entry;
-	struct ast_call_queue *cur_queue;
+	struct call_queue *cur_queue;
 	char queue_data[PM_MAX_LEN];
 
 	AST_LIST_LOCK(&queues);
@@ -3393,7 +3393,7 @@
 static int queue_function_qac(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
 {
 	int count = 0;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct localuser *lu;
 	struct member *m;
 
@@ -3435,7 +3435,7 @@
 static int queue_function_queuewaitingcount(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
 {
 	int count = 0;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct localuser *lu;
 
 	buf[0] = '\0';
@@ -3470,7 +3470,7 @@
 static int queue_function_queuememberlist(struct ast_channel *chan, char *cmd, char *data, char *buf, size_t len)
 {
 	struct localuser *u;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *m;
 
 	/* Ensure an otherwise empty list doesn't return garbage */
@@ -3559,7 +3559,7 @@
 
 static void reload_queues(void)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct ast_config *cfg;
 	char *cat, *tmp;
 	struct ast_variable *var;
@@ -3711,7 +3711,7 @@
 
 static int __queues_show(struct mansession *s, int manager, int fd, int argc, char **argv, int queue_show)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct queue_ent *qe;
 	struct member *mem;
 	int pos;
@@ -3849,7 +3849,7 @@
 
 static char *complete_queue(const char *line, const char *word, int pos, int state)
 {
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	char *ret = NULL;
 	int which = 0;
 	int wordlen = strlen(word);
@@ -3888,7 +3888,7 @@
 	char *queuefilter = astman_get_header(m,"Queue");
 	char *memberfilter = astman_get_header(m,"Member");
 	char idText[256] = "";
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct queue_ent *qe;
 	float sl = 0;
 	struct member *mem;
@@ -4179,7 +4179,7 @@
 static char *complete_remove_queue_member(const char *line, const char *word, int pos, int state)
 {
 	int which = 0;
-	struct ast_call_queue *q;
+	struct call_queue *q;
 	struct member *m;
 
 	/* 0 - add; 1 - queue; 2 - member; 3 - <member>; 4 - from; 5 - <queue> */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:31:01 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:31:01 +0200
Subject: [solid-pbx-svn] r363 - trunk/build_tools
Message-ID: <200606280131.k5S1V1ev014072@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:30:57 +0200 (Wed, 28 Jun 2006)
New Revision: 363

Modified:
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r34353

------------------------------------------------------------------------
r34348 | russell | 2006-06-16 01:40:55 +0200 (Fri, 16 Jun 2006) | 3 lines

remove prototypes for private functions and make functions and variables not
used outside of this file static

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-28 01:29:16 UTC (rev 362)
+++ trunk/build_tools/menuselect_curses.c	2006-06-28 01:30:57 UTC (rev 363)
@@ -48,11 +48,11 @@
 
 
 /*! Maximum number of characters horizontally */
-int max_x = 0;
+static int max_x = 0;
 /*! Maximum number of characters vertically */
-int max_y = 0;
+static int max_y = 0;
 
-const char * const help_info[] = {
+static const char * const help_info[] = {
 	"scroll        => up/down arrows",
 	"(de)select    => Enter",
 	"select all    => F8",
@@ -64,16 +64,8 @@
 	"XXX means dependencies have not been met"
 };
 
-void winch_handler(int sig);
-void show_help(WINDOW *win);
-void draw_main_menu(WINDOW *menu, int curopt);
-void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt, int changed);
-int run_category_menu(WINDOW *menu, int cat_num);
-int run_category_menu(WINDOW *menu, int cat_num);
-void draw_title_window(WINDOW *title);
-
 /*! \brief Handle a window resize in xterm */
-void winch_handler(int sig)
+static void winch_handler(int sig)
 {
 	getmaxyx(stdscr, max_y, max_x);
 
@@ -85,7 +77,7 @@
 }
 
 /*! \brief Display help information */
-void show_help(WINDOW *win)
+static void show_help(WINDOW *win)
 {
 	int i;
 
@@ -98,7 +90,7 @@
 	getch(); /* display the help until the user hits a key */
 }
 
-void draw_main_menu(WINDOW *menu, int curopt)
+static void draw_main_menu(WINDOW *menu, int curopt)
 {
 	struct category *cat;
 	char buf[64];
@@ -122,7 +114,7 @@
 	wrefresh(menu);
 }
 
-void display_mem_info(WINDOW *menu, struct member *mem, int start, int end)
+static void display_mem_info(WINDOW *menu, struct member *mem, int start, int end)
 {
 	char buf[64];
 	struct depend *dep;
@@ -162,7 +154,7 @@
 
 }
 
-void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt, int changed)
+static void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt, int changed)
 {
 	int i = 0;
 	int j = 0;
@@ -212,7 +204,7 @@
 	wrefresh(menu);
 }
 
-int run_category_menu(WINDOW *menu, int cat_num)
+static int run_category_menu(WINDOW *menu, int cat_num)
 {
 	struct category *cat;
 	int i = 0;
@@ -298,7 +290,7 @@
 	return c;
 }
 
-void draw_title_window(WINDOW *title)
+static void draw_title_window(WINDOW *title)
 {
 	wmove(title, 1, (max_x / 2) - (strlen(MENU_TITLE1) / 2));
 	waddstr(title, MENU_TITLE1);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:31:44 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:31:44 +0200
Subject: [solid-pbx-svn] r364 - trunk/build_tools
Message-ID: <200606280131.k5S1ViVA014354@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:31:42 +0200 (Wed, 28 Jun 2006)
New Revision: 364

Modified:
   trunk/build_tools/Makefile
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r34383

------------------------------------------------------------------------
r34374 | russell | 2006-06-16 02:14:46 +0200 (Fri, 16 Jun 2006) | 2 lines

build menuselect objects with -Wall and remove an unused variable

------------------------------------------------------------------------


Modified: trunk/build_tools/Makefile
===================================================================
--- trunk/build_tools/Makefile	2006-06-28 01:30:57 UTC (rev 363)
+++ trunk/build_tools/Makefile	2006-06-28 01:31:42 UTC (rev 364)
@@ -15,13 +15,13 @@
 endif
 
 menuselect: $(MENUSELECT_OBJS)
-	$(CC) -g -o $@ $(MENUSELECT_OBJS) $(MENUSELECT_LIBS)
+	$(CC) -g -Wall -o $@ $(MENUSELECT_OBJS) $(MENUSELECT_LIBS)
 
 menuselect.o: menuselect.c menuselect.h
-	$(CC) -o $@ $(MENUSELECT_CFLAGS) $<
+	$(CC) -Wall -o $@ $(MENUSELECT_CFLAGS) $<
 
 menuselect_curses.o: menuselect_curses.c menuselect.h
-	$(CC) -o $@ $(MENUSELECT_CFLAGS) $(MENUSELECT_INCLUDE) $<
+	$(CC) -Wall -o $@ $(MENUSELECT_CFLAGS) $(MENUSELECT_INCLUDE) $<
 
 clean:
 	rm -f menuselect *.o

Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-06-28 01:30:57 UTC (rev 363)
+++ trunk/build_tools/menuselect_curses.c	2006-06-28 01:31:42 UTC (rev 364)
@@ -160,7 +160,6 @@
 	int j = 0;
 	struct member *mem;
 	char buf[64];
-	const char *desc = NULL;
 
 	if (!changed) {
 		/* If all we have to do is move the cursor, 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:32:20 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:32:20 +0200
Subject: [solid-pbx-svn] r365 - trunk/channels
Message-ID: <200606280132.k5S1WKLu014454@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:32:10 +0200 (Wed, 28 Jun 2006)
New Revision: 365

Modified:
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r34403

------------------------------------------------------------------------
r34401 | file | 2006-06-16 05:38:24 +0200 (Fri, 16 Jun 2006) | 10 lines

Merged revisions 34400 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34400 | file | 2006-06-16 00:37:05 -0300 (Fri, 16 Jun 2006) | 2 lines

Zero out a declared structure so as to not crash if it contains invalid data (reported by Qwell on #asterisk-dev)

.......

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 01:31:42 UTC (rev 364)
+++ trunk/channels/chan_iax2.c	2006-06-28 01:32:10 UTC (rev 365)
@@ -9516,6 +9516,7 @@
 	struct iax2_peer *p;
 	int res = AST_DEVICE_INVALID;
 
+	memset(&pds, 0, sizeof(pds));
 	parse_dial_string(tmp, &pds);
 	if (ast_strlen_zero(pds.peer))
 		return res;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:32:54 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:32:54 +0200
Subject: [solid-pbx-svn] r366 - trunk
Message-ID: <200606280132.k5S1WsdM014701@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:32:51 +0200 (Wed, 28 Jun 2006)
New Revision: 366

Modified:
   trunk/pbx.c
Log:
Update to Asterisk SVN trunk r34433

------------------------------------------------------------------------
r34433 | oej | 2006-06-16 08:25:26 +0200 (Fri, 16 Jun 2006) | 3 lines

Don't force a busy state that will break channel signalling if the channel
already is up. (Reported by Steve Davies in e-mail, waiting for 1.2 approval)

------------------------------------------------------------------------


Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-28 01:32:10 UTC (rev 365)
+++ trunk/pbx.c	2006-06-28 01:32:51 UTC (rev 366)
@@ -4942,7 +4942,10 @@
 static int pbx_builtin_busy(struct ast_channel *chan, void *data)
 {
 	ast_indicate(chan, AST_CONTROL_BUSY);
-	ast_setstate(chan, AST_STATE_BUSY);
+	/* Don't change state of an UP channel, just indicate
+	   busy in audio */
+	if (chan->_state != AST_STATE_UP)
+		ast_setstate(chan, AST_STATE_BUSY);
 	wait_for_hangup(chan, data);
 	return -1;
 }
@@ -4953,7 +4956,10 @@
 static int pbx_builtin_congestion(struct ast_channel *chan, void *data)
 {
 	ast_indicate(chan, AST_CONTROL_CONGESTION);
-	ast_setstate(chan, AST_STATE_BUSY);
+	/* Don't change state of an UP channel, just indicate
+	   congestion in audio */
+	if (chan->_state != AST_STATE_UP)
+		ast_setstate(chan, AST_STATE_BUSY);
 	wait_for_hangup(chan, data);
 	return -1;
 }



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:33:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:33:31 +0200
Subject: [solid-pbx-svn] r367 - in trunk: apps channels
Message-ID: <200606280133.k5S1XVjT015033@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:33:27 +0200 (Wed, 28 Jun 2006)
New Revision: 367

Modified:
   trunk/apps/app_dial.c
   trunk/channels/chan_agent.c
   trunk/channels/chan_local.c
Log:
Update to Asterisk SVN trunk r34463

------------------------------------------------------------------------
r34458 | bweschke | 2006-06-16 14:18:18 +0200 (Fri, 16 Jun 2006) | 3 lines

 Don't ast_request a channel structure twice when a call is being forwarded. (#7362 - twlison / vechers confirming fix)


------------------------------------------------------------------------
r34461 | bweschke | 2006-06-16 14:24:14 +0200 (Fri, 16 Jun 2006) | 3 lines

 Make sure agent_tech is unregistered within unload_module(). It's in 1.2, but was lost at some point in /trunk. #7374 (jstorm)


------------------------------------------------------------------------
r34463 | bweschke | 2006-06-16 14:55:18 +0200 (Fri, 16 Jun 2006) | 3 lines

 Quit early and print a LOG_WARNING if we are trying to check devicestate on a Local channel that's been improperly defined.


------------------------------------------------------------------------


Modified: trunk/apps/app_dial.c
===================================================================
--- trunk/apps/app_dial.c	2006-06-28 01:32:51 UTC (rev 366)
+++ trunk/apps/app_dial.c	2006-06-28 01:33:27 UTC (rev 367)
@@ -485,8 +485,6 @@
 				if (o->forwards < AST_MAX_FORWARDS) {
 					if (option_verbose > 2)
 						ast_verbose(VERBOSE_PREFIX_3 "Now forwarding %s to '%s/%s' (thanks to %s)\n", in->name, tech, stuff, c->name);
-					/* Setup parameters */
-					c = o->chan = ast_request(tech, in->nativeformats, stuff, &cause);
 					/* If we have been told to ignore forwards, just set this channel to null and continue processing extensions normally */
 					if (ast_test_flag(peerflags, OPT_IGNORE_FORWARDING)) {
 						if (option_verbose > 2)

Modified: trunk/channels/chan_agent.c
===================================================================
--- trunk/channels/chan_agent.c	2006-06-28 01:32:51 UTC (rev 366)
+++ trunk/channels/chan_agent.c	2006-06-28 01:33:27 UTC (rev 367)
@@ -2614,7 +2614,7 @@
 	}
 	AST_LIST_UNLOCK(&agents);
 	AST_LIST_HEAD_DESTROY(&agents);
-
+	ast_channel_unregister(&agent_tech);
 	return 0;
 }
 

Modified: trunk/channels/chan_local.c
===================================================================
--- trunk/channels/chan_local.c	2006-06-28 01:32:51 UTC (rev 366)
+++ trunk/channels/chan_local.c	2006-06-28 01:33:27 UTC (rev 367)
@@ -130,16 +130,23 @@
 	int res;
 		
 	exten = ast_strdupa(data);
-	if ((context  = strchr(exten, '@'))) {
-		*context = '\0';
-		context = context + 1;
+	context = strchr(exten, '@');
+
+	if (!context) {
+		ast_log(LOG_WARNING, "Someone used Local/%s somewhere without a @context. This is bad.\n", exten);
+		return AST_DEVICE_INVALID;	
 	}
+
+	*context = '\0';
+	context = context + 1;
+
 	if (option_debug > 2)
 		ast_log(LOG_DEBUG, "Checking if extension %s@%s exists (devicestate)\n", exten, context);
 	res = ast_exists_extension(NULL, context, exten, 1, NULL);
-	if (!res)
+	if (!res) {
+		
 		return AST_DEVICE_INVALID;
-	else
+	} else
 		return AST_DEVICE_UNKNOWN;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:33:51 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:33:51 +0200
Subject: [solid-pbx-svn] r368 - trunk/channels
Message-ID: <200606280133.k5S1XpQJ015119@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:33:50 +0200 (Wed, 28 Jun 2006)
New Revision: 368

Modified:
   trunk/channels/chan_agent.c
Log:
Update to Asterisk SVN trunk r34473

------------------------------------------------------------------------
r34464 | bweschke | 2006-06-16 14:56:03 +0200 (Fri, 16 Jun 2006) | 3 lines

 Fixed per kpfleming's suggestion to asterisk-dev.


------------------------------------------------------------------------


Modified: trunk/channels/chan_agent.c
===================================================================
--- trunk/channels/chan_agent.c	2006-06-28 01:33:27 UTC (rev 367)
+++ trunk/channels/chan_agent.c	2006-06-28 01:33:50 UTC (rev 368)
@@ -2590,6 +2590,7 @@
 {
 	struct agent_pvt *p;
 	/* First, take us out of the channel loop */
+	ast_channel_unregister(&agent_tech);
 	/* Unregister dialplan functions */
 	ast_custom_function_unregister(&agent_function);	
 	/* Unregister CLI commands */
@@ -2614,7 +2615,6 @@
 	}
 	AST_LIST_UNLOCK(&agents);
 	AST_LIST_HEAD_DESTROY(&agents);
-	ast_channel_unregister(&agent_tech);
 	return 0;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:34:40 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:34:40 +0200
Subject: [solid-pbx-svn] r369 - in trunk: apps build_tools doc
Message-ID: <200606280134.k5S1YeFC015455@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:34:33 +0200 (Wed, 28 Jun 2006)
New Revision: 369

Modified:
   trunk/apps/Makefile
   trunk/apps/app_voicemail.c
   trunk/build_tools/get_moduledeps
   trunk/build_tools/prep_moduledeps
   trunk/doc/radius.txt
Log:
Update to Asterisk SVN trunk r34493

------------------------------------------------------------------------
r34491 | file | 2006-06-16 18:16:21 +0200 (Fri, 16 Jun 2006) | 2 lines

Update the RADIUS CDR module documentation (issue #7377 reported by phsultan)

------------------------------------------------------------------------
r34492 | russell | 2006-06-16 18:17:43 +0200 (Fri, 16 Jun 2006) | 4 lines

add support for setting the CFLAGS for voicemail storage options in menuselect

Thanks to kpfleming for the Makefile magic :)

------------------------------------------------------------------------


Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 01:33:50 UTC (rev 368)
+++ trunk/apps/Makefile	2006-06-28 01:34:33 UTC (rev 369)
@@ -15,17 +15,10 @@
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_APPS),$(patsubst %.c,%,$(wildcard app_*.c)))
 
-# If you have UnixODBC you can use ODBC voicemail
-# storage
-#
-# Uncomment to use ODBC storage
-#CFLAGS+=-DUSE_ODBC_STORAGE
-# Uncomment for extended ODBC voicemail storage
-#CFLAGS+=-DEXTENDED_ODBC_STORAGE
-# See doc/README.odbcstorage for more information
-
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
+app_voicemail.o: CFLAGS+=$(patsubst %,-D%,$(MENUSELECT_app_voicemail))
+
 all: $(MODS)
 
 clean-depend:

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 01:33:50 UTC (rev 368)
+++ trunk/apps/app_voicemail.c	2006-06-28 01:34:33 UTC (rev 369)
@@ -41,6 +41,23 @@
  *				 Bartosz Supczinski <Bartosz.Supczinski at dir.pl>
  */
 
+/*** MAKEOPTS
+<category name="MENUSELECT_app_voicemail" displayname="Voicemail Build Options" positive_output="yes" force_clean_on_change="yes">
+	<member name="IMAP_STORAGE" displayname="Storage of Voicemail using IMAP">
+		<depend>cc-client</depend>
+		<defaultenabled>no</defaultenabled>
+	</member>
+	<member name="ODBC_STORAGE" displayname="Storage of Voicemail using ODBC">
+		<depend>unixodbc</depend>
+		<defaultenabled>no</defaultenabled>
+	</member>
+	<member name="EXTENDED_ODBC_STORAGE" displayname="Storage of Voicemail using ODBC (extended)">
+		<depend>unixodbc</depend>
+		<defaultenabled>no</defaultenabled>
+	</member>
+</category>
+ ***/
+
 #include "asterisk.h"
 
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
@@ -81,7 +98,7 @@
 #include "asterisk/stringfields.h"
 #include "asterisk/smdi.h"
 #define SMDI_MWI_WAIT_TIMEOUT 1000 /* 1 second */
-#ifdef USE_ODBC_STORAGE
+#ifdef ODBC_STORAGE
 #include "asterisk/res_odbc.h"
 #endif
 
@@ -293,7 +310,7 @@
 
 static void apply_options(struct ast_vm_user *vmu, const char *options);
 
-#ifdef USE_ODBC_STORAGE
+#ifdef ODBC_STORAGE
 static char odbc_database[80];
 static char odbc_table[80];
 #define RETRIEVE(a,b) retrieve_file(a,b)
@@ -842,7 +859,7 @@
 }
 
 
-#ifdef USE_ODBC_STORAGE
+#ifdef ODBC_STORAGE
 static int retrieve_file(char *dir, int msgnum)
 {
 	int x = 0;
@@ -1294,7 +1311,7 @@
 		}
 		fdlen = lseek(fd, 0, SEEK_END);
 		lseek(fd, 0, SEEK_SET);
-		printf("Length is %d\n", fdlen);
+		printf("Length is %zd\n", fdlen);
 		fdm = mmap(NULL, fdlen, PROT_READ | PROT_WRITE, MAP_SHARED,fd, 0);
 		if (!fdm) {
 			ast_log(LOG_WARNING, "Memory map failed!\n");
@@ -2019,7 +2036,7 @@
 	return (id >= 0 && id < (sizeof(msgs)/sizeof(msgs[0]))) ? msgs[id] : "Unknown";
 }
 
-#ifdef USE_ODBC_STORAGE
+#ifdef ODBC_STORAGE
 static int inboxcount(const char *mailbox, int *newmsgs, int *oldmsgs)
 {
 	int x = -1;
@@ -6187,7 +6204,7 @@
 			astsearch = "no";
 		ast_set2_flag((&globalflags), ast_true(astsearch), VM_SEARCH);
 
-#ifdef USE_ODBC_STORAGE
+#ifdef ODBC_STORAGE
 		strcpy(odbc_database, "asterisk");
 		if ((thresholdstr = ast_variable_retrieve(cfg, "general", "odbcstorage"))) {
 			ast_copy_string(odbc_database, thresholdstr, sizeof(odbc_database));
@@ -6618,7 +6635,7 @@
 
 	ast_install_vm_functions(has_voicemail, inboxcount, messagecount);
 
-#if defined(USE_ODBC_STORAGE) && !defined(EXTENDED_ODBC_STORAGE)
+#if defined(ODBC_STORAGE) && !defined(EXTENDED_ODBC_STORAGE)
 	ast_log(LOG_WARNING, "The current ODBC storage table format will be changed soon."
 				"Please update your tables as per the README and edit the apps/Makefile "
 				"and uncomment the line containing EXTENDED_ODBC_STORAGE to enable the "

Modified: trunk/build_tools/get_moduledeps
===================================================================
--- trunk/build_tools/get_moduledeps	2006-06-28 01:33:50 UTC (rev 368)
+++ trunk/build_tools/get_moduledeps	2006-06-28 01:34:33 UTC (rev 369)
@@ -1,3 +0,0 @@
-/\/\*\*\* MODULEINFO/ {printit=1; next}
-/\*\*\*\// {exit}
-// {if (printit) print}

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-06-28 01:33:50 UTC (rev 368)
+++ trunk/build_tools/prep_moduledeps	2006-06-28 01:34:33 UTC (rev 369)
@@ -39,15 +39,21 @@
 		get_description ${file}
 		desc=${TDESC}
 		echo -e "\t\t<member name=\"${fname%%.c}\" displayname=\"${desc}\">"
-		awk -f build_tools/get_moduledeps ${file}
+		awk -f build_tools/get_moduleinfo ${file}
 		echo -e "\t\t</member>"
 	done
 	echo -e "\t</category>"
+
+	for file in ${dir}/${prefix}*.c
+	do
+		awk -f build_tools/get_makeopts ${file} >> .makeoptstmp
+	done
 }
 
 echo "<?xml version="1.0"?>"
 echo
 echo "<menu>"
+rm -f .makeoptstmp
 process_dir apps app APPS Applications
 process_dir cdr cdr CDR "Call Detail Recording"
 process_dir channels chan CHANNELS "Channel Drivers"
@@ -58,4 +64,6 @@
 process_dir res res RES "Resource Modules"
 cat build_tools/cflags.xml
 cat sounds/sounds.xml
+cat .makeoptstmp
+rm -f .makeoptstmp
 echo "</menu>"

Modified: trunk/doc/radius.txt
===================================================================
--- trunk/doc/radius.txt	2006-06-28 01:33:50 UTC (rev 368)
+++ trunk/doc/radius.txt	2006-06-28 01:34:33 UTC (rev 369)
@@ -81,15 +81,16 @@
 		File "dictionary"
 			
 		Asterisk uses some attributes that are not included in the 
-		dictionary of radiusclient library, therefore it is necesarry to add 
-		them. A file called dictionary.asterisk was created to list all new 
-		attributes used by Asterisk. Add into file
+		dictionary of radiusclient library, therefore it is necessary to add 
+		them. A file called dictionary.digium (kept in the contrib dir)
+ 		was created to list all new attributes used by Asterisk. 
+		Add to the end of the main dictionary file
 		/usr/local/etc/radiusclient-ng/dictionary
 		the line:
 
-			$INCLUDE /path/to/dictionary.asterisk
+			$INCLUDE /path/to/dictionary.digium
 
- 2.FreeRADIUS Server
+ 2.FreeRADIUS Server (Version 1.1.1)
  	2.a Installation
 			
 		Download sources tarball from:
@@ -135,9 +136,13 @@
 
 		File "dictionary"
 			
+		Note : as of version 1.1.2, the dictionary.digium file ships with FreeRADIUS. 
+		The following procedure brings the dictionary.digium file to previous versions 
+		of FreeRADIUS.
+		
 		File /usr/local/etc/raddb/dictionary contains the dictionary of 
 		FreeRADIUS server. You have to add the same dictionary file 
-		(dictionary.asterisk), which you added to the dictionary of radiusclient-ng
+		(dictionary.digium), which you added to the dictionary of radiusclient-ng
 		library. You can include it into the main file, adding the following line at the
 		end of file '/usr/local/etc/raddb/dictionary':
 			



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:35:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:35:31 +0200
Subject: [solid-pbx-svn] r370 - in trunk: . build_tools cdr channels codecs configs formats pbx res
Message-ID: <200606280135.k5S1ZVxH015659@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:35:12 +0200 (Wed, 28 Jun 2006)
New Revision: 370

Modified:
   trunk/Makefile
   trunk/build_tools/menuselect.c
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/configs/indications.conf.sample
   trunk/formats/Makefile
   trunk/pbx/Makefile
   trunk/res/Makefile
   trunk/res/res_smdi.c
Log:
Update to Asterisk SVN trunk r34503

------------------------------------------------------------------------
r34494 | file | 2006-06-16 18:23:13 +0200 (Fri, 16 Jun 2006) | 2 lines

Add bulgarian indications (issue #7314 reported by KNK)

------------------------------------------------------------------------
r34495 | file | 2006-06-16 18:30:42 +0200 (Fri, 16 Jun 2006) | 2 lines

Handle failure of ast_calloc when allocating interfaces in res_smdi (issue #7344 reported by casper)

------------------------------------------------------------------------
r34496 | file | 2006-06-16 18:45:52 +0200 (Fri, 16 Jun 2006) | 2 lines

Fix adsi target in main Makefile and check a variable properly (issue #7369 reported by casper)

------------------------------------------------------------------------
r34497 | russell | 2006-06-16 18:54:00 +0200 (Fri, 16 Jun 2006) | 3 lines

remove "depend" from the "all" targets in sub Makefiles.  The main Makefile
already calls "make depend" for each of the subdirectories

------------------------------------------------------------------------
r34498 | russell | 2006-06-16 18:58:51 +0200 (Fri, 16 Jun 2006) | 2 lines

remove prototypes for static functions and fix some potential memory leaks

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -145,13 +145,13 @@
 OPTIMIZE+=-O6
   else
     # Stack backtraces, while useful for debugging, are incompatible with optimizations
-    ifeq (${OSARCH},Linux)
+    ifeq ($(OSARCH),Linux)
       CFLAGS+=-DSTACK_BACKTRACES
     endif
   endif
 else
   # Stack backtraces, while useful for debugging, are incompatible with optimizations
-  ifeq (${OSARCH},Linux)
+  ifeq ($(OSARCH),Linux)
     CFLAGS+=-DSTACK_BACKTRACES
   endif
 endif
@@ -668,7 +668,7 @@
 adsi:
 	mkdir -p $(DESTDIR)$(ASTETCDIR)
 	for x in configs/*.adsi; do \
-		if [ ! -f $(DESTDIR)$(ASTETCDIRX)/$$x ]; then \
+		if [ ! -f $(DESTDIR)$(ASTETCDIR)/$$x ]; then \
 			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTETCDIR)/`basename $$x` ; \
 		fi ; \
 	done

Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/build_tools/menuselect.c	2006-06-28 01:35:12 UTC (rev 370)
@@ -73,18 +73,6 @@
 /*! Force a clean of the source tree */
 static int force_clean = 0;
 
-static int add_category(struct category *cat);
-static int add_member(struct member *mem, struct category *cat);
-static int parse_makeopts_xml(const char *makeopts_xml);
-static int process_deps(void);
-static int build_member_list(void);
-static void mark_as_present(const char *member, const char *category);
-static void process_prev_failed_deps(char *buf);
-static int parse_existing_config(const char *infile);
-static int generate_makeopts_file(void);
-static void free_member_list(void);
-static void free_trees(void);
-
 /*! \brief return a pointer to the first non-whitespace character */
 static inline char *skip_blanks(char *str)
 {
@@ -129,6 +117,19 @@
 	return 0;
 }
 
+/*! \brief Free a member structure and all of its members */
+static void free_member(struct member *mem)
+{
+	struct depend *dep;
+	struct conflict *cnf;
+
+	while ((dep = AST_LIST_REMOVE_HEAD(&mem->deps, list)))
+		free(dep);
+	while ((cnf = AST_LIST_REMOVE_HEAD(&mem->conflicts, list)))
+		free(cnf);
+	free(mem);
+}
+
 /*! \brief Parse an input makeopts file */
 static int parse_makeopts_xml(const char *makeopts_xml)
 {
@@ -203,8 +204,10 @@
 			     cur3 && cur3->child;
 			     cur3 = mxmlFindElement(cur3, cur2, "depend", NULL, NULL, MXML_DESCEND))
 			{
-				if (!(dep = calloc(1, sizeof(*dep))))
+				if (!(dep = calloc(1, sizeof(*dep)))) {
+					free_member(mem);
 					return -1;
+				}
 				if (!strlen_zero(cur3->child->value.opaque)) {
 					dep->name = cur3->child->value.opaque;
 					AST_LIST_INSERT_HEAD(&mem->deps, dep, list);
@@ -216,8 +219,10 @@
 			     cur3 && cur3->child;
 			     cur3 = mxmlFindElement(cur3, cur2, "conflict", NULL, NULL, MXML_DESCEND))
 			{
-				if (!(cnf = calloc(1, sizeof(*cnf))))
+				if (!(cnf = calloc(1, sizeof(*cnf)))) {
+					free_member(mem);
 					return -1;
+				}
 				if (!strlen_zero(cur3->child->value.opaque)) {
 					cnf->name = cur3->child->value.opaque;
 					AST_LIST_INSERT_HEAD(&mem->conflicts, cnf, list);
@@ -226,7 +231,7 @@
 			}
 
 			if (add_member(mem, cat))
-				free(mem);
+				free_member(mem);
 		}
 	}
 

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/cdr/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -39,7 +39,7 @@
 
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
-all: depend $(MODS)
+all: $(MODS)
 
 install: all
 	for x in $(MODS); do $(INSTALL) -m 755 $$x $(DESTDIR)$(MODULES_DIR) ; done

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/channels/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -32,7 +32,7 @@
 
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
-all: depend $(MODS) 
+all: $(MODS) 
 
 clean-depend:
 	rm -f .depend

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/codecs/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -25,7 +25,7 @@
 
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
-all: depend $(MODS)
+all: $(MODS)
 
 clean-depend:
 	rm -f .depend

Modified: trunk/configs/indications.conf.sample
===================================================================
--- trunk/configs/indications.conf.sample	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/configs/indications.conf.sample	2006-06-28 01:35:12 UTC (rev 370)
@@ -114,6 +114,20 @@
 ; Ringtone for calls to Telstra mobiles
 ringmobile = 400+450/400,0/200,400+450/400,0/2000
 
+[bg]
+; Reference: http://www.itu.int/ITU-T/inr/forms/files/tones-0203.pdf
+description = Bulgaria
+ringdance = 1000,4000
+dial = 425
+busy = 425/500,0/500
+ring = 425/1000,0/4000
+congestion = 425/250,0/250
+callwaiting = 425/150,0/150,425/150,0/4000
+dialrecall = !425/100,!0/100,!425/100,!0/100,!425/100,!0/100,425
+record = 1400/425,0/15000
+info = 950/330,1400/330,1800/330,0/1000
+stutter = 425/1500,0/100
+
 [br]
 description = Brazil
 ringcadence = 1000,4000

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/formats/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -19,7 +19,7 @@
 
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
-all: depend $(MODS)
+all: $(MODS)
 
 clean-depend:
 	rm -f .depend

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/pbx/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -23,7 +23,7 @@
 
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
-all: depend $(MODS)
+all: $(MODS)
 
 clean-depend:
 	rm -f .depend

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/res/Makefile	2006-06-28 01:35:12 UTC (rev 370)
@@ -38,7 +38,7 @@
 
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
-all: depend $(MODS)
+all: $(MODS)
 
 install: all
 	rm -f $(DESTDIR)$(ASTHEADERDIR)/parking.h

Modified: trunk/res/res_smdi.c
===================================================================
--- trunk/res/res_smdi.c	2006-06-28 01:34:33 UTC (rev 369)
+++ trunk/res/res_smdi.c	2006-06-28 01:35:12 UTC (rev 370)
@@ -621,7 +621,8 @@
 				}
 			}
 							
-			iface = ast_calloc(1, sizeof(*iface));
+			if (!(iface = ast_calloc(1, sizeof(*iface))))
+				continue;
 
 			ASTOBJ_INIT(iface);
 			ASTOBJ_CONTAINER_INIT(&iface->md_q);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:36:04 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:36:04 +0200
Subject: [solid-pbx-svn] r371 - trunk/apps
Message-ID: <200606280136.k5S1a4Zu015886@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:35:59 +0200 (Wed, 28 Jun 2006)
New Revision: 371

Modified:
   trunk/apps/app_voicemail.c
Log:
Update to Asterisk SVN trunk r34523

------------------------------------------------------------------------
r34523 | russell | 2006-06-16 19:53:26 +0200 (Fri, 16 Jun 2006) | 3 lines

remove IMAP_STORAGE from the build options list for app_voicemail since it's
not in trunk yet

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 01:35:12 UTC (rev 370)
+++ trunk/apps/app_voicemail.c	2006-06-28 01:35:59 UTC (rev 371)
@@ -43,10 +43,6 @@
 
 /*** MAKEOPTS
 <category name="MENUSELECT_app_voicemail" displayname="Voicemail Build Options" positive_output="yes" force_clean_on_change="yes">
-	<member name="IMAP_STORAGE" displayname="Storage of Voicemail using IMAP">
-		<depend>cc-client</depend>
-		<defaultenabled>no</defaultenabled>
-	</member>
 	<member name="ODBC_STORAGE" displayname="Storage of Voicemail using ODBC">
 		<depend>unixodbc</depend>
 		<defaultenabled>no</defaultenabled>



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:36:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:36:45 +0200
Subject: [solid-pbx-svn] r372 - in trunk/channels: . misdn
Message-ID: <200606280136.k5S1aje1016113@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:36:40 +0200 (Wed, 28 Jun 2006)
New Revision: 372

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
   trunk/channels/misdn/isdn_lib.h
Log:
Update to Asterisk SVN trunk r34553

------------------------------------------------------------------------
r34552 | crichter | 2006-06-17 12:37:35 +0200 (Sat, 17 Jun 2006) | 8 lines

* fixed bchannel cleaning race condition with new bchannel state (CLEAN_REQUEST)
* added early bridge-hook, so we know if we need to generate ringing or 
  can take it from the far end chan_misdn channel (if available)
* fixed the issue, that we may not activate the bchannel on PTMP, 
  when we receive ALERTING/PROCEEDING/PROGRESS, only on CONNECT. There might
  be other PTMP devices and we might disturb their bchannel. 


------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-28 01:35:59 UTC (rev 371)
+++ trunk/channels/chan_misdn.c	2006-06-28 01:36:40 UTC (rev 372)
@@ -88,8 +88,6 @@
 	ast_mutex_t mutexjb;
 };
 
-void export_ies(struct ast_channel *chan, struct misdn_bchannel *bc);
-void import_ies(struct ast_channel *chan, struct misdn_bchannel *bc);
 
 
 /* allocates the jb-structure and initialise the elements*/
@@ -185,6 +183,8 @@
 	struct ast_trans_pvt *trans;
   
 	struct ast_channel * ast;
+
+	int dummy;
   
 	struct misdn_bchannel *bc;
 	struct misdn_bchannel *holded_bc;
@@ -198,6 +198,8 @@
 	int dropped_frame_cnt;
 
 	int far_alerting;
+	int other_pid;
+	struct chan_list *other_ch;
 
 	const struct tone_zone_sound *ts;
 	
@@ -207,6 +209,11 @@
 	struct chan_list *first;
 };
 
+
+
+void export_ch(struct ast_channel *chan, struct misdn_bchannel *bc, struct chan_list *ch);
+void import_ch(struct ast_channel *chan, struct misdn_bchannel *bc, struct chan_list *ch);
+
 struct robin_list {
 	char *group;
 	int port;
@@ -306,6 +313,7 @@
 static void cl_queue_chan(struct chan_list **list, struct chan_list *chan);
 static void cl_dequeue_chan(struct chan_list **list, struct chan_list *chan);
 static struct chan_list *find_chan_by_bc(struct chan_list *list, struct misdn_bchannel *bc);
+static struct chan_list *find_chan_by_pid(struct chan_list *list, int pid);
 
 
 
@@ -1638,7 +1646,7 @@
 		update_config(ch,ORG_AST);
 		
 		/* fill in some ies from channel vary*/
-		import_ies(ast, newbc);
+		import_ch(ast, newbc, ch);
 		
 		/* Finally The Options Override Everything */
 		if (opts)
@@ -1854,7 +1862,12 @@
 				p->state=MISDN_ALERTING;
 				chan_misdn_log(1, p->bc->port, " --> * IND :\tringing pid:%d\n",p->bc?p->bc->pid:-1);
 				misdn_lib_send_event( p->bc, EVENT_ALERTING);
-				
+			
+				if (p->other_ch && p->other_ch->bc && misdn_inband_avail(p->other_ch->bc)) {
+					chan_misdn_log(1,p->bc->port, " --> other End is mISDN and has inband info available\n");
+					break;
+				}
+			
 				if ( !p->bc->nt && (p->orginator==ORG_MISDN) && !p->incoming_early_audio ) 
 					chan_misdn_log(1,p->bc->port, " --> incoming_early_audio off\n");
 				 else 
@@ -1902,10 +1915,11 @@
 	case -1 :
 		chan_misdn_log(1, p->bc->port, " --> * IND :\t-1! (stop indication) pid:%d\n",p->bc?p->bc->pid:-1);
 		
-		if (p->state == MISDN_CONNECTED)
+		tone_indicate(p, TONE_NONE);
+
+		if (p->state == MISDN_CONNECTED) 
 			start_bc_tones(p);
-		else 
-			tone_indicate(p, TONE_NONE);
+
 		break;
 
 	case AST_CONTROL_HOLD:
@@ -1996,8 +2010,11 @@
 			start_bc_tones(p);
 			tone_indicate(p, TONE_BUSY);
 			p->state=MISDN_CLEANING;
-			
-			misdn_lib_send_event( bc, EVENT_RELEASE_COMPLETE);
+		
+			if (bc->nt)
+				misdn_lib_send_event( bc, EVENT_RELEASE);
+			else
+				misdn_lib_send_event( bc, EVENT_RELEASE_COMPLETE);
       
 			break;
       
@@ -2349,7 +2366,15 @@
 	chan_misdn_log(3,cl->bc->port,"Tone Indicate:\n");
 	
 	if (!cl->ast) {
+		chan_misdn_log(-1,cl->bc->port,"Ast Ptr Not existing anymore.. we need to generate tones ourselves now (tbd)\n");
 		return 0;
+#if 0
+		struct ast_channel *dummy=misdn_new(cl, AST_STATE_RESERVED, cl->bc->dad, cl->bc->oad, AST_FORMAT_ALAW, cl->bc->port, 99);
+		cl->ast=dummy;
+		/* return 0; */
+		cl->dummy=1;
+		ast=cl->ast;
+#endif
 	}
 	
 	switch (tone) {
@@ -2361,7 +2386,7 @@
 	case TONE_ALERTING:
 		chan_misdn_log(3,cl->bc->port," --> Ring\n");
 		ts=ast_get_indication_tone(ast->zone,"ring");
-		misdn_lib_tone_generator_stop(cl->bc);
+		misdn_lib_tone_generator_start(cl->bc);
 		break;
 	case TONE_FAR_ALERTING:
 	/* VERY UGLY HACK, BECAUSE CHAN_SIP DOES NOT GENERATE TONES */
@@ -2373,7 +2398,7 @@
 	case TONE_BUSY:
 		chan_misdn_log(3,cl->bc->port," --> Busy\n");
 		ts=ast_get_indication_tone(ast->zone,"busy");
-		misdn_lib_tone_generator_stop(cl->bc);
+		misdn_lib_tone_generator_start(cl->bc);
 		break;
 	case TONE_FILE:
 		break;
@@ -2460,7 +2485,7 @@
 			chan_misdn_log(2, 0, " --> Group Call group: %s\n",group);
 		} 
 		else if ((p = strchr(port_str, ':'))) {
-			// we have a preselected channel
+			/* we have a preselected channel */
 			*p = 0;
 			channel = atoi(++p);
 			port = atoi(port_str);
@@ -2748,6 +2773,17 @@
 	return NULL;
 }
 
+static struct chan_list *find_chan_by_pid(struct chan_list *list, int pid)
+{
+	struct chan_list *help=list;
+	for (;help; help=help->next) {
+		if (help->bc->pid == pid) return help;
+	}
+  
+	chan_misdn_log(6, 0, "$$$ find_chan: No channel found for pid:%d\n",pid);
+  
+	return NULL;
+}
 
 static struct chan_list *find_holded(struct chan_list *list, struct misdn_bchannel *bc)
 {
@@ -2839,8 +2875,15 @@
 		release_unlock;
 		
 		chan_misdn_log(1, bc->port, "release_chan: bc with l3id: %x\n",bc->l3_id);
+#if 0
+		if (ch->dummy) {
+			ast_hangup(ast);
+			ch->ast=NULL;
+			ast=NULL;
+		}
+#endif
 		
-		//releaseing jitterbuffer
+		/*releaseing jitterbuffer*/
 		if (ch->jb ) {
 			misdn_jb_destroy(ch->jb);
 			ch->jb=NULL;
@@ -3042,47 +3085,31 @@
 	}
 }
 
-void import_ies(struct ast_channel *chan, struct misdn_bchannel *bc)
-{
-	const char *tmp;
 
-	tmp=pbx_builtin_getvar_helper(chan,"PRI_MODE");
-	if (tmp) bc->mode=atoi(tmp);
 
-	tmp=pbx_builtin_getvar_helper(chan,"PRI_URATE");
-	if (tmp) bc->urate=atoi(tmp);
 
-	tmp=pbx_builtin_getvar_helper(chan,"PRI_RATE");
-	if (tmp) bc->rate=atoi(tmp);
-
-	tmp=pbx_builtin_getvar_helper(chan,"PRI_USER1");
-	if (tmp) bc->user1=atoi(tmp);
-
-	tmp=pbx_builtin_getvar_helper(chan,"PRI_PROGRESS_INDICATOR");
-	if (tmp) bc->progress_indicator=atoi(tmp);
+void import_ch(struct ast_channel *chan, struct misdn_bchannel *bc, struct chan_list *ch)
+{
+	char *tmp;
+	tmp=pbx_builtin_getvar_helper(chan,"MISDN_PID");
+	if (tmp) {
+		ch->other_pid=atoi(tmp);
+		chan_misdn_log(1,bc->port,"IMPORT_PID: importing pid:%s\n",tmp);
+		if (ch->other_pid >0) {
+			ch->other_ch=find_chan_by_pid(cl_te,ch->other_pid);
+			if (ch->other_ch) ch->other_ch->other_ch=ch;
+		}
+	}
 }
 
-void export_ies(struct ast_channel *chan, struct misdn_bchannel *bc)
+void export_ch(struct ast_channel *chan, struct misdn_bchannel *bc, struct chan_list *ch)
 {
 	char tmp[32];
-	
-	sprintf(tmp,"%d",bc->mode);
-	pbx_builtin_setvar_helper(chan,"_PRI_MODE",tmp);
-
-	sprintf(tmp,"%d",bc->urate);
-	pbx_builtin_setvar_helper(chan,"_PRI_URATE",tmp);
-
-	sprintf(tmp,"%d",bc->rate);
-	pbx_builtin_setvar_helper(chan,"_PRI_RATE",tmp);
-	
-	sprintf(tmp,"%d",bc->user1);
-	pbx_builtin_setvar_helper(chan,"_PRI_USER1",tmp);
-	
-	sprintf(tmp,"%d",bc->progress_indicator);
-	pbx_builtin_setvar_helper(chan,"_PRI_PROGRESS_INDICATOR",tmp);
+	chan_misdn_log(1,bc->port,"EXPORT_PID: pid:%d\n",bc->pid);
+	sprintf(tmp,"%d",bc->pid);
+	pbx_builtin_setvar_helper(chan,"_MISDN_PID",tmp);
 }
 
-
 int add_in_calls(int port)
 {
 	int max_in_calls;
@@ -3145,9 +3172,12 @@
 	
 	if (ch ) {
 		switch (event) {
+		case EVENT_DISCONNECT:
 		case EVENT_RELEASE:
 		case EVENT_RELEASE_COMPLETE:
 		case EVENT_CLEANUP:
+		case EVENT_TIMEOUT:
+			chan_misdn_log(3,bc->port,"ast_hangup already called, so we have no ast ptr anymore in event(%s)\n",manager_isdn_get_info(event));
 			break;
 		default:
 			if ( !ch->ast  || !MISDN_ASTERISK_PVT(ch->ast) || !MISDN_ASTERISK_TECH_PVT(ch->ast)) {
@@ -3357,8 +3387,8 @@
 
 		read_config(ch, ORG_MISDN);
 		
-		export_ies(chan, bc);
-		
+		export_ch(chan, bc, ch);
+
 		ch->ast->rings=1;
 		ast_setstate(ch->ast, AST_STATE_RINGING);
 
@@ -3483,10 +3513,18 @@
 			}
 		} else {
 
-
 			if (bc->sending_complete) {
+				ch->state=MISDN_EXTCANTMATCH;
 				bc->out_cause=1;
-				misdn_lib_send_event(bc, EVENT_RELEASE);
+
+				if (bc->nt)  {
+					chan_misdn_log(0,bc->port," --> sending_complete so we never match ..\n");
+					misdn_lib_send_event(bc, EVENT_RELEASE_COMPLETE);
+				} else {
+					chan_misdn_log(0,bc->port," --> sending_complete so we never match ..\n");
+					misdn_lib_send_event(bc, EVENT_RELEASE);
+				}
+
 			} else {
 				
 				int ret= misdn_lib_send_event(bc, EVENT_SETUP_ACKNOWLEDGE );
@@ -3633,12 +3671,12 @@
 	}
 	break;
 	case EVENT_DISCONNECT:
+	/*we might not have an ch->ast ptr here anymore*/
 	{
-		
 		struct chan_list *holded_ch=find_holded(cl_te, bc);
 		
-		
-		send_cause2ast(ch->ast,bc);
+		if (ch->ast)	
+			send_cause2ast(ch->ast,bc);
 
 
 		chan_misdn_log(3,bc->port," --> org:%d nt:%d, inbandavail:%d state:%d\n", ch->orginator, bc->nt, misdn_inband_avail(bc), ch->state);
@@ -3655,7 +3693,7 @@
 		}
 		
 		/*Check for holded channel, to implement transfer*/
-		if (holded_ch ) {
+		if (holded_ch && ch->ast ) {
 			if  (ch->state == MISDN_CONNECTED ) {
 				misdn_transfer_bc(ch, holded_ch) ;
 				misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
@@ -3722,10 +3760,18 @@
 		chan_misdn_log(9,bc->port,"TONE_GEN: len:%d\n");
 
 		if (!ast->generator) break;
+	
 		
+	
 		tmp = ast->generatordata;
 		ast->generatordata = NULL;
 		generate = ast->generator->generate;
+
+		if (tone_len <0 || tone_len > 512 ) {
+			ast_log(LOG_WARNING, "TONE_GEN: len was %d, set to 128\n",tone_len);
+			tone_len=128;
+		}
+
 		res = generate(ast, tmp, tone_len, tone_len);
 		ast->generatordata = tmp;
 		
@@ -3788,18 +3834,26 @@
 	}
 	break;
 	case EVENT_TIMEOUT:
-
-		misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
-		break;
 		{
-			switch (ch->state) {
+		switch (ch->state) {
+			case MISDN_WAITING4DIGS:
 			case MISDN_CALLING:
-
-				chan_misdn_log(-1, bc?bc->port:0, "GOT TIMOUT AT CALING pid:%d\n", bc?bc->pid:-1);
-					break;
 			case MISDN_DIALING:
 			case MISDN_PROGRESS:
-				break;
+				
+				if (bc->nt) {
+					bc->progress_indicator=8;
+					tone_indicate(ch, TONE_BUSY);
+				}
+				
+				bc->out_cause=1;
+				misdn_lib_send_event(bc,EVENT_DISCONNECT);
+			break;
+
+			case MISDN_CLEANING: 
+				chan_misdn_log(1,bc->port," --> in state cleaning .. so ingoring, the stack should clean it for us\n");
+			break;
+
 			default:
 				misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
 			}
@@ -3883,7 +3937,7 @@
 			
 			if (bridged && MISDN_ASTERISK_TECH_PVT(bridged)) {
 				ch=MISDN_ASTERISK_TECH_PVT(bridged);
-				//ch->state=MISDN_FACILITY_DEFLECTED;
+				/*ch->state=MISDN_FACILITY_DEFLECTED;*/
 				if (ch->bc) {
 					/* todo */
 				}

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-28 01:35:59 UTC (rev 371)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-28 01:36:40 UTC (rev 372)
@@ -61,7 +61,7 @@
 	
 	if (stack) {
 		sprintf(buf, "* Stack Addr:%x Port %d Type %s Prot. %s L2Link %s L1Link:%s", stack->upper_id, stack->port, stack->nt?"NT":"TE", stack->ptp?"PTP":"PMP", stack->l2link?"UP":"DOWN", stack->l1link?"UP":"DOWN");
-		
+
 	} else {
 		buf[0]=0;
 	}
@@ -329,7 +329,7 @@
 }
 
 
-static int mypid=0;
+static int mypid=1;
 
 
 int misdn_cap_is_speech(int cap)
@@ -425,6 +425,7 @@
 		{"BCHAN_RELEASE", BCHAN_RELEASE},
 		{"BCHAN_RELEASED", BCHAN_RELEASED},
 		{"BCHAN_CLEAN", BCHAN_CLEAN},
+		{"BCHAN_CLEAN_REQUEST", BCHAN_CLEAN_REQUEST},
 		{"BCHAN_ERROR", BCHAN_ERROR}
 	};
 	
@@ -550,8 +551,13 @@
 
 	bc->holded_bc=NULL;
 	
-	bc_state_change(bc,BCHAN_EMPTY);
-	bc_next_state_change(bc,BCHAN_EMPTY);
+	
+	if (bc->bc_state != BCHAN_SETUP) {
+		bc_state_change(bc,BCHAN_EMPTY);
+		bc_next_state_change(bc,BCHAN_EMPTY);
+	} else {
+		cb_log(-1,bc->port,"Emptying bc(%x) within SETSTACK!\n",bc->addr);
+	}
 }
 
 
@@ -581,6 +587,12 @@
 		
 	case BCHAN_BRIDGED:
 		cb_log(2, stack->port, "$$$ bc still bridged\n");
+		break;
+
+
+	case BCHAN_SETUP:
+		bc_state_change(bc,BCHAN_CLEAN_REQUEST);
+		return -1;
 	default:
 		break;
 	}
@@ -804,7 +816,7 @@
 		ncr.len = 0;
 
 		bc->l3_id = l3_id;
-		if (mypid>5000) mypid=0;
+		if (mypid>5000) mypid=1;
 		bc->pid=mypid++;
       
 		cb_log(3, stack->port, " --> new_l3id %x\n",l3_id);
@@ -837,7 +849,7 @@
 		/* send message */
 
 		bc->l3_id = l3_id;
-		if (mypid>5000) mypid=0;
+		if (mypid>5000) mypid=1;
 		bc->pid=mypid++;
     
 		cb_log(3, stack->port, "--> new_l3id %x\n",l3_id);
@@ -1442,7 +1454,7 @@
 	cb_log(7, stack->port, " --> new_process: New L3Id: %x\n",frm->dinfo);
 	bc->l3_id=frm->dinfo;
 	
-	if (mypid>5000) mypid=0;
+	if (mypid>5000) mypid=1;
 	bc->pid=mypid++;
 	return 0;
 }
@@ -1711,11 +1723,11 @@
 #endif
 		break;
 		
-		case CC_CONNECT|INDICATION:
 		case CC_ALERTING|INDICATION:
 		case CC_PROCEEDING|INDICATION:
 		case CC_SETUP_ACKNOWLEDGE|INDICATION:
-
+			if(!stack->ptp) break;	
+		case CC_CONNECT|INDICATION:
 		{
 			struct misdn_bchannel *bc=find_bc_by_l3id(stack, hh->dinfo);
 			
@@ -2104,16 +2116,19 @@
 		cb_log(4, stack->port," --> Got Adr %x\n", bc->addr);
 
 		free_msg(msg);
+	
 		
-		if (bc->bc_state !=  BCHAN_SETUP) {
-			cb_log(4, stack->port," --> STATE WASN'T SETUP in SETSTACK|IND\n");
+		switch(bc->bc_state) {
+		case BCHAN_SETUP:
+			bc_state_change(bc,BCHAN_SETUPED);
+			manager_bchannel_activate(bc);
+		break;
+
+		case BCHAN_CLEAN_REQUEST:
+		default:
+			cb_log(-1, stack->port," --> STATE WASN'T SETUP (but %s) in SETSTACK|IND\n",bc_state2str(bc->bc_state));
+			clean_up_bc(bc);
 		}
-		
-		bc_state_change(bc,BCHAN_SETUPED);
-		
-		
-		manager_bchannel_activate(bc);
-				
 		return 1;
 
 	case MGR_DELLAYER| INDICATION:
@@ -2885,7 +2900,7 @@
 	cb_log(3, stack->port, " --> screen:%d --> pres:%d\n",
 			bc->screen, bc->pres);
 	
-	cb_log(2, stack->port, " --> channel:%d caps:%s pi:%x keypad:%s\n", bc->channel, bearer2str(bc->capability),bc->progress_indicator, bc->keypad);
+	cb_log(2, stack->port, " --> channel:%d caps:%s pi:%x keypad:%s sending_complete:%d\n", bc->channel, bearer2str(bc->capability),bc->progress_indicator, bc->keypad, bc->sending_complete);
 
 	cb_log(3, stack->port, " --> urate:%d rate:%d mode:%d user1:%d\n", bc->urate, bc->rate, bc->mode,bc->user1);
 	
@@ -2933,11 +2948,13 @@
 		}
 		break;
 
-	case EVENT_CONNECT:
 	case EVENT_PROGRESS:
 	case EVENT_ALERTING:
 	case EVENT_PROCEEDING:
 	case EVENT_SETUP_ACKNOWLEDGE:
+		if (!bc->nt && !stack->ptp) break;
+
+	case EVENT_CONNECT:
 	case EVENT_RETRIEVE_ACKNOWLEDGE:
 		if (stack->nt) {
 			if (bc->channel <=0 ) { /*  else we have the channel already */

Modified: trunk/channels/misdn/isdn_lib.h
===================================================================
--- trunk/channels/misdn/isdn_lib.h	2006-06-28 01:35:59 UTC (rev 371)
+++ trunk/channels/misdn/isdn_lib.h	2006-06-28 01:36:40 UTC (rev 372)
@@ -35,6 +35,7 @@
 	BCHAN_RELEASE,
 	BCHAN_RELEASED,
 	BCHAN_CLEAN,
+	BCHAN_CLEAN_REQUEST,
 	BCHAN_ERROR
 };
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:37:36 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:37:36 +0200
Subject: [solid-pbx-svn] r373 - in trunk: apps build_tools
Message-ID: <200606280137.k5S1bapg016396@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:37:31 +0200 (Wed, 28 Jun 2006)
New Revision: 373

Modified:
   trunk/apps/app_voicemail.c
   trunk/build_tools/cflags.xml
   trunk/build_tools/menuselect.c
   trunk/build_tools/menuselect.h
   trunk/build_tools/prep_moduledeps
Log:
Update to Asterisk SVN trunk r34583

------------------------------------------------------------------------
r34577 | kpfleming | 2006-06-18 14:52:08 +0200 (Sun, 18 Jun 2006) | 7 lines

commit russell's menuselect/buildoptions work with some changes:
  reverted per-directory .cleancount support
  added ability for 'remove_on_change' to support multiple filenames
  add 'remove_on_change' support to members, not just categories
  only do 'remove_on_change' removals if the config is actually saved
  add a 'remove_on_change' entry for each module found by prep_moduledeps so that if it gets turned off any existing .o/.so files will disappear

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 01:36:40 UTC (rev 372)
+++ trunk/apps/app_voicemail.c	2006-06-28 01:37:31 UTC (rev 373)
@@ -42,7 +42,7 @@
  */
 
 /*** MAKEOPTS
-<category name="MENUSELECT_app_voicemail" displayname="Voicemail Build Options" positive_output="yes" force_clean_on_change="yes">
+<category name="MENUSELECT_app_voicemail" displayname="Voicemail Build Options" positive_output="yes" remove_on_change="apps/app_voicemail.o">
 	<member name="ODBC_STORAGE" displayname="Storage of Voicemail using ODBC">
 		<depend>unixodbc</depend>
 		<defaultenabled>no</defaultenabled>

Modified: trunk/build_tools/cflags.xml
===================================================================
--- trunk/build_tools/cflags.xml	2006-06-28 01:36:40 UTC (rev 372)
+++ trunk/build_tools/cflags.xml	2006-06-28 01:37:31 UTC (rev 373)
@@ -1,4 +1,4 @@
-	<category name="MENUSELECT_CFLAGS" displayname="Compiler Flags" positive_output="yes" force_clean_on_change="yes">
+	<category name="MENUSELECT_CFLAGS" displayname="Compiler Flags" positive_output="yes" remove_on_change=".lastclean">
 		<member name="DEBUG_CHANNEL_LOCKS" displayname="Debug Channel Locking">
 		</member>
 		<member name="DEBUG_SCHEDULER" displayname="Enable Scheduler Debugging Output">

Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-28 01:36:40 UTC (rev 372)
+++ trunk/build_tools/menuselect.c	2006-06-28 01:37:31 UTC (rev 373)
@@ -70,9 +70,6 @@
 /*! This is set when the --check-deps argument is provided. */
 static int check_deps = 0;
 
-/*! Force a clean of the source tree */
-static int force_clean = 0;
-
 /*! \brief return a pointer to the first non-whitespace character */
 static inline char *skip_blanks(char *str)
 {
@@ -175,8 +172,7 @@
 		cat->displayname = mxmlElementGetAttr(cur, "displayname");
 		if ((tmp = mxmlElementGetAttr(cur, "positive_output")))
 			cat->positive_output = !strcasecmp(tmp, "yes");
-		if ((tmp = mxmlElementGetAttr(cur, "force_clean_on_change")))
-			cat->force_clean_on_change = !strcasecmp(tmp, "yes");
+		cat->remove_on_change = mxmlElementGetAttr(cur, "remove_on_change");
 
 		if (add_category(cat)) {
 			free(cat);
@@ -193,8 +189,10 @@
 			mem->name = mxmlElementGetAttr(cur2, "name");
 			mem->displayname = mxmlElementGetAttr(cur2, "displayname");
 		
+			mem->remove_on_change = mxmlElementGetAttr(cur2, "remove_on_change");
+
 			if (!cat->positive_output)
-				mem->enabled = 1;
+				mem->was_enabled = mem->enabled = 1;
 	
 			cur3 = mxmlFindElement(cur2, cur2, "defaultenabled", NULL, NULL, MXML_DESCEND);
 			if (cur3 && cur3->child)
@@ -348,7 +346,7 @@
 			continue;
 		AST_LIST_TRAVERSE(&cat->members, mem, list) {
 			if (!strcmp(member, mem->name)) {
-				mem->enabled = cat->positive_output;
+				mem->was_enabled = mem->enabled = cat->positive_output;
 				break;
 			}
 		}
@@ -374,8 +372,6 @@
 
 	if (mem && !(mem->depsfailed || mem->conflictsfailed)) {
 		mem->enabled = !mem->enabled;
-		if (cat->force_clean_on_change)
-			force_clean = 1;
 	}
 }
 
@@ -507,6 +503,34 @@
 
 	fclose(f);
 
+	/* Traverse all categories and members and remove any files that are supposed
+	   to be removed when an item has been changed */
+	AST_LIST_TRAVERSE(&categories, cat, list) {
+		unsigned int had_changes = 0;
+		char *file, *buf;
+
+		AST_LIST_TRAVERSE(&cat->members, mem, list) {
+			if (mem->enabled == mem->was_enabled)
+				continue;
+
+			had_changes = 1;
+
+			if (mem->remove_on_change) {
+				for (buf = strdupa(mem->remove_on_change), file = strsep(&buf, " ");
+				     file;
+				     file = strsep(&buf, " "))
+					unlink(file);
+			}
+		}
+
+		if (cat->remove_on_change && had_changes) {
+			for (buf = strdupa(cat->remove_on_change), file = strsep(&buf, " ");
+			     file;
+			     file = strsep(&buf, " "))
+				unlink(file);
+		}
+	}
+
 	return 0;
 }
 
@@ -522,7 +546,8 @@
 	AST_LIST_TRAVERSE(&categories, cat, list) {
 		fprintf(stderr, "Category: '%s'\n", cat->name);
 		AST_LIST_TRAVERSE(&cat->members, mem, list) {
-			fprintf(stderr, "   ==>> Member: '%s'  (%s)\n", mem->name, mem->enabled ? "Enabled" : "Disabled");
+			fprintf(stderr, "   ==>> Member: '%s'  (%s)", mem->name, mem->enabled ? "Enabled" : "Disabled");
+			fprintf(stderr, "        Was %s\n", mem->was_enabled ? "Enabled" : "Disabled");
 			AST_LIST_TRAVERSE(&mem->deps, dep, list)
 				fprintf(stderr, "      --> Depends on: '%s'\n", dep->name);
 			if (!AST_LIST_EMPTY(&mem->deps))
@@ -701,11 +726,5 @@
 	free_trees();
 	free_member_list();
 
-	/* In some cases, such as modifying the CFLAGS for the build,
-	 * a "make clean" needs to be forced.  Removing the .lastclean 
-	 * file does this. */
-	if (force_clean)
-		unlink(".lastclean");
-
 	exit(res);
 }

Modified: trunk/build_tools/menuselect.h
===================================================================
--- trunk/build_tools/menuselect.h	2006-06-28 01:36:40 UTC (rev 372)
+++ trunk/build_tools/menuselect.h	2006-06-28 01:37:31 UTC (rev 373)
@@ -52,8 +52,12 @@
 	const char *displayname;
 	/*! Default setting */
 	const char *defaultenabled;
+	/*! Delete these file(s) if this member changes */
+	const char *remove_on_change;
 	/*! This module is currently selected */
 	unsigned int enabled:1;
+	/*! This module was enabled when the config was loaded */
+	unsigned int was_enabled:1;
 	/*! This module has failed dependencies */
 	unsigned int depsfailed:1;
 	/*! This module has failed conflicts */
@@ -71,10 +75,10 @@
 	const char *name;
 	/*! the name displayed in the menu */
 	const char *displayname;
-	/*! Display what is selected, as opposed to not selected */
+	/*! Delete these file(s) if anything in this category changes */
+	const char *remove_on_change;
+	/*! Output what is selected, as opposed to not selected */
 	unsigned int positive_output:1;
-	/*! Force a clean of the source tree if anything in this category changes */
-	unsigned int force_clean_on_change:1;
 	/*! the list of possible values to be set in this variable */
 	AST_LIST_HEAD_NOLOCK(, member) members;
 	/*! for linking */

Modified: trunk/build_tools/prep_moduledeps
===================================================================
--- trunk/build_tools/prep_moduledeps	2006-06-28 01:36:40 UTC (rev 372)
+++ trunk/build_tools/prep_moduledeps	2006-06-28 01:37:31 UTC (rev 373)
@@ -38,7 +38,7 @@
 		fname=${file##${dir}/}
 		get_description ${file}
 		desc=${TDESC}
-		echo -e "\t\t<member name=\"${fname%%.c}\" displayname=\"${desc}\">"
+		echo -e "\t\t<member name=\"${fname%%.c}\" displayname=\"${desc}\" remove_on_change=\"${dir}/${fname%%.c}.o ${dir}/${fname%%.c}.so\">"
 		awk -f build_tools/get_moduleinfo ${file}
 		echo -e "\t\t</member>"
 	done



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:38:14 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:38:14 +0200
Subject: [solid-pbx-svn] r374 - in trunk/channels: . misdn
Message-ID: <200606280138.k5S1cEom016665@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:38:12 +0200 (Wed, 28 Jun 2006)
New Revision: 374

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
   trunk/channels/misdn/isdn_lib.h
Log:
Update to Asterisk SVN trunk r34613

------------------------------------------------------------------------
r34604 | crichter | 2006-06-18 21:09:32 +0200 (Sun, 18 Jun 2006) | 1 line

added TONE_HANGUP, also added Tone generation by mISDN_dsp for post hangup tones, therefore the TONE_X defines are in the isdn_lib.h now. changed a REALEASE to a DISCONNECT in NT Stack, to make tones available in that state.
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-28 01:37:31 UTC (rev 373)
+++ trunk/channels/chan_misdn.c	2006-06-28 01:38:12 UTC (rev 374)
@@ -111,17 +111,7 @@
 /* BEGIN: chan_misdn.h */
 
 
-enum tone_e {
-	TONE_NONE=0,
-	TONE_DIAL,
-	TONE_ALERTING,
-	TONE_FAR_ALERTING,
-	TONE_BUSY,
-	TONE_CUSTOM,
-	TONE_FILE
-};
 
-
 enum misdn_chan_state {
 	MISDN_NOTHING,		/*!< at beginning */
 	MISDN_WAITING4DIGS, /*!<  when waiting for infos */
@@ -1981,7 +1971,7 @@
 		return 0;
 	}
 
-	stop_bc_tones(p);
+	/*stop_bc_tones(p);*/
 	
 	release_unlock;
 	
@@ -2008,11 +1998,11 @@
 		case MISDN_HOLDED:
 		case MISDN_DIALING:
 			start_bc_tones(p);
-			tone_indicate(p, TONE_BUSY);
+			tone_indicate(p, TONE_HANGUP);
 			p->state=MISDN_CLEANING;
 		
 			if (bc->nt)
-				misdn_lib_send_event( bc, EVENT_RELEASE);
+				misdn_lib_send_event( bc, EVENT_DISCONNECT);
 			else
 				misdn_lib_send_event( bc, EVENT_RELEASE_COMPLETE);
       
@@ -2024,7 +2014,7 @@
 			chan_misdn_log(2, bc->port, " --> * State Alerting\n");
 
 			if (p->orginator != ORG_AST) 
-				tone_indicate(p, TONE_BUSY);
+				tone_indicate(p, TONE_HANGUP);
       
 			p->state=MISDN_CLEANING;
 			misdn_lib_send_event( bc, EVENT_DISCONNECT);
@@ -2033,7 +2023,7 @@
 			/*  Alerting or Disconect */
 			chan_misdn_log(2, bc->port, " --> * State Connected\n");
 			start_bc_tones(p);
-			tone_indicate(p, TONE_BUSY);
+			tone_indicate(p, TONE_HANGUP);
 			misdn_lib_send_event( bc, EVENT_DISCONNECT);
       
 			p->state=MISDN_CLEANING; /* MISDN_HUNGUP_FROM_AST; */
@@ -2129,7 +2119,7 @@
 	if (!ast) return NULL;
 	if (! (tmp=MISDN_ASTERISK_TECH_PVT(ast)) ) return NULL;
 	if (!tmp->bc) return NULL;
-	
+
 	len=read(tmp->pipe[0],tmp->ast_rd_buf,sizeof(tmp->ast_rd_buf));
 
 	if (len<=0) {
@@ -2367,14 +2357,9 @@
 	
 	if (!cl->ast) {
 		chan_misdn_log(-1,cl->bc->port,"Ast Ptr Not existing anymore.. we need to generate tones ourselves now (tbd)\n");
+		
+		misdn_lib_send_tone(cl->bc,tone);
 		return 0;
-#if 0
-		struct ast_channel *dummy=misdn_new(cl, AST_STATE_RESERVED, cl->bc->dad, cl->bc->oad, AST_FORMAT_ALAW, cl->bc->port, 99);
-		cl->ast=dummy;
-		/* return 0; */
-		cl->dummy=1;
-		ast=cl->ast;
-#endif
 	}
 	
 	switch (tone) {

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-28 01:37:31 UTC (rev 373)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-28 01:38:12 UTC (rev 374)
@@ -3798,6 +3798,8 @@
 	unsigned int *d = (unsigned int*)&ctrl->data.p;
 	struct misdn_stack *stack=get_stack_by_bc(bc);
 	
+	cb_log(4,bc->port,"ph_control: c1:%x c2:%x\n",c1,c2);
+	
 	ctrl->prim = PH_CONTROL | REQUEST;
 	ctrl->addr = bc->addr | FLG_MSG_DOWN;
 	ctrl->dinfo = 0;
@@ -3915,6 +3917,29 @@
 
 
 
+void misdn_lib_send_tone(struct misdn_bchannel *bc, enum tone_e tone) 
+{
+	switch(tone) {
+	case TONE_DIAL:
+		manager_ph_control(bc, TONE_PATT_ON, TONE_GERMAN_DIALTONE);	
+	break;
+	
+	case TONE_ALERTING:
+		manager_ph_control(bc, TONE_PATT_ON, TONE_GERMAN_RINGING);	
+	break;
+	
+	case TONE_HANGUP:
+		manager_ph_control(bc, TONE_PATT_ON, TONE_GERMAN_HANGUP);	
+	break;
+
+	case TONE_NONE:
+	default:
+		manager_ph_control(bc, TONE_PATT_OFF, TONE_GERMAN_HANGUP);	
+	}
+
+}
+
+
 void manager_ec_enable(struct misdn_bchannel *bc)
 {
 	int ec_arr[2];

Modified: trunk/channels/misdn/isdn_lib.h
===================================================================
--- trunk/channels/misdn/isdn_lib.h	2006-06-28 01:37:31 UTC (rev 373)
+++ trunk/channels/misdn/isdn_lib.h	2006-06-28 01:38:12 UTC (rev 374)
@@ -21,6 +21,19 @@
 
 
 
+enum tone_e {
+	TONE_NONE=0,
+	TONE_DIAL,
+	TONE_ALERTING,
+	TONE_FAR_ALERTING,
+	TONE_BUSY,
+	TONE_HANGUP,
+	TONE_CUSTOM,
+	TONE_FILE
+};
+
+
+
 #define MAX_BCHANS 30
 
 enum bchannel_state {
@@ -376,6 +389,7 @@
 void manager_ec_enable(struct misdn_bchannel *bc);
 void manager_ec_disable(struct misdn_bchannel *bc);
 
+void misdn_lib_send_tone(struct misdn_bchannel *bc, enum tone_e tone);
 
 void get_show_stack_details(int port, char *buf);
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:38:55 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:38:55 +0200
Subject: [solid-pbx-svn] r375 - in trunk: . channels configs db1-ast
Message-ID: <200606280138.k5S1ctpG016881@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:38:49 +0200 (Wed, 28 Jun 2006)
New Revision: 375

Modified:
   trunk/Makefile
   trunk/channels/chan_iax2.c
   trunk/channels/chan_jingle.c
   trunk/configs/iax.conf.sample
   trunk/db1-ast/Makefile
Log:
Update to Asterisk SVN trunk r34633

------------------------------------------------------------------------
r34628 | russell | 2006-06-18 22:18:41 +0200 (Sun, 18 Jun 2006) | 13 lines

Merged revisions 34627 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34627 | russell | 2006-06-18 16:15:15 -0400 (Sun, 18 Jun 2006) | 5 lines

don't store multiple secrets delimited with semicolons for peers because this
is only valid for users. Instead, only keep the last specified secret for a
peer entry. Also, document how multiple secrets are handled in the sample
config. (Reported by PCadach on #asterisk-bugs)

.......

------------------------------------------------------------------------
r34629 | russell | 2006-06-18 22:33:53 +0200 (Sun, 18 Jun 2006) | 4 lines

there is no reason to build and link stdtime/libtime.a because we already
directly include stdtime/localtime.o in the OBJS for asterisk, which is the
only object file for libtime

------------------------------------------------------------------------
r34630 | russell | 2006-06-18 22:41:32 +0200 (Sun, 18 Jun 2006) | 3 lines

use the CFLAGS from the main Makefile when building libdb1
(issue #7324, with mods)

------------------------------------------------------------------------
r34631 | russell | 2006-06-18 22:51:14 +0200 (Sun, 18 Jun 2006) | 2 lines

fix various coding guidelines issues (issue #7345, with additional changes)

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 01:38:12 UTC (rev 374)
+++ trunk/Makefile	2006-06-28 01:38:49 UTC (rev 375)
@@ -277,7 +277,7 @@
 ASTCFLAGS+=$(MALLOC_DEBUG)$(BUSYDETECT)$(OPTIONS)
 
 MOD_SUBDIRS=res channels pbx apps codecs formats cdr funcs
-OTHER_SUBDIRS=utils stdtime agi
+OTHER_SUBDIRS=utils agi
 SUBDIRS:=$(MOD_SUBDIRS) $(OTHER_SUBDIRS)
 
 OBJS=io.o sched.o logger.o frame.o loader.o config.o channel.o \
@@ -477,17 +477,14 @@
 	fi
 	@rm -f $@.tmp
 
-stdtime/libtime.a:
-	CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C stdtime libtime.a
-
-asterisk: include/asterisk/buildopts.h editline/libedit.a db1-ast/libdb1.a stdtime/libtime.a $(OBJS)
+asterisk: include/asterisk/buildopts.h editline/libedit.a db1-ast/libdb1.a $(OBJS)
 	build_tools/make_build_h > include/asterisk/build.h.tmp
 	if cmp -s include/asterisk/build.h.tmp include/asterisk/build.h ; then echo ; else \
 		mv include/asterisk/build.h.tmp include/asterisk/build.h ; \
 	fi
 	rm -f include/asterisk/build.h.tmp
 	$(CC) -c -o buildinfo.o $(CFLAGS) buildinfo.c
-	$(CC) $(DEBUG) $(ASTOBJ) $(ASTLINK) $(OBJS) buildinfo.o $(LIBEDIT) db1-ast/libdb1.a stdtime/libtime.a $(LIBS)
+	$(CC) $(DEBUG) $(ASTOBJ) $(ASTLINK) $(OBJS) buildinfo.o $(LIBEDIT) db1-ast/libdb1.a $(LIBS)
 
 muted: muted.o
 	$(CC) $(AUDIO_LIBS) -o muted muted.o

Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 01:38:12 UTC (rev 374)
+++ trunk/channels/chan_iax2.c	2006-06-28 01:38:49 UTC (rev 375)
@@ -8353,11 +8353,7 @@
 		peer->peercontext[0] = '\0';
 		while(v) {
 			if (!strcasecmp(v->name, "secret")) {
-				if (!ast_strlen_zero(peer->secret)) {
-					strncpy(peer->secret + strlen(peer->secret), ";", sizeof(peer->secret)-strlen(peer->secret) - 1);
-					strncpy(peer->secret + strlen(peer->secret), v->value, sizeof(peer->secret)-strlen(peer->secret) - 1);
-				} else
-					ast_copy_string(peer->secret, v->value, sizeof(peer->secret));
+				ast_copy_string(peer->secret, v->value, sizeof(peer->secret));
 			} else if (!strcasecmp(v->name, "mailbox")) {
 				ast_copy_string(peer->mailbox, v->value, sizeof(peer->mailbox));
 			} else if (!strcasecmp(v->name, "dbsecret")) {

Modified: trunk/channels/chan_jingle.c
===================================================================
--- trunk/channels/chan_jingle.c	2006-06-28 01:38:12 UTC (rev 374)
+++ trunk/channels/chan_jingle.c	2006-06-28 01:38:49 UTC (rev 375)
@@ -479,13 +479,10 @@
 	struct jingle_pvt *tmp;
 
 	ast_log(LOG_DEBUG, "The client is %s\n", client->name);
-	tmp = client->p;
 	/* Make sure our new call doesn't exist yet */
-	while (tmp) {
-		if (iks_find_with_attrib(pak->x, GOOGLE_NODE, GOOGLE_SID, tmp->sid)) {
+	for (tmp = client->p; tmp; tmp = tmp->next) {
+		if (iks_find_with_attrib(pak->x, GOOGLE_NODE, GOOGLE_SID, tmp->sid))
 			break;
-		}
-		tmp = tmp->next;
 	}
 
 	if (tmp) {
@@ -502,13 +499,10 @@
 	struct jingle_pvt *tmp;
 
 	ast_log(LOG_DEBUG, "The client is %s\n", client->name);
-	tmp = client->p;
 	/* Make sure our new call doesn't exist yet */
-	while (tmp) {
-		if (iks_find_with_attrib(pak->x, GOOGLE_NODE, GOOGLE_SID, tmp->sid)) {
+	for (tmp = client->p; tmp; tmp = tmp->next) {
+		if (iks_find_with_attrib(pak->x, GOOGLE_NODE, GOOGLE_SID, tmp->sid))
 			break;
-		}
-		tmp = tmp->next;
 	}
 
 	if (tmp) {
@@ -536,21 +530,18 @@
 	iq = iks_new("iq");
 	jingle = iks_new(GOOGLE_NODE);
 	candidate = iks_new("candidate");
-	ours1 = (struct jingle_candidate *) ast_calloc(1, sizeof(struct jingle_candidate));
-	ours2 = (struct jingle_candidate *) ast_calloc(1, sizeof(struct jingle_candidate));
-	if (!iq || !jingle || !candidate || !ours1 || !ours2) {
-		ast_log(LOG_WARNING, "out of memory!\n");
+	if (!iq || !jingle || !candidate) {
+		ast_log(LOG_ERROR, "Memory allocation error\n");
 		goto safeout;
 	}
-
+	ours1 = ast_calloc(1, sizeof(*ours1));
+	ours2 = ast_calloc(1, sizeof(*ours2));
 	iks_insert_node(iq, jingle);
 	iks_insert_node(jingle, candidate);
 
-	while (p) {
-		if (!strcasecmp(p->sid, sid)) {
+	for (; p; p = p->next) {
+		if (!strcasecmp(p->sid, sid))
 			break;
-		}
-		p = p->next;
 	}
 
 	if (!p) {
@@ -596,8 +587,7 @@
 	dest.sin_port = sin.sin_port;
 
 
-	tmp = p->ourcandidates;
-	while (tmp) {				/*send standard candidates */
+	for (tmp = p->ourcandidates; tmp; tmp = tmp->next) {
 		snprintf(port, sizeof(port), "%d", tmp->port);
 		snprintf(preference, sizeof(preference), "%.2f", tmp->preference);
 		iks_insert_attrib(iq, "from", c->jid->full);
@@ -628,7 +618,6 @@
 		iks_insert_attrib(candidate, "network", "0");
 		iks_insert_attrib(candidate, "generation", "0");
 		iks_send(c->p, iq);
-		tmp = tmp->next;
 	}
 	p->laststun = 0;
 
@@ -958,23 +947,18 @@
 	struct aji_client *c = client->connection;
 	struct jingle_candidate *newcandidate = NULL;
 	iks  *traversenodes = NULL, *receipt = NULL;
-	newcandidate =
-		(struct jingle_candidate *) ast_calloc(1, sizeof(struct jingle_candidate));
+	newcandidate = ast_calloc(1, sizeof(*newcandidate));
 	if (!newcandidate)
 		return 0;
-	memset(newcandidate, 0, sizeof(struct jingle_candidate));
-	tmp = client->p;
-	while (tmp) {
+	for (tmp = client->p; tmp; tmp = tmp->next) {
 		if (iks_find_with_attrib(pak->x, GOOGLE_NODE, GOOGLE_SID, tmp->sid)) {
 			p = tmp;
 			break;
 		}
-		tmp = tmp->next;
 	}
 
-	if (!p) {
+	if (!p)
 		return -1;
-	}
 
 	traversenodes = pak->query;
 	while(traversenodes) {
@@ -983,11 +967,9 @@
 			continue;
 		}
 		if(!strcasecmp(iks_name(traversenodes), "candidate")) {
-			newcandidate =
-				(struct jingle_candidate *) ast_calloc(1, sizeof(struct jingle_candidate));
+			newcandidate = ast_calloc(1, sizeof(*newcandidate));
 			if (!newcandidate)
 				return 0;
-			memset(newcandidate, 0, sizeof(struct jingle_candidate));
 			ast_copy_string(newcandidate->name, iks_find_attrib(traversenodes, "name"),
 							sizeof(newcandidate->name));
 			ast_copy_string(newcandidate->ip, iks_find_attrib(traversenodes, "address"),

Modified: trunk/configs/iax.conf.sample
===================================================================
--- trunk/configs/iax.conf.sample	2006-06-28 01:38:12 UTC (rev 374)
+++ trunk/configs/iax.conf.sample	2006-06-28 01:38:49 UTC (rev 375)
@@ -377,7 +377,9 @@
 ;type=friend
 ;host=dynamic
 ;regexten=1234
-;secret=moofoo
+;secret=moofoo   ; Multiple secrets may be specified. For a "user", all
+;secret=foomoo   ; specified entries will be accepted as valid. For a "peer",
+;secret=shazbot  ; only the last specified secret will be used.
 ;context=default
 ;permit=0.0.0.0/0.0.0.0
 

Modified: trunk/db1-ast/Makefile
===================================================================
--- trunk/db1-ast/Makefile	2006-06-28 01:38:12 UTC (rev 374)
+++ trunk/db1-ast/Makefile	2006-06-28 01:38:49 UTC (rev 375)
@@ -51,8 +51,7 @@
 clean:
 	rm -f $(LIBDB) $(LIBDBSO) $(OBJS) $(SHOBJS)
 
-OORG=	-O2
-CL=	$(CC) -Wall -c -D__DBINTERFACE_PRIVATE $(OORG) -I. -Iinclude
+CL=	$(CC) $(CFLAGS) -Wall -c -D__DBINTERFACE_PRIVATE -I. -I.. -Iinclude
 
 OSTYPE=$(shell uname -s)
 ifeq ($(OSTYPE),SunOS)



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:39:32 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:39:32 +0200
Subject: [solid-pbx-svn] r376 - trunk/channels
Message-ID: <200606280139.k5S1dWga017033@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:39:28 +0200 (Wed, 28 Jun 2006)
New Revision: 376

Modified:
   trunk/channels/chan_jingle.c
Log:
Update to Asterisk SVN trunk r34663

------------------------------------------------------------------------
r34662 | russell | 2006-06-18 23:05:40 +0200 (Sun, 18 Jun 2006) | 10 lines

Blocked revisions 34655 via svnmerge

.......
r34655 | russell | 2006-06-18 17:03:58 -0400 (Sun, 18 Jun 2006) | 3 lines

don't set state to BUSY if the channel is already in the UP state
(issue #7376, backported from trunk)

.......

------------------------------------------------------------------------
r34663 | russell | 2006-06-18 23:24:35 +0200 (Sun, 18 Jun 2006) | 4 lines

bail if ast_calloc fails, this was done before but i accidently removed it when
moving these allocations so duplicate error messages were not produced
(issue #7345)

------------------------------------------------------------------------


Modified: trunk/channels/chan_jingle.c
===================================================================
--- trunk/channels/chan_jingle.c	2006-06-28 01:38:49 UTC (rev 375)
+++ trunk/channels/chan_jingle.c	2006-06-28 01:39:28 UTC (rev 376)
@@ -536,6 +536,8 @@
 	}
 	ours1 = ast_calloc(1, sizeof(*ours1));
 	ours2 = ast_calloc(1, sizeof(*ours2));
+	if (!ours1 || !ours2)
+		goto safeout;
 	iks_insert_node(iq, jingle);
 	iks_insert_node(jingle, candidate);
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:40:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:40:38 +0200
Subject: [solid-pbx-svn] r377 - in trunk: . doc include/asterisk pbx pbx/ael pbx/ael/ael-test res
Message-ID: <200606280140.k5S1ecp2017245@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:40:14 +0200 (Wed, 28 Jun 2006)
New Revision: 377

Modified:
   trunk/doc/ael.txt
   trunk/include/asterisk/ael_structs.h
   trunk/pbx/ael/ael-test/ref.ael-test1
   trunk/pbx/ael/ael-test/ref.ael-test2
   trunk/pbx/ael/ael-test/ref.ael-test3
   trunk/pbx/ael/ael-test/ref.ael-test4
   trunk/pbx/ael/ael-test/ref.ael-test5
   trunk/pbx/ael/ael-test/ref.ael-test6
   trunk/pbx/ael/ael-test/ref.ael-test7
   trunk/pbx/ael/ael.tab.c
   trunk/pbx/ael/ael.tab.h
   trunk/pbx/ael/ael.y
   trunk/pbx/ael/ael_lex.c
   trunk/pbx/pbx_ael.c
   trunk/res/res_jabber.c
   trunk/say.c
Log:
Update to Asterisk SVN trunk r34673

------------------------------------------------------------------------
r34664 | russell | 2006-06-18 23:26:48 +0200 (Sun, 18 Jun 2006) | 2 lines

fix a polish voicemail bug with saying dates (issue #7389, supczinskib)

------------------------------------------------------------------------
r34665 | russell | 2006-06-18 23:36:24 +0200 (Sun, 18 Jun 2006) | 6 lines

merge changes from team/murf/AEL-trunk-fixesonly
 - fix callerid matching for extensions
 - fix nested switch statements
 - fix compilation with bison 2.1a or higher
(issue #7309)

------------------------------------------------------------------------
r34667 | russell | 2006-06-18 23:45:48 +0200 (Sun, 18 Jun 2006) | 3 lines

handle ast_calloc failure and tweak some formatting to comply with coding
guidelines (issue #7341, casper)

------------------------------------------------------------------------


Modified: trunk/doc/ael.txt
===================================================================
--- trunk/doc/ael.txt	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/doc/ael.txt	2006-06-28 01:40:14 UTC (rev 377)
@@ -35,7 +35,7 @@
       Asterisk. Embedded in this language is the Application/AGI
       commands, of which one application call per step, or priority
       can be made. You can think of this as a "macro assembler"
-      language, that AEL2 will compile into.
+      language, that AEL will compile into.
 
 
 Any programmer of AEL should be familiar with it's syntax, of course,
@@ -178,7 +178,7 @@
 * About "aelparse"          *
 *****************************
 
-You can also use the "aelparse" program to check your extensions.ael
+You can use the "aelparse" program to check your extensions.ael
 file before feeding it to asterisk. Wouldn't it be nice to eliminate
 most errors before giving the file to asterisk?
 
@@ -270,7 +270,7 @@
 capitalized letter somewhere in its name. In the Asterisk extension
 language, application names are NOT case-sensitive.
 
-The following are keywords in the AEL2 language:
+The following are keywords in the AEL language:
 
     * abstract
     * context
@@ -581,7 +581,10 @@
 specification of hints, and a keyword, regexten, that will force the
 numbering of priorities to start at 2.
 
+The ability to make extensions match by CID is preserved in
+AEL; just use '/' and the CID number in the specification. See below.
 
+
 context default {
 
     regexten _5XXX => NoOp(it's a pattern!);
@@ -604,8 +607,20 @@
 
 The regexten must come before the hint if they are both present.
 
+CID matching is done as with the extensions.conf file. Follow the extension
+name/number with a slash (/) and the number to match against the Caller ID:
 
+context zoombo 
+{
+	819/7079953345 => { NoOp(hello, 3345); }
+}
 
+In the above,  the 819/7079953345 extension will only be matched if the
+CallerID is 7079953345, and the dialed number is 819. Hopefully you have
+another 819 extension defined for all those who wish 819, that are not so lucky
+as to have 7079953345 as their CallerID!
+
+
 Includes
 ========
 

Modified: trunk/include/asterisk/ael_structs.h
===================================================================
--- trunk/include/asterisk/ael_structs.h	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/include/asterisk/ael_structs.h	2006-06-28 01:40:14 UTC (rev 377)
@@ -170,6 +170,7 @@
 struct ael_extension
 {
 	char *name;
+	char *cidmatch;
 	char *hints;
 	int regexten;
 	

Modified: trunk/pbx/ael/ael-test/ref.ael-test1
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test1	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test1	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,11 +1,11 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:3 file:pbx_ael.c  line:891 func: check_dow  Warning: file ./extensions.ael, line 67-67: The day (m0n) must be one of 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', or 'sat'!
-LOG: lev:3 file:pbx_ael.c  line:849 func: check_timerange  Warning: file ./extensions.ael, line 78-78: The end time (25:00) is out of range!
-LOG: lev:2 file:pbx_ael.c  line:3441 func: pbx_load_module  AEL load process: checked config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3443 func: pbx_load_module  AEL load process: compiled config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3446 func: pbx_load_module  AEL load process: merged config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3449 func: pbx_load_module  AEL load process: verified config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:3 file:../pbx/pbx_ael.c  line:891 func: check_dow  Warning: file ./extensions.ael, line 67-67: The day (m0n) must be one of 'sun', 'mon', 'tue', 'wed', 'thu', 'fri', or 'sat'!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:849 func: check_timerange  Warning: file ./extensions.ael, line 78-78: The end time (25:00) is out of range!
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3441 func: pbx_load_module  AEL load process: checked config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3443 func: pbx_load_module  AEL load process: compiled config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3446 func: pbx_load_module  AEL load process: merged config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3449 func: pbx_load_module  AEL load process: verified config file name './extensions.ael'.
 LOG: lev:4 file:ael2_parse  line:261 func: main  5 contexts, 13 extensions, 156 priorities

Modified: trunk/pbx/ael/ael-test/ref.ael-test2
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test2	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test2	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,15 +1,15 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./apptest.ael2, 3474 chars
 LOG: lev:3 file:ael.y  line:405 func: ael_yyparse  ==== File: ./apptest.ael2, Line 46, Cols: 8-11: Suggestion: Use the goto statement instead of the Goto() application call in AEL.
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 35-35: application call to EndWhile needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 37-37: application call to ExecIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:4 file:pbx_ael.c  line:1100 func: check_goto  Error: file ./apptest.ael2, line 46-46: goto:  no context cont could be found that matches the goto target!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 47-47: application call to GotoIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 48-48: application call to GotoIfTime needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 85-85: application call to Random needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 141-141: application call to While needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:4 file:pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 0 syntax errors and 1 semantic errors were detected. It doesn't make sense to compile.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 35-35: application call to EndWhile needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 37-37: application call to ExecIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:4 file:../pbx/pbx_ael.c  line:1100 func: check_goto  Error: file ./apptest.ael2, line 46-46: goto:  no context cont could be found that matches the goto target!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 47-47: application call to GotoIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 48-48: application call to GotoIfTime needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 85-85: application call to Random needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 141-141: application call to While needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:4 file:../pbx/pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 0 syntax errors and 1 semantic errors were detected. It doesn't make sense to compile.
 LOG: lev:4 file:ael2_parse  line:261 func: main  0 contexts, 0 extensions, 0 priorities

Modified: trunk/pbx/ael/ael-test/ref.ael-test3
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test3	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test3	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,18 +1,18 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./include1.ael2, 78 chars
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./include2.ael2, 98 chars
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./include3.ael2, 57 chars
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./include5.ael2, 56 chars
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./include4.ael2, 87 chars
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file /etc/asterisk/telemarket_torture.ael2, 28036 chars
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:3 file:pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 5-5: expression Console/dsp has operators, but no variables. Interesting...
-LOG: lev:3 file:pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 8-8: expression "Joe-Worker" has operators, but no variables. Interesting...
-LOG: lev:3 file:pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 10-10: expression Zap/6  has operators, but no variables. Interesting...
-LOG: lev:2 file:pbx_ael.c  line:3441 func: pbx_load_module  AEL load process: checked config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3443 func: pbx_load_module  AEL load process: compiled config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3446 func: pbx_load_module  AEL load process: merged config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3449 func: pbx_load_module  AEL load process: verified config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 5-5: expression Console/dsp has operators, but no variables. Interesting...
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 8-8: expression "Joe-Worker" has operators, but no variables. Interesting...
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 10-10: expression Zap/6  has operators, but no variables. Interesting...
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3441 func: pbx_load_module  AEL load process: checked config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3443 func: pbx_load_module  AEL load process: compiled config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3446 func: pbx_load_module  AEL load process: merged config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3449 func: pbx_load_module  AEL load process: verified config file name './extensions.ael'.
 LOG: lev:4 file:ael2_parse  line:261 func: main  172 contexts, 858 extensions, 2326 priorities

Modified: trunk/pbx/ael/ael-test/ref.ael-test4
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test4	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test4	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,15 +1,15 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
 LOG: lev:2 file:ael.flex  line:467 func: ael_yylex    --Read in included file ./apptest.ael2, 3474 chars
 LOG: lev:3 file:ael.y  line:405 func: ael_yyparse  ==== File: ./apptest.ael2, Line 46, Cols: 8-11: Suggestion: Use the goto statement instead of the Goto() application call in AEL.
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 35-35: application call to EndWhile needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 37-37: application call to ExecIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:4 file:pbx_ael.c  line:1100 func: check_goto  Error: file ./apptest.ael2, line 46-46: goto:  no context cont could be found that matches the goto target!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 47-47: application call to GotoIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 48-48: application call to GotoIfTime needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 85-85: application call to Random needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:3 file:pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 141-141: application call to While needs to be re-written using AEL if, while, goto, etc. keywords instead!
-LOG: lev:4 file:pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 0 syntax errors and 1 semantic errors were detected. It doesn't make sense to compile.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 35-35: application call to EndWhile needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 37-37: application call to ExecIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:4 file:../pbx/pbx_ael.c  line:1100 func: check_goto  Error: file ./apptest.ael2, line 46-46: goto:  no context cont could be found that matches the goto target!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 47-47: application call to GotoIf needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 48-48: application call to GotoIfTime needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 85-85: application call to Random needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2081 func: check_pval_item  Warning: file ./apptest.ael2, line 141-141: application call to While needs to be re-written using AEL if, while, goto, etc. keywords instead!
+LOG: lev:4 file:../pbx/pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 0 syntax errors and 1 semantic errors were detected. It doesn't make sense to compile.
 LOG: lev:4 file:ael2_parse  line:261 func: main  0 contexts, 0 extensions, 0 priorities

Modified: trunk/pbx/ael/ael-test/ref.ael-test5
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test5	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test5	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,9 +1,9 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3441 func: pbx_load_module  AEL load process: checked config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3443 func: pbx_load_module  AEL load process: compiled config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3446 func: pbx_load_module  AEL load process: merged config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3449 func: pbx_load_module  AEL load process: verified config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3441 func: pbx_load_module  AEL load process: checked config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3443 func: pbx_load_module  AEL load process: compiled config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3446 func: pbx_load_module  AEL load process: merged config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3449 func: pbx_load_module  AEL load process: verified config file name './extensions.ael'.
 LOG: lev:4 file:ael2_parse  line:261 func: main  38 contexts, 90 extensions, 484 priorities

Modified: trunk/pbx/ael/ael-test/ref.ael-test6
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test6	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test6	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,20 +1,15 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
-LOG: lev:4 file:ael.flex  line:193 func: ael_yylex  File=./extensions.ael, line=165, column=21: Mismatched '}' in expression!
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 165, Cols: 23-23: Error: syntax error, unexpected '=', expecting ')'
-LOG: lev:4 file:ael.flex  line:317 func: ael_yylex  File=./extensions.ael, line=174, column=63: Mismatched '}' in expression!
-LOG: lev:4 file:ael.flex  line:317 func: ael_yylex  File=./extensions.ael, line=180, column=46: Mismatched '}' in expression!
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 184, Cols: 0-4: Error: syntax error, unexpected 'macro'
-LOG: lev:4 file:ael.flex  line:193 func: ael_yylex  File=./extensions.ael, line=222, column=21: Mismatched '}' in expression!
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 222, Cols: 23-23: Error: syntax error, unexpected '=', expecting ')'
-LOG: lev:4 file:ael.flex  line:317 func: ael_yylex  File=./extensions.ael, line=228, column=37: Mismatched '}' in expression!
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 235, Cols: 0-6: Error: syntax error, unexpected 'context'
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 344, Cols: 32-32: Error: syntax error, unexpected ';', expecting '{'
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 350, Cols: 32-32: Error: syntax error, unexpected ';', expecting '{'
-LOG: lev:4 file:ael.y  line:674 func: ael_yyerror  ==== File: ./extensions.ael, Line 461, Cols: 10-13: Error: syntax error, unexpected 'else'
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:4 file:pbx_ael.c  line:1100 func: check_goto  Error: file ./extensions.ael, line 11-11: goto:  no context default could be found that matches the goto target!
-LOG: lev:4 file:pbx_ael.c  line:2036 func: check_pval_item  Error: file ./extensions.ael, line 206-206: macro call to non-existent uvm !
-LOG: lev:4 file:pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 7 syntax errors and 2 semantic errors were detected. It doesn't make sense to compile.
-LOG: lev:4 file:ael2_parse  line:261 func: main  0 contexts, 0 extensions, 0 priorities
+Executed ast_register_file_version();
+Executed ast_register_file_version();
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3453 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3460 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:4 file:ael.flex  line:267 func: ael_yylex  File=./extensions.ael, line=165, column=49: Mismatched '}' in expression!
+LOG: lev:4 file:ael.y  line:726 func: ael_yyerror  ==== File: ./extensions.ael, Line 165, Cols: 51-51: Error: syntax error, unexpected '=', expecting ')'
+LOG: lev:4 file:ael.y  line:726 func: ael_yyerror  ==== File: ./extensions.ael, Line 169, Cols: 24-24: Error: syntax error, unexpected '&'
+LOG: lev:4 file:ael.flex  line:267 func: ael_yylex  File=./extensions.ael, line=222, column=41: Mismatched '}' in expression!
+LOG: lev:4 file:ael.y  line:726 func: ael_yyerror  ==== File: ./extensions.ael, Line 222, Cols: 43-43: Error: syntax error, unexpected '=', expecting ')'
+LOG: lev:4 file:ael.y  line:726 func: ael_yyerror  ==== File: ./extensions.ael, Line 226, Cols: 16-16: Error: syntax error, unexpected '&'
+LOG: lev:4 file:ael.y  line:726 func: ael_yyerror  ==== File: ./extensions.ael, Line 291, Cols: 21-28: Error: syntax error, unexpected word, expecting '(' or ';' or '=' or ':'
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3463 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:4 file:../pbx/pbx_ael.c  line:3476 func: pbx_load_module  Sorry, but 5 syntax errors and 0 semantic errors were detected. It doesn't make sense to compile.
+LOG: lev:4 file:ael2_parse  line:253 func: main  0 contexts, 0 extensions, 0 priorities

Modified: trunk/pbx/ael/ael-test/ref.ael-test7
===================================================================
--- trunk/pbx/ael/ael-test/ref.ael-test7	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael-test/ref.ael-test7	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,13 +1,13 @@
 Executed ast_register_file_version();
-LOG: lev:2 file:pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
-LOG: lev:2 file:pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
-LOG: lev:2 file:pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
-LOG: lev:3 file:pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 6-6: expression Console/dsp has operators, but no variables. Interesting...
-LOG: lev:3 file:pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 10-10: expression pstn-spa3k has operators, but no variables. Interesting...
-LOG: lev:4 file:pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 98-98: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
-LOG: lev:4 file:pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 107-107: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
-LOG: lev:4 file:pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 284-284: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
-LOG: lev:4 file:pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 287-287: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
-LOG: lev:4 file:pbx_ael.c  line:2036 func: check_pval_item  Error: file ./extensions.ael, line 452-452: macro call to non-existent std-exten-ael !
-LOG: lev:4 file:pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 0 syntax errors and 5 semantic errors were detected. It doesn't make sense to compile.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3428 func: pbx_load_module  Starting AEL load process.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3435 func: pbx_load_module  AEL load process: calculated config file name './extensions.ael'.
+LOG: lev:2 file:../pbx/pbx_ael.c  line:3438 func: pbx_load_module  AEL load process: parsed config file name './extensions.ael'.
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 6-6: expression Console/dsp has operators, but no variables. Interesting...
+LOG: lev:3 file:../pbx/pbx_ael.c  line:2186 func: check_pval_item  Warning: file ./extensions.ael, line 10-10: expression pstn-spa3k has operators, but no variables. Interesting...
+LOG: lev:4 file:../pbx/pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 98-98: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
+LOG: lev:4 file:../pbx/pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 107-107: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
+LOG: lev:4 file:../pbx/pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 284-284: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
+LOG: lev:4 file:../pbx/pbx_ael.c  line:2055 func: check_pval_item  Error: file ./extensions.ael, line 287-287: The macro call to checkanddial has 5 arguments, but the macro definition has 7 arguments
+LOG: lev:4 file:../pbx/pbx_ael.c  line:2036 func: check_pval_item  Error: file ./extensions.ael, line 452-452: macro call to non-existent std-exten-ael !
+LOG: lev:4 file:../pbx/pbx_ael.c  line:3451 func: pbx_load_module  Sorry, but 0 syntax errors and 5 semantic errors were detected. It doesn't make sense to compile.
 LOG: lev:4 file:ael2_parse  line:261 func: main  0 contexts, 0 extensions, 0 priorities

Modified: trunk/pbx/ael/ael.tab.c
===================================================================
--- trunk/pbx/ael/ael.tab.c	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael.tab.c	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,7 +1,7 @@
-/* A Bison parser, made by GNU Bison 2.1.  */
+/* A Bison parser, made by GNU Bison 2.1a.  */
 
 /* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -23,8 +23,8 @@
    This special exception was added by the Free Software Foundation
    in version 1.24 of Bison.  */
 
-/* Written by Richard Stallman by simplifying the original so called
-   ``semantic'' parser.  */
+/* C LALR(1) parser skeleton written by Richard Stallman, by
+   simplifying the original so-called "semantic" parser.  */
 
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
@@ -37,7 +37,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.1"
+#define YYBISON_VERSION "2.1a"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -220,21 +220,23 @@
 # define YYTOKEN_TABLE 0
 #endif
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 48 "ael.y"
-typedef union YYSTYPE {
+{
 	int	intval;		/* integer value, typically flags */
 	char	*str;		/* strings */
 	struct pval *pval;	/* full objects */
-} YYSTYPE;
-/* Line 196 of yacc.c.  */
-#line 227 "ael.tab.c"
+}
+/* Line 198 of yacc.c.  */
+#line 228 "ael.tab.c"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
 #endif
 
-#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
 typedef struct YYLTYPE
 {
   int first_line;
@@ -271,23 +273,56 @@
 static pval *update_last(pval *, YYLTYPE *);
 
 
-/* Line 219 of yacc.c.  */
-#line 271 "ael.tab.c"
+/* Line 221 of yacc.c.  */
+#line 273 "ael.tab.c"
 
-#if ! defined (YYSIZE_T) && defined (__SIZE_TYPE__)
-# define YYSIZE_T __SIZE_TYPE__
+#ifdef short
+# undef short
 #endif
-#if ! defined (YYSIZE_T) && defined (size_t)
-# define YYSIZE_T size_t
+
+#ifdef YYTYPE_UINT8
+typedef YYTYPE_UINT8 yytype_uint8;
+#else
+typedef unsigned char yytype_uint8;
 #endif
-#if ! defined (YYSIZE_T) && (defined (__STDC__) || defined (__cplusplus))
-# include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-# define YYSIZE_T size_t
+
+#ifdef YYTYPE_INT8
+typedef YYTYPE_INT8 yytype_int8;
+#elif (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+typedef signed char yytype_int8;
+#else
+typedef short int yytype_int8;
 #endif
-#if ! defined (YYSIZE_T)
-# define YYSIZE_T unsigned int
+
+#ifdef YYTYPE_UINT16
+typedef YYTYPE_UINT16 yytype_uint16;
+#else
+typedef unsigned short int yytype_uint16;
 #endif
 
+#ifdef YYTYPE_INT16
+typedef YYTYPE_INT16 yytype_int16;
+#else
+typedef short int yytype_int16;
+#endif
+
+#ifndef YYSIZE_T
+# ifdef __SIZE_TYPE__
+#  define YYSIZE_T __SIZE_TYPE__
+# elif defined size_t
+#  define YYSIZE_T size_t
+# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
+#  define YYSIZE_T size_t
+# else
+#  define YYSIZE_T unsigned int
+# endif
+#endif
+
+#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
+
 #ifndef YY_
 # if YYENABLE_NLS
 #  if ENABLE_NLS
@@ -300,54 +335,89 @@
 # endif
 #endif
 
-#if ! defined (yyoverflow) || YYERROR_VERBOSE
+/* Suppress unused-variable warnings by "using" E.  */
+#if ! defined lint || defined __GNUC__
+# define YYUSE(e) ((void) (e))
+#else
+# define YYUSE(e) /* empty */
+#endif
 
+/* Identity function, used to suppress warnings about constant conditions.  */
+#ifndef lint
+# define YYID(n) (n)
+#else
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static int
+YYID (int i)
+#else
+static int
+YYID (i)
+    int i;
+#endif
+{
+  return i;
+}
+#endif
+
+#if ! defined yyoverflow || YYERROR_VERBOSE
+
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
 # ifdef YYSTACK_USE_ALLOCA
 #  if YYSTACK_USE_ALLOCA
 #   ifdef __GNUC__
 #    define YYSTACK_ALLOC __builtin_alloca
+#   elif defined __BUILTIN_VA_ARG_INCR
+#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
+#   elif defined _AIX
+#    define YYSTACK_ALLOC __alloca
+#   elif defined _MSC_VER
+#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
+#    define alloca _alloca
 #   else
 #    define YYSTACK_ALLOC alloca
-#    if defined (__STDC__) || defined (__cplusplus)
+#    if ! defined _ALLOCA_H && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 #     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     define YYINCLUDED_STDLIB_H
+#     ifndef _STDLIB_H
+#      define _STDLIB_H 1
+#     endif
 #    endif
 #   endif
 #  endif
 # endif
 
 # ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning. */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (0)
+   /* Pacify GCC's `empty if-body' warning.  */
+#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
 #  ifndef YYSTACK_ALLOC_MAXIMUM
     /* The OS might guarantee only one guard page at the bottom of the stack,
        and a page size can be as small as 4096 bytes.  So we cannot safely
        invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
        to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2005 */
+#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
 #  endif
 # else
 #  define YYSTACK_ALLOC YYMALLOC
 #  define YYSTACK_FREE YYFREE
 #  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM ((YYSIZE_T) -1)
+#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
 #  ifdef __cplusplus
 extern "C" {
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
-#   if (! defined (malloc) && ! defined (YYINCLUDED_STDLIB_H) \
-	&& (defined (__STDC__) || defined (__cplusplus)))
+#   if ! defined malloc && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 #  ifndef YYFREE
 #   define YYFREE free
-#   if (! defined (free) && ! defined (YYINCLUDED_STDLIB_H) \
-	&& (defined (__STDC__) || defined (__cplusplus)))
+#   if ! defined free && ! defined _STDLIB_H && (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
@@ -355,18 +425,18 @@
 }
 #  endif
 # endif
-#endif /* ! defined (yyoverflow) || YYERROR_VERBOSE */
+#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
 
-#if (! defined (yyoverflow) \
-     && (! defined (__cplusplus) \
-	 || (defined (YYLTYPE_IS_TRIVIAL) && YYLTYPE_IS_TRIVIAL \
-             && defined (YYSTYPE_IS_TRIVIAL) && YYSTYPE_IS_TRIVIAL)))
+#if (! defined yyoverflow \
+     && (! defined __cplusplus \
+	 || (defined YYLTYPE_IS_TRIVIAL && YYLTYPE_IS_TRIVIAL \
+	     && defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
 
 /* A type that is properly aligned for any stack member.  */
 union yyalloc
 {
-  short int yyss;
+  yytype_int16 yyss;
   YYSTYPE yyvs;
     YYLTYPE yyls;
 };
@@ -377,13 +447,13 @@
 /* The size of an array large to enough to hold all stacks, each with
    N elements.  */
 # define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (short int) + sizeof (YYSTYPE) + sizeof (YYLTYPE))	\
+     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE) + sizeof (YYLTYPE)) \
       + 2 * YYSTACK_GAP_MAXIMUM)
 
 /* Copy COUNT objects from FROM to TO.  The source and destination do
    not overlap.  */
 # ifndef YYCOPY
-#  if defined (__GNUC__) && 1 < __GNUC__
+#  if defined __GNUC__ && 1 < __GNUC__
 #   define YYCOPY(To, From, Count) \
       __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
 #  else
@@ -394,7 +464,7 @@
 	  for (yyi = 0; yyi < (Count); yyi++)	\
 	    (To)[yyi] = (From)[yyi];		\
 	}					\
-      while (0)
+      while (YYID (0))
 #  endif
 # endif
 
@@ -412,28 +482,22 @@
 	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
 	yyptr += yynewbytes / sizeof (*yyptr);				\
       }									\
-    while (0)
+    while (YYID (0))
 
 #endif
 
-#if defined (__STDC__) || defined (__cplusplus)
-   typedef signed char yysigned_char;
-#else
-   typedef short int yysigned_char;
-#endif
-
-/* YYFINAL -- State number of the termination state. */
+/* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  14
 /* YYLAST -- Last index in YYTABLE.  */
 #define YYLAST   275
 
-/* YYNTOKENS -- Number of terminals. */
+/* YYNTOKENS -- Number of terminals.  */
 #define YYNTOKENS  42
-/* YYNNTS -- Number of nonterminals. */
+/* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  53
-/* YYNRULES -- Number of rules. */
+/* YYNRULES -- Number of rules.  */
 #define YYNRULES  128
-/* YYNRULES -- Number of states. */
+/* YYNRULES -- Number of states.  */
 #define YYNSTATES  258
 
 /* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
@@ -444,7 +508,7 @@
   ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
 
 /* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const unsigned char yytranslate[] =
+static const yytype_uint8 yytranslate[] =
 {
        0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
        2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
@@ -481,7 +545,7 @@
 #if YYDEBUG
 /* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
    YYRHS.  */
-static const unsigned short int yyprhs[] =
+static const yytype_uint16 yyprhs[] =
 {
        0,     0,     3,     5,     7,    10,    13,    15,    17,    19,
       21,    23,    25,    32,    34,    35,    44,    49,    50,    53,
@@ -498,8 +562,8 @@
      392,   396,   399,   401,   405,   408,   412,   415,   420
 };
 
-/* YYRHS -- A `-1'-separated list of the rules' RHS. */
-static const yysigned_char yyrhs[] =
+/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
+static const yytype_int8 yyrhs[] =
 {
       43,     0,    -1,    44,    -1,    45,    -1,    44,    45,    -1,
       44,     1,    -1,    47,    -1,    49,    -1,    50,    -1,     8,
@@ -547,7 +611,7 @@
 };
 
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const unsigned short int yyrline[] =
+static const yytype_uint16 yyrline[] =
 {
        0,   179,   179,   182,   183,   184,   187,   188,   189,   190,
      193,   194,   197,   205,   206,   209,   214,   219,   220,   221,
@@ -557,17 +621,17 @@
      310,   313,   316,   327,   328,   335,   336,   341,   349,   350,
      354,   360,   369,   372,   373,   376,   379,   382,   383,   384,
      382,   390,   394,   395,   396,   397,   400,   400,   433,   434,
-     435,   436,   440,   443,   444,   449,   450,   453,   456,   460,
-     464,   468,   474,   475,   479,   482,   488,   488,   493,   501,
-     501,   512,   519,   522,   523,   526,   527,   530,   533,   534,
-     537,   541,   545,   551,   552,   555,   556,   562,   567,   572,
-     573,   574,   577,   578,   585,   586,   587,   590,   593
+     435,   436,   440,   443,   444,   447,   448,   451,   454,   458,
+     462,   466,   472,   473,   477,   480,   486,   486,   491,   499,
+     499,   510,   517,   520,   521,   524,   525,   528,   531,   532,
+     535,   539,   543,   549,   550,   553,   554,   560,   565,   570,
+     571,   572,   575,   576,   583,   584,   585,   588,   591
 };
 #endif
 
 #if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals. */
+   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
   "$end", "error", "$undefined", "KW_CONTEXT", "LC", "RC", "LP", "RP",
@@ -593,7 +657,7 @@
 # ifdef YYPRINT
 /* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
    token YYLEX-NUM.  */
-static const unsigned short int yytoknum[] =
+static const yytype_uint16 yytoknum[] =
 {
        0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
      265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
@@ -604,7 +668,7 @@
 # endif
 
 /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const unsigned char yyr1[] =
+static const yytype_uint8 yyr1[] =
 {
        0,    42,    43,    44,    44,    44,    45,    45,    45,    45,
       46,    46,    47,    48,    48,    49,    50,    51,    51,    51,
@@ -622,7 +686,7 @@
 };
 
 /* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const unsigned char yyr2[] =
+static const yytype_uint8 yyr2[] =
 {
        0,     2,     1,     1,     2,     2,     1,     1,     1,     1,
        1,     1,     6,     1,     0,     8,     4,     0,     2,     2,
@@ -642,7 +706,7 @@
 /* YYDEFACT[STATE-NAME] -- Default rule to reduce with in state
    STATE-NUM when YYTABLE doesn't specify something else to do.  Zero
    means the default is an error.  */
-static const unsigned char yydefact[] =
+static const yytype_uint8 yydefact[] =
 {
       14,     9,     0,     0,    13,     0,     0,     3,     6,     0,
        7,     8,     0,    17,     1,     5,     4,     0,    22,     0,
@@ -672,8 +736,8 @@
        0,     0,    69,    47,     0,     0,     0,    70
 };
 
-/* YYDEFGOTO[NTERM-NUM]. */
-static const short int yydefgoto[] =
+/* YYDEFGOTO[NTERM-NUM].  */
+static const yytype_int16 yydefgoto[] =
 {
       -1,     5,     6,     7,   101,     8,     9,    10,    11,    20,
       83,    35,    26,    45,    46,    47,    48,   105,   160,   161,
@@ -686,7 +750,7 @@
 /* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
    STATE-NUM.  */
 #define YYPACT_NINF -103
-static const short int yypact[] =
+static const yytype_int16 yypact[] =
 {
      142,  -103,   -28,    52,  -103,    80,   148,  -103,  -103,    84,
     -103,  -103,    88,    65,  -103,  -103,  -103,   -20,    77,   126,
@@ -717,7 +781,7 @@
 };
 
 /* YYPGOTO[NTERM-NUM].  */
-static const short int yypgoto[] =
+static const yytype_int16 yypgoto[] =
 {
     -103,  -103,  -103,   251,   -15,  -103,  -103,  -103,  -103,   240,
       -6,  -103,  -103,   188,  -103,  -103,  -103,  -102,  -103,   102,
@@ -732,7 +796,7 @@
    number is the opposite.  If zero, do what YYDEFACT says.
    If YYTABLE_NINF, syntax error.  */
 #define YYTABLE_NINF -121
-static const short int yytable[] =
+static const yytype_int16 yytable[] =
 {
       86,    96,    24,   118,   154,    99,   149,    21,    56,   165,
      150,   104,    62,    12,   130,    21,    22,    32,    57,   -55,
@@ -764,7 +828,7 @@
        0,     0,     0,   250,     0,   255
 };
 
-static const short int yycheck[] =
+static const yytype_int16 yycheck[] =
 {
       52,    58,    17,    75,   106,    60,     1,    13,    31,    11,
        5,    63,     1,    41,     7,    21,    36,     1,    41,    11,
@@ -798,7 +862,7 @@
 
 /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
    symbol of state STATE-NUM.  */
-static const unsigned char yystos[] =
+static const yytype_uint8 yystos[] =
 {
        0,     8,    15,    16,    23,    43,    44,    45,    47,    48,
       49,    50,    41,     4,     0,     1,    45,     3,     6,    41,
@@ -853,7 +917,7 @@
       yychar = (Token);						\
       yylval = (Value);						\
       yytoken = YYTRANSLATE (yychar);				\
-      YYPOPSTACK;						\
+      YYPOPSTACK (1);						\
       goto yybackup;						\
     }								\
   else								\
@@ -861,7 +925,7 @@
       yyerror (&yylloc, parseio, YY_("syntax error: cannot back up")); \
       YYERROR;							\
     }								\
-while (0)
+while (YYID (0))
 
 
 #define YYTERROR	1
@@ -876,7 +940,7 @@
 #ifndef YYLLOC_DEFAULT
 # define YYLLOC_DEFAULT(Current, Rhs, N)				\
     do									\
-      if (N)								\
+      if (YYID (N))                                                    \
 	{								\
 	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
 	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
@@ -890,7 +954,7 @@
 	  (Current).first_column = (Current).last_column =		\
 	    YYRHSLOC (Rhs, 0).last_column;				\
 	}								\
-    while (0)
+    while (YYID (0))
 #endif
 
 
@@ -902,8 +966,8 @@
 # if YYLTYPE_IS_TRIVIAL
 #  define YY_LOCATION_PRINT(File, Loc)			\
      fprintf (File, "%d.%d-%d.%d",			\
-              (Loc).first_line, (Loc).first_column,	\
-              (Loc).last_line,  (Loc).last_column)
+	      (Loc).first_line, (Loc).first_column,	\
+	      (Loc).last_line,  (Loc).last_column)
 # else
 #  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
 # endif
@@ -930,36 +994,104 @@
 do {						\
   if (yydebug)					\
     YYFPRINTF Args;				\
-} while (0)
+} while (YYID (0))
 
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)		\
-do {								\
-  if (yydebug)							\
-    {								\
-      YYFPRINTF (stderr, "%s ", Title);				\
-      yysymprint (stderr,					\
-                  Type, Value, Location);	\
-      YYFPRINTF (stderr, "\n");					\
-    }								\
-} while (0)
+# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
+do {									  \
+  if (yydebug)								  \
+    {									  \
+      YYFPRINTF (stderr, "%s ", Title);					  \
+      yy_symbol_print (stderr,						  \
+		  Type, Value, Location, parseio); \
+      YYFPRINTF (stderr, "\n");						  \
+    }									  \
+} while (YYID (0))
 
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_value_print (FILE *yyoutput, int yytype, const YYSTYPE * const yyvaluep, const YYLTYPE * const yylocationp, struct parse_io *parseio)
+#else
+static void
+yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp, parseio)
+    FILE *yyoutput;
+    int yytype;
+    const YYSTYPE * const yyvaluep;
+    const YYLTYPE * const yylocationp;
+    struct parse_io *parseio;
+#endif
+{
+  if (!yyvaluep)
+    return;
+  YYUSE (yylocationp);
+  YYUSE (parseio);
+# ifdef YYPRINT
+  if (yytype < YYNTOKENS)
+    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
+# else
+  YYUSE (yyoutput);
+# endif
+  switch (yytype)
+    {
+      default:
+	break;
+    }
+}
+
+
+/*--------------------------------.
+| Print this symbol on YYOUTPUT.  |
+`--------------------------------*/
+
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+static void
+yy_symbol_print (FILE *yyoutput, int yytype, const YYSTYPE * const yyvaluep, const YYLTYPE * const yylocationp, struct parse_io *parseio)
+#else
+static void
+yy_symbol_print (yyoutput, yytype, yyvaluep, yylocationp, parseio)
+    FILE *yyoutput;
+    int yytype;
+    const YYSTYPE * const yyvaluep;
+    const YYLTYPE * const yylocationp;
+    struct parse_io *parseio;
+#endif
+{
+  if (yytype < YYNTOKENS)
+    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
+  else
+    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+
+  YY_LOCATION_PRINT (yyoutput, *yylocationp);
+  YYFPRINTF (yyoutput, ": ");
+  yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp, parseio);
+  YYFPRINTF (yyoutput, ")");
+}
+
 /*------------------------------------------------------------------.
 | yy_stack_print -- Print the state stack from its BOTTOM up to its |
 | TOP (included).                                                   |
 `------------------------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_stack_print (short int *bottom, short int *top)
+yy_stack_print (yytype_int16 *bottom, yytype_int16 *top)
 #else
 static void
 yy_stack_print (bottom, top)
-    short int *bottom;
-    short int *top;
+    yytype_int16 *bottom;
+    yytype_int16 *top;
 #endif
 {
   YYFPRINTF (stderr, "Stack now");
-  for (/* Nothing. */; bottom <= top; ++bottom)
+  for (; bottom <= top; ++bottom)
     YYFPRINTF (stderr, " %d", *bottom);
   YYFPRINTF (stderr, "\n");
 }
@@ -968,37 +1100,47 @@
 do {								\
   if (yydebug)							\
     yy_stack_print ((Bottom), (Top));				\
-} while (0)
+} while (YYID (0))
 
 
 /*------------------------------------------------.
 | Report that the YYRULE is going to be reduced.  |
 `------------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yy_reduce_print (int yyrule)
+yy_reduce_print (YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule, struct parse_io *parseio)
 #else
 static void
-yy_reduce_print (yyrule)
+yy_reduce_print (yyvsp, yylsp, yyrule, parseio)
+    YYSTYPE *yyvsp;
+    YYLTYPE *yylsp;
     int yyrule;
+    struct parse_io *parseio;
 #endif
 {
+  int yynrhs = yyr2[yyrule];
   int yyi;
   unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu), ",
-             yyrule - 1, yylno);
-  /* Print the symbols being reduced, and their result.  */
-  for (yyi = yyprhs[yyrule]; 0 <= yyrhs[yyi]; yyi++)
-    YYFPRINTF (stderr, "%s ", yytname[yyrhs[yyi]]);
-  YYFPRINTF (stderr, "-> %s\n", yytname[yyr1[yyrule]]);
+  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
+	     yyrule - 1, yylno);
+  /* The symbols being reduced.  */
+  for (yyi = 0; yyi < yynrhs; yyi++)
+    {
+      fprintf (stderr, "   $%d = ", yyi + 1);
+      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
+		       &(yyvsp[(yyi + 1) - (yynrhs)])
+		       , &(yylsp[(yyi + 1) - (yynrhs)])		       , parseio);
+      fprintf (stderr, "\n");
+    }
 }
 
 # define YY_REDUCE_PRINT(Rule)		\
 do {					\
   if (yydebug)				\
-    yy_reduce_print (Rule);		\
-} while (0)
+    yy_reduce_print (yyvsp, yylsp, Rule, parseio); \
+} while (YYID (0))
 
 /* Nonzero means print parse trace.  It is left uninitialized so that
    multiple parsers can coexist.  */
@@ -1032,42 +1174,44 @@
 #if YYERROR_VERBOSE
 
 # ifndef yystrlen
-#  if defined (__GLIBC__) && defined (_STRING_H)
+#  if defined __GLIBC__ && defined _STRING_H
 #   define yystrlen strlen
 #  else
 /* Return the length of YYSTR.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static YYSIZE_T
-#   if defined (__STDC__) || defined (__cplusplus)
 yystrlen (const char *yystr)
-#   else
+#else
+static YYSIZE_T
 yystrlen (yystr)
-     const char *yystr;
-#   endif
+    const char *yystr;
+#endif
 {
-  const char *yys = yystr;
-
-  while (*yys++ != '\0')
+  YYSIZE_T yylen;
+  for (yylen = 0; yystr[yylen]; yylen++)
     continue;
-
-  return yys - yystr - 1;
+  return yylen;
 }
 #  endif
 # endif
 
 # ifndef yystpcpy
-#  if defined (__GLIBC__) && defined (_STRING_H) && defined (_GNU_SOURCE)
+#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
 #   define yystpcpy stpcpy
 #  else
 /* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
    YYDEST.  */
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static char *
-#   if defined (__STDC__) || defined (__cplusplus)
 yystpcpy (char *yydest, const char *yysrc)
-#   else
+#else
+static char *
 yystpcpy (yydest, yysrc)
-     char *yydest;
-     const char *yysrc;
-#   endif
+    char *yydest;
+    const char *yysrc;
+#endif
 {
   char *yyd = yydest;
   const char *yys = yysrc;
@@ -1128,71 +1272,138 @@
 }
 # endif
 
-#endif /* YYERROR_VERBOSE */
+/* Copy into YYRESULT an error message about the unexpected token
+   YYCHAR while in state YYSTATE.  Return the number of bytes copied,
+   including the terminating null byte.  If YYRESULT is null, do not
+   copy anything; just return the number of bytes that would be
+   copied.  As a special case, return 0 if an ordinary "syntax error"
+   message will do.  Return YYSIZE_MAXIMUM if overflow occurs during
+   size calculation.  */
+static YYSIZE_T
+yysyntax_error (char *yyresult, int yystate, int yychar)
+{
+  int yyn = yypact[yystate];
 
-
+  if (! (YYPACT_NINF < yyn && yyn < YYLAST))
+    return 0;
+  else
+    {
+      int yytype = YYTRANSLATE (yychar);
+      YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
+      YYSIZE_T yysize = yysize0;
+      YYSIZE_T yysize1;
+      int yysize_overflow = 0;
+      enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
+      char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
+      int yyx;
 
-#if YYDEBUG
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
+# if 0
+      /* This is so xgettext sees the translatable formats that are
+	 constructed on the fly.  */
+      YY_("syntax error, unexpected %s");
+      YY_("syntax error, unexpected %s, expecting %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s");
+      YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
+# endif
+      char *yyfmt;
+      char const *yyf;
+      static char const yyunexpected[] = "syntax error, unexpected %s";
+      static char const yyexpecting[] = ", expecting %s";
+      static char const yyor[] = " or %s";
+      char yyformat[sizeof yyunexpected
+		    + sizeof yyexpecting - 1
+		    + ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
+		       * (sizeof yyor - 1))];
+      char const *yyprefix = yyexpecting;
 
-#if defined (__STDC__) || defined (__cplusplus)
-static void
-yysymprint (FILE *yyoutput, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp)
-#else
-static void
-yysymprint (yyoutput, yytype, yyvaluep, yylocationp)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE *yyvaluep;
-    YYLTYPE *yylocationp;
-#endif
-{
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-  (void) yylocationp;
+      /* Start YYX at -YYN if negative to avoid negative indexes in
+	 YYCHECK.  */
+      int yyxbegin = yyn < 0 ? -yyn : 0;
 
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
+      /* Stay within bounds of both yycheck and yytname.  */
+      int yychecklim = YYLAST - yyn;
+      int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
+      int yycount = 1;
 
-  YY_LOCATION_PRINT (yyoutput, *yylocationp);
-  YYFPRINTF (yyoutput, ": ");
+      yyarg[0] = yytname[yytype];
+      yyfmt = yystpcpy (yyformat, yyunexpected);
 
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# endif
-  switch (yytype)
-    {
-      default:
-        break;
+      for (yyx = yyxbegin; yyx < yyxend; ++yyx)
+	if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+	  {
+	    if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
+	      {
+		yycount = 1;
+		yysize = yysize0;
+		yyformat[sizeof yyunexpected - 1] = '\0';
+		break;
+	      }
+	    yyarg[yycount++] = yytname[yyx];
+	    yysize1 = yysize + yytnamerr (0, yytname[yyx]);
+	    yysize_overflow |= (yysize1 < yysize);
+	    yysize = yysize1;
+	    yyfmt = yystpcpy (yyfmt, yyprefix);
+	    yyprefix = yyor;
+	  }
+
+      yyf = YY_(yyformat);
+      yysize1 = yysize + yystrlen (yyf);
+      yysize_overflow |= (yysize1 < yysize);
+      yysize = yysize1;
+
+      if (yysize_overflow)
+	return YYSIZE_MAXIMUM;
+
+      if (yyresult)
+	{
+	  /* Avoid sprintf, as that infringes on the user's name space.
+	     Don't have undefined behavior even if the translation
+	     produced a string with the wrong number of "%s"s.  */
+	  char *yyp = yyresult;
+	  int yyi = 0;
+	  while ((*yyp = *yyf) != '\0')
+	    {
+	      if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
+		{
+		  yyp += yytnamerr (yyp, yyarg[yyi++]);
+		  yyf += 2;
+		}
+	      else
+		{
+		  yyp++;
+		  yyf++;
+		}
+	    }
+	}
+      return yysize;
     }
-  YYFPRINTF (yyoutput, ")");
 }
+#endif /* YYERROR_VERBOSE */
+
 
-#endif /* ! YYDEBUG */
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
-#if defined (__STDC__) || defined (__cplusplus)
+/*ARGSUSED*/
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp)
+yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, YYLTYPE *yylocationp, struct parse_io *parseio)
 #else
 static void
-yydestruct (yymsg, yytype, yyvaluep, yylocationp)
+yydestruct (yymsg, yytype, yyvaluep, yylocationp, parseio)
     const char *yymsg;
     int yytype;
     YYSTYPE *yyvaluep;
     YYLTYPE *yylocationp;
+    struct parse_io *parseio;
 #endif
 {
-  /* Pacify ``unused variable'' warnings.  */
-  (void) yyvaluep;
-  (void) yylocationp;
+  YYUSE (yyvaluep);
+  YYUSE (yylocationp);
+  YYUSE (parseio);
 
   if (!yymsg)
     yymsg = "Deleting";
@@ -1202,324 +1413,324 @@
     {
       case 41: /* "word" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1202 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1413 "ael.tab.c"
+	break;
       case 44: /* "objects" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1210 "ael.tab.c"
-        break;
+#line 1421 "ael.tab.c"
+	break;
       case 45: /* "object" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1218 "ael.tab.c"
-        break;
+#line 1429 "ael.tab.c"
+	break;
       case 46: /* "context_name" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1223 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1434 "ael.tab.c"
+	break;
       case 47: /* "context" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1231 "ael.tab.c"
-        break;
+#line 1442 "ael.tab.c"
+	break;
       case 49: /* "macro" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1239 "ael.tab.c"
-        break;
+#line 1450 "ael.tab.c"
+	break;
       case 50: /* "globals" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1247 "ael.tab.c"
-        break;
+#line 1458 "ael.tab.c"
+	break;
       case 51: /* "global_statements" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1255 "ael.tab.c"
-        break;
+#line 1466 "ael.tab.c"
+	break;
       case 52: /* "assignment" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1263 "ael.tab.c"
-        break;
+#line 1474 "ael.tab.c"
+	break;
       case 54: /* "arglist" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1271 "ael.tab.c"
-        break;
+#line 1482 "ael.tab.c"
+	break;
       case 55: /* "elements" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1279 "ael.tab.c"
-        break;
+#line 1490 "ael.tab.c"
+	break;
       case 56: /* "element" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1287 "ael.tab.c"
-        break;
+#line 1498 "ael.tab.c"
+	break;
       case 57: /* "ignorepat" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1295 "ael.tab.c"
-        break;
+#line 1506 "ael.tab.c"
+	break;
       case 58: /* "extension" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1303 "ael.tab.c"
-        break;
+#line 1514 "ael.tab.c"
+	break;
       case 59: /* "statements" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1311 "ael.tab.c"
-        break;
+#line 1522 "ael.tab.c"
+	break;
       case 60: /* "timerange" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1316 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1527 "ael.tab.c"
+	break;
       case 61: /* "timespec" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1324 "ael.tab.c"
-        break;
+#line 1535 "ael.tab.c"
+	break;
       case 62: /* "test_expr" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1329 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1540 "ael.tab.c"
+	break;
       case 64: /* "if_like_head" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1337 "ael.tab.c"
-        break;
+#line 1548 "ael.tab.c"
+	break;
       case 65: /* "word_list" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1342 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1553 "ael.tab.c"
+	break;
       case 66: /* "word3_list" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1347 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1558 "ael.tab.c"
+	break;
       case 67: /* "goto_word" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1352 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1563 "ael.tab.c"
+	break;
       case 68: /* "switch_statement" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1360 "ael.tab.c"
-        break;
+#line 1571 "ael.tab.c"
+	break;
       case 69: /* "statement" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1368 "ael.tab.c"
-        break;
+#line 1579 "ael.tab.c"
+	break;
       case 74: /* "opt_else" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1376 "ael.tab.c"
-        break;
+#line 1587 "ael.tab.c"
+	break;
       case 75: /* "target" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1384 "ael.tab.c"
-        break;
+#line 1595 "ael.tab.c"
+	break;
       case 76: /* "opt_pri" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1389 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1600 "ael.tab.c"
+	break;
       case 77: /* "jumptarget" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1397 "ael.tab.c"
-        break;
+#line 1608 "ael.tab.c"
+	break;
       case 78: /* "macro_call" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1405 "ael.tab.c"
-        break;
+#line 1616 "ael.tab.c"
+	break;
       case 80: /* "application_call_head" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1413 "ael.tab.c"
-        break;
+#line 1624 "ael.tab.c"
+	break;
       case 82: /* "application_call" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1421 "ael.tab.c"
-        break;
+#line 1632 "ael.tab.c"
+	break;
       case 83: /* "opt_word" */
 #line 171 "ael.y"
-        { free((yyvaluep->str));};
-#line 1426 "ael.tab.c"
-        break;
+	{ free((yyvaluep->str));};
+#line 1637 "ael.tab.c"
+	break;
       case 84: /* "eval_arglist" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1434 "ael.tab.c"
-        break;
+#line 1645 "ael.tab.c"
+	break;
       case 85: /* "case_statements" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1442 "ael.tab.c"
-        break;
+#line 1653 "ael.tab.c"
+	break;
       case 86: /* "case_statement" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1450 "ael.tab.c"
-        break;
+#line 1661 "ael.tab.c"
+	break;
       case 87: /* "macro_statements" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1458 "ael.tab.c"
-        break;
+#line 1669 "ael.tab.c"
+	break;
       case 88: /* "macro_statement" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1466 "ael.tab.c"
-        break;
+#line 1677 "ael.tab.c"
+	break;
       case 89: /* "switches" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1474 "ael.tab.c"
-        break;
+#line 1685 "ael.tab.c"
+	break;
       case 90: /* "eswitches" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1482 "ael.tab.c"
-        break;
+#line 1693 "ael.tab.c"
+	break;
       case 91: /* "switchlist" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1490 "ael.tab.c"
-        break;
+#line 1701 "ael.tab.c"
+	break;
       case 92: /* "included_entry" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1498 "ael.tab.c"
-        break;
+#line 1709 "ael.tab.c"
+	break;
       case 93: /* "includeslist" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1506 "ael.tab.c"
-        break;
+#line 1717 "ael.tab.c"
+	break;
       case 94: /* "includes" */
 #line 158 "ael.y"
-        {
+	{
 		destroy_pval((yyvaluep->pval));
 		prev_word=0;
 	};
-#line 1514 "ael.tab.c"
-        break;
+#line 1725 "ael.tab.c"
+	break;
 
       default:
-        break;
+	break;
     }
 }
 
@@ -1527,13 +1738,13 @@
 /* Prevent warnings from -Wmissing-prototypes.  */
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (void *YYPARSE_PARAM);
-# else
+#else
 int yyparse ();
-# endif
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if defined __STDC__ || defined __cplusplus
 int yyparse (struct parse_io *parseio);
 #else
 int yyparse ();
@@ -1550,14 +1761,18 @@
 `----------*/
 
 #ifdef YYPARSE_PARAM
-# if defined (__STDC__) || defined (__cplusplus)
-int yyparse (void *YYPARSE_PARAM)
-# else
-int yyparse (YYPARSE_PARAM)
-  void *YYPARSE_PARAM;
-# endif
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
+int
+yyparse (void *YYPARSE_PARAM)
+#else
+int
+yyparse (YYPARSE_PARAM)
+    void *YYPARSE_PARAM;
+#endif
 #else /* ! YYPARSE_PARAM */
-#if defined (__STDC__) || defined (__cplusplus)
+#if (defined __STDC__ || defined __C99__FUNC__ \
+     || defined __cplusplus || defined _MSC_VER)
 int
 yyparse (struct parse_io *parseio)
 #else
@@ -1585,6 +1800,12 @@
   int yyerrstatus;
   /* Look-ahead token as an internal (translated) token number.  */
   int yytoken = 0;
+#if YYERROR_VERBOSE
+  /* Buffer for error messages, and its allocated size.  */
+  char yymsgbuf[128];
+  char *yymsg = yymsgbuf;
+  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
+#endif
 
   /* Three stacks and their tools:
      `yyss': related to states,
@@ -1595,9 +1816,9 @@
      to reallocate them elsewhere.  */
 
   /* The state stack.  */
-  short int yyssa[YYINITDEPTH];
-  short int *yyss = yyssa;
-  short int *yyssp;
+  yytype_int16 yyssa[YYINITDEPTH];
+  yytype_int16 *yyss = yyssa;
+  yytype_int16 *yyssp;
 
   /* The semantic value stack.  */
   YYSTYPE yyvsa[YYINITDEPTH];
@@ -1608,10 +1829,10 @@
   YYLTYPE yylsa[YYINITDEPTH];
   YYLTYPE *yyls = yylsa;
   YYLTYPE *yylsp;
-  /* The locations where the error started and ended. */
+  /* The locations where the error started and ended.  */
   YYLTYPE yyerror_range[2];
 
-#define YYPOPSTACK   (yyvsp--, yyssp--, yylsp--)
+#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N), yylsp -= (N))
 
   YYSIZE_T yystacksize = YYINITDEPTH;
 
@@ -1620,9 +1841,9 @@
   YYSTYPE yyval;
   YYLTYPE yyloc;
 
-  /* When reducing, the number of symbols on the RHS of the reduced
-     rule.  */
-  int yylen;
+  /* The number of symbols on the RHS of the reduced rule.
+     Keep to zero when no symbol should be popped.  */
+  int yylen = 0;
 
   YYDPRINTF ((stderr, "Starting parse\n"));
 
@@ -1652,8 +1873,7 @@
 `------------------------------------------------------------*/
  yynewstate:
   /* In all cases, when you get here, the value and location stacks
-     have just been pushed. so pushing a state here evens the stacks.
-     */
+     have just been pushed.  So pushing a state here evens the stacks.  */
   yyssp++;
 
  yysetstate:
@@ -1666,11 +1886,11 @@
 
 #ifdef yyoverflow
       {
-	/* Give user a chance to reallocate the stack. Use copies of
+	/* Give user a chance to reallocate the stack.  Use copies of
 	   these so that the &'s don't force the real ones into
 	   memory.  */
 	YYSTYPE *yyvs1 = yyvs;
-	short int *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	YYLTYPE *yyls1 = yyls;
 
 	/* Each stack pointer address is followed by the size of the
@@ -1698,7 +1918,7 @@
 	yystacksize = YYMAXDEPTH;
 
       {
-	short int *yyss1 = yyss;
+	yytype_int16 *yyss1 = yyss;
 	union yyalloc *yyptr =
 	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
 	if (! yyptr)
@@ -1733,12 +1953,10 @@
 `-----------*/
 yybackup:
 
-/* Do appropriate processing given the current state.  */
-/* Read a look-ahead token if we need one and don't already have one.  */
-/* yyresume: */
+  /* Do appropriate processing given the current state.  Read a
+     look-ahead token if we need one and don't already have one.  */
 
   /* First try to decide what to do without reference to look-ahead token.  */
-
   yyn = yypact[yystate];
   if (yyn == YYPACT_NINF)
     goto yydefault;
@@ -1780,22 +1998,21 @@
   if (yyn == YYFINAL)
     YYACCEPT;
 
+  /* Count tokens shifted since error; after three, turn off error
+     status.  */
+  if (yyerrstatus)
+    yyerrstatus--;
+
   /* Shift the look-ahead token.  */
   YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
 
-  /* Discard the token being shifted unless it is eof.  */
+  /* Discard the shifted token unless it is eof.  */
   if (yychar != YYEOF)
     yychar = YYEMPTY;
 
+  yystate = yyn;
   *++yyvsp = yylval;
   *++yylsp = yylloc;
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  yystate = yyn;
   goto yynewstate;
 
 
@@ -1826,44 +2043,44 @@
      GCC warning that YYVAL may be used uninitialized.  */
   yyval = yyvsp[1-yylen];
 
-  /* Default location. */
-  YYLLOC_DEFAULT (yyloc, yylsp - yylen, yylen);
+  /* Default location.  */
+  YYLLOC_DEFAULT (yyloc, (yylsp - yylen), yylen);
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
         case 2:
 #line 179 "ael.y"
-    { (yyval.pval) = parseio->pval = (yyvsp[0].pval); ;}
+    { (yyval.pval) = parseio->pval = (yyvsp[(1) - (1)].pval); ;}
     break;
 
   case 3:
 #line 182 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 4:
 #line 183 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-1].pval), (yyvsp[0].pval)); ;}
+    { (yyval.pval) = linku1((yyvsp[(1) - (2)].pval), (yyvsp[(2) - (2)].pval)); ;}
     break;
 
   case 5:
 #line 184 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 6:
 #line 187 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 7:
 #line 188 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 8:
 #line 189 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 9:
@@ -1873,7 +2090,7 @@
 
   case 10:
 #line 193 "ael.y"
-    { (yyval.str) = (yyvsp[0].str); ;}
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
     break;
 
   case 11:
@@ -1884,10 +2101,10 @@
   case 12:
 #line 197 "ael.y"
     {
-		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[-5]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->u3.abstract = (yyvsp[-5].intval); ;}
+		(yyval.pval) = npval2(PV_CONTEXT, &(yylsp[(1) - (6)]), &(yylsp[(6) - (6)]));
+		(yyval.pval)->u1.str = (yyvsp[(3) - (6)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(5) - (6)].pval);
+		(yyval.pval)->u3.abstract = (yyvsp[(1) - (6)].intval); ;}
     break;
 
   case 13:
@@ -1903,15 +2120,15 @@
   case 15:
 #line 209 "ael.y"
     {
-		(yyval.pval) = npval2(PV_MACRO, &(yylsp[-7]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-6].str); (yyval.pval)->u2.arglist = (yyvsp[-4].pval); (yyval.pval)->u3.macro_statements = (yyvsp[-1].pval); ;}
+		(yyval.pval) = npval2(PV_MACRO, &(yylsp[(1) - (8)]), &(yylsp[(8) - (8)]));
+		(yyval.pval)->u1.str = (yyvsp[(2) - (8)].str); (yyval.pval)->u2.arglist = (yyvsp[(4) - (8)].pval); (yyval.pval)->u3.macro_statements = (yyvsp[(7) - (8)].pval); ;}
     break;
 
   case 16:
 #line 214 "ael.y"
     {
-		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.statements = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_GLOBALS, &(yylsp[(1) - (4)]), &(yylsp[(4) - (4)]));
+		(yyval.pval)->u1.statements = (yyvsp[(3) - (4)].pval);;}
     break;
 
   case 17:
@@ -1921,12 +2138,12 @@
 
   case 18:
 #line 220 "ael.y"
-    {(yyval.pval) = linku1((yyvsp[-1].pval), (yyvsp[0].pval)); ;}
+    {(yyval.pval) = linku1((yyvsp[(1) - (2)].pval), (yyvsp[(2) - (2)].pval)); ;}
     break;
 
   case 19:
 #line 221 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 20:
@@ -1937,9 +2154,9 @@
   case 21:
 #line 224 "ael.y"
     {
-		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-4].str);
-		(yyval.pval)->u2.val = (yyvsp[-1].str); ;}
+		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[(1) - (5)]), &(yylsp[(5) - (5)]));
+		(yyval.pval)->u1.str = (yyvsp[(1) - (5)].str);
+		(yyval.pval)->u2.val = (yyvsp[(4) - (5)].str); ;}
     break;
 
   case 22:
@@ -1949,17 +2166,17 @@
 
   case 23:
 #line 232 "ael.y"
-    { (yyval.pval) = nword((yyvsp[0].str), &(yylsp[0])); ;}
+    { (yyval.pval) = nword((yyvsp[(1) - (1)].str), &(yylsp[(1) - (1)])); ;}
     break;
 
   case 24:
 #line 233 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-2].pval), nword((yyvsp[0].str), &(yylsp[0]))); ;}
+    { (yyval.pval) = linku1((yyvsp[(1) - (3)].pval), nword((yyvsp[(3) - (3)].str), &(yylsp[(3) - (3)]))); ;}
     break;
 
   case 25:
 #line 234 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 26:
@@ -1969,47 +2186,47 @@
 
   case 27:
 #line 238 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-1].pval), (yyvsp[0].pval)); ;}
+    { (yyval.pval) = linku1((yyvsp[(1) - (2)].pval), (yyvsp[(2) - (2)].pval)); ;}
     break;
 
   case 28:
 #line 239 "ael.y"
-    { (yyval.pval)=(yyvsp[-1].pval);;}
+    { (yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 29:
 #line 242 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 30:
 #line 243 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 31:
 #line 244 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 32:
 #line 245 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 33:
 #line 246 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 34:
 #line 247 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 35:
 #line 248 "ael.y"
-    {free((yyvsp[-1].str)); (yyval.pval)=0;;}
+    {free((yyvsp[(1) - (2)].str)); (yyval.pval)=0;;}
     break;
 
   case 36:
@@ -2020,44 +2237,44 @@
   case 37:
 #line 252 "ael.y"
     {
-		(yyval.pval) = npval2(PV_IGNOREPAT, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
+		(yyval.pval) = npval2(PV_IGNOREPAT, &(yylsp[(1) - (4)]), &(yylsp[(4) - (4)]));
+		(yyval.pval)->u1.str = (yyvsp[(3) - (4)].str);;}
     break;
 
   case 38:
 #line 257 "ael.y"
     {
-		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-2]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
+		(yyval.pval)->u1.str = (yyvsp[(1) - (3)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(3) - (3)].pval); ;}
     break;
 
   case 39:
 #line 261 "ael.y"
     {
-		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[(1) - (4)]), &(yylsp[(4) - (4)]));
+		(yyval.pval)->u1.str = (yyvsp[(2) - (4)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(4) - (4)].pval);
 		(yyval.pval)->u4.regexten=1;;}
     break;
 
   case 40:
 #line 266 "ael.y"
     {
-		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-6]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);
-		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[(1) - (7)]), &(yylsp[(7) - (7)]));
+		(yyval.pval)->u1.str = (yyvsp[(5) - (7)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(7) - (7)].pval);
+		(yyval.pval)->u3.hints = (yyvsp[(3) - (7)].str);;}
     break;
 
   case 41:
 #line 271 "ael.y"
     {
-		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[-7]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);
+		(yyval.pval) = npval2(PV_EXTENSION, &(yylsp[(1) - (8)]), &(yylsp[(8) - (8)]));
+		(yyval.pval)->u1.str = (yyvsp[(6) - (8)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(8) - (8)].pval);
 		(yyval.pval)->u4.regexten=1;
-		(yyval.pval)->u3.hints = (yyvsp[-4].str);;}
+		(yyval.pval)->u3.hints = (yyvsp[(4) - (8)].str);;}
     break;
 
   case 42:
@@ -2067,35 +2284,35 @@
 
   case 43:
 #line 282 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-1].pval), (yyvsp[0].pval)); ;}
+    { (yyval.pval) = linku1((yyvsp[(1) - (2)].pval), (yyvsp[(2) - (2)].pval)); ;}
     break;
 
   case 44:
 #line 283 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);;}
+    {(yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 45:
 #line 289 "ael.y"
     {
-		asprintf(&(yyval.str), "%s:%s:%s", (yyvsp[-4].str), (yyvsp[-2].str), (yyvsp[0].str));
-		free((yyvsp[-4].str));
-		free((yyvsp[-2].str));
-		free((yyvsp[0].str)); ;}
+		asprintf(&(yyval.str), "%s:%s:%s", (yyvsp[(1) - (5)].str), (yyvsp[(3) - (5)].str), (yyvsp[(5) - (5)].str));
+		free((yyvsp[(1) - (5)].str));
+		free((yyvsp[(3) - (5)].str));
+		free((yyvsp[(5) - (5)].str)); ;}
     break;
 
   case 46:
 #line 294 "ael.y"
-    { (yyval.str) = (yyvsp[0].str); ;}
+    { (yyval.str) = (yyvsp[(1) - (1)].str); ;}
     break;
 
   case 47:
 #line 298 "ael.y"
     {
-		(yyval.pval) = nword((yyvsp[-6].str), &(yylsp[-6]));
-		(yyval.pval)->next = nword((yyvsp[-4].str), &(yylsp[-4]));
-		(yyval.pval)->next->next = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword((yyvsp[(1) - (7)].str), &(yylsp[(1) - (7)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (7)].str), &(yylsp[(3) - (7)]));
+		(yyval.pval)->next->next = nword((yyvsp[(5) - (7)].str), &(yylsp[(5) - (7)]));
+		(yyval.pval)->next->next->next = nword((yyvsp[(7) - (7)].str), &(yylsp[(7) - (7)])); ;}
     break;
 
   case 48:
@@ -2105,129 +2322,129 @@
 
   case 49:
 #line 306 "ael.y"
-    { (yyval.str) = (yyvsp[-1].str); ;}
+    { (yyval.str) = (yyvsp[(3) - (4)].str); ;}
     break;
 
   case 50:
 #line 310 "ael.y"
     {
-		(yyval.pval)= npval2(PV_IF, &(yylsp[-1]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[0].str); ;}
+		(yyval.pval)= npval2(PV_IF, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)]));
+		(yyval.pval)->u1.str = (yyvsp[(2) - (2)].str); ;}
     break;
 
   case 51:
 #line 313 "ael.y"
     {
-		(yyval.pval) = npval2(PV_RANDOM, &(yylsp[-1]), &(yylsp[0]));
-		(yyval.pval)->u1.str=(yyvsp[0].str);;}
+		(yyval.pval) = npval2(PV_RANDOM, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)]));
+		(yyval.pval)->u1.str=(yyvsp[(2) - (2)].str);;}
     break;
 
   case 52:
 #line 316 "ael.y"
     {
-		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval);
+		(yyval.pval) = npval2(PV_IFTIME, &(yylsp[(1) - (4)]), &(yylsp[(4) - (4)]));
+		(yyval.pval)->u1.list = (yyvsp[(3) - (4)].pval);
 		prev_word = 0; ;}
     break;
 
   case 53:
 #line 327 "ael.y"
-    { (yyval.str) = (yyvsp[0].str);;}
+    { (yyval.str) = (yyvsp[(1) - (1)].str);;}
     break;
 
   case 54:
 #line 328 "ael.y"
     {
-		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
-		free((yyvsp[-1].str));
-		free((yyvsp[0].str));
+		asprintf(&((yyval.str)), "%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].str));
+		free((yyvsp[(1) - (2)].str));
+		free((yyvsp[(2) - (2)].str));
 		prev_word = (yyval.str);;}
     break;
 
   case 55:
 #line 335 "ael.y"
-    { (yyval.str) = (yyvsp[0].str);;}
+    { (yyval.str) = (yyvsp[(1) - (1)].str);;}
     break;
 
   case 56:
 #line 336 "ael.y"
     {
-		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
-		free((yyvsp[-1].str));
-		free((yyvsp[0].str));
+		asprintf(&((yyval.str)), "%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].str));
+		free((yyvsp[(1) - (2)].str));
+		free((yyvsp[(2) - (2)].str));
 		prev_word = (yyval.str);;}
     break;
 
   case 57:
 #line 341 "ael.y"
     {
-		asprintf(&((yyval.str)), "%s%s%s", (yyvsp[-2].str), (yyvsp[-1].str), (yyvsp[0].str));
-		free((yyvsp[-2].str));
-		free((yyvsp[-1].str));
-		free((yyvsp[0].str));
+		asprintf(&((yyval.str)), "%s%s%s", (yyvsp[(1) - (3)].str), (yyvsp[(2) - (3)].str), (yyvsp[(3) - (3)].str));
+		free((yyvsp[(1) - (3)].str));
+		free((yyvsp[(2) - (3)].str));
+		free((yyvsp[(3) - (3)].str));
 		prev_word=(yyval.str);;}
     break;
 
   case 58:
 #line 349 "ael.y"
-    { (yyval.str) = (yyvsp[0].str);;}
+    { (yyval.str) = (yyvsp[(1) - (1)].str);;}
     break;
 
   case 59:
 #line 350 "ael.y"
     {
-		asprintf(&((yyval.str)), "%s%s", (yyvsp[-1].str), (yyvsp[0].str));
-		free((yyvsp[-1].str));
-		free((yyvsp[0].str));;}
+		asprintf(&((yyval.str)), "%s%s", (yyvsp[(1) - (2)].str), (yyvsp[(2) - (2)].str));
+		free((yyvsp[(1) - (2)].str));
+		free((yyvsp[(2) - (2)].str));;}
     break;
 
   case 60:
 #line 354 "ael.y"
     {
-		asprintf(&((yyval.str)), "%s:%s", (yyvsp[-2].str), (yyvsp[0].str));
-		free((yyvsp[-2].str));
-		free((yyvsp[0].str));;}
+		asprintf(&((yyval.str)), "%s:%s", (yyvsp[(1) - (3)].str), (yyvsp[(3) - (3)].str));
+		free((yyvsp[(1) - (3)].str));
+		free((yyvsp[(3) - (3)].str));;}
     break;
 
   case 61:
 #line 360 "ael.y"
     {
-		(yyval.pval) = npval2(PV_SWITCH, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_SWITCH, &(yylsp[(1) - (5)]), &(yylsp[(5) - (5)]));
+		(yyval.pval)->u1.str = (yyvsp[(2) - (5)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(4) - (5)].pval);;}
     break;
 
   case 62:
 #line 369 "ael.y"
     {
-		(yyval.pval) = npval2(PV_STATEMENTBLOCK, &(yylsp[-2]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+		(yyval.pval) = npval2(PV_STATEMENTBLOCK, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
+		(yyval.pval)->u1.list = (yyvsp[(2) - (3)].pval); ;}
     break;
 
   case 63:
 #line 372 "ael.y"
-    { (yyval.pval) = (yyvsp[0].pval); ;}
+    { (yyval.pval) = (yyvsp[(1) - (1)].pval); ;}
     break;
 
   case 64:
 #line 373 "ael.y"
     {
-		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_GOTO, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
+		(yyval.pval)->u1.list = (yyvsp[(2) - (3)].pval);;}
     break;
 
   case 65:
 #line 376 "ael.y"
     {
-		(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_GOTO, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
+		(yyval.pval)->u1.list = (yyvsp[(2) - (3)].pval);;}
     break;
 
   case 66:
 #line 379 "ael.y"
     {
-		(yyval.pval) = npval2(PV_LABEL, &(yylsp[-1]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-1].str); ;}
+		(yyval.pval) = npval2(PV_LABEL, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)]));
+		(yyval.pval)->u1.str = (yyvsp[(1) - (2)].str); ;}
     break;
 
   case 67:
@@ -2248,41 +2465,41 @@
   case 70:
 #line 384 "ael.y"
     { /* XXX word_list maybe ? */
-		(yyval.pval) = npval2(PV_FOR, &(yylsp[-11]), &(yylsp[0]));
-		(yyval.pval)->u1.for_init = (yyvsp[-8].str);
-		(yyval.pval)->u2.for_test=(yyvsp[-5].str);
-		(yyval.pval)->u3.for_inc = (yyvsp[-2].str);
-		(yyval.pval)->u4.for_statements = (yyvsp[0].pval);;}
+		(yyval.pval) = npval2(PV_FOR, &(yylsp[(1) - (12)]), &(yylsp[(12) - (12)]));
+		(yyval.pval)->u1.for_init = (yyvsp[(4) - (12)].str);
+		(yyval.pval)->u2.for_test=(yyvsp[(7) - (12)].str);
+		(yyval.pval)->u3.for_inc = (yyvsp[(10) - (12)].str);
+		(yyval.pval)->u4.for_statements = (yyvsp[(12) - (12)].pval);;}
     break;
 
   case 71:
 #line 390 "ael.y"
     {
-		(yyval.pval) = npval2(PV_WHILE, &(yylsp[-2]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-1].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval); ;}
+		(yyval.pval) = npval2(PV_WHILE, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
+		(yyval.pval)->u1.str = (yyvsp[(2) - (3)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(3) - (3)].pval); ;}
     break;
 
   case 72:
 #line 394 "ael.y"
-    { (yyval.pval) = (yyvsp[0].pval); ;}
+    { (yyval.pval) = (yyvsp[(1) - (1)].pval); ;}
     break;
 
   case 73:
 #line 395 "ael.y"
-    { (yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[-1])); ;}
+    { (yyval.pval) = update_last((yyvsp[(2) - (3)].pval), &(yylsp[(2) - (3)])); ;}
     break;
 
   case 74:
 #line 396 "ael.y"
-    { (yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[0])); ;}
+    { (yyval.pval) = update_last((yyvsp[(1) - (2)].pval), &(yylsp[(2) - (2)])); ;}
     break;
 
   case 75:
 #line 397 "ael.y"
     {
-		(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[-1]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-1].str);;}
+		(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)]));
+		(yyval.pval)->u1.str = (yyvsp[(1) - (2)].str);;}
     break;
 
   case 76:
@@ -2296,58 +2513,58 @@
 		char *bufx;
 		int tot=0;
 		pval *pptr;
-		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u2.val=(yyvsp[-1].str);
+		(yyval.pval) = npval2(PV_VARDEC, &(yylsp[(1) - (5)]), &(yylsp[(5) - (5)]));
+		(yyval.pval)->u2.val=(yyvsp[(4) - (5)].str);
 		/* rebuild the original string-- this is not an app call, it's an unwrapped vardec, with a func call on the LHS */
 		/* string to big to fit in the buffer? */
-		tot+=strlen((yyvsp[-4].pval)->u1.str);
-		for(pptr=(yyvsp[-4].pval)->u2.arglist;pptr;pptr=pptr->next) {
+		tot+=strlen((yyvsp[(1) - (5)].pval)->u1.str);
+		for(pptr=(yyvsp[(1) - (5)].pval)->u2.arglist;pptr;pptr=pptr->next) {
 			tot+=strlen(pptr->u1.str);
 			tot++; /* for a sep like a comma */
 		}
 		tot+=4; /* for safety */
 		bufx = calloc(1, tot);
-		strcpy(bufx,(yyvsp[-4].pval)->u1.str);
+		strcpy(bufx,(yyvsp[(1) - (5)].pval)->u1.str);
 		strcat(bufx,"(");
 		/* XXX need to advance the pointer or the loop is very inefficient */
-		for (pptr=(yyvsp[-4].pval)->u2.arglist;pptr;pptr=pptr->next) {
-			if ( pptr != (yyvsp[-4].pval)->u2.arglist )
+		for (pptr=(yyvsp[(1) - (5)].pval)->u2.arglist;pptr;pptr=pptr->next) {
+			if ( pptr != (yyvsp[(1) - (5)].pval)->u2.arglist )
 				strcat(bufx,",");
 			strcat(bufx,pptr->u1.str);
 		}
 		strcat(bufx,")");
 #ifdef AAL_ARGCHECK
-		if ( !ael_is_funcname((yyvsp[-4].pval)->u1.str) )
+		if ( !ael_is_funcname((yyvsp[(1) - (5)].pval)->u1.str) )
 			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Function call? The name %s is not in my internal list of function names\n",
-				my_file, (yylsp[-4]).first_line, (yylsp[-4]).first_column, (yylsp[-4]).last_column, (yyvsp[-4].pval)->u1.str);
+				my_file, (yylsp[(1) - (5)]).first_line, (yylsp[(1) - (5)]).first_column, (yylsp[(1) - (5)]).last_column, (yyvsp[(1) - (5)].pval)->u1.str);
 #endif
 		(yyval.pval)->u1.str = bufx;
-		destroy_pval((yyvsp[-4].pval)); /* the app call it is not, get rid of that chain */
+		destroy_pval((yyvsp[(1) - (5)].pval)); /* the app call it is not, get rid of that chain */
 		prev_word = 0;
 	;}
     break;
 
   case 78:
 #line 433 "ael.y"
-    { (yyval.pval) = npval2(PV_BREAK, &(yylsp[-1]), &(yylsp[0])); ;}
+    { (yyval.pval) = npval2(PV_BREAK, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)])); ;}
     break;
 
   case 79:
 #line 434 "ael.y"
-    { (yyval.pval) = npval2(PV_RETURN, &(yylsp[-1]), &(yylsp[0])); ;}
+    { (yyval.pval) = npval2(PV_RETURN, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)])); ;}
     break;
 
   case 80:
 #line 435 "ael.y"
-    { (yyval.pval) = npval2(PV_CONTINUE, &(yylsp[-1]), &(yylsp[0])); ;}
+    { (yyval.pval) = npval2(PV_CONTINUE, &(yylsp[(1) - (2)]), &(yylsp[(2) - (2)])); ;}
     break;
 
   case 81:
 #line 436 "ael.y"
     {
-		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[-1]));
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);
-		(yyval.pval)->u3.else_statements = (yyvsp[0].pval);;}
+		(yyval.pval) = update_last((yyvsp[(1) - (3)].pval), &(yylsp[(2) - (3)]));
+		(yyval.pval)->u2.statements = (yyvsp[(2) - (3)].pval);
+		(yyval.pval)->u3.else_statements = (yyvsp[(3) - (3)].pval);;}
     break;
 
   case 82:
@@ -2357,7 +2574,7 @@
 
   case 83:
 #line 443 "ael.y"
-    { (yyval.pval) = (yyvsp[0].pval); ;}
+    { (yyval.pval) = (yyvsp[(2) - (2)].pval); ;}
     break;
 
   case 84:
@@ -2366,301 +2583,299 @@
     break;
 
   case 85:
-#line 449 "ael.y"
-    { (yyval.pval) = nword((yyvsp[0].str), &(yylsp[0])); ;}
+#line 447 "ael.y"
+    { (yyval.pval) = nword((yyvsp[(1) - (1)].str), &(yylsp[(1) - (1)])); ;}
     break;
 
   case 86:
-#line 450 "ael.y"
+#line 448 "ael.y"
     {
-		(yyval.pval) = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword((yyvsp[(1) - (3)].str), &(yylsp[(1) - (3)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (3)].str), &(yylsp[(3) - (3)])); ;}
     break;
 
   case 87:
-#line 453 "ael.y"
+#line 451 "ael.y"
     {
-		(yyval.pval) = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword((yyvsp[(1) - (3)].str), &(yylsp[(1) - (3)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (3)].str), &(yylsp[(3) - (3)])); ;}
     break;
 
   case 88:
-#line 456 "ael.y"
+#line 454 "ael.y"
     {
-		(yyval.pval) = nword((yyvsp[-4].str), &(yylsp[-4]));
-		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword((yyvsp[(1) - (5)].str), &(yylsp[(1) - (5)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (5)].str), &(yylsp[(3) - (5)]));
+		(yyval.pval)->next->next = nword((yyvsp[(5) - (5)].str), &(yylsp[(5) - (5)])); ;}
     break;
 
   case 89:
-#line 460 "ael.y"
+#line 458 "ael.y"
     {
-		(yyval.pval) = nword((yyvsp[-4].str), &(yylsp[-4]));
-		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword((yyvsp[(1) - (5)].str), &(yylsp[(1) - (5)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (5)].str), &(yylsp[(3) - (5)]));
+		(yyval.pval)->next->next = nword((yyvsp[(5) - (5)].str), &(yylsp[(5) - (5)])); ;}
     break;
 
   case 90:
-#line 464 "ael.y"
+#line 462 "ael.y"
     {
-		(yyval.pval) = nword(strdup("default"), &(yylsp[-4]));
-		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword(strdup("default"), &(yylsp[(1) - (5)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (5)].str), &(yylsp[(3) - (5)]));
+		(yyval.pval)->next->next = nword((yyvsp[(5) - (5)].str), &(yylsp[(5) - (5)])); ;}
     break;
 
   case 91:
-#line 468 "ael.y"
+#line 466 "ael.y"
     {
-		(yyval.pval) = nword(strdup("default"), &(yylsp[-4]));
-		(yyval.pval)->next = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->next->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword(strdup("default"), &(yylsp[(1) - (5)]));
+		(yyval.pval)->next = nword((yyvsp[(3) - (5)].str), &(yylsp[(3) - (5)]));
+		(yyval.pval)->next->next = nword((yyvsp[(5) - (5)].str), &(yylsp[(5) - (5)])); ;}
     break;
 
   case 92:
-#line 474 "ael.y"
+#line 472 "ael.y"
     { (yyval.str) = strdup("1"); ;}
     break;
 
   case 93:
-#line 475 "ael.y"
-    { (yyval.str) = (yyvsp[0].str); ;}
+#line 473 "ael.y"
+    { (yyval.str) = (yyvsp[(2) - (2)].str); ;}
     break;
 
   case 94:
-#line 479 "ael.y"
+#line 477 "ael.y"
     {			/* ext[, pri] default 1 */
-		(yyval.pval) = nword((yyvsp[-1].str), &(yylsp[-1]));
-		(yyval.pval)->next = nword((yyvsp[0].str), &(yylsp[0])); ;}
+		(yyval.pval) = nword((yyvsp[(1) - (2)].str), &(yylsp[(1) - (2)]));
+		(yyval.pval)->next = nword((yyvsp[(2) - (2)].str), &(yylsp[(2) - (2)])); ;}
     break;
 
   case 95:
-#line 482 "ael.y"
+#line 480 "ael.y"
     {	/* context, ext, pri */
-		(yyval.pval) = nword((yyvsp[0].str), &(yylsp[0]));
-		(yyval.pval)->next = nword((yyvsp[-3].str), &(yylsp[-3]));
-		(yyval.pval)->next->next = nword((yyvsp[-2].str), &(yylsp[-2])); ;}
+		(yyval.pval) = nword((yyvsp[(4) - (4)].str), &(yylsp[(4) - (4)]));
+		(yyval.pval)->next = nword((yyvsp[(1) - (4)].str), &(yylsp[(1) - (4)]));
+		(yyval.pval)->next->next = nword((yyvsp[(2) - (4)].str), &(yylsp[(2) - (4)])); ;}
     break;
 
   case 96:
-#line 488 "ael.y"
+#line 486 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
   case 97:
-#line 488 "ael.y"
+#line 486 "ael.y"
     {
 		/* XXX original code had @2 but i think we need @5 */
-		(yyval.pval) = npval2(PV_MACRO_CALL, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-4].str);
-		(yyval.pval)->u2.arglist = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_MACRO_CALL, &(yylsp[(1) - (5)]), &(yylsp[(5) - (5)]));
+		(yyval.pval)->u1.str = (yyvsp[(1) - (5)].str);
+		(yyval.pval)->u2.arglist = (yyvsp[(4) - (5)].pval);;}
     break;
 
   case 98:
-#line 493 "ael.y"
+#line 491 "ael.y"
     {
-		(yyval.pval)= npval2(PV_MACRO_CALL, &(yylsp[-2]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-2].str); ;}
+		(yyval.pval)= npval2(PV_MACRO_CALL, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
+		(yyval.pval)->u1.str = (yyvsp[(1) - (3)].str); ;}
     break;
 
   case 99:
-#line 501 "ael.y"
+#line 499 "ael.y"
     {reset_argcount(parseio->scanner);;}
     break;
 
   case 100:
-#line 501 "ael.y"
+#line 499 "ael.y"
     {
-		if (strcasecmp((yyvsp[-2].str),"goto") == 0) {
-			(yyval.pval) = npval2(PV_GOTO, &(yylsp[-2]), &(yylsp[-1]));
-			free((yyvsp[-2].str)); /* won't be using this */
-			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n", my_file, (yylsp[-2]).first_line, (yylsp[-2]).first_column, (yylsp[-2]).last_column );
+		if (strcasecmp((yyvsp[(1) - (3)].str),"goto") == 0) {
+			(yyval.pval) = npval2(PV_GOTO, &(yylsp[(1) - (3)]), &(yylsp[(2) - (3)]));
+			free((yyvsp[(1) - (3)].str)); /* won't be using this */
+			ast_log(LOG_WARNING, "==== File: %s, Line %d, Cols: %d-%d: Suggestion: Use the goto statement instead of the Goto() application call in AEL.\n", my_file, (yylsp[(1) - (3)]).first_line, (yylsp[(1) - (3)]).first_column, (yylsp[(1) - (3)]).last_column );
 		} else {
-			(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[-2]), &(yylsp[-1]));
-			(yyval.pval)->u1.str = (yyvsp[-2].str);
+			(yyval.pval)= npval2(PV_APPLICATION_CALL, &(yylsp[(1) - (3)]), &(yylsp[(2) - (3)]));
+			(yyval.pval)->u1.str = (yyvsp[(1) - (3)].str);
 		} ;}
     break;
 
   case 101:
-#line 512 "ael.y"
+#line 510 "ael.y"
     {
-		(yyval.pval) = update_last((yyvsp[-2].pval), &(yylsp[0]));
+		(yyval.pval) = update_last((yyvsp[(1) - (3)].pval), &(yylsp[(3) - (3)]));
  		if( (yyval.pval)->type == PV_GOTO )
-			(yyval.pval)->u1.list = (yyvsp[-1].pval);
+			(yyval.pval)->u1.list = (yyvsp[(2) - (3)].pval);
 	 	else
-			(yyval.pval)->u2.arglist = (yyvsp[-1].pval);
+			(yyval.pval)->u2.arglist = (yyvsp[(2) - (3)].pval);
 	;}
     break;
 
   case 102:
-#line 519 "ael.y"
-    { (yyval.pval) = update_last((yyvsp[-1].pval), &(yylsp[0])); ;}
+#line 517 "ael.y"
+    { (yyval.pval) = update_last((yyvsp[(1) - (2)].pval), &(yylsp[(2) - (2)])); ;}
     break;
 
   case 103:
-#line 522 "ael.y"
-    { (yyval.str) = (yyvsp[0].str) ;}
+#line 520 "ael.y"
+    { (yyval.str) = (yyvsp[(1) - (1)].str) ;}
     break;
 
   case 104:
-#line 523 "ael.y"
+#line 521 "ael.y"
     { (yyval.str) = strdup(""); ;}
     break;
 
   case 105:
-#line 526 "ael.y"
-    { (yyval.pval) = nword((yyvsp[0].str), &(yylsp[0])); ;}
+#line 524 "ael.y"
+    { (yyval.pval) = nword((yyvsp[(1) - (1)].str), &(yylsp[(1) - (1)])); ;}
     break;
 
   case 106:
-#line 527 "ael.y"
+#line 525 "ael.y"
     {
 		(yyval.pval)= npval(PV_WORD,0/*@1.first_line*/,0/*@1.last_line*/,0/* @1.first_column*/, 0/*@1.last_column*/);
 		(yyval.pval)->u1.str = strdup(""); ;}
     break;
 
   case 107:
-#line 530 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-2].pval), nword((yyvsp[0].str), &(yylsp[0]))); ;}
+#line 528 "ael.y"
+    { (yyval.pval) = linku1((yyvsp[(1) - (3)].pval), nword((yyvsp[(3) - (3)].str), &(yylsp[(3) - (3)]))); ;}
     break;
 
   case 108:
-#line 533 "ael.y"
+#line 531 "ael.y"
     { (yyval.pval) = NULL; ;}
     break;
 
   case 109:
-#line 534 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-1].pval), (yyvsp[0].pval)); ;}
+#line 532 "ael.y"
+    { (yyval.pval) = linku1((yyvsp[(1) - (2)].pval), (yyvsp[(2) - (2)].pval)); ;}
     break;
 
   case 110:
-#line 537 "ael.y"
+#line 535 "ael.y"
     {
-		(yyval.pval) = npval2(PV_CASE, &(yylsp[-3]), &(yylsp[-1])); /* XXX 3 or 4 ? */
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
+		(yyval.pval) = npval2(PV_CASE, &(yylsp[(1) - (4)]), &(yylsp[(3) - (4)])); /* XXX 3 or 4 ? */
+		(yyval.pval)->u1.str = (yyvsp[(2) - (4)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(4) - (4)].pval);;}
     break;
 
   case 111:
-#line 541 "ael.y"
+#line 539 "ael.y"
     {
-		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[-2]), &(yylsp[0]));
+		(yyval.pval) = npval2(PV_DEFAULT, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));
 		(yyval.pval)->u1.str = NULL;
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
+		(yyval.pval)->u2.statements = (yyvsp[(3) - (3)].pval);;}
     break;
 
   case 112:
-#line 545 "ael.y"
+#line 543 "ael.y"
     {
-		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[-3]), &(yylsp[0])); /* XXX at 3 or @4 ? */
-		(yyval.pval)->u1.str = (yyvsp[-2].str);
-		(yyval.pval)->u2.statements = (yyvsp[0].pval);;}
+		(yyval.pval) = npval2(PV_PATTERN, &(yylsp[(1) - (4)]), &(yylsp[(4) - (4)])); /* XXX at 3 or @4 ? */
+		(yyval.pval)->u1.str = (yyvsp[(2) - (4)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(4) - (4)].pval);;}
     break;
 
   case 113:
-#line 551 "ael.y"
+#line 549 "ael.y"
     { (yyval.pval) = NULL; ;}
     break;
 
   case 114:
-#line 552 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-1].pval), (yyvsp[0].pval)); ;}
+#line 550 "ael.y"
+    { (yyval.pval) = linku1((yyvsp[(1) - (2)].pval), (yyvsp[(2) - (2)].pval)); ;}
     break;
 
   case 115:
-#line 555 "ael.y"
-    {(yyval.pval)=(yyvsp[0].pval);;}
+#line 553 "ael.y"
+    {(yyval.pval)=(yyvsp[(1) - (1)].pval);;}
     break;
 
   case 116:
-#line 556 "ael.y"
+#line 554 "ael.y"
     {
-		(yyval.pval) = npval2(PV_CATCH, &(yylsp[-4]), &(yylsp[0]));
-		(yyval.pval)->u1.str = (yyvsp[-3].str);
-		(yyval.pval)->u2.statements = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_CATCH, &(yylsp[(1) - (5)]), &(yylsp[(5) - (5)]));
+		(yyval.pval)->u1.str = (yyvsp[(2) - (5)].str);
+		(yyval.pval)->u2.statements = (yyvsp[(4) - (5)].pval);;}
     break;
 
   case 117:
-#line 562 "ael.y"
+#line 560 "ael.y"
     {
-		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[-3]), &(yylsp[-2]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+		(yyval.pval) = npval2(PV_SWITCHES, &(yylsp[(1) - (4)]), &(yylsp[(2) - (4)]));
+		(yyval.pval)->u1.list = (yyvsp[(3) - (4)].pval); ;}
     break;
 
   case 118:
-#line 567 "ael.y"
+#line 565 "ael.y"
     {
-		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[-3]), &(yylsp[-2]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval); ;}
+		(yyval.pval) = npval2(PV_ESWITCHES, &(yylsp[(1) - (4)]), &(yylsp[(2) - (4)]));
+		(yyval.pval)->u1.list = (yyvsp[(3) - (4)].pval); ;}
     break;
 
   case 119:
-#line 572 "ael.y"
+#line 570 "ael.y"
     { (yyval.pval) = NULL; ;}
     break;
 
   case 120:
-#line 573 "ael.y"
-    { (yyval.pval) = linku1(nword((yyvsp[-2].str), &(yylsp[-2])), (yyvsp[0].pval)); ;}
+#line 571 "ael.y"
+    { (yyval.pval) = linku1(nword((yyvsp[(1) - (3)].str), &(yylsp[(1) - (3)])), (yyvsp[(3) - (3)].pval)); ;}
     break;
 
   case 121:
-#line 574 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);;}
+#line 572 "ael.y"
+    {(yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 122:
-#line 577 "ael.y"
-    { (yyval.pval) = nword((yyvsp[0].str), &(yylsp[0])); ;}
+#line 575 "ael.y"
+    { (yyval.pval) = nword((yyvsp[(1) - (1)].str), &(yylsp[(1) - (1)])); ;}
     break;
 
   case 123:
-#line 578 "ael.y"
+#line 576 "ael.y"
     {
-		(yyval.pval) = nword((yyvsp[-2].str), &(yylsp[-2]));
-		(yyval.pval)->u2.arglist = (yyvsp[0].pval);
+		(yyval.pval) = nword((yyvsp[(1) - (3)].str), &(yylsp[(1) - (3)]));
+		(yyval.pval)->u2.arglist = (yyvsp[(3) - (3)].pval);
 		prev_word=0; /* XXX sure ? */ ;}
     break;
 
   case 124:
-#line 585 "ael.y"
-    { (yyval.pval) = (yyvsp[-1].pval); ;}
+#line 583 "ael.y"
+    { (yyval.pval) = (yyvsp[(1) - (2)].pval); ;}
     break;
 
   case 125:
-#line 586 "ael.y"
-    { (yyval.pval) = linku1((yyvsp[-2].pval), (yyvsp[-1].pval)); ;}
+#line 584 "ael.y"
+    { (yyval.pval) = linku1((yyvsp[(1) - (3)].pval), (yyvsp[(2) - (3)].pval)); ;}
     break;
 
   case 126:
-#line 587 "ael.y"
-    {(yyval.pval)=(yyvsp[-1].pval);;}
+#line 585 "ael.y"
+    {(yyval.pval)=(yyvsp[(1) - (2)].pval);;}
     break;
 
   case 127:
-#line 590 "ael.y"
+#line 588 "ael.y"
     {
-		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-3]), &(yylsp[0]));
-		(yyval.pval)->u1.list = (yyvsp[-1].pval);;}
+		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[(1) - (4)]), &(yylsp[(4) - (4)]));
+		(yyval.pval)->u1.list = (yyvsp[(3) - (4)].pval);;}
     break;
 
   case 128:
-#line 593 "ael.y"
+#line 591 "ael.y"
     {
-		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[-2]), &(yylsp[0]));;}
+		(yyval.pval) = npval2(PV_INCLUDES, &(yylsp[(1) - (3)]), &(yylsp[(3) - (3)]));;}
     break;
 
 
+/* Line 1270 of yacc.c.  */
+#line 2868 "ael.tab.c"
       default: break;
     }
+  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
 
-/* Line 1126 of yacc.c.  */
-#line 2654 "ael.tab.c"
-
-  yyvsp -= yylen;
-  yyssp -= yylen;
-  yylsp -= yylen;
-
+  YYPOPSTACK (yylen);
+  yylen = 0;
   YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
@@ -2689,110 +2904,41 @@
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if YYERROR_VERBOSE
-      yyn = yypact[yystate];
-
-      if (YYPACT_NINF < yyn && yyn < YYLAST)
-	{
-	  int yytype = YYTRANSLATE (yychar);
-	  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytype]);
-	  YYSIZE_T yysize = yysize0;
-	  YYSIZE_T yysize1;
-	  int yysize_overflow = 0;
-	  char *yymsg = 0;
-#	  define YYERROR_VERBOSE_ARGS_MAXIMUM 5
-	  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-	  int yyx;
-
-#if 0
-	  /* This is so xgettext sees the translatable formats that are
-	     constructed on the fly.  */
-	  YY_("syntax error, unexpected %s");
-	  YY_("syntax error, unexpected %s, expecting %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s or %s");
-	  YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s");
-#endif
-	  char *yyfmt;
-	  char const *yyf;
-	  static char const yyunexpected[] = "syntax error, unexpected %s";
-	  static char const yyexpecting[] = ", expecting %s";
-	  static char const yyor[] = " or %s";
-	  char yyformat[sizeof yyunexpected
-			+ sizeof yyexpecting - 1
-			+ ((YYERROR_VERBOSE_ARGS_MAXIMUM - 2)
-			   * (sizeof yyor - 1))];
-	  char const *yyprefix = yyexpecting;
-
-	  /* Start YYX at -YYN if negative to avoid negative indexes in
-	     YYCHECK.  */
-	  int yyxbegin = yyn < 0 ? -yyn : 0;
-
-	  /* Stay within bounds of both yycheck and yytname.  */
-	  int yychecklim = YYLAST - yyn;
-	  int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-	  int yycount = 1;
-
-	  yyarg[0] = yytname[yytype];
-	  yyfmt = yystpcpy (yyformat, yyunexpected);
-
-	  for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-	    if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR)
+#if ! YYERROR_VERBOSE
+      yyerror (&yylloc, parseio, YY_("syntax error"));
+#else
+      {
+	YYSIZE_T yysize = yysyntax_error (0, yystate, yychar);
+	if (yymsg_alloc < yysize && yymsg_alloc < YYSTACK_ALLOC_MAXIMUM)
+	  {
+	    YYSIZE_T yyalloc = 2 * yysize;
+	    if (! (yysize <= yyalloc && yyalloc <= YYSTACK_ALLOC_MAXIMUM))
+	      yyalloc = YYSTACK_ALLOC_MAXIMUM;
+	    if (yymsg != yymsgbuf)
+	      YYSTACK_FREE (yymsg);
+	    yymsg = (char *) YYSTACK_ALLOC (yyalloc);
+	    if (yymsg)
+	      yymsg_alloc = yyalloc;
+	    else
 	      {
-		if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-		  {
-		    yycount = 1;
-		    yysize = yysize0;
-		    yyformat[sizeof yyunexpected - 1] = '\0';
-		    break;
-		  }
-		yyarg[yycount++] = yytname[yyx];
-		yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-		yysize_overflow |= yysize1 < yysize;
-		yysize = yysize1;
-		yyfmt = yystpcpy (yyfmt, yyprefix);
-		yyprefix = yyor;
+		yymsg = yymsgbuf;
+		yymsg_alloc = sizeof yymsgbuf;
 	      }
+	  }
 
-	  yyf = YY_(yyformat);
-	  yysize1 = yysize + yystrlen (yyf);
-	  yysize_overflow |= yysize1 < yysize;
-	  yysize = yysize1;
-
-	  if (!yysize_overflow && yysize <= YYSTACK_ALLOC_MAXIMUM)
-	    yymsg = (char *) YYSTACK_ALLOC (yysize);
-	  if (yymsg)
-	    {
-	      /* Avoid sprintf, as that infringes on the user's name space.
-		 Don't have undefined behavior even if the translation
-		 produced a string with the wrong number of "%s"s.  */
-	      char *yyp = yymsg;
-	      int yyi = 0;
-	      while ((*yyp = *yyf))
-		{
-		  if (*yyp == '%' && yyf[1] == 's' && yyi < yycount)
-		    {
-		      yyp += yytnamerr (yyp, yyarg[yyi++]);
-		      yyf += 2;
-		    }
-		  else
-		    {
-		      yyp++;
-		      yyf++;
-		    }
-		}
-	      yyerror (&yylloc, parseio, yymsg);
-	      YYSTACK_FREE (yymsg);
-	    }
-	  else
-	    {
-	      yyerror (&yylloc, parseio, YY_("syntax error"));
+	if (0 < yysize && yysize <= yymsg_alloc)
+	  {
+	    (void) yysyntax_error (yymsg, yystate, yychar);
+	    yyerror (&yylloc, parseio, yymsg);
+	  }
+	else
+	  {
+	    yyerror (&yylloc, parseio, YY_("syntax error"));
+	    if (yysize != 0)
 	      goto yyexhaustedlab;
-	    }
-	}
-      else
-#endif /* YYERROR_VERBOSE */
-	yyerror (&yylloc, parseio, YY_("syntax error"));
+	  }
+      }
+#endif
     }
 
   yyerror_range[0] = yylloc;
@@ -2803,14 +2949,15 @@
 	 error, discard it.  */
 
       if (yychar <= YYEOF)
-        {
+	{
 	  /* Return failure if at end of input.  */
 	  if (yychar == YYEOF)
 	    YYABORT;
-        }
+	}
       else
 	{
-	  yydestruct ("Error: discarding", yytoken, &yylval, &yylloc);
+	  yydestruct ("Error: discarding",
+		      yytoken, &yylval, &yylloc, parseio);
 	  yychar = YYEMPTY;
 	}
     }
@@ -2828,13 +2975,15 @@
   /* Pacify compilers like GCC when the user code never invokes
      YYERROR and the label yyerrorlab therefore never appears in user
      code.  */
-  if (0)
+  if (/*CONSTCOND*/ 0)
      goto yyerrorlab;
 
   yyerror_range[0] = yylsp[1-yylen];
-  yylsp -= yylen;
-  yyvsp -= yylen;
-  yyssp -= yylen;
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYERROR.  */
+  YYPOPSTACK (yylen);
+  yylen = 0;
+  YY_STACK_PRINT (yyss, yyssp);
   yystate = *yyssp;
   goto yyerrlab1;
 
@@ -2864,8 +3013,9 @@
 	YYABORT;
 
       yyerror_range[0] = *yylsp;
-      yydestruct ("Error: popping", yystos[yystate], yyvsp, yylsp);
-      YYPOPSTACK;
+      yydestruct ("Error: popping",
+		  yystos[yystate], yyvsp, yylsp, parseio);
+      YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
     }
@@ -2877,11 +3027,11 @@
 
   yyerror_range[1] = yylloc;
   /* Using YYLLOC is tempting, but would change the location of
-     the look-ahead.  YYLOC is available though. */
-  YYLLOC_DEFAULT (yyloc, yyerror_range - 1, 2);
+     the look-ahead.  YYLOC is available though.  */
+  YYLLOC_DEFAULT (yyloc, (yyerror_range - 1), 2);
   *++yylsp = yyloc;
 
-  /* Shift the error token. */
+  /* Shift the error token.  */
   YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
 
   yystate = yyn;
@@ -2915,22 +3065,30 @@
 yyreturn:
   if (yychar != YYEOF && yychar != YYEMPTY)
      yydestruct ("Cleanup: discarding lookahead",
-		 yytoken, &yylval, &yylloc);
+		 yytoken, &yylval, &yylloc, parseio);
+  /* Do not reclaim the symbols of the rule which action triggered
+     this YYABORT or YYACCEPT.  */
+  YYPOPSTACK (yylen);
+  YY_STACK_PRINT (yyss, yyssp);
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp, yylsp);
-      YYPOPSTACK;
+		  yystos[*yyssp], yyvsp, yylsp, parseio);
+      YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
+#if YYERROR_VERBOSE
+  if (yymsg != yymsgbuf)
+    YYSTACK_FREE (yymsg);
+#endif
   return yyresult;
 }
 
 
-#line 598 "ael.y"
+#line 596 "ael.y"
 
 
 static char *token_equivs1[] =

Modified: trunk/pbx/ael/ael.tab.h
===================================================================
--- trunk/pbx/ael/ael.tab.h	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael.tab.h	2006-06-28 01:40:14 UTC (rev 377)
@@ -1,7 +1,7 @@
-/* A Bison parser, made by GNU Bison 2.1.  */
+/* A Bison parser, made by GNU Bison 2.1a.  */
 
 /* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation, Inc.
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
 
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
@@ -114,15 +114,17 @@
 
 
 
-#if ! defined (YYSTYPE) && ! defined (YYSTYPE_IS_DECLARED)
+#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
+typedef union YYSTYPE
 #line 48 "ael.y"
-typedef union YYSTYPE {
+{
 	int	intval;		/* integer value, typically flags */
 	char	*str;		/* strings */
 	struct pval *pval;	/* full objects */
-} YYSTYPE;
-/* Line 1447 of yacc.c.  */
-#line 126 "ael.tab.h"
+}
+/* Line 1536 of yacc.c.  */
+#line 127 "ael.tab.h"
+	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
 # define YYSTYPE_IS_TRIVIAL 1
@@ -130,7 +132,7 @@
 
 
 
-#if ! defined (YYLTYPE) && ! defined (YYLTYPE_IS_DECLARED)
+#if ! defined YYLTYPE && ! defined YYLTYPE_IS_DECLARED
 typedef struct YYLTYPE
 {
   int first_line;

Modified: trunk/pbx/ael/ael.y
===================================================================
--- trunk/pbx/ael/ael.y	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael.y	2006-06-28 01:40:14 UTC (rev 377)
@@ -153,7 +153,7 @@
 
 /* there will be two shift/reduce conflicts, they involve the if statement, where a single statement occurs not wrapped in curlies in the "true" section
    the default action to shift will attach the else to the preceeding if. */
-%expect 5
+%expect 7
 %error-verbose
 
 /*
@@ -449,8 +449,6 @@
 opt_else : KW_ELSE statement { $$ = $2; }
 	| { $$ = NULL ; }
 
-/* XXX unused */
-bar_or_comma: BAR | COMMA ;
 
 target : goto_word { $$ = nword($1, &@1); }
 	| goto_word BAR goto_word {

Modified: trunk/pbx/ael/ael_lex.c
===================================================================
--- trunk/pbx/ael/ael_lex.c	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/ael/ael_lex.c	2006-06-28 01:40:14 UTC (rev 377)
@@ -9,7 +9,7 @@
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
 #define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 33
+#define YY_FLEX_SUBMINOR_VERSION 31
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
@@ -32,15 +32,7 @@
 
 /* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
 
-#if __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
+#if defined __STDC_VERSION__ && __STDC_VERSION__ >= 199901L
 #include <inttypes.h>
 typedef int8_t flex_int8_t;
 typedef uint8_t flex_uint8_t;
@@ -163,10 +155,6 @@
 #define YY_BUF_SIZE 16384
 #endif
 
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
 #ifndef YY_TYPEDEF_YY_BUFFER_STATE
 #define YY_TYPEDEF_YY_BUFFER_STATE
 typedef struct yy_buffer_state *YY_BUFFER_STATE;
@@ -785,13 +773,11 @@
 #define semic 2
 #define argg 3
 
-#ifndef YY_NO_UNISTD_H
 /* Special case for "unistd.h", since it is non-ANSI. We include it way
  * down here because we want the user's section 1 to have been scanned first.
  * The user has a chance to override it with an option.
  */
 #include <unistd.h>
-#endif
 
 #ifndef YY_EXTRA_TYPE
 #define YY_EXTRA_TYPE void *
@@ -835,8 +821,6 @@
 
     }; /* end struct yyguts_t */
 
-static int yy_init_globals (yyscan_t yyscanner );
-
     /* This must go here because YYSTYPE and YYLTYPE are included
      * from bison output in section 1.*/
     #    define yylval yyg->yylval_r
@@ -987,11 +971,9 @@
 #ifndef YY_DECL
 #define YY_DECL_IS_OURS 1
 
-extern int ael_yylex \
-               (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
+extern int ael_yylex (YYSTYPE * yylval_param,YYLTYPE * yylloc_param ,yyscan_t yyscanner);
 
-#define YY_DECL int ael_yylex \
-               (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
+#define YY_DECL int ael_yylex (YYSTYPE * yylval_param, YYLTYPE * yylloc_param , yyscan_t yyscanner)
 #endif /* !YY_DECL */
 
 /* Code executed at the beginning of each rule, after yytext and yyleng
@@ -1027,9 +1009,9 @@
 
     yylloc = yylloc_param;
 
-	if ( !yyg->yy_init )
+	if ( yyg->yy_init )
 		{
-		yyg->yy_init = 1;
+		yyg->yy_init = 0;
 
 #ifdef YY_USER_INIT
 		YY_USER_INIT;
@@ -1795,7 +1777,7 @@
 
 	else
 		{
-			int num_to_read =
+			size_t num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
@@ -1911,7 +1893,7 @@
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
 {
 	register int yy_is_jam;
-    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	register char *yy_cp = yyg->yy_c_buf_p;
 
 	register YY_CHAR yy_c = 1;
@@ -2354,16 +2336,16 @@
 
 /** Setup the input buffer state to scan a string. The next call to ael_yylex() will
  * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
+ * @param str a NUL-terminated string to scan
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  * @note If you want to scan bytes that may contain NUL values, then use
  *       ael_yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE ael_yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
+YY_BUFFER_STATE ael_yy_scan_string (yyconst char * str , yyscan_t yyscanner)
 {
     
-	return ael_yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
+	return ael_yy_scan_bytes(str,strlen(str) ,yyscanner);
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to ael_yylex() will
@@ -2373,7 +2355,7 @@
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE ael_yy_scan_bytes  (yyconst char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
+YY_BUFFER_STATE ael_yy_scan_bytes  (yyconst char * bytes, int  len , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
 	char *buf;
@@ -2381,15 +2363,15 @@
 	int i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
+	n = len + 2;
 	buf = (char *) ael_yyalloc(n ,yyscanner );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in ael_yy_scan_bytes()" );
 
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
+	for ( i = 0; i < len; ++i )
+		buf[i] = bytes[i];
 
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
+	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;
 
 	b = ael_yy_scan_buffer(buf,n ,yyscanner);
 	if ( ! b )
@@ -2600,51 +2582,21 @@
     yylloc = yylloc_param;
 }
     
-/* User-visible API */
-
-/* ael_yylex_init is special because it creates the scanner itself, so it is
- * the ONLY reentrant function that doesn't take the scanner as the last argument.
- * That's why we explicitly handle the declaration, instead of using our macros.
- */
-
-int ael_yylex_init(yyscan_t* ptr_yy_globals)
-
-{
-    if (ptr_yy_globals == NULL){
-        errno = EINVAL;
-        return 1;
-    }
-
-    *ptr_yy_globals = (yyscan_t) ael_yyalloc ( sizeof( struct yyguts_t ), NULL );
-
-    if (*ptr_yy_globals == NULL){
-        errno = ENOMEM;
-        return 1;
-    }
-
-    /* By setting to 0xAA, we expose bugs in yy_init_globals. Leave at 0x00 for releases. */
-    memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-
-    return yy_init_globals ( *ptr_yy_globals );
-}
-
 static int yy_init_globals (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
     /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from ael_yylex_destroy(), so don't allocate here.
-     */
+       This function is called once per scanner lifetime. */
 
     yyg->yy_buffer_stack = 0;
     yyg->yy_buffer_stack_top = 0;
     yyg->yy_buffer_stack_max = 0;
     yyg->yy_c_buf_p = (char *) 0;
-    yyg->yy_init = 0;
+    yyg->yy_init = 1;
     yyg->yy_start = 0;
-
     yyg->yy_start_stack_ptr = 0;
     yyg->yy_start_stack_depth = 0;
-    yyg->yy_start_stack =  NULL;
+    yyg->yy_start_stack = (int *) 0;
 
 /* Defined in main.c */
 #ifdef YY_STDINIT
@@ -2661,6 +2613,33 @@
     return 0;
 }
 
+/* User-visible API */
+
+/* ael_yylex_init is special because it creates the scanner itself, so it is
+ * the ONLY reentrant function that doesn't take the scanner as the last argument.
+ * That's why we explicitly handle the declaration, instead of using our macros.
+ */
+
+int ael_yylex_init(yyscan_t* ptr_yy_globals)
+
+{
+    if (ptr_yy_globals == NULL){
+        errno = EINVAL;
+        return 1;
+    }
+
+    *ptr_yy_globals = (yyscan_t) ael_yyalloc ( sizeof( struct yyguts_t ), NULL );
+
+    if (*ptr_yy_globals == NULL){
+        errno = ENOMEM;
+        return 1;
+    }
+
+    memset(*ptr_yy_globals,0,sizeof(struct yyguts_t));
+
+    return yy_init_globals ( *ptr_yy_globals );
+}
+
 /* ael_yylex_destroy is for both reentrant and non-reentrant scanners. */
 int ael_yylex_destroy  (yyscan_t yyscanner)
 {
@@ -2681,13 +2660,8 @@
         ael_yyfree(yyg->yy_start_stack ,yyscanner );
         yyg->yy_start_stack = NULL;
 
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * ael_yylex() is called, initialization will occur. */
-    yy_init_globals( yyscanner);
-
     /* Destroy the main struct (reentrant only). */
     ael_yyfree ( yyscanner , yyscanner );
-    yyscanner = NULL;
     return 0;
 }
 
@@ -2699,6 +2673,7 @@
 static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
 {
 	register int i;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
@@ -2708,6 +2683,7 @@
 static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
 {
 	register int n;
+    struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -2739,10 +2715,22 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 453 "ael.flex"
+#undef YY_NEW_FILE
+#undef YY_FLUSH_BUFFER
+#undef yy_set_bol
+#undef yy_new_buffer
+#undef yy_set_interactive
+#undef yytext_ptr
+#undef YY_DO_BEFORE_ACTION
 
+#ifdef YY_DECL_IS_OURS
+#undef YY_DECL_IS_OURS
+#undef YY_DECL
+#endif
+#line 450 "ael.flex"
 
 
+
 static void pbcpush(char x)
 {
 	pbcstack[pbcpos++] = x;

Modified: trunk/pbx/pbx_ael.c
===================================================================
--- trunk/pbx/pbx_ael.c	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/pbx/pbx_ael.c	2006-06-28 01:40:14 UTC (rev 377)
@@ -2491,6 +2491,10 @@
 		if (ne->name)
 			free(ne->name);
 		
+		/* cidmatch fields are allocated with name, and freed when
+		   the name field is freed. Don't do a free for this field,
+		   unless you LIKE to see a crash! */
+
 		if (ne->hints)
 			free(ne->hints);
 		
@@ -2540,6 +2544,7 @@
 	char *strp, *strp2;
 	char new_label[2000];
 	int default_exists;
+	int local_control_statement_count;
 	struct ael_priority *loop_break_save;
 	struct ael_priority *loop_continue_save;
 	struct ael_extension *switch_case;
@@ -2699,6 +2704,7 @@
 
 		case PV_SWITCH:
 			control_statement_count++;
+			local_control_statement_count = control_statement_count;
 			loop_break_save = exten->loop_break; /* save them, then restore before leaving */
 			loop_continue_save = exten->loop_continue;
 			snprintf(new_label,sizeof(new_label),"sw-%s-%d", label, control_statement_count);
@@ -2733,9 +2739,9 @@
 					switch_case->loop_continue = exten->loop_continue;
 					
 					linkexten(exten,switch_case);
-					snprintf(buf1,sizeof(buf1),"sw-%d-%s", control_statement_count, p2->u1.str);
+					snprintf(buf1,sizeof(buf1),"sw-%d-%s", local_control_statement_count, p2->u1.str);
 					switch_case->name = strdup(buf1);
-					snprintf(new_label,sizeof(new_label),"sw-%s-%s-%d", label, p2->u1.str, control_statement_count);
+					snprintf(new_label,sizeof(new_label),"sw-%s-%s-%d", label, p2->u1.str, local_control_statement_count);
 					
 					gen_prios(switch_case, new_label, p2->u2.statements, exten); /* this will link in all the case body statements here */
 
@@ -2751,21 +2757,21 @@
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"sw-%d-%s|1",control_statement_count, p2->next->u1.str);
+							snprintf(buf1,sizeof(buf1),"sw-%d-%s|1",local_control_statement_count, p2->next->u1.str);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (p2->next && p2->next->type == PV_PATTERN) {
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"_sw-%d-%s|1",control_statement_count, p2->next->u1.str);
+							snprintf(buf1,sizeof(buf1),"_sw-%d-%s|1",local_control_statement_count, p2->next->u1.str);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (p2->next && p2->next->type == PV_DEFAULT) {
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"_sw-%d-.|1",control_statement_count);
+							snprintf(buf1,sizeof(buf1),"_sw-%d-.|1",local_control_statement_count);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (!p2->next) {
@@ -2794,9 +2800,9 @@
 					switch_case->loop_continue = exten->loop_continue;
 					
 					linkexten(exten,switch_case);
-					snprintf(buf1,sizeof(buf1),"_sw-%d-%s", control_statement_count, p2->u1.str);
+					snprintf(buf1,sizeof(buf1),"_sw-%d-%s", local_control_statement_count, p2->u1.str);
 					switch_case->name = strdup(buf1);
-					snprintf(new_label,sizeof(new_label),"sw-%s-%s-%d", label, p2->u1.str, control_statement_count);
+					snprintf(new_label,sizeof(new_label),"sw-%s-%s-%d", label, p2->u1.str, local_control_statement_count);
 					
 					gen_prios(switch_case, new_label, p2->u2.statements, exten); /* this will link in all the while body statements here */
 					/* here is where we write code to "fall thru" to the next case... if there is one... */
@@ -2811,21 +2817,21 @@
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"sw-%d-%s|1",control_statement_count, p2->next->u1.str);
+							snprintf(buf1,sizeof(buf1),"sw-%d-%s|1",local_control_statement_count, p2->next->u1.str);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (p2->next && p2->next->type == PV_PATTERN) {
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"_sw-%d-%s|1",control_statement_count, p2->next->u1.str);
+							snprintf(buf1,sizeof(buf1),"_sw-%d-%s|1",local_control_statement_count, p2->next->u1.str);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (p2->next && p2->next->type == PV_DEFAULT) {
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"_sw-%d-.|1",control_statement_count);
+							snprintf(buf1,sizeof(buf1),"_sw-%d-.|1",local_control_statement_count);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (!p2->next) {
@@ -2854,10 +2860,10 @@
 					switch_case->loop_break = exten->loop_break;
 					switch_case->loop_continue = exten->loop_continue;
 					linkexten(exten,switch_case);
-					snprintf(buf1,sizeof(buf1),"_sw-%d-.", control_statement_count);
+					snprintf(buf1,sizeof(buf1),"_sw-%d-.", local_control_statement_count);
 					switch_case->name = strdup(buf1);
 					
-					snprintf(new_label,sizeof(new_label),"sw-%s-default-%d", label, control_statement_count);
+					snprintf(new_label,sizeof(new_label),"sw-%s-default-%d", label, local_control_statement_count);
 					
 					gen_prios(switch_case, new_label, p2->u2.statements, exten); /* this will link in all the while body statements here */
 					
@@ -2873,21 +2879,21 @@
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"sw-%d-%s|1",control_statement_count, p2->next->u1.str);
+							snprintf(buf1,sizeof(buf1),"sw-%d-%s|1",local_control_statement_count, p2->next->u1.str);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (p2->next && p2->next->type == PV_PATTERN) {
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"_sw-%d-%s|1",control_statement_count, p2->next->u1.str);
+							snprintf(buf1,sizeof(buf1),"_sw-%d-%s|1",local_control_statement_count, p2->next->u1.str);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (p2->next && p2->next->type == PV_DEFAULT) {
 							fall_thru = new_prio();
 							fall_thru->type = AEL_APPCALL;
 							fall_thru->app = strdup("Goto");
-							snprintf(buf1,sizeof(buf1),"_sw-%d-.|1",control_statement_count);
+							snprintf(buf1,sizeof(buf1),"_sw-%d-.|1",local_control_statement_count);
 							fall_thru->appargs = strdup(buf1);
 							linkprio(switch_case, fall_thru);
 						} else if (!p2->next) {
@@ -3184,7 +3190,7 @@
 		struct ael_priority *last = 0;
 		
 		if (exten->hints) {
-			if (ast_add_extension2(context, 0 /*no replace*/, exten->name, PRIORITY_HINT, NULL, NULL, 
+			if (ast_add_extension2(context, 0 /*no replace*/, exten->name, PRIORITY_HINT, NULL, exten->cidmatch, 
 								  exten->hints, NULL, FREE, registrar)) {
 				ast_log(LOG_WARNING, "Unable to add step at priority 'hint' of extension '%s'\n",
 						exten->name);
@@ -3266,7 +3272,7 @@
 				label = 0;
 			
 			
-			if (ast_add_extension2(context, 0 /*no replace*/, exten->name, pr->priority_num, (label?label:NULL), NULL, 
+			if (ast_add_extension2(context, 0 /*no replace*/, exten->name, pr->priority_num, (label?label:NULL), exten->cidmatch, 
 								  app, strdup(appargs), FREE, registrar)) {
 				ast_log(LOG_WARNING, "Unable to add step at priority '%d' of extension '%s'\n", pr->priority_num, 
 						exten->name);
@@ -3340,11 +3346,18 @@
 			/* contexts contain: ignorepat, includes, switches, eswitches, extensions,  */
 			for (p2=p->u2.statements; p2; p2=p2->next) {
 				pval *p3;
+				char *s3;
 				
 				switch (p2->type) {
 				case PV_EXTENSION:
 					exten = new_exten();
 					exten->name = strdup(p2->u1.str);
+					if( (s3=strchr(exten->name, '/') ) != 0 )
+					{
+						*s3 = 0;
+						exten->cidmatch = s3+1;
+					}
+					
 					if ( p2->u3.hints )
 						exten->hints = strdup(p2->u3.hints);
 					exten->regexten = p2->u4.regexten;

Modified: trunk/res/res_jabber.c
===================================================================
--- trunk/res/res_jabber.c	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/res/res_jabber.c	2006-06-28 01:40:14 UTC (rev 377)
@@ -1031,22 +1031,24 @@
 {
 	struct aji_message *insert, *tmp;
 	int flag = 0;
-	insert = ast_calloc(1,sizeof(struct aji_message));
+
+	if (!(insert = ast_calloc(1, sizeof(struct aji_message))))
+		return;
 	time(&insert->arrived);
 	insert->message = ast_strdup(iks_find_cdata(pak->x, "body"));
 	ast_copy_string(insert->id, pak->id, sizeof(insert->message));
 	insert->from = ast_strdup(pak->from->full);
 	AST_LIST_LOCK(&client->messages);
 	AST_LIST_TRAVERSE_SAFE_BEGIN(&client->messages, tmp, list) {
-		if(flag) {
-			AST_LIST_REMOVE_CURRENT(&client->messages,list);
+		if (flag) {
+			AST_LIST_REMOVE_CURRENT(&client->messages, list);
 			if (tmp->from)
 				free(tmp->from);
 			if (tmp->message)
 				free(tmp->message);
 		} else if (difftime(time(NULL), tmp->arrived) >= client->message_timeout) {
 			flag = 1;
-			AST_LIST_REMOVE_CURRENT(&client->messages,list);
+			AST_LIST_REMOVE_CURRENT(&client->messages, list);
 			if (tmp->from)
 				free(tmp->from);
 			if (tmp->message)
@@ -1054,9 +1056,10 @@
 		}
 	}
 	AST_LIST_TRAVERSE_SAFE_END;
-	AST_LIST_INSERT_HEAD(&client->messages,insert,list);
+	AST_LIST_INSERT_HEAD(&client->messages, insert, list);
 	AST_LIST_UNLOCK(&client->messages);
 }
+
 static void aji_handle_presence(struct aji_client *client, ikspak *pak)
 {
 	int status, priority;

Modified: trunk/say.c
===================================================================
--- trunk/say.c	2006-06-28 01:39:28 UTC (rev 376)
+++ trunk/say.c	2006-06-28 01:40:14 UTC (rev 377)
@@ -4702,7 +4702,11 @@
 			case 'e':
 				/* First - Thirtyfirst */
 				remainder = tm.tm_mday;
-				if (tm.tm_mday > 20) {
+				if (tm.tm_mday > 30) {
+					res = wait_file(chan, ints, "digits/h-30", lang);
+					remainder -= 30;
+				}
+				if (tm.tm_mday > 20 && tm.tm_mday < 30) {
 					res = wait_file(chan, ints, "digits/h-20", lang);
 					remainder -= 20;
 				}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:41:25 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:41:25 +0200
Subject: [solid-pbx-svn] r378 - in trunk: channels configs
Message-ID: <200606280141.k5S1fPZO017495@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:41:21 +0200 (Wed, 28 Jun 2006)
New Revision: 378

Modified:
   trunk/channels/chan_skinny.c
   trunk/configs/skinny.conf.sample
Log:
Update to Asterisk SVN trunk r34703

------------------------------------------------------------------------
r34696 | north | 2006-06-19 00:36:39 +0200 (Mon, 19 Jun 2006) | 4 lines

Finally merge chan_skinny fixes into trunk.

ready...set...GO!

------------------------------------------------------------------------


Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-28 01:40:14 UTC (rev 377)
+++ trunk/channels/chan_skinny.c	2006-06-28 01:41:21 UTC (rev 378)
@@ -4,6 +4,7 @@
  * Copyright (C) 1999 - 2005, Digium, Inc.
  *
  * chan_skinny was developed by Jeremy McNamara & Florian Overkamp
+ * chan_skinny was heavily modified/fixed by North Antara
  *
  * See http://www.asterisk.org for more information about
  * the Asterisk project. Please do not directly contact
@@ -20,7 +21,7 @@
  *
  * \brief Implementation of the Skinny protocol
  *
- * \author Jeremy McNamara & Florian Overkamp
+ * \author Jeremy McNamara & Florian Overkamp & North Antara
  * \ingroup channel_drivers
  */
 
@@ -73,6 +74,7 @@
 #include "asterisk/utils.h"
 #include "asterisk/dsp.h"
 #include "asterisk/stringfields.h"
+#include "asterisk/astobj.h"
 #include "asterisk/abstract_jb.h"
 
 /*************************************
@@ -92,11 +94,6 @@
 static char date_format[6] = "D-M-Y";
 static char version_id[16] = "P002F202";
 
-/* these should be in an include file, but dunno what to include */
-typedef unsigned char	UINT8;
-typedef unsigned short	UINT16;
-typedef unsigned int	UINT32;
-
 #if __BYTE_ORDER == __LITTLE_ENDIAN
 #define letohl(x) (x)
 #define letohs(x) (x)
@@ -141,127 +138,164 @@
 #define REGISTER_MESSAGE 0x0001
 typedef struct register_message {
 	char name[16];
-	int userId;
-	int instance;
-	char ip[4];
-	int type;
-	int maxStreams;
+	uint32_t userId;
+	uint32_t instance;
+	uint32_t ip;
+	uint32_t type;
+	uint32_t maxStreams;
 } register_message;
 
 #define IP_PORT_MESSAGE	0x0002
 
 #define KEYPAD_BUTTON_MESSAGE 0x0003
 typedef struct keypad_button_message {
-	int button;
+	uint32_t button;
+	uint32_t lineInstance;
+	uint32_t callReference;
 } keypad_button_message;
 
 #define STIMULUS_MESSAGE 0x0005
 typedef struct stimulus_message {
-	int stimulus;
-	int stimulusInstance;
+	uint32_t stimulus;
+	uint32_t stimulusInstance;
+	uint32_t unknown1;
 } stimulus_message;
 
 #define OFFHOOK_MESSAGE 0x0006
+typedef struct offhook_message {
+	uint32_t unknown1;
+	uint32_t unknown2;
+} offhook_message;
+
 #define ONHOOK_MESSAGE 0x0007
+typedef struct onhook_message {
+	uint32_t unknown1;
+	uint32_t unknown2;
+} onhook_message;
 
 #define CAPABILITIES_RES_MESSAGE 0x0010
 typedef struct station_capabilities {
-	int codec;
-	int frames;
+	uint32_t codec;
+	uint32_t frames;
 	union {
 		char res[8];
-		long rate;
+		uint64_t rate;
 	} payloads;
 } station_capabilities;
 
 typedef struct capabilities_res_message {
-	int count;
+	uint32_t count;
 	struct station_capabilities caps[18];
 } capabilities_res_message;
 
 #define SPEED_DIAL_STAT_REQ_MESSAGE 0x000A
 typedef struct speed_dial_stat_req_message {
-	int speedDialNumber;
+	uint32_t speedDialNumber;
 } speed_dial_stat_req_message;
 
 #define LINE_STATE_REQ_MESSAGE 0x000B
 typedef struct line_state_req_message {
-	int lineNumber;
+	uint32_t lineNumber;
 } line_state_req_message;
 
 #define TIME_DATE_REQ_MESSAGE 0x000D
 #define BUTTON_TEMPLATE_REQ_MESSAGE 0x000E
 #define VERSION_REQ_MESSAGE 0x000F
 #define SERVER_REQUEST_MESSAGE 0x0012
+
 #define ALARM_MESSAGE 0x0020
+typedef struct alarm_message {
+	uint32_t alarmSeverity;
+	char displayMessage[80];
+	uint32_t alarmParam1;
+	uint32_t alarmParam2;
+} alarm_message;
 
 #define OPEN_RECEIVE_CHANNEL_ACK_MESSAGE 0x0022
 typedef struct open_receive_channel_ack_message {
-	int status;
-	char ipAddr[4];
-	int port;
-	int passThruId;
+	uint32_t status;
+	uint32_t ipAddr;
+	uint32_t port;
+	uint32_t passThruId;
 } open_receive_channel_ack_message;
 
 #define SOFT_KEY_SET_REQ_MESSAGE 0x0025
+
+#define SOFT_KEY_EVENT_MESSAGE 0x0026
+typedef struct soft_key_event_message {
+	uint32_t softKeyEvent;
+	uint32_t instance;
+	uint32_t reference;
+} soft_key_event_message;
+
 #define UNREGISTER_MESSAGE 0x0027
 #define SOFT_KEY_TEMPLATE_REQ_MESSAGE 0x0028
+#define HEADSET_STATUS_MESSAGE 0x002B
+#define REGISTER_AVAILABLE_LINES_MESSAGE 0x002D
 
 #define REGISTER_ACK_MESSAGE 0x0081
 typedef struct register_ack_message {
-	int keepAlive;
+	uint32_t keepAlive;
 	char dateTemplate[6];
 	char res[2];
-	int secondaryKeepAlive;
+	uint32_t secondaryKeepAlive;
 	char res2[4];
 } register_ack_message;
 
 #define START_TONE_MESSAGE 0x0082
 typedef struct start_tone_message {
-	int tone;
+	uint32_t tone;
 } start_tone_message;
 
 #define STOP_TONE_MESSAGE 0x0083
 
 #define SET_RINGER_MESSAGE 0x0085
 typedef struct set_ringer_message {
-	int ringerMode;
+	uint32_t ringerMode;
+	uint32_t unknown1; /* See notes in transmit_ringer_mode */
+	uint32_t unknown2;
 } set_ringer_message;
 
 #define SET_LAMP_MESSAGE 0x0086
 typedef struct set_lamp_message {
-	int stimulus;
-	int stimulusInstance;
-	int deviceStimulus;
+	uint32_t stimulus;
+	uint32_t stimulusInstance;
+	uint32_t deviceStimulus;
 } set_lamp_message;
 
 #define SET_SPEAKER_MESSAGE 0x0088
 typedef struct set_speaker_message {
-	int mode;
+	uint32_t mode;
 } set_speaker_message;
 
+/* XXX When do we need to use this? */
+#define SET_MICROPHONE_MESSAGE 0x0089
+typedef struct set_microphone_message {
+	uint32_t mode;
+} set_microphone_message;
+
 #define START_MEDIA_TRANSMISSION_MESSAGE 0x008A
 typedef struct media_qualifier {
-	int precedence;
-	int vad;
-	int packets;
-	int bitRate;
+	uint32_t precedence;
+	uint32_t vad;
+	uint32_t packets;
+	uint32_t bitRate;
 } media_qualifier;
 
 typedef struct start_media_transmission_message {
-	int conferenceId;
-	int passThruPartyId;
-	char remoteIp[4];
-	int remotePort;
-	int packetSize;
-	int payloadType;
+	uint32_t conferenceId;
+	uint32_t passThruPartyId;
+	uint32_t remoteIp;
+	uint32_t remotePort;
+	uint32_t packetSize;
+	uint32_t payloadType;
 	media_qualifier qualifier;
 } start_media_transmission_message;
 
 #define STOP_MEDIA_TRANSMISSION_MESSAGE 0x008B
 typedef struct stop_media_transmission_message {
-	int conferenceId;
-	int passThruPartyId;
+	uint32_t conferenceId;
+	uint32_t passThruPartyId;
 } stop_media_transmission_message;
 
 #define CALL_INFO_MESSAGE 0x008F
@@ -270,199 +304,96 @@
 	char callingParty[24];
 	char calledPartyName[40];
 	char calledParty[24];
-	int instance;
-	int reference;
-	int type;
+	uint32_t instance;
+	uint32_t reference;
+	uint32_t type;
 	char originalCalledPartyName[40];
 	char originalCalledParty[24];
 } call_info_message;
 
 #define SPEED_DIAL_STAT_RES_MESSAGE 0x0091
 typedef struct speed_dial_stat_res_message {
-	int speedDialNumber;
+	uint32_t speedDialNumber;
 	char speedDialDirNumber[24];
 	char speedDialDisplayName[40];
 } speed_dial_stat_res_message;
 
 #define LINE_STAT_RES_MESSAGE 0x0092
 typedef struct line_stat_res_message {
-	int linenumber;
+	uint32_t lineNumber;
 	char lineDirNumber[24];
 	char lineDisplayName[42];
-	int space;
+	uint32_t space;
 } line_stat_res_message;
 
 #define DEFINETIMEDATE_MESSAGE 0x0094
 typedef struct definetimedate_message {
-	int year;	/* since 1900 */
-	int month;
-	int dayofweek;	/* monday = 1 */
-	int day;
-	int hour;
-	int minute;
-	int seconds;
-	int milliseconds;
-	int timestamp;
+	uint32_t year;	/* since 1900 */
+	uint32_t month;
+	uint32_t dayofweek;	/* monday = 1 */
+	uint32_t day;
+	uint32_t hour;
+	uint32_t minute;
+	uint32_t seconds;
+	uint32_t milliseconds;
+	uint32_t timestamp;
 } definetimedate_message;
 
 #define BUTTON_TEMPLATE_RES_MESSAGE 0x0097
-
 typedef struct buttondefinition {
-	UINT8 instanceNumber;
-	UINT8 buttonDefinition;
+	uint8_t instanceNumber;
+	uint8_t buttonDefinition;
 } button_definition;
 
-#define STIMULUS_REDIAL 	0x01
-#define STIMULUS_SPEEDDIAL 	0x02
-#define STIMULUS_HOLD 		0x03
-#define STIMULUS_TRANSFER 	0x04
-#define STIMULUS_FORWARDALL 	0x05
-#define STIMULUS_FORWARDBUSY 	0x06
-#define STIMULUS_FORWARDNOANSWER 0x07
-#define STIMULUS_DISPLAY 	0x08
-#define STIMULUS_LINE 		0x09
-#define STIMULUS_VOICEMAIL 	0x0F
-#define STIMULUS_AUTOANSWER 	0x11
-#define STIMULUS_CONFERENCE 	0x7D
-#define STIMULUS_CALLPARK 	0x7E
-#define STIMULUS_CALLPICKUP 	0x7F
-#define STIMULUS_NONE	 	0xFF
+typedef struct buttondefinitiontemplate {
+	uint8_t buttonDefinition;
+	/* for now, anything between 0xB0 and 0xCF is custom */
+	/*int custom;*/
+} button_definition_template;
 
-button_definition button_def_30vip[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 2, STIMULUS_LINE },		/* Line 2 */
-	{ 3, STIMULUS_LINE },		/* Line 3 */
-	{ 4, STIMULUS_LINE },		/* Line 4 */
-	{ 1, STIMULUS_CALLPARK },	/* Call Park */
-	{ 0, STIMULUS_NONE },
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 3, STIMULUS_SPEEDDIAL },	/* Speeddial 3 */
-	{ 4, STIMULUS_SPEEDDIAL },	/* Speeddial 4 */
-	{ 5, STIMULUS_SPEEDDIAL },	/* Speeddial 5 */
-	{ 6, STIMULUS_SPEEDDIAL },	/* Speeddial 6 */
-	{ 1, STIMULUS_VOICEMAIL },	/* Voicemail */
-	{ 1, STIMULUS_FORWARDALL },	/* Forward All */
-	{ 1, STIMULUS_CONFERENCE },	/* Conference */
-	{ 0, STIMULUS_NONE },
-	{ 0, STIMULUS_NONE },
-	{ 0, STIMULUS_NONE },
-	{ 0, STIMULUS_NONE },
-	{ 0, STIMULUS_NONE },
-	{ 7, STIMULUS_SPEEDDIAL },	/* Speeddial 7 */
-	{ 8, STIMULUS_SPEEDDIAL },	/* Speeddial 8 */
-	{ 9, STIMULUS_SPEEDDIAL },	/* Speeddial 9 */
-	{ 10, STIMULUS_SPEEDDIAL }	/* Speeddial 10 */
-};
+#define STIMULUS_REDIAL			0x01
+#define STIMULUS_SPEEDDIAL		0x02
+#define STIMULUS_HOLD			0x03
+#define STIMULUS_TRANSFER		0x04
+#define STIMULUS_FORWARDALL		0x05
+#define STIMULUS_FORWARDBUSY		0x06
+#define STIMULUS_FORWARDNOANSWER	0x07
+#define STIMULUS_DISPLAY		0x08
+#define STIMULUS_LINE			0x09
+#define STIMULUS_VOICEMAIL		0x0F
+#define STIMULUS_AUTOANSWER		0x11
+#define STIMULUS_CONFERENCE		0x7D
+#define STIMULUS_CALLPARK		0x7E
+#define STIMULUS_CALLPICKUP		0x7F
+#define STIMULUS_NONE			0xFF
 
-button_definition button_def_12sp[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 3, STIMULUS_SPEEDDIAL },	/* Speeddial 3 */
-	{ 4, STIMULUS_SPEEDDIAL },	/* Speeddial 4 */
-	{ 1, STIMULUS_VOICEMAIL },	/* Voicemail */
-	{ 5, STIMULUS_SPEEDDIAL },	/* Speeddial 5 */
-	{ 6, STIMULUS_SPEEDDIAL },	/* Speeddial 6 */
-	{ 7, STIMULUS_SPEEDDIAL },	/* Speeddial 7 */
-	{ 8, STIMULUS_SPEEDDIAL },	/* Speeddial 8 */
-	{ 9, STIMULUS_SPEEDDIAL }	/* Speeddial 9 */
-};
+/* Button types */
+#define BT_REDIAL			STIMULUS_REDIAL
+#define BT_SPEEDDIAL			STIMULUS_SPEEDDIAL
+#define BT_HOLD				STIMULUS_HOLD
+#define BT_TRANSFER			STIMULUS_TRANSFER
+#define BT_FORWARDALL			STIMULUS_FORWARDALL
+#define BT_FORWARDBUSY			STIMULUS_FORWARDBUSY
+#define BT_FORWARDNOANSWER		STIMULUS_FORWARDNOANSWER
+#define BT_DISPLAY 			STIMULUS_DISPLAY
+#define BT_LINE				STIMULUS_LINE
+#define BT_VOICEMAIL			STIMULUS_VOICEMAIL
+#define BT_AUTOANSWER			STIMULUS_AUTOANSWER
+#define BT_CONFERENCE			STIMULUS_CONFERENCE
+#define BT_CALLPARK			STIMULUS_CALLPARK
+#define BT_CALLPICKUP			STIMULUS_CALLPICKUP
+#define BT_NONE				0x00
 
-button_definition button_def_7902[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 1, STIMULUS_HOLD },		/* Hold */
-	{ 1, STIMULUS_TRANSFER },
-	{ 1, STIMULUS_DISPLAY },
-	{ 1, STIMULUS_VOICEMAIL },
-	{ 1, STIMULUS_CONFERENCE },
-	{ 1, STIMULUS_FORWARDALL },
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 3, STIMULUS_SPEEDDIAL },	/* Speeddial 3 */
-	{ 4, STIMULUS_SPEEDDIAL },	/* Speeddial 4 */
-	{ 1, STIMULUS_REDIAL }
-};
+/* Custom button types - add our own between 0xB0 and 0xCF.
+   This may need to be revised in the future,
+   if stimuluses are ever added in this range. */
+#define BT_CUST_LINESPEEDDIAL		0xB0	/* line or speeddial */
+#define BT_CUST_HINT			0xB1	/* pipe dream */
 
-button_definition button_def_7910[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 1, STIMULUS_HOLD },		/* Hold */
-	{ 1, STIMULUS_TRANSFER },
-	{ 1, STIMULUS_DISPLAY },
-	{ 1, STIMULUS_VOICEMAIL },
-	{ 1, STIMULUS_CONFERENCE },
-	{ 1, STIMULUS_FORWARDALL },
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 1, STIMULUS_REDIAL }
-};
-
-button_definition button_def_7920[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 2, STIMULUS_LINE },		/* Line 2 */
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 3, STIMULUS_SPEEDDIAL },	/* Speeddial 3 */
-	{ 4, STIMULUS_SPEEDDIAL }	/* Speeddial 4 */
-};
-
-button_definition button_def_7935[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 2, STIMULUS_LINE }		/* Line 2 */
-};
-
-button_definition button_def_7940[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 2, STIMULUS_LINE }		/* Line 2 */
-};
-
-button_definition button_def_7960[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 2, STIMULUS_LINE },		/* Line 2 */
-	{ 3, STIMULUS_LINE },		/* Line 3 */
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 3, STIMULUS_SPEEDDIAL }	/* Speeddial 3 */
-};
-
-button_definition button_def_7970[] = {
-	{ 1, STIMULUS_LINE },		/* Line 1 */
-	{ 2, STIMULUS_LINE },		/* Line 2 */
-	{ 3, STIMULUS_LINE },		/* Line 3 */
-	{ 1, STIMULUS_SPEEDDIAL },	/* Speeddial 1 */
-	{ 2, STIMULUS_SPEEDDIAL },	/* Speeddial 2 */
-	{ 3, STIMULUS_SPEEDDIAL },	/* Speeddial 3 */
-	{ 4, STIMULUS_SPEEDDIAL },	/* Speeddial 4 */
-	{ 5, STIMULUS_SPEEDDIAL }	/* Speeddial 5 */
-};
-
-button_definition button_def_none = { 0, STIMULUS_NONE };
-
-typedef struct button_defs {
-	char *type;
-	int num_buttons;
-	button_definition *button_def;
-} button_defs_t;
-
-button_defs_t button_defs[] = {
-	{ "12SP", 	12,	button_def_12sp }, /* First one is used if
-						      there's no match */
-	{ "30VIP", 	26,	button_def_30vip },
-	{ "7902",	12,	button_def_7902 },
-	{ "7910",	10,	button_def_7910 },
-	{ "7920",	6,	button_def_7920 },
-	{ "7935",	2,	button_def_7935 },
-	{ "7940",	2,	button_def_7940 },
-	{ "7960",	6,	button_def_7960 },
-	{ "7970",	8,	button_def_7970 },
-	{ NULL,		0,	NULL }
-};
-
 typedef struct button_template_res_message {
-	UINT32 buttonOffset;
-	UINT32 buttonCount;
-	UINT32 totalButtonCount;
+	uint32_t buttonOffset;
+	uint32_t buttonCount;
+	uint32_t totalButtonCount;
 	button_definition definition[42];
 } button_template_res_message;
 
@@ -491,196 +422,303 @@
 
 typedef struct server_res_message {
 	server_identifier server[5];
-	int serverListenPort[5];
-	int serverIpAddr[5];
+	uint32_t serverListenPort[5];
+	uint32_t serverIpAddr[5];
 } server_res_message;
 
+#define RESET_MESSAGE 0x009F
+typedef struct reset_message {
+	uint32_t resetType;
+} reset_message;
+
 #define KEEP_ALIVE_ACK_MESSAGE 0x0100
 
 #define OPEN_RECEIVE_CHANNEL_MESSAGE 0x0105
 typedef struct open_receive_channel_message {
-	int conferenceId;
-	int partyId;
-	int packets;
-	int capability;
-	int echo;
-	int bitrate;
+	uint32_t conferenceId;
+	uint32_t partyId;
+	uint32_t packets;
+	uint32_t capability;
+	uint32_t echo;
+	uint32_t bitrate;
 } open_receive_channel_message;
 
 #define CLOSE_RECEIVE_CHANNEL_MESSAGE 0x0106
 typedef struct close_receive_channel_message {
-	int conferenceId;
-	int partyId;
+	uint32_t conferenceId;
+	uint32_t partyId;
 } close_receive_channel_message;
 
 #define SOFT_KEY_TEMPLATE_RES_MESSAGE 0x0108
 
 typedef struct soft_key_template_definition {
 	char softKeyLabel[16];
-	int softKeyEvent;
+	uint32_t softKeyEvent;
 } soft_key_template_definition;
 
+#define KEYDEF_ONHOOK			0
+#define KEYDEF_CONNECTED		1
+#define KEYDEF_ONHOLD			2
+#define KEYDEF_RINGIN			3
+#define KEYDEF_OFFHOOK			4
+#define KEYDEF_CONNWITHTRANS		5
+#define KEYDEF_DADFD			6 /* Digits After Dialing First Digit */
+#define KEYDEF_CONNWITHCONF		7
+#define KEYDEF_RINGOUT			8
+#define KEYDEF_OFFHOOKWITHFEAT		9
+#define KEYDEF_UNKNOWN			10
+
+#define SOFTKEY_NONE			0x00
+#define SOFTKEY_REDIAL			0x01
+#define SOFTKEY_NEWCALL			0x02
+#define SOFTKEY_HOLD			0x03
+#define SOFTKEY_TRNSFER			0x04
+#define SOFTKEY_CFWDALL			0x05
+#define SOFTKEY_CFWDBUSY		0x06
+#define SOFTKEY_CFWDNOANSWER		0x07
+#define SOFTKEY_BKSPC			0x08
+#define SOFTKEY_ENDCALL			0x09
+#define SOFTKEY_RESUME			0x0A
+#define SOFTKEY_ANSWER			0x0B
+#define SOFTKEY_INFO			0x0C
+#define SOFTKEY_CONFRN			0x0D
+#define SOFTKEY_PARK			0x0E
+#define SOFTKEY_JOIN			0x0F
+#define SOFTKEY_MEETME			0x10
+#define SOFTKEY_PICKUP			0x11
+#define SOFTKEY_GPICKUP			0x12
+
 soft_key_template_definition soft_key_template_default[] = {
-	{ "Redial",	 	1 },
-	{ "NewCall",	 	2 },
-	{ "Hold",	 	3 },
-	{ "Trnsfer",	 	4 },
-	{ "CFwdAll",	 	5 },
-	{ "CFwdBusy",	 	6 },
-	{ "CFwdNoAnswer",	7 },
-	{ "<<",		 	8 },
-	{ "EndCall",	 	9 },
-	{ "Resume",		10 },
-	{ "Answer",		11 },
-	{ "Info",		12 },
-	{ "Confrn",		13 },
-	{ "Park",		14 },
-	{ "Join",		15 },
-	{ "MeetMe",		16 },
-	{ "PickUp",		17 },
-	{ "GPickUp",		18 },
+	{ "Redial",	 	0x01 },
+	{ "NewCall",	 	0x02 },
+	{ "Hold",	 	0x03 },
+	{ "Trnsfer",	 	0x04 },
+	{ "CFwdAll",	 	0x05 },
+	{ "CFwdBusy",	 	0x06 },
+	{ "CFwdNoAnswer",	0x07 },
+	{ "<<",		 	0x08 },
+	{ "EndCall",	 	0x09 },
+	{ "Resume",		0x0A },
+	{ "Answer",		0x0B },
+	{ "Info",		0x0C },
+	{ "Confrn",		0x0D },
+	{ "Park",		0x0E },
+	{ "Join",		0x0F },
+	{ "MeetMe",		0x10 },
+	{ "PickUp",		0x11 },
+	{ "GPickUp",		0x12 },
 };
 
-typedef struct soft_key_template {
-	int softKeyOffset;
-	int softKeyCount;
-	int totalSoftKeyCount;
+typedef struct soft_key_definitions {
+	const uint8_t mode;
+	const uint8_t *defaults;
+	const int count;
+} soft_key_definitions;
+
+static const uint8_t soft_key_default_onhook[] = {
+	SOFTKEY_REDIAL,
+	SOFTKEY_CFWDALL,
+	SOFTKEY_CFWDBUSY,
+	SOFTKEY_GPICKUP,
+	SOFTKEY_CONFRN,
+};
+
+static const uint8_t soft_key_default_connected[] = {
+	SOFTKEY_HOLD,
+	SOFTKEY_ENDCALL,
+	SOFTKEY_TRNSFER,
+	SOFTKEY_PARK,
+	SOFTKEY_CFWDALL,
+	SOFTKEY_CFWDBUSY,
+};
+
+static const uint8_t soft_key_default_onhold[] = {
+	SOFTKEY_RESUME,
+	SOFTKEY_NEWCALL,
+	SOFTKEY_ENDCALL,
+	SOFTKEY_TRNSFER,
+};
+
+static const uint8_t soft_key_default_ringin[] = {
+	SOFTKEY_ANSWER,
+	SOFTKEY_ENDCALL,
+	SOFTKEY_TRNSFER,
+};
+
+static const uint8_t soft_key_default_offhook[] = {
+	SOFTKEY_REDIAL,
+	SOFTKEY_ENDCALL,
+	SOFTKEY_CFWDALL,
+	SOFTKEY_CFWDBUSY,
+	SOFTKEY_GPICKUP,
+};
+
+static const uint8_t soft_key_default_connwithtrans[] = {
+	SOFTKEY_HOLD,
+	SOFTKEY_ENDCALL,
+	SOFTKEY_TRNSFER,
+	SOFTKEY_PARK,
+	SOFTKEY_CFWDALL,
+	SOFTKEY_CFWDBUSY,
+};
+
+static const uint8_t soft_key_default_dadfd[] = {
+	SOFTKEY_BKSPC,
+	SOFTKEY_ENDCALL,
+};
+
+static const uint8_t soft_key_default_connwithconf[] = {
+	SOFTKEY_NONE,
+};
+
+static const uint8_t soft_key_default_ringout[] = {
+	SOFTKEY_ENDCALL,
+	SOFTKEY_TRNSFER,
+	SOFTKEY_CFWDALL,
+	SOFTKEY_CFWDBUSY,
+};
+
+static const uint8_t soft_key_default_offhookwithfeat[] = {
+	SOFTKEY_REDIAL,
+	SOFTKEY_ENDCALL,
+};
+
+static const uint8_t soft_key_default_unknown[] = {
+	SOFTKEY_NONE,
+};
+
+static const soft_key_definitions soft_key_default_definitions[] = {
+	{KEYDEF_ONHOOK, soft_key_default_onhook, sizeof(soft_key_default_onhook) / sizeof(uint8_t)},
+	{KEYDEF_CONNECTED, soft_key_default_connected, sizeof(soft_key_default_connected) / sizeof(uint8_t)},
+	{KEYDEF_ONHOLD, soft_key_default_onhold, sizeof(soft_key_default_onhold) / sizeof(uint8_t)},
+	{KEYDEF_RINGIN, soft_key_default_ringin, sizeof(soft_key_default_ringin) / sizeof(uint8_t)},
+	{KEYDEF_OFFHOOK, soft_key_default_offhook, sizeof(soft_key_default_offhook) / sizeof(uint8_t)},
+	{KEYDEF_CONNWITHTRANS, soft_key_default_connwithtrans, sizeof(soft_key_default_connwithtrans) / sizeof(uint8_t)},
+	{KEYDEF_DADFD, soft_key_default_dadfd, sizeof(soft_key_default_dadfd) / sizeof(uint8_t)},
+	{KEYDEF_CONNWITHCONF, soft_key_default_connwithconf, sizeof(soft_key_default_connwithconf) / sizeof(uint8_t)},
+	{KEYDEF_RINGOUT, soft_key_default_ringout, sizeof(soft_key_default_ringout) / sizeof(uint8_t)},
+	{KEYDEF_OFFHOOKWITHFEAT, soft_key_default_offhookwithfeat, sizeof(soft_key_default_offhookwithfeat) / sizeof(uint8_t)},
+	{KEYDEF_UNKNOWN, soft_key_default_unknown, sizeof(soft_key_default_unknown) / sizeof(uint8_t)}
+};
+
+typedef struct soft_key_template_res_message {
+	uint32_t softKeyOffset;
+	uint32_t softKeyCount;
+	uint32_t totalSoftKeyCount;
 	soft_key_template_definition softKeyTemplateDefinition[32];
-} soft_key_template;
+} soft_key_template_res_message;
 
 #define SOFT_KEY_SET_RES_MESSAGE 0x0109
-static const char *soft_key_set_hack = {
-	"\x01\x02\x05\x03\x09\x0a\x0b\x10\x11\x12\x04\x0e\x0d\x00\x00\x00"
-	"\x2d\x01\x2e\x01\x31\x01\x2f\x01\x35\x01\x36\x01\x37\x01\x3c\x01"
-	"\x3d\x01\x3e\x01\x30\x01\x3a\x01\x39\x01\x00\x00\x00\x00\x00\x00"
-	"\x03\x09\x04\x0e\x0d\x13\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x2f\x01\x35\x01\x30\x01\x3a\x01\x39\x01\x3f\x01\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x0a\x02\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x36\x01\x2e\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x0b\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x37\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x01\x09\x05\x10\x11\x12\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x2d\x01\x35\x01\x31\x01\x3c\x01\x3d\x01\x3e\x01\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x09\x04\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x35\x01\x30\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x08\x09\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x34\x01\x35\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x09\x0d\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x35\x01\x39\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x09\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x35\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x01\x09\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x2d\x01\x35\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x15\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x41\x01\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-	"\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00"
-};
 
 typedef struct soft_key_set_definition {
-	UINT8 softKeyTemplateIndex[16];
-	UINT16 softKeyInfoIndex[16];
+	uint8_t softKeyTemplateIndex[16];
+	uint16_t softKeyInfoIndex[16];
 } soft_key_set_definition;
 
-typedef struct soft_key_sets {
-	UINT32 softKeySetOffset;
-	UINT32 softKeySetCount;
-	UINT32 totalSoftKeySetCount;
+typedef struct soft_key_set_res_message {
+	uint32_t softKeySetOffset;
+	uint32_t softKeySetCount;
+	uint32_t totalSoftKeySetCount;
 	soft_key_set_definition softKeySetDefinition[16];
-	UINT32 res;
-} soft_key_sets;
+	uint32_t res;
+} soft_key_set_res_message;
 
 #define SELECT_SOFT_KEYS_MESSAGE 0x0110
 typedef struct select_soft_keys_message {
-	int instance;
-	int reference;
-	int softKeySetIndex;
-	int validKeyMask;
+	uint32_t instance;
+	uint32_t reference;
+	uint32_t softKeySetIndex;
+	uint32_t validKeyMask;
 } select_soft_keys_message;
 
 #define CALL_STATE_MESSAGE 0x0111
 typedef struct call_state_message {
-	int callState;
-	int lineInstance;
-	int callReference;
+	uint32_t callState;
+	uint32_t lineInstance;
+	uint32_t callReference;
 } call_state_message;
 
 #define DISPLAY_PROMPT_STATUS_MESSAGE 0x0112
 typedef struct display_prompt_status_message {
-	int messageTimeout;
+	uint32_t messageTimeout;
 	char promptMessage[32];
-	int lineInstance;
-	int callReference;
+	uint32_t lineInstance;
+	uint32_t callReference;
 } display_prompt_status_message;
 
 #define DISPLAY_NOTIFY_MESSAGE 0x0114
 typedef struct display_notify_message {
-	int displayTimeout;
+	uint32_t displayTimeout;
 	char displayMessage[100];
 } display_notify_message;
 
 #define ACTIVATE_CALL_PLANE_MESSAGE 0x0116
 typedef struct activate_call_plane_message {
-	int lineInstance;
+	uint32_t lineInstance;
 } activate_call_plane_message;
 
 #define DIALED_NUMBER_MESSAGE 0x011D
 typedef struct dialed_number_message {
 	char dialedNumber[24];
-	int lineInstance;
-	int callReference;
+	uint32_t lineInstance;
+	uint32_t callReference;
 } dialed_number_message;
 
+typedef union {
+	alarm_message alarm;
+	speed_dial_stat_req_message speeddialreq;
+	register_message reg;
+	register_ack_message regack;
+	register_rej_message regrej;
+	capabilities_res_message caps;
+	version_res_message version;
+	button_template_res_message buttontemplate;
+	displaytext_message displaytext;
+	display_prompt_status_message displaypromptstatus;
+	definetimedate_message definetimedate;
+	start_tone_message starttone;
+	speed_dial_stat_res_message speeddial;
+	line_state_req_message line;
+	line_stat_res_message linestat;
+	soft_key_set_res_message softkeysets;
+	soft_key_template_res_message softkeytemplate;
+	server_res_message serverres;
+	reset_message reset;
+	set_lamp_message setlamp;
+	set_ringer_message setringer;
+	call_state_message callstate;
+	keypad_button_message keypad;
+	select_soft_keys_message selectsoftkey;
+	activate_call_plane_message activatecallplane;
+	stimulus_message stimulus;
+	offhook_message offhook;
+	onhook_message onhook;
+	set_speaker_message setspeaker;
+	set_microphone_message setmicrophone;
+	call_info_message callinfo;
+	start_media_transmission_message startmedia;
+	stop_media_transmission_message stopmedia;
+	open_receive_channel_message openreceivechannel;
+	open_receive_channel_ack_message openreceivechannelack;
+	close_receive_channel_message closereceivechannel;
+	display_notify_message displaynotify;
+	dialed_number_message dialednumber;
+	soft_key_event_message softkeyeventmessage;
+} skinny_data;
+
 /* packet composition */
 typedef struct {
 	int len;
 	int res;
 	int e;
-	union {
-		speed_dial_stat_req_message speeddialreq;
-		register_message reg;
-		register_ack_message regack;
-		register_rej_message regrej;
-		capabilities_res_message caps;
-		version_res_message version;
-		button_template_res_message buttontemplate;
-		displaytext_message displaytext;
-		display_prompt_status_message displaypromptstatus;
-		definetimedate_message definetimedate;
-		start_tone_message starttone;
-		speed_dial_stat_res_message speeddial;
-		line_state_req_message line;
-		line_stat_res_message linestat;
-		soft_key_sets softkeysets;
-		soft_key_template softkeytemplate;
-		server_res_message serverres;
-		set_lamp_message setlamp;
-		set_ringer_message setringer;
-		call_state_message callstate;
-		keypad_button_message keypad;
-		select_soft_keys_message selectsoftkey;
-		activate_call_plane_message activatecallplane;
-		stimulus_message stimulus;
-		set_speaker_message setspeaker;
-		call_info_message callinfo;
-		start_media_transmission_message startmedia;
-		stop_media_transmission_message stopmedia;
-		open_receive_channel_message openreceivechannel;
-		open_receive_channel_ack_message openreceivechannelack;
-		close_receive_channel_message closereceivechannel;
-		display_notify_message displaynotify;
-		dialed_number_message dialednumber;
-	} data;
+	skinny_data data;
 } skinny_req;
 
+/* XXX This is the combined size of the variables above.  (len, res, e)
+   If more are added, this MUST change.
+   (sizeof(skinny_req) - sizeof(skinny_data)) DOES NOT WORK on all systems (amd64?). */
+int skinny_header_size = 12;
+
 /*****************************
  * Asterisk specific globals *
  *****************************/
@@ -692,7 +730,8 @@
 static char ourhost[256];
 static int ourport;
 static struct in_addr __ourip;
-struct ast_hostent ahp; struct hostent *hp;
+struct ast_hostent ahp;
+struct hostent *hp;
 static int skinnysock = -1;
 static pthread_t tcp_thread;
 static pthread_t accept_t;
@@ -719,13 +758,41 @@
 static int amaflags = 0;
 static int callnums = 1;
 
-#define SUB_REAL 0
-#define SUB_ALT 1
-#define MAX_SUBS 2
+#define SKINNY_DEVICE_UNKNOWN		-1
+#define SKINNY_DEVICE_NONE		0
+#define SKINNY_DEVICE_30SPPLUS		1
+#define SKINNY_DEVICE_12SPPLUS		2
+#define SKINNY_DEVICE_12SP		3
+#define SKINNY_DEVICE_12		4
+#define SKINNY_DEVICE_30VIP		5
+#define SKINNY_DEVICE_7910		6
+#define SKINNY_DEVICE_7960		7
+#define SKINNY_DEVICE_7940		8
+#define SKINNY_DEVICE_7935		9
+#define SKINNY_DEVICE_ATA186		12	/* Cisco ATA-186 */
+#define SKINNY_DEVICE_7941		115
+#define SKINNY_DEVICE_7971		119
+#define SKINNY_DEVICE_7985		302
+#define SKINNY_DEVICE_7911		307
+#define SKINNY_DEVICE_7961GE		308
+#define SKINNY_DEVICE_7941GE		309
+#define SKINNY_DEVICE_7905		20000
+#define SKINNY_DEVICE_7920		30002
+#define SKINNY_DEVICE_7970		30006
+#define SKINNY_DEVICE_7912		30007
+#define SKINNY_DEVICE_7902		30008
+#define SKINNY_DEVICE_CIPC		30016	/* Cisco IP Communicator */
+#define SKINNY_DEVICE_7961		30018
+#define SKINNY_DEVICE_7936		30019
+#define SKINNY_DEVICE_SCCPGATEWAY_AN	30027	/* ??? */
+#define SKINNY_DEVICE_SCCPGATEWAY_BRI	30028	/* ??? */
 
 #define SKINNY_SPEAKERON 1
 #define SKINNY_SPEAKEROFF 2
 
+#define SKINNY_MICON 1
+#define SKINNY_MICOFF 2
+
 #define SKINNY_OFFHOOK 1
 #define SKINNY_ONHOOK 2
 #define SKINNY_RINGOUT 3
@@ -818,26 +885,27 @@
 
 struct skinny_subchannel {
 	ast_mutex_t lock;
-	unsigned int callid;
 	struct ast_channel *owner;
-	struct skinny_line *parent;
 	struct ast_rtp *rtp;
-	time_t lastouttime;
+	struct ast_rtp *vrtp;
+	unsigned int callid;
+	/* time_t lastouttime; */			/* Unused */
 	int progress;
 	int ringing;
-	int lastout;
+	/* int lastout; */				/* Unused */
 	int cxmode;
 	int nat;
 	int outgoing;
 	int alreadygone;
+
 	struct skinny_subchannel *next;
+	struct skinny_line *parent;
 };
 
 struct skinny_line {
 	ast_mutex_t lock;
 	char name[80];
 	char label[42];					/* Label that shows next to the line buttons */
-	struct skinny_subchannel *sub;			/* pointer to our current connection, channel and stuff */
 	char accountcode[AST_MAX_ACCOUNT_CODE];
 	char exten[AST_MAX_EXTENSION];			/* Extension where to start */
 	char context[AST_MAX_CONTEXT];
@@ -848,6 +916,7 @@
 	char call_forward[AST_MAX_EXTENSION];
 	char mailbox[AST_MAX_EXTENSION];
 	char musicclass[MAX_MUSICCLASS];
+	char lastnumberdialed[AST_MAX_EXTENSION];	/* Last number that was dialed - used for redial */
 	int curtone;					/* Current tone being played */
 	ast_group_t callgroup;
 	ast_group_t pickupgroup;
@@ -868,14 +937,34 @@
 	int capability;
 	int nonCodecCapability;
 	int onhooktime;
-	int msgstate;		/* voicemail message state */
+	int msgstate;					/* voicemail message state */
 	int immediate;
 	int hookstate;
-	int progress;
+	int nat;
+
+	struct skinny_subchannel *sub;
 	struct skinny_line *next;
 	struct skinny_device *parent;
 };
 
+struct skinny_speeddial {
+	ast_mutex_t lock;
+	char label[42];
+	char exten[AST_MAX_EXTENSION];
+	int instance;
+
+	struct skinny_speeddial *next;
+	struct skinny_device *parent;
+};
+
+struct skinny_addon {
+	ast_mutex_t lock;
+	char type[10];
+
+	struct skinny_addon *next;
+	struct skinny_device *parent;
+};
+
 static struct skinny_device {
 	/* A device containing one or more lines */
 	char name[80];
@@ -883,10 +972,13 @@
 	char version_id[16];
 	int type;
 	int registered;
-	char model[6];
+	int lastlineinstance;
+	int lastcallreference;
 	struct sockaddr_in addr;
 	struct in_addr ourip;
 	struct skinny_line *lines;
+	struct skinny_speeddial *speeddials;
+	struct skinny_addon *addons;
 	struct ast_ha *ha;
 	struct skinnysession *session;
 	struct skinny_device *next;
@@ -905,6 +997,7 @@
 	struct sockaddr_in sin;
 	int fd;
 	char inbuf[SKINNY_MAX_PACKET];
+	char outbuf[SKINNY_MAX_PACKET];
 	struct skinny_device *device;
 	struct skinnysession *next;
 } *sessions = NULL;
@@ -936,25 +1029,151 @@
 /*	.bridge = ast_rtp_bridge, */
 };
 
-static skinny_req *req_alloc(size_t size)
+static void *get_button_template(struct skinnysession *s, button_definition_template *btn)
 {
+	struct skinny_device *d = s->device;
+	struct skinny_addon *a = d->addons;
+	int i;
+
+	switch (d->type) {
+		case SKINNY_DEVICE_30SPPLUS:
+		case SKINNY_DEVICE_30VIP:
+			/* 13 rows, 2 columns */
+			for (i = 0; i < 4; i++)
+				(btn++)->buttonDefinition = BT_LINE;
+			(btn++)->buttonDefinition = BT_REDIAL;
+			(btn++)->buttonDefinition = BT_VOICEMAIL;
+			(btn++)->buttonDefinition = BT_CALLPARK;
+			(btn++)->buttonDefinition = BT_FORWARDALL;
+			(btn++)->buttonDefinition = BT_CONFERENCE;
+			for (i = 0; i < 4; i++)
+				(btn++)->buttonDefinition = BT_NONE;
+			for (i = 0; i < 13; i++)
+				(btn++)->buttonDefinition = BT_SPEEDDIAL;
+			
+			break;
+		case SKINNY_DEVICE_12SPPLUS:
+		case SKINNY_DEVICE_12SP:
+		case SKINNY_DEVICE_12:
+			/* 6 rows, 2 columns */
+			for (i = 0; i < 2; i++)
+				(btn++)->buttonDefinition = BT_LINE;
+			(btn++)->buttonDefinition = BT_REDIAL;
+			for (i = 0; i < 3; i++)
+				(btn++)->buttonDefinition = BT_SPEEDDIAL;
+			(btn++)->buttonDefinition = BT_HOLD;
+			(btn++)->buttonDefinition = BT_TRANSFER;
+			(btn++)->buttonDefinition = BT_FORWARDALL;
+			(btn++)->buttonDefinition = BT_CALLPARK;
+			(btn++)->buttonDefinition = BT_VOICEMAIL;
+			(btn++)->buttonDefinition = BT_CONFERENCE;
+			break;
+		case SKINNY_DEVICE_7910:
+			(btn++)->buttonDefinition = BT_LINE;
+			(btn++)->buttonDefinition = BT_HOLD;
+			(btn++)->buttonDefinition = BT_TRANSFER;
+			(btn++)->buttonDefinition = BT_DISPLAY;
+			(btn++)->buttonDefinition = BT_VOICEMAIL;
+			(btn++)->buttonDefinition = BT_CONFERENCE;
+			(btn++)->buttonDefinition = BT_FORWARDALL;
+			for (i = 0; i < 2; i++)
+				(btn++)->buttonDefinition = BT_SPEEDDIAL;
+			(btn++)->buttonDefinition = BT_REDIAL;
+			break;
+		case SKINNY_DEVICE_7960:
+		case SKINNY_DEVICE_7961:
+		case SKINNY_DEVICE_7961GE:
+			for (i = 0; i < 6; i++)
+				(btn++)->buttonDefinition = BT_CUST_LINESPEEDDIAL;
+			break;
+		case SKINNY_DEVICE_7940:
+		case SKINNY_DEVICE_7941:
+		case SKINNY_DEVICE_7941GE:
+			for (i = 0; i < 2; i++)
+				(btn++)->buttonDefinition = BT_CUST_LINESPEEDDIAL;
+			break;
+		case SKINNY_DEVICE_7935:
+		case SKINNY_DEVICE_7936:
+			for (i = 0; i < 2; i++)
+				(btn++)->buttonDefinition = BT_LINE;
+			break;
+		case SKINNY_DEVICE_ATA186:
+			(btn++)->buttonDefinition = BT_LINE;
+			break;
+		case SKINNY_DEVICE_7970:
+		case SKINNY_DEVICE_7971:
+		case SKINNY_DEVICE_CIPC:
+			for (i = 0; i < 8; i++)
+				(btn++)->buttonDefinition = BT_CUST_LINESPEEDDIAL;
+			break;
+		case SKINNY_DEVICE_7985:
+			/* XXX I have no idea what the buttons look like on these. */
+			ast_log(LOG_WARNING, "Unsupported device type '%d (7985)' found.\n", d->type);
+			break;
+		case SKINNY_DEVICE_7912:
+		case SKINNY_DEVICE_7911:
+		case SKINNY_DEVICE_7905:
+			(btn++)->buttonDefinition = BT_LINE;
+			(btn++)->buttonDefinition = BT_HOLD;
+			break;
+		case SKINNY_DEVICE_7920:
+			/* XXX I don't know if this is right. */
+			for (i = 0; i < 4; i++)
+				(btn++)->buttonDefinition = BT_CUST_LINESPEEDDIAL;
+			break;
+		case SKINNY_DEVICE_7902:
+			ast_log(LOG_WARNING, "Unsupported device type '%d (7902)' found.\n", d->type);
+			break;
+		case SKINNY_DEVICE_SCCPGATEWAY_AN:
+		case SKINNY_DEVICE_SCCPGATEWAY_BRI:
+			ast_log(LOG_WARNING, "Unsupported device type '%d (SCCP gateway)' found.\n", d->type);
+			break;
+		default:
+			ast_log(LOG_WARNING, "Unknown device type '%d' found.\n", d->type);
+			break;
+	}
+
+	for (a = d->addons; a; a = a->next) {
+		if (!strcasecmp(a->type, "7914")) {
+			for (i = 0; i < 14; i++)
+				(btn++)->buttonDefinition = BT_CUST_LINESPEEDDIAL;
+		} else {
+			ast_log(LOG_WARNING, "Unknown addon type '%s' found.  Skipping.\n", a->type);
+		}
+	}
+
+	return btn;
+}
+
+static skinny_req *req_alloc(size_t size, int response_message)
+{
 	skinny_req *req;
-	req = malloc(size+12);
-	if (!req) {
+
+	if (!(req = ast_calloc(1, skinny_header_size + size + 4)))
 		return NULL;
-	}
-	memset(req, 0, size+12);
+
+	req->len = htolel(size+4);
+	req->e = htolel(response_message);
+
 	return req;
 }
 
-static struct skinny_subchannel *find_subchannel_by_line(struct skinny_line *l)
+static struct skinny_line *find_line_by_instance(struct skinny_device *d, int instance)
 {
-	/* XXX Need to figure out how to determine which sub we want */
-	struct skinny_subchannel *sub = l->sub;
-	return sub;
+	struct skinny_line *l;
+
+	for (l = d->lines; l; l = l->next) {
+		if (l->instance == instance)
+			break;
+	}
+
+	if (!l) {
+		ast_log(LOG_WARNING, "Could not find line with instance '%d' on device '%s'\n", instance, d->name);
+	}
+	return l;
 }
 
-static struct skinny_subchannel *find_subchannel_by_name(const char *dest)
+static struct skinny_line *find_line_by_name(const char *dest)
 {
 	struct skinny_line *l;
 	struct skinny_device *d;
@@ -973,15 +1192,14 @@
 	ast_mutex_lock(&devicelock);
 	for (d = devices; d; d = d->next) {
 		if (!strcasecmp(d->name, device)) {
-			if (skinnydebug) {
+			if (skinnydebug)
 				ast_verbose("Found device: %s\n", d->name);
-			}
 			/* Found the device */
 			for (l = d->lines; l; l = l->next) {
 				/* Search for the right line */
 				if (!strcasecmp(l->name, line)) {
 					ast_mutex_unlock(&devicelock);
-					return l->sub;
+					return l;
 				}
 			}
 		}
@@ -991,18 +1209,82 @@
 	return NULL;
 }
 
+/* It's quicker/easier to find the subchannel when we know the instance number too */
+static struct skinny_subchannel *find_subchannel_by_instance_reference(struct skinny_device *d, int instance, int reference)
+{
+	struct skinny_line *l = find_line_by_instance(d, instance);
+	struct skinny_subchannel *sub;
+
+	if (!l) {
+		return NULL;
+	}
+
+	for (sub = l->sub; sub; sub = sub->next) {
+		if (sub->callid == reference)
+			break;
+	}
+
+	if (!sub) {
+		ast_log(LOG_WARNING, "Could not find subchannel with reference '%d' on '%s'\n", reference, d->name);
+	}
+	return sub;
+}
+
+/* Find the subchannel when we only have the callid - this shouldn't happen often */
+static struct skinny_subchannel *find_subchannel_by_reference(struct skinny_device *d, int reference)
+{
+	struct skinny_line *l;
+	struct skinny_subchannel *sub = NULL;
+
+	for (l = d->lines; l; l = l->next) {
+		for (sub = l->sub; sub; sub = sub->next) {
+			if (sub->callid == reference)
+				break;
+		}
+		if (sub)
+			break;
+	}
+
+	if (!l) {
+		ast_log(LOG_WARNING, "Could not find any lines that contained a subchannel with reference '%d' on device '%s'\n", reference, d->name);
+	} else {
+		if (!sub) {
+			ast_log(LOG_WARNING, "Could not find subchannel with reference '%d' on '%s@%s'\n", reference, l->name, d->name);
+		}
+	}
+	return sub;
+}
+
+static struct skinny_speeddial *find_speeddial_by_instance(struct skinny_device *d, int instance)
+{
+	struct skinny_speeddial *sd;
+
+	for (sd = d->speeddials; sd; sd = sd->next) {
+		if (sd->instance == instance)
+			break;
+	}
+
+	if (!sd) {
+		ast_log(LOG_WARNING, "Could not find speeddial with instance '%d' on device '%s'\n", instance, d->name);
+	}
+	return sd;
+}
+
 static int transmit_response(struct skinnysession *s, skinny_req *req)
 {
 	int res = 0;
 	ast_mutex_lock(&s->lock);
 
 #if 0
-	if (skinnydebug) {
+	if (skinnydebug)
 		ast_verbose("writing packet type %04X (%d bytes) to socket %d\n", letohl(req->e), letohl(req->len)+8, s->fd);
-	}
 #endif
 
-	res = write(s->fd, req, letohl(req->len)+8);
+	memset(s->outbuf,0,sizeof(s->outbuf));
+	memcpy(s->outbuf, req, skinny_header_size);
+	memcpy(s->outbuf+skinny_header_size, &req->data, sizeof(skinny_data));
+
+	res = write(s->fd, s->outbuf, letohl(req->len)+8);
 	if (res != letohl(req->len)+8) {
 		ast_log(LOG_WARNING, "Transmit: write only sent %d out of %d bytes: %s\n", res, letohl(req->len)+8, strerror(errno));
 	}
@@ -1021,76 +1303,74 @@
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct set_speaker_message));
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct set_speaker_message), SET_SPEAKER_MESSAGE)))
 		return;
-	}
-	req->len = htolel(sizeof(set_speaker_message)+4);
-	req->e = htolel(SET_SPEAKER_MESSAGE);
+
 	req->data.setspeaker.mode = htolel(mode);
 	transmit_response(s, req);
 }
+/*
+static void transmit_microphone_mode(struct skinnysession *s, int mode)
+{
+	skinny_req *req;
 
+	if (!(req = req_alloc(sizeof(struct set_microphone_message), SET_MICROPHONE_MESSAGE)))
+		return;
+
+	req->data.setmicrophone.mode = htolel(mode);
+	transmit_response(s, req);
+}
+*/
 static void transmit_callstate(struct skinnysession *s, int instance, int state, unsigned callid)
 {
 	skinny_req *req;
-	int memsize = sizeof(struct call_state_message);
 
-	req = req_alloc(memsize);
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct call_state_message), CALL_STATE_MESSAGE)))
 		return;
-	}
+
 	if (state == SKINNY_ONHOOK) {
 		transmit_speaker_mode(s, SKINNY_SPEAKEROFF);
 	}
-	req->len = htolel(sizeof(call_state_message)+4);
-	req->e = htolel(CALL_STATE_MESSAGE);
 	req->data.callstate.callState = htolel(state);
 	req->data.callstate.lineInstance = htolel(instance);
 	req->data.callstate.callReference = htolel(callid);
 	transmit_response(s, req);
 	if (state == SKINNY_OFFHOOK) {
-		memset(req, 0, memsize);
-		req->len = htolel(sizeof(activate_call_plane_message)+4);
-		req->e = htolel(ACTIVATE_CALL_PLANE_MESSAGE);
+		if (!(req = req_alloc(sizeof(struct activate_call_plane_message), ACTIVATE_CALL_PLANE_MESSAGE)))
+			return;
+
 		req->data.activatecallplane.lineInstance = htolel(instance);
 		transmit_response(s, req);
 	} else if (state == SKINNY_ONHOOK) {
-		memset(req, 0, memsize);
-		req->len = htolel(sizeof(activate_call_plane_message)+4);
-		req->e = htolel(ACTIVATE_CALL_PLANE_MESSAGE);
-		req->data.activatecallplane.lineInstance = 0;
+		if (!(req = req_alloc(sizeof(struct activate_call_plane_message), ACTIVATE_CALL_PLANE_MESSAGE)))
+			return;
+
+		req->data.activatecallplane.lineInstance = htolel(instance);
 		transmit_response(s, req);
-		memset(req, 0, memsize);
-		req->len = htolel(sizeof(close_receive_channel_message)+4);
-		req->e = htolel(CLOSE_RECEIVE_CHANNEL_MESSAGE);
+
+		if (!(req = req_alloc(sizeof(struct close_receive_channel_message), CLOSE_RECEIVE_CHANNEL_MESSAGE)))
+			return;
+
 		req->data.closereceivechannel.conferenceId = 0;
-		req->data.closereceivechannel.partyId = 0;
+		req->data.closereceivechannel.partyId = htolel(callid);
 		transmit_response(s, req);
-		memset(req, 0, memsize);
-		req->len = htolel(sizeof(stop_media_transmission_message)+4);
-		req->e = htolel(STOP_MEDIA_TRANSMISSION_MESSAGE);
+
+		if (!(req = req_alloc(sizeof(struct stop_media_transmission_message), STOP_MEDIA_TRANSMISSION_MESSAGE)))
+			return;
+
 		req->data.stopmedia.conferenceId = 0;
-		req->data.stopmedia.passThruPartyId = 0;
+		req->data.stopmedia.passThruPartyId = htolel(callid);
 		transmit_response(s, req);
 	}
 }
 
-static void transmit_callinfo(struct skinnysession *s, char *fromname, char *fromnum, char *toname, char *tonum, int instance, int callid, int calltype)
+static void transmit_callinfo(struct skinnysession *s, const char *fromname, const char *fromnum, const char *toname, const char *tonum, int instance, int callid, int calltype)
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct call_info_message));
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct call_info_message), CALL_INFO_MESSAGE)))
 		return;
-	}
 
-	req->len = htolel(sizeof(struct call_info_message));
-	req->e = htolel(CALL_INFO_MESSAGE);
-
 	if (fromname) {
 		ast_copy_string(req->data.callinfo.callingPartyName, fromname, sizeof(req->data.callinfo.callingPartyName));
 	}
@@ -1109,20 +1389,16 @@
 	transmit_response(s, req);
 }
 
-static void transmit_connect(struct skinnysession *s)
+static void transmit_connect(struct skinnysession *s, struct skinny_subchannel *sub)
 {
 	skinny_req *req;
-	struct skinny_line *l = s->device->lines;
+	struct skinny_line *l = sub->parent;
 
-	req = req_alloc(sizeof(struct open_receive_channel_message));
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct open_receive_channel_message), OPEN_RECEIVE_CHANNEL_MESSAGE)))
 		return;
-	}
-	req->len = htolel(sizeof(struct open_receive_channel_message));
-	req->e = htolel(OPEN_RECEIVE_CHANNEL_MESSAGE);
+
 	req->data.openreceivechannel.conferenceId = 0;
-	req->data.openreceivechannel.partyId = 0;
+	req->data.openreceivechannel.partyId = htolel(sub->callid);
 	req->data.openreceivechannel.packets = htolel(20);
 	req->data.openreceivechannel.capability = htolel(convert_cap(l->capability));
 	req->data.openreceivechannel.echo = 0;
@@ -1134,59 +1410,46 @@
 {
 	skinny_req *req;
 
+	if (tone == SKINNY_NOTONE) {
+		/* This is bad, mmm'kay? */
+		return;
+	}
+
 	if (tone > 0) {
-		req = req_alloc(sizeof(struct start_tone_message));
+		if (!(req = req_alloc(sizeof(struct start_tone_message), START_TONE_MESSAGE)))
+			return;
 	} else {
-		req = req_alloc(4);
+		if (!(req = req_alloc(0, STOP_TONE_MESSAGE)))
+			return;
 	}
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
-		return;
-	}
+
 	if (tone > 0) {
-		req->len = htolel(sizeof(start_tone_message)+4);
-		req->e = htolel(START_TONE_MESSAGE);
 		req->data.starttone.tone = htolel(tone);
-	} else {
-		req->len = htolel(4);
-		req->e = htolel(STOP_TONE_MESSAGE);
 	}
 	transmit_response(s, req);
 }
 
-#if 0
-/* XXX need to properly deal with softkeys */
 static void transmit_selectsoftkeys(struct skinnysession *s, int instance, int callid, int softkey)
 {
 	skinny_req *req;
-	int memsize = sizeof(struct select_soft_keys_message);
 
-	req = req_alloc(memsize);
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct select_soft_keys_message), SELECT_SOFT_KEYS_MESSAGE)))
 		return;
-	}
-	memset(req, 0, memsize);
-	req->len = htolel(sizeof(select_soft_keys_message)+4);
-	req->e = htolel(SELECT_SOFT_KEYS_MESSAGE);
+
 	req->data.selectsoftkey.instance = htolel(instance);
 	req->data.selectsoftkey.reference = htolel(callid);
 	req->data.selectsoftkey.softKeySetIndex = htolel(softkey);
+	req->data.selectsoftkey.validKeyMask = htolel(0xFFFFFFFF);
 	transmit_response(s, req);
 }
-#endif
 
 static void transmit_lamp_indication(struct skinnysession *s, int stimulus, int instance, int indication)
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct set_lamp_message));
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct set_lamp_message), SET_LAMP_MESSAGE)))
 		return;
-	}
-	req->len = htolel(sizeof(set_lamp_message)+4);
-	req->e = htolel(SET_LAMP_MESSAGE);
+
 	req->data.setlamp.stimulus = htolel(stimulus);
 	req->data.setlamp.stimulusInstance = htolel(instance);
 	req->data.setlamp.deviceStimulus = htolel(indication);
@@ -1197,107 +1460,90 @@
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct set_ringer_message));
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (skinnydebug)
+		ast_verbose("Setting ringer mode to '%d'.\n", mode);
+
+	if (!(req = req_alloc(sizeof(struct set_ringer_message), SET_RINGER_MESSAGE)))
 		return;
-	}
-	req->len = htolel(sizeof(set_ringer_message)+4);
-	req->e = htolel(SET_RINGER_MESSAGE);
+
 	req->data.setringer.ringerMode = htolel(mode);
+	/* XXX okay, I don't quite know what this is, but here's what happens (on a 7960).
+	   Note: The phone will always show as ringing on the display.
+
+	   1: phone will audibly ring over and over
+	   2: phone will audibly ring only once
+	   any other value, will NOT cause the phone to audibly ring
+	*/
+	req->data.setringer.unknown1 = htolel(1);
+	/* XXX the value here doesn't seem to change anything.  Must be higher than 0.
+	   Perhaps a packet capture can shed some light on this. */
+	req->data.setringer.unknown2 = htolel(1);
 	transmit_response(s, req);
 }
 
-static void transmit_displaymessage(struct skinnysession *s, char *text)
+static void transmit_displaymessage(struct skinnysession *s, const char *text)
 {
 	skinny_req *req;
 
 	if (text == 0) {
-		req = req_alloc(4);
-		if (req) {
-			req->len = htolel(4);
-			req->e = htolel(CLEAR_DISPLAY_MESSAGE);
-		}
+		if (!(req = req_alloc(0, CLEAR_DISPLAY_MESSAGE)))
+			return;
+
+		if (skinnydebug)
+			ast_verbose("Clearing Display\n");
 	} else {
-		req = req_alloc(sizeof(struct displaytext_message));
-		if (req) {
-			ast_copy_string(req->data.displaytext.text, text, sizeof(req->data.displaytext.text));
-			req->len = htolel(sizeof(displaytext_message) + 4);
-			req->e = htolel(DISPLAYTEXT_MESSAGE);
-			if (skinnydebug) {
-				ast_verbose("Displaying message '%s'\n", req->data.displaytext.text);
-			}
-		}
+		if (!(req = req_alloc(sizeof(struct displaytext_message), DISPLAYTEXT_MESSAGE)))
+			return;
+
+		ast_copy_string(req->data.displaytext.text, text, sizeof(req->data.displaytext.text));
+		if (skinnydebug)
+			ast_verbose("Displaying message '%s'\n", req->data.displaytext.text);
 	}
 
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
-		return;
-	}
 	transmit_response(s, req);
 }
 
-static void transmit_displaynotify(struct skinnysession *s, char *text, int t)
+static void transmit_displaynotify(struct skinnysession *s, const char *text, int t)
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct display_notify_message));
-
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct display_notify_message), DISPLAY_NOTIFY_MESSAGE)))
 		return;
-	}
 
-	req->e = htolel(DISPLAY_NOTIFY_MESSAGE);
-	req->len = htolel(sizeof(display_notify_message) + 4);
 	ast_copy_string(req->data.displaynotify.displayMessage, text, sizeof(req->data.displaynotify.displayMessage));
 	req->data.displaynotify.displayTimeout = htolel(t);
 
-	if (skinnydebug) {
+	if (skinnydebug)
 		ast_verbose("Displaying notify '%s'\n", text);
-	}
 
 	transmit_response(s, req);
 }
 
-static void transmit_displaypromptstatus(struct skinnysession *s, char *text, int t, int instance, int callid)
+static void transmit_displaypromptstatus(struct skinnysession *s, const char *text, int t, int instance, int callid)
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct display_prompt_status_message));
-
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct display_prompt_status_message), DISPLAY_PROMPT_STATUS_MESSAGE)))
 		return;
-	}
 
-	req->e = htolel(DISPLAY_PROMPT_STATUS_MESSAGE);
-	req->len = htolel(sizeof(display_prompt_status_message) + 4);
 	ast_copy_string(req->data.displaypromptstatus.promptMessage, text, sizeof(req->data.displaypromptstatus.promptMessage));
 	req->data.displaypromptstatus.messageTimeout = htolel(t);
 	req->data.displaypromptstatus.lineInstance = htolel(instance);
 	req->data.displaypromptstatus.callReference = htolel(callid);
 
-	if (skinnydebug) {
+	if (skinnydebug)
 		ast_verbose("Displaying Prompt Status '%s'\n", text);
-	}
 
 	transmit_response(s, req);
 }
 
-static void transmit_dialednumber(struct skinnysession *s, char *text, int instance, int callid)
+static void transmit_dialednumber(struct skinnysession *s, const char *text, int instance, int callid)
 {
 	skinny_req *req;
 
-	req = req_alloc(sizeof(struct dialed_number_message));
-
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = req_alloc(sizeof(struct dialed_number_message), DIALED_NUMBER_MESSAGE)))
 		return;
-	}
 
-	req->e = htolel(DIALED_NUMBER_MESSAGE);
-	req->len = htolel(sizeof(dialed_number_message) + 4);
 	ast_copy_string(req->data.dialednumber.dialedNumber, text, sizeof(req->data.dialednumber.dialedNumber));
 	req->data.dialednumber.lineInstance = htolel(instance);
 	req->data.dialednumber.callReference = htolel(callid);
@@ -1305,41 +1551,50 @@
 	transmit_response(s, req);
 }
 
+/*
 static int has_voicemail(struct skinny_line *l)
 {
 	return ast_app_has_voicemail(l->mailbox, NULL);
 }
+*/
 
-
 static void do_housekeeping(struct skinnysession *s)
 {
+/*
 	int new;
 	int old;
-	struct skinny_subchannel *sub;
-	struct skinny_line *l = s->device->lines;
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+*/
 
-	sub = find_subchannel_by_line(l);
 	transmit_displaymessage(s, NULL);
 
-	if (has_voicemail(sub->parent)) {
-		if (skinnydebug) {
-			ast_verbose("Checking for voicemail Skinny %s@%s\n", sub->parent->name, sub->parent->parent->name);
+/*
+	for (l = d->lines; l; l = l->next) {
+		if (has_voicemail(l)) {
+			if (skinnydebug)
+				ast_verbose("Checking for voicemail Skinny %s@%s\n", l->name, d->name);
+			ast_app_inboxcount(l->mailbox, &new, &old);
+			if (skinnydebug)
+				ast_verbose("Skinny %s@%s has voicemail!\n", l->name, d->name);
+			transmit_lamp_indication(s, STIMULUS_VOICEMAIL, l->instance, l->mwiblink?SKINNY_LAMP_BLINK:SKINNY_LAMP_ON);
+		} else {
+			transmit_lamp_indication(s, STIMULUS_VOICEMAIL, l->instance, SKINNY_LAMP_OFF);
 		}
-		ast_app_inboxcount(sub->parent->mailbox, &new, &old);
-		if (skinnydebug) {
-			ast_verbose("Skinny %s@%s has voicemail!\n", sub->parent->name, sub->parent->parent->name);
-		}
-		transmit_lamp_indication(s, STIMULUS_VOICEMAIL, l->instance, l->mwiblink?SKINNY_LAMP_BLINK:SKINNY_LAMP_ON);
-	} else {
-		transmit_lamp_indication(s, STIMULUS_VOICEMAIL, l->instance, SKINNY_LAMP_OFF);
 	}
-
+*/
 }
 
 /* I do not believe skinny can deal with video.
    Anyone know differently? */
+/* Yes, it can.  Currently 7985 and Cisco VT Advantage do video. */
 static struct ast_rtp *skinny_get_vrtp_peer(struct ast_channel *chan)
 {
+	struct skinny_subchannel *sub;
+	sub = chan->tech_pvt;
+	if (sub && sub->vrtp) {
+		return sub->vrtp;
+	}
 	return NULL;
 }
 
@@ -1391,6 +1646,60 @@
 	return RESULT_SUCCESS;
 }
 
+static char *complete_skinny_reset(const char *line, const char *word, int pos, int state)
+{
+	struct skinny_device *d;
+
+	char *result = NULL;
+	int wordlen = strlen(word);
+	int which = 0;
+
+	if (pos == 2) {
+		for (d = devices; d && !result; d = d->next) {
+			if (!strncasecmp(word, d->id, wordlen) && ++which > state)
+				result = ast_strdup(d->id);
+		}
+	}
+
+	return result;
+}
+
+static int skinny_reset_device(int fd, int argc, char *argv[])
+{
+	struct skinny_device *d;
+	skinny_req *req;
+
+	if (argc < 3 || argc > 4) {
+		return RESULT_SHOWUSAGE;
+	}
+	ast_mutex_lock(&devicelock);
+
+	for (d = devices; d; d = d->next) {
+		int fullrestart = 0;
+		if (!strcasecmp(argv[2], d->id) || !strcasecmp(argv[2], "all")) {
+			if (!(d->session))
+				continue;
+
+			if (!(req = req_alloc(sizeof(struct reset_message), RESET_MESSAGE)))
+				continue;
+
+			if (argc == 4 && !strcasecmp(argv[3], "restart"))
+				fullrestart = 1;
+
+			if (fullrestart)
+				req->data.reset.resetType = 2;
+			else
+				req->data.reset.resetType = 1;
+
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "%s device %s.\n", (fullrestart) ? "Restarting" : "Resetting", d->id);
+			transmit_response(d->session, req);
+		}
+	}
+	ast_mutex_unlock(&devicelock);
+	return RESULT_SUCCESS;
+}
+
 static int skinny_show_devices(int fd, int argc, char *argv[])
 {
 	struct skinny_device *d;
@@ -1402,25 +1711,22 @@
 		return RESULT_SHOWUSAGE;
 	}
 	ast_mutex_lock(&devicelock);
-	d = devices;
 
-	ast_cli(fd, "Name                 DeviceId         IP              TypeId R Model  NL\n");
-	ast_cli(fd, "-------------------- ---------------- --------------- ------ - ------ --\n");
-	while(d) {
-		l = d->lines;
+	ast_cli(fd, "Name                 DeviceId         IP              TypeId R NL\n");
+	ast_cli(fd, "-------------------- ---------------- --------------- ------ - --\n");
+	for (d = devices; d; d = d->next) {
 		numlines = 0;
-		while(l) { numlines++; l = l->next; }
+		for (l = d->lines; l; l = l->next) {
+			numlines++;
+		}
 
-		ast_cli(fd, "%-20s %-16s %-16s %6X %c %-6s %2d\n",
+		ast_cli(fd, "%-20s %-16s %-15s %6X %c %2d\n",
 				d->name,
 				d->id,
 				ast_inet_ntoa(iabuf, sizeof(iabuf), d->addr.sin_addr),
 				d->type,
 				d->registered?'Y':'N',
-				d->model,
 				numlines);
-
-		d = d->next;
 	}
 	ast_mutex_unlock(&devicelock);
 	return RESULT_SUCCESS;
@@ -1435,21 +1741,19 @@
 		return RESULT_SHOWUSAGE;
 	}
 	ast_mutex_lock(&devicelock);
-	d = devices;
-	while(d) {
-		l = d->lines;
-		while (l) {
-			ast_cli(fd, "%-20s %2d %-20s %-20s  %c  %c\n",
-				l->parent->name,
+
+	ast_cli(fd, "Device Name          Instance Name                 Label               \n");
+	ast_cli(fd, "-------------------- -------- -------------------- --------------------\n");
+	for (d = devices; d; d = d->next) {
+		for (l = d->lines; l; l = l->next) {
+			ast_cli(fd, "%-20s %8d %-20s %-20s\n",
+				d->name,
 				l->instance,
 				l->name,
-				l->label,
-				l->sub->owner?'Y':'N',
-				l->sub->rtp?'Y':'N');
-			l = l->next;
+				l->label);
 		}
-		d = d->next;
 	}
+
 	ast_mutex_unlock(&devicelock);
 	return RESULT_SUCCESS;
 }
@@ -1470,6 +1774,10 @@
 "Usage: skinny no debug\n"
 "       Disables dumping of Skinny packets for debugging purposes\n";
 
+static char reset_usage[] =
+"Usage: skinny reset <DeviceId|all> [restart]\n"
+"       Causes a Skinny device to reset itself, optionally with a full restart\n";
+
 static struct ast_cli_entry cli_show_devices =
 	{ { "skinny", "show", "devices", NULL }, skinny_show_devices, "Show defined Skinny devices", show_devices_usage };
 
@@ -1482,24 +1790,31 @@
 static struct ast_cli_entry cli_no_debug =
 	{ { "skinny", "no", "debug", NULL }, skinny_no_debug, "Disable Skinny debugging", no_debug_usage };
 
+static struct ast_cli_entry cli_reset_device =
+	{ { "skinny", "reset", NULL }, skinny_reset_device, "Reset Skinny device(s)", reset_usage, complete_skinny_reset };
+
 #if 0
-static struct skinny_paging_device *build_paging_device(char *cat, struct ast_variable *v)
+static struct skinny_paging_device *build_paging_device(const char *cat, struct ast_variable *v)
 {
 	return NULL;
 }
 #endif
 
-static struct skinny_device *build_device(char *cat, struct ast_variable *v)
+static struct skinny_device *build_device(const char *cat, struct ast_variable *v)
 {
 	struct skinny_device *d;
 	struct skinny_line *l;
-	struct skinny_subchannel *sub;
-	int i=0, y=0;
+	struct skinny_speeddial *sd;
+	struct skinny_addon *a;
+	int lineInstance = 1;
+	int speeddialInstance = 1;
+	int y = 0;
 
-	d = malloc(sizeof(struct skinny_device));
-	if (d) {
-		memset(d, 0, sizeof(struct skinny_device));
+	if (!(d = ast_calloc(1, sizeof(struct skinny_device)))) {
+		return NULL;
+	} else {
 		ast_copy_string(d->name, cat, sizeof(d->name));
+		d->lastlineinstance = 1;
 		while(v) {
 			if (!strcasecmp(v->name, "host")) {
 				if (ast_get_ip(&d->addr, v->value)) {
@@ -1509,17 +1824,15 @@
 			} else if (!strcasecmp(v->name, "port")) {
 				d->addr.sin_port = htons(atoi(v->value));
 			} else if (!strcasecmp(v->name, "device")) {
-				strncpy(d->id, v->value, sizeof(d->id)-1);
+				ast_copy_string(d->id, v->value, sizeof(d->id));
 			} else if (!strcasecmp(v->name, "permit") || !strcasecmp(v->name, "deny")) {
 				d->ha = ast_append_ha(v->name, v->value, d->ha);
 			} else if (!strcasecmp(v->name, "context")) {
-				strncpy(context, v->value, sizeof(context) - 1);
+				ast_copy_string(context, v->value, sizeof(context));
 			} else if (!strcasecmp(v->name, "version")) {
-				strncpy(d->version_id, v->value, sizeof(d->version_id) -1);
+				ast_copy_string(d->version_id, v->value, sizeof(d->version_id));
 			} else if (!strcasecmp(v->name, "nat")) {
 				nat = ast_true(v->value);
-			} else if (!strcasecmp(v->name, "model")) {
-				strncpy(d->model, v->value, sizeof(d->model) - 1);
 			} else if (!strcasecmp(v->name, "callerid")) {
 				if (!strcasecmp(v->value, "asreceived")) {
 					cid_num[0] = '\0';
@@ -1528,9 +1841,9 @@
 					ast_callerid_split(v->value, cid_name, sizeof(cid_name), cid_num, sizeof(cid_num));
 				}
 			} else if (!strcasecmp(v->name, "language")) {
-				strncpy(language, v->value, sizeof(language)-1);
+				ast_copy_string(language, v->value, sizeof(language));
 			} else if (!strcasecmp(v->name, "accountcode")) {
-				strncpy(accountcode, v->value, sizeof(accountcode)-1);
+				ast_copy_string(accountcode, v->value, sizeof(accountcode));
 			} else if (!strcasecmp(v->name, "amaflags")) {
 				y = ast_cdr_amaflags2int(v->value);
 				if (y < 0) {
@@ -1539,7 +1852,7 @@
 					amaflags = y;
 				}
 			} else if (!strcasecmp(v->name, "musiconhold")) {
-				strncpy(musicclass, v->value, sizeof(musicclass)-1);
+				ast_copy_string(musicclass, v->value, sizeof(musicclass));
 			} else if (!strcasecmp(v->name, "callgroup")) {
 				cur_callergroup = ast_get_group(v->value);
 			} else if (!strcasecmp(v->name, "pickupgroup")) {
@@ -1549,7 +1862,7 @@
 			} else if (!strcasecmp(v->name, "cancallforward")) {
 				cancallforward = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "mailbox")) {
-				strncpy(mailbox, v->value, sizeof(mailbox) -1);
+				ast_copy_string(mailbox, v->value, sizeof(mailbox));
 			} else if (!strcasecmp(v->name, "callreturn")) {
 				callreturn = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "callwaiting")) {
@@ -1561,23 +1874,52 @@
 			} else if (!strcasecmp(v->name, "mwiblink")) {
 				mwiblink = ast_true(v->value);
 			} else if (!strcasecmp(v->name, "linelabel")) {
-				strncpy(linelabel, v->value, sizeof(linelabel)-1);
+				ast_copy_string(linelabel, v->value, sizeof(linelabel));
+			} else if (!strcasecmp(v->name, "speeddial")) {
+				if (!(sd = ast_calloc(1, sizeof(struct skinny_speeddial)))) {
+					return NULL;
+				} else {
+					char *stringp, *exten, *label;
+					stringp = v->value;
+					exten = strsep(&stringp, ",");
+					label = strsep(&stringp, ",");
+					ast_mutex_init(&sd->lock);
+					ast_copy_string(sd->exten, exten, sizeof(sd->exten));
+					if (label)
+						ast_copy_string(sd->label, label, sizeof(sd->label));
+					else
+						ast_copy_string(sd->label, exten, sizeof(sd->label));
+					sd->instance = speeddialInstance++;
+
+					sd->next = d->speeddials;
+					d->speeddials = sd;
+				}
+			} else if (!strcasecmp(v->name, "addon")) {
+				if (!(a = ast_calloc(1, sizeof(struct skinny_addon)))) {
+					return NULL;
+				} else {
+					ast_mutex_init(&a->lock);
+					ast_copy_string(a->type, v->value, sizeof(a->type));
+
+					a->next = d->addons;
+					d->addons = a;
+				}
 			} else if (!strcasecmp(v->name, "trunk") || !strcasecmp(v->name, "line")) {
-				l = malloc(sizeof(struct skinny_line));;
-				if (l) {
-					memset(l, 0, sizeof(struct skinny_line));
+				if (!(l = ast_calloc(1, sizeof(struct skinny_line)))) {
+					return NULL;
+				} else {
 					ast_mutex_init(&l->lock);
-					strncpy(l->name, v->value, sizeof(l->name) - 1);
+					ast_copy_string(l->name, v->value, sizeof(l->name));
 
 					/* XXX Should we check for uniqueness?? XXX */
-					strncpy(l->context, context, sizeof(l->context) - 1);
-					strncpy(l->cid_num, cid_num, sizeof(l->cid_num) - 1);
-					strncpy(l->cid_name, cid_name, sizeof(l->cid_name) - 1);
-					strncpy(l->label, linelabel, sizeof(l->label) - 1);
-					strncpy(l->language, language, sizeof(l->language) - 1);
-					strncpy(l->musicclass, musicclass, sizeof(l->musicclass)-1);
-					strncpy(l->mailbox, mailbox, sizeof(l->mailbox)-1);
-					strncpy(l->mailbox, mailbox, sizeof(l->mailbox)-1);
+					ast_copy_string(l->context, context, sizeof(l->context));
+					ast_copy_string(l->cid_num, cid_num, sizeof(l->cid_num));
+					ast_copy_string(l->cid_name, cid_name, sizeof(l->cid_name));
+					ast_copy_string(l->label, linelabel, sizeof(l->label));
+					ast_copy_string(l->language, language, sizeof(l->language));
+					ast_copy_string(l->musicclass, musicclass, sizeof(l->musicclass));
+					ast_copy_string(l->mailbox, mailbox, sizeof(l->mailbox));
+					ast_copy_string(l->mailbox, mailbox, sizeof(l->mailbox));
 					if (!ast_strlen_zero(mailbox)) {
 						if (option_verbose > 2)
 							ast_verbose(VERBOSE_PREFIX_3 "Setting mailbox '%s' on %s@%s\n", mailbox, d->name, l->name);
@@ -1600,37 +1942,13 @@
 					l->threewaycalling = threewaycalling;
 					l->mwiblink = mwiblink;
 					l->onhooktime = time(NULL);
-					l->instance = 1;
+					l->instance = lineInstance++;
 					/* ASSUME we're onhook at this point */
 					l->hookstate = SKINNY_ONHOOK;
+					l->nat = nat;
 
-					for (i = 0; i < MAX_SUBS; i++) {
-						sub = malloc(sizeof(struct skinny_subchannel));
-						if (sub) {
-							if (option_verbose > 2)
-								ast_verbose(VERBOSE_PREFIX_3 "Allocating Skinny subchannel '%d' on %s@%s\n", i, l->name, d->name);
-							memset(sub, 0, sizeof(struct skinny_subchannel));
-							ast_mutex_init(&sub->lock);
-							sub->parent = l;
-							/* Make a call*ID */
-							sub->callid = callnums;
-							callnums++;
-							sub->cxmode = SKINNY_CX_INACTIVE;
-							sub->nat = nat;
-							sub->next = l->sub;
-							l->sub = sub;
-						} else {
-							/* XXX Should find a way to clean up our memory */
-							ast_log(LOG_WARNING, "Out of memory allocating subchannel");
-							return NULL;
-						}
-					}
 					l->next = d->lines;
 					d->lines = l;
-				} else {
-					/* XXX Should find a way to clean up our memory */
-					ast_log(LOG_WARNING, "Out of memory allocating line");
-					return NULL;
 				}
 			} else {
 				ast_log(LOG_WARNING, "Don't know keyword '%s' at line %d\n", v->name, v->lineno);
@@ -1642,16 +1960,20 @@
 			ast_log(LOG_ERROR, "A Skinny device must have at least one line!\n");
 			return NULL;
 		}
-		if (d->addr.sin_addr.s_addr && !ntohs(d->addr.sin_port)) {
+		if (/*d->addr.sin_addr.s_addr && */!ntohs(d->addr.sin_port)) {
 			d->addr.sin_port = htons(DEFAULT_SKINNY_PORT);
 		}
+#if 0
+		/* I don't think we need this anymore at all, since d->ourip is set in skinny_register now */
 		if (d->addr.sin_addr.s_addr) {
+			/* XXX See note above, in 'host' option. */
 			if (ast_ouraddrfor(&d->addr.sin_addr, &d->ourip)) {
-				memcpy(&d->ourip, &__ourip, sizeof(d->ourip));
+				d->ourip = __ourip;
 			}
 		} else {
-			memcpy(&d->ourip, &__ourip, sizeof(d->ourip));
+			d->ourip = __ourip;
 		}
+#endif
 	}
 	return d;
 }
@@ -1659,6 +1981,8 @@
 static int skinny_register(skinny_req *req, struct skinnysession *s)
 {
 	struct skinny_device *d;
+	struct sockaddr_in sin;
+	socklen_t slen;
 
 	ast_mutex_lock(&devicelock);
 	for (d = devices; d; d = d->next) {
@@ -1667,19 +1991,45 @@
 			s->device = d;
 			d->type = letohl(req->data.reg.type);
 			if (ast_strlen_zero(d->version_id)) {
-				strncpy(d->version_id, version_id, sizeof(d->version_id) - 1);
+				ast_copy_string(d->version_id, version_id, sizeof(d->version_id));
 			}
 			d->registered = 1;
 			d->session = s;
+
+			slen = sizeof(sin);
+			if (getsockname(s->fd, (struct sockaddr *)&sin, &slen)) {
+				ast_log(LOG_WARNING, "Cannot get socket name\n");
+				sin.sin_addr = __ourip;
+			}
+			d->ourip = sin.sin_addr;
 			break;
 		}
 	}
 	ast_mutex_unlock(&devicelock);
-	return d ? 1 : 0;
+	if (!d) {
+		return 0;
+	}
+	return 1;
 }
 
+static int skinny_unregister(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d;
+
+	d = s->device;
+
+	if (d) {
+		d->session = NULL;
+		d->registered = 0;
+	}
+
+	return -1; /* main loop will destroy the session */
+}
+
 static void start_rtp(struct skinny_subchannel *sub)
 {
+	struct skinny_line *l = sub->parent;
+	struct skinny_device *d = l->parent;
 	ast_mutex_lock(&sub->lock);
 	/* Allocate the RTP */
 	sub->rtp = ast_rtp_new(sched, io, 1, 0);
@@ -1687,10 +2037,10 @@
 		sub->owner->fds[0] = ast_rtp_fd(sub->rtp);
 	}
 	if (sub->rtp) {
-		ast_rtp_setnat(sub->rtp, sub->nat);
+		ast_rtp_setnat(sub->rtp, l->nat);
 	}
 	/* Create the RTP connection */
-	transmit_connect(sub->parent->parent->session);
+	transmit_connect(d->session, sub);
  	ast_mutex_unlock(&sub->lock);
 }
 
@@ -1699,7 +2049,8 @@
 	struct ast_channel *chan = data;
 	struct skinny_subchannel *sub = chan->tech_pvt;
 	struct skinny_line *l = sub->parent;
-	struct skinnysession *s = l->parent->session;
+	struct skinny_device *d = l->parent;
+	struct skinnysession *s = d->session;
 	char exten[AST_MAX_EXTENSION] = "";
 	int len = 0;
 	int timeout = firstdigittimeout;
@@ -1707,14 +2058,13 @@
 	int getforward=0;
 
 	if (option_verbose > 2)
-		ast_verbose( VERBOSE_PREFIX_3 "Starting simple switch on '%s@%s'\n", l->name, l->parent->name);
+		ast_verbose( VERBOSE_PREFIX_3 "Starting simple switch on '%s@%s'\n", l->name, d->name);
 	while (len < AST_MAX_EXTENSION-1) {
 		res = ast_waitfordigit(chan, timeout);
 		timeout = 0;
 		if (res < 0) {
-			if (skinnydebug) {
-				ast_verbose("Skinny(%s@%s): waitfordigit returned < 0\n", l->name, l->parent->name);
-			}
+			if (skinnydebug)
+				ast_verbose("Skinny(%s@%s): waitfordigit returned < 0\n", l->name, d->name);
 			ast_indicate(chan, -1);
 			ast_hangup(chan);
 			return NULL;
@@ -1729,7 +2079,7 @@
 			if (!res || !ast_matchmore_extension(chan, chan->context, exten, 1, l->cid_num)) {
 				if (getforward) {
 					/* Record this as the forwarding extension */
-					strncpy(l->call_forward, exten, sizeof(l->call_forward) - 1);
+					ast_copy_string(l->call_forward, exten, sizeof(l->call_forward));
 					if (option_verbose > 2)
 						ast_verbose(VERBOSE_PREFIX_3 "Setting call forward to '%s' on channel %s\n",
 							l->call_forward, chan->name);
@@ -1745,20 +2095,21 @@
 					len = 0;
 					getforward = 0;
 				} else {
-					strncpy(chan->exten, exten, sizeof(chan->exten)-1);
+					ast_copy_string(chan->exten, exten, sizeof(chan->exten));
+					ast_copy_string(l->lastnumberdialed, exten, sizeof(l->lastnumberdialed));
 					if (!ast_strlen_zero(l->cid_num)) {
 						if (!l->hidecallerid) {
 							chan->cid.cid_num = strdup(l->cid_num);
 							chan->cid.cid_ani = strdup(l->cid_num);
 						}
-						ast_setstate(chan, AST_STATE_RING);
-						res = ast_pbx_run(chan);
-						if (res) {
-							ast_log(LOG_WARNING, "PBX exited non-zero\n");
-							transmit_tone(s, SKINNY_REORDER);
-						}
-						return NULL;
 					}
+					ast_setstate(chan, AST_STATE_RING);
+					res = ast_pbx_run(chan);
+					if (res) {
+						ast_log(LOG_WARNING, "PBX exited non-zero\n");
+						transmit_tone(s, SKINNY_REORDER);
+					}
+					return NULL;
 				}
 			} else {
 				/* It's a match, but they just typed a digit, and there is an ambiguous match,
@@ -1770,122 +2121,6 @@
 			transmit_tone(s, SKINNY_REORDER);
 			ast_hangup(chan);
 			return NULL;
-		} else if (l->callwaiting && !strcmp(exten, "*70")) {
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Disabling call waiting on %s\n", chan->name);
-			/* Disable call waiting if enabled */
-			l->callwaiting = 0;
-			transmit_tone(s, SKINNY_DIALTONE);
-			len = 0;
-			memset(exten, 0, sizeof(exten));
-			timeout = firstdigittimeout;
-		} else if (!strcmp(exten,ast_pickup_ext())) {
-			/* Scan all channels and see if any there
-			 * ringing channels with that have call groups
-			 * that equal this channels pickup group
-			 */
-			if (ast_pickup_call(chan)) {
-				ast_log(LOG_WARNING, "No call pickup possible...\n");
-				transmit_tone(s, SKINNY_REORDER);
-			}
-			ast_hangup(chan);
-			return NULL;
-		} else if (!l->hidecallerid && !strcmp(exten, "*67")) {
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Disabling Caller*ID on %s\n", chan->name);
-			/* Disable Caller*ID if enabled */
-			l->hidecallerid = 1;
-			if (chan->cid.cid_num) {
-				free(chan->cid.cid_num);
-			}
-			chan->cid.cid_num = NULL;
-			if (chan->cid.cid_name) {
-				free(chan->cid.cid_name);
-			}
-			chan->cid.cid_name = NULL;
-			transmit_tone(s, SKINNY_DIALTONE);
-			len = 0;
-			memset(exten, 0, sizeof(exten));
-			timeout = firstdigittimeout;
-		} else if (l->callreturn && !strcmp(exten, "*69")) {
-			res = 0;
-			if (!ast_strlen_zero(l->lastcallerid)) {
-				res = ast_say_digit_str(chan, l->lastcallerid, "", chan->language);
-			}
-			if (!res) {
-				transmit_tone(s, SKINNY_DIALTONE);
-			}
-			break;
-		} else if (!strcmp(exten, "*78")) {
-			/* Do not disturb */
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Enabled DND on channel %s\n", chan->name);
-			transmit_tone(s, SKINNY_DIALTONE);
-			l->dnd = 1;
-			getforward = 0;
-			memset(exten, 0, sizeof(exten));
-			len = 0;
-		} else if (!strcmp(exten, "*79")) {
-			/* Do not disturb */
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Disabled DND on channel %s\n", chan->name);
-			transmit_tone(s, SKINNY_DIALTONE);
-			l->dnd = 0;
-			getforward = 0;
-			memset(exten, 0, sizeof(exten));
-			len = 0;
-		} else if (l->cancallforward && !strcmp(exten, "*72")) {
-			transmit_tone(s, SKINNY_DIALTONE);
-			getforward = 1;
-			memset(exten, 0, sizeof(exten));
-			len = 0;
-		} else if (l->cancallforward && !strcmp(exten, "*73")) {
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Cancelling call forwarding on channel %s\n", chan->name);
-			transmit_tone(s, SKINNY_DIALTONE);
-			memset(l->call_forward, 0, sizeof(l->call_forward));
-			getforward = 0;
-			memset(exten, 0, sizeof(exten));
-			len = 0;
-		} else if (!strcmp(exten, ast_parking_ext()) &&
-			sub->next->owner &&
-			ast_bridged_channel(sub->next->owner)) {
-			/* This is a three way call, the main call being a real channel,
-			   and we're parking the first call. */
-			ast_masq_park_call(ast_bridged_channel(sub->next->owner), chan, 0, NULL);
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Parking call to '%s'\n", chan->name);
-			break;
-		} else if (!ast_strlen_zero(l->lastcallerid) && !strcmp(exten, "*60")) {
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Blacklisting number %s\n", l->lastcallerid);
-			res = ast_db_put("blacklist", l->lastcallerid, "1");
-			if (!res) {
-				transmit_tone(s, SKINNY_DIALTONE);
-				memset(exten, 0, sizeof(exten));
-				len = 0;
-			}
-		} else if (l->hidecallerid && !strcmp(exten, "*82")) {
-			if (option_verbose > 2)
-				ast_verbose(VERBOSE_PREFIX_3 "Enabling Caller*ID on %s\n", chan->name);
-			/* Enable Caller*ID if enabled */
-			l->hidecallerid = 0;
-			if (chan->cid.cid_num) {
-				free(chan->cid.cid_num);
-			}
-			if (!ast_strlen_zero(l->cid_num)) {
-				chan->cid.cid_num = strdup(l->cid_num);
-			}
-			if (chan->cid.cid_name) {
-				free(chan->cid.cid_name);
-			}
-			if (!ast_strlen_zero(l->cid_name)) {
-				chan->cid.cid_name = strdup(l->cid_name);
-			}
-			transmit_tone(s, SKINNY_DIALTONE);
-			len = 0;
-			memset(exten, 0, sizeof(exten));
-			timeout = firstdigittimeout;
 		} else if (!ast_canmatch_extension(chan, chan->context, exten, 1, chan->cid.cid_num) &&
 			   ((exten[0] != '*') || (!ast_strlen_zero(exten) > 2))) {
 			ast_log(LOG_WARNING, "Can't match [%s] from '%s' in context %s\n", exten, chan->cid.cid_num ? chan->cid.cid_num : "<Unknown Caller>", chan->context);
@@ -1911,15 +2146,12 @@
 {
 	int res = 0;
 	int tone = 0;
-	struct skinny_line *l;
-	struct skinny_subchannel *sub;
-	struct skinnysession *session;
+	struct skinny_subchannel *sub = ast->tech_pvt;
+	struct skinny_line *l = sub->parent;
+	struct skinny_device *d = l->parent;
+	struct skinnysession *session = d->session;
 
-	sub = ast->tech_pvt;
-	l = sub->parent;
-	session = l->parent->session;
-
-	if (!l->parent->registered) {
+	if (!d->registered) {
 		ast_log(LOG_ERROR, "Device not registered, cannot call %s\n", dest);
 		return -1;
 	}
@@ -1929,9 +2161,8 @@
 		return -1;
 	}
 
-	if (skinnydebug) {
+	if (skinnydebug)
 		ast_verbose(VERBOSE_PREFIX_3 "skinny_call(%s)\n", ast->name);
-	}
 
 	if (l->dnd) {
 		ast_queue_control(ast, AST_CONTROL_BUSY);
@@ -1953,41 +2184,12 @@
 	transmit_lamp_indication(session, STIMULUS_LINE, l->instance, SKINNY_LAMP_BLINK);
 	transmit_ringer_mode(session, SKINNY_RING_INSIDE);
 
-	if (ast->cid.cid_num) {
-		char ciddisplay[41];
-		char *work;
-		size_t size = sizeof(ciddisplay);
-		int l = strlen(ast->cid.cid_num);
-
-		/* For now, we'll assume that if it is 10 numbers, it is a standard NANPA number */
-		if (l == 10) {
-			ast_build_string(&work, &size, "(xxx)xxx-xxxx      %s",
-					 ast->cid.cid_name ? ast->cid.cid_name : "");
-			memcpy(&ciddisplay[1], ast->cid.cid_num, 3);
-			memcpy(&ciddisplay[5], &ast->cid.cid_num[3], 3);
-			memcpy(&ciddisplay[9], &ast->cid.cid_num[6], 4);
-		} else {
-			if (l < sizeof(ciddisplay)) {
-				ast_build_string(&work, &size, "%s -- %s", ast->cid.cid_num,
-						 S_OR(ast->cid.cid_name, ""));
-			} else {
-				strncpy(ciddisplay, "Number too long!", 15);	/* XXX what is magic in 15 ? */
-			}
-		}
-		if (skinnydebug) {
-			ast_verbose("Trying to send: '%s'\n",ciddisplay);
-		}
-		transmit_displaymessage(session, ciddisplay);
-	} else {
-		transmit_displaymessage(session, "Unknown Name");
-	}
 	transmit_tone(session, tone);
 	transmit_callstate(session, l->instance, SKINNY_RINGIN, sub->callid);
 	transmit_displaypromptstatus(session, "Ring-In", 0, l->instance, sub->callid);
 	transmit_callinfo(session, ast->cid.cid_name, ast->cid.cid_num, l->cid_name, l->cid_num, l->instance, sub->callid, 1);
+	transmit_selectsoftkeys(session, l->instance, sub->callid, KEYDEF_RINGIN);
 
-	/* XXX need to deal with softkeys */
-
 	ast_setstate(ast, AST_STATE_RINGING);
 	ast_queue_control(ast, AST_CONTROL_RINGING);
 	sub->outgoing = 1;
@@ -1997,24 +2199,27 @@
 static int skinny_hangup(struct ast_channel *ast)
 {
 	struct skinny_subchannel *sub = ast->tech_pvt;
-	struct skinny_line *l = sub->parent;
-	struct skinnysession *s = l->parent->session;
+	struct skinny_line *l;
+	struct skinny_device *d;
+	struct skinnysession *s;
 
-	if (skinnydebug) {
-		ast_verbose("skinny_hangup(%s) on %s@%s\n", ast->name, l->name, l->parent->name);
-	}
-	if (!ast->tech_pvt) {
+	if (!sub) {
 		ast_log(LOG_DEBUG, "Asked to hangup channel not connected\n");
 		return 0;
 	}
+	l = sub->parent;
+	d = l->parent;
+	s = d->session;
+	if (skinnydebug)
+		ast_verbose("skinny_hangup(%s) on %s@%s\n", ast->name, l->name, d->name);
 
-	if (l->parent->registered) {
-		if ((sub->parent->type = TYPE_LINE) && (sub->parent->hookstate == SKINNY_OFFHOOK)) {
-			sub->parent->hookstate = SKINNY_ONHOOK;
+	if (d->registered) {
+		if ((l->type = TYPE_LINE) && (l->hookstate == SKINNY_OFFHOOK)) {
+			l->hookstate = SKINNY_ONHOOK;
 			transmit_callstate(s, l->instance, SKINNY_ONHOOK, sub->callid);
 			transmit_lamp_indication(s, STIMULUS_LINE, l->instance, SKINNY_LAMP_OFF);
 			transmit_speaker_mode(s, SKINNY_SPEAKEROFF);
-		} else if ((sub->parent->type = TYPE_LINE) && (sub->parent->hookstate == SKINNY_ONHOOK)) {
+		} else if ((l->type = TYPE_LINE) && (l->hookstate == SKINNY_ONHOOK)) {
 			transmit_callstate(s, l->instance, SKINNY_ONHOOK, sub->callid);
 			transmit_speaker_mode(s, SKINNY_SPEAKEROFF);
 			transmit_ringer_mode(s, SKINNY_RING_OFF);
@@ -2041,37 +2246,39 @@
 	int res = 0;
 	struct skinny_subchannel *sub = ast->tech_pvt;
 	struct skinny_line *l = sub->parent;
-	struct skinnysession *s = l->parent->session;
+	struct skinny_device *d = l->parent;
+	struct skinnysession *s = d->session;
 
 	sub->cxmode = SKINNY_CX_SENDRECV;
 	if (!sub->rtp) {
 		start_rtp(sub);
 	}
-	if (skinnydebug) {
-		ast_verbose("skinny_answer(%s) on %s@%s-%d\n", ast->name, l->name, l->parent->name, sub->callid);
-	}
+	if (skinnydebug)
+		ast_verbose("skinny_answer(%s) on %s@%s-%d\n", ast->name, l->name, d->name, sub->callid);
 	if (ast->_state != AST_STATE_UP) {
 		ast_setstate(ast, AST_STATE_UP);
 	}
-	transmit_tone(s, SKINNY_NOTONE);
+	transmit_tone(s, SKINNY_SILENCE);
 	transmit_callstate(s, l->instance, SKINNY_CONNECTED, sub->callid);
 	transmit_displaypromptstatus(s, "Connected", 0, l->instance, sub->callid);
 	return res;
 }
 
+/* Retrieve audio/etc from channel.  Assumes sub->lock is already held. */
 static struct ast_frame *skinny_rtp_read(struct skinny_subchannel *sub)
 {
-	/* Retrieve audio/etc from channel.  Assumes sub->lock is already held. */
+	struct ast_channel *ast = sub->owner;
 	struct ast_frame *f;
+
 	f = ast_rtp_read(sub->rtp);
-	if (sub->owner) {
+	if (ast) {
 		/* We already hold the channel lock */
 		if (f->frametype == AST_FRAME_VOICE) {
-			if (f->subclass != sub->owner->nativeformats) {
+			if (f->subclass != ast->nativeformats) {
 				ast_log(LOG_DEBUG, "Oooh, format changed to %d\n", f->subclass);
-				sub->owner->nativeformats = f->subclass;
-				ast_set_read_format(sub->owner, sub->owner->readformat);
-				ast_set_write_format(sub->owner, sub->owner->writeformat);
+				ast->nativeformats = f->subclass;
+				ast_set_read_format(ast, ast->readformat);
+				ast_set_write_format(ast, ast->writeformat);
 			}
 		}
 	}
@@ -2132,10 +2339,12 @@
 {
 #if 0
 	struct skinny_subchannel *sub = ast->tech_pvt;
+	struct skinny_line *l = sub->parent;
+	struct skinny_device *d = l->parent;
 	int tmp;
 	/* not right */
 	sprintf(tmp, "%d", digit);
-	transmit_tone(sub->parent->parent->session, digit);
+	transmit_tone(d->session, digit);
 #endif
 	return -1;
 }
@@ -2190,11 +2399,11 @@
 {
 	struct skinny_subchannel *sub = ast->tech_pvt;
 	struct skinny_line *l = sub->parent;
-	struct skinnysession *s = l->parent->session;
+	struct skinny_device *d = l->parent;
+	struct skinnysession *s = d->session;
 
-	if (skinnydebug) {
+	if (skinnydebug)
 		ast_verbose(VERBOSE_PREFIX_3 "Asked to indicate '%s' condition on channel %s\n", control2str(ind), ast->name);
-	}
 	switch(ind) {
 	case AST_CONTROL_RINGING:
 		if (ast->_state != AST_STATE_UP) {
@@ -2249,23 +2458,45 @@
 	return 0;
 }
 
-static struct ast_channel *skinny_new(struct skinny_subchannel *sub, int state)
+static struct ast_channel *skinny_new(struct skinny_line *l, int state)
 {
 	struct ast_channel *tmp;
-	struct skinny_line *l = sub->parent;
+	struct skinny_subchannel *sub;
+	struct skinny_device *d = l->parent;
 	int fmt;
-	l = sub->parent;
+
 	tmp = ast_channel_alloc(1);
-	if (tmp) {
+	if (!tmp) {
+		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
+		return NULL;
+	} else {
+		sub = ast_calloc(1, sizeof(struct skinny_subchannel));
+		if (!sub) {
+			ast_log(LOG_WARNING, "Unable to allocate Skinny subchannel\n");
+			return NULL;
+		} else {
+			ast_mutex_init(&sub->lock);
+
+			sub->owner = tmp;
+			sub->callid = callnums++;
+			d->lastlineinstance = l->instance;
+			d->lastcallreference = sub->callid;
+			sub->cxmode = SKINNY_CX_INACTIVE;
+			sub->nat = l->nat;
+			sub->parent = l;
+
+			sub->next = l->sub;
+			l->sub = sub;
+		}
 		tmp->tech = &skinny_tech;
+		tmp->tech_pvt = sub;
 		tmp->nativeformats = l->capability;
 		if (!tmp->nativeformats)
 			tmp->nativeformats = capability;
 		fmt = ast_best_codec(tmp->nativeformats);
-		if (skinnydebug) {
+		if (skinnydebug)
 			ast_verbose("skinny_new: tmp->nativeformats=%d fmt=%d\n", tmp->nativeformats, fmt);
-		}
-		ast_string_field_build(tmp, name, "Skinny/%s@%s-%d", l->name, l->parent->name, sub->callid);
+		ast_string_field_build(tmp, name, "Skinny/%s@%s-%d", l->name, d->name, sub->callid);
 		if (sub->rtp) {
 			tmp->fds[0] = ast_rtp_fd(sub->rtp);
 		}
@@ -2277,14 +2508,13 @@
 		tmp->rawwriteformat = fmt;
 		tmp->readformat = fmt;
 		tmp->rawreadformat = fmt;
-		tmp->tech_pvt = sub;
 		if (!ast_strlen_zero(l->language))
 			ast_string_field_set(tmp, language, l->language);
 		if (!ast_strlen_zero(l->accountcode))
 			ast_string_field_set(tmp, accountcode, l->accountcode);
 		if (l->amaflags)
 			tmp->amaflags = l->amaflags;
-		sub->owner = tmp;
+
 		ast_mutex_lock(&usecnt_lock);
 		usecnt++;
 		ast_mutex_unlock(&usecnt_lock);
@@ -2308,532 +2538,1238 @@
 		}
 
 		/* Configure the new channel jb */
-		if (tmp && sub && sub->rtp)
+		if (tmp && sub->rtp)
 			ast_jb_configure(tmp, &global_jbconf);
-	} else {
-		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
 	}
 	return tmp;
 }
 
-static int handle_message(skinny_req *req, struct skinnysession *s)
+static int handle_keep_alive_message(skinny_req *req, struct skinnysession *s)
 {
-	struct skinny_subchannel *sub;
-	struct ast_channel *c;
+	if (!(req = req_alloc(0, KEEP_ALIVE_ACK_MESSAGE)))
+		return -1;
+
+	transmit_response(s, req);
+	do_housekeeping(s);
+	return 1;
+}
+
+static int handle_register_message(skinny_req *req, struct skinnysession *s)
+{
+	char name[16];
+	int res;
+
+	memcpy(&name, req->data.reg.name, sizeof(name));
+
+	res = skinny_register(req, s);
+	if (!res) {
+		ast_log(LOG_ERROR, "Rejecting Device %s: Device not found\n", name);
+		if (!(req = req_alloc(sizeof(register_rej_message), REGISTER_REJ_MESSAGE)))
+			return -1;
+
+		snprintf(req->data.regrej.errMsg, sizeof(req->data.regrej.errMsg), "No Authority: %s", name);
+		transmit_response(s, req);
+		return 0;
+	}
+	if (option_verbose > 2)
+		ast_verbose(VERBOSE_PREFIX_3 "Device '%s' successfully registered\n", name);
+
+	if (!(req = req_alloc(sizeof(register_ack_message), REGISTER_ACK_MESSAGE)))
+		return -1;
+
+	req->data.regack.res[0] = '0';
+	req->data.regack.res[1] = '\0';
+	req->data.regack.keepAlive = htolel(keep_alive);
+	ast_copy_string(req->data.regack.dateTemplate, date_format, sizeof(req->data.regack.dateTemplate));
+	req->data.regack.res2[0] = '0';
+	req->data.regack.res2[1] = '\0';
+	req->data.regack.secondaryKeepAlive = htolel(keep_alive);
+	transmit_response(s, req);
+	if (skinnydebug)
+		ast_verbose("Requesting capabilities\n");
+
+	if (!(req = req_alloc(0, CAPABILITIES_REQ_MESSAGE)))
+		return -1;
+
+	transmit_response(s, req);
+
+	return res;
+}
+
+static int handle_ip_port_message(skinny_req *req, struct skinnysession *s)
+{
+	/* no response necessary */
+	return 1;
+}
+
+static int handle_keypad_button_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_subchannel *sub = NULL;
+	struct skinny_line *l;
 	struct ast_frame f = { 0, };
-	struct sockaddr_in sin;
-	struct sockaddr_in us;
-	struct skinny_line *lines;
-	char name[16];
-	char addr[4];
 	char d;
-	char iabuf[INET_ADDRSTRLEN];
 	int digit;
-	int res=0;
-	int speedDialNum;
-	int lineNumber;
-	int stimulus;
-	int stimulusInstance;
-	int status;
-	int port;
-	int i;
-	time_t timer;
-	struct tm *cmtime;
-	pthread_t t;
-	button_defs_t *b, *buse;
+	int lineInstance;
+	int callReference;
 
-	if ((!s->device) && (letohl(req->e) != REGISTER_MESSAGE && letohl(req->e) != ALARM_MESSAGE)) {
-		ast_log(LOG_WARNING, "Client sent message #%d without first registering.\n", req->e);
-		free(req);
+	digit = letohl(req->data.keypad.button);
+	lineInstance = letohl(req->data.keypad.lineInstance);
+	callReference = letohl(req->data.keypad.callReference);
+	f.frametype = AST_FRAME_DTMF;
+	if (digit == 14) {
+		d = '*';
+	} else if (digit == 15) {
+		d = '#';
+	} else if (digit >=0 && digit <= 9) {
+		d = '0' + digit;
+	} else {
+		/* digit=10-13 (A,B,C,D ?), or
+		 * digit is bad value
+		 *
+		 * probably should not end up here, but set
+		 * value for backward compatibility, and log
+		 * a warning.
+		 */
+		d = '0' + digit;
+		ast_log(LOG_WARNING, "Unsupported digit %d\n", digit);
+	}
+	f.subclass = d;
+	f.src = "skinny";
+
+	if (lineInstance && callReference)
+		sub = find_subchannel_by_instance_reference(s->device, lineInstance, callReference);
+
+	if (!sub)
 		return 0;
+
+	l = sub->parent;
+	if (sub->owner) {
+		/* XXX MUST queue this frame to all lines in threeway call if threeway call is active */
+		ast_queue_frame(sub->owner, &f);
+		/* XXX This seriously needs to be fixed */
+		if (sub->next && sub->next->owner) {
+			ast_queue_frame(sub->next->owner, &f);
+		}
+	} else {
+		if (skinnydebug)
+			ast_verbose("No owner: %s\n", l->name);
 	}
+	return 1;
+}
 
-	switch(letohl(req->e))	{
-	case ALARM_MESSAGE:
-		/* no response necessary */
-		break;
-	case REGISTER_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Device %s is attempting to register\n", req->data.reg.name);
+static int handle_stimulus_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	struct skinny_subchannel *sub;
+	/*struct skinny_speeddial *sd;*/
+	struct ast_channel *c;
+	pthread_t t;
+	int event;
+	int instance;
+	int unknown1;
+	/*int res = 0;*/
+
+	event = letohl(req->data.stimulus.stimulus);
+	instance = letohl(req->data.stimulus.stimulusInstance);
+	unknown1 = letohl(req->data.stimulus.unknown1); /* No clue.. */
+	if (skinnydebug)
+		ast_verbose("unknown1 in handle_stimulus_message is '%d'\n", unknown1);
+
+	sub = find_subchannel_by_instance_reference(d, d->lastlineinstance, d->lastcallreference);
+
+	if (!sub) {
+		l = find_line_by_instance(d, d->lastlineinstance);
+		if (!l) {
+			return 0;
 		}
-		res = skinny_register(req, s);
-		if (!res) {
-			ast_log(LOG_ERROR, "Rejecting Device %s: Device not found\n", req->data.reg.name);
-			memcpy(&name, req->data.reg.name, sizeof(req->data.reg.name));
-			memset(req, 0, sizeof(skinny_req));
-			req->len = htolel(sizeof(register_rej_message)+4);
-			req->e = htolel(REGISTER_REJ_MESSAGE);
-			snprintf(req->data.regrej.errMsg, sizeof(req->data.regrej.errMsg), "No Authority: %s", name);
-			transmit_response(s, req);
-			break;
-		}
-		if (option_verbose > 2)
-			ast_verbose(VERBOSE_PREFIX_3 "Device '%s' successfuly registered\n", s->device->name);
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(register_ack_message)+4);
-		req->e = htolel(REGISTER_ACK_MESSAGE);
-		req->data.regack.res[0] = '0';
-		req->data.regack.res[1] = '\0';
-		req->data.regack.keepAlive = htolel(keep_alive);
-		ast_copy_string(req->data.regack.dateTemplate, date_format, sizeof(req->data.regack.dateTemplate));
-		req->data.regack.res2[0] = '0';
-		req->data.regack.res2[1] = '\0';
-		req->data.regack.secondaryKeepAlive = htolel(keep_alive);
-		transmit_response(s, req);
-		if (skinnydebug) {
-			ast_verbose("Requesting capabilities\n");
-		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(4);
-		req->e = htolel(CAPABILITIES_REQ_MESSAGE);
-		transmit_response(s, req);
-		break;
-	case UNREGISTER_MESSAGE:
-		/* XXX Actually unregister the device */
-		break;
-	case IP_PORT_MESSAGE:
-		/* no response necessary */
-		break;
-	case STIMULUS_MESSAGE:
-		stimulus = letohl(req->data.stimulus.stimulus);
-		stimulusInstance = letohl(req->data.stimulus.stimulusInstance);
+	} else {
+		l = sub->parent;
+	}
 
-		switch(stimulus) {
-		case STIMULUS_REDIAL:
-			/* If we can keep an array of dialed frames we can implement a quick
-			   and dirty redial, feeding the frames we last got into the queue
-			   function */
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Redial(%d)\n", stimulusInstance);
-			}
-			break;
-		case STIMULUS_SPEEDDIAL:
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: SpeedDial(%d)\n", stimulusInstance);
-			}
-			break;
-		case STIMULUS_HOLD:
-			/* start moh? set RTP to 0.0.0.0? */
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Hold(%d)\n", stimulusInstance);
-			}
-			break;
-		case STIMULUS_TRANSFER:
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Transfer(%d)\n", stimulusInstance);
-			}
+	switch(event) {
+	case STIMULUS_REDIAL:
+		/* If we can keep an array of dialed frames we can implement a quick
+		   and dirty redial, feeding the frames we last got into the queue
+		   function */
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Redial(%d)\n", instance);
+
+#if 0
+		c = skinny_new(l, AST_STATE_DOWN);
+		if(c) {
+			sub = c->tech_pvt;
+			l = sub->parent;
+			transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+			if (skinnydebug)
+				ast_verbose("Attempting to Clear display on Skinny %s@%s\n", l->name, d->name);
+			transmit_displaymessage(s, NULL); /* clear display */
 			transmit_tone(s, SKINNY_DIALTONE);
-			/* XXX figure out how to transfer */
-			break;
-		case STIMULUS_CONFERENCE:
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Transfer(%d)\n", stimulusInstance);
-			}
-			transmit_tone(s, SKINNY_DIALTONE);
-			/* XXX determine the best way to pull off a conference.  Meetme? */
-			break;
-		case STIMULUS_VOICEMAIL:
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Voicemail(%d)\n", stimulusInstance);
-			}
-			/* XXX Find and dial voicemail extension */
-			break;
-		case STIMULUS_CALLPARK:
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Park Call(%d)\n", stimulusInstance);
-			}
-			/* XXX Park the call */
-			break;
-		case STIMULUS_FORWARDALL:
-			/* Why is DND under FORWARDALL ? */
 
-			/* Do not disturb */
-			transmit_tone(s, SKINNY_DIALTONE);
-			if (s->device->lines->dnd != 0){
-				if (option_verbose > 2)
-					ast_verbose(VERBOSE_PREFIX_3 "Disabling DND on %s@%s\n",find_subchannel_by_line(s->device->lines)->parent->name,find_subchannel_by_line(s->device->lines)->parent->name);
-				s->device->lines->dnd = 0;
-				transmit_lamp_indication(s, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_ON);
-				transmit_displaynotify(s, "DnD disabled",10);
-			} else {
-				if (option_verbose > 2)
-					ast_verbose(VERBOSE_PREFIX_3 "Enabling DND on %s@%s\n",find_subchannel_by_line(s->device->lines)->parent->name,find_subchannel_by_line(s->device->lines)->parent->name);
-				s->device->lines->dnd = 1;
-				transmit_lamp_indication(s, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_OFF);
-				transmit_displaynotify(s, "DnD enabled",10);
+			if (ast_strlen_zero(l->lastnumberdialed)) {
+				ast_log(LOG_WARNING, "Attempted redial, but no previously dialed number found.\n");
+				return 0;
 			}
-			break;
-		case STIMULUS_FORWARDBUSY:
-		case STIMULUS_FORWARDNOANSWER:
-			/* Gonna be fun, not */
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Forward (%d)\n", stimulusInstance);
+			if (!ast_ignore_pattern(c->context, l->lastnumberdialed)) {
+				transmit_tone(s, SKINNY_SILENCE);
 			}
-			break;
-		case STIMULUS_DISPLAY:
-			/* Not sure what this is */
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Display(%d)\n", stimulusInstance);
+			if (ast_exists_extension(c, c->context, l->lastnumberdialed, 1, l->cid_num)) {
+				if (!ast_matchmore_extension(c, c->context, l->lastnumberdialed, 1, l->cid_num)) {
+					ast_copy_string(c->exten, l->lastnumberdialed, sizeof(c->exten));
+					if (!ast_strlen_zero(l->cid_num)) {
+						if (!l->hidecallerid) {
+							c->cid.cid_num = strdup(l->cid_num);
+							c->cid.cid_ani = strdup(l->cid_num);
+						}
+					}
+					ast_setstate(c, AST_STATE_RING);
+					res = ast_pbx_run(c);
+					if (res) {
+						ast_log(LOG_WARNING, "PBX exited non-zero\n");
+						transmit_tone(s, SKINNY_REORDER);
+					}
+					break;
+				}
 			}
-			break;
-		case STIMULUS_LINE:
-			if (skinnydebug) {
-				ast_verbose("Received Stimulus: Line(%d)\n", stimulusInstance);
-			}
-			sub = find_subchannel_by_line(s->device->lines);
-			/* turn the speaker on */
-			transmit_speaker_mode(s, 1);
-		break;
-		default:
-			if (skinnydebug) {
-				ast_verbose("RECEIVED UNKNOWN STIMULUS:  %d(%d)\n", stimulus, stimulusInstance);
-			}
-			break;
+		} else {
+			ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", l->name, d->name);
 		}
+#endif
 		break;
-	case VERSION_REQ_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Version Request\n");
+	case STIMULUS_SPEEDDIAL:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: SpeedDial(%d)\n", instance);
+
+#if 0
+		if (!(sd = find_speeddial_by_instance(d, instance))) {
+			return 0;
 		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(version_res_message)+4);
-		req->e = htolel(VERSION_RES_MESSAGE);
-		snprintf(req->data.version.version, sizeof(req->data.version.version), s->device->version_id);
-		transmit_response(s, req);
-		break;
-	case SERVER_REQUEST_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Received Server Request\n");
-		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(server_res_message)+4);
-		req->e = htolel(SERVER_RES_MESSAGE);
-		memcpy(req->data.serverres.server[0].serverName, ourhost,
-				sizeof(req->data.serverres.server[0].serverName));
-		req->data.serverres.serverListenPort[0] = htolel(ourport);
-		req->data.serverres.serverIpAddr[0] = htolel(__ourip.s_addr);
-		transmit_response(s, req);
-		break;
-	case BUTTON_TEMPLATE_REQ_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Buttontemplate requested\n");
-		}
-		sub = find_subchannel_by_line(s->device->lines);
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->e = htolel(BUTTON_TEMPLATE_RES_MESSAGE);
-		req->len = htolel(sizeof(button_template_res_message)+4);
 
-		/* Find a matching button definition, default to first in the
-		   list */
-		buse = button_defs;
-		for(b=button_defs; b->type; b++) {
-			if (!strcmp(s->device->model, b->type)) {
-				buse = b;
+		c = skinny_new(l, AST_STATE_DOWN);
+		if(c) {
+			sub = c->tech_pvt;
+			l = sub->parent;
+			transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+			if (skinnydebug)
+				ast_verbose("Attempting to Clear display on Skinny %s@%s\n", l->name, d->name);
+			transmit_displaymessage(s, NULL); /* clear display */
+			transmit_tone(s, SKINNY_DIALTONE);
+
+			if (!ast_ignore_pattern(c->context, sd->exten)) {
+				transmit_tone(s, SKINNY_SILENCE);
 			}
-		}
-		req->data.buttontemplate.buttonOffset = 0;
-		req->data.buttontemplate.buttonCount = htolel(buse->num_buttons);
-		req->data.buttontemplate.totalButtonCount = htolel(buse->num_buttons);
-		for (i=0; i<42; i++) {
-			if (i < buse->num_buttons) {
-				memcpy(&(req->data.buttontemplate.definition[i]),
-					&(buse->button_def[i]),
-					sizeof(button_definition));
-			} else {
-				memcpy(&(req->data.buttontemplate.definition[i]),
-					&(button_def_none),
-					sizeof(button_definition));
+			if (ast_exists_extension(c, c->context, sd->exten, 1, l->cid_num)) {
+				if (!ast_matchmore_extension(c, c->context, sd->exten, 1, l->cid_num)) {
+					ast_copy_string(c->exten, sd->exten, sizeof(c->exten));
+					ast_copy_string(l->lastnumberdialed, sd->exten, sizeof(l->lastnumberdialed));
+					if (!ast_strlen_zero(l->cid_num)) {
+						if (!l->hidecallerid) {
+							c->cid.cid_num = strdup(l->cid_num);
+							c->cid.cid_ani = strdup(l->cid_num);
+						}
+					}
+					ast_setstate(c, AST_STATE_RING);
+					res = ast_pbx_run(c);
+					if (res) {
+						ast_log(LOG_WARNING, "PBX exited non-zero\n");
+						transmit_tone(s, SKINNY_REORDER);
+					}
+					break;
+				}
 			}
+		} else {
+			ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", l->name, d->name);
 		}
-
-		if (skinnydebug) {
-			ast_verbose("Sending %s template to %s@%s (%s)\n",
-						buse->type,
-						sub->parent->name,
-						sub->parent->parent->name,
-						s->device->model);
-		}
-		transmit_response(s, req);
+#endif
 		break;
-	case SOFT_KEY_SET_REQ_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Received SoftKeySetReq\n");
-		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(soft_key_sets)+4);
-		req->e = htolel(SOFT_KEY_SET_RES_MESSAGE);
-		req->data.softkeysets.softKeySetOffset = 0;
-		req->data.softkeysets.softKeySetCount = htolel(11);
-		req->data.softkeysets.totalSoftKeySetCount = htolel(11);
-		/* XXX Wicked hack XXX */
-		memcpy(req->data.softkeysets.softKeySetDefinition,
-			soft_key_set_hack,
-			sizeof(req->data.softkeysets.softKeySetDefinition));
-		transmit_response(s,req);
+	case STIMULUS_HOLD:
+		/* start moh? set RTP to 0.0.0.0? */
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Hold(%d)\n", instance);
 		break;
-	case SOFT_KEY_TEMPLATE_REQ_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Received SoftKey Template Request\n");
-		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(soft_key_template)+4);
-		req->e = htolel(SOFT_KEY_TEMPLATE_RES_MESSAGE);
-		req->data.softkeytemplate.softKeyOffset = 0;
-		req->data.softkeytemplate.softKeyCount	= htolel(sizeof(soft_key_template_default) / sizeof(soft_key_template_definition));
-		req->data.softkeytemplate.totalSoftKeyCount = htolel(sizeof(soft_key_template_default) / sizeof(soft_key_template_definition));
-		memcpy(req->data.softkeytemplate.softKeyTemplateDefinition,
-			soft_key_template_default,
-			sizeof(soft_key_template_default));
-		transmit_response(s,req);
+	case STIMULUS_TRANSFER:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Transfer(%d)\n", instance);
+		transmit_tone(s, SKINNY_DIALTONE);
+		/* XXX figure out how to transfer */
 		break;
-	case TIME_DATE_REQ_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Received Time/Date Request\n");
-		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(definetimedate_message)+4);
-		req->e = htolel(DEFINETIMEDATE_MESSAGE);
-		timer=time(NULL);
-		cmtime = localtime(&timer);
-		req->data.definetimedate.year = htolel(cmtime->tm_year+1900);
-		req->data.definetimedate.month = htolel(cmtime->tm_mon+1);
-		req->data.definetimedate.dayofweek = htolel(cmtime->tm_wday);
-		req->data.definetimedate.day = htolel(cmtime->tm_mday);
-		req->data.definetimedate.hour = htolel(cmtime->tm_hour);
-		req->data.definetimedate.minute = htolel(cmtime->tm_min);
-		req->data.definetimedate.seconds = htolel(cmtime->tm_sec);
-		transmit_response(s, req);
+	case STIMULUS_CONFERENCE:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Transfer(%d)\n", instance);
+		transmit_tone(s, SKINNY_DIALTONE);
+		/* XXX determine the best way to pull off a conference.  Meetme? */
 		break;
-	case SPEED_DIAL_STAT_REQ_MESSAGE:
-		/* Not really sure how Speed Dial's are different than the
-		   Softkey templates */
-		speedDialNum = letohl(req->data.speeddialreq.speedDialNumber);
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(speed_dial_stat_res_message)+4);
-		req->e = htolel(SPEED_DIAL_STAT_RES_MESSAGE);
-#if 0
-		/* XXX Do this right XXX */
-		/* If the redial function works the way I think it will, a modification of it
-		   can work here as well. Yikes. */
-		req->data.speeddialreq.speedDialNumber = speedDialNum;
-		snprintf(req->data.speeddial.speedDialDirNumber, sizeof(req->data.speeddial.speedDialDirNumber), "31337");
-		snprintf(req->data.speeddial.speedDialDisplayName, sizeof(req->data.speeddial.speedDialDisplayName),"Asterisk Rules!");
-#endif
-		transmit_response(s, req);
+	case STIMULUS_VOICEMAIL:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Voicemail(%d)\n", instance);
+		/* XXX Find and dial voicemail extension */
 		break;
-	case LINE_STATE_REQ_MESSAGE:
-		lineNumber = letohl(req->data.line.lineNumber);
-		if (skinnydebug) {
-			ast_verbose("Received LineStateReq\n");
-		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(line_stat_res_message)+4);
-		req->e = htolel(LINE_STAT_RES_MESSAGE);
-		sub = find_subchannel_by_line(s->device->lines);
-		if (!sub) {
-			ast_log(LOG_NOTICE, "No available lines on: %s\n", s->device->name);
-			return 0;
-		}
-		lines = sub->parent;
-		ast_mutex_lock(&devicelock);
-		for (i=1; i < lineNumber; i++) {
-			lines = lines->next;
-		}
-		ast_mutex_unlock(&devicelock);
-		req->data.linestat.linenumber = letohl(lineNumber);
-		memcpy(req->data.linestat.lineDirNumber, lines->name,
-				sizeof(req->data.linestat.lineDirNumber));
-		memcpy(req->data.linestat.lineDisplayName, lines->label,
-				sizeof(req->data.linestat.lineDisplayName));
-		transmit_response(s,req);
+	case STIMULUS_CALLPARK:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Park Call(%d)\n", instance);
+		/* XXX Park the call */
 		break;
-	case CAPABILITIES_RES_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Received CapabilitiesRes\n");
+	case STIMULUS_FORWARDALL:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Forward All(%d)\n", instance);
+		/* Why is DND under FORWARDALL? */
+		/* Because it's the same thing. */
+
+		/* Do not disturb */
+		transmit_tone(s, SKINNY_DIALTONE);
+		if (l->dnd != 0){
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Disabling DND on %s@%s\n", l->name, d->name);
+			l->dnd = 0;
+			transmit_lamp_indication(s, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_ON);
+			transmit_displaynotify(s, "DnD disabled", 10);
+		} else {
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Enabling DND on %s@%s\n", l->name, d->name);
+			l->dnd = 1;
+			transmit_lamp_indication(s, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_OFF);
+			transmit_displaynotify(s, "DnD enabled", 10);
 		}
-		/* XXX process the capabilites */
 		break;
-	case KEEP_ALIVE_MESSAGE:
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(4);
-		req->e = htolel(KEEP_ALIVE_ACK_MESSAGE);
-		transmit_response(s, req);
-		do_housekeeping(s);
+	case STIMULUS_FORWARDBUSY:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Forward Busy (%d)\n", instance);
 		break;
-	case OFFHOOK_MESSAGE:
-		transmit_ringer_mode(s,SKINNY_RING_OFF);
-		transmit_lamp_indication(s, STIMULUS_LINE, s->device->lines->instance, SKINNY_LAMP_ON);
-		sub = find_subchannel_by_line(s->device->lines);
-		if (!sub) {
-			ast_log(LOG_NOTICE, "No available lines on: %s\n", s->device->name);
+	case STIMULUS_FORWARDNOANSWER:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Forward No Answer (%d)\n", instance);
+		break;
+	case STIMULUS_DISPLAY:
+		/* Not sure what this is */
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Display(%d)\n", instance);
+		break;
+	case STIMULUS_LINE:
+		if (skinnydebug)
+			ast_verbose("Received Stimulus: Line(%d)\n", instance);
+
+		l = find_line_by_instance(s->device, instance);
+
+		if (!l) {
 			return 0;
 		}
-		sub->parent->hookstate = SKINNY_OFFHOOK;
 
-		if (sub->outgoing) {
+		/* turn the speaker on */
+		transmit_speaker_mode(s, SKINNY_SPEAKERON);
+		transmit_ringer_mode(s, SKINNY_RING_OFF);
+		transmit_lamp_indication(s, STIMULUS_LINE, l->instance, SKINNY_LAMP_ON);
+
+		l->hookstate = SKINNY_OFFHOOK;
+
+		if (sub && sub->outgoing) {
 			/* We're answering a ringing call */
 			ast_queue_control(sub->owner, AST_CONTROL_ANSWER);
-			transmit_callstate(s, s->device->lines->instance, SKINNY_OFFHOOK, sub->callid);
+			transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
 			transmit_tone(s, SKINNY_SILENCE);
-			transmit_callstate(s, s->device->lines->instance, SKINNY_CONNECTED, sub->callid);
+			transmit_callstate(s, l->instance, SKINNY_CONNECTED, sub->callid);
+			transmit_displaypromptstatus(s, "Connected", 0, l->instance, sub->callid);
+			transmit_selectsoftkeys(s, l->instance, sub->callid, KEYDEF_CONNECTED);
 			start_rtp(sub);
 			ast_setstate(sub->owner, AST_STATE_UP);
-			/* XXX select the appropriate soft key here */
 		} else {
-			if (!sub->owner) {
-				transmit_callstate(s, s->device->lines->instance, SKINNY_OFFHOOK, sub->callid);
-				if (skinnydebug) {
-					ast_verbose("Attempting to Clear display on Skinny %s@%s\n",sub->parent->name, sub->parent->parent->name);
-				}
-				transmit_displaymessage(s, NULL); /* clear display */
-				transmit_tone(s, SKINNY_DIALTONE);
-				c = skinny_new(sub, AST_STATE_DOWN);
+			if (sub && sub->owner) {
+				ast_log(LOG_DEBUG, "Current subchannel [%s] already has owner\n", sub->owner->name);
+			} else {
+				c = skinny_new(l, AST_STATE_DOWN);
 				if(c) {
+					sub = c->tech_pvt;
+					transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+					if (skinnydebug)
+						ast_verbose("Attempting to Clear display on Skinny %s@%s\n", l->name, d->name);
+					transmit_displaymessage(s, NULL); /* clear display */
+					transmit_tone(s, SKINNY_DIALTONE);
+					transmit_selectsoftkeys(s, l->instance, sub->callid, KEYDEF_OFFHOOK);
+
 					/* start the switch thread */
 					if (ast_pthread_create(&t, NULL, skinny_ss, c)) {
 						ast_log(LOG_WARNING, "Unable to create switch thread: %s\n", strerror(errno));
 						ast_hangup(c);
 					}
 				} else {
-					ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", sub->parent->name, s->device->name);
+					ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", l->name, d->name);
 				}
-			} else {
-				ast_log(LOG_DEBUG, "Current sub [%s] already has owner\n", sub->owner->name);
 			}
 		}
 		break;
-	case ONHOOK_MESSAGE:
-		sub = find_subchannel_by_line(s->device->lines);
-		if (sub->parent->hookstate == SKINNY_ONHOOK) {
-			/* Something else already put us back on hook */
-			break;
+	default:
+		if (skinnydebug)
+			ast_verbose("RECEIVED UNKNOWN STIMULUS:  %d(%d)\n", event, instance);
+		break;
+	}
+	return 1;
+}
+
+static int handle_offhook_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	struct skinny_subchannel *sub;
+	struct ast_channel *c;
+	pthread_t t;
+	int unknown1;
+	int unknown2;
+
+	unknown1 = letohl(req->data.offhook.unknown1);
+	unknown2 = letohl(req->data.offhook.unknown2);
+
+	sub = find_subchannel_by_instance_reference(d, d->lastlineinstance, d->lastcallreference);
+
+	if (!sub) {
+		l = find_line_by_instance(d, d->lastlineinstance);
+		if (!l) {
+			return 0;
 		}
-		sub->cxmode = SKINNY_CX_RECVONLY;
-		sub->parent->hookstate = SKINNY_ONHOOK;
-		transmit_callstate(s, s->device->lines->instance, sub->parent->hookstate,sub->callid);
-		if (skinnydebug) {
-			ast_verbose("Skinny %s@%s went on hook\n",sub->parent->name, sub->parent->parent->name);
+	} else {
+		l = sub->parent;
+	}
+
+	transmit_ringer_mode(s, SKINNY_RING_OFF);
+	transmit_lamp_indication(s, STIMULUS_LINE, l->instance, SKINNY_LAMP_ON);
+	l->hookstate = SKINNY_OFFHOOK;
+
+	if (sub && sub->outgoing) {
+		/* We're answering a ringing call */
+		ast_queue_control(sub->owner, AST_CONTROL_ANSWER);
+		transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+		transmit_tone(s, SKINNY_SILENCE);
+		transmit_callstate(s, l->instance, SKINNY_CONNECTED, sub->callid);
+		transmit_selectsoftkeys(s, l->instance, sub->callid, KEYDEF_CONNECTED);
+		start_rtp(sub);
+		ast_setstate(sub->owner, AST_STATE_UP);
+	} else {
+		if (sub && sub->owner) {
+			ast_log(LOG_DEBUG, "Current sub [%s] already has owner\n", sub->owner->name);
+		} else {
+			c = skinny_new(l, AST_STATE_DOWN);
+			if(c) {
+				sub = c->tech_pvt;
+				transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+				if (skinnydebug)
+					ast_verbose("Attempting to Clear display on Skinny %s@%s\n", l->name, d->name);
+				transmit_displaymessage(s, NULL); /* clear display */
+				transmit_tone(s, SKINNY_DIALTONE);
+				transmit_selectsoftkeys(s, l->instance, sub->callid, KEYDEF_OFFHOOK);
+
+				/* start the switch thread */
+				if (ast_pthread_create(&t, NULL, skinny_ss, c)) {
+					ast_log(LOG_WARNING, "Unable to create switch thread: %s\n", strerror(errno));
+					ast_hangup(c);
+				}
+			} else {
+				ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", l->name, d->name);
+			}
 		}
-		if (sub->parent->transfer && (sub->owner && sub->next->owner) && ((!sub->outgoing) || (!sub->next->outgoing))) {
-			/* We're allowed to transfer, we have two active calls and
-			   we made at least one of the calls.  Let's try and transfer */
+	}
+	return 1;
+}
 
+static int handle_onhook_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	struct skinny_subchannel *sub;
+	int unknown1;
+	int unknown2;
+
+	unknown1 = letohl(req->data.onhook.unknown1);
+	unknown2 = letohl(req->data.onhook.unknown2);
+
+	sub = find_subchannel_by_instance_reference(d, d->lastlineinstance, d->lastcallreference);
+
+	if (!sub) {
+		return 0;
+	} else {
+		l = sub->parent;
+	}
+
+	if (l->hookstate == SKINNY_ONHOOK) {
+		/* Something else already put us back on hook */
+		return 0;
+	}
+	sub->cxmode = SKINNY_CX_RECVONLY;
+	l->hookstate = SKINNY_ONHOOK;
+	transmit_callstate(s, l->instance, l->hookstate, sub->callid);
+	if (skinnydebug)
+		ast_verbose("Skinny %s@%s went on hook\n", l->name, d->name);
+	if (l->transfer && (sub->owner && sub->next && sub->next->owner) && ((!sub->outgoing) || (sub->next && !sub->next->outgoing))) {
+		/* We're allowed to transfer, we have two active calls and
+		   we made at least one of the calls.  Let's try and transfer */
+
 #if 0
-			if ((res = attempt_transfer(p)) < 0) {
-				 if (p->sub->next->owner) {
-					sub->next->alreadygone = 1;
-					ast_queue_hangup(sub->next->owner,1);
-				}
-			} else if (res) {
-				ast_log(LOG_WARNING, "Transfer attempt failed\n");
-				return -1;
+		if ((res = attempt_transfer(p)) < 0) {
+			if (sub->next && sub->next->owner) {
+				sub->next->alreadygone = 1;
+				ast_queue_hangup(sub->next->owner,1);
 			}
+		} else if (res) {
+			ast_log(LOG_WARNING, "Transfer attempt failed\n");
+			return 0;
+		}
 #endif
+	} else {
+		/* Hangup the current call */
+		/* If there is another active call, skinny_hangup will ring the phone with the other call */
+		if (sub->owner) {
+			sub->alreadygone = 1;
+			ast_queue_hangup(sub->owner);
 		} else {
-			/* Hangup the current call */
-			/* If there is another active call, skinny_hangup will ring the phone with the other call */
-			if (sub->owner) {
-				sub->alreadygone = 1;
-				ast_queue_hangup(sub->owner);
-			} else {
-				ast_log(LOG_WARNING, "Skinny(%s@%s-%d) channel already destroyed\n",
-					sub->parent->name, sub->parent->parent->name, sub->callid);
- 			}
+			ast_log(LOG_WARNING, "Skinny(%s@%s-%d) channel already destroyed\n",
+				l->name, d->name, sub->callid);
 		}
-		if ((sub->parent->hookstate == SKINNY_ONHOOK) && (!sub->next->rtp)) {
-			do_housekeeping(s);
+	}
+	if ((l->hookstate == SKINNY_ONHOOK) && (sub->next && !sub->next->rtp)) {
+		do_housekeeping(s);
+	}
+	return 1;
+}
+
+static int handle_capabilities_res_message(skinny_req *req, struct skinnysession *s)
+{
+	/* XXX process the capabilites */
+	return 1;
+}
+
+static int handle_speed_dial_stat_req_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_speeddial *sd;
+	int instance;
+
+	instance = letohl(req->data.speeddialreq.speedDialNumber);
+
+	sd = find_speeddial_by_instance(d, instance);
+
+	if (!sd) {
+		return 0;
+	}
+
+	if (!(req = req_alloc(sizeof(speed_dial_stat_res_message), SPEED_DIAL_STAT_RES_MESSAGE)))
+		return -1;
+
+	req->data.speeddialreq.speedDialNumber = htolel(instance);
+	snprintf(req->data.speeddial.speedDialDirNumber, sizeof(req->data.speeddial.speedDialDirNumber), sd->exten);
+	snprintf(req->data.speeddial.speedDialDisplayName, sizeof(req->data.speeddial.speedDialDisplayName), sd->label);
+
+	transmit_response(s, req);
+	return 1;
+}
+
+static int handle_line_state_req_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	int instance;
+
+	instance = letohl(req->data.line.lineNumber);
+
+	ast_mutex_lock(&devicelock);
+
+	l = find_line_by_instance(d, instance);
+
+	if (!l) {
+		return 0;
+	}
+
+	ast_mutex_unlock(&devicelock);
+
+	if (!(req = req_alloc(sizeof(line_stat_res_message), LINE_STAT_RES_MESSAGE)))
+		return -1;
+
+	req->data.linestat.lineNumber = letohl(instance);
+	memcpy(req->data.linestat.lineDirNumber, l->name,
+			sizeof(req->data.linestat.lineDirNumber));
+	memcpy(req->data.linestat.lineDisplayName, l->label,
+			sizeof(req->data.linestat.lineDisplayName));
+	transmit_response(s,req);
+	return 1;
+}
+
+static int handle_time_date_req_message(skinny_req *req, struct skinnysession *s)
+{
+	time_t timer;
+	struct tm *cmtime;
+
+	if (!(req = req_alloc(sizeof(definetimedate_message), DEFINETIMEDATE_MESSAGE)))
+		return -1;
+
+	timer = time(NULL);
+	cmtime = localtime(&timer);
+	req->data.definetimedate.year = htolel(cmtime->tm_year+1900);
+	req->data.definetimedate.month = htolel(cmtime->tm_mon+1);
+	req->data.definetimedate.dayofweek = htolel(cmtime->tm_wday);
+	req->data.definetimedate.day = htolel(cmtime->tm_mday);
+	req->data.definetimedate.hour = htolel(cmtime->tm_hour);
+	req->data.definetimedate.minute = htolel(cmtime->tm_min);
+	req->data.definetimedate.seconds = htolel(cmtime->tm_sec);
+	transmit_response(s, req);
+	return 1;
+}
+
+static int handle_button_template_req_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	int i;
+
+	if (!(req = req_alloc(sizeof(button_template_res_message), BUTTON_TEMPLATE_RES_MESSAGE)))
+		return -1;
+
+	struct skinny_speeddial *sd;
+	button_definition_template btn[42];
+	int lineInstance = 1;
+	int speeddialInstance = 1;
+	int buttonCount = 0;
+
+	memset(&btn, 0, sizeof(btn));
+
+	get_button_template(s, btn);
+
+	for (i=0; i<42; i++) {
+		int btnSet = 0;
+		switch (btn[i].buttonDefinition) {
+			case BT_CUST_LINESPEEDDIAL:
+				/* assume failure */
+				req->data.buttontemplate.definition[i].buttonDefinition = htolel(BT_NONE);
+				req->data.buttontemplate.definition[i].instanceNumber = htolel(0);
+
+				for (l = d->lines; l; l = l->next) {
+					if (l->instance == lineInstance) {
+						ast_verbose("Adding button: %d, %d\n", BT_LINE, lineInstance);
+						req->data.buttontemplate.definition[i].buttonDefinition = htolel(BT_LINE);
+						req->data.buttontemplate.definition[i].instanceNumber = htolel(lineInstance++);
+						buttonCount++;
+						btnSet = 1;
+						break;
+					}
+				}
+
+				if (!btnSet) {
+					for (sd = d->speeddials; sd; sd = sd->next) {
+						if (sd->instance == speeddialInstance) {
+							ast_verbose("Adding button: %d, %d\n", BT_SPEEDDIAL, speeddialInstance);
+							req->data.buttontemplate.definition[i].buttonDefinition = htolel(BT_SPEEDDIAL);
+							req->data.buttontemplate.definition[i].instanceNumber = htolel(speeddialInstance++);
+							buttonCount++;
+							btnSet = 1;
+							break;
+						}
+					}
+				}
+				break;
+			case BT_LINE:
+				req->data.buttontemplate.definition[i].buttonDefinition = htolel(BT_NONE);
+				req->data.buttontemplate.definition[i].instanceNumber = htolel(0);
+
+				for (l = d->lines; l; l = l->next) {
+					if (l->instance == lineInstance) {
+						ast_verbose("Adding button: %d, %d\n", BT_LINE, lineInstance);
+						req->data.buttontemplate.definition[i].buttonDefinition = htolel(BT_LINE);
+						req->data.buttontemplate.definition[i].instanceNumber = htolel(lineInstance++);
+						buttonCount++;
+						btnSet = 1;
+						break;
+					}
+				}
+				break;
+			case BT_SPEEDDIAL:
+				req->data.buttontemplate.definition[i].buttonDefinition = BT_NONE;
+				req->data.buttontemplate.definition[i].instanceNumber = 0;
+
+				for (sd = d->speeddials; sd; sd = sd->next) {
+					if (sd->instance == speeddialInstance) {
+						ast_verbose("Adding button: %d, %d\n", BT_SPEEDDIAL, speeddialInstance);
+						req->data.buttontemplate.definition[i].buttonDefinition = htolel(BT_SPEEDDIAL);
+						req->data.buttontemplate.definition[i].instanceNumber = htolel(speeddialInstance++);
+						buttonCount++;
+						btnSet = 1;
+						break;
+					}
+				}
+				break;
+			case BT_CUST_HINT:
+				break;
+			case BT_NONE:
+				break;
+			default:
+				ast_verbose("Adding button: %d, %d\n", btn[i].buttonDefinition, 0);
+				req->data.buttontemplate.definition[i].buttonDefinition = htolel(btn[i].buttonDefinition);
+				req->data.buttontemplate.definition[i].instanceNumber = htolel(0);
+				buttonCount++;
+				btnSet = 1;
+				break;
 		}
-		break;
-	case KEYPAD_BUTTON_MESSAGE:
-		digit = letohl(req->data.keypad.button);
-		if (skinnydebug) {
-			ast_verbose("Collected digit: [%d]\n", digit);
+	}
+
+	req->data.buttontemplate.buttonOffset = htolel(0);
+	req->data.buttontemplate.buttonCount = htolel(buttonCount);
+	req->data.buttontemplate.totalButtonCount = htolel(buttonCount);
+
+	if (skinnydebug)
+		ast_verbose("Sending %d template to %s\n",
+					d->type,
+					d->name);
+	transmit_response(s, req);
+	return 1;
+}
+
+static int handle_version_req_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	if (!(req = req_alloc(sizeof(version_res_message), VERSION_RES_MESSAGE)))
+		return -1;
+
+	snprintf(req->data.version.version, sizeof(req->data.version.version), d->version_id);
+	transmit_response(s, req);
+	return 1;
+}
+
+static int handle_server_request_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	if (!(req = req_alloc(sizeof(server_res_message), SERVER_RES_MESSAGE)))
+		return -1;
+
+	memcpy(req->data.serverres.server[0].serverName, ourhost,
+			sizeof(req->data.serverres.server[0].serverName));
+	req->data.serverres.serverListenPort[0] = htolel(ourport);
+	req->data.serverres.serverIpAddr[0] = htolel(d->ourip.s_addr);
+	transmit_response(s, req);
+	return 1;
+}
+
+static int handle_alarm_message(skinny_req *req, struct skinnysession *s)
+{
+	/* no response necessary */
+	if (skinnydebug)
+		ast_verbose("Received Alarm Message: %s\n", req->data.alarm.displayMessage);
+
+	return 1;
+}
+
+static int handle_open_receive_channel_ack_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	struct skinny_subchannel *sub;
+	struct sockaddr_in sin;
+	struct sockaddr_in us;
+	char iabuf[INET_ADDRSTRLEN];
+	uint32_t addr;
+	int port;
+	int status;
+	int passthruid;
+
+	status = letohl(req->data.openreceivechannelack.status);
+	if (status) {
+		ast_log(LOG_ERROR, "Open Receive Channel Failure\n");
+		return 0;
+	}
+	addr = letohl(req->data.openreceivechannelack.ipAddr);
+	port = letohl(req->data.openreceivechannelack.port);
+	passthruid = letohl(req->data.openreceivechannelack.passThruId);
+
+	sin.sin_family = AF_INET;
+	sin.sin_addr.s_addr = addr;
+	sin.sin_port = htons(port);
+
+	sub = find_subchannel_by_reference(d, passthruid);
+
+	if (!sub)
+		return 0;
+
+	l = sub->parent;
+
+	if (sub->rtp) {
+		ast_rtp_set_peer(sub->rtp, &sin);
+		ast_rtp_get_us(sub->rtp, &us);
+	} else {
+		ast_log(LOG_ERROR, "No RTP structure, this is very bad\n");
+		return 0;
+	}
+
+	if (skinnydebug) {
+		ast_verbose("ipaddr = %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+		ast_verbose("ourip = %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), d->ourip), ntohs(us.sin_port));
+	}
+
+	if (!(req = req_alloc(sizeof(start_media_transmission_message), START_MEDIA_TRANSMISSION_MESSAGE)))
+		return -1;
+
+	req->data.startmedia.conferenceId = 0;
+	req->data.startmedia.passThruPartyId = htolel(sub->callid);
+	req->data.startmedia.remoteIp = htolel(d->ourip.s_addr);
+	req->data.startmedia.remotePort = htolel(ntohs(us.sin_port));
+	req->data.startmedia.packetSize = htolel(20);
+	req->data.startmedia.payloadType = htolel(convert_cap(l->capability));
+	req->data.startmedia.qualifier.precedence = htolel(127);
+	req->data.startmedia.qualifier.vad = 0;
+	req->data.startmedia.qualifier.packets = 0;
+	req->data.startmedia.qualifier.bitRate = 0;
+	transmit_response(s, req);
+	return 1;
+}
+
+static int handle_soft_key_set_req_message(skinny_req *req, struct skinnysession *s)
+{
+	int i;
+	int x;
+	int y;
+
+	if (!(req = req_alloc(sizeof(soft_key_set_res_message), SOFT_KEY_SET_RES_MESSAGE)))
+		return -1;
+
+	req->data.softkeysets.softKeySetOffset = htolel(0);
+	req->data.softkeysets.softKeySetCount = htolel(11);
+	req->data.softkeysets.totalSoftKeySetCount = htolel(11);
+	const soft_key_definitions *softkeymode = soft_key_default_definitions;
+	for (x = 0; x < sizeof(soft_key_default_definitions) / sizeof(soft_key_definitions); x++) {
+		const uint8_t *defaults = softkeymode->defaults;
+		/* XXX I wanted to get the size of the array dynamically, but that wasn't wanting to work.
+		   This will have to do for now. */
+		for (y = 0; y < softkeymode->count; y++) {
+			for (i = 0; i < (sizeof(soft_key_template_default) / sizeof(soft_key_template_definition)); i++) {
+				if (defaults[y] == i+1) {
+					req->data.softkeysets.softKeySetDefinition[softkeymode->mode].softKeyTemplateIndex[y] = htolel(i+1);
+				}
+			}
 		}
-		f.frametype = AST_FRAME_DTMF;
-		if (digit == 14) {
-			d = '*';
-		} else if (digit == 15) {
-			d = '#';
-		} else if (digit >=0 && digit <= 9) {
-			d = '0' + digit;
+		softkeymode++;
+	}
+	transmit_response(s,req);
+	transmit_selectsoftkeys(s, 0, 0, KEYDEF_ONHOOK);
+	return 1;
+}
+
+static int handle_soft_key_event_message(skinny_req *req, struct skinnysession *s)
+{
+	struct skinny_device *d = s->device;
+	struct skinny_line *l;
+	struct skinny_subchannel *sub = NULL;
+	struct ast_channel *c;
+	pthread_t t;
+	int event;
+	int instance;
+	int reference;
+	/*int res;*/
+
+	event = letohl(req->data.softkeyeventmessage.softKeyEvent);
+	instance = letohl(req->data.softkeyeventmessage.instance);
+	reference = letohl(req->data.softkeyeventmessage.reference);
+
+	if (instance) {
+		l = find_line_by_instance(d, instance);
+		if (reference) {
+			sub = find_subchannel_by_instance_reference(d, instance, reference);
 		} else {
-			/* digit=10-13 (A,B,C,D ?), or
-			 * digit is bad value
-			 *
-			 * probably should not end up here, but set
-			 * value for backward compatibility, and log
-			 * a warning.
-			 */
-			d = '0' + digit;
-			ast_log(LOG_WARNING, "Unsupported digit %d\n", digit);
+			sub = find_subchannel_by_instance_reference(d, instance, d->lastcallreference);
 		}
-		f.subclass = d;
-		f.src = "skinny";
-		sub = find_subchannel_by_line(s->device->lines);
-		if (sub->owner) {
-			/* XXX MUST queue this frame to all subs in threeway call if threeway call is active */
-			ast_queue_frame(sub->owner, &f);
-			if (sub->next->owner) {
-				ast_queue_frame(sub->next->owner, &f);
+	} else {
+		l = find_line_by_instance(d, d->lastlineinstance);
+	}
+
+	if (!l) {
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: %d(%d)\n", event, instance);
+		return 0;
+	}
+
+	switch(event) {
+	case SOFTKEY_NONE:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: None(%d)\n", instance);
+		break;
+	case SOFTKEY_REDIAL:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Redial(%d)\n", instance);
+
+#if 0
+		if (sub)
+			transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+		if (skinnydebug)
+			ast_verbose("Attempting to Clear display on Skinny %s@%s\n", l->name, d->name);
+		transmit_displaymessage(s, NULL); /* clear display */
+		transmit_tone(s, SKINNY_DIALTONE);
+
+		if (!sub) {
+			c = skinny_new(l, AST_STATE_DOWN);
+		} else {
+			c = sub->owner;
+		}
+
+		if(c) {
+			sub = c->tech_pvt;
+			if (ast_strlen_zero(l->lastnumberdialed)) {
+				ast_log(LOG_WARNING, "Attempted redial, but no previously dialed number found.\n");
+				return 0;
 			}
+			if (!ast_ignore_pattern(c->context, l->lastnumberdialed)) {
+				transmit_tone(s, SKINNY_SILENCE);
+			}
+			start_rtp(sub);
+			if (ast_exists_extension(c, c->context, l->lastnumberdialed, 1, l->cid_num)) {
+				if (!ast_matchmore_extension(c, c->context, l->lastnumberdialed, 1, l->cid_num)) {
+					ast_copy_string(c->exten, l->lastnumberdialed, sizeof(c->exten));
+					if (!ast_strlen_zero(l->cid_num)) {
+						if (!l->hidecallerid) {
+							c->cid.cid_num = strdup(l->cid_num);
+							c->cid.cid_ani = strdup(l->cid_num);
+						}
+					}
+					ast_setstate(c, AST_STATE_RING);
+					res = ast_pbx_run(c);
+					if (res) {
+						ast_log(LOG_WARNING, "PBX exited non-zero\n");
+						transmit_tone(s, SKINNY_REORDER);
+					}
+					break;
+				}
+			}
 		} else {
-			if (skinnydebug) {
-				ast_verbose("No owner: %s\n", s->device->lines->name);
+			ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", l->name, d->name);
+		}
+#endif
+		break;
+	case SOFTKEY_NEWCALL:
+		/* XXX Untested */
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: New Call(%d)\n", instance);
+
+		transmit_ringer_mode(s,SKINNY_RING_OFF);
+		transmit_lamp_indication(s, STIMULUS_LINE, l->instance, SKINNY_LAMP_ON);
+
+		l->hookstate = SKINNY_OFFHOOK;
+
+		if (sub) {
+			transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+			if (skinnydebug)
+				ast_verbose("Attempting to Clear display on Skinny %s@%s\n", l->name, d->name);
+			transmit_displaymessage(s, NULL); /* clear display */
+			transmit_tone(s, SKINNY_DIALTONE);
+			transmit_selectsoftkeys(s, l->instance, sub->callid, KEYDEF_OFFHOOK);
+			c = skinny_new(l, AST_STATE_DOWN);
+			if(c) {
+				/* start the switch thread */
+				if (ast_pthread_create(&t, NULL, skinny_ss, c)) {
+					ast_log(LOG_WARNING, "Unable to create switch thread: %s\n", strerror(errno));
+					ast_hangup(c);
+				}
+			} else {
+				ast_log(LOG_WARNING, "Unable to create channel for %s@%s\n", l->name, d->name);
 			}
 		}
 		break;
-	case OPEN_RECEIVE_CHANNEL_ACK_MESSAGE:
-		if (skinnydebug) {
-			ast_verbose("Received Open Receive Channel Ack\n");
+	case SOFTKEY_HOLD:
+		/* start moh? set RTP to 0.0.0.0? */
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Hold(%d)\n", instance);
+		break;
+	case SOFTKEY_TRNSFER:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Transfer(%d)\n", instance);
+		transmit_tone(s, SKINNY_DIALTONE);
+		/* XXX figure out how to transfer */
+		break;
+	case SOFTKEY_CFWDALL:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Forward All(%d)\n", instance);
+
+		/* Do not disturb */
+		transmit_tone(s, SKINNY_DIALTONE);
+		if (l->dnd != 0){
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Disabling DND on %s@%s\n", l->name, d->name);
+			l->dnd = 0;
+			transmit_lamp_indication(s, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_ON);
+			transmit_displaynotify(s, "DnD disabled", 10);
+		} else {
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Enabling DND on %s@%s\n", l->name, d->name);
+			l->dnd = 1;
+			transmit_lamp_indication(s, STIMULUS_FORWARDALL, 1, SKINNY_LAMP_OFF);
+			transmit_displaynotify(s, "DnD enabled", 10);
 		}
-		status = letohl(req->data.openreceivechannelack.status);
-		if (status) {
-			ast_log(LOG_ERROR, "Open Receive Channel Failure\n");
+		break;
+	case SOFTKEY_CFWDBUSY:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Forward Busy (%d)\n", instance);
+		break;
+	case SOFTKEY_CFWDNOANSWER:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Forward No Answer (%d)\n", instance);
+		break;
+	case SOFTKEY_BKSPC:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Backspace(%d)\n", instance);
+		break;
+	case SOFTKEY_ENDCALL:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: End Call(%d)\n", instance);
+
+		if (l->hookstate == SKINNY_ONHOOK) {
+			/* Something else already put us back on hook */
 			break;
 		}
-		/* ENDIAN */
-		memcpy(addr, req->data.openreceivechannelack.ipAddr, sizeof(addr));
-		port = htolel(req->data.openreceivechannelack.port);
-		sin.sin_family = AF_INET;
-		/* I smell endian problems */
-		memcpy(&sin.sin_addr, addr, sizeof(sin.sin_addr));
-		sin.sin_port = htons(port);
-		if (skinnydebug) {
-			ast_verbose("ipaddr = %s:%d\n", ast_inet_ntoa(iabuf, sizeof(iabuf), sin.sin_addr), ntohs(sin.sin_port));
+		if (sub) {
+			sub->cxmode = SKINNY_CX_RECVONLY;
+			l->hookstate = SKINNY_ONHOOK;
+			transmit_callstate(s, l->instance, l->hookstate, sub->callid);
+			if (skinnydebug)
+				ast_verbose("Skinny %s@%s went on hook\n", l->name, d->name);
+			if (l->transfer && (sub->owner && sub->next && sub->next->owner) && ((!sub->outgoing) || (sub->next && !sub->next->outgoing))) {
+				/* We're allowed to transfer, we have two active calls and
+				   we made at least one of the calls.  Let's try and transfer */
+
+#if 0
+				if ((res = attempt_transfer(p)) < 0) {
+					if (sub->next && sub->next->owner) {
+						sub->next->alreadygone = 1;
+						ast_queue_hangup(sub->next->owner, 1);
+					}
+				} else if (res) {
+					ast_log(LOG_WARNING, "Transfer attempt failed\n");
+					return 0;
+				}
+#endif
+			} else {
+				/* Hangup the current call */
+				/* If there is another active call, skinny_hangup will ring the phone with the other call */
+				if (sub->owner) {
+					sub->alreadygone = 1;
+					ast_queue_hangup(sub->owner);
+				} else {
+					ast_log(LOG_WARNING, "Skinny(%s@%s-%d) channel already destroyed\n",
+						l->name, d->name, sub->callid);
+	 			}
+			}
+			if ((l->hookstate == SKINNY_ONHOOK) && (sub->next && !sub->next->rtp)) {
+				do_housekeeping(s);
+			}
 		}
-		sub = find_subchannel_by_line(s->device->lines);
-		if (sub->rtp) {
-			ast_rtp_set_peer(sub->rtp, &sin);
-			ast_rtp_get_us(sub->rtp, &us);
-		} else {
-			ast_log(LOG_ERROR, "No RTP structure, this is very bad\n");
-			break;
+		break;
+	case SOFTKEY_RESUME:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Resume(%d)\n", instance);
+		break;
+	case SOFTKEY_ANSWER:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Answer(%d)\n", instance);
+
+		transmit_ringer_mode(s,SKINNY_RING_OFF);
+		transmit_lamp_indication(s, STIMULUS_LINE, l->instance, SKINNY_LAMP_ON);
+
+		l->hookstate = SKINNY_OFFHOOK;
+
+		if (sub && sub->outgoing) {
+			/* We're answering a ringing call */
+			ast_queue_control(sub->owner, AST_CONTROL_ANSWER);
+			transmit_callstate(s, l->instance, SKINNY_OFFHOOK, sub->callid);
+			transmit_tone(s, SKINNY_SILENCE);
+			transmit_callstate(s, l->instance, SKINNY_CONNECTED, sub->callid);
+			transmit_selectsoftkeys(s, l->instance, sub->callid, KEYDEF_CONNECTED);
+			start_rtp(sub);
+			ast_setstate(sub->owner, AST_STATE_UP);
 		}
-		memset(req, 0, SKINNY_MAX_PACKET);
-		req->len = htolel(sizeof(start_media_transmission_message)+4);
-		req->e = htolel(START_MEDIA_TRANSMISSION_MESSAGE);
-		req->data.startmedia.conferenceId = 0;
-		req->data.startmedia.passThruPartyId = 0;
-		memcpy(req->data.startmedia.remoteIp, &s->device->ourip, 4); /* Endian? */
-		req->data.startmedia.remotePort = htolel(ntohs(us.sin_port));
-		req->data.startmedia.packetSize = htolel(20);
-		req->data.startmedia.payloadType = htolel(convert_cap(s->device->lines->capability));
-		req->data.startmedia.qualifier.precedence = htolel(127);
-		req->data.startmedia.qualifier.vad = 0;
-		req->data.startmedia.qualifier.packets = 0;
-		req->data.startmedia.qualifier.bitRate = 0;
-		transmit_response(s, req);
 		break;
+	case SOFTKEY_INFO:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Info(%d)\n", instance);
+		break;
+	case SOFTKEY_CONFRN:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Transfer(%d)\n", instance);
+		transmit_tone(s, SKINNY_DIALTONE);
+		/* XXX determine the best way to pull off a conference.  Meetme? */
+		break;
+	case SOFTKEY_PARK:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Park Call(%d)\n", instance);
+		/* XXX Park the call */
+		break;
+	case SOFTKEY_JOIN:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Join(%d)\n", instance);
+		break;
+	case SOFTKEY_MEETME:
+		/* XXX How is this different from CONFRN? */
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Meetme(%d)\n", instance);
+		break;
+	case SOFTKEY_PICKUP:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: None(%d)\n", instance);
+		break;
+	case SOFTKEY_GPICKUP:
+		if (skinnydebug)
+			ast_verbose("Received Softkey Event: Group Pickup (%d)\n", instance);
+		break;
 	default:
-		if (skinnydebug) {
-			ast_verbose("RECEIVED UNKNOWN MESSAGE TYPE:  %x\n", letohl(req->e));
-		}
+		if (skinnydebug)
+			ast_verbose("Received unknown Softkey Event: %d(%d)\n", event, instance);
 		break;
 	}
-	free(req);
 	return 1;
 }
 
+static int handle_unregister_message(skinny_req *req, struct skinnysession *s)
+{
+	return skinny_unregister(req, s);
+}
+
+static int handle_soft_key_template_req_message(skinny_req *req, struct skinnysession *s)
+{
+	if (!(req = req_alloc(sizeof(soft_key_template_res_message), SOFT_KEY_TEMPLATE_RES_MESSAGE)))
+		return -1;
+
+	req->data.softkeytemplate.softKeyOffset = htolel(0);
+	req->data.softkeytemplate.softKeyCount	= htolel(sizeof(soft_key_template_default) / sizeof(soft_key_template_definition));
+	req->data.softkeytemplate.totalSoftKeyCount = htolel(sizeof(soft_key_template_default) / sizeof(soft_key_template_definition));
+	memcpy(req->data.softkeytemplate.softKeyTemplateDefinition,
+		soft_key_template_default,
+		sizeof(soft_key_template_default));
+	transmit_response(s,req);
+	return 1;
+}
+
+static int handle_headset_status_message(skinny_req *req, struct skinnysession *s)
+{
+	/* XXX umm...okay?  Why do I care? */
+	return 1;
+}
+
+static int handle_register_available_lines_message(skinny_req *req, struct skinnysession *s)
+{
+	/* XXX I have no clue what this is for, but my phone was sending it, so... */
+	return 1;
+}
+
+static int handle_message(skinny_req *req, struct skinnysession *s)
+{
+	int res = 0;
+
+	if ((!s->device) && (letohl(req->e) != REGISTER_MESSAGE && letohl(req->e) != ALARM_MESSAGE)) {
+		ast_log(LOG_WARNING, "Client sent message #%d without first registering.\n", req->e);
+		free(req);
+		return 0;
+	}
+
+	switch(letohl(req->e))	{
+	case KEEP_ALIVE_MESSAGE:
+		res = handle_keep_alive_message(req, s);
+		break;
+	case REGISTER_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Device %s is attempting to register\n", req->data.reg.name);
+
+		res = handle_register_message(req, s);
+		break;
+	case IP_PORT_MESSAGE:
+		res = handle_ip_port_message(req, s);
+		break;
+	case KEYPAD_BUTTON_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Collected digit: [%d]\n", letohl(req->data.keypad.button));
+
+		res = handle_keypad_button_message(req, s);
+		break;
+	case STIMULUS_MESSAGE:
+		res = handle_stimulus_message(req, s);
+		break;
+	case OFFHOOK_MESSAGE:
+		res = handle_offhook_message(req, s);
+		break;
+	case ONHOOK_MESSAGE:
+		res = handle_onhook_message(req, s);
+		break;
+	case CAPABILITIES_RES_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received CapabilitiesRes\n");
+
+		res = handle_capabilities_res_message(req, s);
+		break;
+	case SPEED_DIAL_STAT_REQ_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received SpeedDialStatRequest\n");
+
+		res = handle_speed_dial_stat_req_message(req, s);
+		break;
+	case LINE_STATE_REQ_MESSAGE:
+		res = handle_line_state_req_message(req, s);
+		break;
+	case TIME_DATE_REQ_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received Time/Date Request\n");
+
+		res = handle_time_date_req_message(req, s);
+		break;
+	case BUTTON_TEMPLATE_REQ_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Buttontemplate requested\n");
+
+		res = handle_button_template_req_message(req, s);
+		break;
+	case VERSION_REQ_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Version Request\n");
+
+		res = handle_version_req_message(req, s);
+		break;
+	case SERVER_REQUEST_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received Server Request\n");
+
+		res = handle_server_request_message(req, s);
+		break;
+	case ALARM_MESSAGE:
+		res = handle_alarm_message(req, s);
+		break;
+	case OPEN_RECEIVE_CHANNEL_ACK_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received Open Receive Channel Ack\n");
+
+		res = handle_open_receive_channel_ack_message(req, s);
+		break;
+	case SOFT_KEY_SET_REQ_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received SoftKeySetReq\n");
+
+		res = handle_soft_key_set_req_message(req, s);
+		break;
+	case SOFT_KEY_EVENT_MESSAGE:
+		res = handle_soft_key_event_message(req, s);
+		break;
+	case UNREGISTER_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received Unregister Request\n");
+
+		res = handle_unregister_message(req, s);
+		break;
+	case SOFT_KEY_TEMPLATE_REQ_MESSAGE:
+		if (skinnydebug)
+			ast_verbose("Received SoftKey Template Request\n");
+
+		res = handle_soft_key_template_req_message(req, s);
+		break;
+	case HEADSET_STATUS_MESSAGE:
+		res = handle_headset_status_message(req, s);
+		break;
+	case REGISTER_AVAILABLE_LINES_MESSAGE:
+		res = handle_register_available_lines_message(req, s);
+		break;
+	default:
+		if (skinnydebug)
+			ast_verbose("RECEIVED UNKNOWN MESSAGE TYPE:  %x\n", letohl(req->e));
+		break;
+	}
+	if (res >= 0 && req)
+		free(req);
+	return res;
+}
+
 static void destroy_session(struct skinnysession *s)
 {
 	struct skinnysession *cur, *prev = NULL;
@@ -2871,15 +3807,25 @@
 
  	fds[0].fd = s->fd;
 	fds[0].events = POLLIN;
+	fds[0].revents = 0;
 	res = poll(fds, 1, -1);
 
 	if (res < 0) {
-		ast_log(LOG_WARNING, "Select returned error: %s\n", strerror(errno));
- 	} else if (res > 0) {
+		if (errno != EINTR)
+		{
+			ast_log(LOG_WARNING, "Select returned error: %s\n", strerror(errno));
+			return res;
+		}
+ 	}
+	if (fds[0].revents) {
+		ast_mutex_lock(&s->lock);
 		memset(s->inbuf,0,sizeof(s->inbuf));
 		res = read(s->fd, s->inbuf, 4);
-		if (res != 4) {
-			ast_log(LOG_WARNING, "Skinny Client sent less data than expected.\n");
+		if (res < 0) {
+			ast_log(LOG_WARNING, "read() returned error: %s\n", strerror(errno));
+			return res;
+		} else if (res != 4) {
+			ast_log(LOG_WARNING, "Skinny Client sent less data than expected.  Expected 4 but got %d.\n", res);
 			return -1;
 		}
 		dlen = letohl(*(int *)s->inbuf);
@@ -2887,33 +3833,40 @@
 			dlen = sizeof(s->inbuf) - 8;
 		}
 		*(int *)s->inbuf = htolel(dlen);
+
 		res = read(s->fd, s->inbuf+4, dlen+4);
 		ast_mutex_unlock(&s->lock);
-		if (res != (dlen+4)) {
+		if (res < 0) {
+			ast_log(LOG_WARNING, "read() returned error: %s\n", strerror(errno));
+			return res;
+		} else if (res != (dlen+4)) {
 			ast_log(LOG_WARNING, "Skinny Client sent less data than expected.\n");
 			return -1;
 		}
+		return res;
 	}
-	return res;
+	return 0;
 }
 
 static skinny_req *skinny_req_parse(struct skinnysession *s)
 {
 	skinny_req *req;
 
-	req = malloc(SKINNY_MAX_PACKET);
-	if (!req) {
-		ast_log(LOG_ERROR, "Unable to allocate skinny_request, this is bad\n");
+	if (!(req = ast_calloc(1, SKINNY_MAX_PACKET)))
 		return NULL;
-	}
-	memset(req, 0, sizeof(skinny_req));
-	/* +8 to account for reserved and length fields */
-	memcpy(req, s->inbuf, letohl(*(int*)(s->inbuf))+8);
+
+	ast_mutex_lock(&s->lock);
+	memcpy(req, s->inbuf, skinny_header_size);
+	memcpy(&req->data, s->inbuf+skinny_header_size, letohl(*(int*)(s->inbuf))-4);
+
+	ast_mutex_unlock(&s->lock);
+
 	if (letohl(req->e) < 0) {
 		ast_log(LOG_ERROR, "Event Message is NULL from socket %d, This is bad\n", s->fd);
 		free(req);
 		return NULL;
 	}
+
 	return req;
 }
 
@@ -2926,21 +3879,26 @@
 
 	if (option_verbose > 2)
 		ast_verbose(VERBOSE_PREFIX_3 "Starting Skinny session from %s\n", ast_inet_ntoa(iabuf, sizeof(iabuf), s->sin.sin_addr));
+
 	for (;;) {
-		res = 0;
 		res = get_input(s);
 		if (res < 0) {
 			break;
 		}
-		req = skinny_req_parse(s);
-		if (!req) {
-			return NULL;
+
+		if (res > 0)
+		{
+			if (!(req = skinny_req_parse(s))) {
+				destroy_session(s);
+				return NULL;
+			}
+
+			res = handle_message(req, s);
+			if (res < 0) {
+				destroy_session(s);
+				return NULL;
+			}
 		}
-		res = handle_message(req, s);
-		if (res < 0) {
-			destroy_session(s);
-			return NULL;
-		}
 	}
 	ast_log(LOG_NOTICE, "Skinny Session returned: %s\n", strerror(errno));
 	destroy_session(s);
@@ -2973,12 +3931,9 @@
 				ast_log(LOG_WARNING, "Failed to set Skinny tcp connection to TCP_NODELAY mode: %s\n", strerror(errno));
 			}
 		}
-		s = malloc(sizeof(struct skinnysession));
-		if (!s) {
-			ast_log(LOG_WARNING, "Failed to allocate Skinny session: %s\n", strerror(errno));
+		if (!(s = ast_calloc(1, sizeof(struct skinnysession))))
 			continue;
-		}
-		memset(s, 0, sizeof(struct skinnysession));
+
 		memcpy(&s->sin, &sin, sizeof(sin));
 		ast_mutex_init(&s->lock);
 		s->fd = as;
@@ -2991,9 +3946,8 @@
 			destroy_session(s);
 		}
 	}
-	if (skinnydebug) {
+	if (skinnydebug)
 		ast_verbose("killing accept thread\n");
-	}
 	close(as);
 	return 0;
 }
@@ -3056,7 +4010,7 @@
 static struct ast_channel *skinny_request(const char *type, int format, void *data, int *cause)
 {
 	int oldformat;
-	struct skinny_subchannel *sub;
+	struct skinny_line *l;
 	struct ast_channel *tmpc = NULL;
 	char tmp[256];
 	char *dest = data;
@@ -3072,17 +4026,15 @@
 		ast_log(LOG_NOTICE, "Skinny channels require a device\n");
 		return NULL;
 	}
-	sub = find_subchannel_by_name(tmp);
-	if (!sub) {
+	l = find_line_by_name(tmp);
+	if (!l) {
 		ast_log(LOG_NOTICE, "No available lines on: %s\n", dest);
 		return NULL;
 	}
 	if (option_verbose > 2) {
 		ast_verbose(VERBOSE_PREFIX_3 "skinny_request(%s)\n", tmp);
-		ast_verbose(VERBOSE_PREFIX_3 "Skinny cw: %d, dnd: %d, so: %d, sno: %d\n",
-			sub->parent->callwaiting, sub->parent->dnd, sub->owner ? 1 : 0, sub->next->owner ? 1: 0);
 	}
-	tmpc = skinny_new(sub->owner ? sub->next : sub, AST_STATE_DOWN);
+	tmpc = skinny_new(l, AST_STATE_DOWN);
 	if (!tmpc) {
 		ast_log(LOG_WARNING, "Unable to make channel for '%s'\n", tmp);
 	}
@@ -3133,10 +4085,10 @@
 			} else {
 				memcpy(&bindaddr.sin_addr, hp->h_addr, sizeof(bindaddr.sin_addr));
 			}
-		} else if (!strcasecmp(v->name, "keepAlive")) {
+		} else if (!strcasecmp(v->name, "keepalive")) {
 			keep_alive = atoi(v->value);
-		} else if (!strcasecmp(v->name, "dateFormat")) {
-			strncpy(date_format, v->value, sizeof(date_format) - 1);
+		} else if (!strcasecmp(v->name, "dateformat")) {
+			ast_copy_string(date_format, v->value, sizeof(date_format));
 		} else if (!strcasecmp(v->name, "allow")) {
 			format = ast_getformatbyname(v->value);
 			if (format < 1) {
@@ -3151,17 +4103,21 @@
 			} else {
 				capability &= ~format;
 			}
-		} else if (!strcasecmp(v->name, "port")) {
+		} else if (!strcasecmp(v->name, "bindport") || !strcasecmp(v->name, "port")) {
 			if (sscanf(v->value, "%d", &ourport) == 1) {
 				bindaddr.sin_port = htons(ourport);
 			} else {
-				ast_log(LOG_WARNING, "Invalid port number '%s' at line %d of %s\n", v->value, v->lineno, config);
+				ast_log(LOG_WARNING, "Invalid bindport '%s' at line %d of %s\n", v->value, v->lineno, config);
 			}
+			if (!strcasecmp(v->name, "port")) { /*! \todo Remove 'port' option after 1.4 */
+				ast_log(LOG_WARNING, "Option 'port' at line %d of %s has been deprecated.  Please use 'bindport' instead.\n", v->lineno, config);
+			}
 		}
 		v = v->next;
 	}
+
 	if (ntohl(bindaddr.sin_addr.s_addr)) {
-		memcpy(&__ourip, &bindaddr.sin_addr, sizeof(__ourip));
+		__ourip = bindaddr.sin_addr;
 	} else {
 		hp = ast_gethostbyname(ourhost, &ahp);
 		if (!hp) {
@@ -3248,7 +4204,8 @@
 {
 	struct skinny_device *d, *dlast;
 	struct skinny_line *l, *llast;
-	struct skinny_subchannel *sub, *slast;
+	struct skinny_speeddial *sd, *sdlast;
+	struct skinny_addon *a, *alast;
 
 	ast_mutex_lock(&devicelock);
 
@@ -3256,18 +4213,25 @@
 	for (d=devices;d;) {
 		/* Delete all lines for this device */
 		for (l=d->lines;l;) {
-			/* Delete all subchannels for this line */
-			for (sub=l->sub;sub;) {
-				slast = sub;
-				sub = sub->next;
-				ast_mutex_destroy(&slast->lock);
-				free(slast);
-			}
 			llast = l;
 			l = l->next;
 			ast_mutex_destroy(&llast->lock);
 			free(llast);
 		}
+		/* Delete all speeddials for this device */
+		for (sd=d->speeddials;sd;) {
+			sdlast = sd;
+			sd = sd->next;
+			ast_mutex_destroy(&sdlast->lock);
+			free(sdlast);
+		}
+		/* Delete all addons for this device */
+		for (a=d->addons;a;) {
+			alast = a;
+			a = a->next;
+			ast_mutex_destroy(&alast->lock);
+			free(alast);
+		}
 		dlast = d;
 		d = d->next;
 		free(dlast);
@@ -3300,6 +4264,7 @@
 	ast_cli_register(&cli_show_lines);
 	ast_cli_register(&cli_debug);
 	ast_cli_register(&cli_no_debug);
+	ast_cli_register(&cli_reset_device);
 	sched = sched_context_create();
 	if (!sched) {
 		ast_log(LOG_WARNING, "Unable to create schedule context\n");
@@ -3325,9 +4290,8 @@
 static int unload_module(void *mod)
 {
 #if 0
-	struct skinny_session *session, s;
-	struct skinny_subchannel *sub;
-	struct skinny_line *line = session;
+	struct skinnysession *session, s;
+	struct skinny_line *l = session;
 
 	/* close all IP connections */
 	if (!ast_mutex_lock(&devicelock)) {
@@ -3371,6 +4335,7 @@
 	ast_cli_unregister(&cli_show_lines);
 	ast_cli_unregister(&cli_debug);
 	ast_cli_unregister(&cli_no_debug);
+	ast_cli_unregister(&cli_reset_device);
 
 	return 0;
 #endif

Modified: trunk/configs/skinny.conf.sample
===================================================================
--- trunk/configs/skinny.conf.sample	2006-06-28 01:40:14 UTC (rev 377)
+++ trunk/configs/skinny.conf.sample	2006-06-28 01:41:21 UTC (rev 378)
@@ -2,10 +2,10 @@
 ; Skinny Configuration for Asterisk
 ;
 [general]
-port=2000		; Port to bind to, default tcp/2000
 bindaddr=0.0.0.0	; Address to bind to
-dateFormat=M-D-Y	; M,D,Y in any order (5 chars max)
-keepAlive=120
+bindport=2000		; Port to bind to, default tcp/2000
+dateformat=M-D-Y	; M,D,Y in any order (5 chars max)
+keepalive=120
 
 ;allow=all
 ;disallow=
@@ -41,9 +41,6 @@
 ; Typical config for 12SP+
 ;[florian]
 ;device=SEP00D0BA847E6B
-;model=12SP		; Specific model of device, for button templates
-			; Valid models: 12SP, 30VIP, 7910, 7920,
-			; 7935, 7940, 7960, 7970 (so far)
 ;version=P002G204	; Thanks critch
 ;context=did
 ;line => 120		; Dial(Skinny/120 at florian)
@@ -51,24 +48,24 @@
 
 ; Typical config for a 7910
 ;[duba]			; Device name
-;model=7910		; Device model
 ;device=SEP0007EB463101	; Offical identifier
 ;version=P002F202	; Firmware version identifier
 ;host=192.168.1.144
 ;permit=192.168.0/24	; Optional, used for authentication
-;nat=0
+;nat=yes
 ;callerid="George W. Bush" <202-456-1414>
 ;mailbox=500
-;callwaiting=1
-;transfer=1
-;threewaycalling=1
+;callwaiting=yes
+;transfer=yes
+;threewaycalling=yes
 ;context=default
 ;line => 500		; Dial(Skinny/500 at duba)
 
-; Typical config for a 7940 / ATA
+
+; Typical config for a 7940 with dual 7914s
 ;[support]
 ;device=SEP0007EB463121
-;nat=0
+;nat=yes
 ;callerid="Customer Support" <810-234-1212>
 ;mailbox=100
 ;context=inbound
@@ -80,3 +77,7 @@
 ;linelabel="John"
 ;mailbox=110
 ;line => 110
+;speeddial => 111,Jack Smith
+;speeddial => 112,Bob Peterson
+;addon => 7914
+;addon => 7914



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:42:37 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:42:37 +0200
Subject: [solid-pbx-svn] r380 - in trunk: apps cdr channels codecs formats funcs pbx res sounds
Message-ID: <200606280142.k5S1gbic017927@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:42:31 +0200 (Wed, 28 Jun 2006)
New Revision: 380

Modified:
   trunk/apps/Makefile
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/formats/Makefile
   trunk/funcs/Makefile
   trunk/pbx/Makefile
   trunk/res/Makefile
   trunk/sounds/Makefile
Log:
Update to Asterisk SVN trunk r34743

------------------------------------------------------------------------
r34738 | russell | 2006-06-19 02:14:16 +0200 (Mon, 19 Jun 2006) | 3 lines

don't blow up in the sub Makefiles if menuselect.makeopts is not present. This
is valid in some cases, such as "make clean".

------------------------------------------------------------------------


Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/apps/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_APPS),$(patsubst %.c,%,$(wildcard app_*.c)))
 

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/cdr/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_CDR),$(patsubst %.c,%,$(wildcard cdr_*.c)))
 

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/channels/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_CHANNELS),$(patsubst %.c,%,$(wildcard chan_*.c)))
 

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/codecs/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_CODECS),$(patsubst %.c,%,$(wildcard codec_*.c)))
 

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/formats/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_FORMATS),$(patsubst %.c,%,$(wildcard format_*.c)))
 

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/funcs/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_FUNCS),$(patsubst %.c,%,$(wildcard func_*.c)))
 

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/pbx/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_PBX),$(patsubst %.c,%,$(wildcard pbx_*.c)))
 

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/res/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 SELECTED_MODS:=$(filter-out $(MENUSELECT_RES),$(patsubst %.c,%,$(wildcard res_*.c)))
 

Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-28 01:41:52 UTC (rev 379)
+++ trunk/sounds/Makefile	2006-06-28 01:42:31 UTC (rev 380)
@@ -11,7 +11,9 @@
 # the GNU General Public License
 #
 
-include ../menuselect.makeopts
+ifneq ($(wildcard ../menuselect.makeopts),)
+  include ../menuselect.makeopts
+endif
 
 PWD:=$(shell pwd)
 SOUNDS_DIR:=$(DESTDIR)$(ASTDATADIR)/sounds



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:41:55 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:41:55 +0200
Subject: [solid-pbx-svn] r379 - trunk/channels
Message-ID: <200606280141.k5S1ftm7017789@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:41:52 +0200 (Wed, 28 Jun 2006)
New Revision: 379

Modified:
   trunk/channels/chan_skinny.c
Log:
Update to Asterisk SVN trunk r34723

------------------------------------------------------------------------
r34717 | north | 2006-06-19 01:18:34 +0200 (Mon, 19 Jun 2006) | 2 lines

No need to have debug enabled by default anymore..

------------------------------------------------------------------------


Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-28 01:41:21 UTC (rev 378)
+++ trunk/channels/chan_skinny.c	2006-06-28 01:41:52 UTC (rev 379)
@@ -723,7 +723,7 @@
  * Asterisk specific globals *
  *****************************/
 
-static int skinnydebug = 1;	/* XXX for now, enable debugging default */
+static int skinnydebug = 0;
 
 /* a hostname, portnumber, socket and such is usefull for VoIP protocols */
 static struct sockaddr_in bindaddr;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:43:12 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:43:12 +0200
Subject: [solid-pbx-svn] r381 - trunk/channels
Message-ID: <200606280143.k5S1hCvv017962@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:43:08 +0200 (Wed, 28 Jun 2006)
New Revision: 381

Modified:
   trunk/channels/chan_misdn.c
Log:
Update to Asterisk SVN trunk r34763

------------------------------------------------------------------------
r34762 | crichter | 2006-06-19 09:36:18 +0200 (Mon, 19 Jun 2006) | 1 line

we need to send DISCONNECT on Timeout in the ALERTING/PROCEEDING cases too
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-28 01:42:31 UTC (rev 380)
+++ trunk/channels/chan_misdn.c	2006-06-28 01:43:08 UTC (rev 381)
@@ -3825,7 +3825,9 @@
 			case MISDN_CALLING:
 			case MISDN_DIALING:
 			case MISDN_PROGRESS:
-				
+			case MISDN_ALERTING:
+			case MISDN_PROCEEDING:
+			case MISDN_CALLING_ACKNOWLEDGE:
 				if (bc->nt) {
 					bc->progress_indicator=8;
 					tone_indicate(ch, TONE_BUSY);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:43:58 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:43:58 +0200
Subject: [solid-pbx-svn] r382 - in trunk/channels: . misdn
Message-ID: <200606280143.k5S1hwUQ018030@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:43:54 +0200 (Wed, 28 Jun 2006)
New Revision: 382

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
Log:
Update to Asterisk SVN trunk r34793

------------------------------------------------------------------------
r34788 | crichter | 2006-06-19 11:44:04 +0200 (Mon, 19 Jun 2006) | 1 line

when we get a disconnect, we should stop the tones on te side..
------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-28 01:43:08 UTC (rev 381)
+++ trunk/channels/chan_misdn.c	2006-06-28 01:43:54 UTC (rev 382)
@@ -1971,7 +1971,9 @@
 		return 0;
 	}
 
-	/*stop_bc_tones(p);*/
+	if (!p->bc->nt) 
+		stop_bc_tones(p);
+
 	
 	release_unlock;
 	

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-28 01:43:08 UTC (rev 381)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-28 01:43:54 UTC (rev 382)
@@ -1495,6 +1495,9 @@
 				cb_log(4, stack->port, " --> lib: CLEANING UP l3id: %x\n",frm->dinfo);
 				empty_chan_in_stack(stack,bc->channel);
 				empty_bc(bc);
+				
+				bc_state_change(bc, BCHAN_EMPTY);
+
 				clean_up_bc(bc);
 				dump_chan_list(stack);
 				bc->pid = 0;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:45:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:45:41 +0200
Subject: [solid-pbx-svn] r384 - trunk
Message-ID: <200606280145.k5S1jfQY018144@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:45:30 +0200 (Wed, 28 Jun 2006)
New Revision: 384

Modified:
   trunk/Makefile
Log:
Update to Asterisk SVN trunk r34853

------------------------------------------------------------------------
r34844 | kpfleming | 2006-06-19 17:17:32 +0200 (Mon, 19 Jun 2006) | 2 lines

various cleanups, remove support for CVS checkouts

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 01:44:34 UTC (rev 383)
+++ trunk/Makefile	2006-06-28 01:45:30 UTC (rev 384)
@@ -263,15 +263,8 @@
   RPMVERSION=unknown
 endif
 
-# CVS mirrors of SVN have .svnrevision files showing
-# which SVN revision they are based on, and .svnbranch
-# showing the branch they are made from
-ifneq ($(wildcard .svnrevision),)
+ifneq ($(wildcard .svn),)
   ASTERISKVERSIONNUM=999999
-else
-  ifneq ($(wildcard .svn),)
-    ASTERISKVERSIONNUM=999999
-  endif
 endif
 
 ASTCFLAGS+=$(MALLOC_DEBUG)$(BUSYDETECT)$(OPTIONS)
@@ -458,21 +451,21 @@
 
 defaults.h: makeopts
 	@build_tools/make_defaults_h > $@.tmp
-	@if cmp -s $@.tmp $@ ; then echo ; else \
+	@if cmp -s $@.tmp $@ ; then : ; else \
 		mv $@.tmp $@ ; \
 	fi
 	@rm -f $@.tmp
 
 include/asterisk/version.h:
 	@build_tools/make_version_h > $@.tmp
-	@if cmp -s $@.tmp $@ ; then echo; else \
+	@if cmp -s $@.tmp $@ ; then : ; else \
 		mv $@.tmp $@ ; \
 	fi
 	@rm -f $@.tmp
 
 include/asterisk/buildopts.h: menuselect.makeopts
 	@build_tools/make_buildopts_h > $@.tmp
-	@if cmp -s $@.tmp $@ ; then echo; else \
+	@if cmp -s $@.tmp $@ ; then : ; else \
 		mv $@.tmp $@ ; \
 	fi
 	@rm -f $@.tmp
@@ -547,16 +540,6 @@
 		fi ; \
 		rm -f update.out; \
 		$(MAKE) clean-depend; \
-	elif [ -d CVS ]; then \
-		echo "Updating from CVS..." ; \
-		cvs -q -z3 update -Pd | tee update.out; \
-		rm -f .version; \
-		if [ `grep -c ^C update.out` -gt 0 ]; then \
-			echo ; echo "The following files have conflicts:" ; \
-			grep ^C update.out | cut -d' ' -f2- ; \
-		fi ; \
-		rm -f update.out; \
-		$(MAKE) clean-depend; \
 	else \
 		echo "Not under version control";  \
 	fi
@@ -603,11 +586,7 @@
 	$(INSTALL) -m 644 contrib/scripts/astgenkey.8 $(DESTDIR)$(ASTMANDIR)/man8
 	$(INSTALL) -m 644 contrib/scripts/autosupport.8 $(DESTDIR)$(ASTMANDIR)/man8
 	$(INSTALL) -m 644 contrib/scripts/safe_asterisk.8 $(DESTDIR)$(ASTMANDIR)/man8
-	if [ -d contrib/firmware/iax ]; then \
-		$(INSTALL) -m 644 contrib/firmware/iax/iaxy.bin $(DESTDIR)$(ASTDATADIR)/firmware/iax/iaxy.bin; \
-	else \
-		echo "You need to do cvs update -d not just cvs update" ; \
-	fi 
+	$(INSTALL) -m 644 contrib/firmware/iax/iaxy.bin $(DESTDIR)$(ASTDATADIR)/firmware/iax/iaxy.bin; \
 
 install-subdirs:
 	@for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:44:54 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:44:54 +0200
Subject: [solid-pbx-svn] r383 - trunk/build_tools
Message-ID: <200606280144.k5S1ish2018080@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:44:34 +0200 (Wed, 28 Jun 2006)
New Revision: 383

Modified:
   trunk/build_tools/menuselect.c
Log:
Update to Asterisk SVN trunk r34823

------------------------------------------------------------------------
r34818 | russell | 2006-06-19 16:24:35 +0200 (Mon, 19 Jun 2006) | 3 lines

copy the definition of ast_strdupa and use it instead of strdupa to fix the
build on systems that don't have it, such as mac

------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-28 01:43:54 UTC (rev 382)
+++ trunk/build_tools/menuselect.c	2006-06-28 01:44:34 UTC (rev 383)
@@ -70,6 +70,18 @@
 /*! This is set when the --check-deps argument is provided. */
 static int check_deps = 0;
 
+#if !defined(ast_strdupa) && defined(__GNUC__)
+#define ast_strdupa(s)                                                    \
+	(__extension__                                                    \
+	({                                                                \
+		const char *__old = (s);                                  \
+		size_t __len = strlen(__old) + 1;                         \
+		char *__new = __builtin_alloca(__len);                    \
+		memcpy (__new, __old, __len);                             \
+		__new;                                                    \
+	}))
+#endif
+
 /*! \brief return a pointer to the first non-whitespace character */
 static inline char *skip_blanks(char *str)
 {
@@ -516,7 +528,7 @@
 			had_changes = 1;
 
 			if (mem->remove_on_change) {
-				for (buf = strdupa(mem->remove_on_change), file = strsep(&buf, " ");
+				for (buf = ast_strdupa(mem->remove_on_change), file = strsep(&buf, " ");
 				     file;
 				     file = strsep(&buf, " "))
 					unlink(file);
@@ -524,7 +536,7 @@
 		}
 
 		if (cat->remove_on_change && had_changes) {
-			for (buf = strdupa(cat->remove_on_change), file = strsep(&buf, " ");
+			for (buf = ast_strdupa(cat->remove_on_change), file = strsep(&buf, " ");
 			     file;
 			     file = strsep(&buf, " "))
 				unlink(file);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:47:06 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:47:06 +0200
Subject: [solid-pbx-svn] r385 - trunk/apps
Message-ID: <200606280147.k5S1l6bN018558@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:46:26 +0200 (Wed, 28 Jun 2006)
New Revision: 385

Modified:
   trunk/apps/app_voicemail.c
Log:
Update to Asterisk SVN trunk r34883

------------------------------------------------------------------------
r34876 | tilghman | 2006-06-19 20:11:04 +0200 (Mon, 19 Jun 2006) | 10 lines

Merged revisions 34875 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34875 | tilghman | 2006-06-19 13:07:26 -0500 (Mon, 19 Jun 2006) | 2 lines

Issue 7357 - txt file left behind when going to operator.  Also, fix a possible file descriptor leak.

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 01:45:30 UTC (rev 384)
+++ trunk/apps/app_voicemail.c	2006-06-28 01:46:26 UTC (rev 385)
@@ -2632,6 +2632,7 @@
 			if (duration < vmminmessage) {
 				if (option_verbose > 2) 
 					ast_verbose( VERBOSE_PREFIX_3 "Recording was %d seconds long but needs to be at least %d - abandoning\n", duration, vmminmessage);
+				fclose(txt);
 				ast_filedelete(tmptxtfile, NULL);
 				unlink(tmptxtfile);
 			} else {
@@ -2642,6 +2643,10 @@
 					/* Delete files */
 					ast_filedelete(tmptxtfile, NULL);
 					unlink(tmptxtfile);
+				} else if (ast_fileexists(tmptxtfile, NULL, NULL) <= 0) {
+					if (option_debug) 
+						ast_log(LOG_DEBUG, "The recorded media file is gone, so we should remove the .txt file too!\n");
+					unlink(tmptxtfile);	
 				} else {
 					for (;;) {
 						make_file(fn, sizeof(fn), dir, msgnum);
@@ -2675,7 +2680,7 @@
 							free_user(recip);
 						}
 					}
-					if (ast_fileexists(fn, NULL, NULL)) {
+					if (ast_fileexists(fn, NULL, NULL) > 0) {
 						STORE(dir, vmu->mailbox, vmu->context, msgnum);
 						notify_new_message(chan, vmu, msgnum, duration, fmt, chan->cid.cid_num, chan->cid.cid_name);
 						DISPOSE(dir, msgnum);



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:48:03 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:48:03 +0200
Subject: [solid-pbx-svn] r386 - trunk/apps
Message-ID: <200606280148.k5S1m3Ub018735@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:47:41 +0200 (Wed, 28 Jun 2006)
New Revision: 386

Modified:
   trunk/apps/app_voicemail.c
Log:
Update to Asterisk SVN trunk r34913

------------------------------------------------------------------------
r34912 | file | 2006-06-19 22:29:08 +0200 (Mon, 19 Jun 2006) | 10 lines

Merged revisions 34911 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r34911 | file | 2006-06-19 17:27:44 -0300 (Mon, 19 Jun 2006) | 2 lines

Call reset_user_pw upon changing the password using externpass (issue #7395 reported by Ryan Cumming)

.......

------------------------------------------------------------------------


Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 01:46:26 UTC (rev 385)
+++ trunk/apps/app_voicemail.c	2006-06-28 01:47:41 UTC (rev 386)
@@ -792,8 +792,10 @@
 {
 	char buf[255];
 	snprintf(buf,255,"%s %s %s %s",ext_pass_cmd,vmu->context,vmu->mailbox,newpassword);
-	if (!ast_safe_system(buf))
+	if (!ast_safe_system(buf)) {
+		reset_user_pw(vmu->context, vmu->mailbox, newpassword);
 		ast_copy_string(vmu->password, newpassword, sizeof(vmu->password));
+	}
 }
 
 static int make_dir(char *dest, int len, const char *context, const char *ext, const char *folder)



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:48:48 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:48:48 +0200
Subject: [solid-pbx-svn] r387 - trunk/channels
Message-ID: <200606280148.k5S1mmfC018996@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:48:44 +0200 (Wed, 28 Jun 2006)
New Revision: 387

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r34953

------------------------------------------------------------------------
r34951 | oej | 2006-06-19 23:09:24 +0200 (Mon, 19 Jun 2006) | 3 lines

- Formatting 
- Create larger buffer for managing long auth headers from clients (adviced by SNOM)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 01:47:41 UTC (rev 386)
+++ trunk/channels/chan_sip.c	2006-06-28 01:48:44 UTC (rev 387)
@@ -7608,7 +7608,27 @@
 	const char *reqheader = "Proxy-Authorization";
 	const char *respheader = "Proxy-Authenticate";
 	const char *authtoken;
+	char a1_hash[256];
+	char resp_hash[256]="";
+	char tmp[BUFSIZ * 2];                /* Make a large enough buffer */
+	char *c;
+	int  wrongnonce = FALSE;
+	int  good_response;
+	const char *usednonce = p->randdata;
 
+	/* table of recognised keywords, and their value in the digest */
+	enum keys { K_RESP, K_URI, K_USER, K_NONCE, K_LAST };
+	struct x {
+		const char *key;
+		const char *s;
+	} *i, keys[] = {
+		[K_RESP] = { "response=", "" },
+		[K_URI] = { "uri=", "" },
+		[K_USER] = { "username=", "" },
+		[K_NONCE] = { "nonce=", "" },
+		[K_LAST] = { NULL, NULL}
+	};
+
 	/* Always OK if no secret */
 	if (ast_strlen_zero(secret) && ast_strlen_zero(md5secret))
 		return AUTH_SUCCESSFUL;
@@ -7639,120 +7659,102 @@
 		/* Schedule auto destroy in 32 seconds */
 		sip_scheddestroy(p, SIP_TRANS_TIMEOUT);
 		return AUTH_CHALLENGE_SENT;
-	} else {	/* We have auth, so check it */
+	} 
 
-		/* XXX reduce nesting here */
+	/* --- We have auth, so check it */
 
-		/* Whoever came up with the authentication section of SIP can suck my %&#$&* for not putting
-	   	an example in the spec of just what it is you're doing a hash on. */
-		char a1_hash[256];
-		char resp_hash[256]="";
-		char tmp[256];
-		char *c;
-		int  wrongnonce = FALSE;
-		int  good_response;
-		const char *usednonce = p->randdata; /* XXX check */
+	/* Whoever came up with the authentication section of SIP can suck my %&#$&* for not putting
+   	   an example in the spec of just what it is you're doing a hash on. */
 
-		/* table of recognised keywords, and their value in the digest */
-		enum keys { K_RESP, K_URI, K_USER, K_NONCE, K_LAST };
-		struct x {
-			const char *key;
-			const char *s;
-		} *i, keys[] = {
-			[K_RESP] = { "response=", "" },
-			[K_URI] = { "uri=", "" },
-			[K_USER] = { "username=", "" },
-			[K_NONCE] = { "nonce=", "" },
-			[K_LAST] = { NULL, NULL}
-		};
 
-		/* Make a copy of the response and parse it */
-		ast_copy_string(tmp, authtoken, sizeof(tmp));
-		c = tmp;
+	/* Make a copy of the response and parse it */
+	ast_copy_string(tmp, authtoken, sizeof(tmp));
+	c = tmp;
 
-		while(c && *(c = ast_skip_blanks(c)) ) { /* lookup for keys */
-			for (i = keys; i->key != NULL; i++) {
-				const char *separator = ",";	/* default */
+	while(c && *(c = ast_skip_blanks(c)) ) { /* lookup for keys */
+		for (i = keys; i->key != NULL; i++) {
+			const char *separator = ",";	/* default */
 
-				if (strncasecmp(c, i->key, strlen(i->key)) != 0)
-					continue;
-				/* Found. Skip keyword, take text in quotes or up to the separator. */
-				c += strlen(i->key);
-				if (*c == '"') { /* in quotes. Skip first and look for last */
-					c++;
-					separator = "\"";
-				}
-				i->s = c;
-				strsep(&c, separator);
-				break;
+			if (strncasecmp(c, i->key, strlen(i->key)) != 0)
+				continue;
+			/* Found. Skip keyword, take text in quotes or up to the separator. */
+			c += strlen(i->key);
+			if (*c == '"') { /* in quotes. Skip first and look for last */
+				c++;
+				separator = "\"";
 			}
-			if (i->key == NULL) /* not found, jump after space or comma */
-				strsep(&c, " ,");
+			i->s = c;
+			strsep(&c, separator);
+			break;
 		}
-		/* Verify that digest username matches  the username we auth as */
-		if (strcmp(username, keys[K_USER].s)) {
-			ast_log(LOG_WARNING, "username mismatch, have <%s>, digest has <%s>\n",
-				username, keys[K_USER].s);
-			/* Oops, we're trying something here */
-			return AUTH_USERNAME_MISMATCH;
-		}
+		if (i->key == NULL) /* not found, jump after space or comma */
+			strsep(&c, " ,");
+	}
 
-		/* Verify nonce from request matches our nonce.  If not, send 401 with new nonce */
-		if (strcasecmp(p->randdata, keys[K_NONCE].s)) { /* XXX it was 'n'casecmp ? */
-			wrongnonce = TRUE;
-			usednonce = keys[K_NONCE].s;
-		}
+	/* Verify that digest username matches  the username we auth as */
+	if (strcmp(username, keys[K_USER].s)) {
+		ast_log(LOG_WARNING, "username mismatch, have <%s>, digest has <%s>\n",
+			username, keys[K_USER].s);
+		/* Oops, we're trying something here */
+		return AUTH_USERNAME_MISMATCH;
+	}
 
-		if (!ast_strlen_zero(md5secret))
-			ast_copy_string(a1_hash, md5secret, sizeof(a1_hash));
-		else {
-			char a1[256];
-			snprintf(a1, sizeof(a1), "%s:%s:%s", username, global_realm, secret);
-			ast_md5_hash(a1_hash, a1);
-		}
+	/* Verify nonce from request matches our nonce.  If not, send 401 with new nonce */
+	if (strcasecmp(p->randdata, keys[K_NONCE].s)) { /* XXX it was 'n'casecmp ? */
+		wrongnonce = TRUE;
+		usednonce = keys[K_NONCE].s;
+	}
 
-		/* compute the expected response to compare with what we received */
-		{
-			char a2[256];
-			char a2_hash[256];
-			char resp[256];
+	if (!ast_strlen_zero(md5secret))
+		ast_copy_string(a1_hash, md5secret, sizeof(a1_hash));
+	else {
+		char a1[256];
+		snprintf(a1, sizeof(a1), "%s:%s:%s", username, global_realm, secret);
+		ast_md5_hash(a1_hash, a1);
+	}
 
-			snprintf(a2, sizeof(a2), "%s:%s", sip_methods[sipmethod].text,
-					S_OR(keys[K_URI].s, uri));
-			ast_md5_hash(a2_hash, a2);
-			snprintf(resp, sizeof(resp), "%s:%s:%s", a1_hash, usednonce, a2_hash);
-			ast_md5_hash(resp_hash, resp);
-		}
+	/* compute the expected response to compare with what we received */
+	{
+		char a2[256];
+		char a2_hash[256];
+		char resp[256];
 
-		good_response = keys[K_RESP].s &&
-				!strncasecmp(keys[K_RESP].s, resp_hash, strlen(resp_hash));
-		if (wrongnonce) {
-			ast_string_field_build(p, randdata, "%08lx", ast_random());
-			if (good_response) {
-				if (sipdebug)
-					ast_log(LOG_NOTICE, "stale nonce received from '%s'\n", get_header(req, "To"));
-				/* We got working auth token, based on stale nonce . */
-				transmit_response_with_auth(p, response, req, p->randdata, reliable, respheader, 1);
-			} else {
-				/* Everything was wrong, so give the device one more try with a new challenge */
-				if (sipdebug)
-					ast_log(LOG_NOTICE, "Bad authentication received from '%s'\n", get_header(req, "To"));
-				transmit_response_with_auth(p, response, req, p->randdata, reliable, respheader, 0);
-			}
+		snprintf(a2, sizeof(a2), "%s:%s", sip_methods[sipmethod].text,
+				S_OR(keys[K_URI].s, uri));
+		ast_md5_hash(a2_hash, a2);
+		snprintf(resp, sizeof(resp), "%s:%s:%s", a1_hash, usednonce, a2_hash);
+		ast_md5_hash(resp_hash, resp);
+	}
 
-			/* Schedule auto destroy in 32 seconds */
-			sip_scheddestroy(p, SIP_TRANS_TIMEOUT);
-			return AUTH_CHALLENGE_SENT;
-		} 
-		if (good_response)
-			return AUTH_SUCCESSFUL;
+	good_response = keys[K_RESP].s &&
+			!strncasecmp(keys[K_RESP].s, resp_hash, strlen(resp_hash));
+	if (wrongnonce) {
+		ast_string_field_build(p, randdata, "%08lx", ast_random());
+		if (good_response) {
+			if (sipdebug)
+				ast_log(LOG_NOTICE, "Correct auth, but based on stale nonce received from '%s'\n", get_header(req, "To"));
+			/* We got working auth token, based on stale nonce . */
+			transmit_response_with_auth(p, response, req, p->randdata, reliable, respheader, 1);
+		} else {
+			/* Everything was wrong, so give the device one more try with a new challenge */
+			if (sipdebug)
+				ast_log(LOG_NOTICE, "Bad authentication received from '%s'\n", get_header(req, "To"));
+			transmit_response_with_auth(p, response, req, p->randdata, reliable, respheader, 0);
+		}
 
-		/* Ok, we have a bad username/secret pair */
-		/* Challenge again, and again, and again */
-		transmit_response_with_auth(p, response, req, p->randdata, reliable, respheader, 0);
+		/* Schedule auto destroy in 32 seconds */
 		sip_scheddestroy(p, SIP_TRANS_TIMEOUT);
 		return AUTH_CHALLENGE_SENT;
-	}
+	} 
+	if (good_response)
+		return AUTH_SUCCESSFUL;
+
+	/* Ok, we have a bad username/secret pair */
+	/* Challenge again, and again, and again */
+	transmit_response_with_auth(p, response, req, p->randdata, reliable, respheader, 0);
+	sip_scheddestroy(p, SIP_TRANS_TIMEOUT);
+
+	return AUTH_CHALLENGE_SENT;
 }
 
 /*! \brief Callback for the devicestate notification (SUBSCRIBE) support subsystem



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:58:19 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:58:19 +0200
Subject: [solid-pbx-svn] r388 - trunk
Message-ID: <200606280158.k5S1wJnb019684@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:58:07 +0200 (Wed, 28 Jun 2006)
New Revision: 388

Modified:
   trunk/Makefile
   trunk/ast_expr2.c
   trunk/ast_expr2.fl
   trunk/ast_expr2.h
   trunk/ast_expr2.y
   trunk/ast_expr2f.c
Log:
Update to Asterisk SVN trunk r34983

------------------------------------------------------------------------
r34980 | russell | 2006-06-20 03:06:50 +0200 (Tue, 20 Jun 2006) | 9 lines

- use $(CC) instead of gcc when building testexpr2
- modify ast_expr2.fl and ast_expr2.y to not try to register the file version
  in a STANDALONE build
- add config.status as a dependency on testexpr2 to ensure configure is
  executed before building it
- add include/asterisk/buildopts.h as a dependency for testexpr2 as well
- add -Iinclude to the gcc commands for building the testexpr2 objects so that
  it can find the local asterisk headers

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 01:48:44 UTC (rev 387)
+++ trunk/Makefile	2006-06-28 01:58:07 UTC (rev 388)
@@ -423,10 +423,10 @@
 ast_expr2f.c:
 	flex -o $@ --full ast_expr2.fl
 
-testexpr2: ast_expr2f.c ast_expr2.c ast_expr2.h
-	gcc -g -c -DSTANDALONE ast_expr2f.c
-	gcc -g -c -DSTANDALONE ast_expr2.c
-	gcc -g -o testexpr2 ast_expr2f.o ast_expr2.o
+testexpr2: config.status include/asterisk/buildopts.h ast_expr2f.c ast_expr2.c ast_expr2.h
+	$(CC) -g -c -Iinclude -DSTANDALONE ast_expr2f.c
+	$(CC) -g -c -Iinclude -DSTANDALONE ast_expr2.c
+	$(CC) -g -o testexpr2 ast_expr2f.o ast_expr2.o
 	rm ast_expr2.o ast_expr2f.o 
 
 manpage: asterisk.8

Modified: trunk/ast_expr2.c
===================================================================
--- trunk/ast_expr2.c	2006-06-28 01:48:44 UTC (rev 387)
+++ trunk/ast_expr2.c	2006-06-28 01:58:07 UTC (rev 388)
@@ -1,8 +1,10 @@
-/* A Bison parser, made by GNU Bison 2.1a.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+/* Skeleton implementation for Bison's Yacc-like parsers in C
 
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
@@ -18,11 +20,19 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
@@ -37,7 +47,7 @@
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "2.1a"
+#define YYBISON_VERSION "2.3"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -131,7 +141,9 @@
 
 #include "asterisk.h"
 
+#ifndef STANDALONE
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+#endif
 
 #include <sys/types.h>
 #include <stdio.h>
@@ -276,12 +288,12 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 140 "ast_expr2.y"
+#line 147 "ast_expr2.y"
 {
 	struct val *val;
 }
-/* Line 198 of yacc.c.  */
-#line 276 "ast_expr2.c"
+/* Line 193 of yacc.c.  */
+#line 293 "ast_expr2.c"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
@@ -303,13 +315,13 @@
 
 
 /* Copy the second part of user declarations.  */
-#line 144 "ast_expr2.y"
+#line 151 "ast_expr2.y"
 
 extern int		ast_yylex __P((YYSTYPE *, YYLTYPE *, yyscan_t));
 
 
-/* Line 221 of yacc.c.  */
-#line 304 "ast_expr2.c"
+/* Line 216 of yacc.c.  */
+#line 321 "ast_expr2.c"
 
 #ifdef short
 # undef short
@@ -439,8 +451,13 @@
 #  ifndef YYSTACK_ALLOC_MAXIMUM
 #   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
 #  endif
-#  ifdef __cplusplus
-extern "C" {
+#  if (defined __cplusplus && ! defined _STDLIB_H \
+       && ! ((defined YYMALLOC || defined malloc) \
+	     && (defined YYFREE || defined free)))
+#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
+#   ifndef _STDLIB_H
+#    define _STDLIB_H 1
+#   endif
 #  endif
 #  ifndef YYMALLOC
 #   define YYMALLOC malloc
@@ -456,9 +473,6 @@
 void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
-#  ifdef __cplusplus
-}
-#  endif
 # endif
 #endif /* ! defined yyoverflow || YYERROR_VERBOSE */
 
@@ -602,9 +616,9 @@
 /* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
 static const yytype_uint16 yyrline[] =
 {
-       0,   168,   168,   176,   183,   184,   188,   192,   196,   200,
-     204,   208,   212,   216,   220,   224,   228,   232,   236,   240,
-     244,   248,   252,   256
+       0,   175,   175,   183,   190,   191,   195,   199,   203,   207,
+     211,   215,   219,   223,   227,   231,   235,   239,   243,   247,
+     251,   255,   259,   263
 };
 #endif
 
@@ -862,14 +876,14 @@
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, const YYSTYPE * const yyvaluep, const YYLTYPE * const yylocationp)
+yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
 #else
 static void
 yy_symbol_value_print (yyoutput, yytype, yyvaluep, yylocationp)
     FILE *yyoutput;
     int yytype;
-    const YYSTYPE * const yyvaluep;
-    const YYLTYPE * const yylocationp;
+    YYSTYPE const * const yyvaluep;
+    YYLTYPE const * const yylocationp;
 #endif
 {
   if (!yyvaluep)
@@ -896,14 +910,14 @@
 #if (defined __STDC__ || defined __C99__FUNC__ \
      || defined __cplusplus || defined _MSC_VER)
 static void
-yy_symbol_print (FILE *yyoutput, int yytype, const YYSTYPE * const yyvaluep, const YYLTYPE * const yylocationp)
+yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep, YYLTYPE const * const yylocationp)
 #else
 static void
 yy_symbol_print (yyoutput, yytype, yyvaluep, yylocationp)
     FILE *yyoutput;
     int yytype;
-    const YYSTYPE * const yyvaluep;
-    const YYLTYPE * const yylocationp;
+    YYSTYPE const * const yyvaluep;
+    YYLTYPE const * const yylocationp;
 #endif
 {
   if (yytype < YYNTOKENS)
@@ -956,8 +970,7 @@
 yy_reduce_print (YYSTYPE *yyvsp, YYLTYPE *yylsp, int yyrule)
 #else
 static void
-yy_reduce_print (yyvsp, yylsp, yyrule
-		   )
+yy_reduce_print (yyvsp, yylsp, yyrule)
     YYSTYPE *yyvsp;
     YYLTYPE *yylsp;
     int yyrule;
@@ -1080,7 +1093,7 @@
 {
   if (*yystr == '"')
     {
-      size_t yyn = 0;
+      YYSIZE_T yyn = 0;
       char const *yyp = yystr;
 
       for (;;)
@@ -1127,7 +1140,7 @@
 {
   int yyn = yypact[yystate];
 
-  if (! (YYPACT_NINF < yyn && yyn < YYLAST))
+  if (! (YYPACT_NINF < yyn && yyn <= YYLAST))
     return 0;
   else
     {
@@ -1165,7 +1178,7 @@
       int yyxbegin = yyn < 0 ? -yyn : 0;
 
       /* Stay within bounds of both yycheck and yytname.  */
-      int yychecklim = YYLAST - yyn;
+      int yychecklim = YYLAST - yyn + 1;
       int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
       int yycount = 1;
 
@@ -1253,114 +1266,114 @@
   switch (yytype)
     {
       case 3: /* "TOK_COLONCOLON" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1250 "ast_expr2.c"
+#line 1268 "ast_expr2.c"
 	break;
       case 4: /* "TOK_COND" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1255 "ast_expr2.c"
+#line 1273 "ast_expr2.c"
 	break;
       case 5: /* "TOK_OR" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1260 "ast_expr2.c"
+#line 1278 "ast_expr2.c"
 	break;
       case 6: /* "TOK_AND" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1265 "ast_expr2.c"
+#line 1283 "ast_expr2.c"
 	break;
       case 7: /* "TOK_NE" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1270 "ast_expr2.c"
+#line 1288 "ast_expr2.c"
 	break;
       case 8: /* "TOK_LE" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1275 "ast_expr2.c"
+#line 1293 "ast_expr2.c"
 	break;
       case 9: /* "TOK_GE" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1280 "ast_expr2.c"
+#line 1298 "ast_expr2.c"
 	break;
       case 10: /* "TOK_LT" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1285 "ast_expr2.c"
+#line 1303 "ast_expr2.c"
 	break;
       case 11: /* "TOK_GT" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1290 "ast_expr2.c"
+#line 1308 "ast_expr2.c"
 	break;
       case 12: /* "TOK_EQ" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1295 "ast_expr2.c"
+#line 1313 "ast_expr2.c"
 	break;
       case 13: /* "TOK_MINUS" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1300 "ast_expr2.c"
+#line 1318 "ast_expr2.c"
 	break;
       case 14: /* "TOK_PLUS" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1305 "ast_expr2.c"
+#line 1323 "ast_expr2.c"
 	break;
       case 15: /* "TOK_MOD" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1310 "ast_expr2.c"
+#line 1328 "ast_expr2.c"
 	break;
       case 16: /* "TOK_DIV" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1315 "ast_expr2.c"
+#line 1333 "ast_expr2.c"
 	break;
       case 17: /* "TOK_MULT" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1320 "ast_expr2.c"
+#line 1338 "ast_expr2.c"
 	break;
       case 18: /* "TOK_COMPL" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1325 "ast_expr2.c"
+#line 1343 "ast_expr2.c"
 	break;
       case 19: /* "TOK_EQTILDE" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1330 "ast_expr2.c"
+#line 1348 "ast_expr2.c"
 	break;
       case 20: /* "TOK_COLON" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1335 "ast_expr2.c"
+#line 1353 "ast_expr2.c"
 	break;
       case 21: /* "TOK_LP" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1340 "ast_expr2.c"
+#line 1358 "ast_expr2.c"
 	break;
       case 22: /* "TOK_RP" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1345 "ast_expr2.c"
+#line 1363 "ast_expr2.c"
 	break;
       case 23: /* "TOKEN" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1350 "ast_expr2.c"
+#line 1368 "ast_expr2.c"
 	break;
       case 26: /* "expr" */
-#line 162 "ast_expr2.y"
+#line 169 "ast_expr2.y"
 	{  free_value((yyvaluep->val)); };
-#line 1355 "ast_expr2.c"
+#line 1373 "ast_expr2.c"
 	break;
 
       default:
@@ -1683,7 +1696,7 @@
   switch (yyn)
     {
         case 2:
-#line 168 "ast_expr2.y"
+#line 175 "ast_expr2.y"
     { ((struct parse_io *)parseio)->val = (struct val *)calloc(sizeof(struct val),1);
               ((struct parse_io *)parseio)->val->type = (yyvsp[(1) - (1)].val)->type;
               if( (yyvsp[(1) - (1)].val)->type == AST_EXPR_integer )
@@ -1695,7 +1708,7 @@
     break;
 
   case 3:
-#line 176 "ast_expr2.y"
+#line 183 "ast_expr2.y"
     {/* nothing */ ((struct parse_io *)parseio)->val = (struct val *)calloc(sizeof(struct val),1);
               ((struct parse_io *)parseio)->val->type = AST_EXPR_string;
 			  ((struct parse_io *)parseio)->val->u.s = strdup(""); 
@@ -1703,12 +1716,12 @@
     break;
 
   case 4:
-#line 183 "ast_expr2.y"
+#line 190 "ast_expr2.y"
     { (yyval.val)= (yyvsp[(1) - (1)].val);;}
     break;
 
   case 5:
-#line 184 "ast_expr2.y"
+#line 191 "ast_expr2.y"
     { (yyval.val) = (yyvsp[(2) - (3)].val); 
 	                       (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
 						   (yyloc).first_line=0; (yyloc).last_line=0;
@@ -1716,7 +1729,7 @@
     break;
 
   case 6:
-#line 188 "ast_expr2.y"
+#line 195 "ast_expr2.y"
     { (yyval.val) = op_or ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val));
 						DESTROY((yyvsp[(2) - (3)].val));	
                          (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1724,7 +1737,7 @@
     break;
 
   case 7:
-#line 192 "ast_expr2.y"
+#line 199 "ast_expr2.y"
     { (yyval.val) = op_and ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                      (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1732,7 +1745,7 @@
     break;
 
   case 8:
-#line 196 "ast_expr2.y"
+#line 203 "ast_expr2.y"
     { (yyval.val) = op_eq ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val));
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                     (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column;
@@ -1740,7 +1753,7 @@
     break;
 
   case 9:
-#line 200 "ast_expr2.y"
+#line 207 "ast_expr2.y"
     { (yyval.val) = op_gt ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val));
 						DESTROY((yyvsp[(2) - (3)].val));	
                          (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column;
@@ -1748,7 +1761,7 @@
     break;
 
   case 10:
-#line 204 "ast_expr2.y"
+#line 211 "ast_expr2.y"
     { (yyval.val) = op_lt ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                     (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1756,7 +1769,7 @@
     break;
 
   case 11:
-#line 208 "ast_expr2.y"
+#line 215 "ast_expr2.y"
     { (yyval.val) = op_ge ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                      (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1764,7 +1777,7 @@
     break;
 
   case 12:
-#line 212 "ast_expr2.y"
+#line 219 "ast_expr2.y"
     { (yyval.val) = op_le ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                      (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1772,7 +1785,7 @@
     break;
 
   case 13:
-#line 216 "ast_expr2.y"
+#line 223 "ast_expr2.y"
     { (yyval.val) = op_ne ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                      (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1780,7 +1793,7 @@
     break;
 
   case 14:
-#line 220 "ast_expr2.y"
+#line 227 "ast_expr2.y"
     { (yyval.val) = op_plus ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                       (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1788,7 +1801,7 @@
     break;
 
   case 15:
-#line 224 "ast_expr2.y"
+#line 231 "ast_expr2.y"
     { (yyval.val) = op_minus ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                        (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1796,7 +1809,7 @@
     break;
 
   case 16:
-#line 228 "ast_expr2.y"
+#line 235 "ast_expr2.y"
     { (yyval.val) = op_negate ((yyvsp[(2) - (2)].val)); 
 						DESTROY((yyvsp[(1) - (2)].val));	
 	                        (yyloc).first_column = (yylsp[(1) - (2)]).first_column; (yyloc).last_column = (yylsp[(2) - (2)]).last_column; 
@@ -1804,7 +1817,7 @@
     break;
 
   case 17:
-#line 232 "ast_expr2.y"
+#line 239 "ast_expr2.y"
     { (yyval.val) = op_compl ((yyvsp[(2) - (2)].val)); 
 						DESTROY((yyvsp[(1) - (2)].val));	
 	                        (yyloc).first_column = (yylsp[(1) - (2)]).first_column; (yyloc).last_column = (yylsp[(2) - (2)]).last_column; 
@@ -1812,7 +1825,7 @@
     break;
 
   case 18:
-#line 236 "ast_expr2.y"
+#line 243 "ast_expr2.y"
     { (yyval.val) = op_times ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                       (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1820,7 +1833,7 @@
     break;
 
   case 19:
-#line 240 "ast_expr2.y"
+#line 247 "ast_expr2.y"
     { (yyval.val) = op_div ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                      (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1828,7 +1841,7 @@
     break;
 
   case 20:
-#line 244 "ast_expr2.y"
+#line 251 "ast_expr2.y"
     { (yyval.val) = op_rem ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                      (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1836,7 +1849,7 @@
     break;
 
   case 21:
-#line 248 "ast_expr2.y"
+#line 255 "ast_expr2.y"
     { (yyval.val) = op_colon ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                        (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1844,7 +1857,7 @@
     break;
 
   case 22:
-#line 252 "ast_expr2.y"
+#line 259 "ast_expr2.y"
     { (yyval.val) = op_eqtilde ((yyvsp[(1) - (3)].val), (yyvsp[(3) - (3)].val)); 
 						DESTROY((yyvsp[(2) - (3)].val));	
 	                        (yyloc).first_column = (yylsp[(1) - (3)]).first_column; (yyloc).last_column = (yylsp[(3) - (3)]).last_column; 
@@ -1852,7 +1865,7 @@
     break;
 
   case 23:
-#line 256 "ast_expr2.y"
+#line 263 "ast_expr2.y"
     { (yyval.val) = op_cond ((yyvsp[(1) - (5)].val), (yyvsp[(3) - (5)].val), (yyvsp[(5) - (5)].val)); 
 						DESTROY((yyvsp[(2) - (5)].val));	
 						DESTROY((yyvsp[(4) - (5)].val));	
@@ -1861,8 +1874,8 @@
     break;
 
 
-/* Line 1270 of yacc.c.  */
-#line 1857 "ast_expr2.c"
+/* Line 1267 of yacc.c.  */
+#line 1875 "ast_expr2.c"
       default: break;
     }
   YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
@@ -2077,11 +2090,12 @@
   if (yymsg != yymsgbuf)
     YYSTACK_FREE (yymsg);
 #endif
-  return yyresult;
+  /* Make sure YYID is used.  */
+  return YYID (yyresult);
 }
 
 
-#line 263 "ast_expr2.y"
+#line 270 "ast_expr2.y"
 
 
 static struct val *

Modified: trunk/ast_expr2.fl
===================================================================
--- trunk/ast_expr2.fl	2006-06-28 01:48:44 UTC (rev 387)
+++ trunk/ast_expr2.fl	2006-06-28 01:58:07 UTC (rev 388)
@@ -24,7 +24,9 @@
 
 #include "asterisk.h"
 
+#ifndef STANDALONE
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+#endif
 
 #include <sys/types.h>
 #include <stdio.h>

Modified: trunk/ast_expr2.h
===================================================================
--- trunk/ast_expr2.h	2006-06-28 01:48:44 UTC (rev 387)
+++ trunk/ast_expr2.h	2006-06-28 01:58:07 UTC (rev 388)
@@ -1,8 +1,10 @@
-/* A Bison parser, made by GNU Bison 2.1a.  */
+/* A Bison parser, made by GNU Bison 2.3.  */
 
-/* Skeleton parser for Yacc-like parsing with Bison,
-   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
+/* Skeleton interface for Bison's Yacc-like parsers in C
 
+   Copyright (C) 1984, 1989, 1990, 2000, 2001, 2002, 2003, 2004, 2005, 2006
+   Free Software Foundation, Inc.
+
    This program is free software; you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation; either version 2, or (at your option)
@@ -18,11 +20,19 @@
    Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.  */
 
-/* As a special exception, when this file is copied by Bison into a
-   Bison output file, you may use that output file without restriction.
-   This special exception was added by the Free Software Foundation
-   in version 1.24 of Bison.  */
+/* As a special exception, you may create a larger work that contains
+   part or all of the Bison parser skeleton and distribute that work
+   under terms of your choice, so long as that work isn't itself a
+   parser generator using the skeleton or a modified version thereof
+   as a parser skeleton.  Alternatively, if you modify or redistribute
+   the parser skeleton itself, you may (at your option) remove this
+   special exception, which will cause the skeleton and the resulting
+   Bison output files to be licensed under the GNU General Public
+   License without this special exception.
 
+   This special exception was added by the Free Software Foundation in
+   version 2.2 of Bison.  */
+
 /* Tokens.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
@@ -80,12 +90,12 @@
 
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 typedef union YYSTYPE
-#line 140 "ast_expr2.y"
+#line 147 "ast_expr2.y"
 {
 	struct val *val;
 }
-/* Line 1536 of yacc.c.  */
-#line 89 "ast_expr2.h"
+/* Line 1529 of yacc.c.  */
+#line 99 "ast_expr2.h"
 	YYSTYPE;
 # define yystype YYSTYPE /* obsolescent; will be withdrawn */
 # define YYSTYPE_IS_DECLARED 1
@@ -108,5 +118,3 @@
 #endif
 
 
-
-

Modified: trunk/ast_expr2.y
===================================================================
--- trunk/ast_expr2.y	2006-06-28 01:48:44 UTC (rev 387)
+++ trunk/ast_expr2.y	2006-06-28 01:58:07 UTC (rev 388)
@@ -14,7 +14,9 @@
 
 #include "asterisk.h"
 
+#ifndef STANDALONE
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+#endif
 
 #include <sys/types.h>
 #include <stdio.h>

Modified: trunk/ast_expr2f.c
===================================================================
--- trunk/ast_expr2f.c	2006-06-28 01:48:44 UTC (rev 387)
+++ trunk/ast_expr2f.c	2006-06-28 01:58:07 UTC (rev 388)
@@ -1356,7 +1356,9 @@
 
 #include "asterisk.h"
 
+#ifndef STANDALONE
 ASTERISK_FILE_VERSION(__FILE__, "$Revision$")
+#endif
 
 #include <sys/types.h>
 #include <stdio.h>
@@ -1425,7 +1427,7 @@
 static int curlycount = 0;
 static char *expr2_token_subst(char *mess);
 
-#line 1425 "ast_expr2f.c"
+#line 1427 "ast_expr2f.c"
 
 #define INITIAL 0
 #define var 1
@@ -1648,10 +1650,10 @@
 	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-#line 102 "ast_expr2.fl"
+#line 104 "ast_expr2.fl"
 
 
-#line 1651 "ast_expr2f.c"
+#line 1653 "ast_expr2f.c"
 
     yylval = yylval_param;
 
@@ -1734,122 +1736,122 @@
 
 case 1:
 YY_RULE_SETUP
-#line 104 "ast_expr2.fl"
+#line 106 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_OR;}
 	YY_BREAK
 case 2:
 YY_RULE_SETUP
-#line 105 "ast_expr2.fl"
+#line 107 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_AND;}
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 106 "ast_expr2.fl"
+#line 108 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_EQ;}
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 107 "ast_expr2.fl"
+#line 109 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_OR;}
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
-#line 108 "ast_expr2.fl"
+#line 110 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_AND;}
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
-#line 109 "ast_expr2.fl"
+#line 111 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_EQ;}
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
-#line 110 "ast_expr2.fl"
+#line 112 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_EQTILDE;}
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
-#line 111 "ast_expr2.fl"
+#line 113 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_GT;}
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
-#line 112 "ast_expr2.fl"
+#line 114 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_LT;}
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
-#line 113 "ast_expr2.fl"
+#line 115 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_GE;}
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
-#line 114 "ast_expr2.fl"
+#line 116 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_LE;}
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
-#line 115 "ast_expr2.fl"
+#line 117 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_NE;}
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
-#line 116 "ast_expr2.fl"
+#line 118 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_PLUS;}
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
-#line 117 "ast_expr2.fl"
+#line 119 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_MINUS;}
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
-#line 118 "ast_expr2.fl"
+#line 120 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_MULT;}
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
-#line 119 "ast_expr2.fl"
+#line 121 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_DIV;}
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
-#line 120 "ast_expr2.fl"
+#line 122 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_MOD;}
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
-#line 121 "ast_expr2.fl"
+#line 123 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COND;}
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
-#line 122 "ast_expr2.fl"
+#line 124 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COMPL;}
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
-#line 123 "ast_expr2.fl"
+#line 125 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COLON;}
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
-#line 124 "ast_expr2.fl"
+#line 126 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_COLONCOLON;}
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
-#line 125 "ast_expr2.fl"
+#line 127 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_LP;}
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
-#line 126 "ast_expr2.fl"
+#line 128 "ast_expr2.fl"
 { SET_COLUMNS; SET_STRING; return TOK_RP;}
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
-#line 127 "ast_expr2.fl"
+#line 129 "ast_expr2.fl"
 {
 		/* gather the contents of ${} expressions, with trailing stuff,
 		 * into a single TOKEN.
@@ -1862,24 +1864,24 @@
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
-#line 137 "ast_expr2.fl"
+#line 139 "ast_expr2.fl"
 {}
 	YY_BREAK
 case 26:
 /* rule 26 can match eol */
 YY_RULE_SETUP
-#line 138 "ast_expr2.fl"
+#line 140 "ast_expr2.fl"
 {SET_COLUMNS; SET_STRING; return TOKEN;}
 	YY_BREAK
 case 27:
 /* rule 27 can match eol */
 YY_RULE_SETUP
-#line 140 "ast_expr2.fl"
+#line 142 "ast_expr2.fl"
 {/* what to do with eol */}
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
-#line 141 "ast_expr2.fl"
+#line 143 "ast_expr2.fl"
 {
 		SET_COLUMNS;
 		/* the original behavior of the expression parser was
@@ -1891,7 +1893,7 @@
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
-#line 150 "ast_expr2.fl"
+#line 152 "ast_expr2.fl"
 {
 		SET_COLUMNS;
 		SET_STRING;
@@ -1901,7 +1903,7 @@
 case 30:
 /* rule 30 can match eol */
 YY_RULE_SETUP
-#line 157 "ast_expr2.fl"
+#line 159 "ast_expr2.fl"
 {
 		curlycount--;
 		if (curlycount < 0) {
@@ -1915,7 +1917,7 @@
 case 31:
 /* rule 31 can match eol */
 YY_RULE_SETUP
-#line 167 "ast_expr2.fl"
+#line 169 "ast_expr2.fl"
 {
 		curlycount++;
 		yymore();
@@ -1923,7 +1925,7 @@
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
-#line 173 "ast_expr2.fl"
+#line 175 "ast_expr2.fl"
 {
 		BEGIN(0);
 		SET_COLUMNS;
@@ -1934,7 +1936,7 @@
 case 33:
 /* rule 33 can match eol */
 YY_RULE_SETUP
-#line 180 "ast_expr2.fl"
+#line 182 "ast_expr2.fl"
 {
 		char c = yytext[yyleng-1];
 		BEGIN(0);
@@ -1946,7 +1948,7 @@
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
-#line 189 "ast_expr2.fl"
+#line 191 "ast_expr2.fl"
 {
 		curlycount = 0;
 		BEGIN(var);
@@ -1954,7 +1956,7 @@
 	}
 	YY_BREAK
 case YY_STATE_EOF(trail):
-#line 195 "ast_expr2.fl"
+#line 197 "ast_expr2.fl"
 {
 		BEGIN(0);
 		SET_COLUMNS;
@@ -1965,10 +1967,10 @@
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
-#line 203 "ast_expr2.fl"
+#line 205 "ast_expr2.fl"
 ECHO;
 	YY_BREAK
-#line 1968 "ast_expr2f.c"
+#line 1970 "ast_expr2f.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(var):
 	yyterminate();
@@ -2201,7 +2203,7 @@
 
 		/* Read in more data. */
 		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			yyg->yy_n_chars, num_to_read );
+			yyg->yy_n_chars, (size_t) num_to_read );
 
 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = yyg->yy_n_chars;
 		}
@@ -3095,7 +3097,7 @@
 
 #define YYTABLES_NAME "yytables"
 
-#line 203 "ast_expr2.fl"
+#line 205 "ast_expr2.fl"
 
 
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 03:59:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 03:59:38 +0200
Subject: [solid-pbx-svn] r389 - trunk/build_tools
Message-ID: <200606280159.k5S1xclA019760@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 03:59:17 +0200 (Wed, 28 Jun 2006)
New Revision: 389

Modified:
   trunk/build_tools/menuselect.c
Log:
Update to Asterisk SVN trunk r35013

------------------------------------------------------------------------
r35006 | russell | 2006-06-20 06:04:57 +0200 (Tue, 20 Jun 2006) | 1 line

ensure menuselect fails if the deps file isn't found
------------------------------------------------------------------------


Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-06-28 01:58:07 UTC (rev 388)
+++ trunk/build_tools/menuselect.c	2006-06-28 01:59:17 UTC (rev 389)
@@ -694,7 +694,8 @@
 		exit(res);
 	
 	/* Process module dependencies */
-	res = process_deps();
+	if ((res = process_deps()))
+		exit(res);
 	
 	/* The --check-deps option is used to ask this application to check to
 	 * see if that an existing menuselect.makeopts file contails all of the



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:01:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:01:45 +0200
Subject: [solid-pbx-svn] r390 - trunk/channels
Message-ID: <200606280201.k5S21jke020032@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:01:08 +0200 (Wed, 28 Jun 2006)
New Revision: 390

Modified:
   trunk/channels/chan_skinny.c
Log:
Update to Asterisk SVN trunk r35033

------------------------------------------------------------------------
r35032 | north | 2006-06-20 10:09:30 +0200 (Tue, 20 Jun 2006) | 4 lines

fix an issue with dtmf not being sent sometimes

slightly modify handling of digits

------------------------------------------------------------------------


Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-28 01:59:17 UTC (rev 389)
+++ trunk/channels/chan_skinny.c	2006-06-28 02:01:08 UTC (rev 390)
@@ -2258,7 +2258,12 @@
 	if (ast->_state != AST_STATE_UP) {
 		ast_setstate(ast, AST_STATE_UP);
 	}
+
 	transmit_tone(s, SKINNY_SILENCE);
+	/* order matters here...
+	   for some reason, transmit_callinfo must be before transmit_callstate,
+	   or you won't get keypad messages in some situations. */
+	transmit_callinfo(s, ast->cid.cid_name, ast->cid.cid_num, ast->exten, ast->exten, l->instance, sub->callid, 2);
 	transmit_callstate(s, l->instance, SKINNY_CONNECTED, sub->callid);
 	transmit_displaypromptstatus(s, "Connected", 0, l->instance, sub->callid);
 	return res;
@@ -2606,8 +2611,9 @@
 {
 	struct skinny_subchannel *sub = NULL;
 	struct skinny_line *l;
+	struct skinny_device *d = s->device;
 	struct ast_frame f = { 0, };
-	char d;
+	char dgt;
 	int digit;
 	int lineInstance;
 	int callReference;
@@ -2617,11 +2623,11 @@
 	callReference = letohl(req->data.keypad.callReference);
 	f.frametype = AST_FRAME_DTMF;
 	if (digit == 14) {
-		d = '*';
+		dgt = '*';
 	} else if (digit == 15) {
-		d = '#';
+		dgt = '#';
 	} else if (digit >=0 && digit <= 9) {
-		d = '0' + digit;
+		dgt = '0' + digit;
 	} else {
 		/* digit=10-13 (A,B,C,D ?), or
 		 * digit is bad value
@@ -2630,14 +2636,16 @@
 		 * value for backward compatibility, and log
 		 * a warning.
 		 */
-		d = '0' + digit;
+		dgt = '0' + digit;
 		ast_log(LOG_WARNING, "Unsupported digit %d\n", digit);
 	}
-	f.subclass = d;
+	f.subclass = dgt;
 	f.src = "skinny";
 
 	if (lineInstance && callReference)
-		sub = find_subchannel_by_instance_reference(s->device, lineInstance, callReference);
+		sub = find_subchannel_by_instance_reference(d, lineInstance, callReference);
+	else
+		sub = find_subchannel_by_instance_reference(d, d->lastlineinstance, d->lastcallreference);
 
 	if (!sub)
 		return 0;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:02:57 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:02:57 +0200
Subject: [solid-pbx-svn] r391 - trunk/channels
Message-ID: <200606280202.k5S22vN6020224@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:02:42 +0200 (Wed, 28 Jun 2006)
New Revision: 391

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r35063

------------------------------------------------------------------------
r35059 | oej | 2006-06-20 12:34:53 +0200 (Tue, 20 Jun 2006) | 7 lines

Issue #6820 - SIP channels hang in semi active state
- Block fix from 1.2
- Implement part of that fix that was not already implemented, but in a different way

basically, don't cancel destruction when we receive re-transmits.


------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:01:08 UTC (rev 390)
+++ trunk/channels/chan_sip.c	2006-06-28 02:02:42 UTC (rev 391)
@@ -4919,16 +4919,16 @@
 	/* Manager Hold and Unhold events must be generated, if necessary */
 	/* XXX Support for sendonly/recvonly needs to be fixed !!! */
 	if (sin.sin_addr.s_addr && !sendonly) {
-		append_history(p, "Unhold", "%s", req->data);
+		if (ast_test_flag(&p->flags[0], SIP_CALL_ONHOLD)) {
+			append_history(p, "Unhold", "%s", req->data);
+			if (global_callevents)
+				manager_event(EVENT_FLAG_CALL, "Unhold",
+					"Channel: %s\r\n"
+					"Uniqueid: %s\r\n",
+					p->owner->name, 
+					p->owner->uniqueid);
 
-		if (global_callevents && ast_test_flag(&p->flags[0], SIP_CALL_ONHOLD)) {
-			manager_event(EVENT_FLAG_CALL, "Unhold",
-				"Channel: %s\r\n"
-				"Uniqueid: %s\r\n",
-				p->owner->name, 
-				p->owner->uniqueid);
-
-		}
+		} 
 		ast_clear_flag(&p->flags[0], SIP_CALL_ONHOLD);
 	} else {
 		/* No address for RTP, we're on hold */
@@ -11824,7 +11824,8 @@
 					ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
 			} else if ((resp >= 100) && (resp < 200)) {
 				if (sipmethod == SIP_INVITE) {
-					sip_cancel_destroy(p);
+					if (!ast_test_flag(req, SIP_PKT_IGNORE))
+						sip_cancel_destroy(p);
 					if (find_sdp(req))
 						process_sdp(p, req);
 					if (p->owner) {
@@ -11861,7 +11862,7 @@
 				/* They got the notify, this is the end */
 				if (p->owner) {
 					ast_log(LOG_WARNING, "Notify answer on an owned channel?\n");
-					//ast_queue_hangup(p->owner);
+					/* ast_queue_hangup(p->owner); Disabled */
 				} else {
 					if (!p->subscribed && !p->refer)
 						ast_set_flag(&p->flags[0], SIP_NEEDDESTROY);	
@@ -11919,7 +11920,7 @@
 		default:	/* Errors without handlers */
 			if ((resp >= 100) && (resp < 200)) {
 				if (sipmethod == SIP_INVITE) { 	/* re-invite */
-					if (!ignore)
+					if (!ast_test_flag(req, SIP_PKT_IGNORE))
 						sip_cancel_destroy(p);
 				}
 			}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:03:56 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:03:56 +0200
Subject: [solid-pbx-svn] r392 - trunk/channels
Message-ID: <200606280203.k5S23uCi020451@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:03:52 +0200 (Wed, 28 Jun 2006)
New Revision: 392

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r35103

------------------------------------------------------------------------
r35094 | oej | 2006-06-20 15:28:33 +0200 (Tue, 20 Jun 2006) | 2 lines

parse SDP properly even when we are debugging. (Thanks fenlander!)

------------------------------------------------------------------------
r35095 | oej | 2006-06-20 15:31:42 +0200 (Tue, 20 Jun 2006) | 2 lines

Don't count unknown media streams as media streams in the offer... (Fenlander reported this on irc)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:02:42 UTC (rev 391)
+++ trunk/channels/chan_sip.c	2006-06-28 02:03:52 UTC (rev 392)
@@ -4510,7 +4510,6 @@
 	while ((m = get_sdp_iterate(&iterator, req, "m"))[0] != '\0') {
 		int x;
 		int audio = FALSE;
-		numberofmediastreams++;
 
 		if (p->vrtp)
 			ast_rtp_pt_clear(newvideortp);  /* Must be cleared in case no m=video line exists */
@@ -4518,6 +4517,7 @@
 		if ((sscanf(m, "audio %d/%d RTP/AVP %n", &x, &numberofports, &len) == 2) ||
 		    (sscanf(m, "audio %d RTP/AVP %n", &x, &len) == 1)) {
 			audio = TRUE;
+			numberofmediastreams++;
 			/* Found audio stream in this media definition */
 			portno = x;
 			/* Scan through the RTP payload types specified in a "m=" line: */
@@ -4535,6 +4535,7 @@
 		    (sscanf(m, "video %d RTP/AVP %n", &x, &len) == 1)) {
 			/* If it is not audio - is it video ? */
 			ast_clear_flag(&p->flags[0], SIP_NOVIDEO);	
+			numberofmediastreams++;
 			vportno = x;
 			/* Scan through the RTP payload types specified in a "m=" line: */
 			for (codecs = m + len; !ast_strlen_zero(codecs); codecs = ast_skip_blanks(codecs + len)) {
@@ -4550,6 +4551,7 @@
 			if (debug)
 				ast_verbose("Got T.38 offer in SDP in dialog %s\n", p->callid);
 			udptlportno = x;
+			numberofmediastreams++;
 			
 			if (p->owner && p->lastinvite) {
 				p->t38.state = T38_PEER_REINVITE; /* T38 Offered in re-invite from remote party */
@@ -4588,7 +4590,7 @@
 		return -2;
 
 	if (numberofmediastreams > 2)
-		/* We have too many media streams, fail this offer */
+		/* We have too many fax, audio and/or video media streams, fail this offer */
 		return -3;
 
 	/* RTP addresses and ports for audio and video */
@@ -4635,23 +4637,19 @@
 	iterator = req->sdp_start;
 	while ((a = get_sdp_iterate(&iterator, req, "a"))[0] != '\0') {
 		char* mimeSubtype = ast_strdupa(a); /* ensures we have enough space */
-		if (!strcasecmp(a, "sendonly")) {
-			sendonly = 1;
-			continue;
-		}  else if (!strcasecmp(a, "sendrecv")) {
-			sendonly = 0;
-			continue;
-		} else if (option_debug) {
+		if (option_debug > 1) {
+			int breakout = FALSE;
+		
 			/* If we're debugging, check for unsupported sdp options */
 			if (!strcasecmp(a, "inactive")) {
 				/* Inactive media streams: Not supported */
 				if (debug)
 					ast_verbose("Got unsupported a:inactive in SDP offer \n");
-				continue;
+				breakout = TRUE;
 			} else if (!strncasecmp(a, "rtcp:", (size_t) 5)) {
 				if (debug)
 					ast_verbose("Got unsupported a:rtcp in SDP offer \n");
-				continue;
+				breakout = TRUE;
 			} else if (!strncasecmp(a, "fmtp:", (size_t) 5)) {
 				/* Format parameters:  Not supported */
 				/* Note: This is used for codec parameters, like bitrate for
@@ -4659,27 +4657,36 @@
 					See RFC2327 for an example */
 				if (debug)
 					ast_verbose("Got unsupported a:fmtp in SDP offer \n");
-				continue;
+				breakout = TRUE;
 			} else if (!strncasecmp(a, "framerate:", (size_t) 10)) {
 				/* Video stuff:  Not supported */
 				if (debug)
 					ast_verbose("Got unsupported a:framerate in SDP offer \n");
-				continue;
+				breakout = TRUE;
 			} else if (!strncasecmp(a, "maxprate:", (size_t) 9)) {
 				/* Video stuff:  Not supported */
 				if (debug)
 					ast_verbose("Got unsupported a:maxprate in SDP offer \n");
-				continue;
+				breakout = TRUE;
 			} else if (!strncasecmp(a, "crypto:", (size_t) 7)) {
 				/* SRTP stuff, not yet supported */
 				if (debug)
 					ast_verbose("Got unsupported a:crypto in SDP offer \n");
-				continue;
+				breakout = TRUE;
 			} else if (!strncasecmp(a, "ptime:", (size_t) 6)) {
 				if (debug)
 					ast_verbose("Got unsupported a:ptime in SDP offer \n");
+				breakout = TRUE;
+			}
+			if (breakout)	/* We have a match, skip to next header */
 				continue;
-			}
+		}
+		if (!strcasecmp(a, "sendonly")) {
+			sendonly = 1;
+			continue;
+		}  else if (!strcasecmp(a, "sendrecv")) {
+			sendonly = 0;
+			continue;
 		} else if (sscanf(a, "rtpmap: %u %[^/]/", &codec, mimeSubtype) != 2) 
 			continue;
 		/* We have a rtpmap to handle */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:04:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:04:31 +0200
Subject: [solid-pbx-svn] r393 - in trunk: . stdtime
Message-ID: <200606280204.k5S24VZY020527@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:04:24 +0200 (Wed, 28 Jun 2006)
New Revision: 393

Modified:
   trunk/Makefile
   trunk/stdtime/private.h
Log:
Update to Asterisk SVN trunk r35123

------------------------------------------------------------------------
r35122 | tilghman | 2006-06-20 17:06:38 +0200 (Tue, 20 Jun 2006) | 10 lines

Merged revisions 35121 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r35121 | tilghman | 2006-06-20 10:05:23 -0500 (Tue, 20 Jun 2006) | 2 lines

Bug 7398 - Solaris puts its zoneinfo files in a nonstandard place

.......

------------------------------------------------------------------------
r35123 | russell | 2006-06-20 17:08:44 +0200 (Tue, 20 Jun 2006) | 2 lines

$(INSTALL) is determined by configure and set in the makeopts file

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:03:52 UTC (rev 392)
+++ trunk/Makefile	2006-06-28 02:04:24 UTC (rev 393)
@@ -359,8 +359,6 @@
   HAVEDOT=no
 endif
 
-INSTALL=install
-
 _all: all
 	@echo " +--------- Asterisk Build Complete ---------+"  
 	@echo " + Asterisk has successfully been built, but +"  

Modified: trunk/stdtime/private.h
===================================================================
--- trunk/stdtime/private.h	2006-06-28 02:03:52 UTC (rev 392)
+++ trunk/stdtime/private.h	2006-06-28 02:04:24 UTC (rev 393)
@@ -20,7 +20,11 @@
 #define HAVE_STRERROR	1
 #define	HAVE_UNISTD_H	1
 #define	LOCALE_HOME	_PATH_LOCALE
+#ifdef SOLARIS
+#define TZDIR		"/usr/share/lib/zoneinfo"
+#else
 #define TZDIR		"/usr/share/zoneinfo"
+#endif /* def SOLARIS */
 #endif /* ndef TM_GMTOFF */
 
 /*



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:05:31 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:05:31 +0200
Subject: [solid-pbx-svn] r394 - trunk/channels
Message-ID: <200606280205.k5S25VMH020576@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:04:57 +0200 (Wed, 28 Jun 2006)
New Revision: 394

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r35133

------------------------------------------------------------------------
r35125 | oej | 2006-06-20 17:46:49 +0200 (Tue, 20 Jun 2006) | 2 lines

use correct test for checking if sip domains are enabled or not

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:04:24 UTC (rev 393)
+++ trunk/channels/chan_sip.c	2006-06-28 02:04:57 UTC (rev 394)
@@ -13241,7 +13241,7 @@
 		p->refer->localtransfer = 1;
 		if (sipdebug && option_debug > 2)
 			ast_log(LOG_DEBUG, "This SIP transfer is local : %s\n", p->refer->refer_to_domain);
-	} else if (!allow_external_domains) {
+	} else if (AST_LIST_EMPTY(&domain_list)) {
 		/* This PBX don't bother with SIP domains, so all transfers are local */
 		p->refer->localtransfer = 1;
 	} else



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:06:16 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:06:16 +0200
Subject: [solid-pbx-svn] r395 - trunk/channels
Message-ID: <200606280206.k5S26GTh020793@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:06:10 +0200 (Wed, 28 Jun 2006)
New Revision: 395

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r35163

------------------------------------------------------------------------
r35159 | oej | 2006-06-20 23:09:50 +0200 (Tue, 20 Jun 2006) | 2 lines

Hunting crash when parking calls with SIP REFER

------------------------------------------------------------------------
r35160 | oej | 2006-06-20 23:12:58 +0200 (Tue, 20 Jun 2006) | 2 lines

How many times can we free allocated memory? Many, obviously... ;-)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:04:57 UTC (rev 394)
+++ trunk/channels/chan_sip.c	2006-06-28 02:06:10 UTC (rev 395)
@@ -11970,6 +11970,10 @@
 	transferer = d->chan2;
 	copy_request(&req, &d->req);
 	free(d);
+
+	if (option_debug > 3) 
+		ast_log(LOG_DEBUG, "SIP Park: Transferer channel %s, Transferee %s\n", transferer->name, transferee->name);
+
 	ast_channel_lock(transferee);
 	if (ast_do_masquerade(transferee)) {
 		ast_log(LOG_WARNING, "Masquerade failed.\n");
@@ -11980,6 +11984,7 @@
 	ast_channel_unlock(transferee);
 
 	res = ast_park_call(transferee, transferer, 0, &ext);
+	
 
 #ifdef WHEN_WE_KNOW_THAT_THE_CLIENT_SUPPORTS_MESSAGE
 	if (!res) {
@@ -11992,9 +11997,11 @@
 #endif
 
 	/* Any way back to the current call??? */
+	/* Transmit response to the REFER request */
 	transmit_response(transferer->tech_pvt, "202 Accepted", &req);
 	if (!res)	{
 		/* Transfer succeeded */
+		append_history(transferer->tech_pvt, "SIPpark","Parked call on %d", ext);
 		transmit_notify_with_sipfrag(transferer->tech_pvt, d->seqno, "200 OK", TRUE);
 		transferer->hangupcause = AST_CAUSE_NORMAL_CLEARING;
 		ast_hangup(transferer); /* This will cause a BYE */
@@ -12002,6 +12009,7 @@
 			ast_log(LOG_DEBUG, "SIP Call parked on extension '%d'\n", ext);
 	} else {
 		transmit_notify_with_sipfrag(transferer->tech_pvt, d->seqno, "503 Service Unavailable", TRUE);
+		append_history(transferer->tech_pvt, "SIPpark","Parking failed\n");
 		if (option_debug)
 			ast_log(LOG_DEBUG, "SIP Call parked failed \n");
 		/* Do not hangup call */
@@ -12009,7 +12017,9 @@
 	return NULL;
 }
 
-/*! \brief Park a call */
+/*! \brief Park a call using the subsystem in res_features.c 
+	This is executed in a separate thread
+*/
 static int sip_park(struct ast_channel *chan1, struct ast_channel *chan2, struct sip_request *req, int seqno)
 {
 	struct sip_dual *d;
@@ -12035,6 +12045,8 @@
 	/* Make formats okay */
 	transferee->readformat = chan1->readformat;
 	transferee->writeformat = chan1->writeformat;
+
+	/* Prepare for taking over the channel */
 	ast_channel_masquerade(transferee, chan1);
 
 	/* Setup the extensions and such */
@@ -12049,6 +12061,8 @@
 	/* Make formats okay */
 	transferer->readformat = chan2->readformat;
 	transferer->writeformat = chan2->writeformat;
+
+	/* Prepare for taking over the channel */
 	ast_channel_masquerade(transferer, chan2);
 
 	/* Setup the extensions and such */
@@ -12065,6 +12079,13 @@
 		return -1;
 	}
 	ast_channel_unlock(transferer);
+	if (!transferer || !transferee) {
+		if (!transferer)
+			ast_log(LOG_DEBUG, "No transferer channel, giving up parking\n");
+		if (!transferee)
+			ast_log(LOG_DEBUG, "No transferee channel, giving up parking\n");
+		return -1;
+	}
 	if ((d = ast_calloc(1, sizeof(*d)))) {
 		/* Save original request for followup */
 		copy_request(&d->req, req);
@@ -12072,10 +12093,10 @@
 		d->chan2 = transferer;	/* Transferer */
 		d->seqno = seqno;
 		if (!ast_pthread_create(&th, NULL, sip_park_thread, d)) {
-			free(d);
+			free(d);	/* We don't need it anymore. If thread is created, d will be free'd
+					   by sip_park_thread() */
 			return 0;
 		}
-		free(d);
 	} 
 	return -1;
 }



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:07:49 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:07:49 +0200
Subject: [solid-pbx-svn] r396 - in trunk: apps formats
Message-ID: <200606280207.k5S27nZk021132@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:06:59 +0200 (Wed, 28 Jun 2006)
New Revision: 396

Modified:
   trunk/apps/app_amd.c
   trunk/formats/format_wav_gsm.c
Log:
Update to Asterisk SVN trunk r35193

------------------------------------------------------------------------
r35184 | tilghman | 2006-06-21 00:22:47 +0200 (Wed, 21 Jun 2006) | 3 lines

Bug 7372:  Wrong size for the block alignment (should have been 4 bytes;
writing 4 from a 2-byte integer caused extra (wrong) bytes set in the header)

------------------------------------------------------------------------
r35185 | tilghman | 2006-06-21 00:26:16 +0200 (Wed, 21 Jun 2006) | 2 lines

Bug 7399 - Sample config showed [general] as the context, so the app should look there, too.

------------------------------------------------------------------------


Modified: trunk/apps/app_amd.c
===================================================================
--- trunk/apps/app_amd.c	2006-06-28 02:06:10 UTC (rev 395)
+++ trunk/apps/app_amd.c	2006-06-28 02:06:59 UTC (rev 396)
@@ -346,7 +346,7 @@
 	cat = ast_category_browse(cfg, NULL);
 
 	while (cat) {
-		if (!strcasecmp(cat, "amd") ) {
+		if (!strcasecmp(cat, "general") ) {
 			var = ast_variable_browse(cfg, cat);
 			while (var) {
 				if (!strcasecmp(var->name, "initial_silence")) {

Modified: trunk/formats/format_wav_gsm.c
===================================================================
--- trunk/formats/format_wav_gsm.c	2006-06-28 02:06:10 UTC (rev 395)
+++ trunk/formats/format_wav_gsm.c	2006-06-28 02:06:59 UTC (rev 396)
@@ -281,7 +281,7 @@
 	/* Mono = 1 channel */
 	unsigned short chans = htols(1);
 	/* Each block of data is exactly 65 bytes in size. */
-	unsigned short block_align = htols(MSGSM_FRAME_SIZE);
+	unsigned int block_align = htoll(MSGSM_FRAME_SIZE);
 	/* Not actually 2, but rounded up to the nearest bit */
 	unsigned short bits_per_sample = htols(2);
 	/* Needed for compressed formats */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:09:22 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:09:22 +0200
Subject: [solid-pbx-svn] r397 - in trunk: channels res
Message-ID: <200606280209.k5S29MQc021488@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:08:36 +0200 (Wed, 28 Jun 2006)
New Revision: 397

Modified:
   trunk/channels/chan_sip.c
   trunk/res/res_features.c
Log:
Update to Asterisk SVN trunk r35213

------------------------------------------------------------------------
r35209 | oej | 2006-06-21 09:13:20 +0200 (Wed, 21 Jun 2006) | 2 lines

Finally fix parking and go back to metermaids

------------------------------------------------------------------------
r35210 | oej | 2006-06-21 09:49:29 +0200 (Wed, 21 Jun 2006) | 3 lines

- Doxygen and some formatting fixes in res_features
- Get rid of compiler warnings in chan_sip

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:06:59 UTC (rev 396)
+++ trunk/channels/chan_sip.c	2006-06-28 02:08:36 UTC (rev 397)
@@ -11971,6 +11971,10 @@
 	copy_request(&req, &d->req);
 	free(d);
 
+	if (!transferee || !transferer) {
+		ast_log(LOG_ERROR, "Missing channels for parking! Transferer %s Transferee %s\n", transferer ? "<available>" : "<missing>", transferee ? "<available>" : "<missing>" );
+		return NULL;
+	}
 	if (option_debug > 3) 
 		ast_log(LOG_DEBUG, "SIP Park: Transferer channel %s, Transferee %s\n", transferer->name, transferee->name);
 
@@ -12092,7 +12096,8 @@
 		d->chan1 = transferee;	/* Transferee */
 		d->chan2 = transferer;	/* Transferer */
 		d->seqno = seqno;
-		if (!ast_pthread_create(&th, NULL, sip_park_thread, d)) {
+		if (ast_pthread_create(&th, NULL, sip_park_thread, d) < 0) {
+			/* Could not start thread */
 			free(d);	/* We don't need it anymore. If thread is created, d will be free'd
 					   by sip_park_thread() */
 			return 0;

Modified: trunk/res/res_features.c
===================================================================
--- trunk/res/res_features.c	2006-06-28 02:06:59 UTC (rev 396)
+++ trunk/res/res_features.c	2006-06-28 02:08:36 UTC (rev 397)
@@ -80,18 +80,18 @@
 
 static char *parkedcall = "ParkedCall";
 
-static int parkingtime = DEFAULT_PARK_TIME; 		/*!< No more than 45 seconds parked before you do something with them */
-static char parking_con[AST_MAX_EXTENSION];		/*!< Context for which parking is made accessible */
-static char parking_con_dial[AST_MAX_EXTENSION];	/*!< Context for dialback for parking (KLUDGE) */
-static char parking_ext[AST_MAX_EXTENSION];		/*!< Extension you type to park the call */
-static char pickup_ext[AST_MAX_EXTENSION];		/*!< Call pickup extension */
-static int parking_start;				/*!< First available extension for parking */
-static int parking_stop;				/*!< Last available extension for parking */
+static int parkingtime = DEFAULT_PARK_TIME;                /*!< No more than 45 seconds parked before you do something with them */
+static char parking_con[AST_MAX_EXTENSION];                /*!< Context for which parking is made accessible */
+static char parking_con_dial[AST_MAX_EXTENSION];           /*!< Context for dialback for parking (KLUDGE) */
+static char parking_ext[AST_MAX_EXTENSION];                /*!< Extension you type to park the call */
+static char pickup_ext[AST_MAX_EXTENSION];                 /*!< Call pickup extension */
+static int parking_start;                                  /*!< First available extension for parking */
+static int parking_stop;                                   /*!< Last available extension for parking */
 
-static char courtesytone[256];				/*!< Courtesy tone */
-static int parkedplay = 0;				/*!< Who to play the courtesy tone to */
-static char xfersound[256];				/*!< Call transfer sound */
-static char xferfailsound[256];				/*!< Call transfer failure sound */
+static char courtesytone[256];                             /*!< Courtesy tone */
+static int parkedplay = 0;                                 /*!< Who to play the courtesy tone to */
+static char xfersound[256];                                /*!< Call transfer sound */
+static char xferfailsound[256];                            /*!< Call transfer failure sound */
 
 static int parking_offset;
 static int parkfindnext;
@@ -103,7 +103,7 @@
 
 static int atxfernoanswertimeout;
 
-static char *registrar = "res_features";		/*!< Registrar for operations */
+static char *registrar = "res_features";		   /*!< Registrar for operations */
 
 /* module and CLI command definitions */
 static char *synopsis = "Answer a parked call";
@@ -129,14 +129,13 @@
 static int monitor_ok = 1;
 
 struct parkeduser {
-	struct ast_channel *chan;
-	struct timeval start;
-	int parkingnum;
-	/* Where to go if our parking time expires */
-	char context[AST_MAX_CONTEXT];
+	struct ast_channel *chan;                   /*!< Parking channel */
+	struct timeval start;                       /*!< Time the parking started */
+	int parkingnum;                             /*!< Parking lot */
+	char context[AST_MAX_CONTEXT];              /*!< Where to go if our parking time expires */
 	char exten[AST_MAX_EXTENSION];
 	int priority;
-	int parkingtime;
+	int parkingtime;                            /*!< Maximum length in parking lot before return */
 	int notquiteyet;
 	char peername[1024];
 	unsigned char moh_trys;
@@ -269,7 +268,7 @@
 }
 
 /*! \brief Park a call 
- 	We put the user in the parking list, then wake up the parking thread to be sure it looks
+ 	\note We put the user in the parking list, then wake up the parking thread to be sure it looks
 	after these channels too */
 int ast_park_call(struct ast_channel *chan, struct ast_channel *peer, int timeout, int *extout)
 {
@@ -278,9 +277,9 @@
 	char exten[AST_MAX_EXTENSION];
 	struct ast_context *con;
 	
-	if (!(pu = ast_calloc(1, sizeof(*pu)))) {
+	if (!(pu = ast_calloc(1, sizeof(*pu)))) 
 		return -1;
-	}
+
 	ast_mutex_lock(&parking_lock);
 	parking_range = parking_stop - parking_start+1;
 	for (i = 0; i < parking_range; i++) {
@@ -309,7 +308,7 @@
 	pu->chan = chan;
 	/* Start music on hold */
 	if (chan != peer) {
-		ast_indicate(pu->chan, AST_CONTROL_HOLD);
+		ast_indicate(pu->chan, AST_CONTROL_HOLD);	/* Indicate to peer that we're on hold */
 		ast_moh_start(pu->chan, NULL);
 	}
 	pu->start = ast_tvnow();
@@ -349,22 +348,21 @@
 		S_OR(pu->chan->cid.cid_name, "<unknown>")
 		);
 
-	if (peer) {
-		if (adsipark && adsi_available(peer))
-			adsi_announce_park(peer, pu->parkingnum);
-		if (adsipark && adsi_available(peer))
-			adsi_unload_session(peer);
+	if (peer && adsipark && adsi_available(peer)) {
+		adsi_announce_park(peer, pu->parkingnum);
+		adsi_unload_session(peer);
 	}
+
 	con = ast_context_find(parking_con);
-	if (!con) {
+	if (!con) 
 		con = ast_context_create(NULL, parking_con, registrar);
-		if (!con)
-			ast_log(LOG_ERROR, "Parking context '%s' does not exist and unable to create\n", parking_con);
-	}
-	if (con) {
+	if (!con)	/* Still no context? Bad */
+		ast_log(LOG_ERROR, "Parking context '%s' does not exist and unable to create\n", parking_con);
+	else {		/* Add extension to context */
 		snprintf(exten, sizeof(exten), "%d", x);
 		ast_add_extension2(con, 1, exten, 1, NULL, NULL, parkedcall, strdup(exten), FREE, registrar);
 	}
+	/* Tell the peer channel the number of the parking space */
 	if (peer) 
 		ast_say_digits(peer, pu->parkingnum, "", peer->language);
 	if (pu->notquiteyet) {
@@ -382,27 +380,27 @@
 	struct ast_frame *f;
 
 	/* Make a new, fake channel that we'll use to masquerade in the real one */
-	if ((chan = ast_channel_alloc(0))) {
-		/* Let us keep track of the channel name */
-		ast_string_field_build(chan, name, "Parked/%s",rchan->name);
-
-		/* Make formats okay */
-		chan->readformat = rchan->readformat;
-		chan->writeformat = rchan->writeformat;
-		ast_channel_masquerade(chan, rchan);
-
-		/* Setup the extensions and such */
-		set_c_e_p(chan, rchan->context, rchan->exten, rchan->priority);
-
-		/* Make the masq execute */
-		f = ast_read(chan);
-		if (f)
-			ast_frfree(f);
-		ast_park_call(chan, peer, timeout, extout);
-	} else {
+	if (!(chan = ast_channel_alloc(0))) {
 		ast_log(LOG_WARNING, "Unable to create parked channel\n");
 		return -1;
 	}
+	/* Let us keep track of the channel name */
+	ast_string_field_build(chan, name, "Parked/%s",rchan->name);
+
+	/* Make formats okay */
+	chan->readformat = rchan->readformat;
+	chan->writeformat = rchan->writeformat;
+	ast_channel_masquerade(chan, rchan);
+
+	/* Setup the extensions and such */
+	set_c_e_p(chan, rchan->context, rchan->exten, rchan->priority);
+
+	/* Make the masq execute */
+	f = ast_read(chan);
+	if (f)
+		ast_frfree(f);
+
+	ast_park_call(chan, peer, timeout, extout);
 	return 0;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:10:38 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:10:38 +0200
Subject: [solid-pbx-svn] r398 - in trunk/channels: . misdn
Message-ID: <200606280210.k5S2AcBc022079@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:10:06 +0200 (Wed, 28 Jun 2006)
New Revision: 398

Modified:
   trunk/channels/chan_misdn.c
   trunk/channels/misdn/isdn_lib.c
Log:
Update to Asterisk SVN trunk r35243

------------------------------------------------------------------------
r35241 | crichter | 2006-06-21 17:21:46 +0200 (Wed, 21 Jun 2006) | 20 lines

* added support for PID export/import to identify bridging in misdn_call already
* fixed a few inband Alerting issues, sometimes we need to create alerting, some
times it's inband
* beautified the state debugging of misdn_hangup
* removed "real"  bchannel activating/deactivating in chan_misdn.c
* fixed "round_robin" bug when there's only 1 port
* added more informative prints when channel could not be created
* changed some warnings to notices
* reworked the whole bchannel state machine stuff, 
  it is now like in the examples of mISDNuser and therefore a lot easier, 
  and it is now harder to create bugs
* bchannel_activate/deactivate is now only called in setup/cleanup bc, 
  they may merge sometime
* it is very important to setup/cleanup the bchannels under the correct 
  conditions, especially in the NT Side we can only setup the bchannels 
  when we send a Message! 
  In the TE side we can only setup the bchannel when we received the channel 
  of course
	      

------------------------------------------------------------------------


Modified: trunk/channels/chan_misdn.c
===================================================================
--- trunk/channels/chan_misdn.c	2006-06-28 02:08:36 UTC (rev 397)
+++ trunk/channels/chan_misdn.c	2006-06-28 02:10:06 UTC (rev 398)
@@ -126,6 +126,7 @@
 	MISDN_CONNECTED, /*!<  when connected */
 	MISDN_PRECONNECTED, /*!<  when connected */
 	MISDN_DISCONNECTED, /*!<  when connected */
+	MISDN_RELEASED, /*!<  when connected */
 	MISDN_BRIDGED, /*!<  when bridged */
 	MISDN_CLEANING, /*!< when hangup from * but we were connected before */
 	MISDN_HUNGUP_FROM_MISDN, /*!< when DISCONNECT/RELEASE/REL_COMP  cam from misdn */
@@ -644,6 +645,8 @@
 	{MISDN_ALERTING,"ALERTING"}, /*  when Alerting */
 	{MISDN_BUSY,"BUSY"}, /*  when BUSY */
 	{MISDN_CONNECTED,"CONNECTED"}, /*  when connected */
+	{MISDN_DISCONNECTED,"DISCONNECTED"}, /*  when connected */
+	{MISDN_RELEASED,"RELEASED"}, /*  when connected */
 	{MISDN_BRIDGED,"BRIDGED"}, /*  when bridged */
 	{MISDN_CLEANING,"CLEANING"}, /* when hangup from * but we were connected before */
 	{MISDN_HUNGUP_FROM_MISDN,"HUNGUP_FROM_MISDN"}, /* when DISCONNECT/RELEASE/REL_COMP  cam from misdn */
@@ -1853,14 +1856,29 @@
 				chan_misdn_log(1, p->bc->port, " --> * IND :\tringing pid:%d\n",p->bc?p->bc->pid:-1);
 				misdn_lib_send_event( p->bc, EVENT_ALERTING);
 			
-				if (p->other_ch && p->other_ch->bc && misdn_inband_avail(p->other_ch->bc)) {
-					chan_misdn_log(1,p->bc->port, " --> other End is mISDN and has inband info available\n");
-					break;
+				if (p->other_ch && p->other_ch->bc) {
+					if (misdn_inband_avail(p->other_ch->bc)) {
+						chan_misdn_log(1,p->bc->port, " --> other End is mISDN and has inband info available\n");
+						break;
+					}
+
+					if (!p->other_ch->bc->nt) {
+						chan_misdn_log(1,p->bc->port, " --> other End is mISDN TE so it has inband info for sure (?)\n");
+						break;
+					}
+#if 0
+					if (p->other_ch->bc->nt) {
+						chan_misdn_log(1,p->bc->port, " --> other End is mISDN NT .. \n");
+						break;
+					}
+#endif
+
 				}
+
 			
 				if ( !p->bc->nt && (p->orginator==ORG_MISDN) && !p->incoming_early_audio ) 
 					chan_misdn_log(1,p->bc->port, " --> incoming_early_audio off\n");
-				 else 
+				else 
 					 tone_indicate(p, TONE_ALERTING);
 				chan_misdn_log(1, p->bc->port, " --> * SEND: State Ring pid:%d\n",p->bc?p->bc->pid:-1);
 				ast_setstate(ast,AST_STATE_RINGING);
@@ -1919,7 +1937,7 @@
 		chan_misdn_log(1, p->bc->port, " --> *\tUNHOLD pid:%d\n",p->bc?p->bc->pid:-1);
 		break;
 	default:
-		ast_log(LOG_WARNING, " --> * Unknown Indication:%d pid:%d\n",cond,p->bc?p->bc->pid:-1);
+		ast_log(LOG_NOTICE, " --> * Unknown Indication:%d pid:%d\n",cond,p->bc?p->bc->pid:-1);
 	}
   
 	return 0;
@@ -1991,6 +2009,7 @@
 		chan_misdn_log(2, bc->port, " --> l3id:%x\n",p->l3id);
 		chan_misdn_log(1, bc->port, " --> cause:%d\n",bc->cause);
 		chan_misdn_log(1, bc->port, " --> out_cause:%d\n",bc->out_cause);
+		chan_misdn_log(1, bc->port, " --> state:%s\n", misdn_get_ch_state(p));
 		
 		switch (p->state) {
 		case MISDN_CALLING:
@@ -2013,8 +2032,6 @@
 		case MISDN_ALERTING:
 		case MISDN_PROGRESS:
 		case MISDN_PROCEEDING:
-			chan_misdn_log(2, bc->port, " --> * State Alerting\n");
-
 			if (p->orginator != ORG_AST) 
 				tone_indicate(p, TONE_HANGUP);
       
@@ -2023,7 +2040,6 @@
 			break;
 		case MISDN_CONNECTED:
 			/*  Alerting or Disconect */
-			chan_misdn_log(2, bc->port, " --> * State Connected\n");
 			start_bc_tones(p);
 			tone_indicate(p, TONE_HANGUP);
 			misdn_lib_send_event( bc, EVENT_DISCONNECT);
@@ -2031,17 +2047,16 @@
 			p->state=MISDN_CLEANING; /* MISDN_HUNGUP_FROM_AST; */
 			break;
 		case MISDN_DISCONNECTED:
-			chan_misdn_log(2, bc->port, " --> * State Disconnected\n");
 			misdn_lib_send_event( bc, EVENT_RELEASE);
 			p->state=MISDN_CLEANING; /* MISDN_HUNGUP_FROM_AST; */
 			break;
 
+		case MISDN_RELEASED:
 		case MISDN_CLEANING:
 			break;
       
 		case MISDN_HOLD_DISCONNECT:
 			/* need to send release here */
-			chan_misdn_log(2, bc->port, " --> state HOLD_DISC\n");
 			chan_misdn_log(1, bc->port, " --> cause %d\n",bc->cause);
 			chan_misdn_log(1, bc->port, " --> out_cause %d\n",bc->out_cause);
 			
@@ -2358,7 +2373,7 @@
 	chan_misdn_log(3,cl->bc->port,"Tone Indicate:\n");
 	
 	if (!cl->ast) {
-		chan_misdn_log(-1,cl->bc->port,"Ast Ptr Not existing anymore.. we need to generate tones ourselves now (tbd)\n");
+		chan_misdn_log(3,cl->bc->port,"Ast Ptr Not existing anymore.. we need to generate tones ourselves now (tbd)\n");
 		
 		misdn_lib_send_tone(cl->bc,tone);
 		return 0;
@@ -2407,7 +2422,7 @@
 
 static int start_bc_tones(struct chan_list* cl)
 {
-	manager_bchannel_activate(cl->bc);
+/*	manager_bchannel_activate(cl->bc); */
 	misdn_lib_tone_generator_stop(cl->bc);
 	cl->notxtone=0;
 	cl->norxtone=0;
@@ -2416,9 +2431,10 @@
 
 static int stop_bc_tones(struct chan_list *cl)
 {
-	if (cl->bc) {
+/*	if (cl->bc) {
 		manager_bchannel_deactivate(cl->bc);
 	}
+*/
 	cl->notxtone=1;
 	cl->norxtone=1;
 	
@@ -2514,7 +2530,7 @@
 					if (port >= port_start)
 						next_chan = 1;
 					
-					if (port < port_start && next_chan) {
+					if (port <= port_start && next_chan) {
 						if (++robin_channel >= MAX_BCHANS) {
 							robin_channel = 1;
 						}
@@ -2528,13 +2544,17 @@
 						int check;
 						misdn_cfg_get(port, MISDN_CFG_PMP_L1_CHECK, &check, sizeof(int));
 						port_up = misdn_lib_port_up(port, check);
+
+						if (check && !port_up) 
+							chan_misdn_log(1,port,"L1 is not Up on this Port\n");
 						
+						
 						if ( port_up )	{
 							newbc = misdn_lib_get_free_bc(port, robin_channel);
 							if (newbc) {
 								chan_misdn_log(4, port, " Success! Found port:%d channel:%d\n", newbc->port, newbc->channel);
 								if (port_up)
-									chan_misdn_log(4, port, "ortup:%d\n",  port_up);
+									chan_misdn_log(4, port, "portup:%d\n",  port_up);
 								rr->port = newbc->port;
 								rr->channel = newbc->channel;
 								break;
@@ -2579,8 +2599,7 @@
 	}
 	
 	if (!newbc) {
-		chan_misdn_log(-1, 0, " --> ! No free channel chan ext:%s even after Group Call\n",ext);
-		chan_misdn_log(-1, 0, " --> SEND: State Down\n");
+		chan_misdn_log(-1, 0, "Could not create channel on port:%d with extensions:%s\n",port,ext);
 		return NULL;
 	}
 
@@ -3144,7 +3163,7 @@
 		ch=find_chan_by_l3id(cl_te, bc->l3_id);
 	
 	if (event != EVENT_BCHAN_DATA && event != EVENT_TONE_GENERATE) { /*  Debug Only Non-Bchan */
-		chan_misdn_log(1, bc->port, "I IND :%s oad:%s dad:%s\n", manager_isdn_get_info(event), bc->oad, bc->dad);
+		chan_misdn_log(1, bc->port, "I IND :%s oad:%s dad:%s pid:%d\n", manager_isdn_get_info(event), bc->oad, bc->dad, bc->pid);
 		misdn_lib_log_ies(bc);
 		chan_misdn_log(2,bc->port," --> bc_state:%s\n",bc_state2str(bc->bc_state));
 	}
@@ -3152,7 +3171,7 @@
 	if (event != EVENT_SETUP) {
 		if (!ch) {
 			if (event != EVENT_CLEANUP )
-				ast_log(LOG_WARNING, "Chan not existing at the moment bc->l3id:%x bc:%p event:%s port:%d channel:%d\n",bc->l3_id, bc, manager_isdn_get_info( event), bc->port,bc->channel);
+				ast_log(LOG_NOTICE, "Chan not existing at the moment bc->l3id:%x bc:%p event:%s port:%d channel:%d\n",bc->l3_id, bc, manager_isdn_get_info( event), bc->port,bc->channel);
 			return -1;
 		}
 	}
@@ -3164,12 +3183,13 @@
 		case EVENT_RELEASE_COMPLETE:
 		case EVENT_CLEANUP:
 		case EVENT_TIMEOUT:
-			chan_misdn_log(3,bc->port,"ast_hangup already called, so we have no ast ptr anymore in event(%s)\n",manager_isdn_get_info(event));
+			if (!ch->ast)
+				chan_misdn_log(3,bc->port,"ast_hangup already called, so we have no ast ptr anymore in event(%s)\n",manager_isdn_get_info(event));
 			break;
 		default:
 			if ( !ch->ast  || !MISDN_ASTERISK_PVT(ch->ast) || !MISDN_ASTERISK_TECH_PVT(ch->ast)) {
 				if (event!=EVENT_BCHAN_DATA)
-					ast_log(LOG_WARNING, "No Ast or No private Pointer in Event (%d:%s)\n", event, manager_isdn_get_info(event));
+					ast_log(LOG_NOTICE, "No Ast or No private Pointer in Event (%d:%s)\n", event, manager_isdn_get_info(event));
 				return -1;
 			}
 		}
@@ -3674,7 +3694,7 @@
 			   alternative number, then play it instead of
 			   immediately releasing the call */
 			chan_misdn_log(0,bc->port, " --> Inband Info Avail, not sending RELEASE\n");
-			ch->state = MISDN_DISCONNECTED;
+			ch->state=MISDN_DISCONNECTED;
 			start_bc_tones(ch);
 			break;
 		}
@@ -3699,6 +3719,9 @@
 		*/
 		
 		misdn_lib_send_event(bc,EVENT_RELEASE);
+
+		if (ch->state == MISDN_CONNECTED)
+			ch->state=MISDN_RELEASED;
 	}
 	break;
 	
@@ -3725,7 +3748,10 @@
 			/*stop_bc_tones(ch);
 			  release_chan(bc);*/
 			
+			if (!bc->nt) release_chan(bc);
+			
 			misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
+
 		}
 		break;
 	case EVENT_RELEASE_COMPLETE:
@@ -3755,7 +3781,7 @@
 		generate = ast->generator->generate;
 
 		if (tone_len <0 || tone_len > 512 ) {
-			ast_log(LOG_WARNING, "TONE_GEN: len was %d, set to 128\n",tone_len);
+			ast_log(LOG_NOTICE, "TONE_GEN: len was %d, set to 128\n",tone_len);
 			tone_len=128;
 		}
 
@@ -3950,7 +3976,7 @@
 		break;
 				
 	default:
-		ast_log(LOG_WARNING, "Got Unknown Event\n");
+		ast_log(LOG_NOTICE, "Got Unknown Event\n");
 		break;
 	}
 	

Modified: trunk/channels/misdn/isdn_lib.c
===================================================================
--- trunk/channels/misdn/isdn_lib.c	2006-06-28 02:08:36 UTC (rev 397)
+++ trunk/channels/misdn/isdn_lib.c	2006-06-28 02:10:06 UTC (rev 398)
@@ -363,7 +363,7 @@
 	int i;
 
 	for (i=0; i <stack->b_num; i++) {
-		cb_log(8, stack->port, "Idx:%d stack->cchan:%d Chan:%d\n",i,stack->channels[i], i+1);
+		cb_log(6, stack->port, "Idx:%d stack->cchan:%d Chan:%d\n",i,stack->channels[i], i+1);
 	}
 }
 
@@ -550,14 +550,6 @@
 	bc->te_choose_channel = 0;
 
 	bc->holded_bc=NULL;
-	
-	
-	if (bc->bc_state != BCHAN_SETUP) {
-		bc_state_change(bc,BCHAN_EMPTY);
-		bc_next_state_change(bc,BCHAN_EMPTY);
-	} else {
-		cb_log(-1,bc->port,"Emptying bc(%x) within SETSTACK!\n",bc->addr);
-	}
 }
 
 
@@ -567,7 +559,7 @@
 	unsigned char buff[32];
 	struct misdn_stack * stack;
 
-	cb_log(3, 0, "$$$ CLEANUP CALLED\n");
+	cb_log(3, bc?bc->port:0, "$$$ CLEANUP CALLED pid:%d\n", bc?bc->pid:-1);
 	
 	if (!bc  ) return -1;
 	stack=get_stack_by_bc(bc);
@@ -575,44 +567,27 @@
 	if (!stack) return -1;
 	
 	switch (bc->bc_state ) {
-		
 	case BCHAN_CLEANED:
 		cb_log(5, stack->port, "$$$ Already cleaned up bc with stid :%x\n", bc->b_stid);
 		return -1;
 		
-	case BCHAN_ACTIVATED:
-		cb_log(2, stack->port, "$$$ bc still active, deactivatiing .. stid :%x\n", bc->b_stid);
-		manager_bchannel_deactivate(bc);
-		break;
-		
-	case BCHAN_BRIDGED:
-		cb_log(2, stack->port, "$$$ bc still bridged\n");
-		break;
-
-
-	case BCHAN_SETUP:
-		bc_state_change(bc,BCHAN_CLEAN_REQUEST);
-		return -1;
 	default:
 		break;
 	}
 	
-	cb_log(5, stack->port, "$$$ Cleaning up bc with stid :%x\n", bc->b_stid);
+	cb_log(2, stack->port, "$$$ Cleaning up bc with stid :%x pid:%d\n", bc->b_stid, bc->pid);
 	
+	manager_bchannel_deactivate(bc);
+
 	if ( misdn_cap_is_speech(bc->capability) && bc->ec_enable) {
 		manager_ec_disable(bc);
 	}
 
+	mISDN_write_frame(stack->midev, buff, bc->layer_id|FLG_MSG_TARGET|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
 	
-	mISDN_write_frame(stack->midev, buff, bc->layer_id|FLG_MSG_DOWN, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
+	/*mISDN_clear_stack(stack->midev, bc->b_stid);*/
 
-#if 0
-	cb_log(3, stack->port, "$$$ CLEARING STACK\n");
-	ret=mISDN_clear_stack(stack->midev,bc->b_stid);
-	if (ret<0 && errno) {
-		cb_log(-1,stack->port,"clear stack failed [%s]\n",strerror(errno));
-	}
-#endif
+	
 
 	bc->b_stid = 0;
 	bc_state_change(bc, BCHAN_CLEANED);
@@ -887,9 +862,12 @@
 	int b_stid=stack->b_stids[channel>=0?channel:0];
 
 
-	if ( bc->bc_state != BCHAN_CLEANED) {
-		cb_log(4, stack->port, "$$$ bc already upsetted stid :%x (state:%s)\n", b_stid, bc_state2str(bc->bc_state) );
-		return -1;
+	switch (bc->bc_state) {
+		case BCHAN_CLEANED:
+			break;
+		default:
+			cb_log(4, stack->port, "$$$ bc already upsetted stid :%x (state:%s)\n", b_stid, bc_state2str(bc->bc_state) );
+			return -1;
 	}
 	
 	cb_log(5, stack->port, "$$$ Setting up bc with stid :%x\n", b_stid);
@@ -1000,9 +978,32 @@
 		return(-EINVAL);
 	}
 
-	bc_state_change(bc,BCHAN_SETUP);
 
+	ret = mISDN_get_setstack_ind(midev, bc->layer_id);
+
+	if (ret) {
+		cb_log(-1, stack->port,"$$$ Set StackIND Err: %d %s\n",ret,strerror(errno));
+		mISDN_write_frame(midev, buff, bc->layer_id, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
+		
+		bc_state_change(bc,BCHAN_ERROR);
+		return(-EINVAL);
+	}
+
+	ret = mISDN_get_layerid(midev, bc->b_stid, bc->layer) ;
+
+	bc->addr = ret>0? ret : 0;
+
+	if (!bc->addr) {
+		cb_log(-1, stack->port,"$$$ Get Layerid Err: %d %s\n",ret,strerror(errno));
+		mISDN_write_frame(midev, buff, bc->layer_id, MGR_DELLAYER | REQUEST, 0, 0, NULL, TIMEOUT_1SEC);
+		
+		bc_state_change(bc,BCHAN_ERROR);
+	}
+
+	manager_bchannel_activate(bc);
 	
+	bc_state_change(bc,BCHAN_ACTIVATED);
+
 	return 0;
 }
 
@@ -1388,15 +1389,14 @@
 		switch (event) {
 
 		case EVENT_CONNECT_ACKNOWLEDGE:
-			
+#if 0
 			if ( !misdn_cap_is_speech(bc->capability)) {
 				int ret=setup_bc(bc);
 				if (ret == -EINVAL){
 					cb_log(-1,bc->port,"send_event: setup_bc failed\n");
 				}
 			}
-			
-			manager_bchannel_activate(bc);
+#endif	
 			break;
 		case EVENT_CONNECT:
 
@@ -1404,14 +1404,14 @@
 				cb_log(4, stack->port, "ENABLING BLOWFISH channel:%d oad%d:%s dad%d:%s\n", bc->channel, bc->onumplan,bc->oad, bc->dnumplan,bc->dad);
 				manager_ph_control_block(bc,  BF_ENABLE_KEY, bc->crypt_key, strlen(bc->crypt_key) );
 			}
-		case EVENT_SETUP:
-			if (bc->channel>0 && bc->channel<255)
-				set_chan_in_stack(stack, bc->channel);
-			break;
 		case EVENT_ALERTING:
 		case EVENT_PROGRESS:
 		case EVENT_PROCEEDING:
 		case EVENT_SETUP_ACKNOWLEDGE:
+
+		setup_bc(bc);
+		
+		case EVENT_SETUP:
 			
 		{
 			if (bc->channel == 0xff) {
@@ -1420,17 +1420,23 @@
 					cb_log(-1, stack->port, "Any Channel Requested, but we have no more!!\n");
 					break;
 				}
-			} 
-			
-			if (!stack->nt) {
-				int ret=setup_bc(bc);
-				if (ret == -EINVAL){
-					cb_log(-1,bc->port,"handle_event: setup_bc failed\n");
-					misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
-				}
+			}  	
+#if 0
+			int ret=setup_bc(bc);
+			if (ret == -EINVAL){
+				cb_log(-1,bc->port,"handle_event: setup_bc failed\n");
+				misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
 			}
+#endif
 		}
-		
+		break;
+
+		case EVENT_RELEASE_COMPLETE:
+		case EVENT_RELEASE:
+			empty_chan_in_stack(stack,bc->channel);
+			empty_bc(bc);
+			clean_up_bc(bc);
+			break;
 		default:
 			break;
 		}
@@ -1496,11 +1502,10 @@
 				empty_chan_in_stack(stack,bc->channel);
 				empty_bc(bc);
 				
-				bc_state_change(bc, BCHAN_EMPTY);
-
 				clean_up_bc(bc);
+				
 				dump_chan_list(stack);
-				bc->pid = 0;
+				/*bc->pid = 0;*/
 				cb_event(EVENT_CLEANUP, bc, glob_mgr->user_data);
 				if (bc->stack_holder) {
 					cb_log(4,stack->port, "REMOVEING Holder\n");
@@ -1719,8 +1724,6 @@
 						
 					}
 				}
-				
-				manager_bchannel_activate(bc);
 			}
 		}
 #endif
@@ -1732,6 +1735,7 @@
 			if(!stack->ptp) break;	
 		case CC_CONNECT|INDICATION:
 		{
+#if 0
 			struct misdn_bchannel *bc=find_bc_by_l3id(stack, hh->dinfo);
 			
 			if (!bc) {
@@ -1750,6 +1754,7 @@
 				cb_log(-1,bc->port,"handle_event_nt: setup_bc failed\n");
 				misdn_lib_send_event(bc,EVENT_RELEASE_COMPLETE);
 			}
+#endif
 		}
 		break;
 		case CC_DISCONNECT|INDICATION:
@@ -1868,6 +1873,7 @@
 		}
 		break;
 
+
 		case DL_RELEASE | INDICATION:
 		case DL_RELEASE | CONFIRM:
 		{
@@ -1900,6 +1906,45 @@
 		}
 		if (bc ) {
 			isdn_msg_parse_event(msgs_g,msg,bc, 1);
+
+			switch (event) {
+				case EVENT_SETUP:
+					if (bc->channel>0 && bc->channel<255) {
+
+						if (stack->ptp) 
+							set_chan_in_stack(stack, bc->channel);
+						else 
+							cb_log(-1,stack->port," --> PTMP but channel requested\n");
+
+					} else {
+
+						bc->channel = find_free_chan_in_stack(stack, 0);
+						if (!bc->channel) {
+							cb_log(-1, stack->port, " No free channel at the moment\n");
+					
+							msg_t *dmsg;
+				
+							cb_log(-1, stack->port, "Releaseing call %x (No free Chan for you..)\n", hh->dinfo);
+								dmsg = create_l3msg(CC_RELEASE_COMPLETE | REQUEST,MT_RELEASE_COMPLETE, hh->dinfo,sizeof(RELEASE_COMPLETE_t), 1);
+							stack->nst.manager_l3(&stack->nst, dmsg);
+							free_msg(msg);
+							return 0;
+						}
+						
+					}
+#if 0
+					setup_bc(bc);
+#endif
+
+					break;
+				case EVENT_RELEASE:
+				case EVENT_RELEASE_COMPLETE:
+					clean_up_bc(bc);
+					break;
+
+				default:
+				break;
+			}
 			
 			if(!isdn_get_info(msgs_g,event,1)) {
 				cb_log(4, stack->port, "Unknown Event Ind: prim %x dinfo %x\n",hh->prim, hh->dinfo);
@@ -2072,9 +2117,9 @@
 int handle_bchan(msg_t *msg)
 {
 	iframe_t *frm= (iframe_t*)msg->data;
-	struct misdn_bchannel *bc;
 
-	bc=find_bc_by_addr(frm->addr);
+
+	struct misdn_bchannel *bc=find_bc_by_addr(frm->addr);
 	
 	if (!bc) {
 		cb_log(0,0,"handle_bchan: BC not found for prim:%x with addr:%x dinfo:%x\n", frm->prim, frm->addr, frm->dinfo);
@@ -2091,12 +2136,13 @@
 	switch (frm->prim) {
 
 	case MGR_SETSTACK| CONFIRM:
-		cb_log(2, stack->port, "BCHAN: MGR_SETSTACK|CONFIRM \n");
+		cb_log(2, stack->port, "BCHAN: MGR_SETSTACK|CONFIRM pid:%d\n",bc->pid);
 		break;
 		
 	case MGR_SETSTACK| INDICATION:
-		cb_log(2, stack->port, "BCHAN: MGR_SETSTACK|IND \n");
-		
+		cb_log(2, stack->port, "BCHAN: MGR_SETSTACK|IND pid:%d\n",bc->pid);
+	break;
+#if 0
 	AGAIN:
 		bc->addr = mISDN_get_layerid(stack->midev, bc->b_stid, bc->layer);
 		if (!bc->addr) {
@@ -2124,60 +2170,71 @@
 		switch(bc->bc_state) {
 		case BCHAN_SETUP:
 			bc_state_change(bc,BCHAN_SETUPED);
-			manager_bchannel_activate(bc);
 		break;
 
 		case BCHAN_CLEAN_REQUEST:
 		default:
-			cb_log(-1, stack->port," --> STATE WASN'T SETUP (but %s) in SETSTACK|IND\n",bc_state2str(bc->bc_state));
+			cb_log(-1, stack->port," --> STATE WASN'T SETUP (but %s) in SETSTACK|IND pid:%d\n",bc_state2str(bc->bc_state), bc->pid);
 			clean_up_bc(bc);
 		}
 		return 1;
+#endif
 
 	case MGR_DELLAYER| INDICATION:
-		cb_log(2, stack->port, "BCHAN: MGR_DELLAYER|IND\n");
+		cb_log(2, stack->port, "BCHAN: MGR_DELLAYER|IND pid:%d\n",bc->pid);
 		break;
 		
 	case MGR_DELLAYER| CONFIRM:
-		cb_log(2, stack->port, "BCHAN: MGR_DELLAYER|CNF \n");
+		cb_log(2, stack->port, "BCHAN: MGR_DELLAYER|CNF pid:%d\n",bc->pid);
 		
-		bc_state_change(bc,BCHAN_CLEANED);
+		bc->pid=0;
+		bc->addr=0;
 		
 		free_msg(msg);
 		return 1;
 		
 	case PH_ACTIVATE | INDICATION:
 	case DL_ESTABLISH | INDICATION:
-		cb_log(4, stack->port, "BCHAN: ACT Ind\n");
+		cb_log(2, stack->port, "BCHAN: ACT Ind pid:%d\n", bc->pid);
 
-		bc_state_change(bc,BCHAN_ACTIVATED);
-		
 		free_msg(msg);
 		return 1;    
 
 	case PH_ACTIVATE | CONFIRM:
 	case DL_ESTABLISH | CONFIRM:
 		
-		bc_state_change(bc,BCHAN_ACTIVATED);
-		
-		cb_log(4, stack->port, "BCHAN: bchan ACT Confirm\n");
+		cb_log(2, stack->port, "BCHAN: bchan ACT Confirm pid:%d\n",bc->pid);
 		free_msg(msg);
 		
 		return 1;    
+
+	case DL_ESTABLISH | REQUEST:
+		{
+			char buf[128];
+			mISDN_write_frame(stack->midev, buf, bc->addr | FLG_MSG_TARGET | FLG_MSG_DOWN,  DL_ESTABLISH | CONFIRM, 0,0, NULL, TIMEOUT_1SEC);
+		}
+		free_msg(msg);
+		return 1;
+
+	case DL_RELEASE|REQUEST:
+		{
+			char buf[128];
+			mISDN_write_frame(stack->midev, buf, bc->addr | FLG_MSG_TARGET | FLG_MSG_DOWN,  DL_RELEASE| CONFIRM, 0,0, NULL, TIMEOUT_1SEC);
+		}
+		free_msg(msg);
+		return 1;
 		
 	case PH_DEACTIVATE | INDICATION:
 	case DL_RELEASE | INDICATION:
-		cb_log (4, stack->port, "BCHAN: DeACT Ind\n");
+		cb_log (2, stack->port, "BCHAN: DeACT Ind pid:%d\n",bc->pid);
 		
-		bc_state_change(bc,BCHAN_RELEASED);
 		free_msg(msg);
 		return 1;
     
 	case PH_DEACTIVATE | CONFIRM:
 	case DL_RELEASE | CONFIRM:
-		cb_log(4, stack->port, "BCHAN: DeACT Conf\n");
+		cb_log(4, stack->port, "BCHAN: DeACT Conf pid:%d\n",bc->pid);
 		
-		bc_state_change(bc,BCHAN_RELEASED);
 		free_msg(msg);
 		return 1;
     
@@ -2637,13 +2694,14 @@
 {
 	msg_t *msg=alloc_msg(MAX_MSG_SIZE);
 	int r;
-	fd_set rdfs;
+/*	fd_set rdfs; */
 
 	if (!msg) {
 		cb_log(-1, 0, "fetch_msg: alloc msg failed !!");
 		return NULL;
 	}
-	
+
+#if 0
 	FD_ZERO(&rdfs);
 	FD_SET(midev,&rdfs);
   
@@ -2651,14 +2709,15 @@
 	//select(FD_SETSIZE, &rdfs, NULL, NULL, NULL);
   
 	if (FD_ISSET(midev, &rdfs)) {
+#endif
 
 	AGAIN:
-		r=mISDN_read(midev,msg->data,MAX_MSG_SIZE, 5000);
+		r=mISDN_read(midev,msg->data,MAX_MSG_SIZE, TIMEOUT_10SEC);
 		msg->len=r;
     
 		if (r==0) {
 			free_msg(msg); /* danger, cauz usualy freeing in main_loop */
-			printf ("Got empty Msg?\n");
+			cb_log(6,0,"Got empty Msg..\n");
 			return NULL;
 		}
 
@@ -2674,9 +2733,12 @@
 		}
 
 		return msg;
+
+#if 0
 	} else {
 		printf ("Select timeout\n");
 	}
+#endif
   
 	return NULL;
 }
@@ -2831,8 +2893,10 @@
 	struct misdn_stack *stack;
 	int i;
 	
-	if (channel < 0 || channel > MAX_BCHANS)
+	if (channel < 0 || channel > MAX_BCHANS) {
+		cb_log(-1,port,"Requested channel out of bounds (%d)\n",channel);
 		return NULL;
+	}
 
 	for (stack=glob_mgr->stack_list; stack; stack=stack->next) {
     
@@ -2841,11 +2905,14 @@
 				if (channel <= stack->b_num) {
 					for (i = 0; i < stack->b_num; i++) {
 						if (stack->bc[i].in_use && stack->bc[i].channel == channel) {
+							cb_log(-1,port,"Requested channel:%d on port:%d is already in use\n",channel, port);
 							return NULL;
 						}
 					}
-				} else
+				} else {
+					cb_log(-1,port,"Requested channel:%d is out of bounds on port:%d\n",channel, port);
 					return NULL;
+				}
 			}
 			for (i = 0; i < stack->b_num; i++) {
 				if (!stack->bc[i].in_use) {
@@ -2855,9 +2922,13 @@
 					return &stack->bc[i];
 				}
 			}
+
+			cb_log(-1,port,"There is no free channel on port (%d)\n",port);
 			return NULL;
 		}
 	}
+
+	cb_log(-1,port,"Port is not configured (%d)\n",port);
 	return NULL;
 }
 
@@ -2917,6 +2988,7 @@
 {
 	msg_t *msg; 
 	int err = -1 ;
+	int ret=0;
   
 	if (!bc) goto ERR; 
 	
@@ -2937,7 +3009,7 @@
 		return 0;
 	}
 	
-	cb_log(1, stack->port, "I SEND:%s oad:%s dad:%s \n", isdn_get_info(msgs_g, event, 0), bc->oad, bc->dad);
+	cb_log(1, stack->port, "I SEND:%s oad:%s dad:%s pid:%d\n", isdn_get_info(msgs_g, event, 0), bc->oad, bc->dad, bc->pid);
 	cb_log(1, stack->port, " --> bc_state:%s\n",bc_state2str(bc->bc_state));
 	misdn_lib_log_ies(bc);
 	
@@ -2949,6 +3021,12 @@
 			err=-ENOCHAN;
 			goto ERR;
 		}
+#if 0
+		ret=setup_bc(bc);
+		if (ret == -EINVAL) {
+			cb_log(-1,bc->port,"send_event: setup_bc failed\n");
+		}
+#endif
 		break;
 
 	case EVENT_PROGRESS:
@@ -2972,13 +3050,10 @@
 			/* Its that i generate channels */
 		}
 		
-		if ( bc->nt || misdn_cap_is_speech(bc->capability)) {
-			int ret=setup_bc(bc);
-			if (ret == -EINVAL){
-				cb_log(-1,bc->port,"send_event: setup_bc failed\n");
-				
-			}
-		} 
+		ret=setup_bc(bc);
+		if (ret == -EINVAL) {
+			cb_log(-1,bc->port,"send_event: setup_bc failed\n");
+		}
 		
 		if ( (event == EVENT_CONNECT ) && misdn_cap_is_speech(bc->capability) ) {
 			if ( *bc->crypt_key ) {
@@ -3004,7 +3079,7 @@
 		}
 		
 		if (event == EVENT_RETRIEVE_ACKNOWLEDGE) {
-			manager_bchannel_activate(bc);
+			cb_log(0,bc->port,"DO WE NEED TO DO SOMETHING HERE WITH THE BC ?\n");
 		}
 		break;
 
@@ -3019,8 +3094,6 @@
 			if (bc->bc_state == BCHAN_BRIDGED) {
 				misdn_split_conf(bc,bc->conf_id);
 				misdn_split_conf(bc->holded_bc,bc->holded_bc->conf_id);
-				/*bc_state_change(bc,BCHAN_SETUPED);
-				manager_bchannel_activate(bc);*/
 			}
 
 			empty_chan_in_stack(stack,bc->channel);
@@ -3038,13 +3111,21 @@
 	break;
 	
 	case EVENT_RELEASE:
-		break;
-		
 	case EVENT_RELEASE_COMPLETE:
 		/*we do the cleanup in EVENT_CLEANUP*/
+		/*clean_up_bc(bc);*/
 		break;
     
 	case EVENT_CONNECT_ACKNOWLEDGE:
+
+		if ( bc->nt || misdn_cap_is_speech(bc->capability)) {
+			int ret=setup_bc(bc);
+			if (ret == -EINVAL){
+				cb_log(-1,bc->port,"send_event: setup_bc failed\n");
+				
+			}
+		}
+	
 		
 		if (misdn_cap_is_speech(bc->capability)) {
 			if (  !bc->nodsp) manager_ph_control(bc,  DTMF_TONE_START, 0);
@@ -3460,7 +3541,7 @@
 				} else {
 					iframe_t *frm = (iframe_t *)msg->data;
 					struct misdn_bchannel *bc = find_bc_by_l3id(stack, frm->dinfo);
-					cb_log(0,stack->port,"Sending msg, prim:%x addr:%x dinfo:%x\n",frm->prim,frm->addr,frm->dinfo);
+					cb_log(4,stack->port,"Sending msg, prim:%x addr:%x dinfo:%x\n",frm->prim,frm->addr,frm->dinfo);
 					if (bc) send_msg(glob_mgr->midev, bc, msg);
 				}
 			}
@@ -3655,9 +3736,10 @@
 
 void manager_bchannel_activate(struct misdn_bchannel *bc)
 {
-	msg_t *msg=alloc_msg(MAX_MSG_SIZE);
-	iframe_t *frm;
-	
+	char buf[128];
+	iframe_t *ifrm;
+	int ret;
+
 	struct misdn_stack *stack=get_stack_by_bc(bc);
 
 	if (!stack) {
@@ -3665,43 +3747,23 @@
 		return ;
 	}
 	
-	if (!msg) {
-		cb_log(-1, stack->port, "bchannel_activate: alloc_msg failed !");
-
-		return ;
-	}
-
-
-	switch (bc->bc_state) {
-
-	case BCHAN_SETUPED:
-		break;
-		
-	default:
-		cb_log(1, stack->port, "bchannel_activate: BC Not properly upsetted (state:%s) addr:%x\n", bc_state2str(bc->bc_state), bc->addr);
-
-		
-		return;
-	}
-	
-
-	
-	frm=(iframe_t*)msg->data;
 	/* we must activate if we are deactivated */
 	clear_ibuffer(bc->astbuf);
 	
 	cb_log(5, stack->port, "$$$ Bchan Activated addr %x\n", bc->addr);
 	
-	/* activate bchannel */
-	frm->prim = DL_ESTABLISH | REQUEST;
-	frm->addr = bc->addr | FLG_MSG_DOWN ;
-	frm->dinfo = 0;
-	frm->len = 0;
+	mISDN_write_frame(stack->midev, buf, bc->addr | FLG_MSG_DOWN,  DL_ESTABLISH | REQUEST, 0,0, NULL, TIMEOUT_1SEC);
+
+	ret=mISDN_read(stack->midev,buf,128,TIMEOUT_10SEC);
+
+	ifrm=(iframe_t*)buf;
 	
-	msg_queue_tail(&glob_mgr->activatequeue, msg);
-	sem_post(&glob_mgr->new_msg);
+	if (ret>0) {
+		if (ifrm->prim== (DL_ESTABLISH|CONFIRM)) {
+			cb_log(2,stack->port,"bchan: DL_ESTABLISH|CNF\n");
+		}
+	}
 	
-	bc_state_change(bc, BCHAN_ACTIVE);
 	
 	return ;
   
@@ -3736,7 +3798,7 @@
 	dact.dinfo = 0;
 	dact.len = 0;
 	char buf[128];	
-	mISDN_write_frame(stack->midev, buf, bc->addr| FLG_MSG_DOWN, DL_RELEASE|REQUEST,0,0,NULL, TIMEOUT_1SEC);
+	mISDN_write_frame(stack->midev, buf, bc->addr | FLG_MSG_DOWN, DL_RELEASE|REQUEST,0,0,NULL, TIMEOUT_1SEC);
 
 	mISDN_read(stack->midev, buf, 128, TIMEOUT_1SEC);
 
@@ -3940,6 +4002,16 @@
 		manager_ph_control(bc, TONE_PATT_OFF, TONE_GERMAN_HANGUP);	
 	}
 
+	char buf[mISDN_HEADER_LEN+128];
+	iframe_t *frm=(iframe_t*)buf;
+	memset(buf,0,mISDN_HEADER_LEN+128);
+
+	frm->prim=DL_DATA|REQUEST;
+	frm->addr=bc->addr|FLG_MSG_DOWN;
+	frm->dinfo=0;
+	frm->len=128;
+	
+	mISDN_write(glob_mgr->midev, frm, mISDN_HEADER_LEN+frm->len, TIMEOUT_1SEC);
 }
 
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:11:29 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:11:29 +0200
Subject: [solid-pbx-svn] r399 - trunk/channels
Message-ID: <200606280211.k5S2BTI3022539@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:11:22 +0200 (Wed, 28 Jun 2006)
New Revision: 399

Modified:
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r35273

------------------------------------------------------------------------
r35264 | file | 2006-06-21 18:50:24 +0200 (Wed, 21 Jun 2006) | 2 lines

Fix timing issue (race) with poke/pong for very close peers that can cause a peer to be declared unreachable (issue #7396 reported by stevedavies)

------------------------------------------------------------------------


Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 02:10:06 UTC (rev 398)
+++ trunk/channels/chan_iax2.c	2006-06-28 02:11:22 UTC (rev 399)
@@ -338,7 +338,7 @@
 
 	/* Qualification */
 	int callno;					/*!< Call number of POKE request */
-	int pokeexpire;					/*!< When to expire poke */
+	int pokeexpire;					/*!< Scheduled qualification-related task (ie iax2_poke_peer_s or iax2_poke_noanswer) */
 	int lastms;					/*!< How long last response took (in ms), or -1 for no response */
 	int maxms;					/*!< Max ms we will accept for the host to be up, 0 to not monitor */
 
@@ -7145,18 +7145,21 @@
 					else					
 						peer->historicms = iaxs[fr->callno]->pingtime;
 
+					/* Remove scheduled iax2_poke_noanswer */
 					if (peer->pokeexpire > -1)
 						ast_sched_del(sched, peer->pokeexpire);
+					/* Schedule the next cycle */
+					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) 
+						peer->pokeexpire = ast_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer);
+					else
+						peer->pokeexpire = ast_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer);
+					/* and finally send the ack */
 					send_command_immediate(iaxs[fr->callno], AST_FRAME_IAX, IAX_COMMAND_ACK, fr->ts, NULL, 0,fr->iseqno);
+					/* And wrap up the qualify call */
 					iax2_destroy_nolock(fr->callno);
 					peer->callno = 0;
-					/* Try again eventually */
 					if (option_debug)
-						ast_log(LOG_DEBUG, "Peer lastms %d, historicms %d, maxms %d\n", peer->lastms, peer->historicms, peer->maxms);
-					if ((peer->lastms < 0)  || (peer->historicms > peer->maxms)) 
-						peer->pokeexpire = ast_sched_add(sched, peer->pokefreqnotok, iax2_poke_peer_s, peer);
-					else
-						peer->pokeexpire = ast_sched_add(sched, peer->pokefreqok, iax2_poke_peer_s, peer);
+						ast_log(LOG_DEBUG, "Peer %s: got pong, lastms %d, historicms %d, maxms %d\n", peer->name, peer->lastms, peer->historicms, peer->maxms);
 				}
 				break;
 			case IAX_COMMAND_LAGRQ:
@@ -7957,7 +7960,7 @@
 {
 	if (!peer->maxms || !peer->addr.sin_addr.s_addr) {
 		/* IF we have no IP, or this isn't to be monitored, return
-		  imeediately after clearing things out */
+		  immediately after clearing things out */
 		peer->lastms = 0;
 		peer->historicms = 0;
 		peer->pokeexpire = -1;
@@ -7977,19 +7980,25 @@
 		ast_log(LOG_WARNING, "Unable to allocate call for poking peer '%s'\n", peer->name);
 		return -1;
 	}
-	if (peer->pokeexpire > -1)
-		ast_sched_del(sched, peer->pokeexpire);
-	/* Speed up retransmission times */
+
+	/* Speed up retransmission times for this qualify call */
 	iaxs[peer->callno]->pingtime = peer->maxms / 4 + 1;
 	iaxs[peer->callno]->peerpoke = peer;
-	send_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);
 	
+	/* Remove any pending pokeexpire task */
+	if (peer->pokeexpire > -1)
+		ast_sched_del(sched, peer->pokeexpire);
+
+	/* Queue up a new task to handle no reply */
 	/* If the host is already unreachable then use the unreachable interval instead */
 	if (peer->lastms < 0) {
 		peer->pokeexpire = ast_sched_add(sched, peer->pokefreqnotok, iax2_poke_noanswer, peer);
 	} else
 		peer->pokeexpire = ast_sched_add(sched, DEFAULT_MAXMS * 2, iax2_poke_noanswer, peer);
 
+	/* And send the poke */
+	send_command(iaxs[peer->callno], AST_FRAME_IAX, IAX_COMMAND_POKE, 0, NULL, 0, -1);
+
 	return 0;
 }
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:12:37 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:12:37 +0200
Subject: [solid-pbx-svn] r401 - trunk/apps
Message-ID: <200606280212.k5S2Cbnn023045@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:12:28 +0200 (Wed, 28 Jun 2006)
New Revision: 401

Modified:
   trunk/apps/app_queue.c
Log:
Update to Asterisk SVN trunk r35313

------------------------------------------------------------------------
r35311 | file | 2006-06-21 20:39:56 +0200 (Wed, 21 Jun 2006) | 2 lines

Actually allow realtime queue members to be added (issue #7408 reported by tgrman)

------------------------------------------------------------------------


Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-28 02:11:58 UTC (rev 400)
+++ trunk/apps/app_queue.c	2006-06-28 02:12:28 UTC (rev 401)
@@ -968,7 +968,7 @@
 	struct ast_variable *v;
 	struct call_queue *q;
 	struct member *m, *prev_m, *next_m;
-	char *interface;
+	char *interface = NULL;
 	char *tmp, *tmp_name;
 	char tmpbuf[64];	/* Must be longer than the longest queue param name. */
 
@@ -1050,8 +1050,7 @@
 			m->dead = 1;
 	}
 
-	interface = NULL;
-	while (ast_category_browse(member_config, interface))
+	while ((interface = ast_category_browse(member_config, interface)))
 		rt_handle_member_record(q, interface, ast_variable_retrieve(member_config, interface, "penalty"));
 
 	/* Delete all realtime members that have been deleted in DB. */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:12:02 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:12:02 +0200
Subject: [solid-pbx-svn] r400 - trunk/channels
Message-ID: <200606280212.k5S2C20a022894@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:11:58 +0200 (Wed, 28 Jun 2006)
New Revision: 400

Modified:
   trunk/channels/chan_sip.c
Log:
Update to Asterisk SVN trunk r35293

------------------------------------------------------------------------
r35287 | oej | 2006-06-21 19:05:38 +0200 (Wed, 21 Jun 2006) | 2 lines

Only formatting changes... (tabs to spaces)

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:11:22 UTC (rev 399)
+++ trunk/channels/chan_sip.c	2006-06-28 02:11:58 UTC (rev 400)
@@ -147,41 +147,41 @@
 #include "asterisk/abstract_jb.h"
 
 #ifndef FALSE
-#define FALSE	0
+#define FALSE    0
 #endif
 
 #ifndef TRUE
-#define TRUE 1
+#define TRUE     1
 #endif
 
-#define VIDEO_CODEC_MASK	0x1fc0000 /*!< Video codecs from H.261 thru AST_FORMAT_MAX_VIDEO */
+#define VIDEO_CODEC_MASK        0x1fc0000 /*!< Video codecs from H.261 thru AST_FORMAT_MAX_VIDEO */
 #ifndef IPTOS_MINCOST
-#define IPTOS_MINCOST		0x02
+#define IPTOS_MINCOST           0x02
 #endif
 
 /* #define VOCAL_DATA_HACK */
 
 #define DEFAULT_DEFAULT_EXPIRY  120
-#define DEFAULT_MIN_EXPIRY	60
-#define DEFAULT_MAX_EXPIRY	3600
-#define DEFAULT_REGISTRATION_TIMEOUT	20
-#define DEFAULT_MAX_FORWARDS	"70"
+#define DEFAULT_MIN_EXPIRY      60
+#define DEFAULT_MAX_EXPIRY      3600
+#define DEFAULT_REGISTRATION_TIMEOUT 20
+#define DEFAULT_MAX_FORWARDS    "70"
 
 /* guard limit must be larger than guard secs */
 /* guard min must be < 1000, and should be >= 250 */
-#define EXPIRY_GUARD_SECS	15		/*!< How long before expiry do we reregister */
-#define EXPIRY_GUARD_LIMIT	30		/*!< Below here, we use EXPIRY_GUARD_PCT instead of 
-					 	  EXPIRY_GUARD_SECS */
-#define EXPIRY_GUARD_MIN	500		/*!< This is the minimum guard time applied. If 
-					 	  GUARD_PCT turns out to be lower than this, it 
-						   will use this time instead.
-						   This is in milliseconds. */
-#define EXPIRY_GUARD_PCT	0.20		/*!< Percentage of expires timeout to use when 
-						   below EXPIRY_GUARD_LIMIT */
-#define DEFAULT_EXPIRY 900			/*!< Expire slowly */
+#define EXPIRY_GUARD_SECS       15                /*!< How long before expiry do we reregister */
+#define EXPIRY_GUARD_LIMIT      30                /*!< Below here, we use EXPIRY_GUARD_PCT instead of 
+                                                   EXPIRY_GUARD_SECS */
+#define EXPIRY_GUARD_MIN        500                /*!< This is the minimum guard time applied. If 
+                                                   GUARD_PCT turns out to be lower than this, it 
+                                                   will use this time instead.
+                                                   This is in milliseconds. */
+#define EXPIRY_GUARD_PCT        0.20                /*!< Percentage of expires timeout to use when 
+                                                    below EXPIRY_GUARD_LIMIT */
+#define DEFAULT_EXPIRY 900                          /*!< Expire slowly */
 
-static int min_expiry = DEFAULT_MIN_EXPIRY;	/*!< Minimum accepted registration time */
-static int max_expiry = DEFAULT_MAX_EXPIRY;	/*!< Maximum accepted registration time */
+static int min_expiry = DEFAULT_MIN_EXPIRY;        /*!< Minimum accepted registration time */
+static int max_expiry = DEFAULT_MAX_EXPIRY;        /*!< Maximum accepted registration time */
 static int default_expiry = DEFAULT_DEFAULT_EXPIRY;
 static int expiry = DEFAULT_EXPIRY;
 
@@ -189,29 +189,29 @@
 #define MAX(a,b) ((a) > (b) ? (a) : (b))
 #endif
 
-#define CALLERID_UNKNOWN	"Unknown"
+#define CALLERID_UNKNOWN        "Unknown"
 
-#define DEFAULT_MAXMS		2000		/*!< Qualification: Must be faster than 2 seconds by default */
-#define DEFAULT_FREQ_OK		60 * 1000	/*!< Qualification: How often to check for the host to be up */
-#define DEFAULT_FREQ_NOTOK	10 * 1000	/*!< Qualification: How often to check, if the host is down... */
+#define DEFAULT_MAXMS                2000             /*!< Qualification: Must be faster than 2 seconds by default */
+#define DEFAULT_FREQ_OK              60 * 1000        /*!< Qualification: How often to check for the host to be up */
+#define DEFAULT_FREQ_NOTOK           10 * 1000        /*!< Qualification: How often to check, if the host is down... */
 
-#define DEFAULT_RETRANS		1000		/*!< How frequently to retransmit Default: 2 * 500 ms in RFC 3261 */
-#define MAX_RETRANS		6		/*!< Try only 6 times for retransmissions, a total of 7 transmissions */
-#define SIP_TRANS_TIMEOUT	32000		/*!< SIP request timeout (rfc 3261) 64*T1 
-						\todo Use known T1 for timeout (peerpoke)
-						*/
-#define MAX_AUTHTRIES		3		/*!< Try authentication three times, then fail */
+#define DEFAULT_RETRANS              1000             /*!< How frequently to retransmit Default: 2 * 500 ms in RFC 3261 */
+#define MAX_RETRANS                  6                /*!< Try only 6 times for retransmissions, a total of 7 transmissions */
+#define SIP_TRANS_TIMEOUT            32000            /*!< SIP request timeout (rfc 3261) 64*T1 
+                                                      \todo Use known T1 for timeout (peerpoke)
+                                                      */
+#define MAX_AUTHTRIES                3                /*!< Try authentication three times, then fail */
 
-#define SIP_MAX_HEADERS		64			/*!< Max amount of SIP headers to read */
-#define SIP_MAX_LINES 		64			/*!< Max amount of lines in SIP attachment (like SDP) */
-#define SIP_MAX_PACKET		4096	/*!< Also from RFC 3261 (2543), should sub headers tho */
+#define SIP_MAX_HEADERS              64               /*!< Max amount of SIP headers to read */
+#define SIP_MAX_LINES                64               /*!< Max amount of lines in SIP attachment (like SDP) */
+#define SIP_MAX_PACKET               4096             /*!< Also from RFC 3261 (2543), should sub headers tho */
 
-#define	INITIAL_CSEQ		101	/*!< our initial sip sequence number */
+#define INITIAL_CSEQ                 101              /*!< our initial sip sequence number */
 
-/*! Global jitterbuffer configuration - by default, jb is disabled */
+/*! \brief Global jitterbuffer configuration - by default, jb is disabled */
 static struct ast_jb_conf default_jbconf =
 {
-	.flags = 0,
+        .flags = 0,
 	.max_size = -1,
 	.resync_threshold = -1,
 	.impl = ""
@@ -231,8 +231,8 @@
 \note Not a bitfield flag, since there are plans for other modes,
 	like "only allow transfers for authenticated devices" */
 enum transfermodes {
-	TRANSFER_OPENFORALL, 		/*!< Allow all SIP transfers */
-	TRANSFER_CLOSED,		/*!< Allow no SIP transfers */
+	TRANSFER_OPENFORALL,            /*!< Allow all SIP transfers */
+	TRANSFER_CLOSED,                /*!< Allow no SIP transfers */
 };
 
 
@@ -250,12 +250,18 @@
 */
 
 enum xmittype {
-	XMIT_CRITICAL = 2,		/*!< Transmit critical SIP message reliably, with re-transmits.
-							If it fails, it's critical and will cause a teardown of the session */
-	XMIT_RELIABLE = 1,		/*!< Transmit SIP message reliably, with re-transmits */
-	XMIT_UNRELIABLE = 0,		/*!< Transmit SIP message without bothering with re-transmits */
+	XMIT_CRITICAL = 2,              /*!< Transmit critical SIP message reliably, with re-transmits.
+                                              If it fails, it's critical and will cause a teardown of the session */
+	XMIT_RELIABLE = 1,              /*!< Transmit SIP message reliably, with re-transmits */
+	XMIT_UNRELIABLE = 0,            /*!< Transmit SIP message without bothering with re-transmits */
 };
 
+enum parse_register_result {
+	PARSE_REGISTER_FAILED,
+	PARSE_REGISTER_UPDATE,
+	PARSE_REGISTER_QUERY,
+};
+
 enum subscriptiontype { 
 	NONE = 0,
 	TIMEOUT,
@@ -266,13 +272,6 @@
 	MWI_NOTIFICATION
 };
 
-enum parse_register_result {
-	PARSE_REGISTER_FAILED,
-	PARSE_REGISTER_UPDATE,
-	PARSE_REGISTER_QUERY,
-};
-
-
 static const struct cfsubscription_types {
 	enum subscriptiontype type;
 	const char * const event;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:13:16 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:13:16 +0200
Subject: [solid-pbx-svn] r402 - trunk
Message-ID: <200606280213.k5S2DGQo023264@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:13:13 +0200 (Wed, 28 Jun 2006)
New Revision: 402

Modified:
   trunk/rtp.c
Log:
Update to Asterisk SVN trunk r35333

------------------------------------------------------------------------
r35333 | oej | 2006-06-21 21:07:02 +0200 (Wed, 21 Jun 2006) | 2 lines

Only delete scheduled item if it exists

------------------------------------------------------------------------


Modified: trunk/rtp.c
===================================================================
--- trunk/rtp.c	2006-06-28 02:12:28 UTC (rev 401)
+++ trunk/rtp.c	2006-06-28 02:13:13 UTC (rev 402)
@@ -1051,7 +1051,7 @@
 		rtp->seedrxseqno = seqno;
 	}
 
-	if (rtp->rtcp->schedid<1) {
+	if (rtp->rtcp->schedid < 1) {
 		/* Schedule transmission of Receiver Report */
 		rtp->rtcp->schedid = ast_sched_add(rtp->sched, ast_rtcp_calc_interval(rtp), ast_rtcp_write, rtp);
 	}
@@ -1748,7 +1748,7 @@
 
 void ast_rtp_stop(struct ast_rtp *rtp)
 {
-	if (rtp->rtcp->schedid>0) {
+	if (rtp->rtcp->schedid > 0) {
 		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 	}
@@ -1820,7 +1820,7 @@
 		ast_verbose("  RTT:		 %f\n", rtp->rtcp->rtt);
 	}
 
-	if (rtp->rtcp->schedid>0) {
+	if (rtp->rtcp->schedid > 0) {
 		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 	}
@@ -1978,7 +1978,8 @@
 	
 	if (!rtp->rtcp->them.sin_addr.s_addr) {  /* This'll stop rtcp for this rtp session */
 		ast_verbose("RTCP SR transmission error, rtcp halted %s\n",strerror(errno));
-		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		if (rtp->rtcp->schedid > 0)
+			ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 		return 0;
 	}
@@ -2036,7 +2037,8 @@
 	res = sendto(rtp->rtcp->s, (unsigned int *)rtcpheader, len, 0, (struct sockaddr *)&rtp->rtcp->them, sizeof(rtp->rtcp->them));
 	if (res < 0) {
 		ast_log(LOG_ERROR, "RTCP SR transmission error to %s:%d, rtcp halted %s\n",ast_inet_ntoa(iabuf, sizeof(iabuf), rtp->rtcp->them.sin_addr), ntohs(rtp->rtcp->them.sin_port), strerror(errno));
-		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		if (rtp->rtcp->schedid > 0)
+			ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 		return 0;
 	}
@@ -2088,7 +2090,8 @@
 	  
 	if (!rtp->rtcp->them.sin_addr.s_addr) {
 		ast_log(LOG_ERROR, "RTCP RR transmission error to, rtcp halted %s\n",strerror(errno));
-		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		if (rtp->rtcp->schedid > 0)
+			ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 		return 0;
 	}
@@ -2136,7 +2139,8 @@
 	if (res < 0) {
 		ast_log(LOG_ERROR, "RTCP RR transmission error, rtcp halted: %s\n",strerror(errno));
 		/* Remove the scheduler */
-		ast_sched_del(rtp->sched, rtp->rtcp->schedid);
+		if (rtp->rtcp->schedid > 0)
+			ast_sched_del(rtp->sched, rtp->rtcp->schedid);
 		rtp->rtcp->schedid = -1;
 		return 0;
 	}



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:14:33 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:14:33 +0200
Subject: [solid-pbx-svn] r403 - in trunk: channels configs
Message-ID: <200606280214.k5S2EXdZ023598@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:13:45 +0200 (Wed, 28 Jun 2006)
New Revision: 403

Modified:
   trunk/channels/chan_sip.c
   trunk/configs/indications.conf.sample
Log:
Update to Asterisk SVN trunk r35343

------------------------------------------------------------------------
r35335 | file | 2006-06-21 21:26:52 +0200 (Wed, 21 Jun 2006) | 10 lines

Merged revisions 35334 via svnmerge from 
https://origsvn.digium.com/svn/asterisk/branches/1.2

.......
r35334 | file | 2006-06-21 16:25:34 -0300 (Wed, 21 Jun 2006) | 2 lines

Add Venezuelan indications (issue #7402 reported by palillo)

.......

------------------------------------------------------------------------
r35336 | oej | 2006-06-21 21:58:03 +0200 (Wed, 21 Jun 2006) | 2 lines

Issue #7380 - Cannot put a one-legged call on hold/off hold

------------------------------------------------------------------------


Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:13:13 UTC (rev 402)
+++ trunk/channels/chan_sip.c	2006-06-28 02:13:45 UTC (rev 403)
@@ -4811,7 +4811,7 @@
 				p->t38.jointcapability);
 	} else {
 		p->t38.state = T38_DISABLED;
-		if (option_debug > 1)
+		if (option_debug > 2)
 			ast_log(LOG_DEBUG, "T38 state changed to %d on channel %s\n", p->t38.state, p->owner ? p->owner->name : "<none>");
 	}
 
@@ -4888,6 +4888,8 @@
 	if (!p->owner) 	/* There's no open channel owning us so we can return here. For a re-invite or so, we proceed */
 		return 0;
 
+	if (option_debug > 3)
+		ast_log(LOG_DEBUG, "We have an owner, now see if we need to change this call\n");
 
 	if (!(p->owner->nativeformats & p->jointcapability & AST_FORMAT_AUDIO_MASK)) {
 		if (debug) {
@@ -4911,7 +4913,6 @@
 			ast_queue_frame(p->owner, &ast_null_frame);
 		} else {
 			/* No address for RTP, we're on hold */
-			
 			ast_moh_start(bridgepeer, NULL);
 			if (sendonly)
 				ast_rtp_stop(p->rtp);
@@ -4923,7 +4924,6 @@
 	}
 
 	/* Manager Hold and Unhold events must be generated, if necessary */
-	/* XXX Support for sendonly/recvonly needs to be fixed !!! */
 	if (sin.sin_addr.s_addr && !sendonly) {
 		if (ast_test_flag(&p->flags[0], SIP_CALL_ONHOLD)) {
 			append_history(p, "Unhold", "%s", req->data);
@@ -4950,7 +4950,6 @@
 		ast_set_flag(&p->flags[0], SIP_CALL_ONHOLD);
 	}
 	
-
 	return 0;
 }
 
@@ -12982,7 +12981,8 @@
 							transmit_response_with_sdp(p, "200 OK", req, XMIT_CRITICAL);
 						}
 					}
-				}
+				} else	/* No bridged peer */
+					transmit_response_with_sdp(p, "200 OK", req, XMIT_CRITICAL);
 			}
 			break;
 		default:

Modified: trunk/configs/indications.conf.sample
===================================================================
--- trunk/configs/indications.conf.sample	2006-06-28 02:13:13 UTC (rev 402)
+++ trunk/configs/indications.conf.sample	2006-06-28 02:13:45 UTC (rev 403)
@@ -665,6 +665,21 @@
 info = !950/330,!1400/330,!1800/330,0
 stutter = !350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,!350+440/100,!0/100,350+440
 
+[ve]
+; Tone definition source for ve found on 
+; Reference: http://www.itu.int/ITU-T/inr/forms/files/tones-0203.pdf
+description = Venezuela / South America
+ringcadence = 1000,4000
+dial = 425
+busy = 425/500,0/500
+ring = 425/1000,0/4000
+congestion = 425/250,0/250
+callwaiting = 400+450/300,0/6000
+dialrecall = 425
+record = 1400/500,0/15000
+info = !950/330,!1440/330,!1800/330,0/1000
+
+
 [za]
 description = South Africa
 ; http://www.cisco.com/univercd/cc/td/doc/product/tel_pswt/vco_prod/safr_sup/saf02.htm



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:16:07 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:16:07 +0200
Subject: [solid-pbx-svn] r404 - in trunk: channels doc
Message-ID: <200606280216.k5S2G7lf023989@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:15:09 +0200 (Wed, 28 Jun 2006)
New Revision: 404

Modified:
   trunk/channels/chan_agent.c
   trunk/doc/video.txt
Log:
Update to Asterisk SVN trunk r35373

------------------------------------------------------------------------
r35365 | oej | 2006-06-21 22:11:09 +0200 (Wed, 21 Jun 2006) | 7 lines

Add video support to chan_agent. 

More ideas for developing better video support in Asterisk?

Join the asterisk-video mailing list to help out in the 
Asterisk Video Task Force!

------------------------------------------------------------------------
r35366 | oej | 2006-06-21 22:14:25 +0200 (Wed, 21 Jun 2006) | 2 lines

Add agent to video docs

------------------------------------------------------------------------


Modified: trunk/channels/chan_agent.c
===================================================================
--- trunk/channels/chan_agent.c	2006-06-28 02:13:45 UTC (rev 403)
+++ trunk/channels/chan_agent.c	2006-06-28 02:15:09 UTC (rev 404)
@@ -267,6 +267,7 @@
 	.answer = agent_answer,
 	.read = agent_read,
 	.write = agent_write,
+	.write_video = agent_write,
 	.send_html = agent_sendhtml,
 	.send_text = agent_sendtext,
 	.exception = agent_read,
@@ -507,7 +508,8 @@
  			}
  			break;
  		case AST_FRAME_VOICE:
- 			/* don't pass voice until the call is acknowledged */
+ 		case AST_FRAME_VIDEO:
+ 			/* don't pass voice or video until the call is acknowledged */
  			if (!p->acknowledged) {
  				ast_frfree(f);
  				f = &ast_null_frame;
@@ -558,16 +560,20 @@
 	int res = -1;
 	CHECK_FORMATS(ast, p);
 	ast_mutex_lock(&p->lock);
-	if (p->chan) {
+	if (!p->chan) 
+		res = 0;
+	else {
 		if ((f->frametype != AST_FRAME_VOICE) ||
+		    (f->frametype != AST_FRAME_VIDEO) ||
 		    (f->subclass == p->chan->writeformat)) {
 			res = ast_write(p->chan, f);
 		} else {
-			ast_log(LOG_DEBUG, "Dropping one incompatible voice frame on '%s' to '%s'\n", ast->name, p->chan->name);
+			ast_log(LOG_DEBUG, "Dropping one incompatible %s frame on '%s' to '%s'\n", 
+				f->frametype == AST_FRAME_VOICE ? "audio" : "video",
+				ast->name, p->chan->name);
 			res = 0;
 		}
-	} else
-		res = 0;
+	}
 	CLEANUP(ast, p);
 	ast_mutex_unlock(&p->lock);
 	return res;

Modified: trunk/doc/video.txt
===================================================================
--- trunk/doc/video.txt	2006-06-28 02:13:45 UTC (rev 403)
+++ trunk/doc/video.txt	2006-06-28 02:15:09 UTC (rev 404)
@@ -26,8 +26,9 @@
 Channel drivers
 ---------------
 SIP		The SIP channel driver (chan_sip.so) has support for video
-IAX2		Supports video calls
+IAX2		Supports video calls (over trunks too)
 Local		Forwards video calls as a proxy channel
+Agent		Forwards video calls as a proxy channel
 
 Applications
 ------------
@@ -42,4 +43,4 @@
 If you want to participate, join the asterisk-video mailing list on http://lists.digium.com
 
 ---
-Updates to this file are welcome!
+Updates to this file are more than welcome!



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:27:19 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:27:19 +0200
Subject: [solid-pbx-svn] r405 - trunk
Message-ID: <200606280227.k5S2RJoa027452@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:27:01 +0200 (Wed, 28 Jun 2006)
New Revision: 405

Modified:
   trunk/Makefile
   trunk/configure.ac
Log:
Update to Asterisk SVN trunk r35393

------------------------------------------------------------------------
r35391 | russell | 2006-06-22 12:30:51 +0200 (Thu, 22 Jun 2006) | 4 lines

use the AC_PREFIX_DEFAULT macro to set the default prefix instead of setting
the variable directly, so that the configure --help information shows the
correct default prefix

------------------------------------------------------------------------
r35392 | russell | 2006-06-22 12:36:45 +0200 (Thu, 22 Jun 2006) | 2 lines

use $(BASENAME) set by configure

------------------------------------------------------------------------
r35393 | russell | 2006-06-22 12:38:45 +0200 (Thu, 22 Jun 2006) | 2 lines

use $(FIND) and $(LN) from configure

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:15:09 UTC (rev 404)
+++ trunk/Makefile	2006-06-28 02:27:01 UTC (rev 405)
@@ -559,7 +559,7 @@
 	mkdir -p $(DESTDIR)$(ASTSPOOLDIR)/monitor
 	if [ -f asterisk ]; then $(INSTALL) -m 755 asterisk $(DESTDIR)$(ASTSBINDIR)/; fi
 	if [ -f asterisk.dll ]; then $(INSTALL) -m 755 asterisk.dll $(DESTDIR)$(ASTSBINDIR)/; fi
-	ln -sf asterisk $(DESTDIR)$(ASTSBINDIR)/rasterisk
+	$(LN) -sf asterisk $(DESTDIR)$(ASTSBINDIR)/rasterisk
 	$(INSTALL) -m 755 contrib/scripts/astgenkey $(DESTDIR)$(ASTSBINDIR)/
 	$(INSTALL) -m 755 contrib/scripts/autosupport $(DESTDIR)$(ASTSBINDIR)/
 	if [ ! -f $(DESTDIR)$(ASTSBINDIR)/safe_asterisk ]; then \
@@ -643,26 +643,26 @@
 	mkdir -p $(DESTDIR)$(ASTETCDIR)
 	for x in configs/*.adsi; do \
 		if [ ! -f $(DESTDIR)$(ASTETCDIR)/$$x ]; then \
-			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTETCDIR)/`basename $$x` ; \
+			$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTETCDIR)/`$(BASENAME) $$x` ; \
 		fi ; \
 	done
 
 samples: adsi
 	mkdir -p $(DESTDIR)$(ASTETCDIR)
 	for x in configs/*.sample; do \
-		if [ -f $(DESTDIR)$(ASTETCDIR)/`basename $$x .sample` ]; then \
+		if [ -f $(DESTDIR)$(ASTETCDIR)/`$(BASENAME) $$x .sample` ]; then \
 			if [ "$(OVERWRITE)" = "y" ]; then \
-				if cmp -s $(DESTDIR)$(ASTETCDIR)/`basename $$x .sample` $$x ; then \
+				if cmp -s $(DESTDIR)$(ASTETCDIR)/`$(BASENAME) $$x .sample` $$x ; then \
 					echo "Config file $$x is unchanged"; \
 					continue; \
 				fi ; \
-				mv -f $(DESTDIR)$(ASTETCDIR)/`basename $$x .sample` $(DESTDIR)$(ASTETCDIR)/`basename $$x .sample`.old ; \
+				mv -f $(DESTDIR)$(ASTETCDIR)/`$(BASENAME) $$x .sample` $(DESTDIR)$(ASTETCDIR)/`$(BASENAME) $$x .sample`.old ; \
 			else \
 				echo "Skipping config file $$x"; \
 				continue; \
 			fi ;\
 		fi ; \
-		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTETCDIR)/`basename $$x .sample` ;\
+		$(INSTALL) -m 644 $$x $(DESTDIR)$(ASTETCDIR)/`$(BASENAME) $$x .sample` ;\
 	done
 	if [ "$(OVERWRITE)" = "y" ] || [ ! -f $(DESTDIR)$(ASTCONFPATH) ]; then \
 		( \
@@ -781,20 +781,20 @@
 
 .tags-depend:
 	@echo -n ".tags-depend: " > $@
-	@find . -maxdepth 1 -name \*.c -printf "\t%p \\\\\n" >> $@
-	@find . -maxdepth 1 -name \*.h -printf "\t%p \\\\\n" >> $@
-	@find $(SUBDIRS) -name \*.c -printf "\t%p \\\\\n" >> $@
-	@find $(SUBDIRS) -name \*.h -printf "\t%p \\\\\n" >> $@
-	@find include -name \*.h -printf "\t%p \\\\\n" >> $@
+	@$(FIND) . -maxdepth 1 -name \*.c -printf "\t%p \\\\\n" >> $@
+	@$(FIND) . -maxdepth 1 -name \*.h -printf "\t%p \\\\\n" >> $@
+	@$(FIND) $(SUBDIRS) -name \*.c -printf "\t%p \\\\\n" >> $@
+	@$(FIND) $(SUBDIRS) -name \*.h -printf "\t%p \\\\\n" >> $@
+	@$(FIND) include -name \*.h -printf "\t%p \\\\\n" >> $@
 	@echo >> $@
 
 .tags-sources:
 	@rm -f $@
-	@find . -maxdepth 1 -name \*.c -print >> $@
-	@find . -maxdepth 1 -name \*.h -print >> $@
-	@find $(SUBDIRS) -name \*.c -print >> $@
-	@find $(SUBDIRS) -name \*.h -print >> $@
-	@find include -name \*.h -print >> $@
+	@$(FIND) . -maxdepth 1 -name \*.c -print >> $@
+	@$(FIND) . -maxdepth 1 -name \*.h -print >> $@
+	@$(FIND) $(SUBDIRS) -name \*.c -print >> $@
+	@$(FIND) $(SUBDIRS) -name \*.h -print >> $@
+	@$(FIND) include -name \*.h -print >> $@
 
 tags: .tags-depend .tags-sources
 	ctags -L .tags-sources -o $@

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-28 02:15:09 UTC (rev 404)
+++ trunk/configure.ac	2006-06-28 02:27:01 UTC (rev 405)
@@ -24,10 +24,10 @@
 
 case "${host}" in
      *freebsd*)
-     ac_default_prefix=/usr/local
+     AC_PREFIX_DEFAULT(/usr/local)
      ;;
      *)
-     ac_default_prefix=/usr
+     AC_PREFIX_DEFAULT(/usr)
      if test ${sysconfdir} = '${prefix}/etc'; then
         sysconfdir=/etc
      fi



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:28:39 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:28:39 +0200
Subject: [solid-pbx-svn] r406 - in trunk: . agi apps build_tools cdr channels codecs formats funcs pbx res sounds utils
Message-ID: <200606280228.k5S2Sda1027971@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:28:17 +0200 (Wed, 28 Jun 2006)
New Revision: 406

Modified:
   trunk/Makefile
   trunk/agi/Makefile
   trunk/apps/Makefile
   trunk/build_tools/Makefile
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/formats/Makefile
   trunk/funcs/Makefile
   trunk/pbx/Makefile
   trunk/res/Makefile
   trunk/sounds/Makefile
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r35423

------------------------------------------------------------------------
r35415 | russell | 2006-06-22 13:27:03 +0200 (Thu, 22 Jun 2006) | 5 lines

add the 'clean', 'clean-depend', and 'dist-clean' targets as .PHONY targets
since they are targets that do not have resulting files and are never listed
as prerequisites to real targets.  Using .PHONY in this manner improves make
performance by never having to check for resulting files.

------------------------------------------------------------------------
r35416 | russell | 2006-06-22 13:39:25 +0200 (Thu, 22 Jun 2006) | 1 line

nothing to see here ...
------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -13,7 +13,7 @@
 
 .EXPORT_ALL_VARIABLES:
 
-.PHONY: sounds
+.PHONY: sounds clean clean-depend dist-clean
 
 # Create OPTIONS variable
 OPTIONS=

Modified: trunk/agi/Makefile
===================================================================
--- trunk/agi/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/agi/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 AGIS=agi-test.agi eagi-test eagi-sphinx-test jukebox.agi
 
 LIBS=

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/apps/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/build_tools/Makefile
===================================================================
--- trunk/build_tools/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/build_tools/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -1,3 +1,5 @@
+.PHONY: clean dist-clean
+
 MENUSELECT_OBJS=menuselect.o menuselect_curses.o
 MENUSELECT_CFLAGS=-g -c -D_GNU_SOURCE -DMENUSELECT -I../ -I../include/
 MENUSELECT_LIBS=../mxml/libmxml.a

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/cdr/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/channels/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/codecs/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/formats/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/funcs/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/pbx/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/res/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/sounds/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: dist-clean
+
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts
 endif

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-06-28 02:27:01 UTC (rev 405)
+++ trunk/utils/Makefile	2006-06-28 02:28:17 UTC (rev 406)
@@ -11,6 +11,8 @@
 # the GNU General Public License
 #
 
+.PHONY: clean clean-depend
+
 UTILS:=astman smsq stereorize streamplayer aelparse
 
 ifeq (${OSARCH},SunOS)



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:29:41 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:29:41 +0200
Subject: [solid-pbx-svn] r407 - trunk
Message-ID: <200606280229.k5S2TfeL028378@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:29:29 +0200 (Wed, 28 Jun 2006)
New Revision: 407

Modified:
   trunk/Makefile
   trunk/configure.ac
Log:
Update to Asterisk SVN trunk r35443

------------------------------------------------------------------------
r35436 | russell | 2006-06-22 14:14:29 +0200 (Thu, 22 Jun 2006) | 9 lines

instead of using a for loop to call make on each subdirectory, use a target for
each subdirectory.
 - the shell code in the for loop doesn't have a manually catch errors from
   make on a subdirectory
 - you can now run something like "make apps" or "make channels" from the root
   source directory
 - This should allow for better support for parallel instances of make (the -j
   option) since make can work on each subdirectory target in parallel

------------------------------------------------------------------------
r35437 | russell | 2006-06-22 14:33:50 +0200 (Thu, 22 Jun 2006) | 3 lines

instead of using a for loop to call 'make install' on each subdirectory, use
separate targets

------------------------------------------------------------------------
r35438 | russell | 2006-06-22 14:48:25 +0200 (Thu, 22 Jun 2006) | 3 lines

use a slightly different, but equivalent way of setting the 
SUBDIRS_INSTALL variable

------------------------------------------------------------------------
r35439 | russell | 2006-06-22 14:55:49 +0200 (Thu, 22 Jun 2006) | 5 lines

revert my change to use the AC_PREFIX_DEFAULT macro since it is not something
that is expanded inline, so it didn't do what I wanted it to. The --help output
will be wrong again, but that's better than completely breaking it. :)
(Thanks to jcollie for catching this!)

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:28:17 UTC (rev 406)
+++ trunk/Makefile	2006-06-28 02:29:29 UTC (rev 407)
@@ -272,6 +272,7 @@
 MOD_SUBDIRS=res channels pbx apps codecs formats cdr funcs
 OTHER_SUBDIRS=utils agi
 SUBDIRS:=$(MOD_SUBDIRS) $(OTHER_SUBDIRS)
+SUBDIRS_INSTALL:=$(SUBDIRS:%=%-install)
 
 OBJS=io.o sched.o logger.o frame.o loader.o config.o channel.o \
 	translate.o file.o pbx.o cli.o md5.o term.o \
@@ -368,7 +369,7 @@
 	@echo " +               make install                +"  
 	@echo " +-------------------------------------------+"  
 
-all: cleantest config.status menuselect.makeopts depend asterisk subdirs
+all: cleantest config.status menuselect.makeopts depend asterisk $(SUBDIRS)
 
 config.status: configure
 	@CFLAGS="" ./configure
@@ -480,11 +481,12 @@
 muted: muted.o
 	$(CC) $(AUDIO_LIBS) -o muted muted.o
 
-subdirs: 
-	@for x in $(MOD_SUBDIRS); do CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $$x || exit 1 ; done
-	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C utils
-	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C agi
+$(MOD_SUBDIRS): FORCE
+	@CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
 
+$(OTHER_SUBDIRS): FORCE 
+	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
+
 clean-depend:
 	@for x in $(SUBDIRS); do $(MAKE) -C $$x clean-depend || exit 1 ; done
 	rm -f .depend .tags-depend
@@ -586,8 +588,8 @@
 	$(INSTALL) -m 644 contrib/scripts/safe_asterisk.8 $(DESTDIR)$(ASTMANDIR)/man8
 	$(INSTALL) -m 644 contrib/firmware/iax/iaxy.bin $(DESTDIR)$(ASTDATADIR)/firmware/iax/iaxy.bin; \
 
-install-subdirs:
-	@for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
+$(SUBDIRS_INSTALL):
+	@$(MAKE) -C $(@:-install=) install
 
 NEWMODS=$(notdir $(wildcard */*.so))
 OLDMODS=$(filter-out $(NEWMODS),$(notdir $(wildcard $(DESTDIR)$(MODULES_DIR)/*.so)))
@@ -610,7 +612,7 @@
 		echo " WARNING WARNING WARNING" ;\
 	fi
 
-install: all datafiles bininstall install-subdirs
+install: all datafiles bininstall $(SUBDIRS_INSTALL)
 	@if [ -x /usr/sbin/asterisk-post-install ]; then \
 		/usr/sbin/asterisk-post-install $(DESTDIR) . ; \
 	fi

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-28 02:28:17 UTC (rev 406)
+++ trunk/configure.ac	2006-06-28 02:29:29 UTC (rev 407)
@@ -24,10 +24,10 @@
 
 case "${host}" in
      *freebsd*)
-     AC_PREFIX_DEFAULT(/usr/local)
+     ac_default_prefix=/usr/local
      ;;
      *)
-     AC_PREFIX_DEFAULT(/usr)
+     ac_default_prefix=/usr
      if test ${sysconfdir} = '${prefix}/etc'; then
         sysconfdir=/etc
      fi



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:31:02 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:31:02 +0200
Subject: [solid-pbx-svn] r408 - trunk
Message-ID: <200606280231.k5S2V2M0028674@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:30:44 +0200 (Wed, 28 Jun 2006)
New Revision: 408

Modified:
   trunk/Makefile
Log:
Update to Asterisk SVN trunk r35463

------------------------------------------------------------------------
r35459 | russell | 2006-06-22 15:22:07 +0200 (Thu, 22 Jun 2006) | 3 lines

clean up a little mess I created by using the 'or' function instead of gross 
nested if statements

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:29:29 UTC (rev 407)
+++ trunk/Makefile	2006-06-28 02:30:44 UTC (rev 408)
@@ -133,8 +133,7 @@
 MOD_SUBDIR_CFLAGS=-I../include -I..
 OTHER_SUBDIR_CFLAGS=-I../include -I..
 
-ifeq ($(findstring dont-optimize,$(MAKECMDGOALS)),)
-  ifeq ($(findstring DONT_OPTIMIZE,$(MENUSELECT_CFLAGS)),)
+ifeq ($(or $(findstring dont-optimize,$(MAKECMDGOALS)),$(findstring DONT_OPTIMIZE,$(MENUSELECT_CFLAGS))),)
 # More GSM codec optimization
 # Uncomment to enable MMXTM optimizations for x86 architecture CPU's
 # which support MMX instructions.  This should be newer pentiums,
@@ -143,12 +142,6 @@
 
 # Tell gcc to optimize the code
 OPTIMIZE+=-O6
-  else
-    # Stack backtraces, while useful for debugging, are incompatible with optimizations
-    ifeq ($(OSARCH),Linux)
-      CFLAGS+=-DSTACK_BACKTRACES
-    endif
-  endif
 else
   # Stack backtraces, while useful for debugging, are incompatible with optimizations
   ifeq ($(OSARCH),Linux)



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:32:10 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:32:10 +0200
Subject: [solid-pbx-svn] r409 - in trunk: . agi apps build_tools cdr channels codecs formats funcs pbx res sounds utils
Message-ID: <200606280232.k5S2WA8Z028929@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:31:36 +0200 (Wed, 28 Jun 2006)
New Revision: 409

Modified:
   trunk/Makefile
   trunk/agi/Makefile
   trunk/apps/Makefile
   trunk/build_tools/Makefile
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/formats/Makefile
   trunk/funcs/Makefile
   trunk/pbx/Makefile
   trunk/res/Makefile
   trunk/sounds/Makefile
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r35483

------------------------------------------------------------------------
r35479 | russell | 2006-06-22 16:09:18 +0200 (Thu, 22 Jun 2006) | 5 lines

- specify that 'all' is a .PHONY target
- add a copyright header to the build_tools Makefile
- remove 'depend' from the 'all' target in agi/ and utils/ since it is handled
  by the main Makefile already

------------------------------------------------------------------------
r35480 | russell | 2006-06-22 16:16:41 +0200 (Thu, 22 Jun 2006) | 2 lines

get rid of another annoying stray space in the gcc commands

------------------------------------------------------------------------
r35481 | russell | 2006-06-22 16:31:52 +0200 (Thu, 22 Jun 2006) | 3 lines

use separate targets instead of for loops to process sub directories for the
'clean' and 'clean-depend' targets

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -13,7 +13,7 @@
 
 .EXPORT_ALL_VARIABLES:
 
-.PHONY: sounds clean clean-depend dist-clean
+.PHONY: sounds clean clean-depend dist-clean all
 
 # Create OPTIONS variable
 OPTIONS=
@@ -201,7 +201,9 @@
 endif
 
 ASTCFLAGS+=-pipe -Wall -Wstrict-prototypes -Wmissing-prototypes -Wmissing-declarations $(DEBUG)
+ifneq ($(OPTIMIZE),)
 ASTCFLAGS+=$(OPTIMIZE)
+endif
 
 ifeq ($(AST_DEVMODE),yes)
   ASTCFLAGS+=-Werror -Wunused
@@ -266,6 +268,8 @@
 OTHER_SUBDIRS=utils agi
 SUBDIRS:=$(MOD_SUBDIRS) $(OTHER_SUBDIRS)
 SUBDIRS_INSTALL:=$(SUBDIRS:%=%-install)
+SUBDIRS_CLEAN:=$(SUBDIRS:%=%-clean)
+SUBDIRS_CLEAN_DEPEND:=$(SUBDIRS:%=%-clean-depend)
 
 OBJS=io.o sched.o logger.o frame.o loader.o config.o channel.o \
 	translate.o file.o pbx.o cli.o md5.o term.o \
@@ -364,6 +368,12 @@
 
 all: cleantest config.status menuselect.makeopts depend asterisk $(SUBDIRS)
 
+$(MOD_SUBDIRS): FORCE
+	@CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
+
+$(OTHER_SUBDIRS): FORCE 
+	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
+
 config.status: configure
 	@CFLAGS="" ./configure
 	@echo "****"
@@ -474,33 +484,31 @@
 muted: muted.o
 	$(CC) $(AUDIO_LIBS) -o muted muted.o
 
-$(MOD_SUBDIRS): FORCE
-	@CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
+$(SUBDIRS_CLEAN_DEPEND):
+	@$(MAKE) -C $(@:-clean-depend=) clean-depend
 
-$(OTHER_SUBDIRS): FORCE 
-	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
+$(SUBDIRS_CLEAN):
+	@$(MAKE) -C $(@:-clean=) clean
 
-clean-depend:
-	@for x in $(SUBDIRS); do $(MAKE) -C $$x clean-depend || exit 1 ; done
-	rm -f .depend .tags-depend
+clean-depend: $(SUBDIRS_CLEAN_DEPEND)
 
-clean: clean-depend
-	@for x in $(SUBDIRS); do $(MAKE) -C $$x clean || exit 1 ; done
+clean: $(SUBDIRS_CLEAN) clean-depend
 	rm -f *.o *.so asterisk
 	rm -f defaults.h
 	rm -f include/asterisk/build.h
 	rm -f include/asterisk/version.h
 	rm -f .tags-sources tags TAGS
+	rm -f .depend .tags-depend
 	@if [ -f editline/Makefile ]; then $(MAKE) -C editline distclean ; fi
-	$(MAKE) -C db1-ast clean
-	$(MAKE) -C stdtime clean
+	@$(MAKE) -C db1-ast clean
+	@$(MAKE) -C stdtime clean
 
 distclean: dist-clean
 
 dist-clean: clean
-	$(MAKE) -C mxml clean
-	$(MAKE) -C build_tools dist-clean
-	$(MAKE) -C sounds dist-clean
+	@$(MAKE) -C mxml clean
+	@$(MAKE) -C build_tools dist-clean
+	@$(MAKE) -C sounds dist-clean
 	rm -f menuselect.makeopts makeopts makeopts.xml
 	rm -f config.log config.status
 	rm -f include/autoconfig.h

Modified: trunk/agi/Makefile
===================================================================
--- trunk/agi/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/agi/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 AGIS=agi-test.agi eagi-test eagi-sphinx-test jukebox.agi
 
@@ -20,7 +20,7 @@
   LIBS=-lsocket -lnsl ../strcompat.o
 endif
 
-all: depend $(AGIS)
+all: $(AGIS)
 
 install: all
 	mkdir -p $(DESTDIR)$(AGI_DIR)

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/apps/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/build_tools/Makefile
===================================================================
--- trunk/build_tools/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/build_tools/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -1,3 +1,16 @@
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
+# Makefile for Build Tools
+#
+# Copyright (C) 2005-2006, Digium, Inc.
+#
+# Russell Bryant <russell at digium.com>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
 .PHONY: clean dist-clean
 
 MENUSELECT_OBJS=menuselect.o menuselect_curses.o

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/cdr/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/channels/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/codecs/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/formats/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/funcs/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/pbx/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/res/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/sounds/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: dist-clean
+.PHONY: dist-clean all
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-06-28 02:30:44 UTC (rev 408)
+++ trunk/utils/Makefile	2006-06-28 02:31:36 UTC (rev 409)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend
+.PHONY: clean clean-depend all
 
 UTILS:=astman smsq stereorize streamplayer aelparse
 
@@ -32,7 +32,7 @@
   UTILS:=$(filter-out aelparse,$(UTILS))
 endif
 
-all: depend $(UTILS)
+all: $(UTILS)
 
 install:
 	for x in $(UTILS); do \



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:34:54 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:34:54 +0200
Subject: [solid-pbx-svn] r410 - in trunk: . agi apps cdr channels codecs formats funcs pbx res utils
Message-ID: <200606280234.k5S2YskY029990@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:34:47 +0200 (Wed, 28 Jun 2006)
New Revision: 410

Modified:
   trunk/Makefile
   trunk/agi/Makefile
   trunk/apps/Makefile
   trunk/cdr/Makefile
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/formats/Makefile
   trunk/funcs/Makefile
   trunk/manager.c
   trunk/pbx/Makefile
   trunk/res/Makefile
   trunk/utils/Makefile
Log:
Update to Asterisk SVN trunk r35503

------------------------------------------------------------------------
r35501 | russell | 2006-06-22 17:08:08 +0200 (Thu, 22 Jun 2006) | 4 lines

- specify that 'depend' is a .PHONY target
- use separate targets instead of a for loop for doing 'make depend' for
  each sub directory

------------------------------------------------------------------------
r35502 | oej | 2006-06-22 17:34:20 +0200 (Thu, 22 Jun 2006) | 2 lines

Formatting fixes

------------------------------------------------------------------------
r35503 | russell | 2006-06-22 17:38:13 +0200 (Thu, 22 Jun 2006) | 7 lines

- convert the 'uninstall' target to use separate targets to process each
  subdirectory instead of a for loop
- remove the FORCE target from the main Makefile and add the couple places
  I used it to the .PHONY target.  .PHONY does the same thing and is a built-in
  more efficient way of doing it.
- add a bunch more targets to .PHONY ...

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -13,8 +13,6 @@
 
 .EXPORT_ALL_VARIABLES:
 
-.PHONY: sounds clean clean-depend dist-clean all
-
 # Create OPTIONS variable
 OPTIONS=
 
@@ -264,12 +262,16 @@
 
 ASTCFLAGS+=$(MALLOC_DEBUG)$(BUSYDETECT)$(OPTIONS)
 
-MOD_SUBDIRS=res channels pbx apps codecs formats cdr funcs
-OTHER_SUBDIRS=utils agi
+MOD_SUBDIRS:=res channels pbx apps codecs formats cdr funcs
+OTHER_SUBDIRS:=utils agi
 SUBDIRS:=$(MOD_SUBDIRS) $(OTHER_SUBDIRS)
 SUBDIRS_INSTALL:=$(SUBDIRS:%=%-install)
 SUBDIRS_CLEAN:=$(SUBDIRS:%=%-clean)
 SUBDIRS_CLEAN_DEPEND:=$(SUBDIRS:%=%-clean-depend)
+MOD_SUBDIRS_DEPEND:=$(MOD_SUBDIRS:%=%-depend)
+OTHER_SUBDIRS_DEPEND:=$(OTHER_SUBDIRS:%=%-depend)
+SUBDIRS_DEPEND:=$(MOD_SUBDIRS_DEPEND) $(OTHER_SUBDIRS_DEPEND)
+SUBDIRS_UNINSTALL:=$(SUBDIRS:%=%-uninstall)
 
 OBJS=io.o sched.o logger.o frame.o loader.o config.o channel.o \
 	translate.o file.o pbx.o cli.o md5.o term.o \
@@ -368,10 +370,10 @@
 
 all: cleantest config.status menuselect.makeopts depend asterisk $(SUBDIRS)
 
-$(MOD_SUBDIRS): FORCE
+$(MOD_SUBDIRS):
 	@CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
 
-$(OTHER_SUBDIRS): FORCE 
+$(OTHER_SUBDIRS):
 	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $@
 
 config.status: configure
@@ -775,10 +777,14 @@
 
 valgrind: dont-optimize
 
-depend: include/asterisk/version.h include/asterisk/buildopts.h .depend defaults.h 
-	@for x in $(MOD_SUBDIRS); do CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $$x depend || exit 1 ; done
-	@for x in $(OTHER_SUBDIRS); do CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $$x depend || exit 1 ; done
+$(MOD_SUBDIRS_DEPEND):
+	@CFLAGS="$(MOD_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $(@:-depend=) depend
 
+$(OTHER_SUBDIRS_DEPEND):
+	@CFLAGS="$(OTHER_SUBDIR_CFLAGS)$(ASTCFLAGS)" $(MAKE) -C $(@:-depend=) depend
+
+depend: include/asterisk/version.h include/asterisk/buildopts.h .depend defaults.h $(SUBDIRS_DEPEND)
+
 .depend: include/asterisk/version.h include/asterisk/buildopts.h defaults.h
 	build_tools/mkdep $(CFLAGS) $(wildcard *.c)
 
@@ -809,8 +815,6 @@
 
 etags: TAGS
 
-FORCE:
-
 %_env:
 	$(MAKE) -C $(shell echo $@ | sed "s/_env//g") env
 
@@ -830,7 +834,10 @@
 		$(MAKE) defaults.h;\
 	fi
 
-_uninstall:
+$(SUBDIRS_UNINSTALL):
+	@$(MAKE) -C $(@:-uninstall=) uninstall
+
+_uninstall: $(SUBDIRS_UNINSTALL)
 	rm -f $(DESTDIR)$(MODULES_DIR)/*
 	rm -f $(DESTDIR)$(ASTSBINDIR)/*asterisk*
 	rm -f $(DESTDIR)$(ASTSBINDIR)/astgenkey
@@ -838,7 +845,6 @@
 	rm -rf $(DESTDIR)$(ASTHEADERDIR)
 	rm -rf $(DESTDIR)$(ASTDATADIR)/firmware
 	rm -rf $(DESTDIR)$(ASTMANDIR)/man8
-	for x in $(SUBDIRS); do $(MAKE) -C $$x uninstall || exit 1 ; done
 	$(MAKE) -C sounds uninstall
 
 uninstall: _uninstall
@@ -880,3 +886,5 @@
 release:
 	cp -ar . ../solid-pbx-$(ASTERISKVERSION)
 	cd ../solid-pbx-$(ASTERISKVERSION) && rm -rf `ls -Rd .svn */.svn */*/.svn */*/*/.svn */*/*/*/.svn` sounds
+
+.PHONY: sounds clean clean-depend dist-clean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL)

Modified: trunk/agi/Makefile
===================================================================
--- trunk/agi/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/agi/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 AGIS=agi-test.agi eagi-test eagi-sphinx-test jukebox.agi
 

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/apps/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/cdr/Makefile
===================================================================
--- trunk/cdr/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/cdr/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/channels/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/codecs/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/formats/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/funcs/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/manager.c
===================================================================
--- trunk/manager.c	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/manager.c	2006-06-28 02:34:47 UTC (rev 410)
@@ -173,7 +173,7 @@
 static struct manager_action *first_action = NULL;
 AST_MUTEX_DEFINE_STATIC(actionlock);
 
-/*! authority_to_str: Convert authority code to string with serveral options */
+/*! \brief Convert authority code to string with serveral options */
 static char *authority_to_str(int authority, char *res, int reslen)
 {
 	int running_total = 0, i;
@@ -422,8 +422,8 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  handle_showmancmds: CLI command */
-/* Should change to "manager show commands" */
+/*! \brief  CLI command 
+	Should change to "manager show commands" */
 static int handle_showmancmds(int fd, int argc, char *argv[])
 {
 	struct manager_action *cur = first_action;
@@ -442,7 +442,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  handle_showmanconn: CLI command show manager connected */
+/*! \brief CLI command show manager connected */
 /* Should change to "manager show connected" */
 static int handle_showmanconn(int fd, int argc, char *argv[])
 {
@@ -461,7 +461,7 @@
 	return RESULT_SUCCESS;
 }
 
-/*! \brief  handle_showmanconn: CLI command show manager connected */
+/*! \brief CLI command show manager connected */
 /* Should change to "manager show connected" */
 static int handle_showmaneventq(int fd, int argc, char *argv[])
 {
@@ -617,7 +617,7 @@
 	return head;
 }
 
-/*! NOTE:
+/*! \note NOTE:
    Callers of astman_send_error(), astman_send_response() or astman_send_ack() must EITHER
    hold the session lock _or_ be running in an action callback (in which case s->busy will
    be non-zero). In either of these cases, there is no need to lock-protect the session's
@@ -734,11 +734,10 @@
 	return ret;
 }
 
-/*! 
+/*! \brief
    Rather than braindead on,off this now can also accept a specific int mask value 
    or a ',' delim list of mask strings (the same as manager.conf) -anthm
 */
-
 static int set_eventmask(struct mansession *s, char *eventmask)
 {
 	int maskint = ast_strings_to_mask(eventmask);
@@ -851,7 +850,7 @@
 	return -1;
 }
 
-/*! \brief PING: Manager PING */
+/*! \brief Manager PING */
 static char mandescr_ping[] = 
 "Description: A 'Ping' action will ellicit a 'Pong' response.  Used to keep the\n"
 "  manager connection open.\n"
@@ -863,7 +862,7 @@
 	return 0;
 }
 
-/*! \brief WAITEVENT: Manager WAITEVENT */
+/*! \brief Manager WAITEVENT */
 static char mandescr_waitevent[] = 
 "Description: A 'WaitEvent' action will ellicit a 'Success' response.  Whenever\n"
 "a manager event is queued.  Once WaitEvent has been called on an HTTP manager\n"
@@ -1127,7 +1126,7 @@
 }
 
 
-/*! \brief  action_status: Manager "status" command to show channels */
+/*! \brief Manager "status" command to show channels */
 /* Needs documentation... */
 static int action_status(struct mansession *s, struct message *m)
 {
@@ -1469,7 +1468,7 @@
 	return 0;
 }
 
-/*! 	\brief Help text for manager command mailboxstatus
+/*! \brief Help text for manager command mailboxstatus
  */
 static char mandescr_mailboxstatus[] = 
 "Description: Checks a voicemail account for status.\n"
@@ -2446,9 +2445,8 @@
 		httptimeout = newhttptimeout;
 
 	/* If not enabled, do nothing */
-	if (!enabled) {
+	if (!enabled)
 		return 0;
-	}
 
 	if (asock < 0) {
 		asock = socket(AF_INET, SOCK_STREAM, 0);

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/pbx/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/res/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts

Modified: trunk/utils/Makefile
===================================================================
--- trunk/utils/Makefile	2006-06-28 02:31:36 UTC (rev 409)
+++ trunk/utils/Makefile	2006-06-28 02:34:47 UTC (rev 410)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: clean clean-depend all
+.PHONY: clean clean-depend all depend uninstall
 
 UTILS:=astman smsq stereorize streamplayer aelparse
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:36:44 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:36:44 +0200
Subject: [solid-pbx-svn] r411 - in trunk: . apps configs sounds
Message-ID: <200606280236.k5S2aiit030401@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:36:37 +0200 (Wed, 28 Jun 2006)
New Revision: 411

Modified:
   trunk/Makefile
   trunk/apps/app_queue.c
   trunk/configs/queues.conf.sample
   trunk/sounds/Makefile
Log:
Update to Asterisk SVN trunk r35513

------------------------------------------------------------------------
r35504 | tilghman | 2006-06-22 17:43:02 +0200 (Thu, 22 Jun 2006) | 2 lines

Bug 6589 - option to display channel variables in queue events

------------------------------------------------------------------------
r35506 | russell | 2006-06-22 17:45:32 +0200 (Thu, 22 Jun 2006) | 2 lines

add a couple more targets to .PHONY

------------------------------------------------------------------------
r35510 | russell | 2006-06-22 17:55:13 +0200 (Thu, 22 Jun 2006) | 2 lines

use .PHONY instead of FORCE

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:34:47 UTC (rev 410)
+++ trunk/Makefile	2006-06-28 02:36:37 UTC (rev 411)
@@ -887,4 +887,4 @@
 	cp -ar . ../solid-pbx-$(ASTERISKVERSION)
 	cd ../solid-pbx-$(ASTERISKVERSION) && rm -rf `ls -Rd .svn */.svn */*/.svn */*/*/.svn */*/*/*/.svn` sounds
 
-.PHONY: sounds clean clean-depend dist-clean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL)
+.PHONY: sounds clean clean-depend dist-clean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL) sounds

Modified: trunk/apps/app_queue.c
===================================================================
--- trunk/apps/app_queue.c	2006-06-28 02:34:47 UTC (rev 410)
+++ trunk/apps/app_queue.c	2006-06-28 02:36:37 UTC (rev 411)
@@ -334,6 +334,7 @@
 #define QUEUE_EMPTY_STRICT 2
 #define ANNOUNCEHOLDTIME_ALWAYS 1
 #define ANNOUNCEHOLDTIME_ONCE 2
+#define QUEUE_EVENT_VARIABLES 3
 
 struct call_queue {
 	ast_mutex_t lock;	
@@ -344,7 +345,7 @@
 	unsigned int monjoin:1;
 	unsigned int dead:1;
 	unsigned int joinempty:2;
-	unsigned int eventwhencalled:1;
+	unsigned int eventwhencalled:2;
 	unsigned int leavewhenempty:2;
 	unsigned int ringinuse:1;
 	unsigned int setinterfacevar:1;
@@ -878,7 +879,11 @@
 	} else if (!strcasecmp(param, "eventmemberstatus")) {
 		q->maskmemberstatus = !ast_true(val);
 	} else if (!strcasecmp(param, "eventwhencalled")) {
-		q->eventwhencalled = ast_true(val);
+		if (strcasecmp(val, "vars")) {
+			q->eventwhencalled = QUEUE_EVENT_VARIABLES;
+		} else {
+			q->eventwhencalled = ast_true(val);
+		}
 	} else if (!strcasecmp(param, "reportholdtime")) {
 		q->reportholdtime = ast_true(val);
 	} else if (!strcasecmp(param, "memberdelay")) {
@@ -1502,6 +1507,41 @@
 	o->chan = NULL;
 }
 
+static char *vars2manager(struct ast_channel *chan, char *vars, size_t len)
+{
+	char *tmp = alloca(len);
+
+	if (pbx_builtin_serialize_variables(chan, tmp, len)) {
+		int i, j;
+
+		/* convert "\n" to "\nVariable: " */
+		strcpy(vars, "Variable: ");
+
+		for (i = 0, j = 10; (i < len - 1) && (j < len - 1); i++, j++) {
+			vars[j] = tmp[i];
+
+			if (tmp[i + 1] == '\0')
+				break;
+			if (tmp[i] == '\n') {
+				vars[j] = '\r';
+				vars[++j] = '\n';
+
+				ast_copy_string(&(vars[j]), "Variable: ", len - j);
+				j += 9;
+			}
+		}
+		if (j > len - 1)
+			j = len - 1;
+		vars[j - 2] = '\r';
+		vars[j - 1] = '\n';
+		vars[j] = '\0';
+	} else {
+		/* there are no channel variables; leave it blank */
+		*vars = '\0';
+	}
+	return vars;
+}
+
 static int ring_entry(struct queue_ent *qe, struct callattempt *tmp, int *busies)
 {
 	int res;
@@ -1593,21 +1633,23 @@
 		do_hang(tmp);
 		(*busies)++;
 		return 0;
-	} else {
-		if (qe->parent->eventwhencalled) {
-			manager_event(EVENT_FLAG_AGENT, "AgentCalled",
-						"AgentCalled: %s\r\n"
-						"ChannelCalling: %s\r\n"
-						"CallerID: %s\r\n"
-						"CallerIDName: %s\r\n"
-						"Context: %s\r\n"
-						"Extension: %s\r\n"
-						"Priority: %d\r\n",
-						tmp->interface, qe->chan->name,
-						S_OR(tmp->chan->cid.cid_num, "unknown"),
-						S_OR(tmp->chan->cid.cid_name, "unknown"),
-						qe->chan->context, qe->chan->exten, qe->chan->priority);
-		}
+	} else if (qe->parent->eventwhencalled) {
+		char vars[2048];
+
+		manager_event(EVENT_FLAG_AGENT, "AgentCalled",
+					"AgentCalled: %s\r\n"
+					"ChannelCalling: %s\r\n"
+					"CallerID: %s\r\n"
+					"CallerIDName: %s\r\n"
+					"Context: %s\r\n"
+					"Extension: %s\r\n"
+					"Priority: %d\r\n"
+					"%s",
+					tmp->interface, qe->chan->name,
+					tmp->chan->cid.cid_num ? tmp->chan->cid.cid_num : "unknown",
+					tmp->chan->cid.cid_name ? tmp->chan->cid.cid_name : "unknown",
+					qe->chan->context, qe->chan->exten, qe->chan->priority,
+					qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "Called %s\n", tmp->interface);
 	}
@@ -2237,6 +2279,7 @@
 	char mixmonargs[1512];
 	struct ast_app *mixmonapp = NULL;
 	char *p;
+	char vars[2048];
 
 	memset(&bridge_config, 0, sizeof(bridge_config));
 	time(&now);
@@ -2385,14 +2428,15 @@
 				ast_log(LOG_WARNING, "Agent on %s hungup on the customer.  They're going to be pissed.\n", peer->name);
 				ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "AGENTDUMP", "%s", "");
 				record_abandoned(qe);
-				if (qe->parent->eventwhencalled) {
+				if (qe->parent->eventwhencalled)
 					manager_event(EVENT_FLAG_AGENT, "AgentDump",
-						      "Queue: %s\r\n"
-						      "Uniqueid: %s\r\n"
-						      "Channel: %s\r\n"
-						      "Member: %s\r\n",
-						      queuename, qe->chan->uniqueid, peer->name, member->interface);
-				}
+							"Queue: %s\r\n"
+							"Uniqueid: %s\r\n"
+							"Channel: %s\r\n"
+							"Member: %s\r\n"
+							"%s",
+							queuename, qe->chan->uniqueid, peer->name, member->interface,
+							qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 				ast_hangup(peer);
 				goto out;
 			} else if (res2) {
@@ -2530,14 +2574,16 @@
 		ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "CONNECT", "%ld|%s", (long)time(NULL) - qe->start, peer->uniqueid);
 		if (qe->parent->eventwhencalled)
 			manager_event(EVENT_FLAG_AGENT, "AgentConnect",
-				      "Queue: %s\r\n"
-				      "Uniqueid: %s\r\n"
-				      "Channel: %s\r\n"
-				      "Member: %s\r\n"
-				      "Holdtime: %ld\r\n"
-				      "BridgedChannel: %s\r\n",
-				      queuename, qe->chan->uniqueid, peer->name, member->interface,
-				      (long) time(NULL) - qe->start,peer->uniqueid);
+					"Queue: %s\r\n"
+					"Uniqueid: %s\r\n"
+					"Channel: %s\r\n"
+					"Member: %s\r\n"
+					"Holdtime: %ld\r\n"
+					"BridgedChannel: %s\r\n"
+					"%s",
+					queuename, qe->chan->uniqueid, peer->name, member->interface,
+					(long)time(NULL) - qe->start, peer->uniqueid,
+					qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		ast_copy_string(oldcontext, qe->chan->context, sizeof(oldcontext));
 		ast_copy_string(oldexten, qe->chan->exten, sizeof(oldexten));
 		time(&callstart);
@@ -2553,28 +2599,32 @@
 				      (long) (callstart - qe->start), (long) (time(NULL) - callstart));
 			if (qe->parent->eventwhencalled)
 				manager_event(EVENT_FLAG_AGENT, "AgentComplete",
-					      "Queue: %s\r\n"
-					      "Uniqueid: %s\r\n"
-					      "Channel: %s\r\n"
-					      "Member: %s\r\n"
-					      "HoldTime: %ld\r\n"
-					      "TalkTime: %ld\r\n"
-					      "Reason: caller\r\n",
-					      queuename, qe->chan->uniqueid, peer->name, member->interface,
-					      (long) (callstart - qe->start), (long) (time(NULL) - callstart));
+						"Queue: %s\r\n"
+						"Uniqueid: %s\r\n"
+						"Channel: %s\r\n"
+						"Member: %s\r\n"
+						"HoldTime: %ld\r\n"
+						"TalkTime: %ld\r\n"
+						"Reason: caller\r\n"
+						"%s",
+						queuename, qe->chan->uniqueid, peer->name, member->interface,
+						(long)(callstart - qe->start), (long)(time(NULL) - callstart),
+						qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		} else {
 			ast_queue_log(queuename, qe->chan->uniqueid, peer->name, "COMPLETEAGENT", "%ld|%ld",
 				      (long) (callstart - qe->start), (long) (time(NULL) - callstart));
 			if (qe->parent->eventwhencalled)
 				manager_event(EVENT_FLAG_AGENT, "AgentComplete",
-					      "Queue: %s\r\n"
-					      "Uniqueid: %s\r\n"
-					      "Channel: %s\r\n"
-					      "HoldTime: %ld\r\n"
-					      "TalkTime: %ld\r\n"
-					      "Reason: agent\r\n",
-					      queuename, qe->chan->uniqueid, peer->name, (long)(callstart - qe->start),
-					      (long) (time(NULL) - callstart));
+						"Queue: %s\r\n"
+						"Uniqueid: %s\r\n"
+						"Channel: %s\r\n"
+						"HoldTime: %ld\r\n"
+						"TalkTime: %ld\r\n"
+						"Reason: agent\r\n"
+						"%s",
+						queuename, qe->chan->uniqueid, peer->name, (long)(callstart - qe->start),
+						(long)(time(NULL) - callstart),
+						qe->parent->eventwhencalled == QUEUE_EVENT_VARIABLES ? vars2manager(qe->chan, vars, sizeof(vars)) : "");
 		}
 
 		if (bridge != AST_PBX_NO_HANGUP_PEER)

Modified: trunk/configs/queues.conf.sample
===================================================================
--- trunk/configs/queues.conf.sample	2006-06-28 02:34:47 UTC (rev 410)
+++ trunk/configs/queues.conf.sample	2006-06-28 02:36:37 UTC (rev 411)
@@ -250,10 +250,11 @@
 ;
 ;
 ; If this is set to yes, the following manager events will be generated:
-; AgentCalled, AgentDump, AgentConnect, AgentComplete
+; AgentCalled, AgentDump, AgentConnect, AgentComplete; setting this to
+; vars also sends all channel variables with the event.
 ; (may generate some extra manager events, but probably ones you want)
 ;
-; eventwhencalled = yes
+; eventwhencalled = yes|no|vars
 ;
 ; If this is set to no, the following manager events will be generated:
 ; QueueMemberStatus

Modified: trunk/sounds/Makefile
===================================================================
--- trunk/sounds/Makefile	2006-06-28 02:34:47 UTC (rev 410)
+++ trunk/sounds/Makefile	2006-06-28 02:36:37 UTC (rev 411)
@@ -11,7 +11,7 @@
 # the GNU General Public License
 #
 
-.PHONY: dist-clean all
+.PHONY: dist-clean all uninstall
 
 ifneq ($(wildcard ../menuselect.makeopts),)
   include ../menuselect.makeopts



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:37:33 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:37:33 +0200
Subject: [solid-pbx-svn] r412 - trunk
Message-ID: <200606280237.k5S2bXJ4030520@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:37:21 +0200 (Wed, 28 Jun 2006)
New Revision: 412

Modified:
   trunk/Makefile
Log:
Update to Asterisk SVN trunk r35533

------------------------------------------------------------------------
r35533 | russell | 2006-06-22 18:26:09 +0200 (Thu, 22 Jun 2006) | 2 lines

actually allow all of the sub directories to be built when running "make", oops

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:36:37 UTC (rev 411)
+++ trunk/Makefile	2006-06-28 02:37:21 UTC (rev 412)
@@ -887,4 +887,4 @@
 	cp -ar . ../solid-pbx-$(ASTERISKVERSION)
 	cd ../solid-pbx-$(ASTERISKVERSION) && rm -rf `ls -Rd .svn */.svn */*/.svn */*/*/.svn */*/*/*/.svn` sounds
 
-.PHONY: sounds clean clean-depend dist-clean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL) sounds
+.PHONY: sounds clean clean-depend dist-clean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL) $(SUBDIRS)



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:39:23 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:39:23 +0200
Subject: [solid-pbx-svn] r413 - in trunk: . channels include/asterisk
Message-ID: <200606280239.k5S2dNqj031235@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:39:13 +0200 (Wed, 28 Jun 2006)
New Revision: 413

Modified:
   trunk/abstract_jb.c
   trunk/channels/chan_alsa.c
   trunk/channels/chan_jingle.c
   trunk/channels/chan_mgcp.c
   trunk/channels/chan_oss.c
   trunk/channels/chan_sip.c
   trunk/channels/chan_skinny.c
   trunk/channels/chan_zap.c
   trunk/include/asterisk/abstract_jb.h
   trunk/include/asterisk/channel.h
Log:
Update to Asterisk SVN trunk r35553

------------------------------------------------------------------------
r35553 | russell | 2006-06-22 19:05:17 +0200 (Thu, 22 Jun 2006) | 14 lines

- dynamically allocate the ast_jb structure that is on the channel structure
  so that channels not using a jitterbuffer don't waste as much memory
- ensure that the channel drivers that use jitterbuffers can handle a failure
  from configuring a jitterbuffer on a new channel because of a memory
  allocation error
- On passing through these channel drivers, configure the jitterbuffer before
  starting the PBX thread instead of afterwards. If the pbx fails to start for
  whatever reason, this would have caused a crash.
- Also on passing, move the increase of the usecount to after all of the
  possible failure conditions in the function
- fix a place where ast_update_use_count() was not called
- ensure that the owner channel pointer of the channel pvt strcutures is set to
  NULL in failure conditions

------------------------------------------------------------------------


Modified: trunk/abstract_jb.c
===================================================================
--- trunk/abstract_jb.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/abstract_jb.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -176,7 +176,7 @@
 
 static void jb_choose_impl(struct ast_channel *chan)
 {
-	struct ast_jb *jb = &chan->jb;
+	struct ast_jb *jb = chan->jb;
 	struct ast_jb_conf *jbconf = &jb->conf;
 	struct ast_jb_impl *test_impl;
 	int i, avail_impl_count = sizeof(avail_impl) / sizeof(avail_impl[0]);
@@ -197,8 +197,8 @@
 
 int ast_jb_do_usecheck(struct ast_channel *c0, struct ast_channel *c1)
 {
-	struct ast_jb *jb0 = &c0->jb;
-	struct ast_jb *jb1 = &c1->jb;
+	struct ast_jb *jb0 = c0->jb;
+	struct ast_jb *jb1 = c1->jb;
 	struct ast_jb_conf *conf0 = &jb0->conf;
 	struct ast_jb_conf *conf1 = &jb1->conf;
 	int c0_wants_jitter = c0->tech->properties & AST_CHAN_TP_WANTSJITTER;
@@ -258,8 +258,8 @@
 
 int ast_jb_get_when_to_wakeup(struct ast_channel *c0, struct ast_channel *c1, int time_left)
 {
-	struct ast_jb *jb0 = &c0->jb;
-	struct ast_jb *jb1 = &c1->jb;
+	struct ast_jb *jb0 = c0->jb;
+	struct ast_jb *jb1 = c1->jb;
 	int c0_use_jb = ast_test_flag(jb0, JB_USE);
 	int c0_jb_is_created = ast_test_flag(jb0, JB_CREATED);
 	int c1_use_jb = ast_test_flag(jb1, JB_USE);
@@ -298,7 +298,7 @@
 
 int ast_jb_put(struct ast_channel *chan, struct ast_frame *f)
 {
-	struct ast_jb *jb = &chan->jb;
+	struct ast_jb *jb = chan->jb;
 	struct ast_jb_impl *jbimpl = jb->impl;
 	void *jbobj = jb->jbobj;
 	struct ast_frame *frr;
@@ -366,8 +366,8 @@
 
 void ast_jb_get_and_deliver(struct ast_channel *c0, struct ast_channel *c1)
 {
-	struct ast_jb *jb0 = &c0->jb;
-	struct ast_jb *jb1 = &c1->jb;
+	struct ast_jb *jb0 = c0->jb;
+	struct ast_jb *jb1 = c1->jb;
 	int c0_use_jb = ast_test_flag(jb0, JB_USE);
 	int c0_jb_is_created = ast_test_flag(jb0, JB_CREATED);
 	int c1_use_jb = ast_test_flag(jb1, JB_USE);
@@ -383,7 +383,7 @@
 
 static void jb_get_and_deliver(struct ast_channel *chan)
 {
-	struct ast_jb *jb = &chan->jb;
+	struct ast_jb *jb = chan->jb;
 	struct ast_jb_impl *jbimpl = jb->impl;
 	void *jbobj = jb->jbobj;
 	struct ast_frame *f, finterp;
@@ -447,7 +447,7 @@
 
 static int create_jb(struct ast_channel *chan, struct ast_frame *frr)
 {
-	struct ast_jb *jb = &chan->jb;
+	struct ast_jb *jb = chan->jb;
 	struct ast_jb_conf *jbconf = &jb->conf;
 	struct ast_jb_impl *jbimpl = jb->impl;
 	void *jbobj;
@@ -527,7 +527,7 @@
 
 void ast_jb_destroy(struct ast_channel *chan)
 {
-	struct ast_jb *jb = &chan->jb;
+	struct ast_jb *jb = chan->jb;
 	struct ast_jb_impl *jbimpl = jb->impl;
 	void *jbobj = jb->jbobj;
 	struct ast_frame *f;
@@ -551,6 +551,8 @@
 		if (option_verbose > 2)
 			ast_verbose(VERBOSE_PREFIX_3 "%s jitterbuffer destroyed on channel %s\n", jbimpl->name, chan->name);
 	}
+
+	free(jb);
 }
 
 
@@ -601,15 +603,25 @@
 }
 
 
-void ast_jb_configure(struct ast_channel *chan, const struct ast_jb_conf *conf)
+int ast_jb_configure(struct ast_channel *chan, const struct ast_jb_conf *conf)
 {
-	memcpy(&chan->jb.conf, conf, sizeof(*conf));
+	if (!(chan->jb = ast_calloc(1, sizeof(*chan->jb))))
+		return -1;
+
+	memcpy(&chan->jb->conf, conf, sizeof(*conf));
+
+	return 0;
 }
 
 
-void ast_jb_get_config(const struct ast_channel *chan, struct ast_jb_conf *conf)
+int ast_jb_get_config(const struct ast_channel *chan, struct ast_jb_conf *conf)
 {
-	memcpy(conf, &chan->jb.conf, sizeof(*conf));
+	if (!chan->jb)
+		return -1;
+
+	memcpy(conf, &chan->jb->conf, sizeof(*conf));
+
+	return 0;
 }
 
 

Modified: trunk/channels/chan_alsa.c
===================================================================
--- trunk/channels/chan_alsa.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_alsa.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -816,19 +816,23 @@
 			ast_string_field_set(tmp, language, language);
 		p->owner = tmp;
 		ast_setstate(tmp, state);
-		ast_mutex_lock(&usecnt_lock);
-		usecnt++;
-		ast_mutex_unlock(&usecnt_lock);
-		ast_update_use_count();
+		if (ast_jb_configure(tmp, &global_jbconf)) {
+			ast_hangup(tmp);
+			p->owner = NULL;
+			return NULL;
+		}
 		if (state != AST_STATE_DOWN) {
 			if (ast_pbx_start(tmp)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 				ast_hangup(tmp);
-				tmp = NULL;
+				p->owner = NULL;
+				return NULL;
 			}
 		}
-		if (tmp)
-			ast_jb_configure(tmp, &global_jbconf);
+		ast_mutex_lock(&usecnt_lock);
+		usecnt++;
+		ast_mutex_unlock(&usecnt_lock);
+		ast_update_use_count();
 	}
 	return tmp;
 }

Modified: trunk/channels/chan_jingle.c
===================================================================
--- trunk/channels/chan_jingle.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_jingle.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -756,9 +756,6 @@
 	if (!ast_strlen_zero(client->musicclass))
 		ast_string_field_set(tmp, musicclass, client->musicclass);
 	i->owner = tmp;
-	ast_mutex_lock(&usecnt_lock);
-	usecnt++;
-	ast_mutex_unlock(&usecnt_lock);
 	ast_copy_string(tmp->context, client->context, sizeof(tmp->context));
 	ast_copy_string(tmp->exten, i->exten, sizeof(tmp->exten));
 	if (!ast_strlen_zero(i->cid_num))
@@ -769,16 +766,26 @@
 		tmp->cid.cid_dnid = ast_strdup(i->exten);
 	tmp->priority = 1;
 	ast_setstate(tmp, state);
+	/* Configure the new channel jb */
+	if (i->rtp) {
+		if (ast_jb_configure(tmp, &global_jbconf)) {
+			ast_hangup(tmp);
+			i->owner = NULL;
+			return NULL;
+		}
+	}
 	if (state != AST_STATE_DOWN && ast_pbx_start(tmp)) {
 		ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 		tmp->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
 		ast_hangup(tmp);
-		tmp = NULL;
+		i->owner = NULL;
+		return NULL;
 	}
 
-	/* Configure the new channel jb */
-	if (tmp && i && i->rtp)
-		ast_jb_configure(tmp, &global_jbconf);
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
+	ast_update_use_count();
 
 	return tmp;
 }

Modified: trunk/channels/chan_mgcp.c
===================================================================
--- trunk/channels/chan_mgcp.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_mgcp.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -1482,8 +1482,6 @@
 		if (i->amaflags)
 			tmp->amaflags = i->amaflags;
 		sub->owner = tmp;
-		ast_atomic_fetchadd_int(&__mod_desc->usecnt, +1);
-		ast_update_use_count();
 		tmp->callgroup = i->callgroup;
 		tmp->pickupgroup = i->pickupgroup;
 		ast_string_field_set(tmp, call_forward, i->call_forward);
@@ -1494,22 +1492,28 @@
 		if (!i->adsi)
 			tmp->adsicpe = AST_ADSI_UNAVAILABLE;
 		tmp->priority = 1;
+		/* Configure the new channel jb */
+		if (sub->rtp) {
+			if (ast_jb_configure(tmp, &global_jbconf)) {
+				ast_hangup(tmp);
+				sub->owner = NULL;
+				return NULL;
+			}
+		}
 		if (state != AST_STATE_DOWN) {
 			if (ast_pbx_start(tmp)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 				ast_hangup(tmp);
-				tmp = NULL;
+				sub->owner = NULL;
+				return NULL;
 			}
 		}
-		/* SC: verbose level check */
 		if (option_verbose > 2) {
 			ast_verbose(VERBOSE_PREFIX_3 "MGCP mgcp_new(%s) created in state: %s\n",
 				tmp->name, ast_state2str(state));
 		}
-
-		/* Configure the new channel jb */
-		if (tmp && sub && sub->rtp)
-			ast_jb_configure(tmp, &global_jbconf);
+		ast_atomic_fetchadd_int(&__mod_desc->usecnt, +1);
+		ast_update_use_count();
 	} else {
 		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
 	}

Modified: trunk/channels/chan_oss.c
===================================================================
--- trunk/channels/chan_oss.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_oss.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -1005,22 +1005,25 @@
 
 	o->owner = c;
 	ast_setstate(c, state);
-	ast_mutex_lock(&usecnt_lock);
-	usecnt++;
-	ast_mutex_unlock(&usecnt_lock);
-	ast_update_use_count();
+	if (ast_jb_configure(c, &global_jbconf)) {
+		ast_hangup(c);
+		o->owner = NULL;
+		return NULL;
+	}
 	if (state != AST_STATE_DOWN) {
 		if (ast_pbx_start(c)) {
 			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", c->name);
 			ast_hangup(c);
-			o->owner = c = NULL;
-			/* XXX what about the channel itself ? */
-			/* XXX what about usecnt ? */
+			o->owner = NULL;
+			return NULL;
 		}
 	}
-	if (c)
-		ast_jb_configure(c, &global_jbconf);
 
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
+	ast_update_use_count();
+
 	return c;
 }
 

Modified: trunk/channels/chan_sip.c
===================================================================
--- trunk/channels/chan_sip.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_sip.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -3652,9 +3652,6 @@
 	if (!ast_strlen_zero(i->musicclass))
 		ast_string_field_set(tmp, musicclass, i->musicclass);
 	i->owner = tmp;
-	ast_mutex_lock(&usecnt_lock);
-	usecnt++;
-	ast_mutex_unlock(&usecnt_lock);
 	ast_copy_string(tmp->context, i->context, sizeof(tmp->context));
 	ast_copy_string(tmp->exten, i->exten, sizeof(tmp->exten));
 	if (!ast_strlen_zero(i->cid_num)) 
@@ -3675,11 +3672,20 @@
 	if (!ast_strlen_zero(i->callid))
 		pbx_builtin_setvar_helper(tmp, "SIPCALLID", i->callid);
 	ast_setstate(tmp, state);
+	/* Configure the new channel jb */
+	if (i->rtp) {
+		if (ast_jb_configure(tmp, &global_jbconf)) {
+			ast_hangup(tmp);
+			i->owner = NULL;
+			return NULL;
+		}
+	}
 	if (state != AST_STATE_DOWN && ast_pbx_start(tmp)) {
 		ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 		tmp->hangupcause = AST_CAUSE_SWITCH_CONGESTION;
 		ast_hangup(tmp);
-		tmp = NULL;
+		i->owner = NULL;
+		return NULL;
 	}
 	/* Set channel variables for this call from configuration */
 	for (v = i->chanvars ; v ; v = v->next)
@@ -3688,9 +3694,9 @@
 	if (recordhistory)
 		append_history(i, "NewChan", "Channel %s - from %s", tmp->name, i->callid);
 
-	/* Configure the new channel jb */
-	if (tmp && i && i->rtp)
-		ast_jb_configure(tmp, &global_jbconf);
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
 
 	return tmp;
 }

Modified: trunk/channels/chan_skinny.c
===================================================================
--- trunk/channels/chan_skinny.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_skinny.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -2520,10 +2520,6 @@
 		if (l->amaflags)
 			tmp->amaflags = l->amaflags;
 
-		ast_mutex_lock(&usecnt_lock);
-		usecnt++;
-		ast_mutex_unlock(&usecnt_lock);
-		ast_update_use_count();
 		tmp->callgroup = l->callgroup;
 		tmp->pickupgroup = l->pickupgroup;
 		ast_string_field_set(tmp, call_forward, l->call_forward);
@@ -2534,18 +2530,29 @@
 		tmp->priority = 1;
 		tmp->adsicpe = AST_ADSI_UNAVAILABLE;
 
+		/* Configure the new channel jb */
+		if (sub->rtp) {
+			if (ast_jb_configure(tmp, &global_jbconf)) {
+				ast_hangup(tmp);
+				sub->owner = NULL;
+				return NULL;
+			}
+		}
 		if (state != AST_STATE_DOWN) {
 			if (ast_pbx_start(tmp)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 				ast_hangup(tmp);
-				tmp = NULL;
+				sub->owner = NULL;
+				return NULL;
 			}
 		}
+	}
 
-		/* Configure the new channel jb */
-		if (tmp && sub->rtp)
-			ast_jb_configure(tmp, &global_jbconf);
-	}
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
+	ast_update_use_count();
+
 	return tmp;
 }
 

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/channels/chan_zap.c	2006-06-28 02:39:13 UTC (rev 413)
@@ -5192,22 +5192,28 @@
 		/* Assure there is no confmute on this channel */
 		zt_confmute(i, 0);
 		ast_setstate(tmp, state);
-		ast_mutex_lock(&usecnt_lock);
-		usecnt++;
-		ast_mutex_unlock(&usecnt_lock);
-		ast_update_use_count();
+		/* Configure the new channel jb */
+		if (ast_jb_configure(tmp, &global_jbconf)) {
+			ast_hangup(tmp);
+			i->owner = NULL;
+			return NULL;
+		}
 		if (startpbx) {
 			if (ast_pbx_start(tmp)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 				ast_hangup(tmp);
-				tmp = NULL;
+				i->owner = NULL;
+				return NULL;
 			}
 		}
 	} else
 		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
-	/* Configure the new channel jb */
-	if (tmp && i)
-		ast_jb_configure(tmp, &global_jbconf);
+
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
+	ast_update_use_count();
+	
 	return tmp;
 }
 

Modified: trunk/include/asterisk/abstract_jb.h
===================================================================
--- trunk/include/asterisk/abstract_jb.h	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/include/asterisk/abstract_jb.h	2006-06-28 02:39:13 UTC (rev 413)
@@ -202,16 +202,22 @@
  *
  * Called from a channel driver when a channel is created and its jitterbuffer needs
  * to be configured.
+ *
+ * \retval 0 success
+ * \retval -1 failure
  */
-void ast_jb_configure(struct ast_channel *chan, const struct ast_jb_conf *conf);
+int ast_jb_configure(struct ast_channel *chan, const struct ast_jb_conf *conf);
 
 
 /*!
  * \brief Copies a channel's jitterbuffer configuration.
  * \param chan channel.
  * \param conf destination.
+ *
+ * \retval 0 success
+ * \retval -1 failure
  */
-void ast_jb_get_config(const struct ast_channel *chan, struct ast_jb_conf *conf);
+int ast_jb_get_config(const struct ast_channel *chan, struct ast_jb_conf *conf);
 
 
 #if defined(__cplusplus) || defined(c_plusplus)

Modified: trunk/include/asterisk/channel.h
===================================================================
--- trunk/include/asterisk/channel.h	2006-06-28 02:37:21 UTC (rev 412)
+++ trunk/include/asterisk/channel.h	2006-06-28 02:39:13 UTC (rev 413)
@@ -383,7 +383,7 @@
 
 	struct ast_channel_spy_list *spies;		/*!< Chan Spy stuff */
 	AST_LIST_ENTRY(ast_channel) chan_list;		/*!< For easy linking */
-	struct ast_jb jb;				/*!< The jitterbuffer state  */
+	struct ast_jb *jb;				/*!< The jitterbuffer state  */
 
 	/*! \brief Data stores on the channel */
 	AST_LIST_HEAD_NOLOCK(datastores, ast_datastore) datastores;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:40:20 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:40:20 +0200
Subject: [solid-pbx-svn] r414 - in trunk: . channels
Message-ID: <200606280240.k5S2eK2R031379@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:39:58 +0200 (Wed, 28 Jun 2006)
New Revision: 414

Modified:
   trunk/channel.c
   trunk/channels/chan_iax2.c
Log:
Update to Asterisk SVN trunk r35563

------------------------------------------------------------------------
r35554 | russell | 2006-06-22 19:10:16 +0200 (Thu, 22 Jun 2006) | 7 lines

- move the increase of the use count to be after the possible failures
- if the pbx fails to start, set the owner channel of the pvt strucutre
  to be NULL
- return immediately if the pbx fails to start so the loop to set all of
  the variables from the "setvar" options aren't set as a bunch of global
  variables instead

------------------------------------------------------------------------
r35555 | russell | 2006-06-22 19:49:28 +0200 (Thu, 22 Jun 2006) | 2 lines

don't blow up if a jitterbuffer is not in use

------------------------------------------------------------------------


Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-28 02:39:13 UTC (rev 413)
+++ trunk/channel.c	2006-06-28 02:39:58 UTC (rev 414)
@@ -1017,7 +1017,8 @@
 		ast_var_delete(vardata);
 
 	/* Destroy the jitterbuffer */
-	ast_jb_destroy(chan);
+	if (chan->jb)
+		ast_jb_destroy(chan);
 
 	ast_string_field_free_all(chan);
 	free(chan);

Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 02:39:13 UTC (rev 413)
+++ trunk/channels/chan_iax2.c	2006-06-28 02:39:58 UTC (rev 414)
@@ -3309,20 +3309,20 @@
 		i->owner = tmp;
 		i->capability = capability;
 		ast_setstate(tmp, state);
-		ast_mutex_lock(&usecnt_lock);
-		usecnt++;
-		ast_mutex_unlock(&usecnt_lock);
-		ast_update_use_count();
 		if (state != AST_STATE_DOWN) {
 			if (ast_pbx_start(tmp)) {
 				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 				ast_hangup(tmp);
-				tmp = NULL;
+				i->owner = NULL;
+				return NULL;
 			}
 		}
 		for (v = i->vars ; v ; v = v->next)
 			pbx_builtin_setvar_helper(tmp,v->name,v->value);
-		
+		ast_mutex_lock(&usecnt_lock);
+		usecnt++;
+		ast_mutex_unlock(&usecnt_lock);
+		ast_update_use_count();
 	}
 	return tmp;
 }



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 04:46:28 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 04:46:28 +0200
Subject: [solid-pbx-svn] r415 - in trunk: . apps build_tools funcs res
Message-ID: <200606280246.k5S2kS0e000561@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 04:45:27 +0200 (Wed, 28 Jun 2006)
New Revision: 415

Modified:
   trunk/apps/Makefile
   trunk/build_tools/menuselect-deps.in
   trunk/configure.ac
   trunk/funcs/Makefile
   trunk/makeopts.in
   trunk/res/Makefile
   trunk/res/res_snmp.c
Log:
Update to Asterisk SVN trunk r35613

------------------------------------------------------------------------
r35605 | russell | 2006-06-23 03:29:41 +0200 (Fri, 23 Jun 2006) | 5 lines

remove various commands that remove old modules since they have been there a
sufficient amount of time.  Even if they happen to be still present, the main
Makefile will spit out a huge warning telling the user that modules not
installed by that run of "make install" are present in the modules directory.

------------------------------------------------------------------------
r35607 | russell | 2006-06-23 03:50:55 +0200 (Fri, 23 Jun 2006) | 2 lines

add basic autoconf support for res_snmp

------------------------------------------------------------------------
r35608 | russell | 2006-06-23 03:54:07 +0200 (Fri, 23 Jun 2006) | 2 lines

delete snmp/agent.o on make clean

------------------------------------------------------------------------


Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/apps/Makefile	2006-06-28 02:45:27 UTC (rev 415)
@@ -42,9 +42,6 @@
 
 install: all
 	for x in $(MODS); do $(INSTALL) -m 755 $$x $(DESTDIR)$(MODULES_DIR) ; done
-	rm -f $(DESTDIR)$(MODULES_DIR)/app_cut.so
-	rm -f $(DESTDIR)$(MODULES_DIR)/app_datetime.so
-	rm -f $(DESTDIR)$(MODULES_DIR)/app_qcall.so
 
 uninstall:
 

Modified: trunk/build_tools/menuselect-deps.in
===================================================================
--- trunk/build_tools/menuselect-deps.in	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/build_tools/menuselect-deps.in	2006-06-28 02:45:27 UTC (rev 415)
@@ -26,3 +26,4 @@
 LIBGSM=@PBX_LIBgsm@
 IKSEMEL=@PBX_LIBIKSEMEL@
 IXJUSER=@PBX_IXJUSER@
+NETSNMP=@PBX_NETSNMP@

Modified: trunk/configure.ac
===================================================================
--- trunk/configure.ac	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/configure.ac	2006-06-28 02:45:27 UTC (rev 415)
@@ -367,6 +367,16 @@
 AC_SUBST([pq_LIB])
 AC_SUBST([PBX_LIBpq])
 
+NETSNMP_LIBS=
+PBX_NETSNMP=0
+AC_PATH_TOOL([NET_SNMP_CONFIG], [net-snmp-config], No)
+if test "x${NET_SNMP_CONFIG}" != "xNo" ; then
+  NETSNMP_LIBS=`${NET_SNMP_CONFIG} --agent-libs`
+  PBX_NETSNMP=1
+fi
+AC_SUBST([NETSNMP_LIBS])
+AC_SUBST([PBX_NETSNMP])
+
 AC_CHECK_HEADER([linux/ixjuser.h], [PBX_IXJUSER=1], [PBX_IXJUSER=0], [
 				   #include <linux/version.h>
 				   #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,0)

Modified: trunk/funcs/Makefile
===================================================================
--- trunk/funcs/Makefile	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/funcs/Makefile	2006-06-28 02:45:27 UTC (rev 415)
@@ -57,7 +57,6 @@
 
 install: all
 	for x in $(MODS); do $(INSTALL) -m 755 $$x $(DESTDIR)$(MODULES_DIR) ; done
-	rm -f $(DESTDIR)$(MODULES_DIR)/pbx_functions.so
 
 uninstall:
 

Modified: trunk/makeopts.in
===================================================================
--- trunk/makeopts.in	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/makeopts.in	2006-06-28 02:45:27 UTC (rev 415)
@@ -123,3 +123,5 @@
 
 RADIUSCLIENT_LIB=@RADIUSCLIENT_LIB@
 RADIUSCLIENT_INCLUDE=@RADIUSCLIENT_INCLUDE@
+
+NETSNMP_LIBS=@NETSNMP_LIBS@

Modified: trunk/res/Makefile
===================================================================
--- trunk/res/Makefile	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/res/Makefile	2006-06-28 02:45:27 UTC (rev 415)
@@ -23,31 +23,11 @@
   SELECTED_MODS:=$(filter-out $(shell if test ${BSDVERSION} -lt 500000 ; then echo "res_config_odbc"; fi),$(SELECTED_MODS))
 endif
 
-# NETsnmp has some difficulties on some platforms (conflict with unload_module)
-# Until we figure out if the collission is version-specific or what to do
-# we have disabled res_snmp on OS/X and *BSD
-ifeq ($(OSARCH),Darwin)
-  SELECTED_MODS:=$(filter-out res_snmp,$(SELECTED_MODS))
-else
-  ifeq ($(findstring BSD,$(OSARCH)),BSD)
-    SELECTED_MODS:=$(filter-out res_snmp,$(SELECTED_MODS))
-  endif
-endif
-
-ifeq ($(wildcard $(CROSS_COMPILE_TARGET)/usr/include/net-snmp/net-snmp-config.h),)
-  SELECTED_MODS:=$(filter-out res_snmp,$(SELECTED_MODS))
-else
-  SNMP_LDLIBS+=$(shell net-snmp-config --agent-libs)
-endif
-
 MODS:=$(patsubst %,%.so,$(SELECTED_MODS))
 
 all: $(MODS)
 
 install: all
-	rm -f $(DESTDIR)$(ASTHEADERDIR)/parking.h
-	rm -f $(DESTDIR)$(MODULES_DIR)/app_agi.so 
-	rm -f $(DESTDIR)$(MODULES_DIR)/res_parking.so
 	for x in $(MODS); do $(INSTALL) -m 755 $$x $(DESTDIR)$(MODULES_DIR) ; done
 	@if [ x`which mpg123 2>/dev/null | grep -v '^no'` != x ] ; then \
 	  if mpg123 --longhelp 2>&1 | grep -q .59r 2>&1 >/dev/null ; then echo ; else \
@@ -74,6 +54,7 @@
 
 clean: clean-depend
 	rm -f *.so *.o
+	rm -f snmp/*.o
 
 res_odbc.so: res_odbc.o
 	$(CC) $(SOLINK) -o $@ $< $(ODBC_LIB) 
@@ -100,7 +81,7 @@
 	$(CC) -c -o $@ $(CFLAGS) $(ODBC_INCLUDE) $<
 
 res_snmp.so: res_snmp.o snmp/agent.o
-	$(CC) $(SOLINK) $(SNMP_LDFLAGS) -o $@ $< snmp/agent.o $(SNMP_LDLIBS)
+	$(CC) $(SOLINK) -o $@ $< snmp/agent.o $(NETSNMP_LIBS)
 
 res_config_pgsql.so: res_config_pgsql.o
 	$(CC) $(SOLINK) -o $@ $< $(PGSQL_LIB)

Modified: trunk/res/res_snmp.c
===================================================================
--- trunk/res/res_snmp.c	2006-06-28 02:39:58 UTC (rev 414)
+++ trunk/res/res_snmp.c	2006-06-28 02:45:27 UTC (rev 415)
@@ -15,6 +15,7 @@
  */
 
 /*** MODULEINFO
+	<depend>netsnmp</depend>
 	<defaultenabled>no</defaultenabled>
  ***/
 



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 05:25:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 05:25:45 +0200
Subject: [solid-pbx-svn] r416 - in trunk: . channels
Message-ID: <200606280325.k5S3PjBC024583@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 05:25:40 +0200 (Wed, 28 Jun 2006)
New Revision: 416

Modified:
   trunk/Makefile
   trunk/channels/chan_iax2.c
   trunk/channels/chan_zap.c
Log:
Update to Asterisk SVN trunk r35633

------------------------------------------------------------------------
r35628 | russell | 2006-06-23 04:03:21 +0200 (Fri, 23 Jun 2006) | 2 lines

reduce indentation

------------------------------------------------------------------------
r35629 | russell | 2006-06-23 04:08:10 +0200 (Fri, 23 Jun 2006) | 2 lines

reduce indentation

------------------------------------------------------------------------
r35630 | russell | 2006-06-23 04:15:35 +0200 (Fri, 23 Jun 2006) | 3 lines

remove the autom4te.cache dir on a "make distclean" and add distclean to the
.PHONY list

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 02:45:27 UTC (rev 415)
+++ trunk/Makefile	2006-06-28 03:25:40 UTC (rev 416)
@@ -513,6 +513,7 @@
 	@$(MAKE) -C sounds dist-clean
 	rm -f menuselect.makeopts makeopts makeopts.xml
 	rm -f config.log config.status
+	rm -rf autom4te.cache
 	rm -f include/autoconfig.h
 	rm -f include/asterisk/buildopts.h
 
@@ -887,4 +888,4 @@
 	cp -ar . ../solid-pbx-$(ASTERISKVERSION)
 	cd ../solid-pbx-$(ASTERISKVERSION) && rm -rf `ls -Rd .svn */.svn */*/.svn */*/*/.svn */*/*/*/.svn` sounds
 
-.PHONY: sounds clean clean-depend dist-clean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL) $(SUBDIRS)
+.PHONY: sounds clean clean-depend dist-clean distclean all _all depend cleantest uninstall _uninstall uninstall-all dont-optimize valgrind $(SUBDIRS_INSTALL) $(SUBDIRS_CLEAN) $(SUBDIRS_CLEAN_DEPEND) $(SUBDIRS_DEPEND) $(SUBDIRS_UNINSTALL) $(SUBDIRS)

Modified: trunk/channels/chan_iax2.c
===================================================================
--- trunk/channels/chan_iax2.c	2006-06-28 02:45:27 UTC (rev 415)
+++ trunk/channels/chan_iax2.c	2006-06-28 03:25:40 UTC (rev 416)
@@ -3270,60 +3270,67 @@
 	struct chan_iax2_pvt *i;
 	struct ast_variable *v = NULL;
 
+	if (!(i = iaxs[callno])) {
+		ast_log(LOG_WARNING, "No IAX2 pvt found for callno '%d' !\n", callno);
+		return NULL;
+	}
+
 	/* Don't hold call lock */
 	ast_mutex_unlock(&iaxsl[callno]);
 	tmp = ast_channel_alloc(1);
 	ast_mutex_lock(&iaxsl[callno]);
-	i = iaxs[callno];
-	if (i && tmp) {
-		tmp->tech = &iax2_tech;
-		ast_string_field_build(tmp, name, "IAX2/%s-%d", i->host, i->callno);
-		/* We can support any format by default, until we get restricted */
-		tmp->nativeformats = capability;
-		tmp->readformat = ast_best_codec(capability);
-		tmp->writeformat = ast_best_codec(capability);
-		tmp->tech_pvt = CALLNO_TO_PTR(i->callno);
+	if (!tmp)
+		return NULL;
+	tmp->tech = &iax2_tech;
+	ast_string_field_build(tmp, name, "IAX2/%s-%d", i->host, i->callno);
+	/* We can support any format by default, until we get restricted */
+	tmp->nativeformats = capability;
+	tmp->readformat = ast_best_codec(capability);
+	tmp->writeformat = ast_best_codec(capability);
+	tmp->tech_pvt = CALLNO_TO_PTR(i->callno);
 
-		if (!ast_strlen_zero(i->cid_num))
-			tmp->cid.cid_num = ast_strdup(i->cid_num);
-		if (!ast_strlen_zero(i->cid_name))
-			tmp->cid.cid_name = ast_strdup(i->cid_name);
-		if (!ast_strlen_zero(i->ani))
-			tmp->cid.cid_ani = ast_strdup(i->ani);
-		if (!ast_strlen_zero(i->language))
-			ast_string_field_set(tmp, language, i->language);
-		if (!ast_strlen_zero(i->dnid))
-			tmp->cid.cid_dnid = ast_strdup(i->dnid);
-		if (!ast_strlen_zero(i->rdnis))
-			tmp->cid.cid_rdnis = ast_strdup(i->rdnis);
-		tmp->cid.cid_pres = i->calling_pres;
-		tmp->cid.cid_ton = i->calling_ton;
-		tmp->cid.cid_tns = i->calling_tns;
-		if (!ast_strlen_zero(i->accountcode))
-			ast_string_field_set(tmp, accountcode, i->accountcode);
-		if (i->amaflags)
-			tmp->amaflags = i->amaflags;
-		ast_copy_string(tmp->context, i->context, sizeof(tmp->context));
-		ast_copy_string(tmp->exten, i->exten, sizeof(tmp->exten));
-		tmp->adsicpe = i->peeradsicpe;
-		i->owner = tmp;
-		i->capability = capability;
-		ast_setstate(tmp, state);
-		if (state != AST_STATE_DOWN) {
-			if (ast_pbx_start(tmp)) {
-				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
-				ast_hangup(tmp);
-				i->owner = NULL;
-				return NULL;
-			}
+	if (!ast_strlen_zero(i->cid_num))
+		tmp->cid.cid_num = ast_strdup(i->cid_num);
+	if (!ast_strlen_zero(i->cid_name))
+		tmp->cid.cid_name = ast_strdup(i->cid_name);
+	if (!ast_strlen_zero(i->ani))
+		tmp->cid.cid_ani = ast_strdup(i->ani);
+	if (!ast_strlen_zero(i->language))
+		ast_string_field_set(tmp, language, i->language);
+	if (!ast_strlen_zero(i->dnid))
+		tmp->cid.cid_dnid = ast_strdup(i->dnid);
+	if (!ast_strlen_zero(i->rdnis))
+		tmp->cid.cid_rdnis = ast_strdup(i->rdnis);
+	tmp->cid.cid_pres = i->calling_pres;
+	tmp->cid.cid_ton = i->calling_ton;
+	tmp->cid.cid_tns = i->calling_tns;
+	if (!ast_strlen_zero(i->accountcode))
+		ast_string_field_set(tmp, accountcode, i->accountcode);
+	if (i->amaflags)
+		tmp->amaflags = i->amaflags;
+	ast_copy_string(tmp->context, i->context, sizeof(tmp->context));
+	ast_copy_string(tmp->exten, i->exten, sizeof(tmp->exten));
+	tmp->adsicpe = i->peeradsicpe;
+	i->owner = tmp;
+	i->capability = capability;
+	ast_setstate(tmp, state);
+	if (state != AST_STATE_DOWN) {
+		if (ast_pbx_start(tmp)) {
+			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
+			ast_hangup(tmp);
+			i->owner = NULL;
+			return NULL;
 		}
-		for (v = i->vars ; v ; v = v->next)
-			pbx_builtin_setvar_helper(tmp,v->name,v->value);
-		ast_mutex_lock(&usecnt_lock);
-		usecnt++;
-		ast_mutex_unlock(&usecnt_lock);
-		ast_update_use_count();
 	}
+
+	for (v = i->vars ; v ; v = v->next)
+		pbx_builtin_setvar_helper(tmp, v->name, v->value);
+
+	ast_mutex_lock(&usecnt_lock);
+	usecnt++;
+	ast_mutex_unlock(&usecnt_lock);
+	ast_update_use_count();
+	
 	return tmp;
 }
 

Modified: trunk/channels/chan_zap.c
===================================================================
--- trunk/channels/chan_zap.c	2006-06-28 02:45:27 UTC (rev 415)
+++ trunk/channels/chan_zap.c	2006-06-28 03:25:40 UTC (rev 416)
@@ -5041,173 +5041,168 @@
 		ast_log(LOG_WARNING, "Channel %d already has a %s call\n", i->channel,subnames[index]);
 		return NULL;
 	}
-	tmp = ast_channel_alloc(0);
-	if (tmp) {
-		tmp->tech = &zap_tech;
-		ps.channo = i->channel;
-		res = ioctl(i->subs[SUB_REAL].zfd, ZT_GET_PARAMS, &ps);
-		if (res) {
-			ast_log(LOG_WARNING, "Unable to get parameters, assuming MULAW\n");
-			ps.curlaw = ZT_LAW_MULAW;
-		}
-		if (ps.curlaw == ZT_LAW_ALAW)
+	if (!(tmp = ast_channel_alloc(0)))
+		return NULL;
+	tmp->tech = &zap_tech;
+	ps.channo = i->channel;
+	res = ioctl(i->subs[SUB_REAL].zfd, ZT_GET_PARAMS, &ps);
+	if (res) {
+		ast_log(LOG_WARNING, "Unable to get parameters, assuming MULAW\n");
+		ps.curlaw = ZT_LAW_MULAW;
+	}
+	if (ps.curlaw == ZT_LAW_ALAW)
+		deflaw = AST_FORMAT_ALAW;
+	else
+		deflaw = AST_FORMAT_ULAW;
+	if (law) {
+		if (law == ZT_LAW_ALAW)
 			deflaw = AST_FORMAT_ALAW;
 		else
 			deflaw = AST_FORMAT_ULAW;
-		if (law) {
-			if (law == ZT_LAW_ALAW)
-				deflaw = AST_FORMAT_ALAW;
-			else
-				deflaw = AST_FORMAT_ULAW;
-		}
-		y = 1;
-		do {
+	}
+	y = 1;
+	do {
 #ifdef HAVE_LIBPRI
-			if (i->bearer || (i->pri && (i->sig == SIG_FXSKS)))
-				ast_string_field_build(tmp, name, "Zap/%d:%d-%d", i->pri->trunkgroup, i->channel, y);
-			else
+		if (i->bearer || (i->pri && (i->sig == SIG_FXSKS)))
+			ast_string_field_build(tmp, name, "Zap/%d:%d-%d", i->pri->trunkgroup, i->channel, y);
+		else
 #endif
-			if (i->channel == CHAN_PSEUDO)
-				ast_string_field_build(tmp, name, "Zap/pseudo-%d", ast_random());
-			else	
-				ast_string_field_build(tmp, name, "Zap/%d-%d", i->channel, y);
-			for (x = 0; x < 3; x++) {
-				if ((index != x) && i->subs[x].owner && !strcasecmp(tmp->name, i->subs[x].owner->name))
-					break;
-			}
-			y++;
-		} while (x < 3);
-		tmp->fds[0] = i->subs[index].zfd;
-		tmp->nativeformats = AST_FORMAT_SLINEAR | deflaw;
-		/* Start out assuming ulaw since it's smaller :) */
-		tmp->rawreadformat = deflaw;
-		tmp->readformat = deflaw;
-		tmp->rawwriteformat = deflaw;
-		tmp->writeformat = deflaw;
-		i->subs[index].linear = 0;
-		zt_setlinear(i->subs[index].zfd, i->subs[index].linear);
-		features = 0;
-		if (i->busydetect && CANBUSYDETECT(i)) {
-			features |= DSP_FEATURE_BUSY_DETECT;
+		if (i->channel == CHAN_PSEUDO)
+			ast_string_field_build(tmp, name, "Zap/pseudo-%d", ast_random());
+		else	
+			ast_string_field_build(tmp, name, "Zap/%d-%d", i->channel, y);
+		for (x = 0; x < 3; x++) {
+			if ((index != x) && i->subs[x].owner && !strcasecmp(tmp->name, i->subs[x].owner->name))
+				break;
 		}
-		if ((i->callprogress & 1) && CANPROGRESSDETECT(i)) {
-			features |= DSP_FEATURE_CALL_PROGRESS;
-		}
-		if ((!i->outgoing && (i->callprogress & 4)) || 
-		    (i->outgoing && (i->callprogress & 2))) {
-			features |= DSP_FEATURE_FAX_DETECT;
-		}
+		y++;
+	} while (x < 3);
+	tmp->fds[0] = i->subs[index].zfd;
+	tmp->nativeformats = AST_FORMAT_SLINEAR | deflaw;
+	/* Start out assuming ulaw since it's smaller :) */
+	tmp->rawreadformat = deflaw;
+	tmp->readformat = deflaw;
+	tmp->rawwriteformat = deflaw;
+	tmp->writeformat = deflaw;
+	i->subs[index].linear = 0;
+	zt_setlinear(i->subs[index].zfd, i->subs[index].linear);
+	features = 0;
+	if (i->busydetect && CANBUSYDETECT(i))
+		features |= DSP_FEATURE_BUSY_DETECT;
+	if ((i->callprogress & 1) && CANPROGRESSDETECT(i))
+		features |= DSP_FEATURE_CALL_PROGRESS;
+	if ((!i->outgoing && (i->callprogress & 4)) || 
+	    (i->outgoing && (i->callprogress & 2))) {
+		features |= DSP_FEATURE_FAX_DETECT;
+	}
 #ifdef ZT_TONEDETECT
-		x = ZT_TONEDETECT_ON | ZT_TONEDETECT_MUTE;
-		if (ioctl(i->subs[index].zfd, ZT_TONEDETECT, &x)) {
+	x = ZT_TONEDETECT_ON | ZT_TONEDETECT_MUTE;
+	if (ioctl(i->subs[index].zfd, ZT_TONEDETECT, &x)) {
 #endif		
-			i->hardwaredtmf = 0;
-			features |= DSP_FEATURE_DTMF_DETECT;
+		i->hardwaredtmf = 0;
+		features |= DSP_FEATURE_DTMF_DETECT;
 #ifdef ZT_TONEDETECT
-		} else if (NEED_MFDETECT(i)) {
-			i->hardwaredtmf = 1;
-			features |= DSP_FEATURE_DTMF_DETECT;
-		}
+	} else if (NEED_MFDETECT(i)) {
+		i->hardwaredtmf = 1;
+		features |= DSP_FEATURE_DTMF_DETECT;
+	}
 #endif
-		if (features) {
+	if (features) {
+		if (i->dsp) {
+			ast_log(LOG_DEBUG, "Already have a dsp on %s?\n", tmp->name);
+		} else {
+			if (i->channel != CHAN_PSEUDO)
+				i->dsp = ast_dsp_new();
+			else
+				i->dsp = NULL;
 			if (i->dsp) {
-				ast_log(LOG_DEBUG, "Already have a dsp on %s?\n", tmp->name);
-			} else {
-				if (i->channel != CHAN_PSEUDO)
-					i->dsp = ast_dsp_new();
-				else
-					i->dsp = NULL;
-				if (i->dsp) {
-					i->dsp_features = features & ~DSP_PROGRESS_TALK;
+				i->dsp_features = features & ~DSP_PROGRESS_TALK;
 #ifdef HAVE_LIBPRI
-					/* We cannot do progress detection until receives PROGRESS message */
-					if (i->outgoing && (i->sig == SIG_PRI)) {
-						/* Remember requested DSP features, don't treat
-						   talking as ANSWER */
-						features = 0;
-					}
+				/* We cannot do progress detection until receives PROGRESS message */
+				if (i->outgoing && (i->sig == SIG_PRI)) {
+					/* Remember requested DSP features, don't treat
+					   talking as ANSWER */
+					features = 0;
+				}
 #endif
-					ast_dsp_set_features(i->dsp, features);
-					ast_dsp_digitmode(i->dsp, DSP_DIGITMODE_DTMF | i->dtmfrelax);
-					if (!ast_strlen_zero(progzone))
-						ast_dsp_set_call_progress_zone(i->dsp, progzone);
-					if (i->busydetect && CANBUSYDETECT(i)) {
-						ast_dsp_set_busy_count(i->dsp, i->busycount);
-						ast_dsp_set_busy_pattern(i->dsp, i->busy_tonelength, i->busy_quietlength);
-					}
+				ast_dsp_set_features(i->dsp, features);
+				ast_dsp_digitmode(i->dsp, DSP_DIGITMODE_DTMF | i->dtmfrelax);
+				if (!ast_strlen_zero(progzone))
+					ast_dsp_set_call_progress_zone(i->dsp, progzone);
+				if (i->busydetect && CANBUSYDETECT(i)) {
+					ast_dsp_set_busy_count(i->dsp, i->busycount);
+					ast_dsp_set_busy_pattern(i->dsp, i->busy_tonelength, i->busy_quietlength);
 				}
 			}
 		}
+	}
 		
-		if (state == AST_STATE_RING)
-			tmp->rings = 1;
-		tmp->tech_pvt = i;
-		if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
-			/* Only FXO signalled stuff can be picked up */
-			tmp->callgroup = i->callgroup;
-			tmp->pickupgroup = i->pickupgroup;
-		}
-		if (!ast_strlen_zero(i->language))
-			ast_string_field_set(tmp, language, i->language);
-		if (!ast_strlen_zero(i->musicclass))
-			ast_string_field_set(tmp, musicclass, i->musicclass);
-		if (!i->owner)
-			i->owner = tmp;
-		if (!ast_strlen_zero(i->accountcode))
-			ast_string_field_set(tmp, accountcode, i->accountcode);
-		if (i->amaflags)
-			tmp->amaflags = i->amaflags;
-		i->subs[index].owner = tmp;
-		ast_copy_string(tmp->context, i->context, sizeof(tmp->context));
-		ast_string_field_set(tmp, call_forward, i->call_forward);
-		/* If we've been told "no ADSI" then enforce it */
-		if (!i->adsi)
-			tmp->adsicpe = AST_ADSI_UNAVAILABLE;
-		if (!ast_strlen_zero(i->exten))
-			ast_copy_string(tmp->exten, i->exten, sizeof(tmp->exten));
-		if (!ast_strlen_zero(i->rdnis))
-			tmp->cid.cid_rdnis = ast_strdup(i->rdnis);
-		if (!ast_strlen_zero(i->dnid))
-			tmp->cid.cid_dnid = ast_strdup(i->dnid);
+	if (state == AST_STATE_RING)
+		tmp->rings = 1;
+	tmp->tech_pvt = i;
+	if ((i->sig == SIG_FXOKS) || (i->sig == SIG_FXOGS) || (i->sig == SIG_FXOLS)) {
+		/* Only FXO signalled stuff can be picked up */
+		tmp->callgroup = i->callgroup;
+		tmp->pickupgroup = i->pickupgroup;
+	}
+	if (!ast_strlen_zero(i->language))
+		ast_string_field_set(tmp, language, i->language);
+	if (!ast_strlen_zero(i->musicclass))
+		ast_string_field_set(tmp, musicclass, i->musicclass);
+	if (!i->owner)
+		i->owner = tmp;
+	if (!ast_strlen_zero(i->accountcode))
+		ast_string_field_set(tmp, accountcode, i->accountcode);
+	if (i->amaflags)
+		tmp->amaflags = i->amaflags;
+	i->subs[index].owner = tmp;
+	ast_copy_string(tmp->context, i->context, sizeof(tmp->context));
+	ast_string_field_set(tmp, call_forward, i->call_forward);
+	/* If we've been told "no ADSI" then enforce it */
+	if (!i->adsi)
+		tmp->adsicpe = AST_ADSI_UNAVAILABLE;
+	if (!ast_strlen_zero(i->exten))
+		ast_copy_string(tmp->exten, i->exten, sizeof(tmp->exten));
+	if (!ast_strlen_zero(i->rdnis))
+		tmp->cid.cid_rdnis = ast_strdup(i->rdnis);
+	if (!ast_strlen_zero(i->dnid))
+		tmp->cid.cid_dnid = ast_strdup(i->dnid);
 
 #ifdef PRI_ANI
-		ast_set_callerid(tmp, i->cid_num, i->cid_name, S_OR(i->cid_ani, i->cid_num));
+	ast_set_callerid(tmp, i->cid_num, i->cid_name, S_OR(i->cid_ani, i->cid_num));
 #else
-		ast_set_callerid(tmp, i->cid_num, i->cid_name, i->cid_num);
+	ast_set_callerid(tmp, i->cid_num, i->cid_name, i->cid_num);
 #endif
-		tmp->cid.cid_pres = i->callingpres;
-		tmp->cid.cid_ton = i->cid_ton;
+	tmp->cid.cid_pres = i->callingpres;
+	tmp->cid.cid_ton = i->cid_ton;
 #ifdef HAVE_LIBPRI
-		tmp->transfercapability = transfercapability;
-		pbx_builtin_setvar_helper(tmp, "TRANSFERCAPABILITY", ast_transfercapability2str(transfercapability));
-		if (transfercapability & PRI_TRANS_CAP_DIGITAL) {
-			i->digital = 1;
-		}
-		/* Assume calls are not idle calls unless we're told differently */
-		i->isidlecall = 0;
-		i->alreadyhungup = 0;
+	tmp->transfercapability = transfercapability;
+	pbx_builtin_setvar_helper(tmp, "TRANSFERCAPABILITY", ast_transfercapability2str(transfercapability));
+	if (transfercapability & PRI_TRANS_CAP_DIGITAL)
+		i->digital = 1;
+	/* Assume calls are not idle calls unless we're told differently */
+	i->isidlecall = 0;
+	i->alreadyhungup = 0;
 #endif
-		/* clear the fake event in case we posted one before we had ast_channel */
-		i->fake_event = 0;
-		/* Assure there is no confmute on this channel */
-		zt_confmute(i, 0);
-		ast_setstate(tmp, state);
-		/* Configure the new channel jb */
-		if (ast_jb_configure(tmp, &global_jbconf)) {
+	/* clear the fake event in case we posted one before we had ast_channel */
+	i->fake_event = 0;
+	/* Assure there is no confmute on this channel */
+	zt_confmute(i, 0);
+	ast_setstate(tmp, state);
+	/* Configure the new channel jb */
+	if (ast_jb_configure(tmp, &global_jbconf)) {
+		ast_hangup(tmp);
+		i->owner = NULL;
+		return NULL;
+	}
+	if (startpbx) {
+		if (ast_pbx_start(tmp)) {
+			ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
 			ast_hangup(tmp);
 			i->owner = NULL;
 			return NULL;
 		}
-		if (startpbx) {
-			if (ast_pbx_start(tmp)) {
-				ast_log(LOG_WARNING, "Unable to start PBX on %s\n", tmp->name);
-				ast_hangup(tmp);
-				i->owner = NULL;
-				return NULL;
-			}
-		}
-	} else
-		ast_log(LOG_WARNING, "Unable to allocate channel structure\n");
+	}
 
 	ast_mutex_lock(&usecnt_lock);
 	usecnt++;



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 07:26:05 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 07:26:05 +0200
Subject: [solid-pbx-svn] r417 - in trunk: . apps codecs include/asterisk pbx
Message-ID: <200606280526.k5S5Q5EC025309@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 07:25:29 +0200 (Wed, 28 Jun 2006)
New Revision: 417

Modified:
   trunk/LICENSE
   trunk/apps/Makefile
   trunk/apps/app_directory.c
   trunk/codecs/slin_g723_ex.h
   trunk/include/asterisk/channel.h
   trunk/include/asterisk/module.h
   trunk/include/asterisk/say.h
   trunk/loader.c
   trunk/pbx/pbx_gtkconsole.c
   trunk/pbx/pbx_kdeconsole.cc
   trunk/pbx/pbx_kdeconsole.h
   trunk/pbx/pbx_kdeconsole_main.cc
   trunk/say.c
Log:
Update to Asterisk SVN trunk r20

------------------------------------------------------------------------
r11 | markster | 1999-10-27 04:12:33 +0200 (Wed, 27 Oct 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r12 | markster | 1999-10-27 04:25:34 +0200 (Wed, 27 Oct 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r13 | markster | 1999-10-28 17:30:50 +0200 (Thu, 28 Oct 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r14 | markster | 1999-10-28 22:38:23 +0200 (Thu, 28 Oct 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r15 | markster | 1999-10-30 03:01:34 +0200 (Sat, 30 Oct 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r16 | markster | 1999-11-12 07:29:40 +0100 (Fri, 12 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r17 | markster | 1999-11-13 00:51:16 +0100 (Sat, 13 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r18 | markster | 1999-11-13 18:59:36 +0100 (Sat, 13 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r19 | markster | 1999-11-13 21:28:28 +0100 (Sat, 13 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r20 | markster | 1999-11-14 11:06:00 +0100 (Sun, 14 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------


Modified: trunk/LICENSE
===================================================================
--- trunk/LICENSE	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/LICENSE	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,3 +1,363 @@
+=================================================================
+Please note that Asterisk is distributed under the GNU General 
+Public License, with the following additional notices (some of
+these notices may be revised or relaxed in future releases):
+
+	a) All distributions or derivative works MUST not remove
+the name of Linux Support Services, LLC or Adtran, Inc. from 
+the product.
+
+	b) Some codecs included in the full Asterisk distribution
+*may* be covered by software patents.  
+
+	c) If You bring legal action against an organization or 
+individual for patent infringement regarding any Open Source 
+software (as defined by the Open Source Definition available at
+http://www.opensource.org/osd.html) then your right to use and/or
+distribute this software is immediately terminated.
+
+=================================================================
+
+		    GNU GENERAL PUBLIC LICENSE
+		       Version 2, June 1991
+
+ Copyright (C) 1989, 1991 Free Software Foundation, Inc.
+                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ Everyone is permitted to copy and distribute verbatim copies
+ of this license document, but changing it is not allowed.
+
+			    Preamble
+
+  The licenses for most software are designed to take away your
+freedom to share and change it.  By contrast, the GNU General Public
+License is intended to guarantee your freedom to share and change free
+software--to make sure the software is free for all its users.  This
+General Public License applies to most of the Free Software
+Foundation's software and to any other program whose authors commit to
+using it.  (Some other Free Software Foundation software is covered by
+the GNU Library General Public License instead.)  You can apply it to
+your programs, too.
+
+  When we speak of free software, we are referring to freedom, not
+price.  Our General Public Licenses are designed to make sure that you
+have the freedom to distribute copies of free software (and charge for
+this service if you wish), that you receive source code or can get it
+if you want it, that you can change the software or use pieces of it
+in new free programs; and that you know you can do these things.
+
+  To protect your rights, we need to make restrictions that forbid
+anyone to deny you these rights or to ask you to surrender the rights.
+These restrictions translate to certain responsibilities for you if you
+distribute copies of the software, or if you modify it.
+
+  For example, if you distribute copies of such a program, whether
+gratis or for a fee, you must give the recipients all the rights that
+you have.  You must make sure that they, too, receive or can get the
+source code.  And you must show them these terms so they know their
+rights.
+
+  We protect your rights with two steps: (1) copyright the software, and
+(2) offer you this license which gives you legal permission to copy,
+distribute and/or modify the software.
+
+  Also, for each author's protection and ours, we want to make certain
+that everyone understands that there is no warranty for this free
+software.  If the software is modified by someone else and passed on, we
+want its recipients to know that what they have is not the original, so
+that any problems introduced by others will not reflect on the original
+authors' reputations.
+
+  Finally, any free program is threatened constantly by software
+patents.  We wish to avoid the danger that redistributors of a free
+program will individually obtain patent licenses, in effect making the
+program proprietary.  To prevent this, we have made it clear that any
+patent must be licensed for everyone's free use or not licensed at all.
+
+  The precise terms and conditions for copying, distribution and
+modification follow.
+
+		    GNU GENERAL PUBLIC LICENSE
+   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
+
+  0. This License applies to any program or other work which contains
+a notice placed by the copyright holder saying it may be distributed
+under the terms of this General Public License.  The "Program", below,
+refers to any such program or work, and a "work based on the Program"
+means either the Program or any derivative work under copyright law:
+that is to say, a work containing the Program or a portion of it,
+either verbatim or with modifications and/or translated into another
+language.  (Hereinafter, translation is included without limitation in
+the term "modification".)  Each licensee is addressed as "you".
+
+Activities other than copying, distribution and modification are not
+covered by this License; they are outside its scope.  The act of
+running the Program is not restricted, and the output from the Program
+is covered only if its contents constitute a work based on the
+Program (independent of having been made by running the Program).
+Whether that is true depends on what the Program does.
+
+  1. You may copy and distribute verbatim copies of the Program's
+source code as you receive it, in any medium, provided that you
+conspicuously and appropriately publish on each copy an appropriate
+copyright notice and disclaimer of warranty; keep intact all the
+notices that refer to this License and to the absence of any warranty;
+and give any other recipients of the Program a copy of this License
+along with the Program.
+
+You may charge a fee for the physical act of transferring a copy, and
+you may at your option offer warranty protection in exchange for a fee.
+
+  2. You may modify your copy or copies of the Program or any portion
+of it, thus forming a work based on the Program, and copy and
+distribute such modifications or work under the terms of Section 1
+above, provided that you also meet all of these conditions:
+
+    a) You must cause the modified files to carry prominent notices
+    stating that you changed the files and the date of any change.
+
+    b) You must cause any work that you distribute or publish, that in
+    whole or in part contains or is derived from the Program or any
+    part thereof, to be licensed as a whole at no charge to all third
+    parties under the terms of this License.
+
+    c) If the modified program normally reads commands interactively
+    when run, you must cause it, when started running for such
+    interactive use in the most ordinary way, to print or display an
+    announcement including an appropriate copyright notice and a
+    notice that there is no warranty (or else, saying that you provide
+    a warranty) and that users may redistribute the program under
+    these conditions, and telling the user how to view a copy of this
+    License.  (Exception: if the Program itself is interactive but
+    does not normally print such an announcement, your work based on
+    the Program is not required to print an announcement.)
+
+These requirements apply to the modified work as a whole.  If
+identifiable sections of that work are not derived from the Program,
+and can be reasonably considered independent and separate works in
+themselves, then this License, and its terms, do not apply to those
+sections when you distribute them as separate works.  But when you
+distribute the same sections as part of a whole which is a work based
+on the Program, the distribution of the whole must be on the terms of
+this License, whose permissions for other licensees extend to the
+entire whole, and thus to each and every part regardless of who wrote it.
+
+Thus, it is not the intent of this section to claim rights or contest
+your rights to work written entirely by you; rather, the intent is to
+exercise the right to control the distribution of derivative or
+collective works based on the Program.
+
+In addition, mere aggregation of another work not based on the Program
+with the Program (or with a work based on the Program) on a volume of
+a storage or distribution medium does not bring the other work under
+the scope of this License.
+
+  3. You may copy and distribute the Program (or a work based on it,
+under Section 2) in object code or executable form under the terms of
+Sections 1 and 2 above provided that you also do one of the following:
+
+    a) Accompany it with the complete corresponding machine-readable
+    source code, which must be distributed under the terms of Sections
+    1 and 2 above on a medium customarily used for software interchange; or,
+
+    b) Accompany it with a written offer, valid for at least three
+    years, to give any third party, for a charge no more than your
+    cost of physically performing source distribution, a complete
+    machine-readable copy of the corresponding source code, to be
+    distributed under the terms of Sections 1 and 2 above on a medium
+    customarily used for software interchange; or,
+
+    c) Accompany it with the information you received as to the offer
+    to distribute corresponding source code.  (This alternative is
+    allowed only for noncommercial distribution and only if you
+    received the program in object code or executable form with such
+    an offer, in accord with Subsection b above.)
+
+The source code for a work means the preferred form of the work for
+making modifications to it.  For an executable work, complete source
+code means all the source code for all modules it contains, plus any
+associated interface definition files, plus the scripts used to
+control compilation and installation of the executable.  However, as a
+special exception, the source code distributed need not include
+anything that is normally distributed (in either source or binary
+form) with the major components (compiler, kernel, and so on) of the
+operating system on which the executable runs, unless that component
+itself accompanies the executable.
+
+If distribution of executable or object code is made by offering
+access to copy from a designated place, then offering equivalent
+access to copy the source code from the same place counts as
+distribution of the source code, even though third parties are not
+compelled to copy the source along with the object code.
+
+  4. You may not copy, modify, sublicense, or distribute the Program
+except as expressly provided under this License.  Any attempt
+otherwise to copy, modify, sublicense or distribute the Program is
+void, and will automatically terminate your rights under this License.
+However, parties who have received copies, or rights, from you under
+this License will not have their licenses terminated so long as such
+parties remain in full compliance.
+
+  5. You are not required to accept this License, since you have not
+signed it.  However, nothing else grants you permission to modify or
+distribute the Program or its derivative works.  These actions are
+prohibited by law if you do not accept this License.  Therefore, by
+modifying or distributing the Program (or any work based on the
+Program), you indicate your acceptance of this License to do so, and
+all its terms and conditions for copying, distributing or modifying
+the Program or works based on it.
+
+  6. Each time you redistribute the Program (or any work based on the
+Program), the recipient automatically receives a license from the
+original licensor to copy, distribute or modify the Program subject to
+these terms and conditions.  You may not impose any further
+restrictions on the recipients' exercise of the rights granted herein.
+You are not responsible for enforcing compliance by third parties to
+this License.
+
+  7. If, as a consequence of a court judgment or allegation of patent
+infringement or for any other reason (not limited to patent issues),
+conditions are imposed on you (whether by court order, agreement or
+otherwise) that contradict the conditions of this License, they do not
+excuse you from the conditions of this License.  If you cannot
+distribute so as to satisfy simultaneously your obligations under this
+License and any other pertinent obligations, then as a consequence you
+may not distribute the Program at all.  For example, if a patent
+license would not permit royalty-free redistribution of the Program by
+all those who receive copies directly or indirectly through you, then
+the only way you could satisfy both it and this License would be to
+refrain entirely from distribution of the Program.
+
+If any portion of this section is held invalid or unenforceable under
+any particular circumstance, the balance of the section is intended to
+apply and the section as a whole is intended to apply in other
+circumstances.
+
+It is not the purpose of this section to induce you to infringe any
+patents or other property right claims or to contest validity of any
+such claims; this section has the sole purpose of protecting the
+integrity of the free software distribution system, which is
+implemented by public license practices.  Many people have made
+generous contributions to the wide range of software distributed
+through that system in reliance on consistent application of that
+system; it is up to the author/donor to decide if he or she is willing
+to distribute software through any other system and a licensee cannot
+impose that choice.
+
+This section is intended to make thoroughly clear what is believed to
+be a consequence of the rest of this License.
+
+  8. If the distribution and/or use of the Program is restricted in
+certain countries either by patents or by copyrighted interfaces, the
+original copyright holder who places the Program under this License
+may add an explicit geographical distribution limitation excluding
+those countries, so that distribution is permitted only in or among
+countries not thus excluded.  In such case, this License incorporates
+the limitation as if written in the body of this License.
+
+  9. The Free Software Foundation may publish revised and/or new versions
+of the General Public License from time to time.  Such new versions will
+be similar in spirit to the present version, but may differ in detail to
+address new problems or concerns.
+
+Each version is given a distinguishing version number.  If the Program
+specifies a version number of this License which applies to it and "any
+later version", you have the option of following the terms and conditions
+either of that version or of any later version published by the Free
+Software Foundation.  If the Program does not specify a version number of
+this License, you may choose any version ever published by the Free Software
+Foundation.
+
+  10. If you wish to incorporate parts of the Program into other free
+programs whose distribution conditions are different, write to the author
+to ask for permission.  For software which is copyrighted by the Free
+Software Foundation, write to the Free Software Foundation; we sometimes
+make exceptions for this.  Our decision will be guided by the two goals
+of preserving the free status of all derivatives of our free software and
+of promoting the sharing and reuse of software generally.
+
+			    NO WARRANTY
+
+  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
+FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
+OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
+PROVIDE THE PROGRAM "AS IS" WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
+OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
+TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
+PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
+REPAIR OR CORRECTION.
+
+  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
+WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
+REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
+INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
+OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
+TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
+YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
+PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
+POSSIBILITY OF SUCH DAMAGES.
+
+		     END OF TERMS AND CONDITIONS
+
+	    How to Apply These Terms to Your New Programs
+
+  If you develop a new program, and you want it to be of the greatest
+possible use to the public, the best way to achieve this is to make it
+free software which everyone can redistribute and change under these terms.
+
+  To do so, attach the following notices to the program.  It is safest
+to attach them to the start of each source file to most effectively
+convey the exclusion of warranty; and each file should have at least
+the "copyright" line and a pointer to where the full notice is found.
+
+    <one line to give the program's name and a brief idea of what it does.>
+    Copyright (C) 19yy  <name of author>
+
+    This program is free software; you can redistribute it and/or modify
+    it under the terms of the GNU General Public License as published by
+    the Free Software Foundation; either version 2 of the License, or
+    (at your option) any later version.
+
+    This program is distributed in the hope that it will be useful,
+    but WITHOUT ANY WARRANTY; without even the implied warranty of
+    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+    GNU General Public License for more details.
+
+    You should have received a copy of the GNU General Public License
+    along with this program; if not, write to the Free Software
+    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+
+
+Also add information on how to contact you by electronic and paper mail.
+
+If the program is interactive, make it output a short notice like this
+when it starts in an interactive mode:
+
+    Gnomovision version 69, Copyright (C) 19yy name of author
+    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
+    This is free software, and you are welcome to redistribute it
+    under certain conditions; type `show c' for details.
+
+The hypothetical commands `show w' and `show c' should show the appropriate
+parts of the General Public License.  Of course, the commands you use may
+be called something other than `show w' and `show c'; they could even be
+mouse-clicks or menu items--whatever suits your program.
+
+You should also get your employer (if you work as a programmer) or your
+school, if any, to sign a "copyright disclaimer" for the program, if
+necessary.  Here is a sample; alter the names:
+
+  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
+  `Gnomovision' (which makes passes at compilers) written by James Hacker.
+
+  <signature of Ty Coon>, 1 April 1989
+  Ty Coon, President of Vice
+
+This General Public License does not permit incorporating your program into
+proprietary programs.  If your program is a subroutine library, you may
+consider it more useful to permit linking proprietary applications with the
+library.  If this is what you want to do, use the GNU Library General
+Public License instead of this License.
 Asterisk is distributed under the GNU General Public License version 2
 and is also available under alternative licenses negotiated directly
 with Digium, Inc. If you obtained Asterisk under the GPL, then the GPL

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/apps/Makefile	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,6 +1,33 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
+# Makefile for PBX frontends (dynamically loaded)
+#
+# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+#
+# Mark Spencer <markster at linux-support.net>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+APPS=app_dial.so app_playback.so app_voicemail.so app_directory.so app_intercom.so app_mp3.so
+
+CFLAGS+=
+
+all: $(APPS)
+
+clean:
+	rm -f *.so *.o
+
+%.so : %.o
+	$(CC) -shared -Xlinker -x -o $@ $<
+
+install: all
+	for x in $(APPS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
 # Makefile for PBX applications
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/apps/app_directory.c
===================================================================
--- trunk/apps/app_directory.c	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/apps/app_directory.c	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,268 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Provide a directory of extensions
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/config.h>
+#include <asterisk/say.h>
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <stdio.h>
+#include "../asterisk.h"
+
+static char *tdesc = "Extension Directory";
+static char *app = "Directory";
+
+/* For simplicity, I'm keeping the format compatible with the voicemail config,
+   but i'm open to suggestions for isolating it */
+
+#define DIRECTORY_CONFIG "voicemail.conf"
+
+/* How many digits to read in */
+#define NUMDIGITS 3
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static char *convert(char *lastname)
+{
+	char *tmp;
+	int lcount = 0;
+	tmp = malloc(NUMDIGITS + 1);
+	if (tmp) {
+		while((*lastname > 32) && lcount < NUMDIGITS) {
+			switch(toupper(*lastname)) {
+			case '1':
+				tmp[lcount++] = '1';
+				break;
+			case '2':
+			case 'A':
+			case 'B':
+			case 'C':
+				tmp[lcount++] = '2';
+				break;
+			case '3':
+			case 'D':
+			case 'E':
+			case 'F':
+				tmp[lcount++] = '3';
+				break;
+			case '4':
+			case 'G':
+			case 'H':
+			case 'I':
+				tmp[lcount++] = '4';
+				break;
+			case '5':
+			case 'J':
+			case 'K':
+			case 'L':
+				tmp[lcount++] = '5';
+				break;
+			case '6':
+			case 'M':
+			case 'N':
+			case 'O':
+				tmp[lcount++] = '6';
+				break;
+			case '7':
+			case 'P':
+			case 'Q':
+			case 'R':
+			case 'S':
+				tmp[lcount++] = '7';
+				break;
+			case '8':
+			case 'T':
+			case 'U':
+			case 'V':
+				tmp[lcount++] = '8';
+				break;
+			case '9':
+			case 'W':
+			case 'X':
+			case 'Y':
+			case 'Z':
+				tmp[lcount++] = '9';
+				break;
+			default:
+			}
+			lastname++;
+		}
+		tmp[lcount] = '\0';
+	}
+	return tmp;
+}
+
+static int do_directory(struct ast_channel *chan, struct ast_config *cfg, char *context, char digit)
+{
+	/* Read in the first three digits..  "digit" is the first digit, already read */
+	char ext[NUMDIGITS + 1];
+	struct ast_variable *v;
+	int res;
+	int found=0;
+	char *start, *pos, *conv;
+	char fn[256];
+	memset(ext, 0, sizeof(ext));
+	ext[0] = digit;
+	res = ast_readstring(chan, ext + 1, NUMDIGITS, 3000, 3000, "#");
+	if (!res) {
+		/* Search for all names which start with those digits */
+		v = ast_variable_browse(cfg, context);
+		while(v && !res) {
+			/* Find all candidate extensions */
+			while(v) {
+				/* Find a candidate extension */
+				start = strdup(v->value);
+				if (start) {
+					strtok(start, ",");
+					pos = strtok(NULL, ",");
+					if (pos) {
+						/* Grab the last name */
+						if (strrchr(pos, ' '))
+							pos = strrchr(pos, ' ') + 1;
+						conv = convert(pos);
+						if (conv) {
+							if (!strcmp(conv, ext)) {
+								/* Match! */
+								found++;
+								free(conv);
+								free(start);
+								break;
+							}
+							free(conv);
+						}
+					}
+					free(start);
+				}
+				v = v->next;
+			}
+			if (v) {
+				/* We have a match -- play a greeting if they have it */
+				snprintf(fn, sizeof(fn), "%s/vm/%s/greet", AST_SPOOL_DIR, v->name);
+				if (ast_fileexists(fn, NULL)) {
+					res = ast_streamfile(chan, fn);
+					if (!res)
+						res = ast_waitstream(chan, AST_DIGIT_ANY);
+					ast_stopstream(chan);
+				} else {
+					res = ast_say_digit_str(chan, v->name);
+				}
+ahem:
+				if (!res)
+					res = ast_streamfile(chan, "dir-instr");
+				if (!res)
+					res = ast_waitstream(chan, AST_DIGIT_ANY);
+				if (!res)
+					res = ast_waitfordigit(chan, 3000);
+				ast_stopstream(chan);
+				if (res > -1) {
+					if (res == '1') {
+						strncpy(chan->exten, v->name, sizeof(chan->exten));
+						chan->priority = 0;
+						strncpy(chan->context, context, sizeof(chan->context));
+						res = 0;
+						break;
+					} else if (res == '*') {
+						res = 0;
+						v = v->next;
+					} else {
+						res = 0;
+						goto ahem;
+					}
+				}
+			} else {
+				if (found) 
+					res = ast_streamfile(chan, "dir-nomore");
+				else
+					res = ast_streamfile(chan, "dir-nomatch");
+				if (!res)
+					res = 1;
+				return res;
+			}
+		}
+		
+	}
+	return res;
+}
+
+static int directory_exec(struct ast_channel *chan, void *data)
+{
+	int res = 0;
+	struct localuser *u;
+	struct ast_config *cfg;
+	if (!data) {
+		ast_log(LOG_WARNING, "directory requires an argument (context)\n");
+		return -1;
+	}
+	cfg = ast_load(DIRECTORY_CONFIG);
+	if (!cfg) {
+		ast_log(LOG_WARNING, "Unable to open directory configuration %s\n", DIRECTORY_CONFIG);
+		return -1;
+	}
+	LOCAL_USER_ADD(u);
+top:
+	if (!res)
+		res = ast_streamfile(chan, "dir-intro");
+	if (!res)
+		res = ast_waitstream(chan, AST_DIGIT_ANY);
+	ast_stopstream(chan);
+	if (!res)
+		res = ast_waitfordigit(chan, 5000);
+	if (res > 0) {
+		res = do_directory(chan, cfg, (char *)data, res);
+		if (res > 0) {
+			res = ast_waitstream(chan, AST_DIGIT_ANY);
+			ast_stopstream(chan);
+			if (res >= 0) {
+				goto top;
+			}
+		}
+	}
+	ast_destroy(cfg);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	return ast_register_application(app, directory_exec);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/codecs/slin_g723_ex.h
===================================================================
--- trunk/codecs/slin_g723_ex.h	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/codecs/slin_g723_ex.h	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,3 +1,39 @@
+/*
+  * Signed 16-bit audio data
+  *
+  * Source: g723.example
+  *
+  * Copyright (C) 1999, Mark Spencer and Linux Support Services
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+static signed short slin_g723_ex[] = {
+0x0873, 0x06d9, 0x038c, 0x0588, 0x0409, 0x033d, 0x0311, 0xff6c, 0xfeef, 0xfd3e, 
+0xfdff, 0xff7a, 0xff6d, 0xffec, 0xff36, 0xfd62, 0xfda7, 0xfc6c, 0xfe67, 0xffe1, 
+0x003d, 0x01cc, 0x0065, 0x002a, 0xff83, 0xfed9, 0xffba, 0xfece, 0xff42, 0xff16, 
+0xfe85, 0xff31, 0xff02, 0xfdff, 0xfe32, 0xfe3f, 0xfed5, 0xff65, 0xffd4, 0x005b, 
+0xff88, 0xff01, 0xfebd, 0xfe95, 0xff46, 0xffe1, 0x00e2, 0x0165, 0x017e, 0x01c9, 
+0x0182, 0x0146, 0x00f9, 0x00ab, 0x006f, 0xffe8, 0xffd8, 0xffc4, 0xffb2, 0xfff9, 
+0xfffe, 0x0023, 0x0018, 0x000b, 0x001a, 0xfff7, 0x0014, 0x000b, 0x0004, 0x000b, 
+0xfff1, 0xff4f, 0xff3f, 0xff42, 0xff5e, 0xffd4, 0x0014, 0x0067, 0x0051, 0x003b, 
+0x0034, 0xfff9, 0x000d, 0xff54, 0xff54, 0xff52, 0xff3f, 0xffcc, 0xffe6, 0x00fc, 
+0x00fa, 0x00e4, 0x00f3, 0x0021, 0x0011, 0xffa1, 0xffab, 0xffdb, 0xffa5, 0x0009, 
+0xffd2, 0xffe6, 0x0007, 0x0096, 0x00e4, 0x00bf, 0x00ce, 0x0048, 0xffe8, 0xffab, 
+0xff8f, 0xffc3, 0xffc1, 0xfffc, 0x0002, 0xfff1, 0x000b, 0x00a7, 0x00c5, 0x00cc, 
+0x015e, 0x00e4, 0x0094, 0x0029, 0xffc7, 0xffc3, 0xff86, 0xffe4, 0xffe6, 0xffec, 
+0x000f, 0xffe3, 0x0028, 0x004b, 0xffaf, 0xffcb, 0xfedd, 0xfef8, 0xfe83, 0xfeba, 
+0xff94, 0xff94, 0xffbe, 0xffa8, 0xff0d, 0xff32, 0xff58, 0x0021, 0x0087, 0x00be, 
+0x0115, 0x007e, 0x0052, 0xfff0, 0xffc9, 0xffe8, 0xffc4, 0x0014, 0xfff0, 0xfff5, 
+0xfffe, 0xffda, 0x000b, 0x0010, 0x006f, 0x006f, 0x0052, 0x0045, 0xffee, 0xffea, 
+0xffcb, 0xffdf, 0xfffc, 0xfff0, 0x0012, 0xfff7, 0xfffe, 0x0018, 0x0050, 0x0066, 
+0x0047, 0x0028, 0xfff7, 0xffe8, 0xffec, 0x0007, 0x001d, 0x0016, 0x00c4, 0x0093, 
+0x007d, 0x0052, 0x00a5, 0x0091, 0x003c, 0x0041, 0xffd1, 0xffda, 0xffc6, 0xfff0, 
+0x001d, 0xfffe, 0x0024, 0xffee, 0xfff3, 0xfff0, 0xffea, 0x0012, 0xfff3, 0xfff7, 
+0xffda, 0xffca, 0xffda, 0xffdf, 0xfff3, 0xfff7, 0xff54, 0xff7c, 0xff8c, 0xffb9, 
+0x0012, 0x0012, 0x004c, 0x0007, 0xff50, 0xff66, 0xff54, 0xffa9, 0xffdc, 0xfff9, 
+0x0038, 0xfff9, 0x00d2, 0x0096, 0x008a, 0x0079, 0xfff5, 0x0019, 0xffad, 0xfffc };
 /*! \file
   * \brief Signed 16-bit audio data
   *

Modified: trunk/include/asterisk/channel.h
===================================================================
--- trunk/include/asterisk/channel.h	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/include/asterisk/channel.h	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,156 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * General Asterisk channel definitions.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_CHANNEL_H
+#define _ASTERISK_CHANNEL_H
+
+#include <asterisk/frame.h>
+#include <asterisk/sched.h>
+#include <setjmp.h>
+#include <pthread.h>
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+
+
+#define AST_CHANNEL_NAME 80
+#define AST_CHANNEL_MAX_STACK 32
+
+/* Max length an extension can be (unique) is this number */
+#define AST_MAX_EXTENSION 80
+
+struct ast_channel {
+	char name[AST_CHANNEL_NAME];		/* ASCII Description of channel name */
+	pthread_t blocker;					/* If anyone is blocking, this is them */
+	char *blockproc;					/* Procedure causing blocking */
+	int blocking;						/* Whether or not we're blocking */
+	struct sched_context *sched;		/* Schedule context */
+	int streamid;					/* For streaming playback, the schedule ID */
+	struct ast_filestream *stream;	/* Stream itself. */
+	struct ast_channel *trans;		/* Translator if present */
+	struct ast_channel *master;		/* Master channel, if this is a translator */
+	int fd;					/* File descriptor for channel -- all must have
+						   a file descriptor! */
+	char *type;				/* Type of channel */
+	int state;				/* State of line */
+	int rings;				/* Number of rings so far */
+	int stack;				/* Current level of application */
+	int format;				/* Kinds of data this channel can
+						   	   natively handle */
+	char *dnid;				/* Malloc'd Dialed Number Identifier */
+	char *callerid;			/* Malloc'd Caller ID */
+	char context[AST_MAX_EXTENSION];	/* Current extension context */
+	char exten[AST_MAX_EXTENSION];		/* Current extension number */
+	int priority;						/* Current extension priority */
+	void *app[AST_CHANNEL_MAX_STACK];	/* Application information -- see assigned numbers */
+	struct ast_channel_pvt *pvt;
+						/* Private channel implementation details */
+	jmp_buf jmp[AST_CHANNEL_MAX_STACK];		/* Jump buffer used for returning from applications */
+	struct ast_pbx *pbx;
+	struct ast_channel *next;		/* For easy linking */
+};
+
+
+/* Bits 0-15 of state are reserved for the state (up/down) of the line */
+
+#define AST_STATE_DOWN		0		/* Channel is down and available */
+#define AST_STATE_RESERVED	1		/* Channel is down, but reserved */
+#define AST_STATE_OFFHOOK	2		/* Channel is off hook */
+#define AST_STATE_DIALING	3		/* Digits (or equivalent) have been dialed */
+#define AST_STATE_RING		4		/* Line is ringing */
+#define AST_STATE_RINGING	5		/* Remote end is ringing */
+#define AST_STATE_UP		6		/* Line is up */
+#define AST_STATE_BUSY  	7		/* Line is busy */
+
+/* Bits 16-32 of state are reserved for flags */
+
+#define AST_STATE_MUTE		(1 << 16)	/* Do not transmit voice data */
+
+/* Request a channel of a given type, with data as optional information used
+   by the low level module */
+struct ast_channel *ast_request(char *type, int format, void *data);
+
+/* Called by a channel module to register the kind of channels it supports.
+   It supplies a brief type, a longer, but still short description, and a
+   routine that creates a channel */
+int ast_channel_register(char *type, char *description, int capabilities, 
+			struct ast_channel* (*requester)(char *type, int format, void *data));
+
+/* Unregister a channel class */
+void ast_channel_unregister(char *type);
+
+/* Hang up a channel -- chan is no longer valid after this call! */
+int ast_hangup(struct ast_channel *chan);
+
+/* Softly hangup up a channel -- call the protocol layer, but don't
+   destroy the channel structure (use this if you are trying to
+   safely hangup a channel managed by another thread. */
+int ast_softhangup(struct ast_channel *chan);
+
+/* Answer a ringing call */
+int ast_answer(struct ast_channel *chan);
+
+/* Place a call, take no longer than timeout ms.  Returns -1 on failure, 
+   0 on not enough time (does not auto matically stop ringing), and  
+   the number of seconds the connect took otherwise.  */
+int ast_call(struct ast_channel *chan, char *addr, int timeout);
+
+/* Misc stuff */
+
+/* Wait for input on a channel for a given # of milliseconds (<0 for indefinite).  
+  Returns < 0 on  failure, 0 if nothing ever arrived, and the # of ms remaining otherwise */
+int ast_waitfor(struct ast_channel *chan, int ms);
+
+/* Wait for input on an array of channels for a given # of milliseconds. Return channel
+   with activity, or NULL if none has activity.  time "ms" is modified in-place, if applicable */
+
+struct ast_channel *ast_waitfor_n(struct ast_channel **chan, int n, int *ms);
+
+/* This version works on fd's only.  Be careful with it. */
+int ast_waitfor_n_fd(int *fds, int n, int *ms);
+
+/* Read a frame.  Returns a frame, or NULL on error.  If it returns NULL, you
+   best just stop reading frames and assume the channel has been
+   disconnected. */
+struct ast_frame *ast_read(struct ast_channel *chan);
+
+/* Write a frame to a channel */
+int ast_write(struct ast_channel *chan, struct ast_frame *frame);
+
+/* Wait for a digit.  Returns <0 on error, 0 on no entry, and the digit on success. */
+char ast_waitfordigit(struct ast_channel *c, int ms);
+
+/* Read in a digit string "s", max length "len", maximum timeout between 
+   digits "timeout" (-1 for none), terminated by anything in "enders".  Give them rtimeout
+   for the first digit */
+int ast_readstring(struct ast_channel *c, char *s, int len, int timeout, int rtimeout, char *enders);
+#define CHECK_BLOCKING(c) { 	 \
+							if ((c)->blocking) \
+								ast_log(LOG_WARNING, "Blocking '%s', already blocked by thread %ld in procedure %s\n", (c)->name, (c)->blocker, (c)->blockproc); \
+							else { \
+								(c)->blocker = pthread_self(); \
+								(c)->blockproc = __PRETTY_FUNCTION__; \
+									c->blocking = -1; } }
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+
+#endif
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/include/asterisk/module.h
===================================================================
--- trunk/include/asterisk/module.h	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/include/asterisk/module.h	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,131 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Module definitions
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_MODULE_H
+#define _ASTERISK_MODULE_H
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+/* Every module must provide these functions */
+
+int load_module(void);			/* Initialize the module */
+int unload_module(void);		/* Cleanup all module structures, 
+					   sockets, etc */
+int usecount(void);			/* How many channels provided by this module are in use? */
+char *description(void);		/* Description of this module */
+
+#define AST_MODULE_CONFIG "modules.conf" /* Module configuration file */
+
+#define AST_FORCE_SOFT 0
+#define AST_FORCE_FIRM 1
+#define AST_FORCE_HARD 2
+
+/* Load a module */
+int ast_load_resource(char *resource_name);
+
+/* Unload a module.  Force unloading a module is not recommended. */
+int ast_unload_resource(char *resource_name, int force);
+
+/* Notify when usecount has been changed */
+void ast_update_use_count(void);
+
+/* Ask for a list of modules, descriptions, and use counts */
+int ast_update_module_list(int (*modentry)(char *module, char *description, int usecnt));
+
+/* Ask this procedure to be run with modules have been updated */
+int ast_loader_register(int (*updater)(void));
+
+/* No longer run me when modules are updated */
+int ast_loader_unregister(int (*updater)(void));
+
+/* Local user routines keep track of which channels are using a given module resource.
+   They can help make removing modules safer, particularly if they're in use at the time
+   they have been requested to be removed */
+
+#define STANDARD_LOCAL_USER struct localuser { \
+								struct ast_channel *chan; \
+								struct localuser *next; \
+							}
+
+#define LOCAL_USER_DECL static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER; \
+						static struct localuser *localusers = NULL; \
+						static int localusecnt = 0;
+
+#define LOCAL_USER_ADD(u) { \
+ \
+	if (!(u=malloc(sizeof(struct localuser)))) { \
+		ast_log(LOG_WARNING, "Out of memory\n"); \
+		return -1; \
+	} \
+	pthread_mutex_lock(&localuser_lock); \
+	u->chan = chan; \
+	u->next = localusers; \
+	localusers = u; \
+	localusecnt++; \
+	pthread_mutex_unlock(&localuser_lock); \
+	ast_update_use_count(); \
+}
+
+#define LOCAL_USER_REMOVE(u) { \
+	struct localuser *uc, *ul = NULL; \
+	pthread_mutex_lock(&localuser_lock); \
+	uc = localusers; \
+	while (uc) { \
+		if (uc == u) { \
+			if (ul) \
+				ul->next = uc->next; \
+			else \
+				localusers = uc->next; \
+			break; \
+		} \
+		ul = uc; \
+		uc = uc->next; \
+	}\
+	free(u); \
+	localusecnt--; \
+	pthread_mutex_unlock(&localuser_lock); \
+	ast_update_use_count(); \
+}
+
+#define STANDARD_HANGUP_LOCALUSERS { \
+	struct localuser *u, *ul; \
+	pthread_mutex_lock(&localuser_lock); \
+	u = localusers; \
+	while(u) { \
+		ast_softhangup(u->chan); \
+		ul = u; \
+		u = u->next; \
+		free(ul); \
+	} \
+	pthread_mutex_unlock(&localuser_lock); \
+	localusecnt=0; \
+}
+
+#define STANDARD_USECOUNT(res) { \
+	pthread_mutex_lock(&localuser_lock); \
+	res = localusecnt; \
+	pthread_mutex_unlock(&localuser_lock); \
+}
+	
+	
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+#endif
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/include/asterisk/say.h
===================================================================
--- trunk/include/asterisk/say.h	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/include/asterisk/say.h	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,36 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Say numbers and dates (maybe words one day too)
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_SAY_H
+#define _ASTERISK_SAY_H
+
+#include <asterisk/channel.h>
+#include <asterisk/file.h>
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+int ast_say_number(struct ast_channel *chan, int num);
+int ast_say_digits(struct ast_channel *chan, int num);
+int ast_say_digit_str(struct ast_channel *chan, char *num);
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/loader.c
===================================================================
--- trunk/loader.c	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/loader.c	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,326 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Module Loader
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <stdio.h>
+#include <dirent.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <asterisk/module.h>
+#include <asterisk/options.h>
+#include <asterisk/config.h>
+#include <asterisk/logger.h>
+#include <dlfcn.h>
+#define __USE_GNU
+#include <pthread.h>
+#include "asterisk.h"
+
+struct module {
+	int (*load_module)(void);
+	int (*unload_module)(void);
+	int (*usecount)(void);
+	char *(*description)(void);
+	void *lib;
+	char resource[256];
+	struct module *next;
+};
+
+static struct loadupdate {
+	int (*updater)(void);
+	struct loadupdate *next;
+} *updaters = NULL;
+
+static pthread_mutex_t modlock = PTHREAD_MUTEX_INITIALIZER;
+
+static struct module *module_list=NULL;
+
+int ast_unload_resource(char *resource_name, int force)
+{
+	struct module *m, *ml = NULL;
+	int res = -1;
+	if (pthread_mutex_lock(&modlock))
+		ast_log(LOG_WARNING, "Failed to lock\n");
+	m = module_list;
+	while(m) {
+		if (!strcasecmp(m->resource, resource_name)) {
+			if ((res = m->usecount()) > 0)  {
+				if (force) 
+					ast_log(LOG_WARNING, "Warning:  Forcing removal of module %s with use count %d\n", resource_name, res);
+				else {
+					ast_log(LOG_WARNING, "Soft unload failed, '%s' has use count %d\n", resource_name, res);
+					pthread_mutex_unlock(&modlock);
+					return -1;
+				}
+			}
+			res = m->unload_module();
+			if (res) {
+				ast_log(LOG_WARNING, "Firm unload failed for %s\n", resource_name);
+				if (force <= AST_FORCE_FIRM) {
+					pthread_mutex_unlock(&modlock);
+					return -1;
+				} else
+					ast_log(LOG_WARNING, "** Dangerous **: Unloading resource anyway, at user request\n");
+			}
+			if (ml)
+				ml->next = m->next;
+			else
+				module_list = m->next;
+			dlclose(m->lib);
+			free(m);
+		}
+		ml = m;
+		m = m->next;
+	}
+	pthread_mutex_unlock(&modlock);
+	ast_update_use_count();
+	return res;
+}
+
+int ast_load_resource(char *resource_name)
+{
+	static char fn[256];
+	int errors=0;
+	int res;
+	struct module *m = malloc(sizeof(struct module));
+	if (!m) {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	strncpy(m->resource, resource_name, sizeof(m->resource));
+	if (resource_name[0] == '/') {
+		strncpy(fn, resource_name, sizeof(fn));
+	} else {
+		snprintf(fn, sizeof(fn), "%s/%s", AST_MODULE_DIR, resource_name);
+	}
+	m->lib = dlopen(fn, RTLD_NOW  | RTLD_GLOBAL);
+	if (!m->lib) {
+		ast_log(LOG_WARNING, "%s\n", dlerror());
+		free(m);
+		return -1;
+	}
+	m->load_module = dlsym(m->lib, "load_module");
+	if (!m->load_module) {
+		ast_log(LOG_WARNING, "No load_module in module %s\n", fn);
+		errors++;
+	}
+	m->unload_module = dlsym(m->lib, "unload_module");
+	if (!m->unload_module) {
+		ast_log(LOG_WARNING, "No unload_module in module %s\n", fn);
+		errors++;
+	}
+	m->usecount = dlsym(m->lib, "usecount");
+	if (!m->usecount) {
+		ast_log(LOG_WARNING, "No usecount in module %s\n", fn);
+		errors++;
+	}
+	m->description = dlsym(m->lib, "description");
+	if (!m->description) {
+		ast_log(LOG_WARNING, "No description in module %s\n", fn);
+		errors++;
+	}
+	if (errors) {
+		ast_log(LOG_WARNING, "%d error(s) loading module %s, aborted\n", errors, fn);
+		dlclose(m->lib);
+		free(m);
+		return -1;
+	}
+	if (option_verbose) 
+		ast_verbose( " => (%s)\n", m->description());
+	if ((res = m->load_module())) {
+		ast_log(LOG_WARNING, "%s: load_module failed, returning %d\n", m->resource, fn, res);
+		free(m);
+		return -1;
+	}
+	if (pthread_mutex_lock(&modlock))
+		ast_log(LOG_WARNING, "Failed to lock\n");
+	m->next = module_list;
+	module_list = m;
+	pthread_mutex_unlock(&modlock);
+	ast_update_use_count();
+	return 0;
+}	
+
+int ast_resource_exists(char *resource)
+{
+	struct module *m;
+	if (pthread_mutex_lock(&modlock))
+		ast_log(LOG_WARNING, "Failed to lock\n");
+	m = module_list;
+	while(m) {
+		if (!strcasecmp(resource, m->resource))
+			break;
+		m = m->next;
+	}
+	pthread_mutex_unlock(&modlock);
+	if (m)
+		return -1;
+	else
+		return 0;
+}
+
+int load_modules()
+{
+	struct ast_config *cfg;
+	struct ast_variable *v;
+	if (option_verbose) 
+		ast_verbose( "Asterisk Dynamic Loader Starting:\n");
+	cfg = ast_load(AST_MODULE_CONFIG);
+	if (cfg) {
+		/* Load explicitly defined modules */
+		v = ast_variable_browse(cfg, "modules");
+		while(v) {
+			if (!strcasecmp(v->name, "load")) {
+				if (option_debug && !option_verbose)
+					ast_log(LOG_DEBUG, "Loading module %s\n", v->value);
+				if (option_verbose) {
+					ast_verbose( " [%s]", v->value);
+					fflush(stdout);
+				}
+				if (ast_load_resource(v->value)) {
+					ast_log(LOG_WARNING, "Loading module %s failed!\n", v->value);
+					if (cfg)
+						ast_destroy(cfg);
+					return -1;
+				}
+			}
+			v=v->next;
+		}
+	}
+	if (!cfg || ast_true(ast_variable_retrieve(cfg, "modules", "autoload"))) {
+		/* Load all modules */
+		DIR *mods;
+		struct dirent *d;
+		mods = opendir(AST_MODULE_DIR);
+		if (mods) {
+			while((d = readdir(mods))) {
+				/* Must end in .so to load it.  */
+				if ((strlen(d->d_name) > 3) && 
+				    !strcasecmp(d->d_name + strlen(d->d_name) - 3, ".so") &&
+					!ast_resource_exists(d->d_name)) {
+					/* It's a shared library -- Just be sure we're allowed to load it -- kinda
+					   an inefficient way to do it, but oh well. */
+					if (cfg) {
+						v = ast_variable_browse(cfg, "modules");
+						while(v) {
+							if (!strcasecmp(v->name, "noload") &&
+							    !strcasecmp(v->value, d->d_name)) 
+								break;
+							v = v->next;
+						}
+						if (v) {
+							if (option_verbose) {
+								ast_verbose( VERBOSE_PREFIX_1 "[skipping %s]\n", d->d_name);
+								fflush(stdout);
+							}
+							continue;
+						}
+						
+					}
+				    if (option_debug && !option_verbose)
+						ast_log(LOG_DEBUG, "Loading module %s\n", d->d_name);
+					if (option_verbose) {
+						ast_verbose( VERBOSE_PREFIX_1 "[%s]", d->d_name);
+						fflush(stdout);
+					}
+					if (ast_load_resource(d->d_name)) {
+						ast_log(LOG_WARNING, "Loading module %s failed!\n", d->d_name);
+						if (cfg)
+							ast_destroy(cfg);
+						return -1;
+					}
+				}
+			};
+		} else {
+			if (!option_quiet)
+				ast_log(LOG_WARNING, "Unable to open modules directory " AST_MODULE_DIR ".\n");
+		}
+	} 
+	ast_destroy(cfg);
+	return 0;
+}
+
+void ast_update_use_count(void)
+{
+	/* Notify any module monitors that the use count for a 
+	   resource has changed */
+	struct loadupdate *m;
+	if (pthread_mutex_lock(&modlock))
+		ast_log(LOG_WARNING, "Failed to lock\n");
+	m = updaters;
+	while(m) {
+		m->updater();
+		m = m->next;
+	}
+	pthread_mutex_unlock(&modlock);
+	
+}
+
+int ast_update_module_list(int (*modentry)(char *module, char *description, int usecnt))
+{
+	struct module *m;
+	int unlock = -1;
+	if (pthread_mutex_trylock(&modlock))
+		unlock = 0;
+	m = module_list;
+	while(m) {
+		modentry(m->resource, m->description(), m->usecount());
+		m = m->next;
+	}
+	if (unlock)
+		pthread_mutex_unlock(&modlock);
+	return 0;
+}
+
+int ast_loader_register(int (*v)(void)) 
+{
+	struct loadupdate *tmp;
+	/* XXX Should be more flexible here, taking > 1 verboser XXX */
+	if ((tmp = malloc(sizeof (struct loadupdate)))) {
+		tmp->updater = v;
+		if (pthread_mutex_lock(&modlock))
+			ast_log(LOG_WARNING, "Failed to lock\n");
+		tmp->next = updaters;
+		updaters = tmp;
+		pthread_mutex_unlock(&modlock);
+		return 0;
+	}
+	return -1;
+}
+
+int ast_loader_unregister(int (*v)(void))
+{
+	int res = -1;
+	struct loadupdate *tmp, *tmpl=NULL;
+	if (pthread_mutex_lock(&modlock))
+		ast_log(LOG_WARNING, "Failed to lock\n");
+	tmp = updaters;
+	while(tmp) {
+		if (tmp->updater == v)	{
+			if (tmpl)
+				tmpl->next = tmp->next;
+			else
+				updaters = tmp->next;
+			break;
+		}
+		tmpl = tmp;
+		tmp = tmp->next;
+	}
+	if (tmp)
+		res = 0;
+	pthread_mutex_unlock(&modlock);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/pbx/pbx_gtkconsole.c
===================================================================
--- trunk/pbx/pbx_gtkconsole.c	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/pbx/pbx_gtkconsole.c	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,391 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * GTK Console monitor -- very kludgy right now
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+/* 
+ * I know this might seem somewhat pointless in its current phase, but one
+ * of the most important parts of this module is demonstrate that modules
+ * can require other external libraries and still be loaded (in this
+ * case, a host of libraries involving gtk), so long as they are properly
+ * linked (see the Makefile)
+ */
+
+
+#include <asterisk/pbx.h>
+#include <asterisk/config.h>
+#include <asterisk/module.h>
+#include <asterisk/logger.h>
+#include <asterisk/options.h>
+#include <stdlib.h>
+#include <fcntl.h>
+#include <unistd.h>
+#include <stdio.h>
+#include <string.h>
+#include <stdarg.h>
+
+#include <gtk/gtk.h>
+#include <glib.h>
+/* For where to put dynamic tables */
+#include "../asterisk.h"
+
+static pthread_mutex_t verb_lock = PTHREAD_MUTEX_INITIALIZER;
+
+static pthread_t console_thread;
+
+static int inuse=0;
+static char *dtext = "Asterisk PBX Console (GTK Version)";
+
+static GtkWidget *window;
+static GtkWidget *quit;
+static GtkWidget *closew;
+static GtkWidget *verb;
+static GtkWidget *modules;
+static GtkWidget *statusbar;
+
+static void update_statusbar(char *msg)
+{
+	gtk_statusbar_pop(GTK_STATUSBAR(statusbar), 1);
+	gtk_statusbar_push(GTK_STATUSBAR(statusbar), 1, msg);
+}
+
+int unload_module(void)
+{
+	if (inuse) {
+		/* Kill off the main thread */
+		pthread_cancel(console_thread);
+		gdk_threads_enter();
+		gtk_widget_destroy(window);
+		gdk_threads_leave();
+	}
+	return 0;
+}
+
+
+static void verboser(char *stuff, int opos, int replacelast, int complete)
+{
+	char *s2[2];
+	pthread_mutex_lock(&verb_lock);
+	s2[0] = stuff;
+	s2[1] = NULL;
+	gdk_threads_enter();
+	if (replacelast) 
+		gtk_clist_remove(GTK_CLIST(verb), GTK_CLIST(verb)->rows - 1);
+	gtk_clist_append(GTK_CLIST(verb), s2);
+	gtk_clist_moveto(GTK_CLIST(verb), GTK_CLIST(verb)->rows - 1, 0, 0, 0);
+	gdk_threads_leave();
+	pthread_mutex_unlock(&verb_lock);
+}
+
+static void remove_module()
+{
+	int res;
+	char *module;
+	char buf[256];
+	if (GTK_CLIST(modules)->selection) {
+		module= (char *)gtk_clist_get_row_data(GTK_CLIST(modules), (int) GTK_CLIST(modules)->selection->data);
+		gdk_threads_leave();
+		res = ast_unload_resource(module, 0);
+		gdk_threads_enter();
+		if (res) {
+			snprintf(buf, sizeof(buf), "Module '%s' is in use", module);
+			update_statusbar(buf);
+		} else {
+			snprintf(buf, sizeof(buf), "Module '%s' removed", module);
+			update_statusbar(buf);
+		}
+	}
+}
+static void reload_module()
+{
+	int res, x;
+	char *module;
+	char buf[256];
+	if (GTK_CLIST(modules)->selection) {
+		module= (char *)gtk_clist_get_row_data(GTK_CLIST(modules), (int) GTK_CLIST(modules)->selection->data);
+		module = strdup(module);
+		if (module) {
+			gdk_threads_leave();
+			res = ast_unload_resource(module, 0);
+			gdk_threads_enter();
+			if (res) {
+				snprintf(buf, sizeof(buf), "Module '%s' is in use", module);
+				update_statusbar(buf);
+			} else {
+				gdk_threads_leave();
+				res = ast_load_resource(module);
+				gdk_threads_enter();
+				if (res) {
+					snprintf(buf, sizeof(buf), "Error reloading module '%s'", module);
+				} else {
+					snprintf(buf, sizeof(buf), "Module '%s' reloaded", module);
+				}
+				for (x=0; x < GTK_CLIST(modules)->rows; x++) {
+					if (!strcmp((char *)gtk_clist_get_row_data(GTK_CLIST(modules), x), module)) {
+						gtk_clist_select_row(GTK_CLIST(modules), x, -1);
+						break;
+					}
+				}
+				update_statusbar(buf);
+				
+			}
+			free(module);
+		}
+	}
+}
+
+static void file_ok_sel(GtkWidget *w, GtkFileSelection *fs)
+{
+	char *module = gtk_file_selection_get_filename(fs);
+	char buf[256];
+	if (!strncmp(module, AST_MODULE_DIR "/", strlen(AST_MODULE_DIR "/"))) 
+		module += strlen(AST_MODULE_DIR "/");
+	gdk_threads_leave();
+	if (ast_load_resource(module)) {
+		snprintf(buf, sizeof(buf), "Error loading module '%s'.", module);
+		update_statusbar(buf);
+	} else {
+		snprintf(buf, sizeof(buf), "Module '%s' loaded", module);
+		update_statusbar(buf);
+	}
+	gdk_threads_enter();
+	gtk_widget_destroy(GTK_WIDGET(fs));
+}
+
+static void add_module()
+{
+	GtkWidget *filew;
+	filew = gtk_file_selection_new("Load Module");
+	gtk_signal_connect(GTK_OBJECT (GTK_FILE_SELECTION(filew)->ok_button),
+					"clicked", GTK_SIGNAL_FUNC(file_ok_sel), filew);
+	gtk_signal_connect_object(GTK_OBJECT (GTK_FILE_SELECTION(filew)->cancel_button),
+					"clicked", GTK_SIGNAL_FUNC(gtk_widget_destroy), GTK_OBJECT(filew));
+	gtk_file_selection_set_filename(GTK_FILE_SELECTION(filew), AST_MODULE_DIR "/*.so");
+	gtk_widget_show(filew);
+}
+
+static int add_mod(char *module, char *description, int usecount)
+{
+	char use[10];
+	char *pass[4];
+	int row;
+	snprintf(use, sizeof(use), "%d", usecount);
+	pass[0] = module;
+	pass[1] = description;
+	pass[2] = use;
+	pass[3] = NULL;
+	row = gtk_clist_append(GTK_CLIST(modules), pass);
+	gtk_clist_set_row_data(GTK_CLIST(modules), row, module);
+	return 0;	
+}
+
+static int mod_update(void)
+{
+	char *module= NULL;
+	/* Update the mod stuff */
+	if (GTK_CLIST(modules)->selection) {
+		module= (char *)gtk_clist_get_row_data(GTK_CLIST(modules), (int) GTK_CLIST(modules)->selection->data);
+	}
+	gdk_threads_enter();
+	gtk_clist_freeze(GTK_CLIST(modules));
+	gtk_clist_clear(GTK_CLIST(modules));
+	ast_update_module_list(add_mod);
+	if (module)
+		gtk_clist_select_row(GTK_CLIST(modules), gtk_clist_find_row_from_data(GTK_CLIST(modules), module), -1);
+	gtk_clist_thaw(GTK_CLIST(modules));
+	gdk_threads_leave();
+	return 1;
+}
+
+static void exit_now(GtkWidget *widget, gpointer data)
+{
+	ast_loader_unregister(mod_update);
+	gtk_main_quit();
+	inuse--;
+	ast_update_use_count();
+	ast_unregister_verbose(verboser);
+	ast_unload_resource("pbx_gtkconsole", 0);
+	if (option_verbose > 1)
+		ast_verbose(VERBOSE_PREFIX_2 "GTK Console Monitor Exiting\n");
+		
+}
+
+static void exit_completely(GtkWidget *widget, gpointer data)
+{
+	/* This is the wrong way to do this.  We need an ast_clean_exit() routine */
+	exit(0);
+}
+
+static void exit_nicely(GtkWidget *widget, gpointer data)
+{
+	fflush(stdout);
+	gtk_widget_destroy(window);
+}
+
+static void *consolethread(void *data)
+{
+	gtk_widget_show(window);
+	gdk_threads_enter();
+	gtk_main();
+	gdk_threads_leave();
+	return NULL;
+}
+
+static int show_console()
+{
+	GtkWidget *hbox;
+	GtkWidget *wbox;
+	GtkWidget *notebook;
+	GtkWidget *sw;
+	GtkWidget *bbox, *hbbox, *add, *removew, *reloadw;
+	char *modtitles[3] = { "Module", "Description", "Use Count" };
+	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
+	
+	statusbar = gtk_statusbar_new();
+	gtk_widget_show(statusbar);
+	
+	gtk_signal_connect(GTK_OBJECT(window), "delete_event",
+			GTK_SIGNAL_FUNC (exit_nicely), window);
+	gtk_signal_connect(GTK_OBJECT(window), "destroy",
+			GTK_SIGNAL_FUNC (exit_now), window);
+	gtk_container_set_border_width(GTK_CONTAINER(window), 10);
+
+	quit = gtk_button_new_with_label("Quit Asterisk");
+	gtk_signal_connect(GTK_OBJECT(quit), "clicked",
+			GTK_SIGNAL_FUNC (exit_completely), window);
+	gtk_widget_show(quit);
+
+	closew = gtk_button_new_with_label("Close Window");
+	gtk_signal_connect(GTK_OBJECT(closew), "clicked",
+			GTK_SIGNAL_FUNC (exit_nicely), window);
+	gtk_widget_show(closew);
+
+	notebook = gtk_notebook_new();
+	verb = gtk_clist_new(1);
+	gtk_clist_columns_autosize(GTK_CLIST(verb));
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+	gtk_container_add(GTK_CONTAINER(sw), verb);
+	gtk_widget_show(verb);
+	gtk_widget_show(sw);
+	gtk_widget_set_usize(verb, 600, 400);
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), sw, gtk_label_new("Verbose Status"));
+
+	
+	modules = gtk_clist_new_with_titles(3, modtitles);
+	gtk_clist_columns_autosize(GTK_CLIST(modules));
+	gtk_clist_set_column_auto_resize(GTK_CLIST(modules), 0, TRUE);
+	gtk_clist_set_column_auto_resize(GTK_CLIST(modules), 1, TRUE);
+	gtk_clist_set_column_auto_resize(GTK_CLIST(modules), 2, TRUE);
+	gtk_clist_set_sort_column(GTK_CLIST(modules), 0);
+	gtk_clist_set_auto_sort(GTK_CLIST(modules), TRUE);
+	gtk_clist_column_titles_passive(GTK_CLIST(modules));
+	sw = gtk_scrolled_window_new(NULL, NULL);
+	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
+	gtk_container_add(GTK_CONTAINER(sw), modules);
+	gtk_clist_set_selection_mode(GTK_CLIST(modules), GTK_SELECTION_BROWSE);
+	gtk_widget_show(modules);
+	gtk_widget_show(sw);
+
+	add = gtk_button_new_with_label("Load...");
+	gtk_widget_show(add);
+	removew = gtk_button_new_with_label("Unload");
+	gtk_widget_show(removew);
+	reloadw = gtk_button_new_with_label("Reload");
+	gtk_widget_show(reloadw);
+	gtk_signal_connect(GTK_OBJECT(removew), "clicked",
+			GTK_SIGNAL_FUNC (remove_module), window);
+	gtk_signal_connect(GTK_OBJECT(add), "clicked",
+			GTK_SIGNAL_FUNC (add_module), window);
+	gtk_signal_connect(GTK_OBJECT(reloadw), "clicked",
+			GTK_SIGNAL_FUNC (reload_module), window);
+		
+	bbox = gtk_vbox_new(FALSE, 5);
+	gtk_widget_show(bbox);
+
+	gtk_widget_set_usize(bbox, 100, -1);
+	gtk_box_pack_start(GTK_BOX(bbox), add, FALSE, FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(bbox), removew, FALSE, FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(bbox), reloadw, FALSE, FALSE, 5);
+
+	hbbox = gtk_hbox_new(FALSE, 5);
+	gtk_widget_show(hbbox);
+	
+	gtk_box_pack_start(GTK_BOX(hbbox), sw, TRUE, TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbbox), bbox, FALSE, FALSE, 5);
+
+	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), hbbox, gtk_label_new("Module Information"));
+
+	gtk_widget_show(notebook);
+
+	wbox = gtk_hbox_new(FALSE, 5);
+	gtk_widget_show(wbox);
+	gtk_box_pack_end(GTK_BOX(wbox), quit, FALSE, FALSE, 5);
+	gtk_box_pack_end(GTK_BOX(wbox), closew, FALSE, FALSE, 5);
+
+	hbox = gtk_vbox_new(FALSE, 0);
+	gtk_widget_show(hbox);
+
+	gtk_box_pack_start(GTK_BOX(hbox), notebook, TRUE, TRUE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), wbox, FALSE, FALSE, 5);
+	gtk_box_pack_start(GTK_BOX(hbox), statusbar, FALSE, FALSE, 0);
+
+
+	gtk_container_add(GTK_CONTAINER(window), hbox);
+	gtk_window_set_title(GTK_WINDOW(window), "Asterisk Console");
+	pthread_create(&console_thread, NULL, consolethread, NULL);
+	/* XXX Okay, seriously fix me! XXX */
+	usleep(100000);
+	ast_register_verbose(verboser);
+	gtk_clist_freeze(GTK_CLIST(verb));
+	ast_loader_register(mod_update);
+	gtk_clist_thaw(GTK_CLIST(verb));
+	mod_update();
+	update_statusbar("Asterisk Console Ready");
+	return 0;
+}
+
+
+int load_module(void)
+{
+	g_thread_init(NULL);
+	if (gtk_init_check(NULL, NULL))  {
+		/* XXX Do we need to call this twice? XXX */
+		gtk_init(NULL, NULL);
+		if (!show_console()) {
+			inuse++;
+			ast_update_use_count();
+			if (option_verbose > 1)
+				ast_verbose( VERBOSE_PREFIX_2 "Launched GTK Console monitor\n");		
+		} else
+			ast_log(LOG_WARNING, "Unable to start GTK console\n");
+	} else {
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Unable to start GTK console monitor -- ignoring\n");
+		else if (option_verbose > 1)
+			ast_verbose( VERBOSE_PREFIX_2 "GTK is not available -- skipping monitor\n");
+	}
+	return 0;
+}
+
+int usecount(void)
+{
+	return inuse;
+}
+
+char *description(void)
+{
+	return dtext;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/pbx/pbx_kdeconsole.cc
===================================================================
--- trunk/pbx/pbx_kdeconsole.cc	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/pbx/pbx_kdeconsole.cc	2006-06-28 05:25:29 UTC (rev 417)
@@ -3,6 +3,67 @@
  *
  * KDE Console monitor -- Class implmementation
  * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include "pbx_kdeconsole.moc"
+
+KAsteriskConsole::KAsteriskConsole() : KTMainWindow()
+{
+	QVBoxLayout *box;
+	QFrame *f;
+	
+	f = new QFrame(this);
+	
+	setGeometry(100,100,600,400);
+	/* Menus */
+	file = new QPopupMenu();
+	file->insertItem("&Exit", this, SLOT(slotExit()));
+	
+	help = kapp->getHelpMenu(TRUE, "KDE Asterisk Console\nby Mark Spencer");
+	
+	setCaption("Asterisk Console");
+	
+	/* Box */
+	box = new QVBoxLayout(f, 20, 5);
+	
+	/* Menu bar creation */
+	menu = new KMenuBar(this);
+	menu->insertItem("&File", file);
+	menu->insertItem("&Help", help);
+	/* Verbose stuff */
+	verbose = new QListBox(f, "verbose");
+	/* Exit button */
+	btnExit = new QPushButton("Exit", f, "exit");
+	btnExit->show();
+	connect(btnExit,  SIGNAL(clicked()), this, SLOT(slotExit()));
+	
+	box->addWidget(verbose, 1);
+	box->addWidget(btnExit, 0);
+	setView(f, TRUE);
+	statusBar()->message("Ready", 2000);
+}
+
+void KAsteriskConsole::slotExit()
+{
+	close();
+}
+
+void KAsteriskConsole::closeEvent(QCloseEvent *)
+{
+	kapp->quit();
+}
+
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * KDE Console monitor -- Class implmementation
+ * 
  * Copyright (C) 1999, Mark Spencer
  *
  * Mark Spencer <markster at linux-support.net>

Modified: trunk/pbx/pbx_kdeconsole.h
===================================================================
--- trunk/pbx/pbx_kdeconsole.h	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/pbx/pbx_kdeconsole.h	2006-06-28 05:25:29 UTC (rev 417)
@@ -3,6 +3,43 @@
  *
  * KDE Console monitor -- Header file
  * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <kapp.h>
+#include <ktmainwindow.h>
+#include <qpushbutton.h>
+#include <kmenubar.h>
+#include <qpopupmenu.h>
+#include <qlistbox.h>
+#include <qlayout.h>
+#include <qframe.h>
+
+class KAsteriskConsole : public KTMainWindow
+{
+	Q_OBJECT
+public:
+	KAsteriskConsole();
+	void closeEvent(QCloseEvent *);
+	QListBox *verbose;
+public slots:
+	void slotExit();
+private:
+	void KAsteriskConsole::verboser(char *stuff, int opos, int replacelast, int complete);
+	QPushButton *btnExit;
+	KMenuBar *menu;
+	QPopupMenu *file, *help;
+};
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * KDE Console monitor -- Header file
+ * 
  * Copyright (C) 1999, Mark Spencer
  *
  * Mark Spencer <markster at linux-support.net>

Modified: trunk/pbx/pbx_kdeconsole_main.cc
===================================================================
--- trunk/pbx/pbx_kdeconsole_main.cc	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/pbx/pbx_kdeconsole_main.cc	2006-06-28 05:25:29 UTC (rev 417)
@@ -3,6 +3,87 @@
  *
  * KDE Console monitor -- Mostly glue code
  * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/module.h>
+#include <asterisk/channel.h>
+#include <asterisk/logger.h>
+#include <pthread.h>
+#include "pbx_kdeconsole.h"
+
+static char *dtext = "KDE Console Monitor";
+
+static int inuse = 0;
+
+static KAsteriskConsole *w;
+
+static void verboser(char *stuff, int opos, int replacelast, int complete)
+{
+	const char *s2[2];
+	s2[0] = stuff;
+	s2[1] = NULL;
+	if (replacelast)  {
+		printf("Removing %d\n", w->verbose->count());
+		w->verbose->removeItem(w->verbose->count());
+	}
+	w->verbose->insertStrList(s2, 1, -1);
+	w->verbose->setBottomItem(w->verbose->count());
+}
+
+static int kde_main(int argc, char *argv[])
+{
+	KApplication a ( argc, argv );
+	w = new KAsteriskConsole();
+	a.setMainWidget(w);
+	w->show();
+	ast_register_verbose(verboser);
+	return a.exec();
+}
+
+static void *kdemain(void *data)
+{
+	/* It would appear kde really wants to be main */;
+	char *argv[1] = { "asteriskconsole" };
+	kde_main(1, argv);
+	return NULL;
+}
+
+extern "C" {
+
+int unload_module(void)
+{
+	return inuse;
+}
+
+int load_module(void)
+{
+	pthread_t t;
+	pthread_create(&t, NULL, kdemain, NULL);
+	return 0;
+}
+
+int usecount(void)
+{
+	return inuse;
+}
+
+char *description(void)
+{
+	return dtext;
+}
+
+}
+/*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * KDE Console monitor -- Mostly glue code
+ * 
  * Copyright (C) 1999, Mark Spencer
  *
  * Mark Spencer <markster at linux-support.net>

Modified: trunk/say.c
===================================================================
--- trunk/say.c	2006-06-28 03:25:40 UTC (rev 416)
+++ trunk/say.c	2006-06-28 05:25:29 UTC (rev 417)
@@ -1,4 +1,71 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Say numbers and dates (maybe words one day too)
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/file.h>
+#include <asterisk/channel.h>
+#include <asterisk/logger.h>
+#include <asterisk/say.h>
+#include <stdio.h>
+
+int ast_say_digit_str(struct ast_channel *chan, char *fn2)
+{
+	char fn[256] = "";
+	int num = 0;
+	int res = 0;
+	while(fn2[num] && !res) {
+		snprintf(fn, sizeof(fn), "digits/%c", fn2[num]);
+		res = ast_streamfile(chan, fn);
+		if (!res) 
+			res = ast_waitstream(chan, AST_DIGIT_ANY);
+		ast_stopstream(chan);
+		num++;
+	}
+	return res;
+}
+
+int ast_say_digits(struct ast_channel *chan, int num)
+{
+	char fn2[256];
+	snprintf(fn2, sizeof(fn2), "%d", num);
+	return ast_say_digit_str(chan, fn2);
+}
+int ast_say_number(struct ast_channel *chan, int num)
+{
+	int res = 0;
+	char fn[256] = "";
+	while(num && !res) {
+		if (num < 20) {
+			snprintf(fn, sizeof(fn), "digits/%d", num);
+			num = 0;
+		} else
+		if (num < 100) {
+			snprintf(fn, sizeof(fn), "digits/%d", (num /10) * 10);
+			num -= ((num / 10) * 10);
+		} else {
+			ast_log(LOG_DEBUG, "Number '%d' is too big for me\n", num);
+			res = -1;
+		}
+		if (!res) {
+			res = ast_streamfile(chan, fn);
+			if (!res) 
+				res = ast_waitstream(chan, AST_DIGIT_ANY);
+			ast_stopstream(chan);
+		}
+		
+	}
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 08:26:13 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 08:26:13 +0200
Subject: [solid-pbx-svn] r418 - in trunk: . apps codecs codecs/gsm codecs/gsm/inc codecs/gsm/src
Message-ID: <200606280626.k5S6QDBj032694@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 08:25:21 +0200 (Wed, 28 Jun 2006)
New Revision: 418

Modified:
   trunk/apps/app_mp3.c
   trunk/asterisk.c
   trunk/codecs/codec_gsm.c
   trunk/codecs/gsm/COPYRIGHT
   trunk/codecs/gsm/README
   trunk/codecs/gsm/inc/config.h
   trunk/codecs/gsm/inc/gsm.h
   trunk/codecs/gsm/inc/private.h
   trunk/codecs/gsm/inc/proto.h
   trunk/codecs/gsm/src/add.c
   trunk/codecs/gsm/src/code.c
   trunk/codecs/gsm/src/debug.c
   trunk/codecs/gsm/src/decode.c
   trunk/codecs/gsm/src/gsm_create.c
   trunk/codecs/gsm/src/gsm_decode.c
   trunk/codecs/gsm/src/gsm_destroy.c
   trunk/codecs/gsm/src/gsm_encode.c
   trunk/codecs/gsm/src/gsm_explode.c
   trunk/codecs/gsm/src/gsm_implode.c
   trunk/codecs/gsm/src/gsm_option.c
   trunk/codecs/gsm/src/gsm_print.c
   trunk/codecs/gsm/src/long_term.c
   trunk/codecs/gsm/src/lpc.c
   trunk/codecs/gsm/src/preprocess.c
   trunk/codecs/gsm/src/rpe.c
   trunk/codecs/gsm/src/short_term.c
   trunk/codecs/gsm/src/table.c
   trunk/codecs/slin_gsm_ex.h
Log:
Update to Asterisk SVN trunk r30

------------------------------------------------------------------------
r21 | markster | 1999-11-15 05:57:28 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r22 | markster | 1999-11-15 06:04:48 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r23 | markster | 1999-11-15 07:08:50 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r24 | markster | 1999-11-15 07:08:52 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.1 from FTP

------------------------------------------------------------------------
r25 | markster | 1999-11-15 07:08:53 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.2 from FTP

------------------------------------------------------------------------
r26 | markster | 1999-11-15 07:08:53 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------
r27 | markster | 1999-11-15 07:08:54 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------
r28 | markster | 1999-11-15 07:08:55 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.4 from FTP

------------------------------------------------------------------------
r29 | markster | 1999-11-15 07:08:56 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.5 from FTP

------------------------------------------------------------------------
r30 | markster | 1999-11-15 07:08:57 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.6 from FTP

------------------------------------------------------------------------


Modified: trunk/apps/app_mp3.c
===================================================================
--- trunk/apps/app_mp3.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/apps/app_mp3.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,4 +1,197 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Silly application to play an MP3 file -- uses mpg123
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/frame.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/translate.h>
+#include <string.h>
+#include <stdio.h>
+#include <signal.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <sys/time.h>
+
+#define MPG_123 "/usr/bin/mpg123"
+
+static char *tdesc = "Silly MP3 Application";
+
+static char *app = "MP3Player";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int mp3play(char *filename, int fd)
+{
+	int res;
+	res = fork();
+	if (res < 0) 
+		ast_log(LOG_WARNING, "Fork failed\n");
+	if (res)
+		return res;
+	dup2(fd, STDOUT_FILENO);
+	/* Execute mpg123, but buffer if it's a net connection */
+	if (strncmp(filename, "http://", 7)) 
+	    execl(MPG_123, MPG_123, "-q", "-s", "-b", "1024", "--mono", "-r", "8000", filename, NULL);
+	else
+	    execl(MPG_123, MPG_123, "-q", "-s", "--mono", "-r", "8000", filename, NULL);
+	ast_log(LOG_WARNING, "Execute of mpg123 failed\n");
+	return -1;
+}
+
+static int mp3_exec(struct ast_channel *chan, void *data)
+{
+	int res=0;
+	struct localuser *u;
+	struct ast_channel *trans;
+	int fds[2];
+	int rfds[2];
+	int ms = -1;
+	int pid;
+	int us;
+	struct timeval tv;
+	struct timeval last;
+	struct ast_frame *f;
+	struct myframe {
+		struct ast_frame f;
+		char offset[AST_FRIENDLY_OFFSET];
+		char frdata[160];
+	} myf;
+	last.tv_usec = 0;
+	last.tv_sec = 0;
+	if (!data) {
+		ast_log(LOG_WARNING, "MP3 Playback requires an argument (filename)\n");
+		return -1;
+	}
+	if (pipe(fds)) {
+		ast_log(LOG_WARNING, "Unable to create pipe\n");
+		return -1;
+	}
+	LOCAL_USER_ADD(u);
+	ast_stopstream(chan);
+	if (chan->format & AST_FORMAT_SLINEAR)
+		trans = chan;
+	else
+		trans = ast_translator_create(chan, AST_FORMAT_SLINEAR, AST_DIRECTION_OUT);
+	if (trans) {
+		res = mp3play((char *)data, fds[1]);
+		if (res >= 0) {
+			pid = res;
+			/* Order is important -- there's almost always going to be mp3...  we want to prioritize the
+			   user */
+			rfds[0] = trans->fd;
+			rfds[1] = fds[0];
+			for (;;) {
+				CHECK_BLOCKING(trans);
+				res = ast_waitfor_n_fd(rfds, 2, &ms);
+				trans->blocking = 0;
+				if (res < 1) {
+					ast_log(LOG_DEBUG, "Hangup detected\n");
+					res = -1;
+					break;
+				} else if (res == trans->fd) {
+					f = ast_read(trans);
+					if (!f) {
+						ast_log(LOG_DEBUG, "Null frame == hangup() detected\n");
+						res = -1;
+						break;
+					}
+					if (f->frametype == AST_FRAME_DTMF) {
+						ast_log(LOG_DEBUG, "User pressed a key\n");
+						ast_frfree(f);
+						res = 0;
+						break;
+					}
+					ast_frfree(f);
+				} else if (res == fds[0]) {
+					gettimeofday(&tv, NULL);
+					if (last.tv_sec || last.tv_usec) {
+						/* We should wait at least a frame length */
+						us = sizeof(myf.frdata) / 16 * 1000;
+						/* Subtract 1,000,000 us for each second late we've passed */
+						us -= (tv.tv_sec - last.tv_sec) * 1000000;
+						/* And one for each us late we've passed */
+						us -= (tv.tv_usec - last.tv_usec);
+						/* Sleep that long if needed */
+						if (us > 0)
+							usleep(us);
+					}
+					last = tv;
+					res = read(fds[0], myf.frdata, sizeof(myf.frdata));
+					if (res > 0) {
+						myf.f.frametype = AST_FRAME_VOICE;
+						myf.f.subclass = AST_FORMAT_SLINEAR;
+						myf.f.datalen = res;
+						myf.f.timelen = res / 16;
+						myf.f.mallocd = 0;
+						myf.f.offset = AST_FRIENDLY_OFFSET;
+						myf.f.src = __PRETTY_FUNCTION__;
+						myf.f.data = myf.frdata;
+						if (ast_write(trans, &myf.f) < 0) {
+							res = -1;
+							break;
+						}
+					} else {
+						ast_log(LOG_DEBUG, "No more mp3\n");
+						res = 0;
+					}
+				} else {
+					ast_log(LOG_DEBUG, "HuhHHH?\n");
+					res = -1;
+					break;
+				}
+			}
+			kill(pid, SIGTERM);
+		}
+		if (trans != chan) 
+			ast_translator_destroy(trans);
+	} else 
+		ast_log(LOG_WARNING, "No translator channel available\n");
+	close(fds[0]);
+	close(fds[1]);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	return ast_register_application(app, mp3_exec);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/asterisk.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,4 +1,98 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Top level source file for asterisk
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <unistd.h>
+#include <stdlib.h>
+#include <asterisk/logger.h>
+#include <asterisk/options.h>
+#include <stdio.h>
+#include <signal.h>
+#include "asterisk.h"
+
+int option_verbose=0;
+int option_debug=0;
+int option_nofork=0;
+int option_quiet=0;
+
+static void urg_handler(int num)
+{
+	/* Called by soft_hangup to interrupt the select, read, or other
+	   system call.  We don't actually need to do anything though.  */
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Urgent handler\n");
+	return;
+}
+
+static void quit_handler(int num)
+{
+	/* Called on exit */
+	if (option_verbose)
+		ast_verbose("Asterisk ending (%d).\n", num);
+	else if (option_debug)
+		ast_log(LOG_DEBUG, "Asterisk ending (%d).\n", num);
+	exit(0);
+}
+
+int main(int argc, char *argv[])
+{
+	char c;
+	/* Check if we're root */
+	if (geteuid()) {
+		ast_log(LOG_ERROR, "Must be run as root\n");
+		exit(1);
+	}
+	/* Check for options */
+	while((c=getopt(argc, argv, "dvq")) != EOF) {
+		switch(c) {
+		case 'd':
+			option_debug++;
+			option_nofork++;
+			option_verbose++;
+			break;
+		case 'v':
+			option_verbose++;
+			break;
+		case 'q':
+			option_quiet++;
+			break;
+		case '?':
+			exit(1);
+		}
+	}
+	/* Print a welcome message if desired */
+	if (option_verbose) {
+		ast_verbose( "Asterisk, Copyright (C) 1999 Adtran, Inc. and Linux Support Services, LLC\n");
+		ast_verbose( "Written by Mark Spencer <markster at linux-support.net>\n");
+		ast_verbose( "=========================================================================\n");
+	}
+	signal(SIGURG, urg_handler);
+	signal(SIGINT, quit_handler);
+	signal(SIGTERM, quit_handler);
+	signal(SIGHUP, quit_handler);
+	if (init_logger())
+		exit(1);
+	if (load_pbx())
+		exit(1);
+	if (load_modules())
+		exit(1);
+	/* We might have the option of showing a console, but for now just
+	   do nothing... */
+	if (option_verbose)
+		ast_verbose( "Asterisk Ready.\n");
+	select(0,NULL,NULL,NULL,NULL);
+	return 0;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/codecs/codec_gsm.c
===================================================================
--- trunk/codecs/codec_gsm.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/codec_gsm.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,4 +1,266 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Translate between signed linear and Global System for Mobile Communications (GSM)
+ *
+ * The GSM code is from TOAST.  Copyright information for that package is available
+ * in  the GSM directory.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#define TYPE_SILENCE	 0x2
+#define TYPE_HIGH	 0x0
+#define TYPE_LOW	 0x1
+#define TYPE_MASK	 0x3
+
+#include <asterisk/translate.h>
+#include <asterisk/module.h>
+#include <asterisk/logger.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <stdio.h>
+
+#include "gsm/inc/gsm.h"
+
+/* Sample frame data */
+#include "slin_gsm_ex.h"
+#include "gsm_slin_ex.h"
+
+static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER;
+static int localusecnt=0;
+
+static char *tdesc = "GSM/PCM16 (signed linear) Codec Translator";
+
+struct ast_translator_pvt {
+	gsm gsm;
+	struct ast_frame f;
+	/* Space to build offset */
+	char offset[AST_FRIENDLY_OFFSET];
+	/* Buffer for our outgoing frame */
+	gsm_frame outbuf;
+	/* Enough to store a full second */
+	short buf[8000];
+	int tail;
+};
+
+#define gsm_coder_pvt ast_translator_pvt
+
+static struct ast_translator_pvt *gsm_new()
+{
+	struct gsm_coder_pvt *tmp;
+	tmp = malloc(sizeof(struct gsm_coder_pvt));
+	if (tmp) {
+		if (!(tmp->gsm = gsm_create())) {
+			free(tmp);
+			tmp = NULL;
+		}
+		tmp->tail = 0;
+	}
+	return tmp;
+}
+
+static struct ast_frame *lintogsm_sample()
+{
+	static struct ast_frame f;
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass = AST_FORMAT_SLINEAR;
+	f.datalen = sizeof(slin_gsm_ex);
+	/* Assume 8000 Hz */
+	f.timelen = sizeof(slin_gsm_ex)/16;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data = slin_gsm_ex;
+	return &f;
+}
+
+static struct ast_frame *gsmtolin_sample()
+{
+	static struct ast_frame f;
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass = AST_FORMAT_GSM;
+	f.datalen = sizeof(gsm_slin_ex);
+	/* All frames are 30 ms long */
+	f.timelen = 30;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data = gsm_slin_ex;
+	return &f;
+}
+
+static struct ast_frame *gsmtolin_frameout(struct ast_translator_pvt *tmp)
+{
+	if (!tmp->tail)
+		return NULL;
+	/* Signed linear is no particular frame size, so just send whatever
+	   we have in the buffer in one lump sum */
+	tmp->f.frametype = AST_FRAME_VOICE;
+	tmp->f.subclass = AST_FORMAT_SLINEAR;
+	tmp->f.datalen = tmp->tail * 2;
+	/* Assume 8000 Hz */
+	tmp->f.timelen = tmp->tail / 8;
+	tmp->f.mallocd = 0;
+	tmp->f.offset = AST_FRIENDLY_OFFSET;
+	tmp->f.src = __PRETTY_FUNCTION__;
+	tmp->f.data = tmp->buf;
+	/* Reset tail pointer */
+	tmp->tail = 0;
+
+#if 0
+	/* Save a sample frame */
+	{ static int samplefr = 0;
+	if (samplefr == 80) {
+		int fd;
+		fd = open("gsm.example", O_WRONLY | O_CREAT, 0644);
+		write(fd, tmp->f.data, tmp->f.datalen);
+		close(fd);
+	} 		
+	samplefr++;
+	}
+#endif
+	return &tmp->f;	
+}
+
+static int gsmtolin_framein(struct ast_translator_pvt *tmp, struct ast_frame *f)
+{
+	/* Assuming there's space left, decode into the current buffer at
+	   the tail location */
+	if (tmp->tail + 160 < sizeof(tmp->buf)/2) {	
+		if (gsm_decode(tmp->gsm, f->data, tmp->buf + tmp->tail)) {
+			ast_log(LOG_WARNING, "Invalid GSM data\n");
+			return -1;
+		}
+		tmp->tail+=160;
+	} else {
+		ast_log(LOG_WARNING, "Out of buffer space\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int lintogsm_framein(struct ast_translator_pvt *tmp, struct ast_frame *f)
+{
+	/* Just add the frames to our stream */
+	/* XXX We should look at how old the rest of our stream is, and if it
+	   is too old, then we should overwrite it entirely, otherwise we can
+	   get artifacts of earlier talk that do not belong */
+	if (tmp->tail + f->datalen < sizeof(tmp->buf) / 2) {
+		memcpy(tmp->buf + tmp->tail, f->data, f->datalen);
+		tmp->tail += f->datalen/2;
+	} else {
+		ast_log(LOG_WARNING, "Out of buffer space\n");
+		return -1;
+	}
+	return 0;
+}
+
+static struct ast_frame *lintogsm_frameout(struct ast_translator_pvt *tmp)
+{
+	/* We can't work on anything less than a frame in size */
+	if (tmp->tail < 160)
+		return NULL;
+	/* Encode a frame of data */
+	gsm_encode(tmp->gsm, tmp->buf, tmp->outbuf);
+	tmp->f.frametype = AST_FRAME_VOICE;
+	tmp->f.subclass = AST_FORMAT_GSM;
+	tmp->f.datalen = 33;
+	/* Assume 8000 Hz -- 20 ms */
+	tmp->f.timelen = 20;
+	tmp->f.mallocd = 0;
+	tmp->f.offset = AST_FRIENDLY_OFFSET;
+	tmp->f.src = __PRETTY_FUNCTION__;
+	tmp->f.data = tmp->outbuf;
+	tmp->tail -= 160;
+	/* Move the data at the end of the buffer to the front */
+	if (tmp->tail)
+		memmove(tmp->buf, tmp->buf + 160 * 2, tmp->tail * 2);
+#if 0
+	/* Save a sample frame */
+	{ static int samplefr = 0;
+	if (samplefr == 0) {
+		int fd;
+		fd = open("gsm.example", O_WRONLY | O_CREAT, 0644);
+		write(fd, tmp->f.data, tmp->f.datalen);
+		close(fd);
+	} 		
+	samplefr++;
+	}
+#endif
+	return &tmp->f;	
+}
+
+static void gsm_destroy_stuff(struct ast_translator_pvt *pvt)
+{
+	free(pvt);
+}
+
+static struct ast_translator gsmtolin =
+	{ "gsmtolin", 
+	   AST_FORMAT_GSM, AST_FORMAT_SLINEAR,
+	   gsm_new,
+	   gsmtolin_framein,
+	   gsmtolin_frameout,
+	   gsm_destroy_stuff,
+	   gsmtolin_sample
+	   };
+
+static struct ast_translator lintogsm =
+	{ "lintogsm", 
+	   AST_FORMAT_SLINEAR, AST_FORMAT_GSM,
+	   gsm_new,
+	   lintogsm_framein,
+	   lintogsm_frameout,
+	   gsm_destroy_stuff,
+	   lintogsm_sample
+	   };
+
+int unload_module(void)
+{
+	int res;
+	pthread_mutex_lock(&localuser_lock);
+	res = ast_unregister_translator(&lintogsm);
+	if (!res)
+		res = ast_unregister_translator(&gsmtolin);
+	if (localusecnt)
+		res = -1;
+	pthread_mutex_unlock(&localuser_lock);
+	return res;
+}
+
+int load_module(void)
+{
+	int res;
+	res=ast_register_translator(&gsmtolin);
+	if (!res) 
+		res=ast_register_translator(&lintogsm);
+	else
+		ast_unregister_translator(&gsmtolin);
+	return res;
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * The GSM code is from TOAST.  Copyright information for that package is available

Modified: trunk/codecs/gsm/COPYRIGHT
===================================================================
--- trunk/codecs/gsm/COPYRIGHT	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/COPYRIGHT	2006-06-28 06:25:21 UTC (rev 418)
@@ -14,3 +14,19 @@
 Berlin, 28.11.1994
 Jutta Degener
 Carsten Bormann
+Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
+Technische Universitaet Berlin
+
+Any use of this software is permitted provided that this notice is not
+removed and that neither the authors nor the Technische Universitaet Berlin
+are deemed to have made any representations as to the suitability of this
+software for any purpose nor are held responsible for any defects of
+this software.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+
+As a matter of courtesy, the authors request to be informed about uses
+this software has found, about bugs in this software, and about any
+improvements that may be of general interest.
+
+Berlin, 28.11.1994
+Jutta Degener
+Carsten Bormann

Modified: trunk/codecs/gsm/README
===================================================================
--- trunk/codecs/gsm/README	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/README	2006-06-28 06:25:21 UTC (rev 418)
@@ -35,3 +35,40 @@
 Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
 Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
 details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+
+GSM 06.10 13 kbit/s RPE/LTP speech compression available
+--------------------------------------------------------
+
+The Communications and Operating Systems Research Group (KBS) at the
+Technische Universitaet Berlin is currently working on a set of
+UNIX-based tools for computer-mediated telecooperation that will be
+made freely available.
+
+As part of this effort we are publishing an implementation of the
+European GSM 06.10 provisional standard for full-rate speech
+transcoding, prI-ETS 300 036, which uses RPE/LTP (residual pulse
+excitation/long term prediction) coding at 13 kbit/s.
+
+GSM 06.10 compresses frames of 160 13-bit samples (8 kHz sampling
+rate, i.e. a frame rate of 50 Hz) into 260 bits; for compatibility
+with typical UNIX applications, our implementation turns frames of 160
+16-bit linear samples into 33-byte frames (1650 Bytes/s).
+The quality of the algorithm is good enough for reliable speaker
+recognition; even music often survives transcoding in recognizable 
+form (given the bandwidth limitations of 8 kHz sampling rate).
+
+The interfaces offered are a front end modelled after compress(1), and
+a library API.  Compression and decompression run faster than realtime
+on most SPARCstations.  The implementation has been verified against the
+ETSI standard test patterns.
+
+Jutta Degener (jutta at cs.tu-berlin.de)
+Carsten Bormann (cabo at cs.tu-berlin.de)
+
+Communications and Operating Systems Research Group, TU Berlin
+Fax: +49.30.31425156, Phone: +49.30.31424315
+
+--
+Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.

Modified: trunk/codecs/gsm/inc/config.h
===================================================================
--- trunk/codecs/gsm/inc/config.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/config.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -9,6 +9,43 @@
 #ifndef	CONFIG_H
 #define	CONFIG_H
 
+/*efine	SIGHANDLER_T	int 		/* signal handlers are void	*/
+/*efine HAS_SYSV_SIGNAL	1		/* sigs not blocked/reset?	*/
+
+#define	HAS_STDLIB_H	1		/* /usr/include/stdlib.h	*/
+/*efine	HAS_LIMITS_H	1		/* /usr/include/limits.h	*/
+#define	HAS_FCNTL_H	1		/* /usr/include/fcntl.h		*/
+/*efine	HAS_ERRNO_DECL	1		/* errno.h declares errno	*/
+
+#define	HAS_FSTAT 	1		/* fstat syscall		*/
+#define	HAS_FCHMOD 	1		/* fchmod syscall		*/
+#define	HAS_CHMOD 	1		/* chmod syscall		*/
+#define	HAS_FCHOWN 	1		/* fchown syscall		*/
+#define	HAS_CHOWN 	1		/* chown syscall		*/
+/*efine	HAS__FSETMODE 	1		/* _fsetmode -- set file mode	*/
+
+#define	HAS_STRING_H 	1		/* /usr/include/string.h 	*/
+/*efine	HAS_STRINGS_H	1		/* /usr/include/strings.h 	*/
+
+#define	HAS_UNISTD_H	1		/* /usr/include/unistd.h	*/
+#define	HAS_UTIME	1		/* POSIX utime(path, times)	*/
+/*efine	HAS_UTIMES	1		/* use utimes()	syscall instead	*/
+#define	HAS_UTIME_H	1		/* UTIME header file		*/
+/*efine	HAS_UTIMBUF	1		/* struct utimbuf		*/
+/*efine	HAS_UTIMEUSEC   1		/* microseconds in utimbuf?	*/
+
+#endif	/* CONFIG_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	CONFIG_H
+#define	CONFIG_H
+
 #if 0
 efine	SIGHANDLER_T	int 		/* signal handlers are void	*/
 efine HAS_SYSV_SIGNAL	1		/* sigs not blocked/reset?	*/

Modified: trunk/codecs/gsm/inc/gsm.h
===================================================================
--- trunk/codecs/gsm/inc/gsm.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/gsm.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -69,3 +69,74 @@
 #undef	GSM_P
 
 #endif	/* GSM_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	GSM_H
+#define	GSM_H
+
+#ifdef __cplusplus
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#if __STDC__
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#ifdef _NO_PROTO
+#	undef	NeedFunctionPrototypes
+#endif
+
+#ifdef NeedFunctionPrototypes
+#   include	<stdio.h>		/* for FILE * 	*/
+#endif
+
+#undef GSM_P
+#if NeedFunctionPrototypes
+#	define	GSM_P( protos )	protos
+#else
+#	define  GSM_P( protos )	( /* protos */ )
+#endif
+
+/*
+ *	Interface
+ */
+
+typedef struct gsm_state * 	gsm;
+typedef short		   	gsm_signal;		/* signed 16 bit */
+typedef unsigned char		gsm_byte;
+typedef gsm_byte 		gsm_frame[33];		/* 33 * 8 bits	 */
+
+#define	GSM_MAGIC		0xD		  	/* 13 kbit/s RPE-LTP */
+
+#define	GSM_PATCHLEVEL		10
+#define	GSM_MINOR		0
+#define	GSM_MAJOR		1
+
+#define	GSM_OPT_VERBOSE		1
+#define	GSM_OPT_FAST		2
+#define	GSM_OPT_LTP_CUT		3
+#define	GSM_OPT_WAV49		4
+#define	GSM_OPT_FRAME_INDEX	5
+#define	GSM_OPT_FRAME_CHAIN	6
+
+extern gsm  gsm_create 	GSM_P((void));
+extern void gsm_destroy GSM_P((gsm));	
+
+extern int  gsm_print   GSM_P((FILE *, gsm, gsm_byte  *));
+extern int  gsm_option  GSM_P((gsm, int, int *));
+
+extern void gsm_encode  GSM_P((gsm, gsm_signal *, gsm_byte  *));
+extern int  gsm_decode  GSM_P((gsm, gsm_byte   *, gsm_signal *));
+
+extern int  gsm_explode GSM_P((gsm, gsm_byte   *, gsm_signal *));
+extern void gsm_implode GSM_P((gsm, gsm_signal *, gsm_byte   *));
+
+#undef	GSM_P
+
+#endif	/* GSM_H */

Modified: trunk/codecs/gsm/inc/private.h
===================================================================
--- trunk/codecs/gsm/inc/private.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/private.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -98,6 +98,274 @@
 # define GSM_L_MULT(a, b) /* word a, word b */	\
 	(((longword)(a) * (longword)(b)) << 1)
 
+# define GSM_L_ADD(a, b)	\
+	( (a) <  0 ? ( (b) >= 0 ? (a) + (b)	\
+		 : (utmp = (ulongword)-((a) + 1) + (ulongword)-((b) + 1)) \
+		   >= MAX_LONGWORD ? MIN_LONGWORD : -(longword)utmp-2 )   \
+	: ((b) <= 0 ? (a) + (b)   \
+	          : (utmp = (ulongword)(a) + (ulongword)(b)) >= MAX_LONGWORD \
+		    ? MAX_LONGWORD : utmp))
+
+/*
+ * # define GSM_ADD(a, b)	\
+ * 	((ltmp = (longword)(a) + (longword)(b)) >= MAX_WORD \
+ * 	? MAX_WORD : ltmp <= MIN_WORD ? MIN_WORD : ltmp)
+ */
+/* Nonportable, but faster: */
+
+#define	GSM_ADD(a, b)	\
+	((ulongword)((ltmp = (longword)(a) + (longword)(b)) - MIN_WORD) > \
+		MAX_WORD - MIN_WORD ? (ltmp > 0 ? MAX_WORD : MIN_WORD) : ltmp)
+
+# define GSM_SUB(a, b)	\
+	((ltmp = (longword)(a) - (longword)(b)) >= MAX_WORD \
+	? MAX_WORD : ltmp <= MIN_WORD ? MIN_WORD : ltmp)
+
+# define GSM_ABS(a)	((a) < 0 ? ((a) == MIN_WORD ? MAX_WORD : -(a)) : (a))
+
+/* Use these if necessary:
+
+# define GSM_MULT_R(a, b)	gsm_mult_r(a, b)
+# define GSM_MULT(a, b)		gsm_mult(a, b)
+# define GSM_L_MULT(a, b)	gsm_L_mult(a, b)
+
+# define GSM_L_ADD(a, b)	gsm_L_add(a, b)
+# define GSM_ADD(a, b)		gsm_add(a, b)
+# define GSM_SUB(a, b)		gsm_sub(a, b)
+
+# define GSM_ABS(a)		gsm_abs(a)
+
+*/
+
+/*
+ *  More prototypes from implementations..
+ */
+extern void Gsm_Coder P((
+		struct gsm_state	* S,
+		word	* s,	/* [0..159] samples		IN	*/
+		word	* LARc,	/* [0..7] LAR coefficients	OUT	*/
+		word	* Nc,	/* [0..3] LTP lag		OUT 	*/
+		word	* bc,	/* [0..3] coded LTP gain	OUT 	*/
+		word	* Mc,	/* [0..3] RPE grid selection	OUT     */
+		word	* xmaxc,/* [0..3] Coded maximum amplitude OUT	*/
+		word	* xMc	/* [13*4] normalized RPE samples OUT	*/));
+
+extern void Gsm_Long_Term_Predictor P((		/* 4x for 160 samples */
+		struct gsm_state * S,
+		word	* d,	/* [0..39]   residual signal	IN	*/
+		word	* dp,	/* [-120..-1] d'		IN	*/
+		word	* e,	/* [0..40] 			OUT	*/
+		word	* dpp,	/* [0..40] 			OUT	*/
+		word	* Nc,	/* correlation lag		OUT	*/
+		word	* bc	/* gain factor			OUT	*/));
+
+extern void Gsm_LPC_Analysis P((
+		struct gsm_state * S,
+		word * s,	 /* 0..159 signals	IN/OUT	*/
+	        word * LARc));   /* 0..7   LARc's	OUT	*/
+
+extern void Gsm_Preprocess P((
+		struct gsm_state * S,
+		word * s, word * so));
+
+extern void Gsm_Encoding P((
+		struct gsm_state * S,
+		word	* e,	
+		word	* ep,	
+		word	* xmaxc,
+		word	* Mc,	
+		word	* xMc));
+
+extern void Gsm_Short_Term_Analysis_Filter P((
+		struct gsm_state * S,
+		word	* LARc,	/* coded log area ratio [0..7]  IN	*/
+		word	* d	/* st res. signal [0..159]	IN/OUT	*/));
+
+extern void Gsm_Decoder P((
+		struct gsm_state * S,
+		word	* LARcr,	/* [0..7]		IN	*/
+		word	* Ncr,		/* [0..3] 		IN 	*/
+		word	* bcr,		/* [0..3]		IN	*/
+		word	* Mcr,		/* [0..3] 		IN 	*/
+		word	* xmaxcr,	/* [0..3]		IN 	*/
+		word	* xMcr,		/* [0..13*4]		IN	*/
+		word	* s));		/* [0..159]		OUT 	*/
+
+extern void Gsm_Decoding P((
+		struct gsm_state * S,
+		word 	xmaxcr,
+		word	Mcr,
+		word	* xMcr,  	/* [0..12]		IN	*/
+		word	* erp)); 	/* [0..39]		OUT 	*/
+
+extern void Gsm_Long_Term_Synthesis_Filtering P((
+		struct gsm_state* S,
+		word	Ncr,
+		word	bcr,
+		word	* erp,		/* [0..39]		  IN 	*/
+		word	* drp)); 	/* [-120..-1] IN, [0..40] OUT 	*/
+
+void Gsm_RPE_Decoding P((
+	struct gsm_state *S,
+		word xmaxcr,
+		word Mcr,
+		word * xMcr,  /* [0..12], 3 bits             IN      */
+		word * erp)); /* [0..39]                     OUT     */
+
+void Gsm_RPE_Encoding P((
+		struct gsm_state * S,
+		word    * e,            /* -5..-1][0..39][40..44     IN/OUT  */
+		word    * xmaxc,        /*                              OUT */
+		word    * Mc,           /*                              OUT */
+		word    * xMc));        /* [0..12]                      OUT */
+
+extern void Gsm_Short_Term_Synthesis_Filter P((
+		struct gsm_state * S,
+		word	* LARcr, 	/* log area ratios [0..7]  IN	*/
+		word	* drp,		/* received d [0...39]	   IN	*/
+		word	* s));		/* signal   s [0..159]	  OUT	*/
+
+extern void Gsm_Update_of_reconstructed_short_time_residual_signal P((
+		word	* dpp,		/* [0...39]	IN	*/
+		word	* ep,		/* [0...39]	IN	*/
+		word	* dp));		/* [-120...-1]  IN/OUT 	*/
+
+/*
+ *  Tables from table.c
+ */
+#ifndef	GSM_TABLE_C
+
+extern word gsm_A[8], gsm_B[8], gsm_MIC[8], gsm_MAC[8];
+extern word gsm_INVA[8];
+extern word gsm_DLB[4], gsm_QLB[4];
+extern word gsm_H[11];
+extern word gsm_NRFAC[8];
+extern word gsm_FAC[8];
+
+#endif	/* GSM_TABLE_C */
+
+/*
+ *  Debugging
+ */
+#ifdef NDEBUG
+
+#	define	gsm_debug_words(a, b, c, d)		/* nil */
+#	define	gsm_debug_longwords(a, b, c, d)		/* nil */
+#	define	gsm_debug_word(a, b)			/* nil */
+#	define	gsm_debug_longword(a, b)		/* nil */
+
+#else	/* !NDEBUG => DEBUG */
+
+	extern void  gsm_debug_words     P((char * name, int, int, word *));
+	extern void  gsm_debug_longwords P((char * name, int, int, longword *));
+	extern void  gsm_debug_longword  P((char * name, longword));
+	extern void  gsm_debug_word      P((char * name, word));
+
+#endif /* !NDEBUG */
+
+#include "unproto.h"
+
+#endif	/* PRIVATE_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	PRIVATE_H
+#define	PRIVATE_H
+
+typedef short			word;		/* 16 bit signed int	*/
+typedef long			longword;	/* 32 bit signed int	*/
+
+typedef unsigned short		uword;		/* unsigned word	*/
+typedef unsigned long		ulongword;	/* unsigned longword	*/
+
+struct gsm_state {
+
+	word		dp0[ 280 ];
+
+	word		z1;		/* preprocessing.c, Offset_com. */
+	longword	L_z2;		/*                  Offset_com. */
+	int		mp;		/*                  Preemphasis	*/
+
+	word		u[8];		/* short_term_aly_filter.c	*/
+	word		LARpp[2][8]; 	/*                              */
+	word		j;		/*                              */
+
+	word            ltp_cut;        /* long_term.c, LTP crosscorr.  */
+	word		nrp; /* 40 */	/* long_term.c, synthesis	*/
+	word		v[9];		/* short_term.c, synthesis	*/
+	word		msr;		/* decoder.c,	Postprocessing	*/
+
+	char		verbose;	/* only used if !NDEBUG		*/
+	char		fast;		/* only used if FAST		*/
+
+	char		wav_fmt;	/* only used if WAV49 defined	*/
+	unsigned char	frame_index;	/*            odd/even chaining	*/
+	unsigned char	frame_chain;	/*   half-byte to carry forward	*/
+};
+
+
+#define	MIN_WORD	(-32767 - 1)
+#define	MAX_WORD	  32767
+
+#define	MIN_LONGWORD	(-2147483647 - 1)
+#define	MAX_LONGWORD	  2147483647
+
+#ifdef	SASR		/* flag: >> is a signed arithmetic shift right */
+#undef	SASR
+#define	SASR(x, by)	((x) >> (by))
+#else
+#define	SASR(x, by)	((x) >= 0 ? (x) >> (by) : (~(-((x) + 1) >> (by))))
+#endif	/* SASR */
+
+#include "proto.h"
+
+/*
+ *	Prototypes from add.c
+ */
+extern word	gsm_mult 	P((word a, word b));
+extern longword gsm_L_mult 	P((word a, word b));
+extern word	gsm_mult_r	P((word a, word b));
+
+extern word	gsm_div  	P((word num, word denum));
+
+extern word	gsm_add 	P(( word a, word b ));
+extern longword gsm_L_add 	P(( longword a, longword b ));
+
+extern word	gsm_sub 	P((word a, word b));
+extern longword gsm_L_sub 	P((longword a, longword b));
+
+extern word	gsm_abs 	P((word a));
+
+extern word	gsm_norm 	P(( longword a ));
+
+extern longword gsm_L_asl  	P((longword a, int n));
+extern word	gsm_asl 	P((word a, int n));
+
+extern longword gsm_L_asr  	P((longword a, int n));
+extern word	gsm_asr  	P((word a, int n));
+
+/*
+ *  Inlined functions from add.h 
+ */
+
+/* 
+ * #define GSM_MULT_R(a, b) (* word a, word b, !(a == b == MIN_WORD) *)	\
+ *	(0x0FFFF & SASR(((longword)(a) * (longword)(b) + 16384), 15))
+ */
+#define GSM_MULT_R(a, b) /* word a, word b, !(a == b == MIN_WORD) */	\
+	(SASR( ((longword)(a) * (longword)(b) + 16384), 15 ))
+
+# define GSM_MULT(a,b)	 /* word a, word b, !(a == b == MIN_WORD) */	\
+	(SASR( ((longword)(a) * (longword)(b)), 15 ))
+
+# define GSM_L_MULT(a, b) /* word a, word b */	\
+	(((longword)(a) * (longword)(b)) << 1)
+
 #if defined(__GNUC__) && defined(__i386__)
 
 static __inline__ int GSM_L_ADD(int a, int b)

Modified: trunk/codecs/gsm/inc/proto.h
===================================================================
--- trunk/codecs/gsm/inc/proto.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/inc/proto.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -63,3 +63,68 @@
 #endif  /* !NeedFunctionPrototypes */
 
 #endif	/* PROTO_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifndef	PROTO_H
+#define	PROTO_H
+
+#if __cplusplus
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#if __STDC__
+#	define	NeedFunctionPrototypes	1
+#endif
+
+#ifdef	_NO_PROTO
+#	undef	NeedFunctionPrototypes
+#endif
+
+#undef	P	/* gnu stdio.h actually defines this... 	*/
+#undef	P0
+#undef	P1
+#undef	P2
+#undef	P3
+#undef	P4
+#undef	P5
+#undef	P6
+#undef	P7
+#undef	P8
+
+#if NeedFunctionPrototypes
+
+#	define	P( protos )	protos
+
+#	define	P0()				(void)
+#	define	P1(x, a)			(a)
+#	define	P2(x, a, b)			(a, b)
+#	define	P3(x, a, b, c)			(a, b, c)
+#	define	P4(x, a, b, c, d)		(a, b, c, d)	
+#	define	P5(x, a, b, c, d, e)		(a, b, c, d, e)
+#	define	P6(x, a, b, c, d, e, f)		(a, b, c, d, e, f)
+#	define	P7(x, a, b, c, d, e, f, g)	(a, b, c, d, e, f, g)
+#	define	P8(x, a, b, c, d, e, f, g, h)	(a, b, c, d, e, f, g, h)
+
+#else /* !NeedFunctionPrototypes */
+
+#	define	P( protos )	( /* protos */ )
+
+#	define	P0()				()
+#	define	P1(x, a)			x a;
+#	define	P2(x, a, b)			x a; b;
+#	define	P3(x, a, b, c)			x a; b; c;
+#	define	P4(x, a, b, c, d)		x a; b; c; d;
+#	define	P5(x, a, b, c, d, e)		x a; b; c; d; e;
+#	define	P6(x, a, b, c, d, e, f)		x a; b; c; d; e; f;
+#	define	P7(x, a, b, c, d, e, f, g)	x a; b; c; d; e; f; g;
+#	define	P8(x, a, b, c, d, e, f, g, h)	x a; b; c; d; e; f; g; h;
+
+#endif  /* !NeedFunctionPrototypes */
+
+#endif	/* PROTO_H */

Modified: trunk/codecs/gsm/src/add.c
===================================================================
--- trunk/codecs/gsm/src/add.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/add.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -23,6 +23,241 @@
 word gsm_add P2((a,b), word a, word b)
 {
 	longword sum = (longword)a + (longword)b;
+	return saturate(sum);
+}
+
+word gsm_sub P2((a,b), word a, word b)
+{
+	longword diff = (longword)a - (longword)b;
+	return saturate(diff);
+}
+
+word gsm_mult P2((a,b), word a, word b)
+{
+	if (a == MIN_WORD && b == MIN_WORD) return MAX_WORD;
+	else return SASR( (longword)a * (longword)b, 15 );
+}
+
+word gsm_mult_r P2((a,b), word a, word b)
+{
+	if (b == MIN_WORD && a == MIN_WORD) return MAX_WORD;
+	else {
+		longword prod = (longword)a * (longword)b + 16384;
+		prod >>= 15;
+		return prod & 0xFFFF;
+	}
+}
+
+word gsm_abs P1((a), word a)
+{
+	return a < 0 ? (a == MIN_WORD ? MAX_WORD : -a) : a;
+}
+
+longword gsm_L_mult P2((a,b),word a, word b)
+{
+	assert( a != MIN_WORD || b != MIN_WORD );
+	return ((longword)a * (longword)b) << 1;
+}
+
+longword gsm_L_add P2((a,b), longword a, longword b)
+{
+	if (a < 0) {
+		if (b >= 0) return a + b;
+		else {
+			ulongword A = (ulongword)-(a + 1) + (ulongword)-(b + 1);
+			return A >= MAX_LONGWORD ? MIN_LONGWORD :-(longword)A-2;
+		}
+	}
+	else if (b <= 0) return a + b;
+	else {
+		ulongword A = (ulongword)a + (ulongword)b;
+		return A > MAX_LONGWORD ? MAX_LONGWORD : A;
+	}
+}
+
+longword gsm_L_sub P2((a,b), longword a, longword b)
+{
+	if (a >= 0) {
+		if (b >= 0) return a - b;
+		else {
+			/* a>=0, b<0 */
+
+			ulongword A = (ulongword)a + -(b + 1);
+			return A >= MAX_LONGWORD ? MAX_LONGWORD : (A + 1);
+		}
+	}
+	else if (b <= 0) return a - b;
+	else {
+		/* a<0, b>0 */  
+
+		ulongword A = (ulongword)-(a + 1) + b;
+		return A >= MAX_LONGWORD ? MIN_LONGWORD : -(longword)A - 1;
+	}
+}
+
+static unsigned char const bitoff[ 256 ] = {
+	 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
+	 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
+	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
+	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
+};
+
+word gsm_norm P1((a), longword a )
+/*
+ * the number of left shifts needed to normalize the 32 bit
+ * variable L_var1 for positive values on the interval
+ *
+ * with minimum of
+ * minimum of 1073741824  (01000000000000000000000000000000) and 
+ * maximum of 2147483647  (01111111111111111111111111111111)
+ *
+ *
+ * and for negative values on the interval with
+ * minimum of -2147483648 (-10000000000000000000000000000000) and
+ * maximum of -1073741824 ( -1000000000000000000000000000000).
+ *
+ * in order to normalize the result, the following
+ * operation must be done: L_norm_var1 = L_var1 << norm( L_var1 );
+ *
+ * (That's 'ffs', only from the left, not the right..)
+ */
+{
+	assert(a != 0);
+
+	if (a < 0) {
+		if (a <= -1073741824) return 0;
+		a = ~a;
+	}
+
+	return    a & 0xffff0000 
+		? ( a & 0xff000000
+		  ?  -1 + bitoff[ 0xFF & (a >> 24) ]
+		  :   7 + bitoff[ 0xFF & (a >> 16) ] )
+		: ( a & 0xff00
+		  ?  15 + bitoff[ 0xFF & (a >> 8) ]
+		  :  23 + bitoff[ 0xFF & a ] );
+}
+
+longword gsm_L_asl P2((a,n), longword a, int n)
+{
+	if (n >= 32) return 0;
+	if (n <= -32) return -(a < 0);
+	if (n < 0) return gsm_L_asr(a, -n);
+	return a << n;
+}
+
+word gsm_asl P2((a,n), word a, int n)
+{
+	if (n >= 16) return 0;
+	if (n <= -16) return -(a < 0);
+	if (n < 0) return gsm_asr(a, -n);
+	return a << n;
+}
+
+longword gsm_L_asr P2((a,n), longword a, int n)
+{
+	if (n >= 32) return -(a < 0);
+	if (n <= -32) return 0;
+	if (n < 0) return a << -n;
+
+#	ifdef	SASR
+		return a >> n;
+#	else
+		if (a >= 0) return a >> n;
+		else return -(longword)( -(ulongword)a >> n );
+#	endif
+}
+
+word gsm_asr P2((a,n), word a, int n)
+{
+	if (n >= 16) return -(a < 0);
+	if (n <= -16) return 0;
+	if (n < 0) return a << -n;
+
+#	ifdef	SASR
+		return a >> n;
+#	else
+		if (a >= 0) return a >> n;
+		else return -(word)( -(uword)a >> n );
+#	endif
+}
+
+/* 
+ *  (From p. 46, end of section 4.2.5)
+ *
+ *  NOTE: The following lines gives [sic] one correct implementation
+ *  	  of the div(num, denum) arithmetic operation.  Compute div
+ *        which is the integer division of num by denum: with denum
+ *	  >= num > 0
+ */
+
+word gsm_div P2((num,denum), word num, word denum)
+{
+	longword	L_num   = num;
+	longword	L_denum = denum;
+	word		div 	= 0;
+	int		k 	= 15;
+
+	/* The parameter num sometimes becomes zero.
+	 * Although this is explicitly guarded against in 4.2.5,
+	 * we assume that the result should then be zero as well.
+	 */
+
+	/* assert(num != 0); */
+
+	assert(num >= 0 && denum >= num);
+	if (num == 0)
+	    return 0;
+
+	while (k--) {
+		div   <<= 1;
+		L_num <<= 1;
+
+		if (L_num >= L_denum) {
+			L_num -= L_denum;
+			div++;
+		}
+	}
+
+	return div;
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+/*
+ *  See private.h for the more commonly used macro versions.
+ */
+
+#include	<stdio.h>
+#include	<assert.h>
+
+#include	"private.h"
+#include	"gsm.h"
+#include	"proto.h"
+
+#define	saturate(x) 	\
+	((x) < MIN_WORD ? MIN_WORD : (x) > MAX_WORD ? MAX_WORD: (x))
+
+word gsm_add P2((a,b), word a, word b)
+{
+	longword sum = (longword)a + (longword)b;
 	return (word)saturate(sum);
 }
 

Modified: trunk/codecs/gsm/src/code.c
===================================================================
--- trunk/codecs/gsm/src/code.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/code.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -8,6 +8,105 @@
 
 #include	"config.h"
 
+
+#ifdef	HAS_STDLIB_H
+#include	<stdlib.h>
+#else
+#	include "proto.h"
+	extern char	* memcpy P((char *, char *, int));
+#endif
+
+#include	"private.h"
+#include	"gsm.h"
+#include	"proto.h"
+
+/* 
+ *  4.2 FIXED POINT IMPLEMENTATION OF THE RPE-LTP CODER 
+ */
+
+void Gsm_Coder P8((S,s,LARc,Nc,bc,Mc,xmaxc,xMc),
+
+	struct gsm_state	* S,
+
+	word	* s,	/* [0..159] samples		  	IN	*/
+
+/*
+ * The RPE-LTD coder works on a frame by frame basis.  The length of
+ * the frame is equal to 160 samples.  Some computations are done
+ * once per frame to produce at the output of the coder the
+ * LARc[1..8] parameters which are the coded LAR coefficients and 
+ * also to realize the inverse filtering operation for the entire
+ * frame (160 samples of signal d[0..159]).  These parts produce at
+ * the output of the coder:
+ */
+
+	word	* LARc,	/* [0..7] LAR coefficients		OUT	*/
+
+/*
+ * Procedure 4.2.11 to 4.2.18 are to be executed four times per
+ * frame.  That means once for each sub-segment RPE-LTP analysis of
+ * 40 samples.  These parts produce at the output of the coder:
+ */
+
+	word	* Nc,	/* [0..3] LTP lag			OUT 	*/
+	word	* bc,	/* [0..3] coded LTP gain		OUT 	*/
+	word	* Mc,	/* [0..3] RPE grid selection		OUT     */
+	word	* xmaxc,/* [0..3] Coded maximum amplitude	OUT	*/
+	word	* xMc	/* [13*4] normalized RPE samples	OUT	*/
+)
+{
+	int	k;
+	word	* dp  = S->dp0 + 120;	/* [ -120...-1 ] */
+	word	* dpp = dp;		/* [ 0...39 ]	 */
+
+	static word e[50];
+
+	word	so[160];
+
+	Gsm_Preprocess			(S, s, so);
+	Gsm_LPC_Analysis		(S, so, LARc);
+	Gsm_Short_Term_Analysis_Filter	(S, LARc, so);
+
+	for (k = 0; k <= 3; k++, xMc += 13) {
+
+		Gsm_Long_Term_Predictor	( S,
+					 so+k*40, /* d      [0..39] IN	*/
+					 dp,	  /* dp  [-120..-1] IN	*/
+					e + 5,	  /* e      [0..39] OUT	*/
+					dpp,	  /* dpp    [0..39] OUT */
+					 Nc++,
+					 bc++);
+
+		Gsm_RPE_Encoding	( S,
+					e + 5,	/* e	  ][0..39][ IN/OUT */
+					  xmaxc++, Mc++, xMc );
+		/*
+		 * Gsm_Update_of_reconstructed_short_time_residual_signal
+		 *			( dpp, e + 5, dp );
+		 */
+
+		{ register int i;
+		  register longword ltmp;
+		  for (i = 0; i <= 39; i++)
+			dp[ i ] = GSM_ADD( e[5 + i], dpp[i] );
+		}
+		dp  += 40;
+		dpp += 40;
+
+	}
+	(void)memcpy( (char *)S->dp0, (char *)(S->dp0 + 160),
+		120 * sizeof(*S->dp0) );
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include	"config.h"
+
 #ifdef	HAS_STRING_H
 #include	<string.h>
 #else

Modified: trunk/codecs/gsm/src/debug.c
===================================================================
--- trunk/codecs/gsm/src/debug.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/debug.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -74,3 +74,79 @@
 }
 
 #endif
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "private.h"
+
+#ifndef	NDEBUG
+
+/* If NDEBUG _is_ defined and no debugging should be performed,
+ * calls to functions in this module are #defined to nothing
+ * in private.h.
+ */
+
+#include <stdio.h>
+#include "proto.h"
+
+void gsm_debug_words P4( (name, from, to, ptr), 
+	char 	      * name,
+	int		from,
+	int		to,
+	word		* ptr)
+{
+	int 	nprinted = 0;
+
+	fprintf( stderr, "%s [%d .. %d]: ", name, from, to );
+	while (from <= to) {
+		fprintf(stderr, "%d ", ptr[ from ] );
+		from++;
+		if (nprinted++ >= 7) {
+			nprinted = 0;
+			if (from < to) putc('\n', stderr);
+		}
+	}
+	putc('\n', stderr);
+}
+
+void gsm_debug_longwords P4( (name, from, to, ptr),
+	char 	      * name,
+	int		from,
+	int		to,
+	longword      * ptr)
+{
+	int 	nprinted = 0;
+
+	fprintf( stderr, "%s [%d .. %d]: ", name, from, to );
+	while (from <= to) {
+
+		fprintf(stderr, "%d ", ptr[ from ] );
+		from++;
+		if (nprinted++ >= 7) {
+			nprinted = 0;
+			if (from < to) putc('\n', stderr);
+		}
+	}
+	putc('\n', stderr);
+}
+
+void gsm_debug_longword P2(  (name, value),
+	char		* name,
+	longword	  value	)
+{
+	fprintf(stderr, "%s: %d\n", name, (long)value );
+}
+
+void gsm_debug_word P2(  (name, value),
+	char	* name,
+	word	  value	)
+{
+	fprintf(stderr, "%s: %d\n", name, (long)value);
+}
+
+#endif

Modified: trunk/codecs/gsm/src/decode.c
===================================================================
--- trunk/codecs/gsm/src/decode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/decode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -22,9 +22,72 @@
 {
 	register int		k;
 	register word		msr = S->msr;
+	register longword	ltmp;	/* for GSM_ADD */
 	register word		tmp;
 
 	for (k = 160; k--; s++) {
+		tmp = GSM_MULT_R( msr, 28180 );
+		msr = GSM_ADD(*s, tmp);  	   /* Deemphasis 	     */
+		*s  = GSM_ADD(msr, msr) & 0xFFF8;  /* Truncation & Upscaling */
+	}
+	S->msr = msr;
+}
+
+void Gsm_Decoder P8((S,LARcr, Ncr,bcr,Mcr,xmaxcr,xMcr,s),
+	struct gsm_state	* S,
+
+	word		* LARcr,	/* [0..7]		IN	*/
+
+	word		* Ncr,		/* [0..3] 		IN 	*/
+	word		* bcr,		/* [0..3]		IN	*/
+	word		* Mcr,		/* [0..3] 		IN 	*/
+	word		* xmaxcr,	/* [0..3]		IN 	*/
+	word		* xMcr,		/* [0..13*4]		IN	*/
+
+	word		* s)		/* [0..159]		OUT 	*/
+{
+	int		j, k;
+	word		erp[40], wt[160];
+	word		* drp = S->dp0 + 120;
+
+	for (j=0; j <= 3; j++, xmaxcr++, bcr++, Ncr++, Mcr++, xMcr += 13) {
+
+		Gsm_RPE_Decoding( S, *xmaxcr, *Mcr, xMcr, erp );
+		Gsm_Long_Term_Synthesis_Filtering( S, *Ncr, *bcr, erp, drp );
+
+		for (k = 0; k <= 39; k++) wt[ j * 40 + k ] =  drp[ k ];
+	}
+
+	Gsm_Short_Term_Synthesis_Filter( S, LARcr, wt, s );
+	Postprocessing(S, s);
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include <stdio.h>
+
+#include	"private.h"
+#include	"gsm.h"
+#include	"proto.h"
+
+/*
+ *  4.3 FIXED POINT IMPLEMENTATION OF THE RPE-LTP DECODER
+ */
+
+static void Postprocessing P2((S,s),
+	struct gsm_state	* S,
+	register word 		* s)
+{
+	register int		k;
+	register word		msr = S->msr;
+	register word		tmp;
+
+	for (k = 160; k--; s++) {
 		tmp = (word)GSM_MULT_R( msr, 28180 );
 		msr = GSM_ADD(*s, tmp);  	   /* Deemphasis 	     */
 		*s  = GSM_ADD(msr, msr) & 0xFFF8;  /* Truncation & Upscaling */

Modified: trunk/codecs/gsm/src/gsm_create.c
===================================================================
--- trunk/codecs/gsm/src/gsm_create.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_create.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -43,3 +43,48 @@
 
 	return r;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+static char const	ident[] = "$Header$";
+
+#include	"config.h"
+
+#ifdef	HAS_STRING_H
+#include	<string.h>
+#else
+#	include "proto.h"
+	extern char	* memset P((char *, int, int));
+#endif
+
+#ifdef	HAS_STDLIB_H
+#	include	<stdlib.h>
+#else
+#	ifdef	HAS_MALLOC_H
+#		include 	<malloc.h>
+#	else
+		extern char * malloc();
+#	endif
+#endif
+
+#include <stdio.h>
+
+#include "gsm.h"
+#include "private.h"
+#include "proto.h"
+
+gsm gsm_create P0()
+{
+	gsm  r;
+
+	r = (gsm)malloc(sizeof(struct gsm_state));
+	if (!r) return r;
+
+	memset((char *)r, 0, sizeof(*r));
+	r->nrp = 40;
+
+	return r;
+}

Modified: trunk/codecs/gsm/src/gsm_decode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_decode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_decode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -359,3 +359,364 @@
 
 	return 0;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
+
+int gsm_decode P3((s, c, target), gsm s, gsm_byte * c, gsm_signal * target)
+{
+	word  	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
+
+#ifdef WAV49
+	if (s->wav_fmt) {
+
+		uword sr = 0;
+
+		s->frame_index = !s->frame_index;
+		if (s->frame_index) {
+
+			sr = *c++;
+			LARc[0] = sr & 0x3f;  sr >>= 6;
+			sr |= (uword)*c++ << 2;
+			LARc[1] = sr & 0x3f;  sr >>= 6;
+			sr |= (uword)*c++ << 4;
+			LARc[2] = sr & 0x1f;  sr >>= 5;
+			LARc[3] = sr & 0x1f;  sr >>= 5;
+			sr |= (uword)*c++ << 2;
+			LARc[4] = sr & 0xf;  sr >>= 4;
+			LARc[5] = sr & 0xf;  sr >>= 4;
+			sr |= (uword)*c++ << 2;			/* 5 */
+			LARc[6] = sr & 0x7;  sr >>= 3;
+			LARc[7] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[0] = sr & 0x7f;  sr >>= 7;
+			bc[0] = sr & 0x3;  sr >>= 2;
+			Mc[0] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[0] = sr & 0x3f;  sr >>= 6;
+			xmc[0] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[1] = sr & 0x7;  sr >>= 3;
+			xmc[2] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[3] = sr & 0x7;  sr >>= 3;
+			xmc[4] = sr & 0x7;  sr >>= 3;
+			xmc[5] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 10 */
+			xmc[6] = sr & 0x7;  sr >>= 3;
+			xmc[7] = sr & 0x7;  sr >>= 3;
+			xmc[8] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[9] = sr & 0x7;  sr >>= 3;
+			xmc[10] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[11] = sr & 0x7;  sr >>= 3;
+			xmc[12] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[1] = sr & 0x7f;  sr >>= 7;
+			bc[1] = sr & 0x3;  sr >>= 2;
+			Mc[1] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[1] = sr & 0x3f;  sr >>= 6;
+			xmc[13] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 15 */
+			xmc[14] = sr & 0x7;  sr >>= 3;
+			xmc[15] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[16] = sr & 0x7;  sr >>= 3;
+			xmc[17] = sr & 0x7;  sr >>= 3;
+			xmc[18] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[19] = sr & 0x7;  sr >>= 3;
+			xmc[20] = sr & 0x7;  sr >>= 3;
+			xmc[21] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[22] = sr & 0x7;  sr >>= 3;
+			xmc[23] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[24] = sr & 0x7;  sr >>= 3;
+			xmc[25] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;			/* 20 */
+			Nc[2] = sr & 0x7f;  sr >>= 7;
+			bc[2] = sr & 0x3;  sr >>= 2;
+			Mc[2] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[2] = sr & 0x3f;  sr >>= 6;
+			xmc[26] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[27] = sr & 0x7;  sr >>= 3;
+			xmc[28] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[29] = sr & 0x7;  sr >>= 3;
+			xmc[30] = sr & 0x7;  sr >>= 3;
+			xmc[31] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[32] = sr & 0x7;  sr >>= 3;
+			xmc[33] = sr & 0x7;  sr >>= 3;
+			xmc[34] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 25 */
+			xmc[35] = sr & 0x7;  sr >>= 3;
+			xmc[36] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[37] = sr & 0x7;  sr >>= 3;
+			xmc[38] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[3] = sr & 0x7f;  sr >>= 7;
+			bc[3] = sr & 0x3;  sr >>= 2;
+			Mc[3] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[3] = sr & 0x3f;  sr >>= 6;
+			xmc[39] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[40] = sr & 0x7;  sr >>= 3;
+			xmc[41] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;			/* 30 */
+			xmc[42] = sr & 0x7;  sr >>= 3;
+			xmc[43] = sr & 0x7;  sr >>= 3;
+			xmc[44] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[45] = sr & 0x7;  sr >>= 3;
+			xmc[46] = sr & 0x7;  sr >>= 3;
+			xmc[47] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[48] = sr & 0x7;  sr >>= 3;
+			xmc[49] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[50] = sr & 0x7;  sr >>= 3;
+			xmc[51] = sr & 0x7;  sr >>= 3;
+
+			s->frame_chain = sr & 0xf;
+		}
+		else {
+			sr = s->frame_chain;
+			sr |= (uword)*c++ << 4;			/* 1 */
+			LARc[0] = sr & 0x3f;  sr >>= 6;
+			LARc[1] = sr & 0x3f;  sr >>= 6;
+			sr = *c++;
+			LARc[2] = sr & 0x1f;  sr >>= 5;
+			sr |= (uword)*c++ << 3;
+			LARc[3] = sr & 0x1f;  sr >>= 5;
+			LARc[4] = sr & 0xf;  sr >>= 4;
+			sr |= (uword)*c++ << 2;
+			LARc[5] = sr & 0xf;  sr >>= 4;
+			LARc[6] = sr & 0x7;  sr >>= 3;
+			LARc[7] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 5 */
+			Nc[0] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;
+			bc[0] = sr & 0x3;  sr >>= 2;
+			Mc[0] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[0] = sr & 0x3f;  sr >>= 6;
+			xmc[0] = sr & 0x7;  sr >>= 3;
+			xmc[1] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[2] = sr & 0x7;  sr >>= 3;
+			xmc[3] = sr & 0x7;  sr >>= 3;
+			xmc[4] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[5] = sr & 0x7;  sr >>= 3;
+			xmc[6] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;			/* 10 */
+			xmc[7] = sr & 0x7;  sr >>= 3;
+			xmc[8] = sr & 0x7;  sr >>= 3;
+			xmc[9] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[10] = sr & 0x7;  sr >>= 3;
+			xmc[11] = sr & 0x7;  sr >>= 3;
+			xmc[12] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[1] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;
+			bc[1] = sr & 0x3;  sr >>= 2;
+			Mc[1] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[1] = sr & 0x3f;  sr >>= 6;
+			xmc[13] = sr & 0x7;  sr >>= 3;
+			xmc[14] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 15 */
+			xmc[15] = sr & 0x7;  sr >>= 3;
+			xmc[16] = sr & 0x7;  sr >>= 3;
+			xmc[17] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[18] = sr & 0x7;  sr >>= 3;
+			xmc[19] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[20] = sr & 0x7;  sr >>= 3;
+			xmc[21] = sr & 0x7;  sr >>= 3;
+			xmc[22] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[23] = sr & 0x7;  sr >>= 3;
+			xmc[24] = sr & 0x7;  sr >>= 3;
+			xmc[25] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[2] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;			/* 20 */
+			bc[2] = sr & 0x3;  sr >>= 2;
+			Mc[2] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[2] = sr & 0x3f;  sr >>= 6;
+			xmc[26] = sr & 0x7;  sr >>= 3;
+			xmc[27] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;	
+			xmc[28] = sr & 0x7;  sr >>= 3;
+			xmc[29] = sr & 0x7;  sr >>= 3;
+			xmc[30] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[31] = sr & 0x7;  sr >>= 3;
+			xmc[32] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[33] = sr & 0x7;  sr >>= 3;
+			xmc[34] = sr & 0x7;  sr >>= 3;
+			xmc[35] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 25 */
+			xmc[36] = sr & 0x7;  sr >>= 3;
+			xmc[37] = sr & 0x7;  sr >>= 3;
+			xmc[38] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[3] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;		
+			bc[3] = sr & 0x3;  sr >>= 2;
+			Mc[3] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[3] = sr & 0x3f;  sr >>= 6;
+			xmc[39] = sr & 0x7;  sr >>= 3;
+			xmc[40] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[41] = sr & 0x7;  sr >>= 3;
+			xmc[42] = sr & 0x7;  sr >>= 3;
+			xmc[43] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 30 */
+			xmc[44] = sr & 0x7;  sr >>= 3;
+			xmc[45] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[46] = sr & 0x7;  sr >>= 3;
+			xmc[47] = sr & 0x7;  sr >>= 3;
+			xmc[48] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[49] = sr & 0x7;  sr >>= 3;
+			xmc[50] = sr & 0x7;  sr >>= 3;
+			xmc[51] = sr & 0x7;  sr >>= 3;
+		}
+	}
+	else
+#endif
+	{
+		/* GSM_MAGIC  = (*c >> 4) & 0xF; */
+
+		if (((*c >> 4) & 0x0F) != GSM_MAGIC) return -1;
+
+		LARc[0]  = (*c++ & 0xF) << 2;		/* 1 */
+		LARc[0] |= (*c >> 6) & 0x3;
+		LARc[1]  = *c++ & 0x3F;
+		LARc[2]  = (*c >> 3) & 0x1F;
+		LARc[3]  = (*c++ & 0x7) << 2;
+		LARc[3] |= (*c >> 6) & 0x3;
+		LARc[4]  = (*c >> 2) & 0xF;
+		LARc[5]  = (*c++ & 0x3) << 2;
+		LARc[5] |= (*c >> 6) & 0x3;
+		LARc[6]  = (*c >> 3) & 0x7;
+		LARc[7]  = *c++ & 0x7;
+		Nc[0]  = (*c >> 1) & 0x7F;
+		bc[0]  = (*c++ & 0x1) << 1;
+		bc[0] |= (*c >> 7) & 0x1;
+		Mc[0]  = (*c >> 5) & 0x3;
+		xmaxc[0]  = (*c++ & 0x1F) << 1;
+		xmaxc[0] |= (*c >> 7) & 0x1;
+		xmc[0]  = (*c >> 4) & 0x7;
+		xmc[1]  = (*c >> 1) & 0x7;
+		xmc[2]  = (*c++ & 0x1) << 2;
+		xmc[2] |= (*c >> 6) & 0x3;
+		xmc[3]  = (*c >> 3) & 0x7;
+		xmc[4]  = *c++ & 0x7;
+		xmc[5]  = (*c >> 5) & 0x7;
+		xmc[6]  = (*c >> 2) & 0x7;
+		xmc[7]  = (*c++ & 0x3) << 1;		/* 10 */
+		xmc[7] |= (*c >> 7) & 0x1;
+		xmc[8]  = (*c >> 4) & 0x7;
+		xmc[9]  = (*c >> 1) & 0x7;
+		xmc[10]  = (*c++ & 0x1) << 2;
+		xmc[10] |= (*c >> 6) & 0x3;
+		xmc[11]  = (*c >> 3) & 0x7;
+		xmc[12]  = *c++ & 0x7;
+		Nc[1]  = (*c >> 1) & 0x7F;
+		bc[1]  = (*c++ & 0x1) << 1;
+		bc[1] |= (*c >> 7) & 0x1;
+		Mc[1]  = (*c >> 5) & 0x3;
+		xmaxc[1]  = (*c++ & 0x1F) << 1;
+		xmaxc[1] |= (*c >> 7) & 0x1;
+		xmc[13]  = (*c >> 4) & 0x7;
+		xmc[14]  = (*c >> 1) & 0x7;
+		xmc[15]  = (*c++ & 0x1) << 2;
+		xmc[15] |= (*c >> 6) & 0x3;
+		xmc[16]  = (*c >> 3) & 0x7;
+		xmc[17]  = *c++ & 0x7;
+		xmc[18]  = (*c >> 5) & 0x7;
+		xmc[19]  = (*c >> 2) & 0x7;
+		xmc[20]  = (*c++ & 0x3) << 1;
+		xmc[20] |= (*c >> 7) & 0x1;
+		xmc[21]  = (*c >> 4) & 0x7;
+		xmc[22]  = (*c >> 1) & 0x7;
+		xmc[23]  = (*c++ & 0x1) << 2;
+		xmc[23] |= (*c >> 6) & 0x3;
+		xmc[24]  = (*c >> 3) & 0x7;
+		xmc[25]  = *c++ & 0x7;
+		Nc[2]  = (*c >> 1) & 0x7F;
+		bc[2]  = (*c++ & 0x1) << 1;		/* 20 */
+		bc[2] |= (*c >> 7) & 0x1;
+		Mc[2]  = (*c >> 5) & 0x3;
+		xmaxc[2]  = (*c++ & 0x1F) << 1;
+		xmaxc[2] |= (*c >> 7) & 0x1;
+		xmc[26]  = (*c >> 4) & 0x7;
+		xmc[27]  = (*c >> 1) & 0x7;
+		xmc[28]  = (*c++ & 0x1) << 2;
+		xmc[28] |= (*c >> 6) & 0x3;
+		xmc[29]  = (*c >> 3) & 0x7;
+		xmc[30]  = *c++ & 0x7;
+		xmc[31]  = (*c >> 5) & 0x7;
+		xmc[32]  = (*c >> 2) & 0x7;
+		xmc[33]  = (*c++ & 0x3) << 1;
+		xmc[33] |= (*c >> 7) & 0x1;
+		xmc[34]  = (*c >> 4) & 0x7;
+		xmc[35]  = (*c >> 1) & 0x7;
+		xmc[36]  = (*c++ & 0x1) << 2;
+		xmc[36] |= (*c >> 6) & 0x3;
+		xmc[37]  = (*c >> 3) & 0x7;
+		xmc[38]  = *c++ & 0x7;
+		Nc[3]  = (*c >> 1) & 0x7F;
+		bc[3]  = (*c++ & 0x1) << 1;
+		bc[3] |= (*c >> 7) & 0x1;
+		Mc[3]  = (*c >> 5) & 0x3;
+		xmaxc[3]  = (*c++ & 0x1F) << 1;
+		xmaxc[3] |= (*c >> 7) & 0x1;
+		xmc[39]  = (*c >> 4) & 0x7;
+		xmc[40]  = (*c >> 1) & 0x7;
+		xmc[41]  = (*c++ & 0x1) << 2;
+		xmc[41] |= (*c >> 6) & 0x3;
+		xmc[42]  = (*c >> 3) & 0x7;
+		xmc[43]  = *c++ & 0x7;			/* 30  */
+		xmc[44]  = (*c >> 5) & 0x7;
+		xmc[45]  = (*c >> 2) & 0x7;
+		xmc[46]  = (*c++ & 0x3) << 1;
+		xmc[46] |= (*c >> 7) & 0x1;
+		xmc[47]  = (*c >> 4) & 0x7;
+		xmc[48]  = (*c >> 1) & 0x7;
+		xmc[49]  = (*c++ & 0x1) << 2;
+		xmc[49] |= (*c >> 6) & 0x3;
+		xmc[50]  = (*c >> 3) & 0x7;
+		xmc[51]  = *c & 0x7;			/* 33 */
+	}
+
+	Gsm_Decoder(s, LARc, Nc, bc, Mc, xmaxc, xmc, target);
+
+	return 0;
+}

Modified: trunk/codecs/gsm/src/gsm_destroy.c
===================================================================
--- trunk/codecs/gsm/src/gsm_destroy.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_destroy.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -24,3 +24,29 @@
 {
 	if (S) free((char *)S);
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "gsm.h"
+#include "config.h"
+#include "proto.h"
+
+#ifdef	HAS_STDLIB_H
+#	include	<stdlib.h>
+#else
+#	ifdef	HAS_MALLOC_H
+#		include 	<malloc.h>
+#	else
+		extern void free();
+#	endif
+#endif
+
+void gsm_destroy P1((S), gsm S)
+{
+	if (S) free((char *)S);
+}

Modified: trunk/codecs/gsm/src/gsm_encode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_encode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_encode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -449,3 +449,454 @@
 
 	}
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "private.h"
+#include "gsm.h"
+#include "proto.h"
+
+void gsm_encode P3((s, source, c), gsm s, gsm_signal * source, gsm_byte * c)
+{
+	word	 	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
+
+	Gsm_Coder(s, source, LARc, Nc, bc, Mc, xmaxc, xmc);
+
+
+	/*	variable	size
+
+		GSM_MAGIC	4
+
+		LARc[0]		6
+		LARc[1]		6
+		LARc[2]		5
+		LARc[3]		5
+		LARc[4]		4
+		LARc[5]		4
+		LARc[6]		3
+		LARc[7]		3
+
+		Nc[0]		7
+		bc[0]		2
+		Mc[0]		2
+		xmaxc[0]	6
+		xmc[0]		3
+		xmc[1]		3
+		xmc[2]		3
+		xmc[3]		3
+		xmc[4]		3
+		xmc[5]		3
+		xmc[6]		3
+		xmc[7]		3
+		xmc[8]		3
+		xmc[9]		3
+		xmc[10]		3
+		xmc[11]		3
+		xmc[12]		3
+
+		Nc[1]		7
+		bc[1]		2
+		Mc[1]		2
+		xmaxc[1]	6
+		xmc[13]		3
+		xmc[14]		3
+		xmc[15]		3
+		xmc[16]		3
+		xmc[17]		3
+		xmc[18]		3
+		xmc[19]		3
+		xmc[20]		3
+		xmc[21]		3
+		xmc[22]		3
+		xmc[23]		3
+		xmc[24]		3
+		xmc[25]		3
+
+		Nc[2]		7
+		bc[2]		2
+		Mc[2]		2
+		xmaxc[2]	6
+		xmc[26]		3
+		xmc[27]		3
+		xmc[28]		3
+		xmc[29]		3
+		xmc[30]		3
+		xmc[31]		3
+		xmc[32]		3
+		xmc[33]		3
+		xmc[34]		3
+		xmc[35]		3
+		xmc[36]		3
+		xmc[37]		3
+		xmc[38]		3
+
+		Nc[3]		7
+		bc[3]		2
+		Mc[3]		2
+		xmaxc[3]	6
+		xmc[39]		3
+		xmc[40]		3
+		xmc[41]		3
+		xmc[42]		3
+		xmc[43]		3
+		xmc[44]		3
+		xmc[45]		3
+		xmc[46]		3
+		xmc[47]		3
+		xmc[48]		3
+		xmc[49]		3
+		xmc[50]		3
+		xmc[51]		3
+	*/
+
+#ifdef WAV49
+
+	if (s->wav_fmt) {
+		s->frame_index = !s->frame_index;
+		if (s->frame_index) {
+
+			uword sr;
+
+			sr = 0;
+			sr = sr >> 6 | LARc[0] << 10;
+			sr = sr >> 6 | LARc[1] << 10;
+			*c++ = sr >> 4;
+			sr = sr >> 5 | LARc[2] << 11;
+			*c++ = sr >> 7;
+			sr = sr >> 5 | LARc[3] << 11;
+			sr = sr >> 4 | LARc[4] << 12;
+			*c++ = sr >> 6;
+			sr = sr >> 4 | LARc[5] << 12;
+			sr = sr >> 3 | LARc[6] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | LARc[7] << 13;
+			sr = sr >> 7 | Nc[0] << 9;
+			*c++ = sr >> 5;
+			sr = sr >> 2 | bc[0] << 14;
+			sr = sr >> 2 | Mc[0] << 14;
+			sr = sr >> 6 | xmaxc[0] << 10;
+			*c++ = sr >> 3;
+			sr = sr >> 3 | xmc[0] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[1] << 13;
+			sr = sr >> 3 | xmc[2] << 13;
+			sr = sr >> 3 | xmc[3] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[4] << 13;
+			sr = sr >> 3 | xmc[5] << 13;
+			sr = sr >> 3 | xmc[6] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[7] << 13;
+			sr = sr >> 3 | xmc[8] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[9] << 13;
+			sr = sr >> 3 | xmc[10] << 13;
+			sr = sr >> 3 | xmc[11] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[12] << 13;
+			sr = sr >> 7 | Nc[1] << 9;
+			*c++ = sr >> 5;
+			sr = sr >> 2 | bc[1] << 14;
+			sr = sr >> 2 | Mc[1] << 14;
+			sr = sr >> 6 | xmaxc[1] << 10;
+			*c++ = sr >> 3;
+			sr = sr >> 3 | xmc[13] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[14] << 13;
+			sr = sr >> 3 | xmc[15] << 13;
+			sr = sr >> 3 | xmc[16] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[17] << 13;
+			sr = sr >> 3 | xmc[18] << 13;
+			sr = sr >> 3 | xmc[19] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[20] << 13;
+			sr = sr >> 3 | xmc[21] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[22] << 13;
+			sr = sr >> 3 | xmc[23] << 13;
+			sr = sr >> 3 | xmc[24] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[25] << 13;
+			sr = sr >> 7 | Nc[2] << 9;
+			*c++ = sr >> 5;
+			sr = sr >> 2 | bc[2] << 14;
+			sr = sr >> 2 | Mc[2] << 14;
+			sr = sr >> 6 | xmaxc[2] << 10;
+			*c++ = sr >> 3;
+			sr = sr >> 3 | xmc[26] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[27] << 13;
+			sr = sr >> 3 | xmc[28] << 13;
+			sr = sr >> 3 | xmc[29] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[30] << 13;
+			sr = sr >> 3 | xmc[31] << 13;
+			sr = sr >> 3 | xmc[32] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[33] << 13;
+			sr = sr >> 3 | xmc[34] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[35] << 13;
+			sr = sr >> 3 | xmc[36] << 13;
+			sr = sr >> 3 | xmc[37] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[38] << 13;
+			sr = sr >> 7 | Nc[3] << 9;
+			*c++ = sr >> 5;
+			sr = sr >> 2 | bc[3] << 14;
+			sr = sr >> 2 | Mc[3] << 14;
+			sr = sr >> 6 | xmaxc[3] << 10;
+			*c++ = sr >> 3;
+			sr = sr >> 3 | xmc[39] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[40] << 13;
+			sr = sr >> 3 | xmc[41] << 13;
+			sr = sr >> 3 | xmc[42] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[43] << 13;
+			sr = sr >> 3 | xmc[44] << 13;
+			sr = sr >> 3 | xmc[45] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[46] << 13;
+			sr = sr >> 3 | xmc[47] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[48] << 13;
+			sr = sr >> 3 | xmc[49] << 13;
+			sr = sr >> 3 | xmc[50] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[51] << 13;
+			sr = sr >> 4;
+			*c = sr >> 8;
+			s->frame_chain = *c;
+		}
+		else {
+			uword sr;
+
+			sr = 0;
+			sr = sr >> 4 | s->frame_chain << 12;
+			sr = sr >> 6 | LARc[0] << 10;
+			*c++ = sr >> 6;
+			sr = sr >> 6 | LARc[1] << 10;
+			*c++ = sr >> 8;
+			sr = sr >> 5 | LARc[2] << 11;
+			sr = sr >> 5 | LARc[3] << 11;
+			*c++ = sr >> 6;
+			sr = sr >> 4 | LARc[4] << 12;
+			sr = sr >> 4 | LARc[5] << 12;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | LARc[6] << 13;
+			sr = sr >> 3 | LARc[7] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 7 | Nc[0] << 9;
+			sr = sr >> 2 | bc[0] << 14;
+			*c++ = sr >> 7;
+			sr = sr >> 2 | Mc[0] << 14;
+			sr = sr >> 6 | xmaxc[0] << 10;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[0] << 13;
+			sr = sr >> 3 | xmc[1] << 13;
+			sr = sr >> 3 | xmc[2] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[3] << 13;
+			sr = sr >> 3 | xmc[4] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[5] << 13;
+			sr = sr >> 3 | xmc[6] << 13;
+			sr = sr >> 3 | xmc[7] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[8] << 13;
+			sr = sr >> 3 | xmc[9] << 13;
+			sr = sr >> 3 | xmc[10] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[11] << 13;
+			sr = sr >> 3 | xmc[12] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 7 | Nc[1] << 9;
+			sr = sr >> 2 | bc[1] << 14;
+			*c++ = sr >> 7;
+			sr = sr >> 2 | Mc[1] << 14;
+			sr = sr >> 6 | xmaxc[1] << 10;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[13] << 13;
+			sr = sr >> 3 | xmc[14] << 13;
+			sr = sr >> 3 | xmc[15] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[16] << 13;
+			sr = sr >> 3 | xmc[17] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[18] << 13;
+			sr = sr >> 3 | xmc[19] << 13;
+			sr = sr >> 3 | xmc[20] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[21] << 13;
+			sr = sr >> 3 | xmc[22] << 13;
+			sr = sr >> 3 | xmc[23] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[24] << 13;
+			sr = sr >> 3 | xmc[25] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 7 | Nc[2] << 9;
+			sr = sr >> 2 | bc[2] << 14;
+			*c++ = sr >> 7;
+			sr = sr >> 2 | Mc[2] << 14;
+			sr = sr >> 6 | xmaxc[2] << 10;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[26] << 13;
+			sr = sr >> 3 | xmc[27] << 13;
+			sr = sr >> 3 | xmc[28] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[29] << 13;
+			sr = sr >> 3 | xmc[30] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[31] << 13;
+			sr = sr >> 3 | xmc[32] << 13;
+			sr = sr >> 3 | xmc[33] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[34] << 13;
+			sr = sr >> 3 | xmc[35] << 13;
+			sr = sr >> 3 | xmc[36] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[37] << 13;
+			sr = sr >> 3 | xmc[38] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 7 | Nc[3] << 9;
+			sr = sr >> 2 | bc[3] << 14;
+			*c++ = sr >> 7;
+			sr = sr >> 2 | Mc[3] << 14;
+			sr = sr >> 6 | xmaxc[3] << 10;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[39] << 13;
+			sr = sr >> 3 | xmc[40] << 13;
+			sr = sr >> 3 | xmc[41] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[42] << 13;
+			sr = sr >> 3 | xmc[43] << 13;
+			*c++ = sr >> 8;
+			sr = sr >> 3 | xmc[44] << 13;
+			sr = sr >> 3 | xmc[45] << 13;
+			sr = sr >> 3 | xmc[46] << 13;
+			*c++ = sr >> 7;
+			sr = sr >> 3 | xmc[47] << 13;
+			sr = sr >> 3 | xmc[48] << 13;
+			sr = sr >> 3 | xmc[49] << 13;
+			*c++ = sr >> 6;
+			sr = sr >> 3 | xmc[50] << 13;
+			sr = sr >> 3 | xmc[51] << 13;
+			*c++ = sr >> 8;
+		}
+	}
+
+	else
+
+#endif	/* WAV49 */
+	{
+
+		*c++ =   ((GSM_MAGIC & 0xF) << 4)		/* 1 */
+		       | ((LARc[0] >> 2) & 0xF);
+		*c++ =   ((LARc[0] & 0x3) << 6)
+		       | (LARc[1] & 0x3F);
+		*c++ =   ((LARc[2] & 0x1F) << 3)
+		       | ((LARc[3] >> 2) & 0x7);
+		*c++ =   ((LARc[3] & 0x3) << 6)
+		       | ((LARc[4] & 0xF) << 2)
+		       | ((LARc[5] >> 2) & 0x3);
+		*c++ =   ((LARc[5] & 0x3) << 6)
+		       | ((LARc[6] & 0x7) << 3)
+		       | (LARc[7] & 0x7);
+		*c++ =   ((Nc[0] & 0x7F) << 1)
+		       | ((bc[0] >> 1) & 0x1);
+		*c++ =   ((bc[0] & 0x1) << 7)
+		       | ((Mc[0] & 0x3) << 5)
+		       | ((xmaxc[0] >> 1) & 0x1F);
+		*c++ =   ((xmaxc[0] & 0x1) << 7)
+		       | ((xmc[0] & 0x7) << 4)
+		       | ((xmc[1] & 0x7) << 1)
+		       | ((xmc[2] >> 2) & 0x1);
+		*c++ =   ((xmc[2] & 0x3) << 6)
+		       | ((xmc[3] & 0x7) << 3)
+		       | (xmc[4] & 0x7);
+		*c++ =   ((xmc[5] & 0x7) << 5)			/* 10 */
+		       | ((xmc[6] & 0x7) << 2)
+		       | ((xmc[7] >> 1) & 0x3);
+		*c++ =   ((xmc[7] & 0x1) << 7)
+		       | ((xmc[8] & 0x7) << 4)
+		       | ((xmc[9] & 0x7) << 1)
+		       | ((xmc[10] >> 2) & 0x1);
+		*c++ =   ((xmc[10] & 0x3) << 6)
+		       | ((xmc[11] & 0x7) << 3)
+		       | (xmc[12] & 0x7);
+		*c++ =   ((Nc[1] & 0x7F) << 1)
+		       | ((bc[1] >> 1) & 0x1);
+		*c++ =   ((bc[1] & 0x1) << 7)
+		       | ((Mc[1] & 0x3) << 5)
+		       | ((xmaxc[1] >> 1) & 0x1F);
+		*c++ =   ((xmaxc[1] & 0x1) << 7)
+		       | ((xmc[13] & 0x7) << 4)
+		       | ((xmc[14] & 0x7) << 1)
+		       | ((xmc[15] >> 2) & 0x1);
+		*c++ =   ((xmc[15] & 0x3) << 6)
+		       | ((xmc[16] & 0x7) << 3)
+		       | (xmc[17] & 0x7);
+		*c++ =   ((xmc[18] & 0x7) << 5)
+		       | ((xmc[19] & 0x7) << 2)
+		       | ((xmc[20] >> 1) & 0x3);
+		*c++ =   ((xmc[20] & 0x1) << 7)
+		       | ((xmc[21] & 0x7) << 4)
+		       | ((xmc[22] & 0x7) << 1)
+		       | ((xmc[23] >> 2) & 0x1);
+		*c++ =   ((xmc[23] & 0x3) << 6)
+		       | ((xmc[24] & 0x7) << 3)
+		       | (xmc[25] & 0x7);
+		*c++ =   ((Nc[2] & 0x7F) << 1)			/* 20 */
+		       | ((bc[2] >> 1) & 0x1);
+		*c++ =   ((bc[2] & 0x1) << 7)
+		       | ((Mc[2] & 0x3) << 5)
+		       | ((xmaxc[2] >> 1) & 0x1F);
+		*c++ =   ((xmaxc[2] & 0x1) << 7)
+		       | ((xmc[26] & 0x7) << 4)
+		       | ((xmc[27] & 0x7) << 1)
+		       | ((xmc[28] >> 2) & 0x1);
+		*c++ =   ((xmc[28] & 0x3) << 6)
+		       | ((xmc[29] & 0x7) << 3)
+		       | (xmc[30] & 0x7);
+		*c++ =   ((xmc[31] & 0x7) << 5)
+		       | ((xmc[32] & 0x7) << 2)
+		       | ((xmc[33] >> 1) & 0x3);
+		*c++ =   ((xmc[33] & 0x1) << 7)
+		       | ((xmc[34] & 0x7) << 4)
+		       | ((xmc[35] & 0x7) << 1)
+		       | ((xmc[36] >> 2) & 0x1);
+		*c++ =   ((xmc[36] & 0x3) << 6)
+		       | ((xmc[37] & 0x7) << 3)
+		       | (xmc[38] & 0x7);
+		*c++ =   ((Nc[3] & 0x7F) << 1)
+		       | ((bc[3] >> 1) & 0x1);
+		*c++ =   ((bc[3] & 0x1) << 7)
+		       | ((Mc[3] & 0x3) << 5)
+		       | ((xmaxc[3] >> 1) & 0x1F);
+		*c++ =   ((xmaxc[3] & 0x1) << 7)
+		       | ((xmc[39] & 0x7) << 4)
+		       | ((xmc[40] & 0x7) << 1)
+		       | ((xmc[41] >> 2) & 0x1);
+		*c++ =   ((xmc[41] & 0x3) << 6)			/* 30 */
+		       | ((xmc[42] & 0x7) << 3)
+		       | (xmc[43] & 0x7);
+		*c++ =   ((xmc[44] & 0x7) << 5)
+		       | ((xmc[45] & 0x7) << 2)
+		       | ((xmc[46] >> 1) & 0x3);
+		*c++ =   ((xmc[46] & 0x1) << 7)
+		       | ((xmc[47] & 0x7) << 4)
+		       | ((xmc[48] & 0x7) << 1)
+		       | ((xmc[49] >> 2) & 0x1);
+		*c++ =   ((xmc[49] & 0x3) << 6)
+		       | ((xmc[50] & 0x7) << 3)
+		       | (xmc[51] & 0x7);
+
+	}
+}

Modified: trunk/codecs/gsm/src/gsm_explode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_explode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_explode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -415,3 +415,420 @@
 
 	return 0;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "private.h"
+#include "gsm.h"
+#include "proto.h"
+
+int gsm_explode P3((s, c, target), gsm s, gsm_byte * c, gsm_signal * target)
+{
+#	define	LARc	target
+#	define	Nc	*((gsm_signal (*) [17])(target + 8))
+#	define	bc	*((gsm_signal (*) [17])(target + 9))
+#	define	Mc	*((gsm_signal (*) [17])(target + 10))
+#	define	xmaxc	*((gsm_signal (*) [17])(target + 11))
+
+
+#ifdef WAV49
+	if (s->wav_fmt) {
+
+		uword sr = 0;
+
+		if (s->frame_index == 1) {
+
+			sr = *c++;
+			LARc[0] = sr & 0x3f;  sr >>= 6;
+			sr |= (uword)*c++ << 2;
+			LARc[1] = sr & 0x3f;  sr >>= 6;
+			sr |= (uword)*c++ << 4;
+			LARc[2] = sr & 0x1f;  sr >>= 5;
+			LARc[3] = sr & 0x1f;  sr >>= 5;
+			sr |= (uword)*c++ << 2;
+			LARc[4] = sr & 0xf;  sr >>= 4;
+			LARc[5] = sr & 0xf;  sr >>= 4;
+			sr |= (uword)*c++ << 2;			/* 5 */
+			LARc[6] = sr & 0x7;  sr >>= 3;
+			LARc[7] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[0] = sr & 0x7f;  sr >>= 7;
+			bc[0] = sr & 0x3;  sr >>= 2;
+			Mc[0] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[0] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(target + 12)
+			xmc[0] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[1] = sr & 0x7;  sr >>= 3;
+			xmc[2] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[3] = sr & 0x7;  sr >>= 3;
+			xmc[4] = sr & 0x7;  sr >>= 3;
+			xmc[5] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 10 */
+			xmc[6] = sr & 0x7;  sr >>= 3;
+			xmc[7] = sr & 0x7;  sr >>= 3;
+			xmc[8] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[9] = sr & 0x7;  sr >>= 3;
+			xmc[10] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[11] = sr & 0x7;  sr >>= 3;
+			xmc[12] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[1] = sr & 0x7f;  sr >>= 7;
+			bc[1] = sr & 0x3;  sr >>= 2;
+			Mc[1] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[1] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(target + 29 - 13)
+
+			xmc[13] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 15 */
+			xmc[14] = sr & 0x7;  sr >>= 3;
+			xmc[15] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[16] = sr & 0x7;  sr >>= 3;
+			xmc[17] = sr & 0x7;  sr >>= 3;
+			xmc[18] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[19] = sr & 0x7;  sr >>= 3;
+			xmc[20] = sr & 0x7;  sr >>= 3;
+			xmc[21] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[22] = sr & 0x7;  sr >>= 3;
+			xmc[23] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[24] = sr & 0x7;  sr >>= 3;
+			xmc[25] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;			/* 20 */
+			Nc[2] = sr & 0x7f;  sr >>= 7;
+			bc[2] = sr & 0x3;  sr >>= 2;
+			Mc[2] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[2] = sr & 0x3f;  sr >>= 6;
+
+#undef	xmc
+#define	xmc	(target + 46 - 26)
+
+			xmc[26] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[27] = sr & 0x7;  sr >>= 3;
+			xmc[28] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[29] = sr & 0x7;  sr >>= 3;
+			xmc[30] = sr & 0x7;  sr >>= 3;
+			xmc[31] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[32] = sr & 0x7;  sr >>= 3;
+			xmc[33] = sr & 0x7;  sr >>= 3;
+			xmc[34] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 25 */
+			xmc[35] = sr & 0x7;  sr >>= 3;
+			xmc[36] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[37] = sr & 0x7;  sr >>= 3;
+			xmc[38] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[3] = sr & 0x7f;  sr >>= 7;
+			bc[3] = sr & 0x3;  sr >>= 2;
+			Mc[3] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[3] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(target + 63 - 39)
+
+			xmc[39] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[40] = sr & 0x7;  sr >>= 3;
+			xmc[41] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;			/* 30 */
+			xmc[42] = sr & 0x7;  sr >>= 3;
+			xmc[43] = sr & 0x7;  sr >>= 3;
+			xmc[44] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[45] = sr & 0x7;  sr >>= 3;
+			xmc[46] = sr & 0x7;  sr >>= 3;
+			xmc[47] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[48] = sr & 0x7;  sr >>= 3;
+			xmc[49] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[50] = sr & 0x7;  sr >>= 3;
+			xmc[51] = sr & 0x7;  sr >>= 3;
+
+			s->frame_chain = sr & 0xf;
+		}
+		else {
+			sr = s->frame_chain;
+			sr |= (uword)*c++ << 4;			/* 1 */
+			LARc[0] = sr & 0x3f;  sr >>= 6;
+			LARc[1] = sr & 0x3f;  sr >>= 6;
+			sr = *c++;
+			LARc[2] = sr & 0x1f;  sr >>= 5;
+			sr |= (uword)*c++ << 3;
+			LARc[3] = sr & 0x1f;  sr >>= 5;
+			LARc[4] = sr & 0xf;  sr >>= 4;
+			sr |= (uword)*c++ << 2;
+			LARc[5] = sr & 0xf;  sr >>= 4;
+			LARc[6] = sr & 0x7;  sr >>= 3;
+			LARc[7] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 5 */
+			Nc[0] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;
+			bc[0] = sr & 0x3;  sr >>= 2;
+			Mc[0] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[0] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(target + 12)
+			xmc[0] = sr & 0x7;  sr >>= 3;
+			xmc[1] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[2] = sr & 0x7;  sr >>= 3;
+			xmc[3] = sr & 0x7;  sr >>= 3;
+			xmc[4] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[5] = sr & 0x7;  sr >>= 3;
+			xmc[6] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;			/* 10 */
+			xmc[7] = sr & 0x7;  sr >>= 3;
+			xmc[8] = sr & 0x7;  sr >>= 3;
+			xmc[9] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[10] = sr & 0x7;  sr >>= 3;
+			xmc[11] = sr & 0x7;  sr >>= 3;
+			xmc[12] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[1] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;
+			bc[1] = sr & 0x3;  sr >>= 2;
+			Mc[1] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[1] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(target + 29 - 13)
+
+			xmc[13] = sr & 0x7;  sr >>= 3;
+			xmc[14] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 15 */
+			xmc[15] = sr & 0x7;  sr >>= 3;
+			xmc[16] = sr & 0x7;  sr >>= 3;
+			xmc[17] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[18] = sr & 0x7;  sr >>= 3;
+			xmc[19] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[20] = sr & 0x7;  sr >>= 3;
+			xmc[21] = sr & 0x7;  sr >>= 3;
+			xmc[22] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[23] = sr & 0x7;  sr >>= 3;
+			xmc[24] = sr & 0x7;  sr >>= 3;
+			xmc[25] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[2] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;			/* 20 */
+			bc[2] = sr & 0x3;  sr >>= 2;
+			Mc[2] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[2] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(target + 46 - 26)
+			xmc[26] = sr & 0x7;  sr >>= 3;
+			xmc[27] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;	
+			xmc[28] = sr & 0x7;  sr >>= 3;
+			xmc[29] = sr & 0x7;  sr >>= 3;
+			xmc[30] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[31] = sr & 0x7;  sr >>= 3;
+			xmc[32] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[33] = sr & 0x7;  sr >>= 3;
+			xmc[34] = sr & 0x7;  sr >>= 3;
+			xmc[35] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 25 */
+			xmc[36] = sr & 0x7;  sr >>= 3;
+			xmc[37] = sr & 0x7;  sr >>= 3;
+			xmc[38] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[3] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;		
+			bc[3] = sr & 0x3;  sr >>= 2;
+			Mc[3] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[3] = sr & 0x3f;  sr >>= 6;
+
+#undef	xmc
+#define	xmc	(target + 63 - 39)
+
+			xmc[39] = sr & 0x7;  sr >>= 3;
+			xmc[40] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[41] = sr & 0x7;  sr >>= 3;
+			xmc[42] = sr & 0x7;  sr >>= 3;
+			xmc[43] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 30 */
+			xmc[44] = sr & 0x7;  sr >>= 3;
+			xmc[45] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[46] = sr & 0x7;  sr >>= 3;
+			xmc[47] = sr & 0x7;  sr >>= 3;
+			xmc[48] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[49] = sr & 0x7;  sr >>= 3;
+			xmc[50] = sr & 0x7;  sr >>= 3;
+			xmc[51] = sr & 0x7;  sr >>= 3;
+		}
+	}
+	else 
+#endif
+	{
+	/* GSM_MAGIC  = (*c >> 4) & 0xF; */
+
+	if (((*c >> 4) & 0x0F) != GSM_MAGIC) return -1;
+
+	LARc[0]  = (*c++ & 0xF) << 2;		/* 1 */
+	LARc[0] |= (*c >> 6) & 0x3;
+	LARc[1]  = *c++ & 0x3F;
+	LARc[2]  = (*c >> 3) & 0x1F;
+	LARc[3]  = (*c++ & 0x7) << 2;
+	LARc[3] |= (*c >> 6) & 0x3;
+	LARc[4]  = (*c >> 2) & 0xF;
+	LARc[5]  = (*c++ & 0x3) << 2;
+	LARc[5] |= (*c >> 6) & 0x3;
+	LARc[6]  = (*c >> 3) & 0x7;
+	LARc[7]  = *c++ & 0x7;
+
+	Nc[0]  = (*c >> 1) & 0x7F;
+
+	bc[0]  = (*c++ & 0x1) << 1;
+	bc[0] |= (*c >> 7) & 0x1;
+
+	Mc[0]  = (*c >> 5) & 0x3;
+
+	xmaxc[0]  = (*c++ & 0x1F) << 1;
+	xmaxc[0] |= (*c >> 7) & 0x1;
+
+#undef	xmc
+#define	xmc	(target + 12)
+
+	xmc[0]  = (*c >> 4) & 0x7;
+	xmc[1]  = (*c >> 1) & 0x7;
+	xmc[2]  = (*c++ & 0x1) << 2;
+	xmc[2] |= (*c >> 6) & 0x3;
+	xmc[3]  = (*c >> 3) & 0x7;
+	xmc[4]  = *c++ & 0x7;
+	xmc[5]  = (*c >> 5) & 0x7;
+	xmc[6]  = (*c >> 2) & 0x7;
+	xmc[7]  = (*c++ & 0x3) << 1;		/* 10 */
+	xmc[7] |= (*c >> 7) & 0x1;
+	xmc[8]  = (*c >> 4) & 0x7;
+	xmc[9]  = (*c >> 1) & 0x7;
+	xmc[10]  = (*c++ & 0x1) << 2;
+	xmc[10] |= (*c >> 6) & 0x3;
+	xmc[11]  = (*c >> 3) & 0x7;
+	xmc[12]  = *c++ & 0x7;
+
+	Nc[1]  = (*c >> 1) & 0x7F;
+
+	bc[1]  = (*c++ & 0x1) << 1;
+	bc[1] |= (*c >> 7) & 0x1;
+
+	Mc[1]  = (*c >> 5) & 0x3;
+
+	xmaxc[1]  = (*c++ & 0x1F) << 1;
+	xmaxc[1] |= (*c >> 7) & 0x1;
+
+#undef	xmc
+#define	xmc	(target + 29 - 13)
+
+	xmc[13]  = (*c >> 4) & 0x7;
+	xmc[14]  = (*c >> 1) & 0x7;
+	xmc[15]  = (*c++ & 0x1) << 2;
+	xmc[15] |= (*c >> 6) & 0x3;
+	xmc[16]  = (*c >> 3) & 0x7;
+	xmc[17]  = *c++ & 0x7;
+	xmc[18]  = (*c >> 5) & 0x7;
+	xmc[19]  = (*c >> 2) & 0x7;
+	xmc[20]  = (*c++ & 0x3) << 1;
+	xmc[20] |= (*c >> 7) & 0x1;
+	xmc[21]  = (*c >> 4) & 0x7;
+	xmc[22]  = (*c >> 1) & 0x7;
+	xmc[23]  = (*c++ & 0x1) << 2;
+	xmc[23] |= (*c >> 6) & 0x3;
+	xmc[24]  = (*c >> 3) & 0x7;
+	xmc[25]  = *c++ & 0x7;
+
+	Nc[2]  = (*c >> 1) & 0x7F;
+
+	bc[2]  = (*c++ & 0x1) << 1;		/* 20 */
+	bc[2] |= (*c >> 7) & 0x1;
+
+	Mc[2]  = (*c >> 5) & 0x3;
+
+	xmaxc[2]  = (*c++ & 0x1F) << 1;
+	xmaxc[2] |= (*c >> 7) & 0x1;
+
+#undef	xmc
+#define	xmc	(target + 46 - 26)
+
+	xmc[26]  = (*c >> 4) & 0x7;
+	xmc[27]  = (*c >> 1) & 0x7;
+	xmc[28]  = (*c++ & 0x1) << 2;
+	xmc[28] |= (*c >> 6) & 0x3;
+	xmc[29]  = (*c >> 3) & 0x7;
+	xmc[30]  = *c++ & 0x7;
+	xmc[31]  = (*c >> 5) & 0x7;
+	xmc[32]  = (*c >> 2) & 0x7;
+	xmc[33]  = (*c++ & 0x3) << 1;
+	xmc[33] |= (*c >> 7) & 0x1;
+	xmc[34]  = (*c >> 4) & 0x7;
+	xmc[35]  = (*c >> 1) & 0x7;
+	xmc[36]  = (*c++ & 0x1) << 2;
+	xmc[36] |= (*c >> 6) & 0x3;
+	xmc[37]  = (*c >> 3) & 0x7;
+	xmc[38]  = *c++ & 0x7;
+
+	Nc[3]  = (*c >> 1) & 0x7F;
+
+	bc[3]  = (*c++ & 0x1) << 1;
+	bc[3] |= (*c >> 7) & 0x1;
+
+	Mc[3]  = (*c >> 5) & 0x3;
+
+	xmaxc[3]  = (*c++ & 0x1F) << 1;
+	xmaxc[3] |= (*c >> 7) & 0x1;
+
+#undef	xmc
+#define	xmc	(target + 63 - 39)
+
+	xmc[39]  = (*c >> 4) & 0x7;
+	xmc[40]  = (*c >> 1) & 0x7;
+	xmc[41]  = (*c++ & 0x1) << 2;
+	xmc[41] |= (*c >> 6) & 0x3;
+	xmc[42]  = (*c >> 3) & 0x7;
+	xmc[43]  = *c++ & 0x7;			/* 30  */
+	xmc[44]  = (*c >> 5) & 0x7;
+	xmc[45]  = (*c >> 2) & 0x7;
+	xmc[46]  = (*c++ & 0x3) << 1;
+	xmc[46] |= (*c >> 7) & 0x1;
+	xmc[47]  = (*c >> 4) & 0x7;
+	xmc[48]  = (*c >> 1) & 0x7;
+	xmc[49]  = (*c++ & 0x1) << 2;
+	xmc[49] |= (*c >> 6) & 0x3;
+	xmc[50]  = (*c >> 3) & 0x7;
+	xmc[51]  = *c & 0x7;			/* 33 */
+	}
+
+	return 0;
+}

Modified: trunk/codecs/gsm/src/gsm_implode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_implode.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_implode.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -513,3 +513,518 @@
 	       | (xmc[51] & 0x7);
 	}
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
+
+void gsm_implode P3((s, source, c), gsm s, gsm_signal * source, gsm_byte * c)
+{
+	/*	variable	size	index
+
+		GSM_MAGIC	4	-
+
+		LARc[0]		6	0
+		LARc[1]		6	1
+		LARc[2]		5	2
+		LARc[3]		5	3
+		LARc[4]		4	4
+		LARc[5]		4	5
+		LARc[6]		3	6
+		LARc[7]		3	7
+
+		Nc[0]		7	8
+		bc[0]		2	9
+		Mc[0]		2	10
+		xmaxc[0]	6	11
+		xmc[0]		3	12
+		xmc[1]		3	13
+		xmc[2]		3	14
+		xmc[3]		3	15
+		xmc[4]		3	16
+		xmc[5]		3	17
+		xmc[6]		3	18
+		xmc[7]		3	19
+		xmc[8]		3	20
+		xmc[9]		3	21
+		xmc[10]		3	22
+		xmc[11]		3	23
+		xmc[12]		3	24
+
+		Nc[1]		7	25
+		bc[1]		2	26
+		Mc[1]		2	27
+		xmaxc[1]	6	28
+		xmc[13]		3	29
+		xmc[14]		3	30
+		xmc[15]		3	31
+		xmc[16]		3	32
+		xmc[17]		3	33
+		xmc[18]		3	34
+		xmc[19]		3	35
+		xmc[20]		3	36
+		xmc[21]		3	37
+		xmc[22]		3	38
+		xmc[23]		3	39
+		xmc[24]		3	40
+		xmc[25]		3	41
+
+		Nc[2]		7	42
+		bc[2]		2	43
+		Mc[2]		2	44
+		xmaxc[2]	6	45
+		xmc[26]		3	46
+		xmc[27]		3	47
+		xmc[28]		3	48
+		xmc[29]		3	49
+		xmc[30]		3	50
+		xmc[31]		3	51
+		xmc[32]		3	52
+		xmc[33]		3	53
+		xmc[34]		3	54
+		xmc[35]		3	55
+		xmc[36]		3	56
+		xmc[37]		3	57
+		xmc[38]		3	58
+
+		Nc[3]		7	59
+		bc[3]		2	60
+		Mc[3]		2	61
+		xmaxc[3]	6	62
+		xmc[39]		3	63
+		xmc[40]		3	64
+		xmc[41]		3	65
+		xmc[42]		3	66
+		xmc[43]		3	67
+		xmc[44]		3	68
+		xmc[45]		3	69
+		xmc[46]		3	70
+		xmc[47]		3	71
+		xmc[48]		3	72
+		xmc[49]		3	73
+		xmc[50]		3	74
+		xmc[51]		3	75
+	*/
+
+	/*	There are 76 parameters per frame.  The first eight are
+	 * 	unique.  The remaining 68 are four identical subframes of
+	 * 	17 parameters each.  gsm_implode converts from a representation
+	 * 	of these parameters as values in one array of signed words
+	 * 	to the "packed" version of a GSM frame.
+	 */
+
+#	define	LARc	source
+#	define	Nc	*((gsm_signal (*) [17])(source + 8))
+#	define	bc	*((gsm_signal (*) [17])(source + 9))
+#	define	Mc	*((gsm_signal (*) [17])(source + 10))
+#	define	xmaxc	*((gsm_signal (*) [17])(source + 11))
+
+#ifdef WAV49
+	if (s->wav_fmt) {
+
+		uword sr = 0;
+		if (s->frame_index == 0) {
+
+			sr = *c++;
+			LARc[0] = sr & 0x3f;  sr >>= 6;
+			sr |= (uword)*c++ << 2;
+			LARc[1] = sr & 0x3f;  sr >>= 6;
+			sr |= (uword)*c++ << 4;
+			LARc[2] = sr & 0x1f;  sr >>= 5;
+			LARc[3] = sr & 0x1f;  sr >>= 5;
+			sr |= (uword)*c++ << 2;
+			LARc[4] = sr & 0xf;  sr >>= 4;
+			LARc[5] = sr & 0xf;  sr >>= 4;
+			sr |= (uword)*c++ << 2;			/* 5 */
+			LARc[6] = sr & 0x7;  sr >>= 3;
+			LARc[7] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[0] = sr & 0x7f;  sr >>= 7;
+			bc[0] = sr & 0x3;  sr >>= 2;
+			Mc[0] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[0] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 12)
+			xmc[0] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[1] = sr & 0x7;  sr >>= 3;
+			xmc[2] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[3] = sr & 0x7;  sr >>= 3;
+			xmc[4] = sr & 0x7;  sr >>= 3;
+			xmc[5] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 10 */
+			xmc[6] = sr & 0x7;  sr >>= 3;
+			xmc[7] = sr & 0x7;  sr >>= 3;
+			xmc[8] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[9] = sr & 0x7;  sr >>= 3;
+			xmc[10] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[11] = sr & 0x7;  sr >>= 3;
+			xmc[12] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[1] = sr & 0x7f;  sr >>= 7;
+			bc[1] = sr & 0x3;  sr >>= 2;
+			Mc[1] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[1] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 29 - 13)
+			xmc[13] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 15 */
+			xmc[14] = sr & 0x7;  sr >>= 3;
+			xmc[15] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[16] = sr & 0x7;  sr >>= 3;
+			xmc[17] = sr & 0x7;  sr >>= 3;
+			xmc[18] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[19] = sr & 0x7;  sr >>= 3;
+			xmc[20] = sr & 0x7;  sr >>= 3;
+			xmc[21] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[22] = sr & 0x7;  sr >>= 3;
+			xmc[23] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[24] = sr & 0x7;  sr >>= 3;
+			xmc[25] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;			/* 20 */
+			Nc[2] = sr & 0x7f;  sr >>= 7;
+			bc[2] = sr & 0x3;  sr >>= 2;
+			Mc[2] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[2] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 46 - 26)
+			xmc[26] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[27] = sr & 0x7;  sr >>= 3;
+			xmc[28] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[29] = sr & 0x7;  sr >>= 3;
+			xmc[30] = sr & 0x7;  sr >>= 3;
+			xmc[31] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[32] = sr & 0x7;  sr >>= 3;
+			xmc[33] = sr & 0x7;  sr >>= 3;
+			xmc[34] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 25 */
+			xmc[35] = sr & 0x7;  sr >>= 3;
+			xmc[36] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[37] = sr & 0x7;  sr >>= 3;
+			xmc[38] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 4;
+			Nc[3] = sr & 0x7f;  sr >>= 7;
+			bc[3] = sr & 0x3;  sr >>= 2;
+			Mc[3] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 1;
+			xmaxc[3] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 63 - 39)
+
+			xmc[39] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[40] = sr & 0x7;  sr >>= 3;
+			xmc[41] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;			/* 30 */
+			xmc[42] = sr & 0x7;  sr >>= 3;
+			xmc[43] = sr & 0x7;  sr >>= 3;
+			xmc[44] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[45] = sr & 0x7;  sr >>= 3;
+			xmc[46] = sr & 0x7;  sr >>= 3;
+			xmc[47] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[48] = sr & 0x7;  sr >>= 3;
+			xmc[49] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[50] = sr & 0x7;  sr >>= 3;
+			xmc[51] = sr & 0x7;  sr >>= 3;
+
+			s->frame_chain = sr & 0xf;
+		}
+		else {
+			sr = s->frame_chain;
+			sr |= (uword)*c++ << 4;			/* 1 */
+			LARc[0] = sr & 0x3f;  sr >>= 6;
+			LARc[1] = sr & 0x3f;  sr >>= 6;
+			sr = *c++;
+			LARc[2] = sr & 0x1f;  sr >>= 5;
+			sr |= (uword)*c++ << 3;
+			LARc[3] = sr & 0x1f;  sr >>= 5;
+			LARc[4] = sr & 0xf;  sr >>= 4;
+			sr |= (uword)*c++ << 2;
+			LARc[5] = sr & 0xf;  sr >>= 4;
+			LARc[6] = sr & 0x7;  sr >>= 3;
+			LARc[7] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 5 */
+			Nc[0] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;
+			bc[0] = sr & 0x3;  sr >>= 2;
+			Mc[0] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[0] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 12)
+			xmc[0] = sr & 0x7;  sr >>= 3;
+			xmc[1] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[2] = sr & 0x7;  sr >>= 3;
+			xmc[3] = sr & 0x7;  sr >>= 3;
+			xmc[4] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[5] = sr & 0x7;  sr >>= 3;
+			xmc[6] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;			/* 10 */
+			xmc[7] = sr & 0x7;  sr >>= 3;
+			xmc[8] = sr & 0x7;  sr >>= 3;
+			xmc[9] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[10] = sr & 0x7;  sr >>= 3;
+			xmc[11] = sr & 0x7;  sr >>= 3;
+			xmc[12] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[1] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;
+			bc[1] = sr & 0x3;  sr >>= 2;
+			Mc[1] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[1] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 29 - 13)
+			xmc[13] = sr & 0x7;  sr >>= 3;
+			xmc[14] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 15 */
+			xmc[15] = sr & 0x7;  sr >>= 3;
+			xmc[16] = sr & 0x7;  sr >>= 3;
+			xmc[17] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[18] = sr & 0x7;  sr >>= 3;
+			xmc[19] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[20] = sr & 0x7;  sr >>= 3;
+			xmc[21] = sr & 0x7;  sr >>= 3;
+			xmc[22] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[23] = sr & 0x7;  sr >>= 3;
+			xmc[24] = sr & 0x7;  sr >>= 3;
+			xmc[25] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[2] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;			/* 20 */
+			bc[2] = sr & 0x3;  sr >>= 2;
+			Mc[2] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[2] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 46 - 26)
+			xmc[26] = sr & 0x7;  sr >>= 3;
+			xmc[27] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;	
+			xmc[28] = sr & 0x7;  sr >>= 3;
+			xmc[29] = sr & 0x7;  sr >>= 3;
+			xmc[30] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			xmc[31] = sr & 0x7;  sr >>= 3;
+			xmc[32] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[33] = sr & 0x7;  sr >>= 3;
+			xmc[34] = sr & 0x7;  sr >>= 3;
+			xmc[35] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;			/* 25 */
+			xmc[36] = sr & 0x7;  sr >>= 3;
+			xmc[37] = sr & 0x7;  sr >>= 3;
+			xmc[38] = sr & 0x7;  sr >>= 3;
+			sr = *c++;
+			Nc[3] = sr & 0x7f;  sr >>= 7;
+			sr |= (uword)*c++ << 1;		
+			bc[3] = sr & 0x3;  sr >>= 2;
+			Mc[3] = sr & 0x3;  sr >>= 2;
+			sr |= (uword)*c++ << 5;
+			xmaxc[3] = sr & 0x3f;  sr >>= 6;
+#undef	xmc
+#define	xmc	(source + 63 - 39)
+
+			xmc[39] = sr & 0x7;  sr >>= 3;
+			xmc[40] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[41] = sr & 0x7;  sr >>= 3;
+			xmc[42] = sr & 0x7;  sr >>= 3;
+			xmc[43] = sr & 0x7;  sr >>= 3;
+			sr = *c++;				/* 30 */
+			xmc[44] = sr & 0x7;  sr >>= 3;
+			xmc[45] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 2;
+			xmc[46] = sr & 0x7;  sr >>= 3;
+			xmc[47] = sr & 0x7;  sr >>= 3;
+			xmc[48] = sr & 0x7;  sr >>= 3;
+			sr |= (uword)*c++ << 1;
+			xmc[49] = sr & 0x7;  sr >>= 3;
+			xmc[50] = sr & 0x7;  sr >>= 3;
+			xmc[51] = sr & 0x7;  sr >>= 3;
+		}
+	}
+	else
+#endif 
+	{
+
+	*c++ =   ((GSM_MAGIC & 0xF) << 4)		/* 1 */
+	       | ((LARc[0] >> 2) & 0xF);
+	*c++ =   ((LARc[0] & 0x3) << 6)
+	       | (LARc[1] & 0x3F);
+	*c++ =   ((LARc[2] & 0x1F) << 3)
+	       | ((LARc[3] >> 2) & 0x7);
+	*c++ =   ((LARc[3] & 0x3) << 6)
+	       | ((LARc[4] & 0xF) << 2)
+	       | ((LARc[5] >> 2) & 0x3);
+	*c++ =   ((LARc[5] & 0x3) << 6)
+	       | ((LARc[6] & 0x7) << 3)
+	       | (LARc[7] & 0x7);
+
+
+	*c++ =   ((Nc[0] & 0x7F) << 1)
+
+
+	       | ((bc[0] >> 1) & 0x1);
+	*c++ =   ((bc[0] & 0x1) << 7)
+
+
+	       | ((Mc[0] & 0x3) << 5)
+
+	       | ((xmaxc[0] >> 1) & 0x1F);
+	*c++ =   ((xmaxc[0] & 0x1) << 7)
+
+#undef xmc
+#define	xmc	(source + 12)
+
+	       | ((xmc[0] & 0x7) << 4)
+	       | ((xmc[1] & 0x7) << 1)
+	       | ((xmc[2] >> 2) & 0x1);
+	*c++ =   ((xmc[2] & 0x3) << 6)
+	       | ((xmc[3] & 0x7) << 3)
+	       | (xmc[4] & 0x7);
+	*c++ =   ((xmc[5] & 0x7) << 5)			/* 10 */
+	       | ((xmc[6] & 0x7) << 2)
+	       | ((xmc[7] >> 1) & 0x3);
+	*c++ =   ((xmc[7] & 0x1) << 7)
+	       | ((xmc[8] & 0x7) << 4)
+	       | ((xmc[9] & 0x7) << 1)
+	       | ((xmc[10] >> 2) & 0x1);
+	*c++ =   ((xmc[10] & 0x3) << 6)
+	       | ((xmc[11] & 0x7) << 3)
+	       | (xmc[12] & 0x7);
+
+
+	*c++ =   ((Nc[1] & 0x7F) << 1)
+
+
+	       | ((bc[1] >> 1) & 0x1);
+	*c++ =   ((bc[1] & 0x1) << 7)
+
+
+	       | ((Mc[1] & 0x3) << 5)
+
+
+	       | ((xmaxc[1] >> 1) & 0x1F);
+	*c++ =   ((xmaxc[1] & 0x1) << 7)
+
+#undef	xmc
+#define	xmc	(source + 29 - 13)
+
+	       | ((xmc[13] & 0x7) << 4)
+	       | ((xmc[14] & 0x7) << 1)
+	       | ((xmc[15] >> 2) & 0x1);
+	*c++ =   ((xmc[15] & 0x3) << 6)
+	       | ((xmc[16] & 0x7) << 3)
+	       | (xmc[17] & 0x7);
+	*c++ =   ((xmc[18] & 0x7) << 5)
+	       | ((xmc[19] & 0x7) << 2)
+	       | ((xmc[20] >> 1) & 0x3);
+	*c++ =   ((xmc[20] & 0x1) << 7)
+	       | ((xmc[21] & 0x7) << 4)
+	       | ((xmc[22] & 0x7) << 1)
+	       | ((xmc[23] >> 2) & 0x1);
+	*c++ =   ((xmc[23] & 0x3) << 6)
+	       | ((xmc[24] & 0x7) << 3)
+	       | (xmc[25] & 0x7);
+
+
+	*c++ =   ((Nc[2] & 0x7F) << 1)			/* 20 */
+
+
+	       | ((bc[2] >> 1) & 0x1);
+	*c++ =   ((bc[2] & 0x1) << 7)
+
+
+	       | ((Mc[2] & 0x3) << 5)
+
+
+	       | ((xmaxc[2] >> 1) & 0x1F);
+	*c++ =   ((xmaxc[2] & 0x1) << 7)
+
+#undef	xmc
+#define	xmc	(source + 46 - 26)
+
+	       | ((xmc[26] & 0x7) << 4)
+	       | ((xmc[27] & 0x7) << 1)
+	       | ((xmc[28] >> 2) & 0x1);
+	*c++ =   ((xmc[28] & 0x3) << 6)
+	       | ((xmc[29] & 0x7) << 3)
+	       | (xmc[30] & 0x7);
+	*c++ =   ((xmc[31] & 0x7) << 5)
+	       | ((xmc[32] & 0x7) << 2)
+	       | ((xmc[33] >> 1) & 0x3);
+	*c++ =   ((xmc[33] & 0x1) << 7)
+	       | ((xmc[34] & 0x7) << 4)
+	       | ((xmc[35] & 0x7) << 1)
+	       | ((xmc[36] >> 2) & 0x1);
+	*c++ =   ((xmc[36] & 0x3) << 6)
+	       | ((xmc[37] & 0x7) << 3)
+	       | (xmc[38] & 0x7);
+
+
+	*c++ =   ((Nc[3] & 0x7F) << 1)
+
+
+	       | ((bc[3] >> 1) & 0x1);
+	*c++ =   ((bc[3] & 0x1) << 7)
+
+
+	       | ((Mc[3] & 0x3) << 5)
+
+
+	       | ((xmaxc[3] >> 1) & 0x1F);
+	*c++ =   ((xmaxc[3] & 0x1) << 7)
+
+#undef	xmc
+#define	xmc	(source + 63 - 39)
+
+	       | ((xmc[39] & 0x7) << 4)
+	       | ((xmc[40] & 0x7) << 1)
+	       | ((xmc[41] >> 2) & 0x1);
+	*c++ =   ((xmc[41] & 0x3) << 6)			/* 30 */
+	       | ((xmc[42] & 0x7) << 3)
+	       | (xmc[43] & 0x7);
+	*c++ =   ((xmc[44] & 0x7) << 5)
+	       | ((xmc[45] & 0x7) << 2)
+	       | ((xmc[46] >> 1) & 0x3);
+	*c++ =   ((xmc[46] & 0x1) << 7)
+	       | ((xmc[47] & 0x7) << 4)
+	       | ((xmc[48] & 0x7) << 1)
+	       | ((xmc[49] >> 2) & 0x1);
+	*c++ =   ((xmc[49] & 0x3) << 6)
+	       | ((xmc[50] & 0x7) << 3)
+	       | (xmc[51] & 0x7);
+	}
+}

Modified: trunk/codecs/gsm/src/gsm_option.c
===================================================================
--- trunk/codecs/gsm/src/gsm_option.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_option.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -67,3 +67,72 @@
 	}
 	return result;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
+
+int gsm_option P3((r, opt, val), gsm r, int opt, int * val)
+{
+	int 	result = -1;
+
+	switch (opt) {
+	case GSM_OPT_LTP_CUT:
+#ifdef 	LTP_CUT
+		result = r->ltp_cut;
+		if (val) r->ltp_cut = *val;
+#endif
+		break;
+
+	case GSM_OPT_VERBOSE:
+#ifndef	NDEBUG
+		result = r->verbose;
+		if (val) r->verbose = *val;
+#endif
+		break;
+
+	case GSM_OPT_FAST:
+
+#if	defined(FAST) && defined(USE_FLOAT_MUL)
+		result = r->fast;
+		if (val) r->fast = !!*val;
+#endif
+		break;
+
+	case GSM_OPT_FRAME_CHAIN:
+
+#ifdef WAV49
+		result = r->frame_chain;
+		if (val) r->frame_chain = *val;
+#endif
+		break;
+
+	case GSM_OPT_FRAME_INDEX:
+
+#ifdef WAV49
+		result = r->frame_index;
+		if (val) r->frame_index = *val;
+#endif
+		break;
+
+	case GSM_OPT_WAV49:
+
+#ifdef WAV49 
+		result = r->wav_fmt;
+		if (val) r->wav_fmt = !!*val;
+#endif
+		break;
+
+	default:
+		break;
+	}
+	return result;
+}

Modified: trunk/codecs/gsm/src/gsm_print.c
===================================================================
--- trunk/codecs/gsm/src/gsm_print.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/gsm_print.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -165,3 +165,170 @@
 
 	return 0;
 }
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include	<stdio.h>
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
+
+int gsm_print P3((f, s, c), FILE * f, gsm s, gsm_byte * c)
+{
+	word  	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
+
+	/* GSM_MAGIC  = (*c >> 4) & 0xF; */
+
+	if (((*c >> 4) & 0x0F) != GSM_MAGIC) return -1;
+
+	LARc[0]  = (*c++ & 0xF) << 2;		/* 1 */
+	LARc[0] |= (*c >> 6) & 0x3;
+	LARc[1]  = *c++ & 0x3F;
+	LARc[2]  = (*c >> 3) & 0x1F;
+	LARc[3]  = (*c++ & 0x7) << 2;
+	LARc[3] |= (*c >> 6) & 0x3;
+	LARc[4]  = (*c >> 2) & 0xF;
+	LARc[5]  = (*c++ & 0x3) << 2;
+	LARc[5] |= (*c >> 6) & 0x3;
+	LARc[6]  = (*c >> 3) & 0x7;
+	LARc[7]  = *c++ & 0x7;
+
+
+	Nc[0]  = (*c >> 1) & 0x7F;
+	bc[0]  = (*c++ & 0x1) << 1;
+	bc[0] |= (*c >> 7) & 0x1;
+	Mc[0]  = (*c >> 5) & 0x3;
+	xmaxc[0]  = (*c++ & 0x1F) << 1;
+	xmaxc[0] |= (*c >> 7) & 0x1;
+	xmc[0]  = (*c >> 4) & 0x7;
+	xmc[1]  = (*c >> 1) & 0x7;
+	xmc[2]  = (*c++ & 0x1) << 2;
+	xmc[2] |= (*c >> 6) & 0x3;
+	xmc[3]  = (*c >> 3) & 0x7;
+	xmc[4]  = *c++ & 0x7;
+	xmc[5]  = (*c >> 5) & 0x7;
+	xmc[6]  = (*c >> 2) & 0x7;
+	xmc[7]  = (*c++ & 0x3) << 1;		/* 10 */
+	xmc[7] |= (*c >> 7) & 0x1;
+	xmc[8]  = (*c >> 4) & 0x7;
+	xmc[9]  = (*c >> 1) & 0x7;
+	xmc[10]  = (*c++ & 0x1) << 2;
+	xmc[10] |= (*c >> 6) & 0x3;
+	xmc[11]  = (*c >> 3) & 0x7;
+	xmc[12]  = *c++ & 0x7;
+
+	Nc[1]  = (*c >> 1) & 0x7F;
+	bc[1]  = (*c++ & 0x1) << 1;
+	bc[1] |= (*c >> 7) & 0x1;
+	Mc[1]  = (*c >> 5) & 0x3;
+	xmaxc[1]  = (*c++ & 0x1F) << 1;
+	xmaxc[1] |= (*c >> 7) & 0x1;
+	xmc[13]  = (*c >> 4) & 0x7;
+	xmc[14]  = (*c >> 1) & 0x7;
+	xmc[15]  = (*c++ & 0x1) << 2;
+	xmc[15] |= (*c >> 6) & 0x3;
+	xmc[16]  = (*c >> 3) & 0x7;
+	xmc[17]  = *c++ & 0x7;
+	xmc[18]  = (*c >> 5) & 0x7;
+	xmc[19]  = (*c >> 2) & 0x7;
+	xmc[20]  = (*c++ & 0x3) << 1;
+	xmc[20] |= (*c >> 7) & 0x1;
+	xmc[21]  = (*c >> 4) & 0x7;
+	xmc[22]  = (*c >> 1) & 0x7;
+	xmc[23]  = (*c++ & 0x1) << 2;
+	xmc[23] |= (*c >> 6) & 0x3;
+	xmc[24]  = (*c >> 3) & 0x7;
+	xmc[25]  = *c++ & 0x7;
+
+
+	Nc[2]  = (*c >> 1) & 0x7F;
+	bc[2]  = (*c++ & 0x1) << 1;		/* 20 */
+	bc[2] |= (*c >> 7) & 0x1;
+	Mc[2]  = (*c >> 5) & 0x3;
+	xmaxc[2]  = (*c++ & 0x1F) << 1;
+	xmaxc[2] |= (*c >> 7) & 0x1;
+	xmc[26]  = (*c >> 4) & 0x7;
+	xmc[27]  = (*c >> 1) & 0x7;
+	xmc[28]  = (*c++ & 0x1) << 2;
+	xmc[28] |= (*c >> 6) & 0x3;
+	xmc[29]  = (*c >> 3) & 0x7;
+	xmc[30]  = *c++ & 0x7;
+	xmc[31]  = (*c >> 5) & 0x7;
+	xmc[32]  = (*c >> 2) & 0x7;
+	xmc[33]  = (*c++ & 0x3) << 1;
+	xmc[33] |= (*c >> 7) & 0x1;
+	xmc[34]  = (*c >> 4) & 0x7;
+	xmc[35]  = (*c >> 1) & 0x7;
+	xmc[36]  = (*c++ & 0x1) << 2;
+	xmc[36] |= (*c >> 6) & 0x3;
+	xmc[37]  = (*c >> 3) & 0x7;
+	xmc[38]  = *c++ & 0x7;
+
+	Nc[3]  = (*c >> 1) & 0x7F;
+	bc[3]  = (*c++ & 0x1) << 1;
+	bc[3] |= (*c >> 7) & 0x1;
+	Mc[3]  = (*c >> 5) & 0x3;
+	xmaxc[3]  = (*c++ & 0x1F) << 1;
+	xmaxc[3] |= (*c >> 7) & 0x1;
+
+	xmc[39]  = (*c >> 4) & 0x7;
+	xmc[40]  = (*c >> 1) & 0x7;
+	xmc[41]  = (*c++ & 0x1) << 2;
+	xmc[41] |= (*c >> 6) & 0x3;
+	xmc[42]  = (*c >> 3) & 0x7;
+	xmc[43]  = *c++ & 0x7;			/* 30  */
+	xmc[44]  = (*c >> 5) & 0x7;
+	xmc[45]  = (*c >> 2) & 0x7;
+	xmc[46]  = (*c++ & 0x3) << 1;
+	xmc[46] |= (*c >> 7) & 0x1;
+	xmc[47]  = (*c >> 4) & 0x7;
+	xmc[48]  = (*c >> 1) & 0x7;
+	xmc[49]  = (*c++ & 0x1) << 2;
+	xmc[49] |= (*c >> 6) & 0x3;
+	xmc[50]  = (*c >> 3) & 0x7;
+	xmc[51]  = *c & 0x7;			/* 33 */
+
+	fprintf(f,
+	      "LARc:\t%2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d\n",
+	       LARc[0],LARc[1],LARc[2],LARc[3],LARc[4],LARc[5],LARc[6],LARc[7]);
+
+	fprintf(f, "#1: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n",
+		Nc[0], bc[0], Mc[0], xmaxc[0]);
+	fprintf(f,
+"\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n",
+		xmc[0],xmc[1],xmc[2],xmc[3],xmc[4],xmc[5],xmc[6],
+		xmc[7],xmc[8],xmc[9],xmc[10],xmc[11],xmc[12] );
+
+	fprintf(f, "#2: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n",
+		Nc[1], bc[1], Mc[1], xmaxc[1]);
+	fprintf(f,
+"\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n",
+		xmc[13+0],xmc[13+1],xmc[13+2],xmc[13+3],xmc[13+4],xmc[13+5],
+		xmc[13+6], xmc[13+7],xmc[13+8],xmc[13+9],xmc[13+10],xmc[13+11],
+		xmc[13+12] );
+
+	fprintf(f, "#3: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n",
+		Nc[2], bc[2], Mc[2], xmaxc[2]);
+	fprintf(f,
+"\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n",
+		xmc[26+0],xmc[26+1],xmc[26+2],xmc[26+3],xmc[26+4],xmc[26+5],
+		xmc[26+6], xmc[26+7],xmc[26+8],xmc[26+9],xmc[26+10],xmc[26+11],
+		xmc[26+12] );
+
+	fprintf(f, "#4: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n",
+		Nc[3], bc[3], Mc[3], xmaxc[3]);
+	fprintf(f,
+"\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n",
+		xmc[39+0],xmc[39+1],xmc[39+2],xmc[39+3],xmc[39+4],xmc[39+5],
+		xmc[39+6], xmc[39+7],xmc[39+8],xmc[39+9],xmc[39+10],xmc[39+11],
+		xmc[39+12] );
+
+	return 0;
+}

Modified: trunk/codecs/gsm/src/long_term.c
===================================================================
--- trunk/codecs/gsm/src/long_term.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/long_term.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -13,6 +13,955 @@
 
 #include "gsm.h"
 #include "proto.h"
+
+/*
+ *  4.2.11 .. 4.2.12 LONG TERM PREDICTOR (LTP) SECTION
+ */
+
+
+/*
+ * This module computes the LTP gain (bc) and the LTP lag (Nc)
+ * for the long term analysis filter.   This is done by calculating a
+ * maximum of the cross-correlation function between the current
+ * sub-segment short term residual signal d[0..39] (output of
+ * the short term analysis filter; for simplification the index
+ * of this array begins at 0 and ends at 39 for each sub-segment of the
+ * RPE-LTP analysis) and the previous reconstructed short term
+ * residual signal dp[ -120 .. -1 ].  A dynamic scaling must be
+ * performed to avoid overflow.
+ */
+
+ /* The next procedure exists in six versions.  First two integer
+  * version (if USE_FLOAT_MUL is not defined); then four floating
+  * point versions, twice with proper scaling (USE_FLOAT_MUL defined),
+  * once without (USE_FLOAT_MUL and FAST defined, and fast run-time
+  * option used).  Every pair has first a Cut version (see the -C
+  * option to toast or the LTP_CUT option to gsm_option()), then the
+  * uncut one.  (For a detailed explanation of why this is altogether
+  * a bad idea, see Henry Spencer and Geoff Collyer, ``#ifdef Considered
+  * Harmful''.)
+  */
+
+#ifndef  USE_FLOAT_MUL
+
+#ifdef	LTP_CUT
+
+static void Cut_Calculation_of_the_LTP_parameters P5((st, d,dp,bc_out,Nc_out),
+
+	struct gsm_state * st,
+
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+	word		wt[40];
+
+	longword	L_result;
+	longword	L_max, L_power;
+	word		R, S, dmax, scal, best_k;
+	word		ltp_cut;
+
+	register word	temp, wt_k;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+	for (k = 0; k <= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp > dmax) {
+			dmax = temp;
+			best_k = k;
+		}
+	}
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax > 0);
+		temp = gsm_norm( (longword)dmax << 16 );
+	}
+	if (temp > 6) scal = 0;
+	else scal = 6 - temp;
+	assert(scal >= 0);
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+	wt_k  = SASR(d[best_k], scal);
+
+	for (lambda = 40; lambda <= 120; lambda++) {
+		L_result = (longword)wt_k * dp[best_k - lambda];
+		if (L_result > L_max) {
+			Nc    = lambda;
+			L_max = L_result;
+		}
+	}
+	*Nc_out = Nc;
+	L_max <<= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal <= 100 && scal >= -100);
+	L_max = L_max >> (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc <= 120 && Nc >= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k <= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power <<= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max <= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max >= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   << temp, 16 );
+	S = SASR( L_power << temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc <= 2; bc++) if (R <= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#endif 	/* LTP_CUT */
+
+static void Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+	word		wt[40];
+
+	longword	L_max, L_power;
+	word		R, S, dmax, scal;
+	register word	temp;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+
+	for (k = 0; k <= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp > dmax) dmax = temp;
+	}
+
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax > 0);
+		temp = gsm_norm( (longword)dmax << 16 );
+	}
+
+	if (temp > 6) scal = 0;
+	else scal = 6 - temp;
+
+	assert(scal >= 0);
+
+	/*  Initialization of a working array wt
+	 */
+
+	for (k = 0; k <= 39; k++) wt[k] = SASR( d[k], scal );
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda <= 120; lambda++) {
+
+# undef STEP
+#		define STEP(k) 	(longword)wt[k] * dp[k - lambda]
+
+		register longword L_result;
+
+		L_result  = STEP(0)  ; L_result += STEP(1) ;
+		L_result += STEP(2)  ; L_result += STEP(3) ;
+		L_result += STEP(4)  ; L_result += STEP(5)  ;
+		L_result += STEP(6)  ; L_result += STEP(7)  ;
+		L_result += STEP(8)  ; L_result += STEP(9)  ;
+		L_result += STEP(10) ; L_result += STEP(11) ;
+		L_result += STEP(12) ; L_result += STEP(13) ;
+		L_result += STEP(14) ; L_result += STEP(15) ;
+		L_result += STEP(16) ; L_result += STEP(17) ;
+		L_result += STEP(18) ; L_result += STEP(19) ;
+		L_result += STEP(20) ; L_result += STEP(21) ;
+		L_result += STEP(22) ; L_result += STEP(23) ;
+		L_result += STEP(24) ; L_result += STEP(25) ;
+		L_result += STEP(26) ; L_result += STEP(27) ;
+		L_result += STEP(28) ; L_result += STEP(29) ;
+		L_result += STEP(30) ; L_result += STEP(31) ;
+		L_result += STEP(32) ; L_result += STEP(33) ;
+		L_result += STEP(34) ; L_result += STEP(35) ;
+		L_result += STEP(36) ; L_result += STEP(37) ;
+		L_result += STEP(38) ; L_result += STEP(39) ;
+
+		if (L_result > L_max) {
+
+			Nc    = lambda;
+			L_max = L_result;
+		}
+	}
+
+	*Nc_out = Nc;
+
+	L_max <<= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal <= 100 && scal >=  -100);
+	L_max = L_max >> (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc <= 120 && Nc >= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k <= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power <<= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max <= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max >= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   << temp, 16 );
+	S = SASR( L_power << temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc <= 2; bc++) if (R <= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#else	/* USE_FLOAT_MUL */
+
+#ifdef	LTP_CUT
+
+static void Cut_Calculation_of_the_LTP_parameters P5((st, d,dp,bc_out,Nc_out),
+	struct gsm_state * st,		/*              IN 	*/
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+	word		ltp_cut;
+
+	float		wt_float[40];
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	longword	L_max, L_power;
+	word		R, S, dmax, scal;
+	register word	temp;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+
+	for (k = 0; k <= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp > dmax) dmax = temp;
+	}
+
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax > 0);
+		temp = gsm_norm( (longword)dmax << 16 );
+	}
+
+	if (temp > 6) scal = 0;
+	else scal = 6 - temp;
+
+	assert(scal >= 0);
+	ltp_cut = (longword)SASR(dmax, scal) * st->ltp_cut / 100; 
+
+
+	/*  Initialization of a working array wt
+	 */
+
+	for (k = 0; k < 40; k++) {
+		register word w = SASR( d[k], scal );
+		if (w < 0 ? w > -ltp_cut : w < ltp_cut) {
+			wt_float[k] = 0.0;
+		}
+		else {
+			wt_float[k] =  w;
+		}
+	}
+	for (k = -120; k <  0; k++) dp_float[k] =  dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda <= 120; lambda += 9) {
+
+		/*  Calculate L_result for l = lambda .. lambda + 9.
+		 */
+		register float *lp = dp_float - lambda;
+
+		register float	W;
+		register float	a = lp[-8], b = lp[-7], c = lp[-6],
+				d = lp[-5], e = lp[-4], f = lp[-3],
+				g = lp[-2], h = lp[-1];
+		register float  E; 
+		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
+				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
+
+#		undef STEP
+#		define	STEP(K, a, b, c, d, e, f, g, h) \
+			if ((W = wt_float[K]) != 0.0) {	\
+			E = W * a; S8 += E;		\
+			E = W * b; S7 += E;		\
+			E = W * c; S6 += E;		\
+			E = W * d; S5 += E;		\
+			E = W * e; S4 += E;		\
+			E = W * f; S3 += E;		\
+			E = W * g; S2 += E;		\
+			E = W * h; S1 += E;		\
+			a  = lp[K];			\
+			E = W * a; S0 += E; } else (a = lp[K])
+
+#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
+#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
+#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
+#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
+#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
+#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
+#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
+#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
+
+		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
+		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
+
+		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
+		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
+
+		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
+		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
+
+		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
+		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
+
+		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
+		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
+
+		if (S0 > L_max) { L_max = S0; Nc = lambda;     }
+		if (S1 > L_max) { L_max = S1; Nc = lambda + 1; }
+		if (S2 > L_max) { L_max = S2; Nc = lambda + 2; }
+		if (S3 > L_max) { L_max = S3; Nc = lambda + 3; }
+		if (S4 > L_max) { L_max = S4; Nc = lambda + 4; }
+		if (S5 > L_max) { L_max = S5; Nc = lambda + 5; }
+		if (S6 > L_max) { L_max = S6; Nc = lambda + 6; }
+		if (S7 > L_max) { L_max = S7; Nc = lambda + 7; }
+		if (S8 > L_max) { L_max = S8; Nc = lambda + 8; }
+
+	}
+	*Nc_out = Nc;
+
+	L_max <<= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal <= 100 && scal >=  -100);
+	L_max = L_max >> (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc <= 120 && Nc >= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k <= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power <<= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max <= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max >= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   << temp, 16 );
+	S = SASR( L_power << temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc <= 2; bc++) if (R <= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#endif /* LTP_CUT */
+
+static void Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+
+	float		wt_float[40];
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	longword	L_max, L_power;
+	word		R, S, dmax, scal;
+	register word	temp;
+
+	/*  Search of the optimum scaling of d[0..39].
+	 */
+	dmax = 0;
+
+	for (k = 0; k <= 39; k++) {
+		temp = d[k];
+		temp = GSM_ABS( temp );
+		if (temp > dmax) dmax = temp;
+	}
+
+	temp = 0;
+	if (dmax == 0) scal = 0;
+	else {
+		assert(dmax > 0);
+		temp = gsm_norm( (longword)dmax << 16 );
+	}
+
+	if (temp > 6) scal = 0;
+	else scal = 6 - temp;
+
+	assert(scal >= 0);
+
+	/*  Initialization of a working array wt
+	 */
+
+	for (k =    0; k < 40; k++) wt_float[k] =  SASR( d[k], scal );
+	for (k = -120; k <  0; k++) dp_float[k] =  dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda <= 120; lambda += 9) {
+
+		/*  Calculate L_result for l = lambda .. lambda + 9.
+		 */
+		register float *lp = dp_float - lambda;
+
+		register float	W;
+		register float	a = lp[-8], b = lp[-7], c = lp[-6],
+				d = lp[-5], e = lp[-4], f = lp[-3],
+				g = lp[-2], h = lp[-1];
+		register float  E; 
+		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
+				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
+
+#		undef STEP
+#		define	STEP(K, a, b, c, d, e, f, g, h) \
+			W = wt_float[K];		\
+			E = W * a; S8 += E;		\
+			E = W * b; S7 += E;		\
+			E = W * c; S6 += E;		\
+			E = W * d; S5 += E;		\
+			E = W * e; S4 += E;		\
+			E = W * f; S3 += E;		\
+			E = W * g; S2 += E;		\
+			E = W * h; S1 += E;		\
+			a  = lp[K];			\
+			E = W * a; S0 += E
+
+#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
+#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
+#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
+#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
+#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
+#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
+#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
+#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
+
+		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
+		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
+
+		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
+		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
+
+		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
+		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
+
+		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
+		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
+
+		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
+		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
+
+		if (S0 > L_max) { L_max = S0; Nc = lambda;     }
+		if (S1 > L_max) { L_max = S1; Nc = lambda + 1; }
+		if (S2 > L_max) { L_max = S2; Nc = lambda + 2; }
+		if (S3 > L_max) { L_max = S3; Nc = lambda + 3; }
+		if (S4 > L_max) { L_max = S4; Nc = lambda + 4; }
+		if (S5 > L_max) { L_max = S5; Nc = lambda + 5; }
+		if (S6 > L_max) { L_max = S6; Nc = lambda + 6; }
+		if (S7 > L_max) { L_max = S7; Nc = lambda + 7; }
+		if (S8 > L_max) { L_max = S8; Nc = lambda + 8; }
+	}
+	*Nc_out = Nc;
+
+	L_max <<= 1;
+
+	/*  Rescaling of L_max
+	 */
+	assert(scal <= 100 && scal >=  -100);
+	L_max = L_max >> (6 - scal);	/* sub(6, scal) */
+
+	assert( Nc <= 120 && Nc >= 40);
+
+	/*   Compute the power of the reconstructed short term residual
+	 *   signal dp[..]
+	 */
+	L_power = 0;
+	for (k = 0; k <= 39; k++) {
+
+		register longword L_temp;
+
+		L_temp   = SASR( dp[k - Nc], 3 );
+		L_power += L_temp * L_temp;
+	}
+	L_power <<= 1;	/* from L_MULT */
+
+	/*  Normalization of L_max and L_power
+	 */
+
+	if (L_max <= 0)  {
+		*bc_out = 0;
+		return;
+	}
+	if (L_max >= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	temp = gsm_norm( L_power );
+
+	R = SASR( L_max   << temp, 16 );
+	S = SASR( L_power << temp, 16 );
+
+	/*  Coding of the LTP gain
+	 */
+
+	/*  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	for (bc = 0; bc <= 2; bc++) if (R <= gsm_mult(S, gsm_DLB[bc])) break;
+	*bc_out = bc;
+}
+
+#ifdef	FAST
+#ifdef	LTP_CUT
+
+static void Cut_Fast_Calculation_of_the_LTP_parameters P5((st,
+							d,dp,bc_out,Nc_out),
+	struct gsm_state * st,		/*              IN	*/
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	register float	wt_float;
+	word		Nc, bc;
+	word		wt_max, best_k, ltp_cut;
+
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	register float	L_result, L_max, L_power;
+
+	wt_max = 0;
+
+	for (k = 0; k < 40; ++k) {
+		if      ( d[k] > wt_max) wt_max =  d[best_k = k];
+		else if (-d[k] > wt_max) wt_max = -d[best_k = k];
+	}
+
+	assert(wt_max >= 0);
+	wt_float = (float)wt_max;
+
+	for (k = -120; k < 0; ++k) dp_float[k] = (float)dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda <= 120; lambda++) {
+		L_result = wt_float * dp_float[best_k - lambda];
+		if (L_result > L_max) {
+			Nc    = lambda;
+			L_max = L_result;
+		}
+	}
+
+	*Nc_out = Nc;
+	if (L_max <= 0.)  {
+		*bc_out = 0;
+		return;
+	}
+
+	/*  Compute the power of the reconstructed short term residual
+	 *  signal dp[..]
+	 */
+	dp_float -= Nc;
+	L_power = 0;
+	for (k = 0; k < 40; ++k) {
+		register float f = dp_float[k];
+		L_power += f * f;
+	}
+
+	if (L_max >= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	/*  Coding of the LTP gain
+	 *  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	lambda = L_max / L_power * 32768.;
+	for (bc = 0; bc <= 2; ++bc) if (lambda <= gsm_DLB[bc]) break;
+	*bc_out = bc;
+}
+
+#endif /* LTP_CUT */
+
+static void Fast_Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
+	register word	* d,		/* [0..39]	IN	*/
+	register word	* dp,		/* [-120..-1]	IN	*/
+	word		* bc_out,	/* 		OUT	*/
+	word		* Nc_out	/* 		OUT	*/
+)
+{
+	register int  	k, lambda;
+	word		Nc, bc;
+
+	float		wt_float[40];
+	float		dp_float_base[120], * dp_float = dp_float_base + 120;
+
+	register float	L_max, L_power;
+
+	for (k = 0; k < 40; ++k) wt_float[k] = (float)d[k];
+	for (k = -120; k < 0; ++k) dp_float[k] = (float)dp[k];
+
+	/* Search for the maximum cross-correlation and coding of the LTP lag
+	 */
+	L_max = 0;
+	Nc    = 40;	/* index for the maximum cross-correlation */
+
+	for (lambda = 40; lambda <= 120; lambda += 9) {
+
+		/*  Calculate L_result for l = lambda .. lambda + 9.
+		 */
+		register float *lp = dp_float - lambda;
+
+		register float	W;
+		register float	a = lp[-8], b = lp[-7], c = lp[-6],
+				d = lp[-5], e = lp[-4], f = lp[-3],
+				g = lp[-2], h = lp[-1];
+		register float  E; 
+		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
+				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
+
+#		undef STEP
+#		define	STEP(K, a, b, c, d, e, f, g, h) \
+			W = wt_float[K];		\
+			E = W * a; S8 += E;		\
+			E = W * b; S7 += E;		\
+			E = W * c; S6 += E;		\
+			E = W * d; S5 += E;		\
+			E = W * e; S4 += E;		\
+			E = W * f; S3 += E;		\
+			E = W * g; S2 += E;		\
+			E = W * h; S1 += E;		\
+			a  = lp[K];			\
+			E = W * a; S0 += E
+
+#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
+#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
+#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
+#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
+#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
+#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
+#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
+#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
+
+		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
+		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
+
+		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
+		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
+
+		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
+		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
+
+		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
+		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
+
+		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
+		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
+
+		if (S0 > L_max) { L_max = S0; Nc = lambda;     }
+		if (S1 > L_max) { L_max = S1; Nc = lambda + 1; }
+		if (S2 > L_max) { L_max = S2; Nc = lambda + 2; }
+		if (S3 > L_max) { L_max = S3; Nc = lambda + 3; }
+		if (S4 > L_max) { L_max = S4; Nc = lambda + 4; }
+		if (S5 > L_max) { L_max = S5; Nc = lambda + 5; }
+		if (S6 > L_max) { L_max = S6; Nc = lambda + 6; }
+		if (S7 > L_max) { L_max = S7; Nc = lambda + 7; }
+		if (S8 > L_max) { L_max = S8; Nc = lambda + 8; }
+	}
+	*Nc_out = Nc;
+
+	if (L_max <= 0.)  {
+		*bc_out = 0;
+		return;
+	}
+
+	/*  Compute the power of the reconstructed short term residual
+	 *  signal dp[..]
+	 */
+	dp_float -= Nc;
+	L_power = 0;
+	for (k = 0; k < 40; ++k) {
+		register float f = dp_float[k];
+		L_power += f * f;
+	}
+
+	if (L_max >= L_power) {
+		*bc_out = 3;
+		return;
+	}
+
+	/*  Coding of the LTP gain
+	 *  Table 4.3a must be used to obtain the level DLB[i] for the
+	 *  quantization of the LTP gain b to get the coded version bc.
+	 */
+	lambda = L_max / L_power * 32768.;
+	for (bc = 0; bc <= 2; ++bc) if (lambda <= gsm_DLB[bc]) break;
+	*bc_out = bc;
+}
+
+#endif	/* FAST 	 */
+#endif	/* USE_FLOAT_MUL */
+
+
+/* 4.2.12 */
+
+static void Long_term_analysis_filtering P6((bc,Nc,dp,d,dpp,e),
+	word		bc,	/* 					IN  */
+	word		Nc,	/* 					IN  */
+	register word	* dp,	/* previous d	[-120..-1]		IN  */
+	register word	* d,	/* d		[0..39]			IN  */
+	register word	* dpp,	/* estimate	[0..39]			OUT */
+	register word	* e	/* long term res. signal [0..39]	OUT */
+)
+/*
+ *  In this part, we have to decode the bc parameter to compute
+ *  the samples of the estimate dpp[0..39].  The decoding of bc needs the
+ *  use of table 4.3b.  The long term residual signal e[0..39]
+ *  is then calculated to be fed to the RPE encoding section.
+ */
+{
+	register int      k;
+	register longword ltmp;
+
+#	undef STEP
+#	define STEP(BP)					\
+	for (k = 0; k <= 39; k++) {			\
+		dpp[k]  = GSM_MULT_R( BP, dp[k - Nc]);	\
+		e[k]	= GSM_SUB( d[k], dpp[k] );	\
+	}
+
+	switch (bc) {
+	case 0:	STEP(  3277 ); break;
+	case 1:	STEP( 11469 ); break;
+	case 2: STEP( 21299 ); break;
+	case 3: STEP( 32767 ); break; 
+	}
+}
+
+void Gsm_Long_Term_Predictor P7((S,d,dp,e,dpp,Nc,bc), 	/* 4x for 160 samples */
+
+	struct gsm_state	* S,
+
+	word	* d,	/* [0..39]   residual signal	IN	*/
+	word	* dp,	/* [-120..-1] d'		IN	*/
+
+	word	* e,	/* [0..39] 			OUT	*/
+	word	* dpp,	/* [0..39] 			OUT	*/
+	word	* Nc,	/* correlation lag		OUT	*/
+	word	* bc	/* gain factor			OUT	*/
+)
+{
+	assert( d  ); assert( dp ); assert( e  );
+	assert( dpp); assert( Nc ); assert( bc );
+
+#if defined(FAST) && defined(USE_FLOAT_MUL)
+	if (S->fast) 
+#if   defined (LTP_CUT)
+		if (S->ltp_cut)
+			Cut_Fast_Calculation_of_the_LTP_parameters(S,
+				d, dp, bc, Nc);
+		else
+#endif /* LTP_CUT */
+			Fast_Calculation_of_the_LTP_parameters(d, dp, bc, Nc );
+	else 
+#endif /* FAST & USE_FLOAT_MUL */
+#ifdef LTP_CUT
+		if (S->ltp_cut)
+			Cut_Calculation_of_the_LTP_parameters(S, d, dp, bc, Nc);
+		else
+#endif
+			Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
+
+	Long_term_analysis_filtering( *bc, *Nc, dp, d, dpp, e );
+}
+
+/* 4.3.2 */
+void Gsm_Long_Term_Synthesis_Filtering P5((S,Ncr,bcr,erp,drp),
+	struct gsm_state	* S,
+
+	word			Ncr,
+	word			bcr,
+	register word		* erp,	   /* [0..39]		  	 IN */
+	register word		* drp	   /* [-120..-1] IN, [-120..40] OUT */
+)
+/*
+ *  This procedure uses the bcr and Ncr parameter to realize the
+ *  long term synthesis filtering.  The decoding of bcr needs
+ *  table 4.3b.
+ */
+{
+	register longword	ltmp;	/* for ADD */
+	register int 		k;
+	word			brp, drpp, Nr;
+
+	/*  Check the limits of Nr.
+	 */
+	Nr = Ncr < 40 || Ncr > 120 ? S->nrp : Ncr;
+	S->nrp = Nr;
+	assert(Nr >= 40 && Nr <= 120);
+
+	/*  Decoding of the LTP gain bcr
+	 */
+	brp = gsm_QLB[ bcr ];
+
+	/*  Computation of the reconstructed short term residual 
+	 *  signal drp[0..39]
+	 */
+	assert(brp != MIN_WORD);
+
+	for (k = 0; k <= 39; k++) {
+		drpp   = GSM_MULT_R( brp, drp[ k - Nr ] );
+		drp[k] = GSM_ADD( erp[k], drpp );
+	}
+
+	/*
+	 *  Update of the reconstructed short term residual signal
+	 *  drp[ -1..-120 ]
+	 */
+
+	for (k = 0; k <= 119; k++) drp[ -120 + k ] = drp[ -80 + k ];
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include <stdio.h>
+#include <assert.h>
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
 #ifdef K6OPT
 #include "k6opt.h"
 #endif

Modified: trunk/codecs/gsm/src/lpc.c
===================================================================
--- trunk/codecs/gsm/src/lpc.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/lpc.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -14,6 +14,347 @@
 #include "gsm.h"
 #include "proto.h"
 
+#undef	P
+
+/*
+ *  4.2.4 .. 4.2.7 LPC ANALYSIS SECTION
+ */
+
+/* 4.2.4 */
+
+
+static void Autocorrelation P2((s, L_ACF),
+	word     * s,		/* [0..159]	IN/OUT  */
+ 	longword * L_ACF)	/* [0..8]	OUT     */
+/*
+ *  The goal is to compute the array L_ACF[k].  The signal s[i] must
+ *  be scaled in order to avoid an overflow situation.
+ */
+{
+	register int	k, i;
+
+	word		temp, smax, scalauto;
+
+#ifdef	USE_FLOAT_MUL
+	float		float_s[160];
+#endif
+
+	/*  Dynamic scaling of the array  s[0..159]
+	 */
+
+	/*  Search for the maximum.
+	 */
+	smax = 0;
+	for (k = 0; k <= 159; k++) {
+		temp = GSM_ABS( s[k] );
+		if (temp > smax) smax = temp;
+	}
+
+	/*  Computation of the scaling factor.
+	 */
+	if (smax == 0) scalauto = 0;
+	else {
+		assert(smax > 0);
+		scalauto = 4 - gsm_norm( (longword)smax << 16 );/* sub(4,..) */
+	}
+
+	/*  Scaling of the array s[0...159]
+	 */
+
+	if (scalauto > 0) {
+
+# ifdef USE_FLOAT_MUL
+#   define SCALE(n)	\
+	case n: for (k = 0; k <= 159; k++) \
+			float_s[k] = (float)	\
+				(s[k] = GSM_MULT_R(s[k], 16384 >> (n-1)));\
+		break;
+# else 
+#   define SCALE(n)	\
+	case n: for (k = 0; k <= 159; k++) \
+			s[k] = GSM_MULT_R( s[k], 16384 >> (n-1) );\
+		break;
+# endif /* USE_FLOAT_MUL */
+
+		switch (scalauto) {
+		SCALE(1)
+		SCALE(2)
+		SCALE(3)
+		SCALE(4)
+		}
+# undef	SCALE
+	}
+# ifdef	USE_FLOAT_MUL
+	else for (k = 0; k <= 159; k++) float_s[k] = (float) s[k];
+# endif
+
+	/*  Compute the L_ACF[..].
+	 */
+	{
+# ifdef	USE_FLOAT_MUL
+		register float * sp = float_s;
+		register float   sl = *sp;
+
+#		define STEP(k)	 L_ACF[k] += (longword)(sl * sp[ -(k) ]);
+# else
+		word  * sp = s;
+		word    sl = *sp;
+
+#		define STEP(k)	 L_ACF[k] += ((longword)sl * sp[ -(k) ]);
+# endif
+
+#	define NEXTI	 sl = *++sp
+
+
+	for (k = 9; k--; L_ACF[k] = 0) ;
+
+	STEP (0);
+	NEXTI;
+	STEP(0); STEP(1);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5); STEP(6);
+	NEXTI;
+	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5); STEP(6); STEP(7);
+
+	for (i = 8; i <= 159; i++) {
+
+		NEXTI;
+
+		STEP(0);
+		STEP(1); STEP(2); STEP(3); STEP(4);
+		STEP(5); STEP(6); STEP(7); STEP(8);
+	}
+
+	for (k = 9; k--; L_ACF[k] <<= 1) ; 
+
+	}
+	/*   Rescaling of the array s[0..159]
+	 */
+	if (scalauto > 0) {
+		assert(scalauto <= 4); 
+		for (k = 160; k--; *s++ <<= scalauto) ;
+	}
+}
+
+#if defined(USE_FLOAT_MUL) && defined(FAST)
+
+static void Fast_Autocorrelation P2((s, L_ACF),
+	word * s,		/* [0..159]	IN/OUT  */
+ 	longword * L_ACF)	/* [0..8]	OUT     */
+{
+	register int	k, i;
+	float f_L_ACF[9];
+	float scale;
+
+	float          s_f[160];
+	register float *sf = s_f;
+
+	for (i = 0; i < 160; ++i) sf[i] = s[i];
+	for (k = 0; k <= 8; k++) {
+		register float L_temp2 = 0;
+		register float *sfl = sf - k;
+		for (i = k; i < 160; ++i) L_temp2 += sf[i] * sfl[i];
+		f_L_ACF[k] = L_temp2;
+	}
+	scale = MAX_LONGWORD / f_L_ACF[0];
+
+	for (k = 0; k <= 8; k++) {
+		L_ACF[k] = f_L_ACF[k] * scale;
+	}
+}
+#endif	/* defined (USE_FLOAT_MUL) && defined (FAST) */
+
+/* 4.2.5 */
+
+static void Reflection_coefficients P2( (L_ACF, r),
+	longword	* L_ACF,		/* 0...8	IN	*/
+	register word	* r			/* 0...7	OUT 	*/
+)
+{
+	register int	i, m, n;
+	register word	temp;
+	register longword ltmp;
+	word		ACF[9];	/* 0..8 */
+	word		P[  9];	/* 0..8 */
+	word		K[  9]; /* 2..8 */
+
+	/*  Schur recursion with 16 bits arithmetic.
+	 */
+
+	if (L_ACF[0] == 0) {
+		for (i = 8; i--; *r++ = 0) ;
+		return;
+	}
+
+	assert( L_ACF[0] != 0 );
+	temp = gsm_norm( L_ACF[0] );
+
+	assert(temp >= 0 && temp < 32);
+
+	/* ? overflow ? */
+	for (i = 0; i <= 8; i++) ACF[i] = SASR( L_ACF[i] << temp, 16 );
+
+	/*   Initialize array P[..] and K[..] for the recursion.
+	 */
+
+	for (i = 1; i <= 7; i++) K[ i ] = ACF[ i ];
+	for (i = 0; i <= 8; i++) P[ i ] = ACF[ i ];
+
+	/*   Compute reflection coefficients
+	 */
+	for (n = 1; n <= 8; n++, r++) {
+
+		temp = P[1];
+		temp = GSM_ABS(temp);
+		if (P[0] < temp) {
+			for (i = n; i <= 8; i++) *r++ = 0;
+			return;
+		}
+
+		*r = gsm_div( temp, P[0] );
+
+		assert(*r >= 0);
+		if (P[1] > 0) *r = -*r;		/* r[n] = sub(0, r[n]) */
+		assert (*r != MIN_WORD);
+		if (n == 8) return; 
+
+		/*  Schur recursion
+		 */
+		temp = GSM_MULT_R( P[1], *r );
+		P[0] = GSM_ADD( P[0], temp );
+
+		for (m = 1; m <= 8 - n; m++) {
+			temp     = GSM_MULT_R( K[ m   ],    *r );
+			P[m]     = GSM_ADD(    P[ m+1 ],  temp );
+
+			temp     = GSM_MULT_R( P[ m+1 ],    *r );
+			K[m]     = GSM_ADD(    K[ m   ],  temp );
+		}
+	}
+}
+
+/* 4.2.6 */
+
+static void Transformation_to_Log_Area_Ratios P1((r),
+	register word	* r 			/* 0..7	   IN/OUT */
+)
+/*
+ *  The following scaling for r[..] and LAR[..] has been used:
+ *
+ *  r[..]   = integer( real_r[..]*32768. ); -1 <= real_r < 1.
+ *  LAR[..] = integer( real_LAR[..] * 16384 );
+ *  with -1.625 <= real_LAR <= 1.625
+ */
+{
+	register word	temp;
+	register int	i;
+
+
+	/* Computation of the LAR[0..7] from the r[0..7]
+	 */
+	for (i = 1; i <= 8; i++, r++) {
+
+		temp = *r;
+		temp = GSM_ABS(temp);
+		assert(temp >= 0);
+
+		if (temp < 22118) {
+			temp >>= 1;
+		} else if (temp < 31130) {
+			assert( temp >= 11059 );
+			temp -= 11059;
+		} else {
+			assert( temp >= 26112 );
+			temp -= 26112;
+			temp <<= 2;
+		}
+
+		*r = *r < 0 ? -temp : temp;
+		assert( *r != MIN_WORD );
+	}
+}
+
+/* 4.2.7 */
+
+static void Quantization_and_coding P1((LAR),
+	register word * LAR    	/* [0..7]	IN/OUT	*/
+)
+{
+	register word	temp;
+	longword	ltmp;
+
+
+	/*  This procedure needs four tables; the following equations
+	 *  give the optimum scaling for the constants:
+	 *  
+	 *  A[0..7] = integer( real_A[0..7] * 1024 )
+	 *  B[0..7] = integer( real_B[0..7] *  512 )
+	 *  MAC[0..7] = maximum of the LARc[0..7]
+	 *  MIC[0..7] = minimum of the LARc[0..7]
+	 */
+
+#	undef STEP
+#	define	STEP( A, B, MAC, MIC )		\
+		temp = GSM_MULT( A,   *LAR );	\
+		temp = GSM_ADD(  temp,   B );	\
+		temp = GSM_ADD(  temp, 256 );	\
+		temp = SASR(     temp,   9 );	\
+		*LAR  =  temp>MAC ? MAC - MIC : (temp<MIC ? 0 : temp - MIC); \
+		LAR++;
+
+	STEP(  20480,     0,  31, -32 );
+	STEP(  20480,     0,  31, -32 );
+	STEP(  20480,  2048,  15, -16 );
+	STEP(  20480, -2560,  15, -16 );
+
+	STEP(  13964,    94,   7,  -8 );
+	STEP(  15360, -1792,   7,  -8 );
+	STEP(   8534,  -341,   3,  -4 );
+	STEP(   9036, -1144,   3,  -4 );
+
+#	undef	STEP
+}
+
+void Gsm_LPC_Analysis P3((S, s,LARc),
+	struct gsm_state *S,
+	word 		 * s,		/* 0..159 signals	IN/OUT	*/
+        word 		 * LARc)	/* 0..7   LARc's	OUT	*/
+{
+	longword	L_ACF[9];
+
+#if defined(USE_FLOAT_MUL) && defined(FAST)
+	if (S->fast) Fast_Autocorrelation (s,	  L_ACF );
+	else
+#endif
+	Autocorrelation			  (s,	  L_ACF	);
+	Reflection_coefficients		  (L_ACF, LARc	);
+	Transformation_to_Log_Area_Ratios (LARc);
+	Quantization_and_coding		  (LARc);
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include <stdio.h>
+#include <assert.h>
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
+
 #ifdef K6OPT
 #include "k6opt.h"
 #endif

Modified: trunk/codecs/gsm/src/preprocess.c
===================================================================
--- trunk/codecs/gsm/src/preprocess.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/preprocess.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -36,6 +36,119 @@
 	word		 * s,
 	word 		 * so )		/* [0..159] 	IN/OUT	*/
 {
+
+	word       z1 = S->z1;
+	longword L_z2 = S->L_z2;
+	word 	   mp = S->mp;
+
+	word 	   	s1;
+	longword      L_s2;
+
+	longword      L_temp;
+
+	word		msp, lsp;
+	word		SO;
+
+	longword	ltmp;		/* for   ADD */
+	ulongword	utmp;		/* for L_ADD */
+
+	register int		k = 160;
+
+	while (k--) {
+
+	/*  4.2.1   Downscaling of the input signal
+	 */
+		SO = SASR( *s, 3 ) << 2;
+		s++;
+
+		assert (SO >= -0x4000);	/* downscaled by     */
+		assert (SO <=  0x3FFC);	/* previous routine. */
+
+
+	/*  4.2.2   Offset compensation
+	 * 
+	 *  This part implements a high-pass filter and requires extended
+	 *  arithmetic precision for the recursive part of this filter.
+	 *  The input of this procedure is the array so[0...159] and the
+	 *  output the array sof[ 0...159 ].
+	 */
+		/*   Compute the non-recursive part
+		 */
+
+		s1 = SO - z1;			/* s1 = gsm_sub( *so, z1 ); */
+		z1 = SO;
+
+		assert(s1 != MIN_WORD);
+
+		/*   Compute the recursive part
+		 */
+		L_s2 = s1;
+		L_s2 <<= 15;
+
+		/*   Execution of a 31 bv 16 bits multiplication
+		 */
+
+		msp = SASR( L_z2, 15 );
+		lsp = L_z2-((longword)msp<<15); /* gsm_L_sub(L_z2,(msp<<15)); */
+
+		L_s2  += GSM_MULT_R( lsp, 32735 );
+		L_temp = (longword)msp * 32735; /* GSM_L_MULT(msp,32735) >> 1;*/
+		L_z2   = GSM_L_ADD( L_temp, L_s2 );
+
+		/*    Compute sof[k] with rounding
+		 */
+		L_temp = GSM_L_ADD( L_z2, 16384 );
+
+	/*   4.2.3  Preemphasis
+	 */
+
+		msp   = GSM_MULT_R( mp, -28180 );
+		mp    = SASR( L_temp, 15 );
+		*so++ = GSM_ADD( mp, msp );
+	}
+
+	S->z1   = z1;
+	S->L_z2 = L_z2;
+	S->mp   = mp;
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include	<stdio.h>
+#include	<assert.h>
+
+#include "private.h"
+
+#include	"gsm.h"
+#include 	"proto.h"
+
+/*	4.2.0 .. 4.2.3	PREPROCESSING SECTION
+ *  
+ *  	After A-law to linear conversion (or directly from the
+ *   	Ato D converter) the following scaling is assumed for
+ * 	input to the RPE-LTP algorithm:
+ *
+ *      in:  0.1.....................12
+ *	     S.v.v.v.v.v.v.v.v.v.v.v.v.*.*.*
+ *
+ *	Where S is the sign bit, v a valid bit, and * a "don't care" bit.
+ * 	The original signal is called sop[..]
+ *
+ *      out:   0.1................... 12 
+ *	     S.S.v.v.v.v.v.v.v.v.v.v.v.v.0.0
+ */
+
+
+void Gsm_Preprocess P3((S, s, so),
+	struct gsm_state * S,
+	word		 * s,
+	word 		 * so )		/* [0..159] 	IN/OUT	*/
+{
 	word       	z1 = S->z1;
 	longword 	L_z2 = S->L_z2;
 	word 	   	mp = S->mp;

Modified: trunk/codecs/gsm/src/rpe.c
===================================================================
--- trunk/codecs/gsm/src/rpe.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/rpe.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -18,6 +18,494 @@
  */
 
 /* 4.2.13 */
+
+static void Weighting_filter P2((e, x),
+	register word	* e,		/* signal [-5..0.39.44]	IN  */
+	word		* x		/* signal [0..39]	OUT */
+)
+/*
+ *  The coefficients of the weighting filter are stored in a table
+ *  (see table 4.4).  The following scaling is used:
+ *
+ *	H[0..10] = integer( real_H[ 0..10] * 8192 ); 
+ */
+{
+	/* word			wt[ 50 ]; */
+
+	register longword	L_result;
+	register int		k /* , i */ ;
+
+	/*  Initialization of a temporary working array wt[0...49]
+	 */
+
+	/* for (k =  0; k <=  4; k++) wt[k] = 0;
+	 * for (k =  5; k <= 44; k++) wt[k] = *e++;
+	 * for (k = 45; k <= 49; k++) wt[k] = 0;
+	 *
+	 *  (e[-5..-1] and e[40..44] are allocated by the caller,
+	 *  are initially zero and are not written anywhere.)
+	 */
+	e -= 5;
+
+	/*  Compute the signal x[0..39]
+	 */ 
+	for (k = 0; k <= 39; k++) {
+
+		L_result = 8192 >> 1;
+
+		/* for (i = 0; i <= 10; i++) {
+		 *	L_temp   = GSM_L_MULT( wt[k+i], gsm_H[i] );
+		 *	L_result = GSM_L_ADD( L_result, L_temp );
+		 * }
+		 */
+
+#undef	STEP
+#define	STEP( i, H )	(e[ k + i ] * (longword)H)
+
+		/*  Every one of these multiplications is done twice --
+		 *  but I don't see an elegant way to optimize this. 
+		 *  Do you?
+		 */
+
+#ifdef	STUPID_COMPILER
+		L_result += STEP(	0, 	-134 ) ;
+		L_result += STEP(	1, 	-374 )  ;
+	               /* + STEP(	2, 	0    )  */
+		L_result += STEP(	3, 	2054 ) ;
+		L_result += STEP(	4, 	5741 ) ;
+		L_result += STEP(	5, 	8192 ) ;
+		L_result += STEP(	6, 	5741 ) ;
+		L_result += STEP(	7, 	2054 ) ;
+	 	       /* + STEP(	8, 	0    )  */
+		L_result += STEP(	9, 	-374 ) ;
+		L_result += STEP(	10, 	-134 ) ;
+#else
+		L_result +=
+		  STEP(	0, 	-134 ) 
+		+ STEP(	1, 	-374 ) 
+	     /* + STEP(	2, 	0    )  */
+		+ STEP(	3, 	2054 ) 
+		+ STEP(	4, 	5741 ) 
+		+ STEP(	5, 	8192 ) 
+		+ STEP(	6, 	5741 ) 
+		+ STEP(	7, 	2054 ) 
+	     /* + STEP(	8, 	0    )  */
+		+ STEP(	9, 	-374 ) 
+		+ STEP(10, 	-134 )
+		;
+#endif
+
+		/* L_result = GSM_L_ADD( L_result, L_result ); (* scaling(x2) *)
+		 * L_result = GSM_L_ADD( L_result, L_result ); (* scaling(x4) *)
+		 *
+		 * x[k] = SASR( L_result, 16 );
+		 */
+
+		/* 2 adds vs. >>16 => 14, minus one shift to compensate for
+		 * those we lost when replacing L_MULT by '*'.
+		 */
+
+		L_result = SASR( L_result, 13 );
+		x[k] =  (  L_result < MIN_WORD ? MIN_WORD
+			: (L_result > MAX_WORD ? MAX_WORD : L_result ));
+	}
+}
+
+/* 4.2.14 */
+
+static void RPE_grid_selection P3((x,xM,Mc_out),
+	word		* x,		/* [0..39]		IN  */ 
+	word		* xM,		/* [0..12]		OUT */
+	word		* Mc_out	/*			OUT */
+)
+/*
+ *  The signal x[0..39] is used to select the RPE grid which is
+ *  represented by Mc.
+ */
+{
+	/* register word	temp1;	*/
+	register int		/* m, */  i;
+	register longword	L_result, L_temp;
+	longword		EM;	/* xxx should be L_EM? */
+	word			Mc;
+
+	longword		L_common_0_3;
+
+	EM = 0;
+	Mc = 0;
+
+	/* for (m = 0; m <= 3; m++) {
+	 *	L_result = 0;
+	 *
+	 *
+	 *	for (i = 0; i <= 12; i++) {
+	 *
+	 *		temp1    = SASR( x[m + 3*i], 2 );
+	 *
+	 *		assert(temp1 != MIN_WORD);
+	 *
+	 *		L_temp   = GSM_L_MULT( temp1, temp1 );
+	 *		L_result = GSM_L_ADD( L_temp, L_result );
+	 *	}
+	 * 
+	 *	if (L_result > EM) {
+	 *		Mc = m;
+	 *		EM = L_result;
+	 *	}
+	 * }
+	 */
+
+#undef	STEP
+#define	STEP( m, i )		L_temp = SASR( x[m + 3 * i], 2 );	\
+				L_result += L_temp * L_temp;
+
+	/* common part of 0 and 3 */
+
+	L_result = 0;
+	STEP( 0, 1 ); STEP( 0, 2 ); STEP( 0, 3 ); STEP( 0, 4 );
+	STEP( 0, 5 ); STEP( 0, 6 ); STEP( 0, 7 ); STEP( 0, 8 );
+	STEP( 0, 9 ); STEP( 0, 10); STEP( 0, 11); STEP( 0, 12);
+	L_common_0_3 = L_result;
+
+	/* i = 0 */
+
+	STEP( 0, 0 );
+	L_result <<= 1;	/* implicit in L_MULT */
+	EM = L_result;
+
+	/* i = 1 */
+
+	L_result = 0;
+	STEP( 1, 0 );
+	STEP( 1, 1 ); STEP( 1, 2 ); STEP( 1, 3 ); STEP( 1, 4 );
+	STEP( 1, 5 ); STEP( 1, 6 ); STEP( 1, 7 ); STEP( 1, 8 );
+	STEP( 1, 9 ); STEP( 1, 10); STEP( 1, 11); STEP( 1, 12);
+	L_result <<= 1;
+	if (L_result > EM) {
+		Mc = 1;
+	 	EM = L_result;
+	}
+
+	/* i = 2 */
+
+	L_result = 0;
+	STEP( 2, 0 );
+	STEP( 2, 1 ); STEP( 2, 2 ); STEP( 2, 3 ); STEP( 2, 4 );
+	STEP( 2, 5 ); STEP( 2, 6 ); STEP( 2, 7 ); STEP( 2, 8 );
+	STEP( 2, 9 ); STEP( 2, 10); STEP( 2, 11); STEP( 2, 12);
+	L_result <<= 1;
+	if (L_result > EM) {
+		Mc = 2;
+	 	EM = L_result;
+	}
+
+	/* i = 3 */
+
+	L_result = L_common_0_3;
+	STEP( 3, 12 );
+	L_result <<= 1;
+	if (L_result > EM) {
+		Mc = 3;
+	 	EM = L_result;
+	}
+
+	/**/
+
+	/*  Down-sampling by a factor 3 to get the selected xM[0..12]
+	 *  RPE sequence.
+	 */
+	for (i = 0; i <= 12; i ++) xM[i] = x[Mc + 3*i];
+	*Mc_out = Mc;
+}
+
+/* 4.12.15 */
+
+static void APCM_quantization_xmaxc_to_exp_mant P3((xmaxc,exp_out,mant_out),
+	word		xmaxc,		/* IN 	*/
+	word		* exp_out,	/* OUT	*/
+	word		* mant_out )	/* OUT  */
+{
+	word	exp, mant;
+
+	/* Compute exponent and mantissa of the decoded version of xmaxc
+	 */
+
+	exp = 0;
+	if (xmaxc > 15) exp = SASR(xmaxc, 3) - 1;
+	mant = xmaxc - (exp << 3);
+
+	if (mant == 0) {
+		exp  = -4;
+		mant = 7;
+	}
+	else {
+		while (mant <= 7) {
+			mant = mant << 1 | 1;
+			exp--;
+		}
+		mant -= 8;
+	}
+
+	assert( exp  >= -4 && exp <= 6 );
+	assert( mant >= 0 && mant <= 7 );
+
+	*exp_out  = exp;
+	*mant_out = mant;
+}
+
+static void APCM_quantization P5((xM,xMc,mant_out,exp_out,xmaxc_out),
+	word		* xM,		/* [0..12]		IN	*/
+
+	word		* xMc,		/* [0..12]		OUT	*/
+	word		* mant_out,	/* 			OUT	*/
+	word		* exp_out,	/*			OUT	*/
+	word		* xmaxc_out	/*			OUT	*/
+)
+{
+	int	i, itest;
+
+	word	xmax, xmaxc, temp, temp1, temp2;
+	word	exp, mant;
+
+
+	/*  Find the maximum absolute value xmax of xM[0..12].
+	 */
+
+	xmax = 0;
+	for (i = 0; i <= 12; i++) {
+		temp = xM[i];
+		temp = GSM_ABS(temp);
+		if (temp > xmax) xmax = temp;
+	}
+
+	/*  Qantizing and coding of xmax to get xmaxc.
+	 */
+
+	exp   = 0;
+	temp  = SASR( xmax, 9 );
+	itest = 0;
+
+	for (i = 0; i <= 5; i++) {
+
+		itest |= (temp <= 0);
+		temp = SASR( temp, 1 );
+
+		assert(exp <= 5);
+		if (itest == 0) exp++;		/* exp = add (exp, 1) */
+	}
+
+	assert(exp <= 6 && exp >= 0);
+	temp = exp + 5;
+
+	assert(temp <= 11 && temp >= 0);
+	xmaxc = gsm_add( SASR(xmax, temp), exp << 3 );
+
+	/*   Quantizing and coding of the xM[0..12] RPE sequence
+	 *   to get the xMc[0..12]
+	 */
+
+	APCM_quantization_xmaxc_to_exp_mant( xmaxc, &exp, &mant );
+
+	/*  This computation uses the fact that the decoded version of xmaxc
+	 *  can be calculated by using the exponent and the mantissa part of
+	 *  xmaxc (logarithmic table).
+	 *  So, this method avoids any division and uses only a scaling
+	 *  of the RPE samples by a function of the exponent.  A direct 
+	 *  multiplication by the inverse of the mantissa (NRFAC[0..7]
+	 *  found in table 4.5) gives the 3 bit coded version xMc[0..12]
+	 *  of the RPE samples.
+	 */
+
+
+	/* Direct computation of xMc[0..12] using table 4.5
+	 */
+
+	assert( exp <= 4096 && exp >= -4096);
+	assert( mant >= 0 && mant <= 7 ); 
+
+	temp1 = 6 - exp;		/* normalization by the exponent */
+	temp2 = gsm_NRFAC[ mant ];  	/* inverse mantissa 		 */
+
+	for (i = 0; i <= 12; i++) {
+
+		assert(temp1 >= 0 && temp1 < 16);
+
+		temp = xM[i] << temp1;
+		temp = GSM_MULT( temp, temp2 );
+		temp = SASR(temp, 12);
+		xMc[i] = temp + 4;		/* see note below */
+	}
+
+	/*  NOTE: This equation is used to make all the xMc[i] positive.
+	 */
+
+	*mant_out  = mant;
+	*exp_out   = exp;
+	*xmaxc_out = xmaxc;
+}
+
+/* 4.2.16 */
+
+static void APCM_inverse_quantization P4((xMc,mant,exp,xMp),
+	register word	* xMc,	/* [0..12]			IN 	*/
+	word		mant,
+	word		exp,
+	register word	* xMp)	/* [0..12]			OUT 	*/
+/* 
+ *  This part is for decoding the RPE sequence of coded xMc[0..12]
+ *  samples to obtain the xMp[0..12] array.  Table 4.6 is used to get
+ *  the mantissa of xmaxc (FAC[0..7]).
+ */
+{
+	int	i;
+	word	temp, temp1, temp2, temp3;
+	longword	ltmp;
+
+	assert( mant >= 0 && mant <= 7 ); 
+
+	temp1 = gsm_FAC[ mant ];	/* see 4.2-15 for mant */
+	temp2 = gsm_sub( 6, exp );	/* see 4.2-15 for exp  */
+	temp3 = gsm_asl( 1, gsm_sub( temp2, 1 ));
+
+	for (i = 13; i--;) {
+
+		assert( *xMc <= 7 && *xMc >= 0 ); 	/* 3 bit unsigned */
+
+		/* temp = gsm_sub( *xMc++ << 1, 7 ); */
+		temp = (*xMc++ << 1) - 7;	        /* restore sign   */
+		assert( temp <= 7 && temp >= -7 ); 	/* 4 bit signed   */
+
+		temp <<= 12;				/* 16 bit signed  */
+		temp = GSM_MULT_R( temp1, temp );
+		temp = GSM_ADD( temp, temp3 );
+		*xMp++ = gsm_asr( temp, temp2 );
+	}
+}
+
+/* 4.2.17 */
+
+static void RPE_grid_positioning P3((Mc,xMp,ep),
+	word		Mc,		/* grid position	IN	*/
+	register word	* xMp,		/* [0..12]		IN	*/
+	register word	* ep		/* [0..39]		OUT	*/
+)
+/*
+ *  This procedure computes the reconstructed long term residual signal
+ *  ep[0..39] for the LTP analysis filter.  The inputs are the Mc
+ *  which is the grid position selection and the xMp[0..12] decoded
+ *  RPE samples which are upsampled by a factor of 3 by inserting zero
+ *  values.
+ */
+{
+	int	i = 13;
+
+	assert(0 <= Mc && Mc <= 3);
+
+        switch (Mc) {
+                case 3: *ep++ = 0;
+                case 2:  do {
+                                *ep++ = 0;
+                case 1:         *ep++ = 0;
+                case 0:         *ep++ = *xMp++;
+                         } while (--i);
+        }
+        while (++Mc < 4) *ep++ = 0;
+
+	/*
+
+	int i, k;
+	for (k = 0; k <= 39; k++) ep[k] = 0;
+	for (i = 0; i <= 12; i++) {
+		ep[ Mc + (3*i) ] = xMp[i];
+	}
+	*/
+}
+
+/* 4.2.18 */
+
+/*  This procedure adds the reconstructed long term residual signal
+ *  ep[0..39] to the estimated signal dpp[0..39] from the long term
+ *  analysis filter to compute the reconstructed short term residual
+ *  signal dp[-40..-1]; also the reconstructed short term residual
+ *  array dp[-120..-41] is updated.
+ */
+
+#if 0	/* Has been inlined in code.c */
+void Gsm_Update_of_reconstructed_short_time_residual_signal P3((dpp, ep, dp),
+	word	* dpp,		/* [0...39]	IN	*/
+	word	* ep,		/* [0...39]	IN	*/
+	word	* dp)		/* [-120...-1]  IN/OUT 	*/
+{
+	int 		k;
+
+	for (k = 0; k <= 79; k++) 
+		dp[ -120 + k ] = dp[ -80 + k ];
+
+	for (k = 0; k <= 39; k++)
+		dp[ -40 + k ] = gsm_add( ep[k], dpp[k] );
+}
+#endif	/* Has been inlined in code.c */
+
+void Gsm_RPE_Encoding P5((S,e,xmaxc,Mc,xMc),
+
+	struct gsm_state * S,
+
+	word	* e,		/* -5..-1][0..39][40..44	IN/OUT  */
+	word	* xmaxc,	/* 				OUT */
+	word	* Mc,		/* 			  	OUT */
+	word	* xMc)		/* [0..12]			OUT */
+{
+	word	x[40];
+	word	xM[13], xMp[13];
+	word	mant, exp;
+
+	Weighting_filter(e, x);
+	RPE_grid_selection(x, xM, Mc);
+
+	APCM_quantization(	xM, xMc, &mant, &exp, xmaxc);
+	APCM_inverse_quantization(  xMc,  mant,  exp, xMp);
+
+	RPE_grid_positioning( *Mc, xMp, e );
+
+}
+
+void Gsm_RPE_Decoding P5((S, xmaxcr, Mcr, xMcr, erp),
+	struct gsm_state	* S,
+
+	word 		xmaxcr,
+	word		Mcr,
+	word		* xMcr,  /* [0..12], 3 bits 		IN	*/
+	word		* erp	 /* [0..39]			OUT 	*/
+)
+{
+	word	exp, mant;
+	word	xMp[ 13 ];
+
+	APCM_quantization_xmaxc_to_exp_mant( xmaxcr, &exp, &mant );
+	APCM_inverse_quantization( xMcr, mant, exp, xMp );
+	RPE_grid_positioning( Mcr, xMp, erp );
+
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include <stdio.h>
+#include <assert.h>
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
+
+/*  4.2.13 .. 4.2.17  RPE ENCODING SECTION
+ */
+
+/* 4.2.13 */
 #ifdef K6OPT
 #include "k6opt.h"
 #else

Modified: trunk/codecs/gsm/src/short_term.c
===================================================================
--- trunk/codecs/gsm/src/short_term.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/short_term.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -13,6 +13,435 @@
 
 #include "gsm.h"
 #include "proto.h"
+
+/*
+ *  SHORT TERM ANALYSIS FILTERING SECTION
+ */
+
+/* 4.2.8 */
+
+static void Decoding_of_the_coded_Log_Area_Ratios P2((LARc,LARpp),
+	word 	* LARc,		/* coded log area ratio	[0..7] 	IN	*/
+	word	* LARpp)	/* out: decoded ..			*/
+{
+	register word	temp1 /* , temp2 */;
+	register long	ltmp;	/* for GSM_ADD */
+
+	/*  This procedure requires for efficient implementation
+	 *  two tables.
+ 	 *
+	 *  INVA[1..8] = integer( (32768 * 8) / real_A[1..8])
+	 *  MIC[1..8]  = minimum value of the LARc[1..8]
+	 */
+
+	/*  Compute the LARpp[1..8]
+	 */
+
+	/* 	for (i = 1; i <= 8; i++, B++, MIC++, INVA++, LARc++, LARpp++) {
+	 *
+	 *		temp1  = GSM_ADD( *LARc, *MIC ) << 10;
+	 *		temp2  = *B << 1;
+	 *		temp1  = GSM_SUB( temp1, temp2 );
+	 *
+	 *		assert(*INVA != MIN_WORD);
+	 *
+	 *		temp1  = GSM_MULT_R( *INVA, temp1 );
+	 *		*LARpp = GSM_ADD( temp1, temp1 );
+	 *	}
+	 */
+
+#undef	STEP
+#define	STEP( B, MIC, INVA )	\
+		temp1    = GSM_ADD( *LARc++, MIC ) << 10;	\
+		temp1    = GSM_SUB( temp1, B << 1 );		\
+		temp1    = GSM_MULT_R( INVA, temp1 );		\
+		*LARpp++ = GSM_ADD( temp1, temp1 );
+
+	STEP(      0,  -32,  13107 );
+	STEP(      0,  -32,  13107 );
+	STEP(   2048,  -16,  13107 );
+	STEP(  -2560,  -16,  13107 );
+
+	STEP(     94,   -8,  19223 );
+	STEP(  -1792,   -8,  17476 );
+	STEP(   -341,   -4,  31454 );
+	STEP(  -1144,   -4,  29708 );
+
+	/* NOTE: the addition of *MIC is used to restore
+	 * 	 the sign of *LARc.
+	 */
+}
+
+/* 4.2.9 */
+/* Computation of the quantized reflection coefficients 
+ */
+
+/* 4.2.9.1  Interpolation of the LARpp[1..8] to get the LARp[1..8]
+ */
+
+/*
+ *  Within each frame of 160 analyzed speech samples the short term
+ *  analysis and synthesis filters operate with four different sets of
+ *  coefficients, derived from the previous set of decoded LARs(LARpp(j-1))
+ *  and the actual set of decoded LARs (LARpp(j))
+ *
+ * (Initial value: LARpp(j-1)[1..8] = 0.)
+ */
+
+static void Coefficients_0_12 P3((LARpp_j_1, LARpp_j, LARp),
+	register word * LARpp_j_1,
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int 	i;
+	register longword ltmp;
+
+	for (i = 1; i <= 8; i++, LARp++, LARpp_j_1++, LARpp_j++) {
+		*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));
+		*LARp = GSM_ADD( *LARp,  SASR( *LARpp_j_1, 1));
+	}
+}
+
+static void Coefficients_13_26 P3((LARpp_j_1, LARpp_j, LARp),
+	register word * LARpp_j_1,
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int i;
+	register longword ltmp;
+	for (i = 1; i <= 8; i++, LARpp_j_1++, LARpp_j++, LARp++) {
+		*LARp = GSM_ADD( SASR( *LARpp_j_1, 1), SASR( *LARpp_j, 1 ));
+	}
+}
+
+static void Coefficients_27_39 P3((LARpp_j_1, LARpp_j, LARp),
+	register word * LARpp_j_1,
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int i;
+	register longword ltmp;
+
+	for (i = 1; i <= 8; i++, LARpp_j_1++, LARpp_j++, LARp++) {
+		*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));
+		*LARp = GSM_ADD( *LARp, SASR( *LARpp_j, 1 ));
+	}
+}
+
+
+static void Coefficients_40_159 P2((LARpp_j, LARp),
+	register word * LARpp_j,
+	register word * LARp)
+{
+	register int i;
+
+	for (i = 1; i <= 8; i++, LARp++, LARpp_j++)
+		*LARp = *LARpp_j;
+}
+
+/* 4.2.9.2 */
+
+static void LARp_to_rp P1((LARp),
+	register word * LARp)	/* [0..7] IN/OUT  */
+/*
+ *  The input of this procedure is the interpolated LARp[0..7] array.
+ *  The reflection coefficients, rp[i], are used in the analysis
+ *  filter and in the synthesis filter.
+ */
+{
+	register int 		i;
+	register word		temp;
+	register longword	ltmp;
+
+	for (i = 1; i <= 8; i++, LARp++) {
+
+		/* temp = GSM_ABS( *LARp );
+	         *
+		 * if (temp < 11059) temp <<= 1;
+		 * else if (temp < 20070) temp += 11059;
+		 * else temp = GSM_ADD( temp >> 2, 26112 );
+		 *
+		 * *LARp = *LARp < 0 ? -temp : temp;
+		 */
+
+		if (*LARp < 0) {
+			temp = *LARp == MIN_WORD ? MAX_WORD : -(*LARp);
+			*LARp = - ((temp < 11059) ? temp << 1
+				: ((temp < 20070) ? temp + 11059
+				:  GSM_ADD( temp >> 2, 26112 )));
+		} else {
+			temp  = *LARp;
+			*LARp =    (temp < 11059) ? temp << 1
+				: ((temp < 20070) ? temp + 11059
+				:  GSM_ADD( temp >> 2, 26112 ));
+		}
+	}
+}
+
+
+/* 4.2.10 */
+static void Short_term_analysis_filtering P4((S,rp,k_n,s),
+	struct gsm_state * S,
+	register word	* rp,	/* [0..7]	IN	*/
+	register int 	k_n, 	/*   k_end - k_start	*/
+	register word	* s	/* [0..n-1]	IN/OUT	*/
+)
+/*
+ *  This procedure computes the short term residual signal d[..] to be fed
+ *  to the RPE-LTP loop from the s[..] signal and from the local rp[..]
+ *  array (quantized reflection coefficients).  As the call of this
+ *  procedure can be done in many ways (see the interpolation of the LAR
+ *  coefficient), it is assumed that the computation begins with index
+ *  k_start (for arrays d[..] and s[..]) and stops with index k_end
+ *  (k_start and k_end are defined in 4.2.9.1).  This procedure also
+ *  needs to keep the array u[0..7] in memory for each call.
+ */
+{
+	register word		* u = S->u;
+	register int		i;
+	register word		di, zzz, ui, sav, rpi;
+	register longword 	ltmp;
+
+	for (; k_n--; s++) {
+
+		di = sav = *s;
+
+		for (i = 0; i < 8; i++) {		/* YYY */
+
+			ui    = u[i];
+			rpi   = rp[i];
+			u[i]  = sav;
+
+			zzz   = GSM_MULT_R(rpi, di);
+			sav   = GSM_ADD(   ui,  zzz);
+
+			zzz   = GSM_MULT_R(rpi, ui);
+			di    = GSM_ADD(   di,  zzz );
+		}
+
+		*s = di;
+	}
+}
+
+#if defined(USE_FLOAT_MUL) && defined(FAST)
+
+static void Fast_Short_term_analysis_filtering P4((S,rp,k_n,s),
+	struct gsm_state * S,
+	register word	* rp,	/* [0..7]	IN	*/
+	register int 	k_n, 	/*   k_end - k_start	*/
+	register word	* s	/* [0..n-1]	IN/OUT	*/
+)
+{
+	register word		* u = S->u;
+	register int		i;
+
+	float 	  uf[8],
+		 rpf[8];
+
+	register float scalef = 3.0517578125e-5;
+	register float		sav, di, temp;
+
+	for (i = 0; i < 8; ++i) {
+		uf[i]  = u[i];
+		rpf[i] = rp[i] * scalef;
+	}
+	for (; k_n--; s++) {
+		sav = di = *s;
+		for (i = 0; i < 8; ++i) {
+			register float rpfi = rpf[i];
+			register float ufi  = uf[i];
+
+			uf[i] = sav;
+			temp  = rpfi * di + ufi;
+			di   += rpfi * ufi;
+			sav   = temp;
+		}
+		*s = di;
+	}
+	for (i = 0; i < 8; ++i) u[i] = uf[i];
+}
+#endif /* ! (defined (USE_FLOAT_MUL) && defined (FAST)) */
+
+static void Short_term_synthesis_filtering P5((S,rrp,k,wt,sr),
+	struct gsm_state * S,
+	register word	* rrp,	/* [0..7]	IN	*/
+	register int	k,	/* k_end - k_start	*/
+	register word	* wt,	/* [0..k-1]	IN	*/
+	register word	* sr	/* [0..k-1]	OUT	*/
+)
+{
+	register word		* v = S->v;
+	register int		i;
+	register word		sri, tmp1, tmp2;
+	register longword	ltmp;	/* for GSM_ADD  & GSM_SUB */
+
+	while (k--) {
+		sri = *wt++;
+		for (i = 8; i--;) {
+
+			/* sri = GSM_SUB( sri, gsm_mult_r( rrp[i], v[i] ) );
+			 */
+			tmp1 = rrp[i];
+			tmp2 = v[i];
+			tmp2 =  ( tmp1 == MIN_WORD && tmp2 == MIN_WORD
+				? MAX_WORD
+				: 0x0FFFF & (( (longword)tmp1 * (longword)tmp2
+					     + 16384) >> 15)) ;
+
+			sri  = GSM_SUB( sri, tmp2 );
+
+			/* v[i+1] = GSM_ADD( v[i], gsm_mult_r( rrp[i], sri ) );
+			 */
+			tmp1  = ( tmp1 == MIN_WORD && sri == MIN_WORD
+				? MAX_WORD
+				: 0x0FFFF & (( (longword)tmp1 * (longword)sri
+					     + 16384) >> 15)) ;
+
+			v[i+1] = GSM_ADD( v[i], tmp1);
+		}
+		*sr++ = v[0] = sri;
+	}
+}
+
+
+#if defined(FAST) && defined(USE_FLOAT_MUL)
+
+static void Fast_Short_term_synthesis_filtering P5((S,rrp,k,wt,sr),
+	struct gsm_state * S,
+	register word	* rrp,	/* [0..7]	IN	*/
+	register int	k,	/* k_end - k_start	*/
+	register word	* wt,	/* [0..k-1]	IN	*/
+	register word	* sr	/* [0..k-1]	OUT	*/
+)
+{
+	register word		* v = S->v;
+	register int		i;
+
+	float va[9], rrpa[8];
+	register float scalef = 3.0517578125e-5, temp;
+
+	for (i = 0; i < 8; ++i) {
+		va[i]   = v[i];
+		rrpa[i] = (float)rrp[i] * scalef;
+	}
+	while (k--) {
+		register float sri = *wt++;
+		for (i = 8; i--;) {
+			sri -= rrpa[i] * va[i];
+			if     (sri < -32768.) sri = -32768.;
+			else if (sri > 32767.) sri =  32767.;
+
+			temp = va[i] + rrpa[i] * sri;
+			if     (temp < -32768.) temp = -32768.;
+			else if (temp > 32767.) temp =  32767.;
+			va[i+1] = temp;
+		}
+		*sr++ = va[0] = sri;
+	}
+	for (i = 0; i < 9; ++i) v[i] = va[i];
+}
+
+#endif /* defined(FAST) && defined(USE_FLOAT_MUL) */
+
+void Gsm_Short_Term_Analysis_Filter P3((S,LARc,s),
+
+	struct gsm_state * S,
+
+	word	* LARc,		/* coded log area ratio [0..7]  IN	*/
+	word	* s		/* signal [0..159]		IN/OUT	*/
+)
+{
+	word		* LARpp_j	= S->LARpp[ S->j      ];
+	word		* LARpp_j_1	= S->LARpp[ S->j ^= 1 ];
+
+	word		LARp[8];
+
+#undef	FILTER
+#if 	defined(FAST) && defined(USE_FLOAT_MUL)
+# 	define	FILTER 	(* (S->fast			\
+			   ? Fast_Short_term_analysis_filtering	\
+		    	   : Short_term_analysis_filtering	))
+
+#else
+# 	define	FILTER	Short_term_analysis_filtering
+#endif
+
+	Decoding_of_the_coded_Log_Area_Ratios( LARc, LARpp_j );
+
+	Coefficients_0_12(  LARpp_j_1, LARpp_j, LARp );
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, s);
+
+	Coefficients_13_26( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 14, s + 13);
+
+	Coefficients_27_39( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, s + 27);
+
+	Coefficients_40_159( LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 120, s + 40);
+}
+
+void Gsm_Short_Term_Synthesis_Filter P4((S, LARcr, wt, s),
+	struct gsm_state * S,
+
+	word	* LARcr,	/* received log area ratios [0..7] IN  */
+	word	* wt,		/* received d [0..159]		   IN  */
+
+	word	* s		/* signal   s [0..159]		  OUT  */
+)
+{
+	word		* LARpp_j	= S->LARpp[ S->j     ];
+	word		* LARpp_j_1	= S->LARpp[ S->j ^=1 ];
+
+	word		LARp[8];
+
+#undef	FILTER
+#if 	defined(FAST) && defined(USE_FLOAT_MUL)
+
+# 	define	FILTER 	(* (S->fast			\
+			   ? Fast_Short_term_synthesis_filtering	\
+		    	   : Short_term_synthesis_filtering	))
+#else
+#	define	FILTER	Short_term_synthesis_filtering
+#endif
+
+	Decoding_of_the_coded_Log_Area_Ratios( LARcr, LARpp_j );
+
+	Coefficients_0_12( LARpp_j_1, LARpp_j, LARp );
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, wt, s );
+
+	Coefficients_13_26( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 14, wt + 13, s + 13 );
+
+	Coefficients_27_39( LARpp_j_1, LARpp_j, LARp);
+	LARp_to_rp( LARp );
+	FILTER( S, LARp, 13, wt + 27, s + 27 );
+
+	Coefficients_40_159( LARpp_j, LARp );
+	LARp_to_rp( LARp );
+	FILTER(S, LARp, 120, wt + 40, s + 40);
+}
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+#include <stdio.h>
+#include <assert.h>
+
+#include "private.h"
+
+#include "gsm.h"
+#include "proto.h"
 #ifdef K6OPT
 #include "k6opt.h"
 

Modified: trunk/codecs/gsm/src/table.c
===================================================================
--- trunk/codecs/gsm/src/table.c	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/gsm/src/table.c	2006-06-28 06:25:21 UTC (rev 418)
@@ -61,3 +61,66 @@
  */
 /* i                  0      1       2      3      4      5      6      7   */
 word gsm_FAC[8]	= { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/* $Header$ */
+
+/*  Most of these tables are inlined at their point of use.
+ */
+
+/*  4.4 TABLES USED IN THE FIXED POINT IMPLEMENTATION OF THE RPE-LTP
+ *      CODER AND DECODER
+ *
+ *	(Most of them inlined, so watch out.)
+ */
+
+#define	GSM_TABLE_C
+#include "private.h"
+#include	"gsm.h"
+
+/*  Table 4.1  Quantization of the Log.-Area Ratios
+ */
+/* i 		     1      2      3        4      5      6        7       8 */
+word gsm_A[8]   = {20480, 20480, 20480,  20480,  13964,  15360,   8534,  9036};
+word gsm_B[8]   = {    0,     0,  2048,  -2560,     94,  -1792,   -341, -1144};
+word gsm_MIC[8] = { -32,   -32,   -16,    -16,     -8,     -8,     -4,    -4 };
+word gsm_MAC[8] = {  31,    31,    15,     15,      7,      7,      3,     3 };
+
+
+/*  Table 4.2  Tabulation  of 1/A[1..8]
+ */
+word gsm_INVA[8]={ 13107, 13107,  13107, 13107,  19223, 17476,  31454, 29708 };
+
+
+/*   Table 4.3a  Decision level of the LTP gain quantizer
+ */
+/*  bc		      0	        1	  2	     3			*/
+word gsm_DLB[4] = {  6554,    16384,	26214,	   32767	};
+
+
+/*   Table 4.3b   Quantization levels of the LTP gain quantizer
+ */
+/* bc		      0          1        2          3			*/
+word gsm_QLB[4] = {  3277,    11469,	21299,	   32767	};
+
+
+/*   Table 4.4	 Coefficients of the weighting filter
+ */
+/* i		    0      1   2    3   4      5      6     7   8   9    10  */
+word gsm_H[11] = {-134, -374, 0, 2054, 5741, 8192, 5741, 2054, 0, -374, -134 };
+
+
+/*   Table 4.5 	 Normalized inverse mantissa used to compute xM/xmax 
+ */
+/* i		 	0        1    2      3      4      5     6      7   */
+word gsm_NRFAC[8] = { 29128, 26215, 23832, 21846, 20165, 18725, 17476, 16384 };
+
+
+/*   Table 4.6	 Normalized direct mantissa used to compute xM/xmax
+ */
+/* i                  0      1       2      3      4      5      6      7   */
+word gsm_FAC[8]	= { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };

Modified: trunk/codecs/slin_gsm_ex.h
===================================================================
--- trunk/codecs/slin_gsm_ex.h	2006-06-28 05:25:29 UTC (rev 417)
+++ trunk/codecs/slin_gsm_ex.h	2006-06-28 06:25:21 UTC (rev 418)
@@ -1,3 +1,31 @@
+/*
+  * Signed 16-bit audio data
+  *
+  * Source: gsm.example
+  *
+  * Copyright (C) 1999, Mark Spencer and Linux Support Services
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+static signed short slin_gsm_ex[] = {
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 0xfff8, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 0x0008, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+0x0008, 000000, 000000, 000000, 0xfff8, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
+000000, 000000, 000000, 000000, 000000, 000000, 0x0008, 000000, 000000, 000000 };
 /*! \file
   * \brief Signed 16-bit audio data
   *



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 09:26:14 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 09:26:14 +0200
Subject: [solid-pbx-svn] r419 - trunk/codecs/gsm/inc
Message-ID: <200606280726.k5S7QELq002758@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 09:26:01 +0200 (Wed, 28 Jun 2006)
New Revision: 419

Modified:
   trunk/codecs/gsm/inc/unproto.h
Log:
Update to Asterisk SVN trunk r50

------------------------------------------------------------------------
r41 | markster | 1999-11-15 07:09:01 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.10 from FTP

------------------------------------------------------------------------
r42 | markster | 1999-11-15 07:09:02 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.4 from FTP

------------------------------------------------------------------------
r43 | markster | 1999-11-15 07:09:02 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.11 from FTP

------------------------------------------------------------------------
r44 | markster | 1999-11-15 07:09:03 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.5 from FTP

------------------------------------------------------------------------
r45 | markster | 1999-11-15 07:09:03 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.12 from FTP

------------------------------------------------------------------------
r46 | markster | 1999-11-15 07:09:04 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.6 from FTP

------------------------------------------------------------------------
r47 | markster | 1999-11-15 07:09:04 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.2.0 from FTP

------------------------------------------------------------------------
r48 | markster | 1999-11-15 07:09:05 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.7 from FTP

------------------------------------------------------------------------
r49 | markster | 1999-11-15 07:09:05 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.3.0 from FTP

------------------------------------------------------------------------
r50 | markster | 1999-11-15 23:07:19 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------


Modified: trunk/codecs/gsm/inc/unproto.h
===================================================================
--- trunk/codecs/gsm/inc/unproto.h	2006-06-28 06:25:21 UTC (rev 418)
+++ trunk/codecs/gsm/inc/unproto.h	2006-06-28 07:26:01 UTC (rev 419)
@@ -21,3 +21,26 @@
 #undef	P8
 
 #endif	/* PROTO_H */
+/*
+ * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
+ * Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+ * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+ */
+
+/*$Header$*/
+
+#ifdef	PROTO_H		/* sic */
+#undef	PROTO_H
+
+#undef	P
+#undef	P0
+#undef	P1
+#undef	P2
+#undef	P3
+#undef	P4
+#undef	P5
+#undef	P6
+#undef	P7
+#undef	P8
+
+#endif	/* PROTO_H */



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 10:25:51 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 10:25:51 +0200
Subject: [solid-pbx-svn] r420 - in trunk: . apps channels include/asterisk
Message-ID: <200606280825.k5S8Ppnj016443@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 10:25:38 +0200 (Wed, 28 Jun 2006)
New Revision: 420

Modified:
   trunk/apps/app_playback.c
   trunk/apps/app_voicemail.c
   trunk/channels/Makefile
   trunk/frame.c
   trunk/include/asterisk/file.h
   trunk/include/asterisk/frame.h
   trunk/include/asterisk/translate.h
Log:
Update to Asterisk SVN trunk r70

------------------------------------------------------------------------
r61 | markster | 1999-11-15 23:07:30 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.11 from FTP

------------------------------------------------------------------------
r62 | markster | 1999-11-15 23:07:31 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.1.12 from FTP

------------------------------------------------------------------------
r63 | markster | 1999-11-15 23:07:32 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.2.0 from FTP

------------------------------------------------------------------------
r64 | markster | 1999-11-15 23:07:33 +0100 (Mon, 15 Nov 1999) | 2 lines

Version 0.3.0 from FTP

------------------------------------------------------------------------
r65 | markster | 1999-11-21 03:26:43 +0100 (Sun, 21 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r66 | markster | 1999-11-21 22:15:14 +0100 (Sun, 21 Nov 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r67 | markster | 1999-12-01 06:25:44 +0100 (Wed, 01 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r68 | markster | 1999-12-01 06:25:45 +0100 (Wed, 01 Dec 1999) | 2 lines

Version 0.1.1 from FTP

------------------------------------------------------------------------
r69 | markster | 1999-12-01 06:25:46 +0100 (Wed, 01 Dec 1999) | 2 lines

Version 0.1.2 from FTP

------------------------------------------------------------------------
r70 | markster | 1999-12-01 06:25:47 +0100 (Wed, 01 Dec 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------


Modified: trunk/apps/app_playback.c
===================================================================
--- trunk/apps/app_playback.c	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/apps/app_playback.c	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,4 +1,75 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Trivial application to playback a sound file
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/module.h>
+#include <asterisk/translate.h>
+#include <string.h>
+#include <stdlib.h>
+#include <pthread.h>
+
+static char *tdesc = "Trivial Playback Application";
+
+static char *app = "Playback";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static int playback_exec(struct ast_channel *chan, void *data)
+{
+	int res;
+	struct localuser *u;
+	if (!data) {
+		ast_log(LOG_WARNING, "Playback requires an argument (filename)\n");
+		return -1;
+	}
+	LOCAL_USER_ADD(u);
+	ast_stopstream(chan);
+	res = ast_streamfile(chan, (char *)data);
+	if (!res)
+		res = ast_waitstream(chan, "");
+	ast_stopstream(chan);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	return ast_register_application(app, playback_exec);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/apps/app_voicemail.c	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,4 +1,599 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Voicemail System (did you ever think it could be so easy?)
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/options.h>
+#include <asterisk/config.h>
+#include <asterisk/say.h>
+#include <asterisk/module.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/time.h>
+#include <sys/stat.h>
+#include <time.h>
+
+#include <pthread.h>
+#include "../asterisk.h"
+
+#define COMMAND_TIMEOUT 5000
+
+#define VOICEMAIL_CONFIG "voicemail.conf"
+#define ASTERISK_USERNAME "asterisk"
+
+/*
+#define HOSTNAME_OVERRIDE "linux-support.net"
+*/
+
+#define SENDMAIL "/usr/sbin/sendmail -t"
+
+#define INTRO "vm-intro"
+
+#define MAXMSG 100
+
+#define MAX_OTHER_FORMATS 10
+
+#define VM_SPOOL_DIR AST_SPOOL_DIR "/vm"
+
+
+static char *tdesc = "Comedian Mail (Voicemail System)";
+
+/* Leave a message */
+static char *app = "VoiceMail";
+
+/* Check mail, control, etc */
+static char *app2 = "VoiceMailMain";
+
+STANDARD_LOCAL_USER;
+
+LOCAL_USER_DECL;
+
+static char *get_dir(char *ext, char *mailbox)
+{
+	char *tmp = malloc(strlen(ext) + strlen(VM_SPOOL_DIR) + 3 + strlen(mailbox));
+	sprintf(tmp, "%s/%s/%s", VM_SPOOL_DIR, ext, mailbox);
+	return tmp;
+}
+static char *get_fn(char *dir, int num)
+{
+	char *tmp = malloc(strlen(dir) + 10);
+	sprintf(tmp, "%s/msg%04d", dir, num);
+	return tmp;
+}
+
+static int announce_message(struct ast_channel *chan, char *dir, int msgcnt)
+{
+	char *fn;
+	int res;
+	res = ast_streamfile(chan, "vm-message");
+	if (!res) {
+		res = ast_waitstream(chan, AST_DIGIT_ANY);
+		if (!res) {
+			res = ast_say_number(chan, msgcnt+1);
+			if (!res) {
+				fn = get_fn(dir, msgcnt);
+				if (fn) {
+					res = ast_streamfile(chan, fn);
+					free(fn);
+				}
+			}
+		}
+	}
+	if (res < 0)
+		ast_log(LOG_WARNING, "Unable to announce message\n");
+	return res;
+}
+static int sendmail(char *email, char *name, int msgnum, char *mailbox)
+{
+	FILE *p;
+	char date[256];
+	char host[256];
+	time_t t;
+	struct tm *tm;
+	p = popen(SENDMAIL, "w");
+	if (p) {
+		gethostname(host, sizeof(host));
+		time(&t);
+		tm = localtime(&t);
+		strftime(date, sizeof(date), "%a, %d %b %Y %H:%M:%S %z", tm);
+		fprintf(p, "Date: %s\n", date);
+		fprintf(p, "Message-ID: <Asterisk-%d-%s-%d@%s>\n", msgnum, mailbox, getpid(), host);
+		fprintf(p, "From: Asterisk PBX <%s@%s>\n", ASTERISK_USERNAME,
+#ifdef HOSTNAME_OVERRIDE
+				HOSTNAME_OVERRIDE
+#else
+				host
+#endif
+				);
+		fprintf(p, "To: %s <%s>\n", name, email);
+		fprintf(p, "Subject: [PBX]: New message %d in mailbox %s\n\n", msgnum, mailbox);
+		strftime(date, sizeof(date), "%A, %B %d, %Y at %r", tm);
+		fprintf(p, "Dear %s:\n\n\tJust wanted to let you know you were just left a message (number %d)\n"
+		           "in mailbox %s, on %s so you might\n"
+				   "want to check it when you get a chance.  Thanks!\n\n\t\t\t\t--Asterisk\n", name, msgnum, mailbox, date);
+		fprintf(p, ".\n");
+		pclose(p);
+	} else {
+		ast_log(LOG_WARNING, "Unable to launch '%s'\n", SENDMAIL);
+		return -1;
+	}
+	return 0;
+}
+
+static int leave_voicemail(struct ast_channel *chan, char *ext, int silent)
+{
+	struct ast_config *cfg;
+	char *copy, *name, *passwd, *email, *dir, *fmt, *fmts, *fn=NULL;
+	char comment[256];
+	struct ast_filestream *writer, *others[MAX_OTHER_FORMATS];
+	char *sfmt[MAX_OTHER_FORMATS];
+	int res = -1, fmtcnt=0, x;
+	int msgnum;
+	int outmsg=0;
+	struct ast_frame *f;
+	
+	cfg = ast_load(VOICEMAIL_CONFIG);
+	if (!cfg) {
+		ast_log(LOG_WARNING, "No such configuration file %s\n", VOICEMAIL_CONFIG);
+		return -1;
+	}
+	if ((copy = ast_variable_retrieve(cfg, chan->context, ext))) {
+		/* Make sure they have an entry in the config */
+		copy = strdup(copy);
+		passwd = strtok(copy, ",");
+		name = strtok(NULL, ",");
+		email = strtok(NULL, ",");
+		dir = get_dir(ext, "");
+		/* It's easier just to try to make it than to check for its existence */
+		if (mkdir(dir, 0700) && (errno != EEXIST))
+			ast_log(LOG_WARNING, "mkdir '%s' failed: %s\n", dir, strerror(errno));
+		dir = get_dir(ext, "INBOX");
+		if (mkdir(dir, 0700) && (errno != EEXIST))
+			ast_log(LOG_WARNING, "mkdir '%s' failed: %s\n", dir, strerror(errno));
+		/* Stream an info message */
+		if (silent || !ast_streamfile(chan, INTRO)) {
+			/* Wait for the message to finish */
+			if (silent || !ast_waitstream(chan, "")) {
+				fmt = ast_variable_retrieve(cfg, "general", "format");
+				if (fmt) {
+					fmts = strdup(fmt);
+					fmt = strtok(fmts, "|");
+					msgnum = 0;
+					do {
+						if (fn)
+							free(fn);
+						fn = get_fn(dir, msgnum);
+						snprintf(comment, sizeof(comment), "Voicemail from %s to %s (%s) on %s\n",
+											(chan->callerid ? chan->callerid : "Unknown"), 
+											name, ext, chan->name);
+						writer = ast_writefile(fn, fmt, comment, O_EXCL, 1 /* check for other formats */, 0700);
+						if (!writer && (errno != EEXIST))
+							break;
+						msgnum++;
+					} while(!writer && (msgnum < MAXMSG));
+					if (writer) {
+						/* We need to reset these values */
+						free(fmts);
+						fmt = ast_variable_retrieve(cfg, "general", "format");
+						fmts = strdup(fmt);
+						strtok(fmts, "|");
+						while((fmt = strtok(NULL, "|"))) {
+							if (fmtcnt > MAX_OTHER_FORMATS - 1) {
+								ast_log(LOG_WARNING, "Please increase MAX_OTHER_FORMATS in app_voicemail.c\n");
+								break;
+							}
+							sfmt[fmtcnt++] = strdup(fmt);
+						}
+						for (x=0;x<fmtcnt;x++) {
+							others[x] = ast_writefile(fn, sfmt[x], comment, 0, 0, 0700);
+							if (!others[x]) {
+								/* Ick, the other format didn't work, but be sure not
+								   to leak memory here */
+								int y;
+								for(y=x+1;y < fmtcnt;y++)
+									free(sfmt[y]);
+								break;
+							}
+							free(sfmt[x]);
+						}
+						if (x == fmtcnt) {
+							/* Loop forever, writing the packets we read to the writer(s), until
+							   we read a # or get a hangup */
+							if (option_verbose > 2) 
+								ast_verbose( VERBOSE_PREFIX_3 "Recording to %s\n", fn);
+							while((f = ast_read(chan))) {
+								if (f->frametype == AST_FRAME_VOICE) {
+									/* Write the primary format */
+									res = ast_writestream(writer, f);
+									/* And each of the others */
+									for (x=0;x<fmtcnt;x++)
+										res |= ast_writestream(others[x], f);
+									ast_frfree(f);
+									/* Exit on any error */
+									if (res) {
+										ast_log(LOG_WARNING, "Error writing frame\n");
+										break;
+									}
+								}
+								if (f->frametype == AST_FRAME_DTMF) {
+									if (f->subclass == '#') {
+										if (option_verbose > 2) 
+											ast_verbose( VERBOSE_PREFIX_3 "User ended message by pressing %c\n", f->subclass);
+										outmsg=2;
+										break;
+									}
+								}
+							}
+							if (!f) {
+								if (option_verbose > 2) 
+									ast_verbose( VERBOSE_PREFIX_3 "User hung up\n");
+								res = -1;
+								outmsg=1;
+							}
+						} else {
+							ast_log(LOG_WARNING, "Error creating writestream '%s', format '%s'\n", fn, sfmt[x]); 
+							free(sfmt[x]);
+						}
+						ast_closestream(writer);
+						for (x=0;x<fmtcnt;x++) {
+							if (!others[x])
+								break;
+							ast_closestream(others[x]);
+						}
+						if (outmsg) {
+							if (outmsg > 1) {
+								/* Let them know it worked */
+								ast_streamfile(chan, "vm-msgsaved");
+								ast_waitstream(chan, "");
+							}
+							/* Send e-mail if applicable */
+							if (email) 
+								sendmail(email, name, msgnum, ext);
+						}
+					} else {
+						if (msgnum < MAXMSG)
+							ast_log(LOG_WARNING, "Error writing to mailbox %s\n", ext);
+						else
+							ast_log(LOG_WARNING, "Too many messages in mailbox %s\n", ext);
+					}
+					if (fn)
+						free(fn);
+					free(fmts);
+				} else 
+					ast_log(LOG_WARNING, "No format to save messages in \n");
+			}
+		} else
+			ast_log(LOG_WARNING, "Unable to playback instructions\n");
+			
+		free(dir);
+		free(copy);
+	} else
+		ast_log(LOG_WARNING, "No entry in voicemail config file for '%s'\n", ext);
+	ast_destroy(cfg);
+	/* Leave voicemail for someone */
+	return res;
+}
+
+static int vm_execmain(struct ast_channel *chan, void *data)
+{
+	/* XXX This is, admittedly, some pretty horrendus code XXX */
+	int res=-1;
+	int valid = 0;
+	int curmsg = 0;
+	int maxmsg = 0;
+	int x;
+	char *fn, *nfn;
+	char d;
+	struct localuser *u;
+	char username[80];
+	char password[80], *copy;
+	int deleted[MAXMSG];
+	struct ast_config *cfg;
+	int state;
+	char *dir=NULL;
+	
+	LOCAL_USER_ADD(u);
+	cfg = ast_load(VOICEMAIL_CONFIG);
+	if (!cfg) {
+		ast_log(LOG_WARNING, "No voicemail configuration\n");
+		goto out;
+	}
+	if (ast_streamfile(chan, "vm-login"))
+		goto out;
+	do {
+		/* Prompt for, and read in the username */
+		if (ast_readstring(chan, username, sizeof(username), 2000, 5000, "#"))
+			goto out;
+		if (ast_streamfile(chan, "vm-password"))
+			goto out;
+		if (ast_readstring(chan, password, sizeof(password), 2000, 5000, "#"))
+			goto out;
+		copy = ast_variable_retrieve(cfg, chan->context, username);
+		if (copy) {
+			copy = strdup(copy);
+			strtok(copy, ",");
+			if (!strcmp(password,copy))
+				valid++;
+			else if (option_verbose > 2)
+				ast_verbose( VERBOSE_PREFIX_3 "Incorrect password '%s' for user '%s'\n", password, username);
+			free(copy);
+		} else if (option_verbose > 2)
+			ast_verbose( VERBOSE_PREFIX_3 "No such user '%s' in config file\n", username);
+		if (!valid) {
+			if (ast_streamfile(chan, "vm-incorrect"))
+				break;
+			if (ast_waitstream(chan, ""))
+				break;
+		}
+	} while (!valid);
+	if (valid) {
+		dir = get_dir(username, "INBOX");
+		if (!dir) 
+			goto out;
+
+		deleted[0] = 0;
+		/* Find out how many messages are there, mark all as
+		   not deleted. */
+		do {
+			fn = get_fn(dir, maxmsg);
+			if ((res = ast_fileexists(fn, NULL))>0) {
+				maxmsg++;
+				deleted[maxmsg] = 0;
+			}
+			free(fn);
+		} while(res > 0);
+		if (ast_streamfile(chan, "vm-youhave"))
+			goto out;
+		if ((d=ast_waitstream(chan, AST_DIGIT_ANY)) < 0)
+			goto out;
+		ast_stopstream(chan);
+		if (!d) {
+			/* If they haven't interrupted us, play the message count */
+			if (maxmsg > 0) {
+				if ((d = ast_say_number(chan, maxmsg)) < 0)
+					goto out;
+			} else {
+				if (ast_streamfile(chan, "vm-no"))
+					goto out;
+				if ((d=ast_waitstream(chan, AST_DIGIT_ANY)) < 0)
+					goto out;
+				ast_stopstream(chan);
+			}
+			if (!d) {
+				/* And if they still haven't, give them the last word */
+				if (ast_streamfile(chan, ((maxmsg == 1) ? "vm-message" : "vm-messages")))
+					goto out;
+				if (ast_waitstream(chan, AST_DIGIT_ANY) < 0)
+					goto out;
+				ast_stopstream(chan);
+			}
+		}
+		res = -1;
+				
+#define STATE_STARTING 1
+#define STATE_MESSAGE 2
+#define STATE_MESSAGE_PLAYING 3
+		state = STATE_STARTING;
+		ast_log(LOG_EVENT, "User '%s' logged in on channel '%s' with %d message(s).\n", username, chan->name, maxmsg);
+		if (option_verbose > 2)
+			ast_verbose( VERBOSE_PREFIX_3 "User '%s' logged in on channel %s with %d messages\n", username, chan->name, maxmsg);
+		if (!ast_streamfile(chan, "vm-instructions")) {
+			for(;;) {
+				if (chan->stream || (chan->trans && chan->trans->stream)) {
+					d = ast_waitstream(chan, AST_DIGIT_ANY);
+					ast_stopstream(chan);
+					if (!d && (state == STATE_MESSAGE_PLAYING)) {
+						state  = STATE_MESSAGE;
+						/* If it runs out playing a message, then give directions */
+						if (!(d = ast_streamfile(chan, "vm-msginstruct")))
+							d = ast_waitstream(chan, AST_DIGIT_ANY);
+						ast_stopstream(chan);
+					}
+					if (!d)
+						d = ast_waitfordigit(chan, COMMAND_TIMEOUT);
+				} else
+					d = ast_waitfordigit(chan, COMMAND_TIMEOUT);
+				if (d < 0)
+					goto out;
+restart:
+				if (!d || (d == '*')) {
+					/* If they don't say anything, play back a message.  We'll decide which one is
+					   best based up on where they are.  Ditto if they press the '*' key. */
+					switch(state) {
+					case STATE_STARTING:
+						if (ast_streamfile(chan, "vm-instructions"))
+							goto out;
+						break;
+					case STATE_MESSAGE:
+					case STATE_MESSAGE_PLAYING:
+						if (ast_streamfile(chan, "vm-msginstruct"))
+							goto out;
+						break;
+					default:
+						ast_log(LOG_WARNING, "What do I do when they timeout/* in state %d?\n", state);
+					}
+				} else {
+					/* XXX Should we be command-compatible with Meridian mail?  Their system seems
+					       very confusing, but also widely used XXX */
+					/* They've entered (or started to enter) a command */
+					switch(d) {
+					case '0':
+						if (curmsg < maxmsg) {
+							deleted[curmsg] = !deleted[curmsg];
+							if (deleted[curmsg]) {
+								if (ast_streamfile(chan, "vm-deleted"))
+									goto out;
+							} else {
+								if (ast_streamfile(chan, "vm-undeleted"))
+									goto out;
+							}
+						} else {
+							if (ast_streamfile(chan, "vm-nomore"))
+								goto out;
+						}
+						break;
+					case '1':
+						curmsg = 0;
+						if (maxmsg > 0) {
+							/* Yuck */
+							if ((d = announce_message(chan, dir, curmsg)) > 0)
+								goto restart;
+							else if (d < 0)
+								goto out;
+						} else {
+							if (ast_streamfile(chan, "vm-nomore"))
+								goto out;
+						}
+						state = STATE_MESSAGE_PLAYING;
+						break;
+					case '4':
+						if (curmsg > 0)
+							curmsg--;
+						/* Yuck */
+						if ((d = announce_message(chan, dir, curmsg)) > 0)
+							goto restart;
+						else if (d < 0)
+							goto out;
+						state = STATE_MESSAGE_PLAYING;
+						break;
+					case '5':
+						if ((d = announce_message(chan, dir, curmsg)) > 0)
+							goto restart;
+						else if (d < 0)
+							goto out;
+						state = STATE_MESSAGE_PLAYING;
+						break;
+					case '6':
+						if (curmsg < maxmsg - 1) {
+							curmsg++;
+							if ((d = announce_message(chan, dir, curmsg)) > 0)
+								goto restart;
+							else if (d < 0)
+								goto out;
+						} else {
+							if (ast_streamfile(chan, "vm-nomore"))
+								goto out;
+						}
+						state = STATE_MESSAGE_PLAYING;
+						break;
+					/* XXX Message compose? It's easy!  Just read their # and, assuming it's in the config, 
+					       call the routine as if it were called from the PBX proper XXX */
+					case '#':
+						if (ast_streamfile(chan, "vm-goodbye"))
+							goto out;
+						if (ast_waitstream(chan, ""))
+							goto out;
+						res = 0;
+						goto out;
+						break;
+					default:
+						/* Double yuck */
+						d = '*';
+						goto restart;
+					}
+				}
+			}
+		}
+	}
+	
+out:
+	ast_stopstream(chan);
+	if (maxmsg) {
+		/* Get the deleted messages fixed */
+		curmsg = -1;
+		for (x=0;x<maxmsg;x++) {
+			if (!deleted[x]) {
+				curmsg++;
+				fn = get_fn(dir, x);
+				nfn = get_fn(dir, curmsg);
+				if (strcmp(fn, nfn))
+					ast_filerename(fn, nfn, NULL);
+				free(fn);
+				free(nfn);
+			}
+		}
+		for (x = curmsg + 1; x<maxmsg; x++) {
+			fn = get_fn(dir, x);
+			if (fn) {
+				ast_filedelete(fn, NULL);
+				free(fn);
+			}
+		}
+	}
+	if (dir)
+		free(dir);
+	if (cfg)
+		ast_destroy(cfg);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+static int vm_exec(struct ast_channel *chan, void *data)
+{
+	int res=0, silent=0;
+	struct localuser *u;
+	char *ext = (char *)data;
+	
+	if (!data) {
+		ast_log(LOG_WARNING, "vm requires an argument (extension)\n");
+		return -1;
+	}
+	LOCAL_USER_ADD(u);
+	if (*ext == 's') {
+		silent++;
+		ext++;
+	}
+	res = leave_voicemail(chan, ext, silent);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+int unload_module(void)
+{
+	int res;
+	STANDARD_HANGUP_LOCALUSERS;
+	res = ast_unregister_application(app);
+	res |= ast_unregister_application(app2);
+	return res;
+}
+
+int load_module(void)
+{
+	int res;
+	res = ast_register_application(app, vm_exec);
+	if (!res)
+		res = ast_register_application(app2, vm_execmain);
+	return res;
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/channels/Makefile	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,6 +1,33 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
+# Makefile for Channel backends (dynamically loaded)
+#
+# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+#
+# Mark Spencer <markster at linux-support.net>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+CHANNEL_LIBS=chan_vofr.so chan_ixj.so
+
+CFLAGS+=#-DVOFRDUMPER
+
+all: $(CHANNEL_LIBS)
+
+clean:
+	rm -f *.so *.o
+
+%.so : %.o
+	$(CC) -shared -Xlinker -x -o $@ $<
+
+install: all
+	for x in $(CHANNEL_LIBS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
 # Makefile for channel drivers
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/frame.c	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,4 +1,93 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Frame manipulation routines
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/frame.h>
+#include <asterisk/logger.h>
+#include <stdlib.h>
+#include <string.h>
+
+/*
+ * Important: I should be made more efficient.  Frame headers should
+ * most definitely be cached
+ */
+
+void ast_frfree(struct ast_frame *fr)
+{
+	if (fr->mallocd & AST_MALLOCD_DATA) {
+		if (fr->data) 
+			free(fr->data - fr->offset);
+	}
+	if (fr->mallocd & AST_MALLOCD_SRC) {
+		if (fr->src)
+			free(fr->src);
+	}
+	if (fr->mallocd & AST_MALLOCD_HDR) {
+		free(fr);
+	}
+}
+
+void ast_frchain(struct ast_frame_chain *fc)
+{
+	struct ast_frame_chain *last;
+	while(fc) {
+		last = fc;
+		fc = fc->next;
+		if (last->fr)
+			ast_frfree(last->fr);
+		free(last);
+	}
+}
+
+struct ast_frame *ast_frisolate(struct ast_frame *fr)
+{
+	struct ast_frame *out;
+	if (!(fr->mallocd & AST_MALLOCD_HDR)) {
+		/* Allocate a new header if needed */
+		out = malloc(sizeof(struct ast_frame));
+		if (!out) {
+			ast_log(LOG_WARNING, "Out of memory\n");
+			return NULL;
+		}
+		out->frametype = fr->frametype;
+		out->subclass = fr->subclass;
+		out->datalen = 0;
+		out->timelen = fr->timelen;
+		out->offset = 0;
+		out->src = NULL;
+		out->data = NULL;
+	} else {
+		out = fr;
+	}
+	if (!(fr->mallocd & AST_MALLOCD_SRC)) {
+		if (fr->src)
+			out->src = strdup(fr->src);
+	} else
+		out->src = fr->src;
+	if (!(fr->mallocd & AST_MALLOCD_DATA))  {
+		out->data = malloc(fr->datalen + fr->offset);
+		out->data += fr->offset;
+		out->offset = fr->offset;
+		out->datalen = fr->datalen;
+		memcpy(out->data, fr->data, fr->datalen);
+		if (!out->data) {
+			ast_log(LOG_WARNING, "Out of memory\n");
+			return NULL;
+		}
+	}
+	out->mallocd = AST_MALLOCD_HDR | AST_MALLOCD_SRC | AST_MALLOCD_DATA;
+	return out;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/file.h
===================================================================
--- trunk/include/asterisk/file.h	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/include/asterisk/file.h	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,4 +1,88 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Generic File Format Support.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_FILE_H
+#define _ASTERISK_FILE_H
+
+#include <asterisk/channel.h>
+#include <asterisk/frame.h>
+#include <fcntl.h>
+
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+
+/* Convenient for waiting */
+#define AST_DIGIT_ANY "0123456789#*"
+
+/* Defined by individual formats.  First item MUST be a
+   pointer for use by the stream manager */
+struct ast_filestream;
+
+/* Register a new file format capability */
+int ast_format_register(char *name, char *exts, int format,
+						struct ast_filestream * (*open)(int fd),
+						struct ast_filestream * (*rewrite)(int fd, char *comment),
+						int (*apply)(struct ast_channel *, struct ast_filestream *),
+						int (*write)(struct ast_filestream *, struct ast_frame *),
+						struct ast_frame * (*read)(struct ast_filestream *),
+						void (*close)(struct ast_filestream *),
+						char * (*getcomment)(struct ast_filestream *));
+	
+int ast_format_unregister(char *name);
+
+/* Start streaming a file */
+int ast_streamfile(struct ast_channel *c, char *filename);
+
+/* Stop playback of a stream */
+int ast_stopstream(struct ast_channel *c);
+
+/* See if a given file exists in a given format.  If fmt is NULL,  any format is accepted.*/
+int ast_fileexists(char *filename, char *fmt);
+
+/* Rename a given file in a given format, or if fmt is NULL, then do so for all */
+int ast_filerename(char *oldname, char *newname, char *fmt);
+
+/* Delete a given file in a given format, or if fmt is NULL, then do so for all */
+int ast_filedelete(char *filename, char *fmt);
+
+/* Wait for a stream to stop or for any one of a given digit to arrive,  Returns
+   0 if the stream finishes, the character if it was interrupted, and -1 on error */
+char ast_waitstream(struct ast_channel *c, char *breakon);
+
+/* Create an outgoing file stream.  oflags are flags for the open() command, and
+   if check is non-zero, then it will not write a file if there are any files that
+   start with that name and have an extension */
+struct ast_filestream *ast_writefile(char *filename, char *type, char *comment, int oflags, int check, mode_t mode);
+
+/* Send a frame to a filestream -- note: does NOT free the frame, call ast_frfree manually */
+int ast_writestream(struct ast_filestream *fs, struct ast_frame *f);
+
+/* Close a playback or recording stream */
+int ast_closestream(struct ast_filestream *f);
+
+#define AST_RESERVED_POINTERS 4
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+
+
+#endif
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/frame.h
===================================================================
--- trunk/include/asterisk/frame.h	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/include/asterisk/frame.h	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,4 +1,105 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Asterisk internal frame definitions.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_FRAME_H
+#define _ASTERISK_FRAME_H
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+/* A frame of data read used to communicate between 
+   between channels and applications */
+struct ast_frame {
+	int frametype;				/* Kind of frame */
+	int subclass;				/* Subclass, frame dependent */
+	int datalen;				/* Length of data */
+	int timelen;				/* Amount of time associated with this frame */
+	int mallocd;				/* Was the data malloc'd?  i.e. should we
+								   free it when we discard the frame? */
+	int offset;					/* How far into "data" the data really starts */
+	char *src;					/* Optional source of frame for debugging */
+	void *data;					/* Pointer to actual data */
+};
+
+struct ast_frame_chain {
+	/* XXX Should ast_frame chain's be just prt of frames, i.e. should they just link? XXX */
+	struct ast_frame *fr;
+	struct ast_frame_chain *next;
+};
+
+#define AST_FRIENDLY_OFFSET 	64		/* It's polite for a a new frame to
+										   have at least this number of bytes
+										   of offset before your real frame data
+										   so that additional headers can be
+										   added. */
+
+#define AST_MALLOCD_HDR		(1 << 0)	/* Need the header be free'd? */
+#define AST_MALLOCD_DATA	(1 << 1)	/* Need the data be free'd? */
+#define AST_MALLOCD_SRC		(1 << 2)	/* Need the source be free'd? (haha!) */
+
+/* Frame types */
+#define AST_FRAME_DTMF		1		/* A DTMF digit, subclass is the digit */
+#define AST_FRAME_VOICE		2		/* Voice data, subclass is AST_FORMAT_* */
+#define AST_FRAME_VIDEO		3		/* Video frame, maybe?? :) */
+#define AST_FRAME_CONTROL	4		/* A control frame, subclass is AST_CONTROL_* */
+#define AST_FRAME_NULL		5		/* An empty, useless frame */
+
+/* Data formats for capabilities and frames alike */
+#define AST_FORMAT_G723_1	(1 << 0)	/* G.723.1 compression */
+#define AST_FORMAT_GSM		(1 << 1)	/* GSM compression */
+#define AST_FORMAT_ULAW		(1 << 2)	/* Raw mu-law data (G.711) */
+#define AST_FORMAT_ALAW		(1 << 3)	/* Raw A-law data (G.711) */
+#define AST_FORMAT_MP3		(1 << 4)	/* MPEG-2 layer 3 */
+#define AST_FORMAT_ADPCM	(1 << 5)	/* ADPCM */
+#define AST_FORMAT_SLINEAR	(1 << 6)	/* Raw 16-bit Signed Linear (8000 Hz) PCM */
+#define AST_FORMAT_MAX_AUDIO (1 << 15)	/* Maximum audio format */
+#define AST_FORMAT_JPEG		(1 << 16)	/* JPEG Images */
+#define AST_FORMAT_PNG		(1 << 17)	/* PNG Images */
+#define AST_FORMAT_H261		(1 << 18)	/* H.261 Video */
+#define AST_FORMAT_H263		(1 << 19)	/* H.263 Video */
+
+/* Control frame types */
+#define AST_CONTROL_HANGUP		1			/* Other end has hungup */
+#define AST_CONTROL_RING		2			/* Local ring */
+#define AST_CONTROL_RINGING 	3			/* Remote end is ringing */
+#define AST_CONTROL_ANSWER		4			/* Remote end has answered */
+#define AST_CONTROL_BUSY		5			/* Remote end is busy */
+#define AST_CONTROL_TAKEOFFHOOK 6			/* Make it go off hook */
+#define AST_CONTROL_OFFHOOK		7			/* Line is off hook */
+
+/* Request a frame be allocated.  source is an optional source of the frame, 
+   len is the requested length, or "0" if the caller will supply the buffer */
+struct ast_frame *ast_fralloc(char *source, int len);
+
+/* Free a frame, and the memory it used if applicable */
+void ast_frfree(struct ast_frame *fr);
+
+/* Take a frame, and if it's not been malloc'd, make a malloc'd copy
+   and if the data hasn't been malloced then make the
+   data malloc'd.  If you need to store frames, say for queueing, then
+   you should call this function. */
+struct ast_frame *ast_frisolate(struct ast_frame *fr);
+
+void ast_frchain(struct ast_frame_chain *fc);
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+
+#endif
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/translate.h
===================================================================
--- trunk/include/asterisk/translate.h	2006-06-28 07:26:01 UTC (rev 419)
+++ trunk/include/asterisk/translate.h	2006-06-28 08:25:38 UTC (rev 420)
@@ -1,4 +1,80 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Translate via the use of pseudo channels
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#ifndef _ASTERISK_TRANSLATE_H
+#define _ASTERISK_TRANSLATE_H
+
+#define MAX_FORMAT 32
+
+#if defined(__cplusplus) || defined(c_plusplus)
+extern "C" {
+#endif
+
+#include <asterisk/frame.h>
+
+/* Declared by individual translators */
+struct ast_translator_pvt;
+
+struct ast_translator {
+	char name[80];
+	int srcfmt;
+	int dstfmt;
+	struct ast_translator_pvt *(*new)();
+	int (*framein)(struct ast_translator_pvt *pvt, struct ast_frame *in);
+	struct ast_frame * (*frameout)(struct ast_translator_pvt *pvt);
+	void (*destroy)(struct ast_translator_pvt *pvt);
+	/* For performance measurements */
+	/* Generate an example frame */
+	struct ast_frame * (*sample)(void);
+	/* Cost in milliseconds for encoding/decoding 1 second of sound */
+	int cost;
+	/* For linking, not to be modified by the translator */
+	struct ast_translator *next;
+};
+
+struct ast_trans_pvt;
+
+/* Create a pseudo channel which translates from a real channel into our
+   desired format.  When a translator is installed, you should not use the
+   sub channel until you have stopped the translator.  For all other
+   actions, use the real channel. Generally, translators should be created 
+   when needed and immediately destroyed when no longer needed.  */
+
+/* Directions */
+#define AST_DIRECTION_OUT  1
+#define AST_DIRECTION_IN   2
+#define AST_DIRECTION_BOTH 3
+
+extern struct ast_channel *ast_translator_create(struct ast_channel *real, int format, int direction);
+extern void ast_translator_destroy(struct ast_channel *tran);
+/* Register a Codec translator */
+extern int ast_register_translator(struct ast_translator *t);
+/* Unregister same */
+extern int ast_unregister_translator(struct ast_translator *t);
+/* Given a list of sources, and a designed destination format, which should
+   I choose? */
+extern int ast_translator_best_choice(int dst, int srcs);
+extern struct ast_trans_pvt *ast_translator_build_path(int source, int dest);
+extern void ast_translator_free_path(struct ast_trans_pvt *tr);
+extern struct ast_frame_chain *ast_translate(struct ast_trans_pvt *tr, struct ast_frame *f);
+
+
+#if defined(__cplusplus) || defined(c_plusplus)
+}
+#endif
+
+#endif
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 12:25:45 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 12:25:45 +0200
Subject: [solid-pbx-svn] r421 - in trunk: . apps channels codecs codecs/gsm configs formats
Message-ID: <200606281025.k5SAPjjR027129@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 12:25:31 +0200 (Wed, 28 Jun 2006)
New Revision: 421

Modified:
   trunk/BUGS
   trunk/README
   trunk/apps/app_dial.c
   trunk/channel.c
   trunk/channels/DialTone.h
   trunk/codecs/Makefile
   trunk/codecs/codec_g723_1.c
   trunk/codecs/g723_slin_ex.h
   trunk/codecs/gsm/Makefile
   trunk/codecs/gsm_slin_ex.h
   trunk/configs/adtranvofr.conf.sample
   trunk/configs/extensions.conf.sample
   trunk/configs/modules.conf.sample
   trunk/configs/voicemail.conf.sample
   trunk/file.c
   trunk/formats/format_g723.c
   trunk/formats/format_wav.c
   trunk/pbx.c
   trunk/translate.c
Log:
Update to Asterisk SVN trunk r90

------------------------------------------------------------------------
r81 | markster | 1999-12-01 06:25:58 +0100 (Wed, 01 Dec 1999) | 2 lines

Version 0.3.0 from FTP

------------------------------------------------------------------------
r82 | markster | 1999-12-02 21:24:59 +0100 (Thu, 02 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r83 | markster | 1999-12-04 21:45:45 +0100 (Sat, 04 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r84 | markster | 1999-12-04 22:35:07 +0100 (Sat, 04 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r85 | markster | 1999-12-04 23:05:35 +0100 (Sat, 04 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r86 | markster | 1999-12-05 02:29:36 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r87 | markster | 1999-12-05 02:40:43 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r88 | markster | 1999-12-05 03:03:40 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r89 | markster | 1999-12-05 03:10:05 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r90 | markster | 1999-12-05 08:09:27 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------


Modified: trunk/BUGS
===================================================================
--- trunk/BUGS	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/BUGS	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,3 +1,12 @@
+* EVERYTHING MARKED WITH "XXX" IN THE SOURCE REPRESENTS A BUG!  Sometimes
+  these bugs are in asterisk, and sometimes they relate to the products
+  that asterisk uses.
+
+* The MP3 decoder is completely broken
+
+* The translator API may introduce warble in the case of going in both
+  directions, but I haven't verified that.  The trouble should only enter
+  in the case of mismatched frame lengths.
 Solid PBX Bug Tracking Information
 =================================
 

Modified: trunk/README
===================================================================
--- trunk/README	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/README	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,3 +1,30 @@
+The Asterisk Open Source PBX
+by Mark Spencer <markster at linux-support.net>
+Copyright (C) 1999, Linux Support Services, LLC and Adtran, Inc.
+================================================================
+* WHAT IS ASTERISK
+  Asterisk is an Open Source PBX and telephony toolkit.  It is, in a
+sense, middleware between Internet and telephony channels on the bottom,
+and Internet and telephony applications at the top.  For more information
+on the project itself, please visit the Asterisk home page at:
+
+           http://www.asteriskpbx.com
+
+
+* REQUIRED COMPONENTS
+
+== Linux ==
+  Currently, the Asterisk Open Source PBX is only known to run on the
+Linux OS, although it may be portable to other UNIX-like operating systems
+as well.
+
+== libaudiofile ==
+
+  If you want to use format_wav module, then you need a very recent
+version of libaudiofile (at least version 0.2.0, or you can apply the
+following patch to version 0.1.9):
+
+
 The Solid PBX Soft Switch Class 5
 by the Solid PBX community
 

Modified: trunk/apps/app_dial.c
===================================================================
--- trunk/apps/app_dial.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/apps/app_dial.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,414 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Trivial application to dial a channel
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/pbx.h>
+#include <asterisk/options.h>
+#include <asterisk/module.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <unistd.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <sys/time.h>
+
+#include <pthread.h>
+
+
+static char *tdesc = "Trivial Dialing Application";
+
+static char *app = "Dial";
+
+/* We define a customer "local user" structure because we
+   use it not only for keeping track of what is in use but
+   also for keeping track of who we're dialing. */
+
+struct localuser {
+	struct ast_channel *chan;
+	int stillgoing;
+	int allowredirect;
+	struct localuser *next;
+};
+
+LOCAL_USER_DECL;
+
+static void hanguptree(struct localuser *outgoing, struct ast_channel *exception)
+{
+	/* Hang up a tree of stuff */
+	struct localuser *oo;
+	while(outgoing) {
+		/* Hangup any existing lines we have open */
+		if (outgoing->chan != exception)
+			ast_hangup(outgoing->chan);
+		oo = outgoing;
+		outgoing=outgoing->next;
+		free(oo);
+	}
+}
+
+static struct ast_channel *wait_for_answer(struct ast_channel *in, struct localuser *outgoing, int *to, int *allowredir)
+{
+	fd_set rfds, efds;
+	struct localuser *o;
+	int found;
+	int numlines;
+	int numbusies = 0;
+	int orig = *to;
+	struct timeval tv;
+	struct ast_frame *f;
+	struct ast_channel *peer = NULL;
+	/* Watch all outgoing channels looking for an answer of some sort.  */
+	tv.tv_sec = *to / 1000;
+	tv.tv_usec = (*to % 1000) * 1000;
+	while((tv.tv_sec || tv.tv_usec) && !peer) {
+		FD_ZERO(&rfds);
+		FD_ZERO(&efds);
+		/* Always watch the input fd */
+		FD_SET(in->fd, &rfds);
+		FD_SET(in->fd, &efds);
+		o = outgoing;
+		found = -1;
+		numlines = 0;
+		while(o) {
+			if (o->stillgoing) {
+				/* Pay attention to this one */
+				CHECK_BLOCKING(o->chan);
+				FD_SET(o->chan->fd, &rfds);
+				FD_SET(o->chan->fd, &efds);
+				if (o->chan->fd > found)
+					found = o->chan->fd;
+			}
+			numlines++;
+			o = o->next;
+		}
+		/* If nobody is left, just go ahead and stop */
+		if (found<0) {
+			if (numlines == numbusies) {
+				if (option_verbose > 2)
+					ast_verbose( VERBOSE_PREFIX_2 "Everyone is busy at this time\n");
+				/* See if there is a special busy message */
+				if (ast_exists_extension(in, in->context, in->exten, in->priority + 101)) 
+					in->priority+=100;
+			} else {
+				if (option_verbose > 2)
+					ast_verbose( VERBOSE_PREFIX_2 "No one is available to answer at this time\n");
+			}
+			break;
+		}
+		if (in->fd > found)
+			found = in->fd;
+		if (*to > -1) 
+			found = select(found + 1, &rfds, NULL, &efds, &tv);
+		else
+			found = select(found + 1, &rfds, NULL, &efds, NULL);
+		if (found < 0) {
+			ast_log(LOG_WARNING, "select failed, returned %d (%s)\n", errno, strerror(errno));
+			*to = -1;
+			o = outgoing;
+			while(o) {
+				if (o->stillgoing) {
+					o->chan->blocking = 0;
+				}
+				o = o->next;
+			}
+			return NULL;
+		}
+		o = outgoing;
+		while(o) {
+			if (o->stillgoing) {
+				o->chan->blocking = 0;
+				if (FD_ISSET(o->chan->fd, &rfds) || FD_ISSET(o->chan->fd, &efds)) {
+					f = ast_read(o->chan);
+					if (f) {
+						if (f->frametype == AST_FRAME_CONTROL) {
+							switch(f->subclass) {
+						    case AST_CONTROL_ANSWER:
+								/* This is our guy if someone answered. */
+								if (!peer) {
+									if (option_verbose > 2)
+										ast_verbose( VERBOSE_PREFIX_3 "%s answered %s\n", o->chan->name, in->name);
+									peer = o->chan;
+									*allowredir = o->allowredirect;
+								}
+								break;
+							case AST_CONTROL_BUSY:
+								if (option_verbose > 2)
+									ast_verbose( VERBOSE_PREFIX_3 "%s is busy\n", o->chan->name);
+								o->stillgoing = 0;
+								numbusies++;
+								break;
+							case AST_CONTROL_RINGING:
+								if (option_verbose > 2)
+									ast_verbose( VERBOSE_PREFIX_3 "%s is ringing\n", o->chan->name);
+								break;
+							case AST_CONTROL_OFFHOOK:
+								/* Ignore going off hook */
+								break;
+							default:
+								ast_log(LOG_DEBUG, "Dunno what to do with control type %d\n", f->subclass);
+							}
+						}
+						ast_frfree(f);
+					} else {
+						o->stillgoing = 0;
+					}
+					
+				}
+			}
+			o = o->next;
+		}
+		if (FD_ISSET(in->fd, &rfds) || FD_ISSET(in->fd, &efds)) {
+			/* After unblocking the entirity of the list, check for the main channel */
+			f = ast_read(in);
+#if 0
+			if (f && (f->frametype != AST_FRAME_VOICE))
+					printf("Frame type: %d, %d\n", f->frametype, f->subclass);
+#endif
+			if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass = AST_CONTROL_HANGUP))) {
+				/* Got hung up */
+				*to=-1;
+				return NULL;
+			}
+		}
+		
+	}
+	if (!(tv.tv_sec || tv.tv_usec) && (option_verbose > 2))
+		ast_verbose( VERBOSE_PREFIX_3 "Nobody picked up in %d ms\n", orig);
+	*to = 0;
+	return peer;
+}
+
+static int bridge_call(struct ast_channel *chan, struct ast_channel *peer, int allowredirect)
+{
+	/* Copy voice back and forth between the two channels.  Give the peer
+	   the ability to transfer calls with '#<extension' syntax. */
+	struct ast_channel *cs[3];
+	int to = -1, len;
+	struct ast_frame *f;
+	struct ast_channel *who;
+	char newext[256], *ptr;
+	int res;
+	/* Answer if need be */
+	if (chan->state != AST_STATE_UP)
+		if (ast_answer(chan))
+			return -1;
+	cs[0] = chan;
+	cs[1] = peer;
+	for (/* ever */;;) {
+		who = ast_waitfor_n(cs, 2, &to);
+		if (!who) {
+			ast_log(LOG_WARNING, "Nobody there??\n");
+			continue;
+		}
+		f = ast_read(who);
+		if (!f || ((f->frametype == AST_FRAME_CONTROL) && (f->subclass == AST_CONTROL_HANGUP))) 
+			return -1;
+		if ((f->frametype == AST_FRAME_VOICE) ||
+		    (f->frametype == AST_FRAME_DTMF)) {
+			if ((f->frametype == AST_FRAME_DTMF) && (who == peer) && allowredirect) {
+				if (f->subclass == '#') {
+					memset(newext, 0, sizeof(newext));
+					ptr = newext;
+					len = ast_pbx_longest_extension(chan->context) + 1;
+
+					/* Transfer */
+					if ((res=ast_streamfile(peer, "pbx-transfer")))
+						break;
+					if ((res=ast_waitstream(peer, AST_DIGIT_ANY)) < 0)
+						break;
+					ast_stopstream(peer);
+					if (res > 0) {
+						/* If they've typed a digit already, handle it */
+						newext[0] = res;
+						ptr++;
+						len --;
+					}
+					res = ast_readstring(peer, ptr, len, 3000, 2000, "#");
+					if (res)
+						break;
+					if (ast_exists_extension(chan, chan->context, newext, 1)) {
+						/* Set the channel's new extension, since it exists */
+						strncpy(chan->exten, newext, sizeof(chan->exten));
+						chan->priority = 0;
+						ast_frfree(f);
+						res=0;
+						break;
+					}
+					res = ast_streamfile(peer, "pbx-invalid");
+					if (res)
+						break;
+					res = ast_waitstream(peer, AST_DIGIT_ANY);
+					ast_stopstream(peer);
+					res = 0;
+				}
+			} else {
+#if 0
+				ast_log(LOG_DEBUG, "Read from %s\n", who->name);
+#endif
+				if (who == chan) 
+					ast_write(peer, f);
+				else 
+					ast_write(chan, f);
+			}
+			ast_frfree(f);
+			
+		} else
+			ast_frfree(f);
+		/* Swap who gets priority */
+		cs[2] = cs[0];
+		cs[0] = cs[1];
+		cs[1] = cs[2];
+	}
+	return res;
+}
+
+static int dial_exec(struct ast_channel *chan, void *data)
+{
+	int res=-1;
+	struct localuser *u;
+	char *info, *peers, *timeout, *tech, *number, *rest, *cur;
+	struct localuser *outgoing=NULL, *tmp;
+	struct ast_channel *peer;
+	int to;
+	int allowredir=0;
+	
+	if (!data) {
+		ast_log(LOG_WARNING, "Dial requires an argument (technology1/number1&technology2/number2...|optional timeout)\n");
+		return -1;
+	}
+	
+	LOCAL_USER_ADD(u);
+	
+	/* Parse our arguments */
+	info = strdup((char *)data);
+	peers = strtok(info, "|");
+	if (!peers) {
+		ast_log(LOG_WARNING, "Dial argument takes format (technology1/number1&technology2/number2...|optional timeout)\n");
+		goto out;
+	}
+	timeout = strtok(NULL, "|");
+	rest = peers;
+	do {
+		cur = strtok(rest, "&");
+		/* Remember where to start next time */
+		rest = strtok(NULL, "\128");
+		/* Get a technology/number pair */
+		tech = strtok(cur, "/");
+		number = strtok(NULL, "&");
+		if (!number) {
+			ast_log(LOG_WARNING, "Dial argument takes format (technology1/number1&technology2/number2...|optional timeout)\n");
+			goto out;
+		}
+		tmp = malloc(sizeof(struct localuser));
+		if (!tmp) {
+			ast_log(LOG_WARNING, "Out of memory\n");
+			goto out;
+		}
+		tmp->allowredirect = 1;
+		/* If we're dialing by extension, look at the extension to know what to dial */
+		if (!strcasecmp(number, "BYEXTENSION")) {
+			if (option_debug)
+				ast_log(LOG_DEBUG, "Dialing by extension %s\n", chan->exten);
+			number = chan->exten;
+			/* By default, if we're dialing by extension, don't permit redirecting */
+			tmp->allowredirect = 0;
+		}
+		/* Request the peer */
+		tmp->chan = ast_request(tech, chan->format, number);
+		if (!tmp->chan) {
+			/* If we can't, just go on to the next call */
+			ast_log(LOG_WARNING, "Unable to create channel of type '%s'\n", tech);
+			free(tmp);
+			continue;
+		}
+		/* Place the call, but don't wait on the answer */
+		res = ast_call(tmp->chan, number, 0);
+		if (res) {
+			/* Again, keep going even if there's an error */
+			if (option_debug)
+				ast_log(LOG_DEBUG, "ast call on peer returned %d\n", res);
+			else if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Couldn't call %s\n", number);
+			ast_hangup(tmp->chan);
+			free(tmp);
+			continue;
+		} else
+			if (option_verbose > 2)
+				ast_verbose(VERBOSE_PREFIX_3 "Called %s\n", number);
+		/* Put them in the list of outgoing thingies...  We're ready now. 
+		   XXX If we're forcibly removed, these outgoing calls won't get
+		   hung up XXX */
+		tmp->stillgoing = -1;
+		tmp->next = outgoing;
+		outgoing = tmp;
+	} while(rest);
+	if (timeout)
+		to = atoi(timeout) * 1000;
+	else
+		to = -1;
+	peer = wait_for_answer(chan, outgoing, &to, &allowredir);
+	if (!peer) {
+		if (to) 
+			/* Musta gotten hung up */
+			res = -1;
+		 else 
+		 	/* Nobody answered, next please? */
+			res=0;
+		
+		goto out;
+	}
+	if (peer) {
+		/* Ah ha!  Someone answered within the desired timeframe.  Of course after this
+		   we will always return with -1 so that it is hung up properly after the 
+		   conversation.  */
+		hanguptree(outgoing, peer);
+		outgoing = NULL;
+		res = bridge_call(chan, peer, allowredir);
+		ast_hangup(peer);
+	}	
+out:
+	hanguptree(outgoing, NULL);
+	free(info);
+	LOCAL_USER_REMOVE(u);
+	return res;
+}
+
+int unload_module(void)
+{
+	STANDARD_HANGUP_LOCALUSERS;
+	return ast_unregister_application(app);
+}
+
+int load_module(void)
+{
+	return ast_register_application(app, dial_exec);
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/channel.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,406 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Channel Management
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <sys/time.h>
+#include <signal.h>
+#include <errno.h>
+#include <asterisk/sched.h>
+#include <asterisk/options.h>
+#include <asterisk/channel.h>
+#include <asterisk/channel_pvt.h>
+#include <asterisk/logger.h>
+#include <asterisk/file.h>
+
+struct chanlist {
+	char type[80];
+	char description[80];
+	int capabilities;
+	struct ast_channel * (*requester)(char *type, int format, void *data);
+	struct chanlist *next;
+} *backends = NULL;
+
+/* Protect the channel list (highly unlikely that two things would change
+   it at the same time, but still! */
+   
+static pthread_mutex_t chlock = PTHREAD_MUTEX_INITIALIZER;
+
+int ast_channel_register(char *type, char *description, int capabilities,
+		struct ast_channel *(*requester)(char *type, int format, void *data))
+{
+	struct chanlist *chan, *last=NULL;
+	if (pthread_mutex_lock(&chlock)) {
+		ast_log(LOG_WARNING, "Unable to lock channel list\n");
+		return -1;
+	}
+	chan = backends;
+	while(chan) {
+		if (!strcasecmp(type, chan->type)) {
+			ast_log(LOG_WARNING, "Already have a handler for type '%s'\n", type);
+			pthread_mutex_unlock(&chlock);
+			return -1;
+		}
+		last = chan;
+		chan = chan->next;
+	}
+	chan = malloc(sizeof(struct chanlist));
+	if (!chan) {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		pthread_mutex_unlock(&chlock);
+		return -1;
+	}
+	strncpy(chan->type, type, sizeof(chan->type));
+	strncpy(chan->description, description, sizeof(chan->description));
+	chan->capabilities = capabilities;
+	chan->requester = requester;
+	chan->next = NULL;
+	if (last)
+		last->next = chan;
+	else
+		backends = chan;
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Registered handler for '%s' (%s)\n", chan->type, chan->description);
+	else if (option_verbose > 1)
+		ast_verbose( VERBOSE_PREFIX_2 "Registered channel type '%s' (%s)\n", chan->type, chan->description);
+	pthread_mutex_unlock(&chlock);
+	return 0;
+}
+
+struct ast_channel *ast_channel_alloc(void)
+{
+	struct ast_channel *tmp;
+	struct ast_channel_pvt *pvt;
+	tmp = malloc(sizeof(struct ast_channel));
+	memset(tmp, 0, sizeof(struct ast_channel));
+	if (tmp) {
+		pvt = malloc(sizeof(struct ast_channel_pvt));
+		if (pvt) {
+			memset(pvt, 0, sizeof(struct ast_channel_pvt));
+			tmp->sched = sched_context_create();
+			if (tmp->sched) {
+				tmp->fd = -1;
+				strncpy(tmp->name, "**Unknown**", sizeof(tmp->name));
+				tmp->pvt = pvt;
+				tmp->state = AST_STATE_DOWN;
+				tmp->stack = -1;
+				tmp->streamid = -1;
+				strncpy(tmp->context, "default", sizeof(tmp->context));
+				strncpy(tmp->exten, "s", sizeof(tmp->exten));
+				tmp->priority=1;
+			} else {
+				ast_log(LOG_WARNING, "Unable to create schedule context\n");
+				free(tmp);
+				tmp = NULL;
+			}
+		} else {
+			ast_log(LOG_WARNING, "Out of memory\n");
+			free(tmp);
+			tmp = NULL;
+		}
+	} else 
+		ast_log(LOG_WARNING, "Out of memory\n");
+	return tmp;
+}
+
+int ast_softhangup(struct ast_channel *chan)
+{
+	int res = 0;
+	if (chan->stream)
+		ast_stopstream(chan);
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Soft-Hanging up channel '%s'\n", chan->name);
+	if (chan->trans)
+		ast_log(LOG_WARNING, "Soft hangup called on '%s' while a translator is in place!  Expect a failure.\n", chan->name);
+	if (chan->pvt->hangup)
+		res = chan->pvt->hangup(chan);
+	if (chan->pvt->pvt)
+		ast_log(LOG_WARNING, "Channel '%s' may not have been hung up properly\n", chan->name);
+	if (chan->pbx) 
+		ast_log(LOG_WARNING, "PBX may not have been terminated properly on '%s'\n", chan->name);	
+	/* Interrupt any select call or such */
+	if (chan->blocking)
+		pthread_kill(chan->blocker, SIGURG);
+	return res;
+}
+
+int ast_hangup(struct ast_channel *chan)
+{
+	int res = 0;
+	if (chan->stream)
+		ast_stopstream(chan);
+	if (chan->sched)
+		sched_context_destroy(chan->sched);
+	if (chan->blocking)
+		ast_log(LOG_WARNING, "Hard hangup called, while fd is blocking!  Expect a failure\n");
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Hanging up channel '%s'\n", chan->name);
+	if (chan->pvt->hangup)
+		res = chan->pvt->hangup(chan);
+	if (chan->pvt->pvt)
+		ast_log(LOG_WARNING, "Channel '%s' may not have been hung up properly\n", chan->name);
+	if (chan->trans)
+		ast_log(LOG_WARNING, "Hard hangup called on '%s' while a translator is in place!  Expect a failure.\n", chan->name);
+	if (chan->pbx) 
+		ast_log(LOG_WARNING, "PBX may not have been terminated properly on '%s'\n", chan->name);
+	if (chan->dnid)
+		free(chan->dnid);
+	if (chan->callerid)
+		free(chan->callerid);	
+	free(chan->pvt);
+	free(chan);
+	return res;
+}
+
+void ast_channel_unregister(char *type)
+{
+	struct chanlist *chan, *last=NULL;
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Unregistering channel type '%s'\n", type);
+	if (pthread_mutex_lock(&chlock)) {
+		ast_log(LOG_WARNING, "Unable to lock channel list\n");
+		return;
+	}
+	chan = backends;
+	while(chan) {
+		if (!strcasecmp(chan->type, type)) {
+			if (last)
+				last->next = chan->next;
+			else
+				backends = backends->next;
+			free(chan);
+			pthread_mutex_unlock(&chlock);
+			return;
+		}
+		last = chan;
+		chan = chan->next;
+	}
+	pthread_mutex_unlock(&chlock);
+}
+
+int ast_answer(struct ast_channel *chan)
+{
+	/* Answer the line, if possible */
+	if (chan->state == AST_STATE_RING) {
+		if (chan->pvt->answer)
+			return chan->pvt->answer(chan);
+	}
+	return 0;
+}
+
+int ast_waitfor_n_fd(int *fds, int n, int *ms)
+{
+	/* Wait for x amount of time on a file descriptor to have input.  */
+	struct timeval tv;
+	fd_set rfds, efds;
+	int res;
+	int x, max=-1;
+	int winner = -1;
+	
+	tv.tv_sec = *ms / 1000;
+	tv.tv_usec = (*ms % 1000) * 1000;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (x=0;x<n;x++) {
+		FD_SET(fds[x], &rfds);
+		FD_SET(fds[x], &efds);
+		if (fds[x] > max)
+			max = fds[x];
+	}
+	if (*ms >= 0) 
+		res = select(max + 1, &rfds, NULL, &efds, &tv);
+	else
+		res = select(max + 1, &rfds, NULL, &efds, NULL);
+	for (x=0;x<n;x++) {
+		if ((FD_ISSET(fds[x], &rfds) || FD_ISSET(fds[x], &efds)) && (winner < 0))
+			winner = fds[x];
+	}
+	*ms = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	if (res < 0)
+		*ms = -10;
+	return winner;
+}
+
+struct ast_channel *ast_waitfor_n(struct ast_channel **c, int n, int *ms)
+{
+	/* Wait for x amount of time on a file descriptor to have input.  */
+	struct timeval tv;
+	fd_set rfds, efds;
+	int res;
+	int x, max=-1;
+	struct ast_channel *winner = NULL;
+	
+	tv.tv_sec = *ms / 1000;
+	tv.tv_usec = (*ms % 1000) * 1000;
+	FD_ZERO(&rfds);
+	FD_ZERO(&efds);
+	for (x=0;x<n;x++) {
+		FD_SET(c[x]->fd, &rfds);
+		FD_SET(c[x]->fd, &efds);
+		CHECK_BLOCKING(c[x]);
+		if (c[x]->fd > max)
+			max = c[x]->fd;
+	}
+	if (*ms >= 0) 
+		res = select(max + 1, &rfds, NULL, &efds, &tv);
+	else
+		res = select(max + 1, &rfds, NULL, &efds, NULL);
+	for (x=0;x<n;x++) {
+		c[x]->blocking = 0;
+		if ((FD_ISSET(c[x]->fd, &rfds) || FD_ISSET(c[x]->fd, &efds)) && !winner)
+			winner = c[x];
+	}
+	*ms = tv.tv_sec * 1000 + tv.tv_usec / 1000;
+	if (res < 0)
+		*ms = -10;
+	return winner;
+}
+
+int ast_waitfor(struct ast_channel *c, int ms)
+{
+	if (ast_waitfor_n(&c, 1, &ms)) {
+		if (ms < 0)
+			return -ms;
+		return ms;
+	}
+	/* Error if ms < 0 */
+	if (ms < 0) 
+		return -1;
+	return 0;
+}
+
+char ast_waitfordigit(struct ast_channel *c, int ms)
+{
+	struct ast_frame *f;
+	char result = 0;
+	/* Wait for a digit, no more than ms milliseconds total. */
+	while(ms && !result) {
+		ms = ast_waitfor(c, ms);
+		if (ms < 0) /* Error */
+			result = -1; 
+		else if (ms > 0) {
+			/* Read something */
+			f = ast_read(c);
+			if (f) {
+				if (f->frametype == AST_FRAME_DTMF) 
+					result = f->subclass;
+				ast_frfree(f);
+			} else
+				result = -1;
+		}
+	}
+	return result;
+}
+
+struct ast_frame *ast_read(struct ast_channel *chan)
+{
+	struct ast_frame *f = NULL;
+	chan->blocker = pthread_self();
+	if (chan->pvt->read)
+		f = chan->pvt->read(chan);
+	else
+		ast_log(LOG_WARNING, "No read routine on channel %s\n", chan);
+	return f;
+}
+
+int ast_write(struct ast_channel *chan, struct ast_frame *fr)
+{
+	int res = -1;
+	CHECK_BLOCKING(chan);
+	switch(fr->frametype) {
+	case AST_FRAME_CONTROL:
+		/* XXX Interpret control frames XXX */
+		ast_log(LOG_WARNING, "Don't know how to handle control frames yet\n");
+		break;
+	case AST_FRAME_DTMF:
+		
+		if (chan->pvt->send_digit)
+			res = chan->pvt->send_digit(chan, fr->subclass);
+		break;
+	default:
+		if (chan->pvt->write)
+			res = chan->pvt->write(chan, fr);
+	}
+	chan->blocking = 0;
+	return res;
+}
+
+struct ast_channel *ast_request(char *type, int format, void *data)
+{
+	struct chanlist *chan;
+	struct ast_channel *c = NULL;
+	if (pthread_mutex_lock(&chlock)) {
+		ast_log(LOG_WARNING, "Unable to lock channel list\n");
+		return NULL;
+	}
+	chan = backends;
+	while(chan) {
+		if (!strcasecmp(type, chan->type)) {
+			if (chan->requester)
+				c = chan->requester(type, format, data);
+			pthread_mutex_unlock(&chlock);
+			break;
+		}
+		chan = chan->next;
+	}
+	if (!chan)
+		ast_log(LOG_WARNING, "No channel type registered for '%s'\n", type);
+	return c;
+}
+
+int ast_call(struct ast_channel *chan, char *addr, int timeout) 
+{
+	/* Place an outgoing call, but don't wait any longer than timeout ms before returning. 
+	   If the remote end does not answer within the timeout, then do NOT hang up, but 
+	   return anyway.  */
+	int res = -1;
+	if (chan->pvt->call)
+		res = chan->pvt->call(chan, addr, timeout);
+	return res;
+}
+
+int ast_readstring(struct ast_channel *c, char *s, int len, int timeout, int ftimeout, char *enders)
+{
+	int pos=0;
+	int to = ftimeout;
+	char d;
+	if (!len)
+		return -1;
+	do {
+		if (c->streamid > -1) {
+			d = ast_waitstream(c, AST_DIGIT_ANY);
+			ast_stopstream(c);
+			if (!d)
+				d = ast_waitfordigit(c, to);
+		} else {
+			d = ast_waitfordigit(c, to);
+		}
+		if (d < 0)
+			return -1;
+		if (!strchr(enders, d))
+			s[pos++] = d;
+		if ((d == 0) || strchr(enders, d) || (pos >= len - 1)) {
+			s[pos]='\0';
+			return 0;
+		}
+		to = timeout;
+	} while(1);
+	/* Never reached */
+	return 0;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/channels/DialTone.h
===================================================================
--- trunk/channels/DialTone.h	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/channels/DialTone.h	2006-06-28 10:25:31 UTC (rev 421)
@@ -3,6 +3,258 @@
   *
   * Source: DialTone.ulaw
   *
+  * Copyright (C) 1999, Mark Spencer and Linux Support Services
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+static unsigned char DialTone[] = {
+0xff, 0xab, 0x9d, 0x96, 0x91, 0x90, 0x91, 0x96, 0x9c, 0xaa, 
+0xd9, 0x2f, 0x1f, 0x19, 0x15, 0x14, 0x15, 0x19, 0x1f, 0x2c, 
+0x4e, 0xb9, 0xa7, 0x9f, 0x9c, 0x9b, 0x9c, 0x9f, 0xa7, 0xb3, 
+0xcf, 0x47, 0x34, 0x2d, 0x2a, 0x2a, 0x2c, 0x31, 0x3a, 0x47, 
+0x5f, 0xe4, 0xd8, 0xd9, 0xe9, 0x64, 0x4f, 0x49, 0x46, 0x49, 
+0x58, 0xde, 0xc2, 0xb5, 0xad, 0xa8, 0xa6, 0xa6, 0xa9, 0xaf, 
+0xbf, 0x56, 0x32, 0x26, 0x1e, 0x1b, 0x19, 0x1a, 0x1d, 0x24, 
+0x33, 0xdd, 0xad, 0x9f, 0x98, 0x94, 0x92, 0x93, 0x97, 0x9e, 
+0xac, 0xf8, 0x2c, 0x1d, 0x16, 0x11, 0xf, 0x10, 0x15, 0x1b, 
+0x29, 0x55, 0xae, 0x9e, 0x97, 0x92, 0x90, 0x91, 0x95, 0x9c, 
+0xa8, 0xca, 0x35, 0x22, 0x1a, 0x16, 0x15, 0x16, 0x19, 0x1f, 
+0x2b, 0x47, 0xbe, 0xab, 0xa2, 0x9e, 0x9d, 0x9e, 0xa2, 0xa9, 
+0xb4, 0xcc, 0x4f, 0x3a, 0x32, 0x2f, 0x2f, 0x32, 0x39, 0x41, 
+0x4f, 0x67, 0xf5, 0xf5, 0x67, 0x51, 0x46, 0x3e, 0x3b, 0x3b, 
+0x3f, 0x4d, 0xe2, 0xbe, 0xb0, 0xa9, 0xa4, 0xa1, 0xa1, 0xa5, 
+0xab, 0xba, 0x64, 0x33, 0x25, 0x1d, 0x19, 0x17, 0x18, 0x1b, 
+0x20, 0x2e, 0x72, 0xae, 0x9f, 0x98, 0x94, 0x91, 0x92, 0x96, 
+0x9c, 0xa9, 0xd4, 0x2f, 0x1e, 0x17, 0x11, 0xf, 0x10, 0x14, 
+0x1a, 0x26, 0x48, 0xb2, 0x9f, 0x98, 0x93, 0x91, 0x92, 0x95, 
+0x9b, 0xa7, 0xc1, 0x3a, 0x25, 0x1c, 0x18, 0x16, 0x17, 0x1a, 
+0x1f, 0x2b, 0x42, 0xc6, 0xae, 0xa6, 0xa0, 0x9f, 0xa0, 0xa5, 
+0xab, 0xb6, 0xcb, 0x5a, 0x40, 0x39, 0x36, 0x37, 0x3b, 0x43, 
+0x4e, 0x60, 0x7b, 0x7c, 0x60, 0x4e, 0x41, 0x3a, 0x34, 0x32, 
+0x33, 0x39, 0x45, 0xed, 0xbd, 0xae, 0xa6, 0xa0, 0x9e, 0x9e, 
+0xa0, 0xa8, 0xb4, 0xef, 0x34, 0x24, 0x1c, 0x18, 0x16, 0x16, 
+0x19, 0x1e, 0x2b, 0x54, 0xb1, 0x9f, 0x98, 0x93, 0x91, 0x91, 
+0x95, 0x9b, 0xa6, 0xc6, 0x33, 0x1f, 0x17, 0x12, 0xf, 0x10, 
+0x13, 0x1a, 0x24, 0x3e, 0xb8, 0xa2, 0x99, 0x94, 0x92, 0x92, 
+0x96, 0x9b, 0xa6, 0xbc, 0x40, 0x29, 0x1e, 0x1a, 0x18, 0x19, 
+0x1b, 0x20, 0x2b, 0x3f, 0xcf, 0xb3, 0xa9, 0xa5, 0xa3, 0xa4, 
+0xa8, 0xae, 0xb9, 0xcc, 0x67, 0x49, 0x40, 0x3f, 0x42, 0x4a, 
+0x59, 0x79, 0xe5, 0xe4, 0x7a, 0x54, 0x43, 0x39, 0x31, 0x2d, 
+0x2c, 0x2d, 0x32, 0x3e, 0x71, 0xbd, 0xad, 0xa4, 0x9e, 0x9c, 
+0x9c, 0x9e, 0xa4, 0xaf, 0xd7, 0x36, 0x24, 0x1c, 0x17, 0x15, 
+0x15, 0x17, 0x1d, 0x28, 0x47, 0xb5, 0xa1, 0x98, 0x93, 0x90, 
+0x90, 0x93, 0x99, 0xa4, 0xbd, 0x38, 0x21, 0x18, 0x13, 0x10, 
+0x10, 0x13, 0x19, 0x22, 0x39, 0xbe, 0xa5, 0x9b, 0x96, 0x93, 
+0x93, 0x96, 0x9b, 0xa5, 0xb9, 0x4a, 0x2c, 0x20, 0x1c, 0x1a, 
+0x1a, 0x1d, 0x22, 0x2c, 0x3d, 0xdc, 0xb8, 0xad, 0xa9, 0xa8, 
+0xa9, 0xac, 0xb2, 0xbd, 0xce, 0x78, 0x54, 0x4d, 0x4f, 0x5a, 
+0xff, 0xda, 0xcf, 0xcd, 0xd4, 0xf8, 0x4e, 0x3d, 0x32, 0x2c, 
+0x29, 0x28, 0x29, 0x2d, 0x38, 0x5c, 0xbd, 0xac, 0xa2, 0x9d, 
+0x9a, 0x9a, 0x9c, 0xa0, 0xac, 0xca, 0x39, 0x25, 0x1b, 0x16, 
+0x13, 0x13, 0x16, 0x1b, 0x25, 0x3e, 0xb9, 0xa2, 0x99, 0x93, 
+0x90, 0x90, 0x93, 0x98, 0xa1, 0xb8, 0x3d, 0x24, 0x19, 0x13, 
+0x10, 0x10, 0x13, 0x18, 0x21, 0x35, 0xc7, 0xa8, 0x9d, 0x97, 
+0x95, 0x95, 0x97, 0x9c, 0xa4, 0xb6, 0x57, 0x2f, 0x24, 0x1e, 
+0x1c, 0x1c, 0x1e, 0x24, 0x2d, 0x3d, 0xf1, 0xbe, 0xb2, 0xad, 
+0xac, 0xad, 0xb1, 0xb9, 0xc3, 0xd4, 0xfa, 0x64, 0x65, 0xf9, 
+0xd9, 0xca, 0xc2, 0xbf, 0xc0, 0xc9, 0xe7, 0x4c, 0x39, 0x2e, 
+0x28, 0x24, 0x23, 0x25, 0x29, 0x33, 0x4f, 0xbf, 0xab, 0xa0, 
+0x9b, 0x99, 0x98, 0x9a, 0x9e, 0xa9, 0xc0, 0x3c, 0x26, 0x1b, 
+0x16, 0x12, 0x12, 0x14, 0x19, 0x22, 0x38, 0xbe, 0xa4, 0x9a, 
+0x93, 0x90, 0x8f, 0x92, 0x97, 0x9f, 0xb3, 0x46, 0x26, 0x1b, 
+0x15, 0x11, 0x11, 0x13, 0x18, 0x1f, 0x31, 0xd4, 0xab, 0x9e, 
+0x99, 0x96, 0x96, 0x98, 0x9c, 0xa4, 0xb4, 0x6f, 0x34, 0x28, 
+0x20, 0x1e, 0x1e, 0x20, 0x26, 0x2e, 0x3d, 0x6d, 0xc5, 0xb9, 
+0xb3, 0xb2, 0xb4, 0xba, 0xc1, 0xcd, 0xe0, 0xfc, 0xfb, 0xe0, 
+0xce, 0xc3, 0xbb, 0xb7, 0xb6, 0xb9, 0xc0, 0xda, 0x4b, 0x36, 
+0x2b, 0x25, 0x20, 0x1f, 0x20, 0x26, 0x2e, 0x46, 0xc2, 0xab, 
+0x9f, 0x9a, 0x97, 0x96, 0x98, 0x9c, 0xa5, 0xba, 0x41, 0x27, 
+0x1b, 0x15, 0x12, 0x11, 0x13, 0x18, 0x1f, 0x32, 0xc8, 0xa6, 
+0x9a, 0x94, 0x90, 0x8f, 0x91, 0x97, 0x9e, 0xaf, 0x54, 0x29, 
+0x1c, 0x16, 0x12, 0x11, 0x14, 0x18, 0x1f, 0x2e, 0xf2, 0xae, 
+0xa0, 0x9b, 0x98, 0x97, 0x99, 0x9d, 0xa5, 0xb3, 0xe4, 0x3a, 
+0x2b, 0x25, 0x21, 0x21, 0x24, 0x29, 0x30, 0x3e, 0x62, 0xcd, 
+0xbf, 0xbb, 0xbb, 0xbe, 0xc6, 0xd1, 0xe7, 0x76, 0x75, 0xe7, 
+0xcf, 0xc1, 0xb9, 0xb2, 0xaf, 0xaf, 0xb2, 0xba, 0xcf, 0x4c, 
+0x34, 0x29, 0x22, 0x1e, 0x1d, 0x1e, 0x22, 0x2b, 0x3e, 0xc7, 
+0xab, 0x9f, 0x99, 0x96, 0x95, 0x96, 0x9a, 0xa2, 0xb5, 0x4a, 
+0x28, 0x1c, 0x15, 0x11, 0x10, 0x12, 0x17, 0x1e, 0x2e, 0xd5, 
+0xa9, 0x9b, 0x95, 0x90, 0x8f, 0x91, 0x96, 0x9d, 0xac, 0x78, 
+0x2c, 0x1e, 0x17, 0x13, 0x12, 0x14, 0x18, 0x1f, 0x2d, 0x5d, 
+0xb3, 0xa4, 0x9d, 0x9a, 0x99, 0x9b, 0x9e, 0xa6, 0xb2, 0xd6, 
+0x3f, 0x2f, 0x29, 0x26, 0x26, 0x28, 0x2d, 0x35, 0x42, 0x5e, 
+0xd8, 0xca, 0xc6, 0xc9, 0xcf, 0xe4, 0x69, 0x59, 0x58, 0x64, 
+0xdf, 0xc7, 0xba, 0xb1, 0xac, 0xaa, 0xaa, 0xad, 0xb4, 0xc7, 
+0x4f, 0x33, 0x27, 0x1f, 0x1c, 0x1b, 0x1c, 0x1f, 0x27, 0x39, 
+0xce, 0xac, 0x9f, 0x99, 0x95, 0x94, 0x95, 0x99, 0x9f, 0xaf, 
+0x59, 0x2a, 0x1c, 0x16, 0x11, 0x10, 0x11, 0x16, 0x1d, 0x2b, 
+0xff, 0xab, 0x9d, 0x96, 0x91, 0x90, 0x91, 0x96, 0x9c, 0xaa, 
+0xd9, 0x2f, 0x1f, 0x19, 0x15, 0x14, 0x15, 0x19, 0x1f, 0x2c, 
+0x4e, 0xb9, 0xa7, 0x9f, 0x9c, 0x9b, 0x9c, 0x9f, 0xa7, 0xb3, 
+0xcf, 0x47, 0x34, 0x2d, 0x2a, 0x2a, 0x2c, 0x31, 0x3a, 0x47, 
+0x5f, 0xe4, 0xd8, 0xd9, 0xe9, 0x64, 0x4f, 0x49, 0x46, 0x49, 
+0x58, 0xde, 0xc2, 0xb5, 0xad, 0xa8, 0xa6, 0xa6, 0xa9, 0xaf, 
+0xbf, 0x56, 0x32, 0x26, 0x1e, 0x1b, 0x19, 0x1a, 0x1d, 0x24, 
+0x33, 0xdd, 0xad, 0x9f, 0x98, 0x94, 0x92, 0x93, 0x97, 0x9e, 
+0xac, 0xf8, 0x2c, 0x1d, 0x16, 0x11, 0xf, 0x10, 0x15, 0x1b, 
+0x29, 0x55, 0xae, 0x9e, 0x97, 0x92, 0x90, 0x91, 0x95, 0x9c, 
+0xa8, 0xca, 0x35, 0x22, 0x1a, 0x16, 0x15, 0x16, 0x19, 0x1f, 
+0x2b, 0x47, 0xbe, 0xab, 0xa2, 0x9e, 0x9d, 0x9e, 0xa2, 0xa9, 
+0xb4, 0xcc, 0x4f, 0x3a, 0x32, 0x2f, 0x2f, 0x32, 0x39, 0x41, 
+0x4f, 0x67, 0xf5, 0xf5, 0x67, 0x51, 0x46, 0x3e, 0x3b, 0x3b, 
+0x3f, 0x4d, 0xe2, 0xbe, 0xb0, 0xa9, 0xa4, 0xa1, 0xa1, 0xa5, 
+0xab, 0xba, 0x64, 0x33, 0x25, 0x1d, 0x19, 0x17, 0x18, 0x1b, 
+0x20, 0x2e, 0x72, 0xae, 0x9f, 0x98, 0x94, 0x91, 0x92, 0x96, 
+0x9c, 0xa9, 0xd4, 0x2f, 0x1e, 0x17, 0x11, 0xf, 0x10, 0x14, 
+0x1a, 0x26, 0x48, 0xb2, 0x9f, 0x98, 0x93, 0x91, 0x92, 0x95, 
+0x9b, 0xa7, 0xc1, 0x3a, 0x25, 0x1c, 0x18, 0x16, 0x17, 0x1a, 
+0x1f, 0x2b, 0x42, 0xc6, 0xae, 0xa6, 0xa0, 0x9f, 0xa0, 0xa5, 
+0xab, 0xb6, 0xcb, 0x5a, 0x40, 0x39, 0x36, 0x37, 0x3b, 0x43, 
+0x4e, 0x60, 0x7b, 0x7c, 0x60, 0x4e, 0x41, 0x3a, 0x34, 0x32, 
+0x33, 0x39, 0x45, 0xed, 0xbd, 0xae, 0xa6, 0xa0, 0x9e, 0x9e, 
+0xa0, 0xa8, 0xb4, 0xef, 0x34, 0x24, 0x1c, 0x18, 0x16, 0x16, 
+0x19, 0x1e, 0x2b, 0x54, 0xb1, 0x9f, 0x98, 0x93, 0x91, 0x91, 
+0x95, 0x9b, 0xa6, 0xc6, 0x33, 0x1f, 0x17, 0x12, 0xf, 0x10, 
+0x13, 0x1a, 0x24, 0x3e, 0xb8, 0xa2, 0x99, 0x94, 0x92, 0x92, 
+0x96, 0x9b, 0xa6, 0xbc, 0x40, 0x29, 0x1e, 0x1a, 0x18, 0x19, 
+0x1b, 0x20, 0x2b, 0x3f, 0xcf, 0xb3, 0xa9, 0xa5, 0xa3, 0xa4, 
+0xa8, 0xae, 0xb9, 0xcc, 0x67, 0x49, 0x40, 0x3f, 0x42, 0x4a, 
+0x59, 0x79, 0xe5, 0xe4, 0x7a, 0x54, 0x43, 0x39, 0x31, 0x2d, 
+0x2c, 0x2d, 0x32, 0x3e, 0x71, 0xbd, 0xad, 0xa4, 0x9e, 0x9c, 
+0x9c, 0x9e, 0xa4, 0xaf, 0xd7, 0x36, 0x24, 0x1c, 0x17, 0x15, 
+0x15, 0x17, 0x1d, 0x28, 0x47, 0xb5, 0xa1, 0x98, 0x93, 0x90, 
+0x90, 0x93, 0x99, 0xa4, 0xbd, 0x38, 0x21, 0x18, 0x13, 0x10, 
+0x10, 0x13, 0x19, 0x22, 0x39, 0xbe, 0xa5, 0x9b, 0x96, 0x93, 
+0x93, 0x96, 0x9b, 0xa5, 0xb9, 0x4a, 0x2c, 0x20, 0x1c, 0x1a, 
+0x1a, 0x1d, 0x22, 0x2c, 0x3d, 0xdc, 0xb8, 0xad, 0xa9, 0xa8, 
+0xa9, 0xac, 0xb2, 0xbd, 0xce, 0x78, 0x54, 0x4d, 0x4f, 0x5a, 
+0xff, 0xda, 0xcf, 0xcd, 0xd4, 0xf8, 0x4e, 0x3d, 0x32, 0x2c, 
+0x29, 0x28, 0x29, 0x2d, 0x38, 0x5c, 0xbd, 0xac, 0xa2, 0x9d, 
+0x9a, 0x9a, 0x9c, 0xa0, 0xac, 0xca, 0x39, 0x25, 0x1b, 0x16, 
+0x13, 0x13, 0x16, 0x1b, 0x25, 0x3e, 0xb9, 0xa2, 0x99, 0x93, 
+0x90, 0x90, 0x93, 0x98, 0xa1, 0xb8, 0x3d, 0x24, 0x19, 0x13, 
+0x10, 0x10, 0x13, 0x18, 0x21, 0x35, 0xc7, 0xa8, 0x9d, 0x97, 
+0x95, 0x95, 0x97, 0x9c, 0xa4, 0xb6, 0x57, 0x2f, 0x24, 0x1e, 
+0x1c, 0x1c, 0x1e, 0x24, 0x2d, 0x3d, 0xf1, 0xbe, 0xb2, 0xad, 
+0xac, 0xad, 0xb1, 0xb9, 0xc3, 0xd4, 0xfa, 0x64, 0x65, 0xf9, 
+0xd9, 0xca, 0xc2, 0xbf, 0xc0, 0xc9, 0xe7, 0x4c, 0x39, 0x2e, 
+0x28, 0x24, 0x23, 0x25, 0x29, 0x33, 0x4f, 0xbf, 0xab, 0xa0, 
+0x9b, 0x99, 0x98, 0x9a, 0x9e, 0xa9, 0xc0, 0x3c, 0x26, 0x1b, 
+0x16, 0x12, 0x12, 0x14, 0x19, 0x22, 0x38, 0xbe, 0xa4, 0x9a, 
+0x93, 0x90, 0x8f, 0x92, 0x97, 0x9f, 0xb3, 0x46, 0x26, 0x1b, 
+0x15, 0x11, 0x11, 0x13, 0x18, 0x1f, 0x31, 0xd4, 0xab, 0x9e, 
+0x99, 0x96, 0x96, 0x98, 0x9c, 0xa4, 0xb4, 0x6f, 0x34, 0x28, 
+0x20, 0x1e, 0x1e, 0x20, 0x26, 0x2e, 0x3d, 0x6d, 0xc5, 0xb9, 
+0xb3, 0xb2, 0xb4, 0xba, 0xc1, 0xcd, 0xe0, 0xfc, 0xfb, 0xe0, 
+0xce, 0xc3, 0xbb, 0xb7, 0xb6, 0xb9, 0xc0, 0xda, 0x4b, 0x36, 
+0x2b, 0x25, 0x20, 0x1f, 0x20, 0x26, 0x2e, 0x46, 0xc2, 0xab, 
+0x9f, 0x9a, 0x97, 0x96, 0x98, 0x9c, 0xa5, 0xba, 0x41, 0x27, 
+0x1b, 0x15, 0x12, 0x11, 0x13, 0x18, 0x1f, 0x32, 0xc8, 0xa6, 
+0x9a, 0x94, 0x90, 0x8f, 0x91, 0x97, 0x9e, 0xaf, 0x54, 0x29, 
+0x1c, 0x16, 0x12, 0x11, 0x14, 0x18, 0x1f, 0x2e, 0xf2, 0xae, 
+0xa0, 0x9b, 0x98, 0x97, 0x99, 0x9d, 0xa5, 0xb3, 0xe4, 0x3a, 
+0x2b, 0x25, 0x21, 0x21, 0x24, 0x29, 0x30, 0x3e, 0x62, 0xcd, 
+0xbf, 0xbb, 0xbb, 0xbe, 0xc6, 0xd1, 0xe7, 0x76, 0x75, 0xe7, 
+0xcf, 0xc1, 0xb9, 0xb2, 0xaf, 0xaf, 0xb2, 0xba, 0xcf, 0x4c, 
+0x34, 0x29, 0x22, 0x1e, 0x1d, 0x1e, 0x22, 0x2b, 0x3e, 0xc7, 
+0xab, 0x9f, 0x99, 0x96, 0x95, 0x96, 0x9a, 0xa2, 0xb5, 0x4a, 
+0x28, 0x1c, 0x15, 0x11, 0x10, 0x12, 0x17, 0x1e, 0x2e, 0xd5, 
+0xa9, 0x9b, 0x95, 0x90, 0x8f, 0x91, 0x96, 0x9d, 0xac, 0x78, 
+0x2c, 0x1e, 0x17, 0x13, 0x12, 0x14, 0x18, 0x1f, 0x2d, 0x5d, 
+0xb3, 0xa4, 0x9d, 0x9a, 0x99, 0x9b, 0x9e, 0xa6, 0xb2, 0xd6, 
+0x3f, 0x2f, 0x29, 0x26, 0x26, 0x28, 0x2d, 0x35, 0x42, 0x5e, 
+0xd8, 0xca, 0xc6, 0xc9, 0xcf, 0xe4, 0x69, 0x59, 0x58, 0x64, 
+0xdf, 0xc7, 0xba, 0xb1, 0xac, 0xaa, 0xaa, 0xad, 0xb4, 0xc7, 
+0x4f, 0x33, 0x27, 0x1f, 0x1c, 0x1b, 0x1c, 0x1f, 0x27, 0x39, 
+0xce, 0xac, 0x9f, 0x99, 0x95, 0x94, 0x95, 0x99, 0x9f, 0xaf, 
+0x59, 0x2a, 0x1c, 0x16, 0x11, 0x10, 0x11, 0x16, 0x1d, 0x2b, 
+0xff, 0xab, 0x9d, 0x96, 0x91, 0x90, 0x91, 0x96, 0x9c, 0xaa, 
+0xd9, 0x2f, 0x1f, 0x19, 0x15, 0x14, 0x15, 0x19, 0x1f, 0x2c, 
+0x4e, 0xb9, 0xa7, 0x9f, 0x9c, 0x9b, 0x9c, 0x9f, 0xa7, 0xb3, 
+0xcf, 0x47, 0x34, 0x2d, 0x2a, 0x2a, 0x2c, 0x31, 0x3a, 0x47, 
+0x5f, 0xe4, 0xd8, 0xd9, 0xe9, 0x64, 0x4f, 0x49, 0x46, 0x49, 
+0x58, 0xde, 0xc2, 0xb5, 0xad, 0xa8, 0xa6, 0xa6, 0xa9, 0xaf, 
+0xbf, 0x56, 0x32, 0x26, 0x1e, 0x1b, 0x19, 0x1a, 0x1d, 0x24, 
+0x33, 0xdd, 0xad, 0x9f, 0x98, 0x94, 0x92, 0x93, 0x97, 0x9e, 
+0xac, 0xf8, 0x2c, 0x1d, 0x16, 0x11, 0xf, 0x10, 0x15, 0x1b, 
+0x29, 0x55, 0xae, 0x9e, 0x97, 0x92, 0x90, 0x91, 0x95, 0x9c, 
+0xa8, 0xca, 0x35, 0x22, 0x1a, 0x16, 0x15, 0x16, 0x19, 0x1f, 
+0x2b, 0x47, 0xbe, 0xab, 0xa2, 0x9e, 0x9d, 0x9e, 0xa2, 0xa9, 
+0xb4, 0xcc, 0x4f, 0x3a, 0x32, 0x2f, 0x2f, 0x32, 0x39, 0x41, 
+0x4f, 0x67, 0xf5, 0xf5, 0x67, 0x51, 0x46, 0x3e, 0x3b, 0x3b, 
+0x3f, 0x4d, 0xe2, 0xbe, 0xb0, 0xa9, 0xa4, 0xa1, 0xa1, 0xa5, 
+0xab, 0xba, 0x64, 0x33, 0x25, 0x1d, 0x19, 0x17, 0x18, 0x1b, 
+0x20, 0x2e, 0x72, 0xae, 0x9f, 0x98, 0x94, 0x91, 0x92, 0x96, 
+0x9c, 0xa9, 0xd4, 0x2f, 0x1e, 0x17, 0x11, 0xf, 0x10, 0x14, 
+0x1a, 0x26, 0x48, 0xb2, 0x9f, 0x98, 0x93, 0x91, 0x92, 0x95, 
+0x9b, 0xa7, 0xc1, 0x3a, 0x25, 0x1c, 0x18, 0x16, 0x17, 0x1a, 
+0x1f, 0x2b, 0x42, 0xc6, 0xae, 0xa6, 0xa0, 0x9f, 0xa0, 0xa5, 
+0xab, 0xb6, 0xcb, 0x5a, 0x40, 0x39, 0x36, 0x37, 0x3b, 0x43, 
+0x4e, 0x60, 0x7b, 0x7c, 0x60, 0x4e, 0x41, 0x3a, 0x34, 0x32, 
+0x33, 0x39, 0x45, 0xed, 0xbd, 0xae, 0xa6, 0xa0, 0x9e, 0x9e, 
+0xa0, 0xa8, 0xb4, 0xef, 0x34, 0x24, 0x1c, 0x18, 0x16, 0x16, 
+0x19, 0x1e, 0x2b, 0x54, 0xb1, 0x9f, 0x98, 0x93, 0x91, 0x91, 
+0x95, 0x9b, 0xa6, 0xc6, 0x33, 0x1f, 0x17, 0x12, 0xf, 0x10, 
+0x13, 0x1a, 0x24, 0x3e, 0xb8, 0xa2, 0x99, 0x94, 0x92, 0x92, 
+0x96, 0x9b, 0xa6, 0xbc, 0x40, 0x29, 0x1e, 0x1a, 0x18, 0x19, 
+0x1b, 0x20, 0x2b, 0x3f, 0xcf, 0xb3, 0xa9, 0xa5, 0xa3, 0xa4, 
+0xa8, 0xae, 0xb9, 0xcc, 0x67, 0x49, 0x40, 0x3f, 0x42, 0x4a, 
+0x59, 0x79, 0xe5, 0xe4, 0x7a, 0x54, 0x43, 0x39, 0x31, 0x2d, 
+0x2c, 0x2d, 0x32, 0x3e, 0x71, 0xbd, 0xad, 0xa4, 0x9e, 0x9c, 
+0x9c, 0x9e, 0xa4, 0xaf, 0xd7, 0x36, 0x24, 0x1c, 0x17, 0x15, 
+0x15, 0x17, 0x1d, 0x28, 0x47, 0xb5, 0xa1, 0x98, 0x93, 0x90, 
+0x90, 0x93, 0x99, 0xa4, 0xbd, 0x38, 0x21, 0x18, 0x13, 0x10, 
+0x10, 0x13, 0x19, 0x22, 0x39, 0xbe, 0xa5, 0x9b, 0x96, 0x93, 
+0x93, 0x96, 0x9b, 0xa5, 0xb9, 0x4a, 0x2c, 0x20, 0x1c, 0x1a, 
+0x1a, 0x1d, 0x22, 0x2c, 0x3d, 0xdc, 0xb8, 0xad, 0xa9, 0xa8, 
+0xa9, 0xac, 0xb2, 0xbd, 0xce, 0x78, 0x54, 0x4d, 0x4f, 0x5a, 
+0xff, 0xda, 0xcf, 0xcd, 0xd4, 0xf8, 0x4e, 0x3d, 0x32, 0x2c, 
+0x29, 0x28, 0x29, 0x2d, 0x38, 0x5c, 0xbd, 0xac, 0xa2, 0x9d, 
+0x9a, 0x9a, 0x9c, 0xa0, 0xac, 0xca, 0x39, 0x25, 0x1b, 0x16, 
+0x13, 0x13, 0x16, 0x1b, 0x25, 0x3e, 0xb9, 0xa2, 0x99, 0x93, 
+0x90, 0x90, 0x93, 0x98, 0xa1, 0xb8, 0x3d, 0x24, 0x19, 0x13, 
+0x10, 0x10, 0x13, 0x18, 0x21, 0x35, 0xc7, 0xa8, 0x9d, 0x97, 
+0x95, 0x95, 0x97, 0x9c, 0xa4, 0xb6, 0x57, 0x2f, 0x24, 0x1e, 
+0x1c, 0x1c, 0x1e, 0x24, 0x2d, 0x3d, 0xf1, 0xbe, 0xb2, 0xad, 
+0xac, 0xad, 0xb1, 0xb9, 0xc3, 0xd4, 0xfa, 0x64, 0x65, 0xf9, 
+0xd9, 0xca, 0xc2, 0xbf, 0xc0, 0xc9, 0xe7, 0x4c, 0x39, 0x2e, 
+0x28, 0x24, 0x23, 0x25, 0x29, 0x33, 0x4f, 0xbf, 0xab, 0xa0, 
+0x9b, 0x99, 0x98, 0x9a, 0x9e, 0xa9, 0xc0, 0x3c, 0x26, 0x1b, 
+0x16, 0x12, 0x12, 0x14, 0x19, 0x22, 0x38, 0xbe, 0xa4, 0x9a, 
+0x93, 0x90, 0x8f, 0x92, 0x97, 0x9f, 0xb3, 0x46, 0x26, 0x1b, 
+0x15, 0x11, 0x11, 0x13, 0x18, 0x1f, 0x31, 0xd4, 0xab, 0x9e, 
+0x99, 0x96, 0x96, 0x98, 0x9c, 0xa4, 0xb4, 0x6f, 0x34, 0x28, 
+0x20, 0x1e, 0x1e, 0x20, 0x26, 0x2e, 0x3d, 0x6d, 0xc5, 0xb9, 
+0xb3, 0xb2, 0xb4, 0xba, 0xc1, 0xcd, 0xe0, 0xfc, 0xfb, 0xe0, 
+0xce, 0xc3, 0xbb, 0xb7, 0xb6, 0xb9, 0xc0, 0xda, 0x4b, 0x36, 
+0x2b, 0x25, 0x20, 0x1f, 0x20, 0x26, 0x2e, 0x46, 0xc2, 0xab, 
+0x9f, 0x9a, 0x97, 0x96, 0x98, 0x9c, 0xa5, 0xba, 0x41, 0x27, 
+0x1b, 0x15, 0x12, 0x11, 0x13, 0x18, 0x1f, 0x32, 0xc8, 0xa6, 
+0x9a, 0x94, 0x90, 0x8f, 0x91, 0x97, 0x9e, 0xaf, 0x54, 0x29, 
+0x1c, 0x16, 0x12, 0x11, 0x14, 0x18, 0x1f, 0x2e, 0xf2, 0xae, 
+0xa0, 0x9b, 0x98, 0x97, 0x99, 0x9d, 0xa5, 0xb3, 0xe4, 0x3a, 
+0x2b, 0x25, 0x21, 0x21, 0x24, 0x29, 0x30, 0x3e, 0x62, 0xcd, 
+0xbf, 0xbb, 0xbb, 0xbe, 0xc6, 0xd1, 0xe7, 0x76, 0x75, 0xe7, 
+0xcf, 0xc1, 0xb9, 0xb2, 0xaf, 0xaf, 0xb2, 0xba, 0xcf, 0x4c, 
+0x34, 0x29, 0x22, 0x1e, 0x1d, 0x1e, 0x22, 0x2b, 0x3e, 0xc7, 
+0xab, 0x9f, 0x99, 0x96, 0x95, 0x96, 0x9a, 0xa2, 0xb5, 0x4a, 
+0x28, 0x1c, 0x15, 0x11, 0x10, 0x12, 0x17, 0x1e, 0x2e, 0xd5, 
+0xa9, 0x9b, 0x95, 0x90, 0x8f, 0x91, 0x96, 0x9d, 0xac, 0x78, 
+0x2c, 0x1e, 0x17, 0x13, 0x12, 0x14, 0x18, 0x1f, 0x2d, 0x5d, 
+0xb3, 0xa4, 0x9d, 0x9a, 0x99, 0x9b, 0x9e, 0xa6, 0xb2, 0xd6, 
+0x3f, 0x2f, 0x29, 0x26, 0x26, 0x28, 0x2d, 0x35, 0x42, 0x5e, 
+0xd8, 0xca, 0xc6, 0xc9, 0xcf, 0xe4, 0x69, 0x59, 0x58, 0x64, 
+0xdf, 0xc7, 0xba, 0xb1, 0xac, 0xaa, 0xaa, 0xad, 0xb4, 0xc7, 
+0x4f, 0x33, 0x27, 0x1f, 0x1c, 0x1b, 0x1c, 0x1f, 0x27, 0x39, 
+0xce, 0xac, 0x9f, 0x99, 0x95, 0x94, 0x95, 0x99, 0x9f, 0xaf, 
+0x59, 0x2a, 0x1c, 0x16, 0x11, 0x10, 0x11, 0x16, 0x1d, 0x2b };
+/*
+  * 8-bit raw data
+  *
+  * Source: DialTone.ulaw
+  *
   * Copyright (C) 1999, Mark Spencer
   *
   * Distributed under the terms of the GNU General Public License

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/codecs/Makefile	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,6 +1,78 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
+# Makefile for PBX frontends (dynamically loaded)
+#
+# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+#
+# Mark Spencer <markster at linux-support.net>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+#
+# Uncomment if you have g723.1 code (with the same API as the Annex-A code
+# and have placed it in the g723.1 directory and/or the Annex-B code in 
+# g723.1b)
+#
+#MODG723=codec_g723_1.so codec_g723_1b.so
+MODG723=$(shell [ -f g723.1/coder.c ] && echo "codec_g723_1.so")
+MODG723+=$(shell [ -f g723.1b/coder2.c ] && echo "codec_g723_1b.so")
+
+CFLAGS+=
+
+LIBG723=g723.1/libg723.a
+LIBG723B=g723.1b/libg723b.a
+LIBGSM=gsm/lib/libgsm.a
+LIBMP3=mp3/libmp3.a
+
+CODECS+=$(MODG723) codec_gsm.so #codec_mp3_d.so
+
+all: $(CODECS)
+
+clean:
+	rm -f *.so *.o
+	make -C g723.1 clean
+	make -C g723.1b clean
+	make -C gsm clean
+	make -C mp3 clean
+
+$(LIBG723):
+	make -C g723.1 all
+
+$(LIBGSM):
+	make -C gsm lib/libgsm.a
+
+$(LIBG723B):
+	make -C g723.1b all
+
+$(LIBMP3):
+	make -C mp3 all
+
+codec_g723_1.so : codec_g723_1.o $(LIBG723)
+	$(CC) -shared -Xlinker -x -o $@ $< $(LIBG723)
+
+codec_g723_1b.o : codec_g723_1.c
+	$(CC) -c -o $@ $(CFLAGS) -DANNEX_B $<
+
+codec_g723_1b.so : codec_g723_1b.o $(LIBG723B)
+	$(CC) -shared -Xlinker -x -o $@ $< $(LIBG723B) -lm
+
+codec_gsm.so: codec_gsm.o $(LIBGSM)
+	$(CC) -shared -Xlinker -x -o $@ $< $(LIBGSM)
+
+codec_mp3_d.so: codec_mp3_d.o $(LIBMP3)
+	$(CC) -shared -Xlinker -x -o $@ $< $(LIBMP3)
+
+%.so : %.o
+	$(CC) -shared -Xlinker -x -o $@ $<
+
+install: all
+	for x in $(CODECS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
 # Makefile for codec modules
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/codecs/codec_g723_1.c
===================================================================
--- trunk/codecs/codec_g723_1.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/codecs/codec_g723_1.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,362 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Translate between signed linear and G.723.1
+ *
+ * The G.723.1 code is not included in the Asterisk distribution because
+ * it is covered with patents, and in spite of statements to the contrary,
+ * the "technology" is extremely expensive to license.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#define TYPE_SILENCE	 0x2
+#define TYPE_HIGH	 0x0
+#define TYPE_LOW	 0x1
+#define TYPE_MASK	 0x3
+
+#include <asterisk/translate.h>
+#include <asterisk/module.h>
+#include <asterisk/logger.h>
+#include <pthread.h>
+#include <fcntl.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <netinet/in.h>
+#include <string.h>
+#include <stdio.h>
+
+#ifdef ANNEX_B
+#include "g723.1b/typedef2.h"
+#include "g723.1b/cst2.h"
+#include "g723.1b/coder2.h"
+#include "g723.1b/decod2.h"
+#include "g723.1b/deccng2.h"
+#include "g723.1b/codcng2.h"
+#include "g723.1b/vad2.h"
+#else
+#include "g723.1/typedef.h"
+#include "g723.1/cst_lbc.h"
+#include "g723.1/coder.h"
+#include "g723.1/decod.h"
+#include "g723.1/dec_cng.h"
+#include "g723.1/cod_cng.h"
+#include "g723.1/vad.h"
+#endif
+
+/* Sample frame data */
+#include "slin_g723_ex.h"
+#include "g723_slin_ex.h"
+
+static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER;
+static int localusecnt=0;
+
+#ifdef ANNEX_B
+static char *tdesc = "Annex B (floating point) G.723.1/PCM16 Codec Translator";
+#else
+static char *tdesc = "Annex A (fixed point) G.723.1/PCM16 Codec Translator";
+#endif
+
+/* Globals */
+Flag UsePf = True;
+Flag UseHp = True;
+Flag UseVx = True;
+
+enum Crate WrkRate = Rate63;
+
+struct g723_encoder_pvt {
+	struct cod_state cod;
+	struct ast_frame f;
+	/* Space to build offset */
+	char offset[AST_FRIENDLY_OFFSET];
+	/* Buffer for our outgoing frame */
+	char outbuf[24];
+	/* Enough to store a full second */
+	short buf[8000];
+	int tail;
+};
+
+struct g723_decoder_pvt {
+	struct dec_state dec;
+	struct ast_frame f;
+	/* Space to build offset */
+	char offset[AST_FRIENDLY_OFFSET];
+	/* Enough to store a full second */
+	short buf[8000];
+	int tail;
+};
+
+static struct ast_translator_pvt *g723tolin_new()
+{
+	struct g723_decoder_pvt *tmp;
+	tmp = malloc(sizeof(struct g723_decoder_pvt));
+	if (tmp) {
+		Init_Decod(&tmp->dec);
+	    Init_Dec_Cng(&tmp->dec);
+		tmp->tail = 0;
+	}
+	return (struct ast_translator_pvt *)tmp;
+}
+
+static struct ast_frame *lintog723_sample()
+{
+	static struct ast_frame f;
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass = AST_FORMAT_SLINEAR;
+	f.datalen = sizeof(slin_g723_ex);
+	/* Assume 8000 Hz */
+	f.timelen = sizeof(slin_g723_ex)/16;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data = slin_g723_ex;
+	return &f;
+}
+
+static struct ast_frame *g723tolin_sample()
+{
+	static struct ast_frame f;
+	f.frametype = AST_FRAME_VOICE;
+	f.subclass = AST_FORMAT_G723_1;
+	f.datalen = sizeof(g723_slin_ex);
+	/* All frames are 30 ms long */
+	f.timelen = 30;
+	f.mallocd = 0;
+	f.offset = 0;
+	f.src = __PRETTY_FUNCTION__;
+	f.data = g723_slin_ex;
+	return &f;
+}
+
+static struct ast_translator_pvt *lintog723_new()
+{
+	struct g723_encoder_pvt *tmp;
+	tmp = malloc(sizeof(struct g723_encoder_pvt));
+	if (tmp) {
+		Init_Coder(&tmp->cod);
+	    /* Init Comfort Noise Functions */
+   		 if( UseVx ) {
+   	   		Init_Vad(&tmp->cod);
+        	Init_Cod_Cng(&tmp->cod);
+    	 }
+		tmp->tail = 0;
+	}
+	return (struct ast_translator_pvt *)tmp;
+}
+
+static struct ast_frame *g723tolin_frameout(struct ast_translator_pvt *pvt)
+{
+	struct g723_decoder_pvt *tmp = (struct g723_decoder_pvt *)pvt;
+	if (!tmp->tail)
+		return NULL;
+	/* Signed linear is no particular frame size, so just send whatever
+	   we have in the buffer in one lump sum */
+	tmp->f.frametype = AST_FRAME_VOICE;
+	tmp->f.subclass = AST_FORMAT_SLINEAR;
+	tmp->f.datalen = tmp->tail * 2;
+	/* Assume 8000 Hz */
+	tmp->f.timelen = tmp->tail / 8;
+	tmp->f.mallocd = 0;
+	tmp->f.offset = AST_FRIENDLY_OFFSET;
+	tmp->f.src = __PRETTY_FUNCTION__;
+	tmp->f.data = tmp->buf;
+	/* Reset tail pointer */
+	tmp->tail = 0;
+
+#if 0
+	/* Save a sample frame */
+	{ static int samplefr = 0;
+	if (samplefr == 80) {
+		int fd;
+		fd = open("g723.example", O_WRONLY | O_CREAT | O_TRUNC, 0644);
+		write(fd, tmp->f.data, tmp->f.datalen);
+		close(fd);
+	} 		
+	samplefr++;
+	}
+#endif
+	return &tmp->f;	
+}
+
+static int g723tolin_framein(struct ast_translator_pvt *pvt, struct ast_frame *f)
+{
+	struct g723_decoder_pvt *tmp = (struct g723_decoder_pvt *)pvt;
+#ifdef  ANNEX_B
+	FLOAT tmpdata[Frame];
+	int x;
+#endif
+	/* Assuming there's space left, decode into the current buffer at
+	   the tail location */
+	if (tmp->tail + Frame < sizeof(tmp->buf)/2) {	
+#ifdef ANNEX_B
+		Decod(&tmp->dec, tmpdata, f->data, 0);
+		for (x=0;x<Frame;x++)
+			(tmp->buf + tmp->tail)[x] = tmpdata[x]; 
+#else
+		Decod(&tmp->dec, tmp->buf + tmp->tail, f->data, 0);
+#endif
+		tmp->tail+=Frame;
+	} else {
+		ast_log(LOG_WARNING, "Out of buffer space\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int lintog723_framein(struct ast_translator_pvt *pvt, struct ast_frame *f)
+{
+	/* Just add the frames to our stream */
+	/* XXX We should look at how old the rest of our stream is, and if it
+	   is too old, then we should overwrite it entirely, otherwise we can
+	   get artifacts of earlier talk that do not belong */
+	struct g723_encoder_pvt *tmp = (struct g723_encoder_pvt *)pvt;
+	if (tmp->tail + f->datalen/2 < sizeof(tmp->buf) / 2) {
+		memcpy(&tmp->buf[tmp->tail], f->data, f->datalen);
+		tmp->tail += f->datalen/2;
+	} else {
+		ast_log(LOG_WARNING, "Out of buffer space\n");
+		return -1;
+	}
+	return 0;
+}
+
+static struct ast_frame *lintog723_frameout(struct ast_translator_pvt *pvt)
+{
+	struct g723_encoder_pvt *tmp = (struct g723_encoder_pvt *)pvt;
+#ifdef ANNEX_B
+	int x;
+	FLOAT tmpdata[Frame];
+#endif
+	/* We can't work on anything less than a frame in size */
+	if (tmp->tail < Frame)
+		return NULL;
+	/* Encode a frame of data */
+#ifdef ANNEX_B
+	for (x=0;x<Frame;x++)
+		tmpdata[x] = tmp->buf[x];
+	Coder(&tmp->cod, tmpdata, tmp->outbuf);
+#else
+	Coder(&tmp->cod, tmp->buf, tmp->outbuf);
+#endif
+	tmp->f.frametype = AST_FRAME_VOICE;
+	tmp->f.subclass = AST_FORMAT_G723_1;
+	/* Assume 8000 Hz */
+	tmp->f.timelen = 30;
+	tmp->f.mallocd = 0;
+	tmp->f.offset = AST_FRIENDLY_OFFSET;
+	tmp->f.src = __PRETTY_FUNCTION__;
+	tmp->f.data = tmp->outbuf;
+	switch(tmp->outbuf[0] & TYPE_MASK) {
+	case TYPE_MASK:
+	case TYPE_SILENCE:
+		tmp->f.datalen = 4;
+		break;
+	case TYPE_HIGH:
+		tmp->f.datalen = 24;
+		break;
+	case TYPE_LOW:
+		tmp->f.datalen = 20;
+		break;
+	default:
+		ast_log(LOG_WARNING, "Badly encoded frame (%d)\n", tmp->outbuf[0] & TYPE_MASK);
+	}
+	tmp->tail -= Frame;
+	/* Move the data at the end of the buffer to the front */
+	if (tmp->tail)
+		memmove(tmp->buf, tmp->buf + Frame, tmp->tail * 2);
+#if 0
+	/* Save to a g723 sample output file... */
+	{ 
+		static int fd = -1;
+		int delay = htonl(30);
+		short size;
+		if (fd < 0)
+			fd = open("trans.g723", O_WRONLY | O_CREAT | O_TRUNC, 0644);
+		if (fd < 0)
+			ast_log(LOG_WARNING, "Unable to create demo\n");
+		write(fd, &delay, 4);
+		size = htons(tmp->f.datalen);
+		write(fd, &size, 2);
+		write(fd, tmp->f.data, tmp->f.datalen);
+	}
+#endif
+	return &tmp->f;	
+}
+
+static void g723_destroy(struct ast_translator_pvt *pvt)
+{
+	free(pvt);
+}
+
+static struct ast_translator g723tolin =
+#ifdef ANNEX_B
+	{ "g723tolinb", 
+#else
+	{ "g723tolin", 
+#endif
+	   AST_FORMAT_G723_1, AST_FORMAT_SLINEAR,
+	   g723tolin_new,
+	   g723tolin_framein,
+	   g723tolin_frameout,
+	   g723_destroy,
+	   g723tolin_sample
+	   };
+
+static struct ast_translator lintog723 =
+#ifdef ANNEX_B
+	{ "lintog723b", 
+#else
+	{ "lintog723", 
+#endif
+	   AST_FORMAT_SLINEAR, AST_FORMAT_G723_1,
+	   lintog723_new,
+	   lintog723_framein,
+	   lintog723_frameout,
+	   g723_destroy,
+	   lintog723_sample
+	   };
+
+int unload_module(void)
+{
+	int res;
+	pthread_mutex_lock(&localuser_lock);
+	res = ast_unregister_translator(&lintog723);
+	if (!res)
+		res = ast_unregister_translator(&g723tolin);
+	if (localusecnt)
+		res = -1;
+	pthread_mutex_unlock(&localuser_lock);
+	return res;
+}
+
+int load_module(void)
+{
+	int res;
+	res=ast_register_translator(&g723tolin);
+	if (!res) 
+		res=ast_register_translator(&lintog723);
+	else
+		ast_unregister_translator(&g723tolin);
+	return res;
+}
+
+char *description(void)
+{
+	return tdesc;
+}
+
+int usecount(void)
+{
+	int res;
+	STANDARD_USECOUNT(res);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * The G.723.1 code is not included in the Asterisk distribution because

Modified: trunk/codecs/g723_slin_ex.h
===================================================================
--- trunk/codecs/g723_slin_ex.h	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/codecs/g723_slin_ex.h	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,3 +1,18 @@
+/*
+  * 8-bit raw data
+  *
+  * Source: g723.example
+  *
+  * Copyright (C) 1999, Mark Spencer and Linux Support Services
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+static unsigned char g723_slin_ex[] = {
+0x4c, 0x34, 0xc2, 0xd9, 0x81, 0x80, 0xa8, 0x50, 0xd7, 0x8d, 
+0x8, 0x80, 0xf0, 0xb4, 0x40, 0x53, 0xe3, 0xe1, 0x63, 0x4e, 
+0x1a, 0x37, 0xd6, 0x0037 };
 /*! \file
   * \brief 8-bit raw data
   *

Modified: trunk/codecs/gsm/Makefile
===================================================================
--- trunk/codecs/gsm/Makefile	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/codecs/gsm/Makefile	2006-06-28 10:25:31 UTC (rev 421)
@@ -7,6 +7,500 @@
 SASR	= -DSASR
 ######### Define SASR if >> is a signed arithmetic shift (-1 >> 1 == -1)
 
+MULHACK = -DUSE_FLOAT_MUL
+######### Define this if your host multiplies floats faster than integers,
+######### e.g. on a SPARCstation.
+
+FAST	= -DFAST
+######### Define together with USE_FLOAT_MUL to enable the GSM library's
+######### approximation option for incorrect, but good-enough results.
+
+# LTP_CUT	= -DLTP_CUT
+LTP_CUT	=
+######### Define to enable the GSM library's long-term correlation 
+######### approximation option---faster, but worse; works for
+######### both integer and floating point multiplications.
+######### This flag is still in the experimental stage.
+
+WAV49	= -DWAV49
+#WAV49	=
+######### Define to enable the GSM library's option to pack GSM frames 
+######### in the style used by the WAV #49 format.  If you want to write
+######### a tool that produces .WAV files which contain GSM-encoded data,
+######### define this, and read about the GSM_OPT_WAV49 option in the
+######### manual page on gsm_option(3).
+
+# Choose a compiler.  The code works both with ANSI and K&R-C.
+# Use -DNeedFunctionPrototypes to compile with, -UNeedFunctionPrototypes to
+# compile without, function prototypes in the header files.
+#
+# You can use the -DSTUPID_COMPILER to circumvent some compilers'
+# static limits regarding the number of subexpressions in a statement.
+
+# CC		= cc
+# CCFLAGS 	= -c -DSTUPID_COMPILER
+
+# CC		= /usr/lang/acc
+# CCFLAGS 	= -c -O
+
+CC		= gcc -ansi -pedantic
+CCFLAGS 	+= -c -DNeedFunctionPrototypes=1 -finline-functions -funroll-loops
+
+LD 		= $(CC)
+
+# LD		= gcc
+# LDFLAGS 	=
+
+
+# If your compiler needs additional flags/libraries, regardless of
+# the source compiled, configure them here.
+
+# CCINC	= -I/usr/gnu/lib/gcc-2.1/gcc-lib/sparc-sun-sunos4.1.2/2.1/include
+######### Includes needed by $(CC)
+
+# LDINC	= -L/usr/gnu/lib/gcc-2.1/gcc-lib/sparc-sun-sunos4.1.2/2.1
+######### Library paths needed by $(LD)
+
+# LDLIB	= -lgcc
+######### Additional libraries needed by $(LD)
+
+
+# Where do you want to install libraries, binaries, a header file
+# and the manual pages?
+#
+# Leave INSTALL_ROOT empty (or just don't execute "make install") to
+# not install gsm and toast outside of this directory.
+
+INSTALL_ROOT	=
+
+# Where do you want to install the gsm library, header file, and manpages?
+#
+# Leave GSM_INSTALL_ROOT empty to not install the GSM library outside of
+# this directory.
+
+GSM_INSTALL_ROOT = $(INSTALL_ROOT)
+GSM_INSTALL_LIB = $(GSM_INSTALL_ROOT)/lib
+GSM_INSTALL_INC = $(GSM_INSTALL_ROOT)/inc
+GSM_INSTALL_MAN = $(GSM_INSTALL_ROOT)/man/man3
+
+
+# Where do you want to install the toast binaries and their manpage?
+#
+# Leave TOAST_INSTALL_ROOT empty to not install the toast binaries outside
+# of this directory.
+
+TOAST_INSTALL_ROOT	  = $(INSTALL_ROOT)
+TOAST_INSTALL_BIN = $(TOAST_INSTALL_ROOT)/bin
+TOAST_INSTALL_MAN = $(TOAST_INSTALL_ROOT)/man/man1
+
+#  Other tools
+
+SHELL		= /bin/sh
+LN		= ln
+BASENAME 	= basename
+AR		= ar
+ARFLAGS		= cr
+RMFLAGS		= -f
+FIND		= find
+COMPRESS 	= compress
+COMPRESSFLAGS 	= 
+# RANLIB 	= true
+RANLIB	 	= ranlib
+
+#
+#    You shouldn't have to configure below this line if you're porting.
+# 
+
+
+# Local Directories
+
+ROOT	= .
+ADDTST	= $(ROOT)/add-test
+TST	= $(ROOT)/tst
+MAN	= $(ROOT)/man
+BIN	= $(ROOT)/bin
+SRC	= $(ROOT)/src
+LIB	= $(ROOT)/lib
+TLS	= $(ROOT)/tls
+INC	= $(ROOT)/inc
+
+# Flags
+
+# DEBUG	= -DNDEBUG
+######### Remove -DNDEBUG to enable assertions.
+
+CFLAGS	= $(CCFLAGS) $(SASR) $(DEBUG) $(MULHACK) $(FAST) $(LTP_CUT) \
+	$(WAV49) $(CCINC) -I$(INC)
+######### It's $(CC) $(CFLAGS)
+
+LFLAGS	= $(LDFLAGS) $(LDINC)
+######### It's $(LD) $(LFLAGS)
+
+
+# Targets
+
+LIBGSM	= $(LIB)/libgsm.a
+
+TOAST	= $(BIN)/toast
+UNTOAST	= $(BIN)/untoast
+TCAT	= $(BIN)/tcat
+
+# Headers
+
+GSM_HEADERS =	$(INC)/gsm.h
+
+HEADERS	=	$(INC)/proto.h		\
+		$(INC)/unproto.h	\
+		$(INC)/config.h		\
+		$(INC)/private.h	\
+		$(INC)/gsm.h		\
+		$(INC)/toast.h		\
+		$(TLS)/taste.h
+
+# Sources
+
+GSM_SOURCES =	$(SRC)/add.c		\
+		$(SRC)/code.c		\
+		$(SRC)/debug.c		\
+		$(SRC)/decode.c		\
+		$(SRC)/long_term.c	\
+		$(SRC)/lpc.c		\
+		$(SRC)/preprocess.c	\
+		$(SRC)/rpe.c		\
+		$(SRC)/gsm_destroy.c	\
+		$(SRC)/gsm_decode.c	\
+		$(SRC)/gsm_encode.c	\
+		$(SRC)/gsm_explode.c	\
+		$(SRC)/gsm_implode.c	\
+		$(SRC)/gsm_create.c	\
+		$(SRC)/gsm_print.c	\
+		$(SRC)/gsm_option.c	\
+		$(SRC)/short_term.c	\
+		$(SRC)/table.c
+
+TOAST_SOURCES = $(SRC)/toast.c 		\
+		$(SRC)/toast_lin.c	\
+		$(SRC)/toast_ulaw.c	\
+		$(SRC)/toast_alaw.c	\
+		$(SRC)/toast_audio.c
+
+SOURCES	=	$(GSM_SOURCES)		\
+		$(TOAST_SOURCES)	\
+		$(ADDTST)/add_test.c	\
+		$(TLS)/sour.c		\
+		$(TLS)/ginger.c		\
+		$(TLS)/sour1.dta	\
+		$(TLS)/sour2.dta	\
+		$(TLS)/bitter.c		\
+		$(TLS)/bitter.dta	\
+		$(TLS)/taste.c		\
+		$(TLS)/sweet.c		\
+		$(TST)/cod2lin.c	\
+		$(TST)/cod2txt.c	\
+		$(TST)/gsm2cod.c	\
+		$(TST)/lin2cod.c	\
+		$(TST)/lin2txt.c
+
+# Object files
+
+GSM_OBJECTS =	$(SRC)/add.o		\
+		$(SRC)/code.o		\
+		$(SRC)/debug.o		\
+		$(SRC)/decode.o		\
+		$(SRC)/long_term.o	\
+		$(SRC)/lpc.o		\
+		$(SRC)/preprocess.o	\
+		$(SRC)/rpe.o		\
+		$(SRC)/gsm_destroy.o	\
+		$(SRC)/gsm_decode.o	\
+		$(SRC)/gsm_encode.o	\
+		$(SRC)/gsm_explode.o	\
+		$(SRC)/gsm_implode.o	\
+		$(SRC)/gsm_create.o	\
+		$(SRC)/gsm_print.o	\
+		$(SRC)/gsm_option.o	\
+		$(SRC)/short_term.o	\
+		$(SRC)/table.o
+
+TOAST_OBJECTS =	$(SRC)/toast.o 		\
+		$(SRC)/toast_lin.o	\
+		$(SRC)/toast_ulaw.o	\
+		$(SRC)/toast_alaw.o	\
+		$(SRC)/toast_audio.o
+
+OBJECTS =	 $(GSM_OBJECTS) $(TOAST_OBJECTS)
+
+# Manuals
+
+GSM_MANUALS =	$(MAN)/gsm.3		\
+		$(MAN)/gsm_explode.3	\
+		$(MAN)/gsm_option.3	\
+		$(MAN)/gsm_print.3
+
+TOAST_MANUALS =	$(MAN)/toast.1
+
+MANUALS	= 	$(GSM_MANUALS) $(TOAST_MANUALS) $(MAN)/bitter.1
+
+# Other stuff in the distribution
+
+STUFF = 	ChangeLog			\
+		INSTALL			\
+		MACHINES		\
+		MANIFEST		\
+		Makefile		\
+		README			\
+		$(ADDTST)/add_test.dta	\
+		$(TLS)/bitter.dta	\
+		$(TST)/run
+
+
+# Install targets
+
+GSM_INSTALL_TARGETS =	\
+		$(GSM_INSTALL_LIB)/libgsm.a		\
+		$(GSM_INSTALL_INC)/gsm.h		\
+		$(GSM_INSTALL_MAN)/gsm.3		\
+		$(GSM_INSTALL_MAN)/gsm_explode.3	\
+		$(GSM_INSTALL_MAN)/gsm_option.3		\
+		$(GSM_INSTALL_MAN)/gsm_print.3
+
+TOAST_INSTALL_TARGETS =	\
+		$(TOAST_INSTALL_BIN)/toast		\
+		$(TOAST_INSTALL_BIN)/tcat		\
+		$(TOAST_INSTALL_BIN)/untoast		\
+		$(TOAST_INSTALL_MAN)/toast.1
+
+
+# Default rules
+
+.c.o:
+		$(CC) $(CFLAGS) $?
+		@-mv `$(BASENAME) $@` $@ > /dev/null 2>&1
+
+# Target rules
+
+all:		$(LIBGSM) $(TOAST) $(TCAT) $(UNTOAST)
+		@-echo $(ROOT): Done.
+
+tst:		$(TST)/lin2cod $(TST)/cod2lin $(TOAST) $(TST)/test-result
+		@-echo tst: Done.
+
+addtst:		$(ADDTST)/add $(ADDTST)/add_test.dta
+		$(ADDTST)/add < $(ADDTST)/add_test.dta > /dev/null
+		@-echo addtst: Done.
+
+misc:		$(TLS)/sweet $(TLS)/bitter $(TLS)/sour $(TLS)/ginger 	\
+			$(TST)/lin2txt $(TST)/cod2txt $(TST)/gsm2cod
+		@-echo misc: Done.
+
+install:	toastinstall gsminstall
+		@-echo install: Done.
+
+
+# The basic API: libgsm
+
+$(LIBGSM):	$(LIB) $(GSM_OBJECTS)
+		-rm $(RMFLAGS) $(LIBGSM)
+		$(AR) $(ARFLAGS) $(LIBGSM) $(GSM_OBJECTS)
+		$(RANLIB) $(LIBGSM)
+
+
+# Toast, Untoast and Tcat -- the compress-like frontends to gsm.
+
+$(TOAST):	$(BIN) $(TOAST_OBJECTS) $(LIBGSM)
+		$(LD) $(LFLAGS) -o $(TOAST) $(TOAST_OBJECTS) $(LIBGSM) $(LDLIB)
+
+$(UNTOAST):	$(BIN) $(TOAST)
+		-rm $(RMFLAGS) $(UNTOAST)
+		$(LN) $(TOAST) $(UNTOAST)
+
+$(TCAT):	$(BIN) $(TOAST)
+		-rm $(RMFLAGS) $(TCAT)
+		$(LN) $(TOAST) $(TCAT)
+
+
+# The local bin and lib directories
+
+$(BIN):
+		if [ ! -d $(BIN) ] ; then mkdir $(BIN) ; fi
+
+$(LIB):
+		if [ ! -d $(LIB) ] ; then mkdir $(LIB) ; fi
+
+
+# Installation
+
+gsminstall:
+		-if [ x"$(GSM_INSTALL_ROOT)" != x ] ; then	\
+			make $(GSM_INSTALL_TARGETS) ;	\
+		fi
+
+toastinstall:
+		-if [ x"$(TOAST_INSTALL_ROOT)" != x ]; then	\
+			make $(TOAST_INSTALL_TARGETS);	\
+		fi
+
+gsmuninstall:
+		-if [ x"$(GSM_INSTALL_ROOT)" != x ] ; then	\
+			rm $(RMFLAGS) $(GSM_INSTALL_TARGETS) ;	\
+		fi
+
+toastuninstall:
+		-if [ x"$(TOAST_INSTALL_ROOT)" != x ] ; then 	\
+			rm $(RMFLAGS) $(TOAST_INSTALL_TARGETS);	\
+		fi
+
+$(TOAST_INSTALL_BIN)/toast:	$(TOAST)
+		-rm $@
+		cp $(TOAST) $@
+		chmod 755 $@
+
+$(TOAST_INSTALL_BIN)/untoast:	$(TOAST_INSTALL_BIN)/toast
+		-rm $@
+		ln $? $@
+
+$(TOAST_INSTALL_BIN)/tcat:	$(TOAST_INSTALL_BIN)/toast
+		-rm $@
+		ln $? $@
+
+$(TOAST_INSTALL_MAN)/toast.1:	$(MAN)/toast.1
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+$(GSM_INSTALL_MAN)/gsm.3:	$(MAN)/gsm.3
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+$(GSM_INSTALL_MAN)/gsm_option.3:	$(MAN)/gsm_option.3
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+$(GSM_INSTALL_MAN)/gsm_explode.3:	$(MAN)/gsm_explode.3
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+$(GSM_INSTALL_MAN)/gsm_print.3:	$(MAN)/gsm_print.3
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+$(GSM_INSTALL_INC)/gsm.h:	$(INC)/gsm.h
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+$(GSM_INSTALL_LIB)/libgsm.a:	$(LIBGSM)
+		-rm $@
+		cp $? $@
+		chmod 444 $@
+
+
+# Distribution
+
+dist:		gsm-1.0.tar.Z
+		@echo dist: Done.
+
+gsm-1.0.tar.Z:	$(STUFF) $(SOURCES) $(HEADERS) $(MANUALS)
+		(	cd $(ROOT)/..;				\
+			tar cvf - `cat $(ROOT)/gsm-1.0/MANIFEST	\
+				| sed '/^#/d'`			\
+		) | $(COMPRESS) $(COMPRESSFLAGS) > $(ROOT)/gsm-1.0.tar.Z
+
+# Clean
+
+uninstall:	toastuninstall gsmuninstall
+		@-echo uninstall: Done.
+
+semi-clean:
+		-rm $(RMFLAGS)  */*.o			\
+			$(TST)/lin2cod $(TST)/lin2txt	\
+			$(TST)/cod2lin $(TST)/cod2txt	\
+			$(TST)/gsm2cod 			\
+			$(TST)/*.*.*
+		-$(FIND) . \( -name core -o -name foo \) \
+			-print | xargs rm $(RMFLAGS)
+
+clean:	semi-clean
+		-rm $(RMFLAGS) $(LIBGSM) $(ADDTST)/add		\
+			$(TOAST) $(TCAT) $(UNTOAST)	\
+			$(ROOT)/gsm-1.0.tar.Z
+
+
+# Two tools that helped me generate gsm_encode.c and gsm_decode.c,
+# but aren't generally needed to port this.
+
+$(TLS)/sweet:	$(TLS)/sweet.o $(TLS)/taste.o
+		$(LD) $(LFLAGS) -o $(TLS)/sweet \
+			$(TLS)/sweet.o $(TLS)/taste.o $(LDLIB)
+
+$(TLS)/bitter:	$(TLS)/bitter.o $(TLS)/taste.o
+		$(LD) $(LFLAGS) -o $(TLS)/bitter \
+			$(TLS)/bitter.o $(TLS)/taste.o $(LDLIB)
+
+# A version of the same family that Jeff Chilton used to implement
+# the WAV #49 GSM format.
+
+$(TLS)/ginger:	$(TLS)/ginger.o $(TLS)/taste.o
+		$(LD) $(LFLAGS) -o $(TLS)/ginger \
+			$(TLS)/ginger.o $(TLS)/taste.o $(LDLIB)
+
+$(TLS)/sour:	$(TLS)/sour.o $(TLS)/taste.o
+		$(LD) $(LFLAGS) -o $(TLS)/sour \
+			$(TLS)/sour.o $(TLS)/taste.o $(LDLIB)
+
+# Run $(ADDTST)/add < $(ADDTST)/add_test.dta to make sure the
+# basic arithmetic functions work as intended.
+
+$(ADDTST)/add:	$(ADDTST)/add_test.o
+		$(LD) $(LFLAGS) -o $(ADDTST)/add $(ADDTST)/add_test.o $(LDLIB)
+
+
+# Various conversion programs between linear, text, .gsm and the code
+# format used by the tests we ran (.cod).  We paid for the test data,
+# so I guess we can't just provide them with this package.  Still,
+# if you happen to have them lying around, here's the code.
+# 
+# You can use gsm2cod | cod2txt independently to look at what's
+# coded inside the compressed frames, although this shouldn't be
+# hard to roll on your own using the gsm_print() function from
+# the API.
+
+
+$(TST)/test-result:	$(TST)/lin2cod $(TST)/cod2lin $(TOAST) $(TST)/run
+			( cd $(TST); ./run ) 
+
+$(TST)/lin2txt:		$(TST)/lin2txt.o $(LIBGSM)
+			$(LD) $(LFLAGS) -o $(TST)/lin2txt \
+				$(TST)/lin2txt.o $(LIBGSM) $(LDLIB)
+
+$(TST)/lin2cod:		$(TST)/lin2cod.o $(LIBGSM)
+			$(LD) $(LFLAGS) -o $(TST)/lin2cod \
+				$(TST)/lin2cod.o $(LIBGSM) $(LDLIB)
+
+$(TST)/gsm2cod:		$(TST)/gsm2cod.o $(LIBGSM)
+			$(LD) $(LFLAGS) -o $(TST)/gsm2cod \
+				$(TST)/gsm2cod.o $(LIBGSM) $(LDLIB)
+
+$(TST)/cod2txt:		$(TST)/cod2txt.o $(LIBGSM)
+			$(LD) $(LFLAGS) -o $(TST)/cod2txt \
+				$(TST)/cod2txt.o $(LIBGSM) $(LDLIB)
+
+$(TST)/cod2lin:		$(TST)/cod2lin.o $(LIBGSM)
+			$(LD) $(LFLAGS) -o $(TST)/cod2lin \
+				$(TST)/cod2lin.o $(LIBGSM) $(LDLIB)
+# Copyright 1992-1996 by Jutta Degener and Carsten Bormann, Technische
+# Universitaet Berlin.  See the accompanying file "COPYRIGHT" for
+# details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+
+# Machine- or installation dependent flags you should configure to port
+
+SASR	= -DSASR
+######### Define SASR if >> is a signed arithmetic shift (-1 >> 1 == -1)
+
 #MULHACK = -DUSE_FLOAT_MUL
 ######### Define this if your host multiplies floats faster than integers,
 ######### e.g. on a SPARCstation.

Modified: trunk/codecs/gsm_slin_ex.h
===================================================================
--- trunk/codecs/gsm_slin_ex.h	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/codecs/gsm_slin_ex.h	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,3 +1,19 @@
+/*
+  * 8-bit raw data
+  *
+  * Source: gsm.example
+  *
+  * Copyright (C) 1999, Mark Spencer and Linux Support Services
+  *
+  * Distributed under the terms of the GNU General Public License
+  *
+  */
+
+static unsigned char gsm_slin_ex[] = {
+0xda, 0xa6, 0xac, 0x2d, 0xa3, 0x50, 000, 0x49, 0x24, 0x92, 
+0x49, 0x24, 0x50, 0x40, 0x49, 0x24, 0x92, 0x37, 0x24, 0x52, 
+000, 0x49, 0x24, 0x92, 0x47, 0x24, 0x50, 0x80, 0x46, 0xe3, 
+0x6d, 0xb8, 0xdc };
 /*! \file
   * \brief 8-bit raw data
   *

Modified: trunk/configs/adtranvofr.conf.sample
===================================================================
--- trunk/configs/adtranvofr.conf.sample	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/configs/adtranvofr.conf.sample	2006-06-28 10:25:31 UTC (rev 421)
@@ -2,6 +2,43 @@
 ; Voice over Frame Relay (Adtran style)
 ;
 ; Configuration file
+;
+[interfaces]
+;
+; Lines for which we are the user termination.  They accept incoming
+; and outgoing calls.
+;
+;user=voice00
+;user=voice01
+;user=voice02
+;user=voice03
+;user=voice04
+;user=voice05
+;user=voice06
+;user=voice07
+context=default
+user=voice13
+user=voice14
+user=voice15
+; Calls on 16 and 17 come from the outside world, so they get
+; a little bit special treatment
+context=remote
+user=voice16
+user=voice17
+;
+; Next we have lines which we only accept calls on, and typically
+; do not send outgoing calls on (i.e. these are where we are the
+; network termination)
+;
+;network=voice08
+;network=voice09
+;network=voice10
+;network=voice11
+;network=voice12
+;
+; Voice over Frame Relay (Adtran style)
+;
+; Configuration file
 
 [interfaces]
 ;

Modified: trunk/configs/extensions.conf.sample
===================================================================
--- trunk/configs/extensions.conf.sample	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/configs/extensions.conf.sample	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,122 @@
 ;
+; Static extension configuration files, used by
+; the pbx_config module.
+;
+; The "General" category is for certain variables.  All other categories
+; are interpreted as extension contexts
+;
+[general]
+;
+; If static is set to no, or omitted, then the pbx_config will rewrite
+; this file when extensions are modified.  Remember that all comments
+; made in the file will be lost when that happens.
+;
+static=yes
+
+; Remote things always ring all phones first.
+[remote]
+exten=s,1,Dial,AdtranVoFR/4200&AdtranVoFR/4151&AdtranVoFR/4300|15
+exten=s,2,Goto,default|s|2
+
+; Local stuff
+[local]
+exten=s,1,Goto,defaults|s|2
+; Special extension for local phone numbers, long distance, etc, going
+; out via the Frame Relay interface.  Patterns are prefixed with "_", which
+; is ignored.
+exten=_9NXXXXXX,1,Dial,AdtranVoFR/BYEXTENSION
+exten=_91NXXNXXXXXX,1,Dial,AdtranVoFR/BYEXTENSION
+exten=_9911,1,Dial,AdtranVoFR/BYEXTENSION
+
+[default]
+exten=s,1,Wait,0
+exten=s,2,Answer
+exten=s,3,DigitTimeout,5
+exten=s,4,ResponseTimeout,10
+exten=s,5,BackGround,welcome
+exten=*,1,Directory,default
+exten=*,2,Goto,s|4
+exten=#,1,Playback,goodbye
+exten=#,2,Hangup
+exten=100,1,Goto,other|s|1
+exten=200,1,Intercom
+exten=400,1,MP3Player,song8.mp3
+exten=401,1,MP3Player,sample.mp3
+exten=402,1,MP3Player,sunscreen.mp3
+exten=403,1,MP3Player,http://trode.vergenet.net:8000
+exten=404,1,MP3Player,http://216.32.166.94:14900
+exten=405,1,Playback,sample
+;
+; Here's the template for a typical extension, carefully broken apart
+; for analysis.  The others are pretty much the same, but not as well
+; documented.
+;
+; Step 1:  Play back a "Please hold while I try that extension" message
+exten=4300,1,Playback,transfer
+; Step 2:  Dial the numbers where Ben is likely to be.  Try for no more
+;          than 15 seconds.
+exten=4300,2,Dial,AdtranVoFR/4300|15
+; Step 3:  If there is no answer, play back a message stating that Ben is
+;          unavailable.  Alternatively, we could have rung an operator first.
+exten=4300,3,Playback,vm/4300/unavail
+; Step 4:  Send them to voicemail.
+exten=4300,4,Voicemail,4300
+; Step 5:  If they return from voicemail, go back to the top
+exten=4300,5,Goto,s|4
+; Step 103: If the Dialing is busy, it will try here first.  We'll play a
+;           special "I'm busy" message...
+exten=4300,103,Playback,vm/4300/busy
+; Step 104: And then continue as if it had been busy in the first place.
+exten=4300,104,Goto,4
+; Exten. 4301: Provide a short-circuit so we can transfer striaght to 
+;              voicemail.
+exten=4301,1,Goto,4300|3
+; Exten. 4302: Provide a way to ring a given phone indefinitely
+exten=4302,1,Dial,AdtranVoFR/4300
+
+exten=4200,1,Playback,transfer
+exten=4200,2,Dial,AdtranVoFR/4200|15
+exten=4200,3,Playback,vm/4200/unavail
+exten=4200,4,Voicemail,4200
+exten=4200,5,Goto,s|4
+exten=4200,103,Playback,vm/4200/busy
+exten=4200,104,Goto,4
+exten=4201,1,Goto,4200|3
+exten=4202,1,Dial,AdtranVoFR/4200
+
+exten=4230,1,Dial,PhoneJack/ixj0
+
+exten=4110,1,Playback,transfer
+;exten=4110,2,Dial,AdtranVoFR/4110|15
+exten=4110,2,Wait,5
+exten=4110,3,Playback,vm/4110/unavail
+exten=4110,4,Voicemail,4110
+exten=4110,5,Goto,s|4
+exten=4110,103,Playback,vm/4110/busy
+exten=4110,104,Goto,4
+exten=4111,1,Goto,4110|3
+exten=4112,1,Dial,AdtranVoFR/4110
+exten=4113,1,Voicemail,s4110
+
+exten=8500,1,VoicemailMain
+exten=8500,2,Goto,s|4
+exten=762,1,Playback,somepeople
+exten=762,2,Wait,4
+exten=762,3,Goto,s|4
+
+; Timeout stuff...  We could send to an operator, or just ditch them.
+exten=t,1,Goto,#|1
+exten=i,1,BackGround,invalid
+
+[other]
+exten=s,1,Playback,digits/9
+exten=s,2,Playback,digits/8
+exten=s,3,Playback,digits/7
+exten=s,4,Goto,100|1
+exten=100,1,Playback,digits/6
+exten=100,2,Playback,digits/5
+exten=100,3,Goto,default|s|4
+;
 ; Static extension configuration file, used by
 ; the pbx_config module. This is where you configure all your 
 ; inbound and outbound calls in Asterisk. 

Modified: trunk/configs/modules.conf.sample
===================================================================
--- trunk/configs/modules.conf.sample	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/configs/modules.conf.sample	2006-06-28 10:25:31 UTC (rev 421)
@@ -3,7 +3,21 @@
 ;
 ; Module Loader configuration file
 ;
+[modules]
+autoload=yes
+;load=pbx_gtkconsole.so
+noload=pbx_gtkconsole.so
+noload=pbx_kdeconsole.so
+noload=app_intercom.so
+;load=chan_vofr.so
+;load=chan_h323.so 
 
+;
+; Asterisk configuration file
+;
+; Module Loader configuration file
+;
+
 [modules]
 autoload=yes
 ;

Modified: trunk/configs/voicemail.conf.sample
===================================================================
--- trunk/configs/voicemail.conf.sample	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/configs/voicemail.conf.sample	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,8 +1,22 @@
 ;
 ; Voicemail Configuration
 ;
+[general]
+; Default format for writing Voicemail
+; format=g723sf|rawgsm|mp3|wav
+format=g723sf|wav
 
+[default]
+4200=2345,Mark Spencer,markster at linux-support.net
+4300=2345,Ben Rigas,ben at american-computer.net
+4310=2345,Sales,sales at marko.net
+4069=2345,Matt Brooks,matt at marko.net
+4110=1379,Rob Flynn,rflynn at blueridge.net
 ;
+; Voicemail Configuration
+;
+
+;
 ; NOTE: Asterisk has to edit this file to change a user's password.  This does
 ; note currently work with the "#include <file>" directive for Asterisk
 ; configuration files.  Do not use it with this configuration file.

Modified: trunk/file.c
===================================================================
--- trunk/file.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/file.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,494 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Generic File Format Support.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/frame.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/channel.h>
+#include <asterisk/sched.h>
+#include <asterisk/options.h>
+#include <asterisk/translate.h>
+#include <errno.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <stdio.h>
+#include <fcntl.h>
+#include <dirent.h>
+#include <sys/stat.h>
+#include "asterisk.h"
+
+struct ast_format {
+	/* Name of format */
+	char name[80];
+	/* Extensions (separated by | if more than one) 
+	   this format can read.  First is assumed for writing (e.g. .mp3) */
+	char exts[80];
+	/* Format of frames it uses/provides (one only) */
+	int format;
+	/* Open an input stream, and start playback */
+	struct ast_filestream * (*open)(int fd);
+	/* Open an output stream, of a given file descriptor and comment it appropriately if applicable */
+	struct ast_filestream * (*rewrite)(int fd, char *comment);
+	/* Apply a reading filestream to a channel */
+	int (*apply)(struct ast_channel *, struct ast_filestream *);
+	/* Write a frame to a channel */
+	int (*write)(struct ast_filestream *, struct ast_frame *);
+	/* Read the next frame from the filestream (if available) */
+	struct ast_frame * (*read)(struct ast_filestream *);
+	/* Close file, and destroy filestream structure */
+	void (*close)(struct ast_filestream *);
+	/* Retrieve file comment */
+	char * (*getcomment)(struct ast_filestream *);
+	/* Link */
+	struct ast_format *next;
+};
+
+struct ast_filestream {
+	/* Everybody reserves a block of AST_RESERVED_POINTERS pointers for us */
+	struct ast_format *fmt;
+	/* Transparently translate from another format -- just once */
+	struct ast_trans_pvt *trans;
+	struct ast_tranlator_pvt *tr;
+};
+
+static pthread_mutex_t formatlock = PTHREAD_MUTEX_INITIALIZER;
+
+static struct ast_format *formats = NULL;
+
+int ast_format_register(char *name, char *exts, int format,
+						struct ast_filestream * (*open)(int fd),
+						struct ast_filestream * (*rewrite)(int fd, char *comment),
+						int (*apply)(struct ast_channel *, struct ast_filestream *),
+						int (*write)(struct ast_filestream *, struct ast_frame *),
+						struct ast_frame * (*read)(struct ast_filestream *),
+						void (*close)(struct ast_filestream *),
+						char * (*getcomment)(struct ast_filestream *))
+{
+	struct ast_format *tmp;
+	if (pthread_mutex_lock(&formatlock)) {
+		ast_log(LOG_WARNING, "Unable to lock format list\n");
+		return -1;
+	}
+	tmp = formats;
+	while(tmp) {
+		if (!strcasecmp(name, tmp->name)) {
+			pthread_mutex_unlock(&formatlock);
+			ast_log(LOG_WARNING, "Tried to register '%s' format, already registered\n", name);
+			return -1;
+		}
+		tmp = tmp->next;
+	}
+	tmp = malloc(sizeof(struct ast_format));
+	if (!tmp) {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		pthread_mutex_unlock(&formatlock);
+		return -1;
+	}
+	strncpy(tmp->name, name, sizeof(tmp->name));
+	strncpy(tmp->exts, exts, sizeof(tmp->exts));
+	tmp->open = open;
+	tmp->rewrite = rewrite;
+	tmp->apply = apply;
+	tmp->read = read;
+	tmp->write = write;
+	tmp->close = close;
+	tmp->format = format;
+	tmp->getcomment = getcomment;
+	tmp->next = formats;
+	formats = tmp;
+	pthread_mutex_unlock(&formatlock);
+	if (option_verbose > 1)
+		ast_verbose( VERBOSE_PREFIX_2 "Registered file format %s, extension(s) %s\n", name, exts);
+	return 0;
+}
+
+int ast_format_unregister(char *name)
+{
+	struct ast_format *tmp, *tmpl = NULL;
+	if (pthread_mutex_lock(&formatlock)) {
+		ast_log(LOG_WARNING, "Unable to lock format list\n");
+		return -1;
+	}
+	tmp = formats;
+	while(tmp) {
+		if (!strcasecmp(name, tmp->name)) {
+			if (tmpl) 
+				tmpl->next = tmp->next;
+			else
+				formats = tmp->next;
+			free(tmp);
+			pthread_mutex_unlock(&formatlock);
+			if (option_verbose > 1)
+				ast_verbose( VERBOSE_PREFIX_2 "Unregistered format %s\n", name);
+			return 0;
+		}
+		tmp = tmp->next;
+	}
+	ast_log(LOG_WARNING, "Tried to unregister format %s, already unregistered\n", name);
+	return -1;
+}
+
+int ast_stopstream(struct ast_channel *tmp)
+{
+	if (tmp->trans)
+		tmp = tmp->trans;
+	/* Stop a running stream if there is one */
+	if (!tmp->stream) 
+		return 0;
+	tmp->stream->fmt->close(tmp->stream);
+	if (tmp->master) {
+		ast_translator_destroy(tmp);
+	}
+	return 0;
+}
+
+int ast_closestream(struct ast_filestream *f)
+{
+	if (f->trans) {
+		ast_translator_free_path(f->trans);
+	}
+	/* Stop a running stream if there is one */
+	f->fmt->close(f);
+	return 0;
+}
+
+int ast_writestream(struct ast_filestream *fs, struct ast_frame *f)
+{
+	struct ast_frame_chain *fc, *f2;
+	int res = -1;
+	int count=0;
+	if (f->frametype != AST_FRAME_VOICE) {
+		ast_log(LOG_WARNING, "Tried to write non-voice frame\n");
+		return -1;
+	}
+	if ((fs->fmt->format & f->subclass) == f->subclass)
+		return fs->fmt->write(fs, f);
+	else {
+		/* XXX If they try to send us a type of frame that isn't the normal frame, and isn't
+		       the one we've setup a translator for, we do the "wrong thing" XXX */
+		if (!fs->trans) 
+			fs->trans = ast_translator_build_path(f->subclass, fs->fmt->format);
+		if (!fs->trans)
+			ast_log(LOG_WARNING, "Unable to translate to format %s, source format %d\n", fs->fmt->name, f->subclass);
+		else {
+			/* Build a chain of translated frames */
+			fc = ast_translate(fs->trans, f);
+			f2 = fc;
+			while(f2) {
+				res = fs->fmt->write(fs, f2->fr);
+				if (res) {
+					ast_log(LOG_WARNING, "Frame write failed\n");
+					break;
+				}
+				f2 = f2->next;
+				count++;
+				if (count > 1) 
+					ast_log(LOG_DEBUG, "Count is %d\n", count);
+			}
+			if (fc)
+				ast_frchain(fc);
+		}
+		return res;
+	}
+}
+
+static char *build_filename(char *filename, char *ext)
+{
+	char *fn;
+	fn = malloc(strlen(AST_SOUNDS) + strlen(filename) + strlen(ext) + 10);
+	if (fn) {
+		if (filename[0] == '/') 
+			sprintf(fn, "%s.%s", filename, ext);
+		else
+			sprintf(fn, "%s/%s.%s", AST_SOUNDS, filename, ext);
+	}
+	return fn;
+	
+}
+
+#define ACTION_EXISTS 1
+#define ACTION_DELETE 2
+#define ACTION_RENAME 3
+#define ACTION_OPEN   4
+
+static int ast_filehelper(char *filename, char *filename2, char *fmt, int action)
+{
+	struct stat st;
+	struct ast_format *f;
+	struct ast_filestream *s;
+	int res=0, ret = 0;
+	char *ext=NULL, *exts, *fn, *nfn;
+	struct ast_channel *trans = (struct ast_channel *)filename2;
+	
+	/* Start with negative response */
+	if (action == ACTION_EXISTS)
+		res = 0;
+	else
+		res = -1;
+	if (action == ACTION_OPEN)
+		ret = -1;
+	/* Check for a specific format */
+	if (pthread_mutex_lock(&formatlock)) {
+		ast_log(LOG_WARNING, "Unable to lock format list\n");
+		if (action == ACTION_EXISTS)
+			return 0;
+		else
+			return -1;
+	}
+	f = formats;
+	while(f) {
+		if (!fmt || !strcasecmp(f->name, fmt)) {
+			exts = strdup(f->exts);
+			/* Try each kind of extension */
+			ext = strtok(exts, "|");
+			do {
+				fn = build_filename(filename, ext);
+				if (fn) {
+					res = stat(fn, &st);
+					if (!res) {
+						switch(action) {
+						case ACTION_EXISTS:
+							ret |= f->format;
+							break;
+						case ACTION_DELETE:
+							res = unlink(fn);
+							if (res)
+								ast_log(LOG_WARNING, "unlink(%s) failed: %s\n", fn, strerror(errno));
+							break;
+						case ACTION_RENAME:
+							nfn = build_filename(filename2, ext);
+							if (nfn) {
+								res = rename(fn, nfn);
+								if (res)
+									ast_log(LOG_WARNING, "rename(%s,%s) failed: %s\n", fn, nfn, strerror(errno));
+								free(nfn);
+							} else
+								ast_log(LOG_WARNING, "Out of memory\n");
+							break;
+						case ACTION_OPEN:
+							if ((ret < 0) && ((trans->format & f->format) /* == trans->format */)) {
+								ret = open(fn, O_RDONLY);
+								if (ret >= 0) {
+									s = f->open(ret);
+									if (s) {
+										s->fmt = f;
+										s->trans = NULL;
+										trans->stream = s;
+										if (f->apply(trans, s)) {
+											f->close(s);
+											trans->stream = NULL;
+											ast_log(LOG_WARNING, "Unable to apply stream to channel %s\n", trans->name);
+											close(ret);
+											ret = 0;
+										}
+									} else {
+										close(ret);
+										ast_log(LOG_WARNING, "Unable to open fd on %s\n", filename);
+									}
+								} else
+									ast_log(LOG_WARNING, "Couldn't open file %s\n", fn);
+							}
+							break;
+						default:
+							ast_log(LOG_WARNING, "Unknown helper %d\n", action);
+						}
+						/* Conveniently this logic is the same for all */
+						if (res)
+							break;
+					}
+					free(fn);
+				}
+				ext = strtok(NULL, "|");
+			} while(ext);
+			free(exts);
+		}
+		f = f->next;
+	}
+	pthread_mutex_unlock(&formatlock);
+	if ((action == ACTION_EXISTS) || (action == ACTION_OPEN))
+		res = ret ? ret : -1;
+	return res;
+}
+
+int ast_fileexists(char *filename, char *fmt)
+{
+	return ast_filehelper(filename, NULL, fmt, ACTION_EXISTS);
+}
+
+int ast_filedelete(char *filename, char *fmt)
+{
+	return ast_filehelper(filename, NULL, fmt, ACTION_DELETE);
+}
+
+int ast_filerename(char *filename, char *filename2, char *fmt)
+{
+	return ast_filehelper(filename, filename2, fmt, ACTION_RENAME);
+}
+
+int ast_streamfile(struct ast_channel *chan, char *filename)
+{
+	/* This is a fairly complex routine.  Essentially we should do 
+	   the following:
+	   
+	   1) Find which file handlers produce our type of format.
+	   2) Look for a filename which it can handle.
+	   3) If we find one, then great.  
+	   *4) If not, see what files are there
+	   *5) See what we can actually support
+	   *6) Choose the one with the least costly translator path and
+	       set it up.
+		   
+		XXX * = unimplemented XXX
+	*/
+	int fd = -1;
+	struct ast_channel *trans;
+	int fmts;
+	ast_stopstream(chan);
+	fmts = ast_fileexists(filename, NULL);
+	if (fmts < 1) {
+		ast_log(LOG_WARNING, "File %s does not exist in any format\n", filename);
+		return -1;
+	}
+	if (fmts & chan->format) {
+		/* No translation necessary -- we have a file in a format our channel can 
+		   handle */
+		trans = chan;
+	} else {
+		/* Find the best */
+		fmts = ast_translator_best_choice(chan->format, fmts);
+		if (fmts < 1) {
+			ast_log(LOG_WARNING, "Unable to find a translator method\n");
+			return -1;
+		}
+		trans = ast_translator_create(chan, fmts, AST_DIRECTION_OUT);
+		if (!trans) {
+			ast_log(LOG_WARNING, "Unable to create translator\n");
+			return -1;
+		}
+	}
+ 	fd = ast_filehelper(filename, (char *)trans, NULL, ACTION_OPEN);
+	if (fd >= 0) {
+#if 0
+		ast_verbose(VERBOSE_PREFIX_3 "Playing '%s'\n", filename);
+#endif
+		return 0;
+	}
+	ast_log(LOG_WARNING, "Unable to open %s (format %d): %s\n", filename, chan->format, strerror(errno));
+	if (chan != trans)
+		ast_translator_destroy(trans);	
+	return -1;
+}
+
+
+struct ast_filestream *ast_writefile(char *filename, char *type, char *comment, int flags, int check, mode_t mode)
+{
+	int fd;
+	struct ast_format *f;
+	struct ast_filestream *fs=NULL;
+	char *fn;
+	char *ext;
+	if (pthread_mutex_lock(&formatlock)) {
+		ast_log(LOG_WARNING, "Unable to lock format list\n");
+		return NULL;
+	}
+	f = formats;
+	while(f) {
+		if (!strcasecmp(f->name, type)) {
+			/* XXX Implement check XXX */
+			ext = strdup(f->exts);
+			ext = strtok(ext, "|");
+			fn = build_filename(filename, ext);
+			fd = open(fn, flags | O_WRONLY | O_CREAT, mode);
+			if (fd >= 0) {
+				errno = 0;
+				if ((fs = f->rewrite(fd, comment))) {
+					fs->trans = NULL;
+					fs->fmt = f;
+				} else {
+					ast_log(LOG_WARNING, "Unable to rewrite %s\n", fn);
+					close(fd);
+					unlink(fn);
+				}
+			} else if (errno != EEXIST)
+				ast_log(LOG_WARNING, "Unable to open file %s: %s\n", fn, strerror(errno));
+			free(fn);
+			free(ext);
+			break;
+		}
+		f = f->next;
+	}
+	pthread_mutex_unlock(&formatlock);
+	if (!f) 
+		ast_log(LOG_WARNING, "No such format '%s'\n", type);
+	return fs;
+}
+
+char ast_waitstream(struct ast_channel *c, char *breakon)
+{
+	int res;
+	struct ast_frame *fr;
+	if (c->trans)
+		c=c->trans;
+	while(c->stream) {
+		res = ast_sched_wait(c->sched);
+		if (res < 0) {
+			/* Okay, stop :) */
+			return 0;
+		}
+		res = ast_waitfor(c, res);
+		if (res < 0) {
+			ast_log(LOG_WARNING, "Select failed (%s)\n", strerror(errno));
+			return res;
+		} else
+		if (res > 0) {
+			fr = ast_read(c);
+			if (!fr) {
+#if 0
+				ast_log(LOG_DEBUG, "Got hung up\n");
+#endif
+				return -1;
+			}
+			
+			switch(fr->frametype) {
+			case AST_FRAME_DTMF:
+				res = fr->subclass;
+				ast_frfree(fr);
+				if (strchr(breakon, res))
+					return res;
+				break;
+			case AST_FRAME_CONTROL:
+				switch(fr->subclass) {
+				case AST_CONTROL_HANGUP:
+					ast_frfree(fr);
+					return -1;
+				default:
+					ast_log(LOG_WARNING, "Unexpected control subclass '%d'\n", fr->subclass);
+				}
+			default:
+				/* Ignore */
+				ast_frfree(fr);
+			}
+		} else
+			ast_sched_runq(c->sched);
+	
+		
+	}
+	return 0;
+}
+
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/formats/format_g723.c
===================================================================
--- trunk/formats/format_g723.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/formats/format_g723.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,346 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Old-style G.723 frame/timestamp format.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include <asterisk/channel.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/sched.h>
+#include <asterisk/module.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+#include <sys/time.h>
+#include "../channels/adtranvofr.h"
+
+
+#define G723_MAX_SIZE 1024
+
+struct ast_filestream {
+	/* First entry MUST be reserved for the channel type */
+	void *reserved[AST_RESERVED_POINTERS];
+	/* This is what a filestream means to us */
+	int fd; /* Descriptor */
+	u_int32_t lasttimeout;	/* Last amount of timeout */
+	struct ast_channel *owner;
+	struct ast_filestream *next;
+	struct ast_frame *fr;	/* Frame representation of buf */
+	struct timeval orig;	/* Original frame time */
+	char buf[G723_MAX_SIZE + AST_FRIENDLY_OFFSET];	/* Buffer for sending frames, etc */
+};
+
+
+static struct ast_filestream *glist = NULL;
+static pthread_mutex_t g723_lock = PTHREAD_MUTEX_INITIALIZER;
+static int glistcnt = 0;
+
+static char *name = "g723sf";
+static char *desc = "G.723.1 Simple Timestamp File Format";
+static char *exts = "g723";
+
+static struct ast_filestream *g723_open(int fd)
+{
+	/* We don't have any header to read or anything really, but
+	   if we did, it would go here.  We also might want to check
+	   and be sure it's a valid file.  */
+	struct ast_filestream *tmp;
+	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
+		if (pthread_mutex_lock(&g723_lock)) {
+			ast_log(LOG_WARNING, "Unable to lock g723 list\n");
+			free(tmp);
+			return NULL;
+		}
+		tmp->next = glist;
+		glist = tmp;
+		tmp->fd = fd;
+		tmp->owner = NULL;
+		tmp->fr = (struct ast_frame *)tmp->buf;
+		tmp->fr->data = tmp->buf + sizeof(struct ast_frame);
+		tmp->fr->frametype = AST_FRAME_VOICE;
+		tmp->fr->subclass = AST_FORMAT_G723_1;
+		/* datalen will vary for each frame */
+		tmp->fr->src = name;
+		tmp->fr->mallocd = 0;
+		tmp->lasttimeout = -1;
+		tmp->orig.tv_usec = 0;
+		tmp->orig.tv_sec = 0;
+		glistcnt++;
+		pthread_mutex_unlock(&g723_lock);
+		ast_update_use_count();
+	}
+	return tmp;
+}
+
+static struct ast_filestream *g723_rewrite(int fd, char *comment)
+{
+	/* We don't have any header to read or anything really, but
+	   if we did, it would go here.  We also might want to check
+	   and be sure it's a valid file.  */
+	struct ast_filestream *tmp;
+	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
+		if (pthread_mutex_lock(&g723_lock)) {
+			ast_log(LOG_WARNING, "Unable to lock g723 list\n");
+			free(tmp);
+			return NULL;
+		}
+		tmp->next = glist;
+		glist = tmp;
+		tmp->fd = fd;
+		tmp->owner = NULL;
+		tmp->fr = NULL;
+		tmp->lasttimeout = -1;
+		glistcnt++;
+		pthread_mutex_unlock(&g723_lock);
+		ast_update_use_count();
+	} else
+		ast_log(LOG_WARNING, "Out of memory\n");
+	return tmp;
+}
+
+static struct ast_frame *g723_read(struct ast_filestream *s)
+{
+	return NULL;
+}
+
+static void g723_close(struct ast_filestream *s)
+{
+	struct ast_filestream *tmp, *tmpl = NULL;
+	if (pthread_mutex_lock(&g723_lock)) {
+		ast_log(LOG_WARNING, "Unable to lock g723 list\n");
+		return;
+	}
+	tmp = glist;
+	while(tmp) {
+		if (tmp == s) {
+			if (tmpl)
+				tmpl->next = tmp->next;
+			else
+				glist = tmp->next;
+			break;
+		}
+		tmpl = tmp;
+		tmp = tmp->next;
+	}
+	glistcnt--;
+	if (s->owner) {
+		s->owner->stream = NULL;
+		if (s->owner->streamid > -1)
+			ast_sched_del(s->owner->sched, s->owner->streamid);
+		s->owner->streamid = -1;
+	}
+	pthread_mutex_unlock(&g723_lock);
+	ast_update_use_count();
+	if (!tmp) 
+		ast_log(LOG_WARNING, "Freeing a filestream we don't seem to own\n");
+	close(s->fd);
+	free(s);
+}
+
+static int ast_read_callback(void *data)
+{
+	u_int16_t size;
+	u_int32_t delay = -1;
+	int looper = 1;
+	int retval = 0;
+	int res;
+	struct ast_filestream *s = data;
+	/* Send a frame from the file to the appropriate channel */
+	while(looper) {
+		if (read(s->fd, &size, 2) != 2) {
+			/* Out of data, or the file is no longer valid.  In any case
+			   go ahead and stop the stream */
+			s->owner->streamid = -1;
+			return 0;
+		}
+		/* Looks like we have a frame to read from here */
+		size = ntohs(size);
+		if (size > G723_MAX_SIZE - sizeof(struct ast_frame)) {
+			ast_log(LOG_WARNING, "Size %d is invalid\n", size);
+			/* The file is apparently no longer any good, as we
+			   shouldn't ever get frames even close to this 
+			   size.  */
+			s->owner->streamid = -1;
+			return 0;
+		}
+		/* Read the data into the buffer */
+		s->fr->offset = AST_FRIENDLY_OFFSET;
+		s->fr->datalen = size;
+		s->fr->data = s->buf + sizeof(struct ast_frame) + AST_FRIENDLY_OFFSET;
+		if ((res = read(s->fd, s->fr->data , size)) != size) {
+			ast_log(LOG_WARNING, "Short read (%d of %d bytes) (%s)!\n", res, size, strerror(errno));
+			s->owner->streamid = -1;
+			return 0;
+		}
+		/* Read the delay for the next packet, and schedule again if necessary */
+		if (read(s->fd, &delay, 4) == 4) 
+			delay = ntohl(delay);
+		else
+			delay = -1;
+		/* Average out frames <= 40 ms */
+		if (delay < 41)
+			s->fr->timelen = 30;
+		else
+			s->fr->timelen = delay;
+		/* Unless there is no delay, we're going to exit out as soon as we
+		   have processed the current frame. */
+		if (delay > VOFR_FUDGE) {
+			looper = 0;
+			/* If there is a delay, lets schedule the next event */
+			if (delay != s->lasttimeout) {
+				/* We'll install the next timeout now. */
+				s->owner->streamid = ast_sched_add(s->owner->sched, 
+													  delay - VOFR_FUDGE, 
+													  ast_read_callback, s);
+				
+				s->lasttimeout = delay;
+			} else
+				/* Just come back again at the same time */
+				retval = -1;
+		}
+		/* Lastly, process the frame */
+		if (ast_write(s->owner, s->fr)) {
+			ast_log(LOG_WARNING, "Failed to write frame\n");
+			s->owner->streamid = -1;
+			return 0;
+		}
+	}
+	return retval;
+}
+
+static int g723_apply(struct ast_channel *c, struct ast_filestream *s)
+{
+	u_int32_t delay;
+	/* Select our owner for this stream, and get the ball rolling. */
+	s->owner = c;
+	/* Read and ignore the first delay */
+	if (read(s->fd, &delay, 4) != 4) {
+		ast_log(LOG_WARNING, "Bad stream?\n");
+		return -1;
+	}
+	ast_read_callback(s);
+	return 0;
+}
+
+static int g723_write(struct ast_filestream *fs, struct ast_frame *f)
+{
+	struct timeval now;
+	u_int32_t delay;
+	u_int16_t size;
+	int res;
+	if (fs->fr) {
+		ast_log(LOG_WARNING, "Asked to write on a read stream??\n");
+		return -1;
+	}
+	if (f->frametype != AST_FRAME_VOICE) {
+		ast_log(LOG_WARNING, "Asked to write non-voice frame!\n");
+		return -1;
+	}
+	if (f->subclass != AST_FORMAT_G723_1) {
+		ast_log(LOG_WARNING, "Asked to write non-g723 frame!\n");
+		return -1;
+	}
+	if (!(fs->orig.tv_usec || fs->orig.tv_sec)) {
+		/* First frame should have zeros for delay */
+		delay = 0;
+		if (gettimeofday(&fs->orig, NULL)) {
+			ast_log(LOG_WARNING, "gettimeofday() failed??  What is this?  Y2k?\n");
+			return -1;
+		}
+	} else {
+		if (gettimeofday(&now, NULL)) {
+			ast_log(LOG_WARNING, "gettimeofday() failed??  What is this?  Y2k?\n");
+			return -1;
+		}
+		delay = (now.tv_sec - fs->orig.tv_sec) * 1000 + (now.tv_usec - fs->orig.tv_usec) / 1000;
+		delay = htonl(delay);
+		fs->orig.tv_sec = now.tv_sec;
+		fs->orig.tv_usec = now.tv_usec;
+	}
+	if ((res = write(fs->fd, &delay, 4)) != 4) {
+		ast_log(LOG_WARNING, "Unable to write delay: res=%d (%s)\n", res, strerror(errno));
+		return -1;
+	}
+	size = htons(f->datalen);
+	if ((res =write(fs->fd, &size, 2)) != 2) {
+		ast_log(LOG_WARNING, "Unable to write size: res=%d (%s)\n", res, strerror(errno));
+		return -1;
+	}
+	if ((res = write(fs->fd, f->data, f->datalen)) != f->datalen) {
+		ast_log(LOG_WARNING, "Unable to write frame: res=%d (%s)\n", res, strerror(errno));
+		return -1;
+	}	
+	return 0;
+}
+
+char *g723_getcomment(struct ast_filestream *s)
+{
+	return NULL;
+}
+
+int load_module()
+{
+	return ast_format_register(name, exts, AST_FORMAT_G723_1,
+								g723_open,
+								g723_rewrite,
+								g723_apply,
+								g723_write,
+								g723_read,
+								g723_close,
+								g723_getcomment);
+								
+								
+}
+
+int unload_module()
+{
+	struct ast_filestream *tmp, *tmpl;
+	if (pthread_mutex_lock(&g723_lock)) {
+		ast_log(LOG_WARNING, "Unable to lock g723 list\n");
+		return -1;
+	}
+	tmp = glist;
+	while(tmp) {
+		if (tmp->owner)
+			ast_softhangup(tmp->owner);
+		tmpl = tmp;
+		tmp = tmp->next;
+		free(tmpl);
+	}
+	pthread_mutex_unlock(&g723_lock);
+	return ast_format_unregister(name);
+}	
+
+int usecount()
+{
+	int res;
+	if (pthread_mutex_lock(&g723_lock)) {
+		ast_log(LOG_WARNING, "Unable to lock g723 list\n");
+		return -1;
+	}
+	res = glistcnt;
+	pthread_mutex_unlock(&g723_lock);
+	return res;
+}
+
+char *description()
+{
+	return desc;
+}
+
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/formats/format_wav.c
===================================================================
--- trunk/formats/format_wav.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/formats/format_wav.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,359 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Microsoft WAV File Format using libaudiofile 
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+ 
+#include <asterisk/channel.h>
+#include <asterisk/file.h>
+#include <asterisk/logger.h>
+#include <asterisk/sched.h>
+#include <asterisk/module.h>
+#include <arpa/inet.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <errno.h>
+#include <string.h>
+#include <pthread.h>
+#include <audiofile.h>
+
+
+/* Read 320 samples at a time, max */ 
+#define WAV_MAX_SIZE 320
+
+/* Fudge in milliseconds */
+#define WAV_FUDGE 2
+
+struct ast_filestream {
+	/* First entry MUST be reserved for the channel type */
+	void *reserved[AST_RESERVED_POINTERS];
+	/* This is what a filestream means to us */
+	int fd; /* Descriptor */
+	/* Audio File */
+	AFfilesetup afs;
+	AFfilehandle af;
+	int lasttimeout;
+	struct ast_channel *owner;
+	struct ast_filestream *next;
+	struct ast_frame fr;				/* Frame information */
+	char waste[AST_FRIENDLY_OFFSET];	/* Buffer for sending frames, etc */
+	short samples[WAV_MAX_SIZE];
+};
+
+
+static struct ast_filestream *glist = NULL;
+static pthread_mutex_t wav_lock = PTHREAD_MUTEX_INITIALIZER;
+static int glistcnt = 0;
+
+static char *name = "wav";
+static char *desc = "Microsoft WAV format (PCM/16, 8000Hz mono)";
+static char *exts = "wav";
+
+static struct ast_filestream *wav_open(int fd)
+{
+	/* We don't have any header to read or anything really, but
+	   if we did, it would go here.  We also might want to check
+	   and be sure it's a valid file.  */
+	struct ast_filestream *tmp;
+	int notok = 0;
+	int fmt, width;
+	double rate;
+	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
+		tmp->afs = afNewFileSetup();
+		if (!tmp->afs) {
+			ast_log(LOG_WARNING, "Unable to create file setup\n");
+			free(tmp);
+			return NULL;
+		}
+		afInitFileFormat(tmp->afs, AF_FILE_WAVE);
+		tmp->af = afOpenFD(fd, "r", tmp->afs);
+		if (!tmp->af) {
+			afFreeFileSetup(tmp->afs);
+			ast_log(LOG_WARNING, "Unable to open file descriptor\n");
+			free(tmp);
+			return NULL;
+		}
+#if 0
+		afGetFileFormat(tmp->af, &version);
+		if (version != AF_FILE_WAVE) {
+			ast_log(LOG_WARNING, "This is not a wave file (%d)\n", version);
+			notok++;
+		}
+#endif
+		/* Read the format and make sure it's exactly what we seek. */
+		if (afGetChannels(tmp->af, AF_DEFAULT_TRACK) != 1) {
+			ast_log(LOG_WARNING, "Invalid number of channels %d.  Should be mono (1)\n", afGetChannels(tmp->af, AF_DEFAULT_TRACK));
+			notok++;
+		}
+		afGetSampleFormat(tmp->af, AF_DEFAULT_TRACK, &fmt, &width);
+		if (fmt != AF_SAMPFMT_TWOSCOMP) {
+			ast_log(LOG_WARNING, "Input file is not signed\n");
+			notok++;
+		}
+		rate = afGetRate(tmp->af, AF_DEFAULT_TRACK);
+		if ((rate < 7900) || (rate > 8100)) {
+			ast_log(LOG_WARNING, "Rate %f is not close enough to 8000 Hz\n", rate);
+			notok++;
+		}
+		if (width != 16) {
+			ast_log(LOG_WARNING, "Input file is not 16-bit\n");
+			notok++;
+		}
+		if (notok) {
+			afCloseFile(tmp->af);
+			afFreeFileSetup(tmp->afs);
+			free(tmp);
+			return NULL;
+		}
+		if (pthread_mutex_lock(&wav_lock)) {
+			afCloseFile(tmp->af);
+			afFreeFileSetup(tmp->afs);
+			ast_log(LOG_WARNING, "Unable to lock wav list\n");
+			free(tmp);
+			return NULL;
+		}
+		tmp->next = glist;
+		glist = tmp;
+		tmp->fd = fd;
+		tmp->owner = NULL;
+		tmp->fr.data = tmp->samples;
+		tmp->fr.frametype = AST_FRAME_VOICE;
+		tmp->fr.subclass = AST_FORMAT_SLINEAR;
+		/* datalen will vary for each frame */
+		tmp->fr.src = name;
+		tmp->fr.mallocd = 0;
+		tmp->lasttimeout = -1;
+		glistcnt++;
+		pthread_mutex_unlock(&wav_lock);
+		ast_update_use_count();
+	}
+	return tmp;
+}
+
+static struct ast_filestream *wav_rewrite(int fd, char *comment)
+{
+	/* We don't have any header to read or anything really, but
+	   if we did, it would go here.  We also might want to check
+	   and be sure it's a valid file.  */
+	struct ast_filestream *tmp;
+	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
+		tmp->afs = afNewFileSetup();
+		if (!tmp->afs) {
+			ast_log(LOG_WARNING, "Unable to create file setup\n");
+			free(tmp);
+			return NULL;
+		}
+		/* WAV format */
+		afInitFileFormat(tmp->afs, AF_FILE_WAVE);
+		/* Mono */
+		afInitChannels(tmp->afs, AF_DEFAULT_TRACK, 1);
+		/* Signed linear, 16-bit */
+		afInitSampleFormat(tmp->afs, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 16);
+		/* 8000 Hz */
+		afInitRate(tmp->afs, AF_DEFAULT_TRACK, (double)8000.0);
+		tmp->af = afOpenFD(fd, "w", tmp->afs);
+		if (!tmp->af) {
+			afFreeFileSetup(tmp->afs);
+			ast_log(LOG_WARNING, "Unable to open file descriptor\n");
+			free(tmp);
+			return NULL;
+		}
+		if (pthread_mutex_lock(&wav_lock)) {
+			ast_log(LOG_WARNING, "Unable to lock wav list\n");
+			free(tmp);
+			return NULL;
+		}
+		tmp->next = glist;
+		glist = tmp;
+		tmp->fd = fd;
+		tmp->owner = NULL;
+		tmp->lasttimeout = -1;
+		glistcnt++;
+		pthread_mutex_unlock(&wav_lock);
+		ast_update_use_count();
+	} else
+		ast_log(LOG_WARNING, "Out of memory\n");
+	return tmp;
+}
+
+static struct ast_frame *wav_read(struct ast_filestream *s)
+{
+	return NULL;
+}
+
+static void wav_close(struct ast_filestream *s)
+{
+	struct ast_filestream *tmp, *tmpl = NULL;
+	if (pthread_mutex_lock(&wav_lock)) {
+		ast_log(LOG_WARNING, "Unable to lock wav list\n");
+		return;
+	}
+	tmp = glist;
+	while(tmp) {
+		if (tmp == s) {
+			if (tmpl)
+				tmpl->next = tmp->next;
+			else
+				glist = tmp->next;
+			break;
+		}
+		tmpl = tmp;
+		tmp = tmp->next;
+	}
+	glistcnt--;
+	if (s->owner) {
+		s->owner->stream = NULL;
+		if (s->owner->streamid > -1)
+			ast_sched_del(s->owner->sched, s->owner->streamid);
+		s->owner->streamid = -1;
+	}
+	pthread_mutex_unlock(&wav_lock);
+	ast_update_use_count();
+	if (!tmp) 
+		ast_log(LOG_WARNING, "Freeing a filestream we don't seem to own\n");
+	afCloseFile(tmp->af);
+	afFreeFileSetup(tmp->afs);
+	close(s->fd);
+	free(s);
+}
+
+static int ast_read_callback(void *data)
+{
+	u_int32_t delay = -1;
+	int retval = 0;
+	int res;
+	struct ast_filestream *s = data;
+	/* Send a frame from the file to the appropriate channel */
+
+	if ((res = afReadFrames(s->af, AF_DEFAULT_TRACK, s->samples, sizeof(s->samples)/2)) < 1) {
+		if (res)
+			ast_log(LOG_WARNING, "Short read (%d) (%s)!\n", res, strerror(errno));
+		s->owner->streamid = -1;
+		return 0;
+	}
+	/* Per 8 samples, one milisecond */
+	delay = res / 8;
+	s->fr.frametype = AST_FRAME_VOICE;
+	s->fr.subclass = AST_FORMAT_SLINEAR;
+	s->fr.offset = AST_FRIENDLY_OFFSET;
+	s->fr.datalen = res * 2;
+	s->fr.data = s->samples;
+	s->fr.mallocd = 0;
+	s->fr.timelen = delay;
+	/* Unless there is no delay, we're going to exit out as soon as we
+	   have processed the current frame. */
+	/* If there is a delay, lets schedule the next event */
+	if (delay != s->lasttimeout) {
+		/* We'll install the next timeout now. */
+		s->owner->streamid = ast_sched_add(s->owner->sched, 
+											  delay, 
+											  ast_read_callback, s);
+		
+		s->lasttimeout = delay;
+	} else {
+		/* Just come back again at the same time */
+		retval = -1;
+	}
+	/* Lastly, process the frame */
+	if (ast_write(s->owner, &s->fr)) {
+		ast_log(LOG_WARNING, "Failed to write frame\n");
+		s->owner->streamid = -1;
+		return 0;
+	}
+	
+	return retval;
+}
+
+static int wav_apply(struct ast_channel *c, struct ast_filestream *s)
+{
+	/* Select our owner for this stream, and get the ball rolling. */
+	s->owner = c;
+	ast_read_callback(s);
+	return 0;
+}
+
+static int wav_write(struct ast_filestream *fs, struct ast_frame *f)
+{
+	int res;
+	if (f->frametype != AST_FRAME_VOICE) {
+		ast_log(LOG_WARNING, "Asked to write non-voice frame!\n");
+		return -1;
+	}
+	if (f->subclass != AST_FORMAT_SLINEAR) {
+		ast_log(LOG_WARNING, "Asked to write non-signed linear frame (%d)!\n", f->subclass);
+		return -1;
+	}
+	if ((res = afWriteFrames(fs->af, AF_DEFAULT_TRACK, f->data, f->datalen/2)) != f->datalen/2) {
+		ast_log(LOG_WARNING, "Unable to write frame: res=%d (%s)\n", res, strerror(errno));
+		return -1;
+	}	
+	return 0;
+}
+
+char *wav_getcomment(struct ast_filestream *s)
+{
+	return NULL;
+}
+
+int load_module()
+{
+	return ast_format_register(name, exts, AST_FORMAT_SLINEAR,
+								wav_open,
+								wav_rewrite,
+								wav_apply,
+								wav_write,
+								wav_read,
+								wav_close,
+								wav_getcomment);								
+								
+								
+}
+
+int unload_module()
+{
+	struct ast_filestream *tmp, *tmpl;
+	if (pthread_mutex_lock(&wav_lock)) {
+		ast_log(LOG_WARNING, "Unable to lock wav list\n");
+		return -1;
+	}
+	tmp = glist;
+	while(tmp) {
+		if (tmp->owner)
+			ast_softhangup(tmp->owner);
+		tmpl = tmp;
+		tmp = tmp->next;
+		free(tmpl);
+	}
+	pthread_mutex_unlock(&wav_lock);
+	return ast_format_unregister(name);
+}	
+
+int usecount()
+{
+	int res;
+	if (pthread_mutex_lock(&wav_lock)) {
+		ast_log(LOG_WARNING, "Unable to lock wav list\n");
+		return -1;
+	}
+	res = glistcnt;
+	pthread_mutex_unlock(&wav_lock);
+	return res;
+}
+
+char *description()
+{
+	return desc;
+}
+
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/pbx.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,862 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Core PBX routines.
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <pthread.h>
+#include <asterisk/pbx.h>
+#include <asterisk/channel.h>
+#include <asterisk/options.h>
+#include <asterisk/logger.h>
+#include <asterisk/file.h>
+#include <string.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <stdio.h>
+#include <setjmp.h>
+#include <ctype.h>
+
+
+/*
+ * I M P O R T A N T :
+ *
+ *		The speed of extension handling will likely be among the most important
+ * aspects of this PBX.  The switching scheme as it exists right now isn't
+ * terribly bad (it's O(N+M), where N is the # of extensions and M is the avg #
+ * of priorities, but a constant search time here would be great ;-) 
+ *
+ */
+
+
+struct ast_context;
+
+struct ast_pbx {
+	int dtimeout;					/* Timeout between digits (seconds) */
+	int rtimeout;					/* Timeout for response (seconds) */
+};
+
+/* An extension */
+struct ast_exten {
+	char exten[AST_MAX_EXTENSION];
+	int priority;
+	/* An extension */
+	struct ast_context *parent;
+	/* Application to execute */
+	char app[AST_MAX_EXTENSION];
+	/* Data to use */
+	void *data;
+	/* Data destructor */
+	void (*datad)(void *);
+	/* Next highest priority with our extension */
+	struct ast_exten *peer;
+	/* Extension with a greater ID */
+	struct ast_exten *next;
+};
+
+/* An extension context */
+struct ast_context {
+	/* Name of the context */
+	char name[AST_MAX_EXTENSION];
+	/* A lock to prevent multiple threads from clobbering the context */
+	pthread_mutex_t lock;
+	/* The root of the list of extensions */
+	struct ast_exten *root;
+	/* Link them together */
+	struct ast_context *next;
+};
+
+
+/* An application */
+struct ast_app {
+	/* Name of the application */
+	char name[AST_MAX_APP];
+	int (*execute)(struct ast_channel *chan, void *data);
+	struct ast_app *next;
+};
+
+static int pbx_builtin_answer(struct ast_channel *, void *);
+static int pbx_builtin_goto(struct ast_channel *, void *);
+static int pbx_builtin_hangup(struct ast_channel *, void *);
+static int pbx_builtin_background(struct ast_channel *, void *);
+static int pbx_builtin_dtimeout(struct ast_channel *, void *);
+static int pbx_builtin_rtimeout(struct ast_channel *, void *);
+static int pbx_builtin_wait(struct ast_channel *, void *);
+
+static struct pbx_builtin {
+	char name[AST_MAX_APP];
+	int (*execute)(struct ast_channel *chan, void *data);
+} builtins[] = 
+{
+	/* These applications are built into the PBX core and do not
+	   need separate modules */
+	{ "Answer", pbx_builtin_answer },
+	{ "Goto", pbx_builtin_goto },
+	{ "Hangup", pbx_builtin_hangup },
+	{ "DigitTimeout", pbx_builtin_dtimeout },
+	{ "ResponseTimeout", pbx_builtin_rtimeout },
+	{ "BackGround", pbx_builtin_background },
+	{ "Wait", pbx_builtin_wait },
+};
+
+/* Lock for the application list */
+static pthread_mutex_t applock = PTHREAD_MUTEX_INITIALIZER;
+static struct ast_context *contexts = NULL;
+/* Lock for the ast_context list */
+static pthread_mutex_t conlock = PTHREAD_MUTEX_INITIALIZER;
+static struct ast_app *apps = NULL;
+
+static int pbx_exec(struct ast_channel *c, /* Channel */
+					int (*execute)(struct ast_channel *chan, void *data), 
+					void *data,				/* Data for execution */
+					int newstack)			/* Force stack increment */
+{
+	/* This function is special.  It saves the stack so that no matter
+	   how many times it is called, it returns to the same place */
+	int res;
+	int stack = c->stack;
+	if (newstack && stack > AST_CHANNEL_MAX_STACK - 2) {
+		/* Don't allow us to go over the max number of stacks we
+		   permit saving. */
+		ast_log(LOG_WARNING, "Stack overflow, cannot create another stack\n");
+		return -1;
+	}
+	if (newstack && (res = setjmp(c->jmp[++c->stack]))) {
+		/* Okay, here's where it gets weird.  If newstack is non-zero, 
+		   then we increase the stack increment, but setjmp is not going
+		   to return until longjmp is called -- when the application
+		   exec'd is finished running. */
+		if (res == 1)
+			res = 0;
+		if (c->stack != stack + 1) 
+			ast_log(LOG_WARNING, "Stack returned to an unexpected place!\n");
+		else if (c->app[c->stack])
+			ast_log(LOG_WARNING, "Application may have forgotten to free its memory\n");
+		c->stack = stack;
+		return res;
+	} else {
+		res = execute(c, data);
+		/* Any application that returns, we longjmp back, just in case. */
+		if (c->stack != stack + 1)
+			ast_log(LOG_WARNING, "Stack is not at expected value\n");
+		longjmp(c->jmp[stack+1], res);
+		/* Never returns */
+	}
+}
+
+
+#define HELPER_EXISTS 0
+#define HELPER_SPAWN 1
+#define HELPER_EXEC 2
+
+static struct ast_app *pbx_findapp(char *app) 
+{
+	struct ast_app *tmp;
+	if (pthread_mutex_lock(&applock)) {
+		ast_log(LOG_WARNING, "Unable to obtain application lock\n");
+		return NULL;
+	}
+	tmp = apps;
+	while(tmp) {
+		if (!strcasecmp(tmp->name, app))
+			break;
+		tmp = tmp->next;
+	}
+	pthread_mutex_unlock(&applock);
+	return tmp;
+}
+
+static void pbx_destroy(struct ast_pbx *p)
+{
+	free(p);
+}
+
+int extension_match(char *pattern, char *data)
+{
+	int match;
+	/* If they're the same return */
+	if (!strcasecmp(pattern, data))
+		return 1;
+	/* All patterns begin with _ */
+	if (pattern[0] != '_') 
+		return 0;
+	/* Obviously must be the same length */
+	if (strlen(pattern) != strlen(data) + 1)
+		return 0;
+	/* Start optimistic */
+	match=1;
+	pattern++;
+	while(match && *data && *pattern) {
+		switch(toupper(*pattern)) {
+		case 'N':
+			if ((*data < '2') || (*data > '9'))
+				match=0;
+			break;
+		case 'X':
+			if ((*data < '0') || (*data > '9'))
+				match = 0;
+			break;
+		default:
+			if (*data != *pattern)
+				match =0;
+		}
+		data++;
+		pattern++;
+	}
+	return match;
+}
+
+static int pbx_extension_helper(struct ast_channel *c, char *context, char *exten, int priority, int action) 
+{
+	struct ast_context *tmp;
+	struct ast_exten *e;
+	struct ast_app *app;
+	int newstack = 0;
+	if (pthread_mutex_lock(&conlock)) {
+		ast_log(LOG_WARNING, "Unable to obtain lock\n");
+		if (action == HELPER_EXISTS)
+			return 0;
+		else
+			return -1;
+	}
+	tmp = contexts;
+	while(tmp) {
+		if (!strcasecmp(tmp->name, context)) {
+			/* By locking tmp, not only can the state of its entries not
+			   change, but it cannot be destroyed either. */
+			pthread_mutex_lock(&tmp->lock);
+			/* But we can relieve the conlock, as tmp will not change */
+			pthread_mutex_unlock(&conlock);
+			e = tmp->root;
+			while(e) {
+				if (extension_match(e->exten, exten)) {
+					while(e) {
+						if (e->priority == priority) {
+							pthread_mutex_unlock(&tmp->lock);
+							/* We have a winner! Maybe there are some races
+							   in here though. XXX */
+							switch(action) {
+							case HELPER_EXISTS:
+								return -1;
+							case HELPER_SPAWN:
+								newstack++;
+								/* Fall through */
+							case HELPER_EXEC:
+								app = pbx_findapp(e->app);
+								if (app) {
+									strncpy(c->context, context, sizeof(c->context));
+									strncpy(c->exten, exten, sizeof(c->exten));
+									c->priority = priority;
+									if (option_debug)
+										ast_log(LOG_DEBUG, "Launching '%s'\n", app->name);
+									else if (option_verbose > 2)
+										ast_verbose( VERBOSE_PREFIX_3 "Executing %s(\"%s\", \"%s\") %s\n", 
+												app->name, c->name, (e->data ? (char *)e->data : NULL), (newstack ? "in new stack" : "in same stack"));
+									return pbx_exec(c, app->execute, e->data, newstack);
+								} else {
+									ast_log(LOG_WARNING, "No application '%s' for extension (%s, %s, %d)\n", e->app, context, exten, priority);
+									return -1;
+								}
+							default:
+								ast_log(LOG_WARNING, "Huh (%d)?\n", action);
+							}
+						}
+						e = e->peer;
+					}
+					pthread_mutex_unlock(&tmp->lock);
+					if (action != HELPER_EXISTS) {
+						ast_log(LOG_WARNING, "No such priority '%d' in '%s' in '%s'\n", priority, exten, context);
+						return -1;
+					} else
+						return 0;
+				}
+				e = e->next;
+			}
+			pthread_mutex_unlock(&tmp->lock);
+			if (action != HELPER_EXISTS) {
+				ast_log(LOG_WARNING, "No such extension '%s' in '%s'\n", exten, context);
+				return -1;
+			} else
+				return 0;
+		}
+		tmp = tmp->next;
+	}
+	pthread_mutex_unlock(&conlock);
+	if (action != HELPER_EXISTS) {
+		ast_log(LOG_WARNING, "No such context '%s'\n", context);
+		return -1;
+	} else
+		return 0;
+}
+int ast_pbx_longest_extension(char *context) 
+{
+	struct ast_context *tmp;
+	struct ast_exten *e;
+	int len = 0;
+	if (pthread_mutex_lock(&conlock)) {
+		ast_log(LOG_WARNING, "Unable to obtain lock\n");
+		return -1;
+	}
+	tmp = contexts;
+	while(tmp) {
+		if (!strcasecmp(tmp->name, context)) {
+			/* By locking tmp, not only can the state of its entries not
+			   change, but it cannot be destroyed either. */
+			pthread_mutex_lock(&tmp->lock);
+			/* But we can relieve the conlock, as tmp will not change */
+			pthread_mutex_unlock(&conlock);
+			e = tmp->root;
+			while(e) {
+				if (strlen(e->exten) > len)
+					len = strlen(e->exten);
+				e = e->next;
+			}
+			pthread_mutex_unlock(&tmp->lock);
+			return len;
+		}
+		tmp = tmp->next;
+	}
+	ast_log(LOG_WARNING, "No such context '%s'\n", context);
+	return -1;
+}
+
+int ast_exists_extension(struct ast_channel *c, char *context, char *exten, int priority) 
+{
+	return pbx_extension_helper(c, context, exten, priority, HELPER_EXISTS);
+}
+
+int ast_spawn_extension(struct ast_channel *c, char *context, char *exten, int priority) 
+{
+	return pbx_extension_helper(c, context, exten, priority, HELPER_SPAWN);
+}
+
+static void *pbx_thread(void *data)
+{
+	/* Oh joyeous kernel, we're a new thread, with nothing to do but
+	   answer this channel and get it going.  The setjmp stuff is fairly
+	   confusing, but necessary to get smooth transitions between
+	   the execution of different applications (without the use of
+	   additional threads) */
+	struct ast_channel *c = data;
+	int firstpass = 1;
+	char digit;
+	char exten[256];
+	int pos;
+	int waittime;
+	if (option_debug)
+		ast_log(LOG_DEBUG, "PBX_THREAD(%s)\n", c->name);
+	else if (option_verbose > 1)
+		ast_verbose( VERBOSE_PREFIX_2 "Accepting call on '%s'\n", c->name);
+		
+	
+	/* Start by trying whatever the channel is set to */
+	if (!ast_exists_extension(c, c->context, c->exten, c->priority)) {
+		strncpy(c->context, "default", sizeof(c->context));
+		strncpy(c->exten, "s", sizeof(c->exten));
+		c->priority = 1;
+	}
+	for(;;) {
+		memset(exten, 0, sizeof(exten));
+		pos = 0;
+		digit = 0;
+		while(ast_exists_extension(c, c->context, c->exten, c->priority)) {
+			if (ast_spawn_extension(c, c->context, c->exten, c->priority)) {
+				/* Something bad happened, or a hangup has been requested. */
+				if (option_debug)
+					ast_log(LOG_DEBUG, "Spawn extension (%s,%s,%d) exited non-zero on '%s'\n", c->context, c->exten, c->priority, c->name);
+				else if (option_verbose > 1)
+					ast_verbose( VERBOSE_PREFIX_2 "Spawn extension (%s, %s, %d) exited non-zero on '%s'\n", c->context, c->exten, c->priority, c->name);
+				goto out;
+			}
+			/* If we're playing something in the background, wait for it to finish or for a digit */
+			if (c->stream) {
+				digit = ast_waitstream(c, AST_DIGIT_ANY);
+				ast_stopstream(c);
+				/* Hang up if something goes wrong */
+				if (digit < 0)
+					goto out;
+				else if (digit) {
+					ast_stopstream(c);
+					exten[pos++] = digit;
+					break;
+				}
+			}
+			firstpass = 0;
+			c->priority++;
+		}
+		/* Done, wait for an extension */
+		if (digit)
+			waittime = c->pbx->dtimeout;
+		else
+			waittime = c->pbx->rtimeout;
+		while(!ast_exists_extension(c, c->context, exten, 1) && (
+		       strlen(exten) < ast_pbx_longest_extension(c->context))) {
+			/* As long as we're willing to wait, and as long as it's not defined, 
+			   keep reading digits until we can't possibly get a right answer anymore.  */
+			digit = ast_waitfordigit(c, waittime * 1000);
+			if (!digit)
+				/* No entry */
+				break;
+			if (digit < 0)
+				/* Error, maybe a  hangup */
+				goto out;
+			exten[pos++] = digit;
+			waittime = c->pbx->dtimeout;
+		}
+		if (ast_exists_extension(c, c->context, exten, 1)) {
+			/* Prepare the next cycle */
+			strncpy(c->exten, exten, sizeof(c->exten));
+			c->priority = 1;
+		} else {
+			/* No such extension */
+			if (strlen(exten)) {
+				/* An invalid extension */
+				if (ast_exists_extension(c, c->context, "i", 1)) {
+					if (option_verbose > 2)
+						ast_verbose( VERBOSE_PREFIX_3 "Invalid extension '%s' in context '%s' on %s\n", exten, c->context, c->name);
+					strncpy(c->exten, "i", sizeof(c->exten));
+					c->priority = 1;
+				} else {
+					ast_log(LOG_WARNING, "Invalid extension, but no rule 'i' in context '%s'\n", c->context);
+					goto out;
+				}
+			} else {
+				/* A simple timeout */
+				if (ast_exists_extension(c, c->context, "t", 1)) {
+					if (option_verbose > 2)
+						ast_verbose( VERBOSE_PREFIX_3 "Timeout on %s\n", c->name);
+					strncpy(c->exten, "t", sizeof(c->exten));
+					c->priority = 1;
+				} else {
+					ast_log(LOG_WARNING, "Timeout, but no rule 't' in context '%s'\n", c->context);
+					goto out;
+				}
+			}	
+		}
+	}
+	if (firstpass) 
+		ast_log(LOG_WARNING, "Don't know what to do with '%s'\n", c->name);
+out:
+	pbx_destroy(c->pbx);
+	c->pbx = NULL;
+	ast_hangup(c);
+	pthread_exit(NULL);
+	
+}
+
+int ast_pbx_start(struct ast_channel *c)
+{
+	pthread_t t;
+	if (!c) {
+		ast_log(LOG_WARNING, "Asked to start thread on NULL channel?\n");
+		return -1;
+	}
+	if (c->pbx)
+		ast_log(LOG_WARNING, "%s already has PBX structure??\n");
+	c->pbx = malloc(sizeof(struct ast_pbx));
+	if (!c->pbx) {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	memset(c->pbx, 0, sizeof(struct ast_pbx));
+	/* Start a new thread, and get something handling this channel. */
+	if (pthread_create(&t, NULL, pbx_thread, c)) {
+		ast_log(LOG_WARNING, "Failed to create new channel thread\n");
+		return -1;
+	}
+	return 0;
+}
+#if 0
+int ast_remove_extension(struct ast_context *con, char *extension, int priority)
+{
+	/* XXX Implement me XXX */
+	return -1;
+}
+#endif
+int ast_register_application(char *app, int (*execute)(struct ast_channel *, void *))
+{
+	struct ast_app *tmp;
+	if (pthread_mutex_lock(&applock)) {
+		ast_log(LOG_ERROR, "Unable to lock application list\n");
+		return -1;
+	}
+	tmp = apps;
+	while(tmp) {
+		if (!strcasecmp(app, tmp->name)) {
+			ast_log(LOG_WARNING, "Already have an application '%s'\n", app);
+			pthread_mutex_unlock(&applock);
+			return -1;
+		}
+		tmp = tmp->next;
+	}
+	tmp = malloc(sizeof(struct ast_app));
+	if (tmp) {
+		strncpy(tmp->name, app, sizeof(tmp->name));
+		tmp->execute = execute;
+		tmp->next = apps;
+		apps = tmp;
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		pthread_mutex_unlock(&applock);
+		return -1;
+	}
+	if (option_verbose > 1)
+		ast_verbose( VERBOSE_PREFIX_2 "Registered application '%s'\n", tmp->name);
+	pthread_mutex_unlock(&applock);
+	return 0;
+}
+
+int ast_unregister_application(char *app) {
+	struct ast_app *tmp, *tmpl = NULL;
+	if (pthread_mutex_lock(&applock)) {
+		ast_log(LOG_ERROR, "Unable to lock application list\n");
+		return -1;
+	}
+	tmp = apps;
+	while(tmp) {
+		if (!strcasecmp(app, tmp->name)) {
+			if (tmpl)
+				tmpl->next = tmp->next;
+			else
+				apps = tmp->next;
+			if (option_verbose > 1)
+				ast_verbose( VERBOSE_PREFIX_2 "Unregistered application '%s'\n", tmp->name);
+			pthread_mutex_unlock(&applock);
+			return 0;
+		}
+		tmpl = tmp;
+		tmp = tmp->next;
+	}
+	pthread_mutex_unlock(&applock);
+	return -1;
+}
+
+struct ast_context *ast_context_create(char *name)
+{
+	struct ast_context *tmp;
+	
+	pthread_mutex_lock(&conlock);
+	tmp = contexts;
+	while(tmp) {
+		if (!strcasecmp(tmp->name, name)) {
+			pthread_mutex_unlock(&conlock);
+			ast_log(LOG_WARNING, "Tried to register context '%s', already in use\n", name);
+			return NULL;
+		}
+		tmp = tmp->next;
+	}
+	tmp = malloc(sizeof(struct ast_context));
+	if (tmp) {
+		pthread_mutex_init(&tmp->lock, NULL);
+		strncpy(tmp->name, name, sizeof(tmp->name));
+		tmp->root = NULL;
+		tmp->next = contexts;
+		contexts = tmp;
+		if (option_debug)
+			ast_log(LOG_DEBUG, "Registered context '%s'\n", tmp->name);
+		else if (option_verbose > 2)
+			ast_verbose( VERBOSE_PREFIX_3 "Registered extension context '%s'\n", tmp->name);
+	} else
+		ast_log(LOG_WARNING, "Out of memory\n");
+	
+	pthread_mutex_unlock(&conlock);
+	return tmp;
+}
+
+int ast_add_extension2(struct ast_context *con,
+					  int replace, char *extension, int priority,
+					  char *application, void *data, void (*datad)(void *))
+{
+
+#define LOG { 	if (option_debug) \
+		ast_log(LOG_DEBUG, "Added extension '%s' priority %d to %s\n", tmp->exten, tmp->priority, con->name); \
+	else if (option_verbose > 2) \
+		ast_verbose( VERBOSE_PREFIX_3 "Added extension '%s' priority %d to %s\n", tmp->exten, tmp->priority, con->name); \
+		}
+
+	/*
+	 * This is a fairly complex routine.  Different extensions are kept
+	 * in order by the extension number.  Then, extensions of different
+	 * priorities (same extension) are kept in a list, according to the
+	 * peer pointer.
+	 */
+	struct ast_exten *tmp, *e, *el = NULL, *ep = NULL;
+	int res;
+	/* Be optimistic:  Build the extension structure first */
+	tmp = malloc(sizeof(struct ast_exten));
+	if (tmp) {
+		strncpy(tmp->exten, extension, sizeof(tmp->exten));
+		tmp->priority = priority;
+		strncpy(tmp->app, application, sizeof(tmp->app));
+		tmp->data = data;
+		tmp->datad = datad;
+		tmp->peer = NULL;
+		tmp->next =  NULL;
+	} else {
+		ast_log(LOG_WARNING, "Out of memory\n");
+		return -1;
+	}
+	if (pthread_mutex_lock(&con->lock)) {
+		free(tmp);
+		/* And properly destroy the data */
+		datad(data);
+		ast_log(LOG_WARNING, "Failed to lock context '%s'\n", con->name);
+		return -1;
+	}
+	e = con->root;
+	while(e) {
+		res= strcasecmp(e->exten, extension);
+		if (res == 0) {
+			/* We have an exact match, now we find where we are
+			   and be sure there's no duplicates */
+			while(e) {
+				if (e->priority == tmp->priority) {
+					/* Can't have something exactly the same.  Is this a
+					   replacement?  If so, replace, otherwise, bonk. */
+					if (replace) {
+						if (ep) {
+							/* We're in the peer list, insert ourselves */
+							ep->peer = tmp;
+							tmp->peer = e->peer;
+						} else if (el) {
+							/* We're the first extension. Take over e's functions */
+							el->next = tmp;
+							tmp->next = e->next;
+							tmp->peer = e->peer;
+						} else {
+							/* We're the very first extension.  */
+							con->root = tmp;
+							tmp->next = e->next;
+							tmp->peer = e->peer;
+						}
+						/* Destroy the old one */
+						e->datad(e->data);
+						free(e);
+						pthread_mutex_unlock(&con->lock);
+						/* And immediately return success. */
+						LOG;
+						return 0;
+					} else {
+						ast_log(LOG_WARNING, "Unable to register extension '%s', priority %d in '%s', already in use\n", tmp->exten, tmp->priority, con->name);
+						tmp->datad(tmp->data);
+						free(tmp);
+						pthread_mutex_unlock(&con->lock);
+						return -1;
+					}
+				} else if (e->priority > tmp->priority) {
+					/* Slip ourselves in just before e */
+					if (ep) {
+						/* Easy enough, we're just in the peer list */
+						ep->peer = tmp;
+						tmp->peer = e;
+					} else if (el) {
+						/* We're the first extension in this peer list */
+						el->next = tmp;
+						tmp->next = e->next;
+						e->next = NULL;
+						tmp->peer = e;
+					} else {
+						/* We're the very first extension altogether */
+						tmp->next = con->root;
+						/* Con->root must always exist or we couldn't get here */
+						tmp->peer = con->root->peer;
+						con->root = tmp;
+					}
+					pthread_mutex_unlock(&con->lock);
+					/* And immediately return success. */
+					LOG;
+					return 0;
+				}
+				ep = e;
+				e = e->peer;
+			}
+			/* If we make it here, then it's time for us to go at the very end.
+			   ep *must* be defined or we couldn't have gotten here. */
+			ep->peer = tmp;
+			pthread_mutex_unlock(&con->lock);
+			/* And immediately return success. */
+			LOG;
+			return 0;
+				
+		} else if (res > 0) {
+			/* Insert ourselves just before 'e'.  We're the first extension of
+			   this kind */
+			tmp->next = e;
+			if (el) {
+				/* We're in the list somewhere */
+				el->next = tmp;
+			} else {
+				/* We're at the top of the list */
+				con->root = tmp;
+			}
+			pthread_mutex_unlock(&con->lock);
+			/* And immediately return success. */
+			LOG;
+			return 0;
+		}			
+			
+		el = e;
+		e = e->next;
+	}
+	/* If we fall all the way through to here, then we need to be on the end. */
+	if (el)
+		el->next = tmp;
+	else
+		con->root = tmp;
+	pthread_mutex_unlock(&con->lock);
+	LOG;
+	return 0;	
+}
+
+void ast_context_destroy(struct ast_context *con)
+{
+	struct ast_context *tmp, *tmpl=NULL;
+	pthread_mutex_lock(&conlock);
+	tmp = contexts;
+	while(tmp) {
+		if (tmp == con) {
+			/* Okay, let's lock the structure to be sure nobody else
+			   is searching through it. */
+			if (pthread_mutex_lock(&tmp->lock)) {
+				ast_log(LOG_WARNING, "Unable to lock context lock\n");
+				return;
+			}
+			if (tmpl)
+				tmpl->next = tmp->next;
+			else
+				contexts = tmp->next;
+			/* Okay, now we're safe to let it go -- in a sense, we were
+			   ready to let it go as soon as we locked it. */
+			pthread_mutex_unlock(&tmp->lock);
+			free(tmp);
+			pthread_mutex_unlock(&conlock);
+			return;
+		}
+		tmpl = tmp;
+		tmp = tmp->next;
+	}
+	pthread_mutex_unlock(&conlock);
+}
+
+int pbx_builtin_answer(struct ast_channel *chan, void *data)
+{
+	if (chan->state != AST_STATE_RING) {
+		ast_log(LOG_WARNING, "Ignoring answer request since line is not ringing\n");
+		return 0;
+	} else
+		return ast_answer(chan);
+}
+
+int pbx_builtin_hangup(struct ast_channel *chan, void *data)
+{
+	/* Just return non-zero and it will hang up */
+	return -1;
+}
+
+int pbx_builtin_wait(struct ast_channel *chan, void *data)
+{
+	/* Wait for "n" seconds */
+	if (data && atoi((char *)data))
+		sleep(atoi((char *)data));
+	return 0;
+}
+
+int pbx_builtin_background(struct ast_channel *chan, void *data)
+{
+	int res;
+	/* Stop anything playing */
+	ast_stopstream(chan);
+	/* Stream a file */
+	res = ast_streamfile(chan, (char *)data);
+	return res;
+}
+
+int pbx_builtin_rtimeout(struct ast_channel *chan, void *data)
+{
+	/* Set the timeout for how long to wait between digits */
+	chan->pbx->rtimeout = atoi((char *)data);
+	if (option_verbose > 2)
+		ast_verbose( VERBOSE_PREFIX_3 "Set Response Timeout to %d\n", chan->pbx->rtimeout);
+	return 0;
+}
+
+int pbx_builtin_dtimeout(struct ast_channel *chan, void *data)
+{
+	/* Set the timeout for how long to wait between digits */
+	chan->pbx->dtimeout = atoi((char *)data);
+	if (option_verbose > 2)
+		ast_verbose( VERBOSE_PREFIX_3 "Set Digit Timeout to %d\n", chan->pbx->dtimeout);
+	return 0;
+}
+
+int pbx_builtin_goto(struct ast_channel *chan, void *data)
+{
+	char *s;
+	char *exten, *pri, *context;
+	if (!data) {
+		ast_log(LOG_WARNING, "Goto requires an argument (optional context|optional extension|priority)\n");
+		return -1;
+	}
+	s = strdup((void *) data);
+	context = strtok(s, "|");
+	exten = strtok(NULL, "|");
+	if (!exten) {
+		/* Only a priority in this one */
+		pri = context;
+		exten = NULL;
+		context = NULL;
+	} else {
+		pri = strtok(NULL, "|");
+		if (!pri) {
+			/* Only an extension and priority in this one */
+			pri = exten;
+			exten = context;
+			context = NULL;
+		}
+	}
+	if (atoi(pri) < 0) {
+		ast_log(LOG_WARNING, "Priority '%s' must be a number > 0\n", pri);
+		free(s);
+		return -1;
+	}
+	/* At this point we have a priority and maybe an extension and a context */
+	chan->priority = atoi(pri) - 1;
+	if (exten)
+		strncpy(chan->exten, exten, sizeof(chan->exten));
+	if (context)
+		strncpy(chan->context, context, sizeof(chan->context));
+	if (option_verbose > 2)
+		ast_verbose( VERBOSE_PREFIX_3 "Goto (%s,%s,%d)\n", chan->context,chan->exten, chan->priority+1);
+	return 0;
+}
+
+int load_pbx(void)
+{
+	int x;
+	/* Initialize the PBX */
+	if (option_verbose) {
+		ast_verbose( "Asterisk PBX Core Initializing\n");
+		ast_verbose( "Registering builtin applications:\n");
+	}
+	for (x=0;x<sizeof(builtins) / sizeof(struct pbx_builtin); x++) {
+		if (option_verbose)
+			ast_verbose( VERBOSE_PREFIX_1 "[%s]\n", builtins[x].name);
+		if (ast_register_application(builtins[x].name, builtins[x].execute)) {
+			ast_log(LOG_ERROR, "Unable to register builtin application '%s'\n", builtins[x].name);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/translate.c
===================================================================
--- trunk/translate.c	2006-06-28 08:25:38 UTC (rev 420)
+++ trunk/translate.c	2006-06-28 10:25:31 UTC (rev 421)
@@ -1,4 +1,604 @@
 /*
+ * Asterisk -- A telephony toolkit for Linux.
+ *
+ * Translate via the use of pseudo channels
+ * 
+ * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+ *
+ * Mark Spencer <markster at linux-support.net>
+ *
+ * This program is free software, distributed under the terms of
+ * the GNU General Public License
+ */
+
+#include <asterisk/channel.h>
+#include <asterisk/channel_pvt.h>
+#include <asterisk/logger.h>
+#include <asterisk/translate.h>
+#include <asterisk/options.h>
+#include <sys/socket.h>
+#include <sys/time.h>
+#include <unistd.h>
+#include <stdlib.h>
+#include <pthread.h>
+#include <string.h>
+#include <stdio.h>
+
+static char *type = "Trans";
+
+static pthread_mutex_t list_lock = PTHREAD_MUTEX_INITIALIZER;
+static struct ast_translator *list = NULL;
+
+struct ast_translator_dir {
+	struct ast_translator *step;	/* Next step translator */
+	int cost;						/* Complete cost to destination */
+};
+
+static struct ast_translator_dir tr_matrix[MAX_FORMAT][MAX_FORMAT];
+
+struct ast_trans_pvt {
+	struct ast_translator *step;
+	struct ast_translator_pvt *state;
+	struct ast_trans_pvt *next;
+};
+
+
+static int powerof(int d)
+{
+	int x;
+	for (x = 0; x < 32; x++)
+		if ((1 << x) & d)
+			return x;
+	ast_log(LOG_WARNING, "Powerof %d: No power??\n", d);
+	return -1;
+}
+
+struct translator_pvt {
+	/* Sockets for communication */
+	int comm[2];
+	struct ast_trans_pvt *system;
+	struct ast_trans_pvt *rsystem;
+};
+
+static int translator_hangup(struct ast_channel *chan)
+{
+	ast_log(LOG_WARNING, "Explicit hangup on '%s' not recommended!  Call translator_destroy() instead.\n", chan->name);
+	chan->master->trans = NULL;
+	ast_hangup(chan->master);
+	chan->master = NULL;
+	return 0;
+}
+
+static int translator_send_digit(struct ast_channel *chan, char digit)
+{
+	/* Pass digits right along */
+	if (chan->master->pvt->send_digit)
+		return chan->master->pvt->send_digit(chan->master, digit);
+	return -1;
+}
+
+static int translator_call(struct ast_channel *chan, char *addr, int timeout)
+{
+	if (chan->master->pvt->call)
+		return chan->master->pvt->call(chan->master, addr, timeout);
+	return -1;
+}
+
+static int translator_answer(struct ast_channel *chan)
+{
+	if (chan->master->pvt->answer)
+		return chan->master->pvt->answer(chan->master);
+	return -1;
+}
+
+void ast_translator_free_path(struct ast_trans_pvt *p)
+{
+	struct ast_trans_pvt *pl;
+	while(p) {
+		pl = p;
+		p = p->next;
+		if (pl->state && pl->step->destroy)
+			pl->step->destroy(pl->state);
+		free(pl);
+	}
+}
+
+static void ast_translator_free(struct translator_pvt *pvt)
+{
+	ast_translator_free_path(pvt->system);
+	ast_translator_free_path(pvt->rsystem);
+	if (pvt->comm[0] > -1)
+		close(pvt->comm[0]);
+	if (pvt->comm[1] > -1)
+		close(pvt->comm[1]);
+	free(pvt);
+}
+
+struct ast_trans_pvt *ast_translator_build_path(int source, int dest)
+{
+	struct ast_trans_pvt *tmpr = NULL, *tmp = NULL;
+	/* One of the hardest parts:  Build a set of translators based upon
+	   the given source and destination formats */
+	source = powerof(source);
+	dest = powerof(dest);
+	while(source != dest) {
+		if (tr_matrix[source][dest].step) {
+			if (tmp) {
+				tmp->next = malloc(sizeof(struct ast_trans_pvt));
+				tmp = tmp->next;
+			} else
+				tmp = malloc(sizeof(struct ast_trans_pvt));
+
+				
+			if (tmp) {
+				tmp->next = NULL;
+				tmp->step = tr_matrix[source][dest].step;
+				tmp->state = tmp->step->new();
+				if (!tmp->state) {
+					free(tmp);
+					tmp = NULL;
+				}
+				/* Set the root, if it doesn't exist yet... */
+				if (!tmpr)
+					tmpr = tmp;
+				/* Keep going if this isn't the final destination */
+				source = tmp->step->dstfmt;
+			} else {
+				/* XXX This could leak XXX */
+				ast_log(LOG_WARNING, "Out of memory\n");
+				return NULL;
+			}
+		}
+	}
+	return tmpr;
+}
+
+static struct ast_frame *fd_read(int fd)
+{
+	/* XXX Wrong: Not thread safe! XXX */
+	char buf[4096];
+	int res;
+	struct ast_frame *f = (struct ast_frame *)buf;
+	/* Read a frame directly from there.  They're always in the
+	   right format. */
+	
+	if (read(fd, buf, sizeof(struct ast_frame)) 
+						== sizeof(struct ast_frame)) {
+		/* read the frame header */
+		f->mallocd = 0;
+		f->data = buf + sizeof(struct ast_frame) + AST_FRIENDLY_OFFSET;
+		f->offset = AST_FRIENDLY_OFFSET;
+		if (f->datalen > sizeof(buf) - sizeof(struct ast_frame) - AST_FRIENDLY_OFFSET) {
+			/* Really bad read */
+			ast_log(LOG_WARNING, "Strange read (%d bytes)\n", f->datalen);
+			return NULL;
+		}
+		if (f->datalen) {
+			if ((res = read(fd, f->data, f->datalen)) != f->datalen) {
+				/* Bad read */
+				ast_log(LOG_WARNING, "How very strange, expected %d, got %d\n", f->datalen, res);
+				return NULL;
+			}
+		}
+		return ast_frisolate(f);
+	} else if (option_debug)
+		ast_log(LOG_DEBUG, "NULL or invalid header\n");
+	/* Null if there was an error */
+	return NULL;
+}
+
+static struct ast_frame *translator_read(struct ast_channel *chan)
+{
+	return fd_read(chan->fd);
+}
+
+static int fd_write(int fd, struct ast_frame *frame)
+{
+	/* Write the frame exactly */
+	if (write(fd, frame, sizeof(struct ast_frame)) != sizeof(struct ast_frame)) {
+		ast_log(LOG_WARNING, "Write error\n");
+		return -1;
+	}
+	if (write(fd, frame->data, frame->datalen) != frame->datalen) {
+		ast_log(LOG_WARNING, "Write error\n");
+		return -1;
+	}
+	return 0;
+}
+
+static int translator_write(struct ast_channel *chan, struct ast_frame *frame)
+{
+	return fd_write(chan->fd, frame);
+}
+
+struct ast_frame_chain *ast_translate(struct ast_trans_pvt *path, struct ast_frame *f)
+{
+	struct ast_trans_pvt *p;
+	struct ast_frame *out;
+	struct ast_frame_chain *outc = NULL, *prev = NULL, *cur;
+	p = path;
+	/* Feed the first frame into the first translator */
+	p->step->framein(p->state, f);
+	while(p) {
+		/* Read all the frames from the current translator */
+		while((out = p->step->frameout(p->state)))  {
+			if (p->next) {
+				/* Feed to next layer */
+				p->next->step->framein(p->next->state, out);
+			} else {
+				/* Last layer -- actually do something */
+				cur = malloc(sizeof(struct ast_frame_chain));
+				if (!cur) {
+					/* XXX Leak majorly on a problem XXX */
+					ast_log(LOG_WARNING, "Out of memory\n");
+					return NULL;
+				}
+				if (prev) 
+					prev->next = cur;
+				else
+					outc = cur;
+				cur->fr = ast_frisolate(out);
+				cur->next = NULL;
+				if (prev)
+					prev = prev->next;
+				else
+					prev = outc;
+			}
+		}
+		p = p->next;
+	}
+	return outc;
+}
+
+/* XXX There's an experimentally derived fudge factor XXX */
+#define FUDGE 4
+
+static void translator_apply(struct ast_trans_pvt *path, struct ast_frame *f, int fd, struct ast_channel *c)
+{
+	struct ast_trans_pvt *p;
+	struct ast_frame *out;
+	p = path;
+	/* Feed the first frame into the first translator */
+	p->step->framein(p->state, f);
+	while(p) {
+		/* Read all the frames from the current translator */
+		while((out = p->step->frameout(p->state)))  {
+			if (p->next) {
+				/* Feed to next layer */
+				p->next->step->framein(p->next->state, out);
+			} else {
+				if (c)
+					ast_write(c, out);
+				else
+					fd_write(fd, out);
+			}
+		}
+		p = p->next;
+	}
+}
+
+static void *translator_thread(void *data)
+{
+	struct ast_channel *real = data;
+	struct ast_frame *f;
+	int ms = -1;
+	struct translator_pvt *pvt = NULL;
+	int fd = -1;
+	int fds[2];
+	int res;
+	/* Read from the real, translate, write as necessary to the fake */
+	for(;;) {
+		if (!real->trans) {
+			ast_log(LOG_WARNING, "No translator anymore\n");
+			break;
+		}
+		pvt = real->trans->pvt->pvt;
+		fd = pvt->comm[1];
+		fds[0] = fd;
+		fds[1] = real->fd;
+		CHECK_BLOCKING(real);
+		res = ast_waitfor_n_fd(fds, 2, &ms);
+		real->blocking = 0;
+		if (res >= 0) {
+			if (res == real->fd) {
+				f = ast_read(real);
+				if (!f) {
+					if (option_debug)
+						ast_log(LOG_DEBUG, "Empty frame\n");
+					break;
+				}
+				if (f->frametype ==  AST_FRAME_VOICE) {
+					if (pvt->system)
+						translator_apply(pvt->system, f, fd, NULL);
+				} else {
+					/* If it's not voice, just pass it along */
+					fd_write(fd, f);
+				}
+				ast_frfree(f);
+			} else {
+				f = fd_read(res);
+				if (!f) {
+					if (option_debug)
+						ast_log(LOG_DEBUG, "Empty (hangup) frame\n");
+					break;
+				}
+				if (f->frametype == AST_FRAME_VOICE) {
+					if (pvt->rsystem)
+						translator_apply(pvt->rsystem, f, -1, real);
+				} else {
+					ast_write(real, f);
+				}
+				ast_frfree(f);
+			}
+		} else {
+			ast_log(LOG_DEBUG, "Waitfor returned non-zero\n");
+			break;
+		}
+	}
+	if (pvt)
+		pvt->comm[1] = -1;
+	if (fd > -1) {
+		/* Write a bogus frame */
+		write(fd, data, 1);
+		close(fd);
+	}
+	return NULL;
+}
+
+struct ast_channel *ast_translator_create(struct ast_channel *real, int format, int direction)
+{
+	struct ast_channel *tmp;
+	struct translator_pvt *pvt;
+	pthread_t t;
+	if (real->trans) {
+		ast_log(LOG_WARNING, "Translator already exists on '%s'\n", real->name);
+		return NULL;
+	}
+	if (!(pvt = malloc(sizeof(struct translator_pvt)))) {
+		ast_log(LOG_WARNING, "Unable to allocate private translator on '%s'\n", real->name);
+		return NULL;
+	}
+	pvt->comm[0] = -1;
+	pvt->comm[1] = -1;
+	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pvt->comm)) {
+		ast_log(LOG_WARNING, "Unable to create UNIX domain socket on '%s'\n", real->name);
+		ast_translator_free(pvt);
+	}
+	/* In to the system */
+	if (direction & AST_DIRECTION_IN)
+		pvt->system = ast_translator_build_path(real->format, format);
+	else
+		pvt->system = NULL;
+	/* Out from the system */
+	if (direction & AST_DIRECTION_OUT)
+		pvt->rsystem = ast_translator_build_path(format, real->format);
+	else
+		pvt->rsystem = NULL;
+	if (!pvt->system && !pvt->rsystem) {
+		ast_log(LOG_WARNING, "Unable to build a translation path for %s (%d to %d)\n", real->name, real->format, format);
+		ast_translator_free(pvt);
+		return NULL;
+	}
+	if (!pvt->system && (direction & AST_DIRECTION_IN)) {
+		ast_log(LOG_WARNING, "Translation path for '%s' is one-way (reverse)\n", real->name);
+		ast_translator_free(pvt);
+		return NULL;
+	}
+	if (!pvt->rsystem && (direction & AST_DIRECTION_OUT)) {
+		ast_log(LOG_WARNING, "Translation path for '%s' is one-way (forward)\n", real->name);
+		ast_translator_free(pvt);
+		return NULL;
+	}
+	if ((tmp = ast_channel_alloc())) {
+		snprintf(tmp->name, sizeof(tmp->name), "%s/Translate:%d", real->name, format);
+		tmp->type = type;
+		tmp->fd = pvt->comm[0];
+		tmp->format = format;
+		tmp->state = real->state;
+		tmp->rings = 0;
+		tmp->pvt->pvt = pvt;
+		tmp->master = real;
+		tmp->pvt->send_digit = translator_send_digit;
+		tmp->pvt->call = translator_call;
+		tmp->pvt->hangup = translator_hangup;
+		tmp->pvt->answer = translator_answer;
+		tmp->pvt->read = translator_read;
+		tmp->pvt->write = translator_write;
+		real->trans = tmp;
+		if (option_verbose > 2)
+			ast_verbose(VERBOSE_PREFIX_3 "Created translator %s\n", tmp->name);
+		if (pthread_create(&t, NULL, translator_thread, real) < 0) {
+			ast_translator_destroy(tmp);
+			tmp = NULL;
+			ast_log(LOG_WARNING, "Failed to start thread\n");
+		}
+	} else {
+		ast_translator_free(pvt);
+		ast_log(LOG_WARNING, "Unable to allocate channel\n");
+	}
+	return tmp;
+} 
+
+static void rebuild_matrix()
+{
+	struct ast_translator *t;
+	int changed;
+	int x,y,z;
+	if (option_debug)
+		ast_log(LOG_DEBUG, "Reseting translation matrix\n");
+	/* Use the list of translators to build a translation matrix */
+	bzero(tr_matrix, sizeof(tr_matrix));
+	t = list;
+	while(t) {
+		if (!tr_matrix[t->srcfmt][t->dstfmt].step ||
+		     tr_matrix[t->srcfmt][t->dstfmt].cost > t->cost) {
+			tr_matrix[t->srcfmt][t->dstfmt].step = t;
+			tr_matrix[t->srcfmt][t->dstfmt].cost = t->cost;
+		}
+		t = t->next;
+	}
+	do {
+		changed = 0;
+		/* Don't you just love O(N^3) operations? */
+		for (x=0; x< MAX_FORMAT; x++)				/* For each source format */
+			for (y=0; y < MAX_FORMAT; y++) 			/* And each destination format */
+				if (x != y)							/* Except ourselves, of course */
+					for (z=0; z < MAX_FORMAT; z++) 	/* And each format it might convert to */
+						if ((x!=z) && (y!=z)) 		/* Don't ever convert back to us */
+							if (tr_matrix[x][y].step && /* We can convert from x to y */
+								tr_matrix[y][z].step && /* And from y to z and... */
+								(!tr_matrix[x][z].step || 	/* Either there isn't an x->z conversion */
+								(tr_matrix[x][y].cost + 
+								 tr_matrix[y][z].cost <	/* Or we're cheaper than the existing */
+								 tr_matrix[x][z].cost)  /* solution */
+							     )) {
+								 			/* We can get from x to z via y with a cost that
+											   is the sum of the transition from x to y and
+											   from y to z */
+								 
+								 	tr_matrix[x][z].step = tr_matrix[x][y].step;
+									tr_matrix[x][z].cost = tr_matrix[x][y].cost + 
+														   tr_matrix[y][z].cost;
+									if (option_debug)
+										ast_log(LOG_DEBUG, "Discovered %d cost path from %d to %d, via %d\n", tr_matrix[x][z].cost, x, z, y);
+									changed++;
+								 }
+		
+	} while (changed);
+}
+
+static void calc_cost(struct ast_translator *t)
+{
+	int sofar=0;
+	struct ast_translator_pvt *pvt;
+	struct ast_frame *f, *out;
+	struct timeval start, finish;
+	int cost;
+	/* If they don't make samples, give them a terrible score */
+	if (!t->sample) {
+		ast_log(LOG_WARNING, "Translator '%s' does not produce sample frames.\n", t->name);
+		t->cost = 99999;
+		return;
+	}
+	pvt = t->new();
+	if (!pvt) {
+		ast_log(LOG_WARNING, "Translator '%s' appears to be broken and will probably fail.\n", t->name);
+		t->cost = 99999;
+		return;
+	}
+	gettimeofday(&start, NULL);
+	/* Call the encoder until we've processed one second of time */
+	while(sofar < 1000) {
+		f = t->sample();
+		if (!f) {
+			ast_log(LOG_WARNING, "Translator '%s' failed to produce a sample frame.\n", t->name);
+			t->destroy(pvt);
+			t->cost = 99999;
+			return;
+		}
+		t->framein(pvt, f);
+		ast_frfree(f);
+		while((out = t->frameout(pvt))) {
+			sofar += out->timelen;
+			ast_frfree(out);
+		}
+	}
+	gettimeofday(&finish, NULL);
+	t->destroy(pvt);
+	cost = (finish.tv_sec - start.tv_sec) * 1000 + (finish.tv_usec - start.tv_usec) / 1000;
+	t->cost = cost;
+}
+
+int ast_register_translator(struct ast_translator *t)
+{
+	t->srcfmt = powerof(t->srcfmt);
+	t->dstfmt = powerof(t->dstfmt);
+	if ((t->srcfmt >= MAX_FORMAT) || (t->dstfmt >= MAX_FORMAT)) {
+		ast_log(LOG_WARNING, "Format %d is larger than MAX_FORMAT\n", t->srcfmt);
+		return -1;
+	}
+	calc_cost(t);
+	if (option_verbose > 1)
+		ast_verbose(VERBOSE_PREFIX_2 "Registered translator '%s' from format %d to %d, cost %d\n", t->name, t->srcfmt, t->dstfmt, t->cost);
+	pthread_mutex_lock(&list_lock);
+	t->next = list;
+	list = t;
+	rebuild_matrix();
+	pthread_mutex_unlock(&list_lock);
+	return 0;
+}
+
+int ast_unregister_translator(struct ast_translator *t)
+{
+	struct ast_translator *u, *ul = NULL;
+	pthread_mutex_lock(&list_lock);
+	u = list;
+	while(u) {
+		if (u == t) {
+			if (ul)
+				ul->next = u->next;
+			else
+				list = u->next;
+			break;
+		}
+		u = u->next;
+	}
+	rebuild_matrix();
+	pthread_mutex_unlock(&list_lock);
+	return (u ? 0 : -1);
+}
+
+void ast_translator_destroy(struct ast_channel *trans)
+{
+	char dummy;
+	int ms = 1000;
+	if (!trans->master) {
+		ast_log(LOG_WARNING, "Translator is not part of a real channel?\n");
+		return;
+	}
+	if (trans->master->trans != trans) {
+		ast_log(LOG_WARNING, "Translator is not the right one!?!?\n");
+		return;
+	}
+	trans->master->trans = NULL;
+	/* Write an invalid frame to kill off the main thread, which will
+	   in turn acknowledge by writing an invalid frame back to us, unless
+	   they're already closed.  */
+	if (trans->fd > -1) {
+		if (write(trans->fd, trans, 1) == 1) {
+			/* Wait for a respnose, but no more than 1 second */
+			if (ast_waitfor_n_fd(&trans->fd, 1, &ms) == trans->fd)
+				read(trans->fd, &dummy, 1);
+		}
+	}
+	if (option_verbose > 2)
+		ast_verbose(VERBOSE_PREFIX_3 "Destroyed translator %s\n", trans->name);
+	close(trans->fd);
+	ast_channel_free(trans);
+}
+
+int ast_translator_best_choice(int dst, int srcs)
+{
+	/* Calculate our best source format, given costs, and a desired destination */
+	int x;
+	int best=-1;
+	int besttime=999999999;
+	dst = powerof(dst);
+	pthread_mutex_lock(&list_lock);
+	for (x=0;x<MAX_FORMAT;x++) {
+		if (tr_matrix[x][dst].step &&	/* There's a step */
+		    (tr_matrix[x][dst].cost < besttime) && /* We're better than what exists now */
+			(srcs & (1 << x)))			/* x is a valid source format */
+			{
+				best = 1 << x;
+				besttime = tr_matrix[x][dst].cost;
+			}
+				
+	}
+	pthread_mutex_unlock(&list_lock);
+	return best;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.



From solid-pbx-svn-admin at lists.berlios.de  Wed Jun 28 13:25:50 2006
From: solid-pbx-svn-admin at lists.berlios.de (solid-pbx-svn-admin at lists.berlios.de)
Date: Wed, 28 Jun 2006 13:25:50 +0200
Subject: [solid-pbx-svn] r422 - in trunk: . configs formats pbx
Message-ID: <200606281125.k5SBPol0011196@sheep.berlios.de>

Author: casper2
Date: 2006-06-28 13:25:38 +0200 (Wed, 28 Jun 2006)
New Revision: 422

Modified:
   trunk/CREDITS
   trunk/Makefile
   trunk/configs/voicemail.conf.sample
   trunk/formats/Makefile
   trunk/logger.c
   trunk/pbx/Makefile
Log:
Update to Asterisk SVN trunk r100

------------------------------------------------------------------------
r91 | markster | 1999-12-05 08:16:40 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r92 | markster | 1999-12-05 08:28:29 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.0 from FTP

------------------------------------------------------------------------
r94 | markster | 1999-12-05 21:52:10 +0100 (Sun, 05 Dec 1999) | 2 lines

Version 0.1.1 from FTP

------------------------------------------------------------------------
r95 | markster | 1999-12-07 06:45:48 +0100 (Tue, 07 Dec 1999) | 2 lines

Version 0.1.1 from FTP

------------------------------------------------------------------------
r96 | markster | 1999-12-07 06:45:50 +0100 (Tue, 07 Dec 1999) | 2 lines

Version 0.1.2 from FTP

------------------------------------------------------------------------
r97 | markster | 1999-12-07 06:45:50 +0100 (Tue, 07 Dec 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------
r98 | markster | 1999-12-07 06:45:51 +0100 (Tue, 07 Dec 1999) | 2 lines

Version 0.1.3 from FTP

------------------------------------------------------------------------
r99 | markster | 1999-12-07 06:45:52 +0100 (Tue, 07 Dec 1999) | 2 lines

Version 0.1.4 from FTP

------------------------------------------------------------------------
r100 | markster | 1999-12-07 06:45:53 +0100 (Tue, 07 Dec 1999) | 2 lines

Version 0.1.5 from FTP

------------------------------------------------------------------------


Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-28 10:25:31 UTC (rev 421)
+++ trunk/CREDITS	2006-06-28 11:25:38 UTC (rev 422)
@@ -1,4 +1,56 @@
+=== HARDWARE DONORS === 
 
+* Special thanks to Adtran, Inc, for their donation of an Adtran Atlas,
+and TSU 120e to the project. (http://www.adtran.com)
+
+* Thanks to QuickNet Technologies for their donation of an Internet
+PhoneJack card to the project.  (http://www.quicknet.net)
+
+=== OTHER SOURCE CODE IN ASTERISK ===
+
+I did not implement the codecs in asterisk.  Here is the copyright on the
+GSM source:
+
+Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
+Technische Universitaet Berlin
+
+Any use of this software is permitted provided that this notice is not
+removed and that neither the authors nor the Technische Universitaet Berlin
+are deemed to have made any representations as to the suitability of this
+software for any purpose nor are held responsible for any defects of
+this software.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
+
+As a matter of courtesy, the authors request to be informed about uses
+this software has found, about bugs in this software, and about any
+improvements that may be of general interest.
+
+Berlin, 28.11.1994
+Jutta Degener
+Carsten Bormann
+
+And the copyright on the ADPCM source:
+
+Copyright 1992 by Stichting Mathematisch Centrum, Amsterdam, The
+Netherlands.
+
+                        All Rights Reserved
+
+Permission to use, copy, modify, and distribute this software and its
+documentation for any purpose and without fee is hereby granted,
+provided that the above copyright notice appear in all copies and that
+both that copyright notice and this permission notice appear in
+supporting documentation, and that the names of Stichting Mathematisch
+Centrum or CWI not be used in advertising or publicity pertaining to
+distribution of the software without specific, written prior permission.
+
+STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
+THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
+FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
+FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
+WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
+ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
+OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
+
 === DEVELOPMENT SUPPORT ===
 We'd like to thank the following companies for helping fund development of
 Asterisk:

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 10:25:31 UTC (rev 421)
+++ trunk/Makefile	2006-06-28 11:25:38 UTC (rev 422)
@@ -3,6 +3,51 @@
 # 
 # Top level Makefile
 #
+# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+#
+# Mark Spencer <markster at linux-support.net>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+
+.EXPORT_ALL_VARIABLES:
+
+MODULES_DIR=/usr/lib/asterisk/modules
+
+DEBUG=-g #-pg
+INCLUDE=-Iinclude -I../include
+CFLAGS=-Wall -Werror -O6 $(DEBUG) $(INCLUDE) -D_REENTRANT
+CFLAGS+=$(shell if $(CC) -march=i686 -S -o /dev/null -xc /dev/null >/dev/null 2>&1; then echo "-march=i686"; fi)
+SUBDIRS=channels pbx apps codecs formats
+LIBS=-ldl -lpthread #-lefence
+OBJS=io.o sched.o logger.o frame.o loader.o config.o channel.o translate.o file.o say.o pbx.o asterisk.o
+CC=gcc
+INSTALL=install
+
+all: asterisk subdirs
+
+asterisk: $(OBJS)
+	gcc -o asterisk -rdynamic $(OBJS) $(LIBS)
+
+subdirs: 
+	for x in $(SUBDIRS); do $(MAKE) -C $$x || exit 1 ; done
+
+clean:
+	for x in $(SUBDIRS); do $(MAKE) -C $$x clean || exit 1 ; done
+	rm -f *.o *.so asterisk
+
+install: all
+	mkdir -p $(MODULES_DIR)
+	for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
+	install -d /usr/include/asterisk
+	install include/asterisk/*.h /usr/include/asterisk
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
+# Top level Makefile
+#
 # Copyright (C) 1999-2006, Digium, Inc.
 #
 # Mark Spencer <markster at digium.com>

Modified: trunk/configs/voicemail.conf.sample
===================================================================
--- trunk/configs/voicemail.conf.sample	2006-06-28 10:25:31 UTC (rev 421)
+++ trunk/configs/voicemail.conf.sample	2006-06-28 11:25:38 UTC (rev 422)
@@ -4,7 +4,7 @@
 [general]
 ; Default format for writing Voicemail
 ; format=g723sf|rawgsm|mp3|wav
-format=g723sf|wav
+format=g723sf|wav49|wav
 
 [default]
 4200=2345,Mark Spencer,markster at linux-support.net

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 10:25:31 UTC (rev 421)
+++ trunk/formats/Makefile	2006-06-28 11:25:38 UTC (rev 422)
@@ -3,6 +3,41 @@
 # 
 # Makefile for file format modules
 #
+# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+#
+# Mark Spencer <markster at linux-support.net>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+FORMAT_LIBS=format_g723.so format_wav.so format_mp3.so # format_wav_gsm.so
+
+GSMLIB=../codecs/gsm/lib/libgsm.a
+
+CFLAGS+=
+
+all: $(FORMAT_LIBS)
+
+clean:
+	rm -f *.so *.o
+
+%.so : %.o
+	$(CC) -shared -Xlinker -x -o $@ $<
+
+format_wav.so : format_wav.o
+	$(CC) -shared -Xlinker -x -o $@ $< -laudiofile
+
+format_wav_gsm.so : format_wav_gsm.o
+	$(CC) -shared -Xlinker -x -o $@ $< $(LIBGSM)
+
+install: all
+	for x in $(FORMAT_LIBS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
+# Makefile for file format modules
+#
 # Copyright (C) 1999-2006, Digium, Inc.
 #
 # Mark Spencer <markster at digium.com>

Modified: trunk/logger.c
===================================================================
--- trunk/logger.c	2006-06-28 10:25:31 UTC (rev 421)
+++ trunk/logger.c	2006-06-28 11:25:38 UTC (rev 422)
@@ -1,4 +1,208 @@
 /*
+ * Cheops Next Generation
+ * 
+ * Mark Spencer <markster at marko.net>
+ *
+ * Copyright(C) 1999, Adtran, Inc.
+ * 
+ * Distributed under the terms of the GNU General Public License (GPL) Version 2
+ *
+ * Logging routines
+ *
+ */
+
+#include <stdarg.h>
+#include <stdio.h>
+#include <unistd.h>
+#include <time.h>
+#include <asterisk/logger.h>
+#include <asterisk/options.h>
+#include <string.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <pthread.h>
+#include <sys/stat.h>
+#include "asterisk.h"
+
+#define AST_EVENT_LOG AST_LOG_DIR "/" EVENTLOG
+
+#define MAX_MSG_QUEUE 200
+
+static pthread_mutex_t msglist_lock = PTHREAD_MUTEX_INITIALIZER;
+
+static struct msglist {
+	char *msg;
+	struct msglist *next;
+} *list = NULL, *last = NULL;
+
+static int msgcnt = 0;
+
+static FILE *eventlog = NULL;
+
+static char *levels[] = {
+	"DEBUG",
+	"EVENT",
+	"NOTICE",
+	"WARNING",
+	"ERROR"
+};
+
+static struct verb {
+	void (*verboser)(char *string, int opos, int replacelast, int complete);
+	struct verb *next;
+} *verboser = NULL;
+
+int init_logger(void)
+{
+
+	mkdir(AST_LOG_DIR, 0755);
+	eventlog = fopen(AST_EVENT_LOG, "a");
+	if (eventlog) {
+		ast_log(LOG_EVENT, "Started Asterisk Event Logger\n");
+		if (option_verbose)
+			ast_verbose("Asterisk Event Logger Started\n");
+		return 0;
+	} else 
+		ast_log(LOG_ERROR, "Unable to create event log: %s\n", strerror(errno));
+	return -1;
+}
+
+extern void ast_log(int level, char *file, int line, char *function, char *fmt, ...)
+{
+	char date[256];
+	time_t t;
+	struct tm *tm;
+
+	va_list ap;
+	va_start(ap, fmt);
+
+	if (level == 1 /* Event */) {
+		time(&t);
+		tm = localtime(&t);
+		if (tm) {
+			/* Log events into the event log file, with a different format */
+			strftime(date, sizeof(date), "%b %e %T", tm);
+			fprintf(eventlog, "%s asterisk[%d]: ", date, getpid());
+			vfprintf(eventlog, fmt, ap);
+			fflush(eventlog);
+		} else
+			ast_log(LOG_WARNING, "Unable to retrieve local time?\n");
+	} else {
+		fprintf(stdout, "%s: File %s, Line %d (%s): ", levels[level], file, line, function);
+		vfprintf(stdout, fmt, ap);
+		fflush(stdout);
+	}
+	va_end(ap);
+}
+
+extern void ast_verbose(char *fmt, ...)
+{
+	static char stuff[256];
+	static int pos = 0, opos;
+	static int replacelast = 0, complete;
+	struct msglist *m;
+	struct verb *v;
+	va_list ap;
+	va_start(ap, fmt);
+	pthread_mutex_lock(&msglist_lock);
+	vsnprintf(stuff + pos, sizeof(stuff) - pos, fmt, ap);
+	opos = pos;
+	pos = strlen(stuff);
+	if (fmt[strlen(fmt)-1] == '\n') 
+		complete = 1;
+	else
+		complete=0;
+	if (complete) {
+		if (msgcnt < MAX_MSG_QUEUE) {
+			/* Allocate new structure */
+			m = malloc(sizeof(struct msglist));
+			msgcnt++;
+		} else {
+			/* Recycle the oldest entry */
+			m = list;
+			list = list->next;
+			free(m->msg);
+		}
+		if (m) {
+			m->msg = strdup(stuff);
+			if (m->msg) {
+				if (last)
+					last->next = m;
+				else
+					list = m;
+				m->next = NULL;
+				last = m;
+			} else {
+				msgcnt--;
+				ast_log(LOG_DEBUG, "Out of memory\n");
+				free(m);
+			}
+		}
+	}
+	if (verboser) {
+		v = verboser;
+		while(v) {
+			v->verboser(stuff, opos, replacelast, complete);
+			v = v->next;
+		}
+	} else
+		fprintf(stdout, stuff + opos);
+
+	if (fmt[strlen(fmt)-1] != '\n') 
+		replacelast = 1;
+	else 
+		replacelast = pos = 0;
+	
+	va_end(ap);
+	pthread_mutex_unlock(&msglist_lock);
+}
+
+
+int ast_register_verbose(void (*v)(char *string, int opos, int replacelast, int complete)) 
+{
+	struct msglist *m;
+	struct verb *tmp;
+	/* XXX Should be more flexible here, taking > 1 verboser XXX */
+	if ((tmp = malloc(sizeof (struct verb)))) {
+		tmp->verboser = v;
+		pthread_mutex_lock(&msglist_lock);
+		tmp->next = verboser;
+		verboser = tmp;
+		m = list;
+		while(m) {
+			/* Send all the existing entries that we have queued (i.e. they're likely to have missed) */
+			v(m->msg, 0, 0, 1);
+			m = m->next;
+		}
+		pthread_mutex_unlock(&msglist_lock);
+		return 0;
+	}
+	return -1;
+}
+
+int ast_unregister_verbose(void (*v)(char *string, int opos, int replacelast, int complete))
+{
+	int res = -1;
+	struct verb *tmp, *tmpl=NULL;
+	pthread_mutex_lock(&msglist_lock);
+	tmp = verboser;
+	while(tmp) {
+		if (tmp->verboser == v)	{
+			if (tmpl)
+				tmpl->next = tmp->next;
+			else
+				verboser = tmp->next;
+			break;
+		}
+		tmpl = tmp;
+		tmp = tmp->next;
+	}
+	if (tmp)
+		res = 0;
+	pthread_mutex_unlock(&msglist_lock);
+	return res;
+}
+/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 10:25:31 UTC (rev 421)
+++ trunk/pbx/Makefile	2006-06-28 11:25:38 UTC (rev 422)
@@ -1,6 +1,67 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
+# Makefile for PBX frontends (dynamically loaded)
+#
+# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
+#
+# Mark Spencer <markster at linux-support.net>
+#
+# This program is free software, distributed under the terms of
+# the GNU General Public License
+#
+
+
+
+PBX_LIBS=pbx_config.so             # pbx_gtkconsole.so pbx_kdeconsole.so
+
+# Add GTK console if appropriate
+PBX_LIBS+=$(shell gtk-config --cflags >&/dev/null && echo "pbx_gtkconsole.so")
+# Add KDE Console if appropriate
+PBX_LIBS+=$(shell [ "$$QTDIR" != "" ] && echo "pbx_kdeconsole.so")
+
+
+GTK_FLAGS=`gtk-config --cflags gthread`
+GTK_LIBS=`gtk-config --libs gthread`
+#CXX=egcs
+MOC=$(QTDIR)/bin/moc
+KDE_FLAGS=-I$(KDEDIR)/include -I$(KDEDIR)/include/kde -I$(QTDIR)/include
+KDE_LIBS=-L$(KDEDIR)/lib -L$(QTDIR)/lib -lqt -lkdecore -lkdeui
+CFLAGS+=
+
+KDE_CONSOLE_OBJS=pbx_kdeconsole_main.o pbx_kdeconsole.o 
+
+all: $(PBX_LIBS)
+
+clean:
+	rm -f *.so *.o
+
+pbx_gtkconsole.o: pbx_gtkconsole.c
+	$(CC) $(CFLAGS) $(GTK_FLAGS) -c -o $@ $<
+
+pbx_gtkconsole.so: pbx_gtkconsole.o
+	$(CC) -shared -Xlinker -x -o $@ $< $(GTK_LIBS)
+
+pbx_kdeconsole.o: pbx_kdeconsole.cc pbx_kdeconsole.moc
+	$(CXX) $(CFLAGS) $(KDE_FLAGS) -c -o $@ $<
+
+pbx_kdeconsole_main.o: pbx_kdeconsole_main.cc pbx_kdeconsole.h
+	$(CXX) $(CFLAGS) $(KDE_FLAGS) -c -o $@ $<
+
+pbx_kdeconsole.so: $(KDE_CONSOLE_OBJS)
+	$(CC) -shared -Xlinker -x -o $@ $(KDE_CONSOLE_OBJS) $(KDE_LIBS)
+
+%.moc : %.h
+	$(MOC) $< -o $@
+
+%.so : %.o
+	$(CC) -shared -Xlinker -x -o $@ $<
+
+install: all
+	for x in $(PBX_LIBS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
+#
+# Asterisk -- A telephony toolkit for Linux.
+# 
 # Makefile for PBX modules
 #
 # Copyright (C) 1999-2006, Digium, Inc.



