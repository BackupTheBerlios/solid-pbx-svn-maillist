<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [solid-pbx-svn] r426 - in trunk: . build_tools
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r426%20-%20in%20trunk%3A%20.%20build_tools&In-Reply-To=%3C200607052226.k65MQkn4010382%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   <LINK REL="Previous"  HREF="000420.html">
   
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[solid-pbx-svn] r426 - in trunk: . build_tools</H1>
    <B>solid-pbx-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r426%20-%20in%20trunk%3A%20.%20build_tools&In-Reply-To=%3C200607052226.k65MQkn4010382%40sheep.berlios.de%3E"
       TITLE="[solid-pbx-svn] r426 - in trunk: . build_tools">solid-pbx-svn-admin at lists.berlios.de
       </A><BR>
    <I>Thu Jul  6 00:26:46 CEST 2006</I>
    <P><UL>
        <LI>Previous message: <A HREF="000420.html">[solid-pbx-svn] r425 - trunk/apps
</A></li>
        
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#421">[ date ]</a>
              <a href="thread.html#421">[ thread ]</a>
              <a href="subject.html#421">[ subject ]</a>
              <a href="author.html#421">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-07-06 00:26:39 +0200 (Thu, 06 Jul 2006)
New Revision: 426

Modified:
   trunk/Makefile
   trunk/build_tools/Makefile
   trunk/build_tools/menuselect.c
   trunk/build_tools/menuselect.h
   trunk/build_tools/menuselect_curses.c
Log:
Update to Asterisk SVN trunk r35713

------------------------------------------------------------------------
r35704 | russell | 2006-06-23 16:19:35 +0200 (Fri, 23 Jun 2006) | 2 lines

merge changes to get menuselect using svn:externals

------------------------------------------------------------------------


Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-07-05 22:02:15 UTC (rev 425)
+++ trunk/Makefile	2006-07-05 22:26:39 UTC (rev 426)
@@ -392,8 +392,8 @@
 	@echo &quot;****&quot;
 	@exit 1
 
-menuselect.makeopts: build_tools/menuselect makeopts.xml
-	@build_tools/menuselect --check-deps ${GLOBAL_MAKEOPTS} ${USER_MAKEOPTS} $@
+menuselect.makeopts: menuselect/menuselect makeopts.xml
+	@menuselect/menuselect --check-deps ${GLOBAL_MAKEOPTS} ${USER_MAKEOPTS} $@
 
 #ifneq ($(wildcard tags),)
 ctags: tags
@@ -871,11 +871,11 @@
 	rm -rf $(DESTDIR)$(ASTETCDIR)
 	rm -rf $(DESTDIR)$(ASTLOGDIR)
 
-menuselect: build_tools/menuselect makeopts.xml
-	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">- at build_tools</A>/menuselect ${GLOBAL_MAKEOPTS} ${USER_MAKEOPTS} menuselect.makeopts &amp;&amp; echo &quot;menuselect changes saved!&quot; || echo &quot;menuselect changes NOT saved!&quot;
+menuselect: menuselect/menuselect makeopts.xml
+	<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">- at menuselect</A>/menuselect ${GLOBAL_MAKEOPTS} ${USER_MAKEOPTS} menuselect.makeopts &amp;&amp; echo &quot;menuselect changes saved!&quot; || echo &quot;menuselect changes NOT saved!&quot;
 
-build_tools/menuselect: build_tools/menuselect.c build_tools/menuselect_curses.c build_tools/menuselect.h config.status mxml/libmxml.a $(MENUSELECT_OBJS)
-	$(MAKE) -C build_tools menuselect
+menuselect/menuselect: menuselect/menuselect.c menuselect/menuselect_curses.c menuselect/menuselect.h config.status mxml/libmxml.a $(MENUSELECT_OBJS)
+	@CFLAGS=&quot;-include ../include/asterisk/autoconfig.h&quot; $(MAKE) -C menuselect menuselect
 
 mxml/libmxml.a:
 	@cd mxml &amp;&amp; unset CFLAGS LIBS &amp;&amp; test -f config.h || ./configure

Modified: trunk/build_tools/Makefile
===================================================================
--- trunk/build_tools/Makefile	2006-07-05 22:02:15 UTC (rev 425)
+++ trunk/build_tools/Makefile	2006-07-05 22:26:39 UTC (rev 426)
@@ -1,45 +0,0 @@
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
-# Makefile for Build Tools
-#
-# Copyright (C) 2005-2006, Digium, Inc.
-#
-# Russell Bryant &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russell at digium.com</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-.PHONY: clean dist-clean
-
-MENUSELECT_OBJS=menuselect.o menuselect_curses.o
-MENUSELECT_CFLAGS=-g -c -D_GNU_SOURCE -DMENUSELECT -I../ -I../include/
-MENUSELECT_LIBS=../mxml/libmxml.a
-
-ifeq ($(OSARCH),SunOS)
-  MENUSELECT_OBJS+=../strcompat.o
-endif
-
-ifneq ($(NCURSES_LIB),)
-  MENUSELECT_LIBS+=$(NCURSES_LIB)
-  MENUSELECT_INCLUDE=$(NCURSES_INCLUDE)
-else
-  MENUSELECT_LIBS+=$(CURSES_LIB)
-  MENUSELECT_INCLUDE=$(CURSES_INCLUDE)
-endif
-
-menuselect: $(MENUSELECT_OBJS)
-	$(CC) -g -Wall -o $@ $(MENUSELECT_OBJS) $(MENUSELECT_LIBS)
-
-menuselect.o: menuselect.c menuselect.h
-	$(CC) -Wall -o $@ $(MENUSELECT_CFLAGS) $&lt;
-
-menuselect_curses.o: menuselect_curses.c menuselect.h
-	$(CC) -Wall -o $@ $(MENUSELECT_CFLAGS) $(MENUSELECT_INCLUDE) $&lt;
-
-clean:
-	rm -f menuselect *.o
-
-dist-clean: clean
-	rm -f menuselect-deps

Modified: trunk/build_tools/menuselect.c
===================================================================
--- trunk/build_tools/menuselect.c	2006-07-05 22:02:15 UTC (rev 425)
+++ trunk/build_tools/menuselect.c	2006-07-05 22:26:39 UTC (rev 426)
@@ -1,743 +0,0 @@
-/*
- * Asterisk -- An open source telephony toolkit.
- *
- * Copyright (C) 2005 - 2006, Russell Bryant
- *
- * Russell Bryant &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russell at digium.com</A>&gt;
- *
- * See <A HREF="http://www.asterisk.org">http://www.asterisk.org</A> for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*!
- * \file
- *
- * \author Russell Bryant &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russell at digium.com</A>&gt;
- * 
- * \brief A menu-driven system for Asterisk module selection
- */
-
-#include &quot;asterisk.h&quot;
-
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;unistd.h&gt;
-
-#include &quot;mxml/mxml.h&quot;
-#include &quot;menuselect.h&quot;
-
-#include &quot;asterisk/linkedlists.h&quot;
-
-#undef MENUSELECT_DEBUG
-
-/*! The list of categories */
-struct categories categories = AST_LIST_HEAD_NOLOCK_INIT_VALUE;
-
-/*!
-   We have to maintain a pointer to the root of the trees generated from reading
-   the build options XML files so that we can free it when we're done.  We don't
-   copy any of the information over from these trees. Our list is just a 
-   convenient mapping to the information contained in these lists with one
-   additional piece of information - whether the build option is enabled or not.
-*/
-struct tree {
-	/*! the root of the tree */
-	mxml_node_t *root;
-	/*! for linking */
-	AST_LIST_ENTRY(tree) list;
-};
-
-/*! The list of trees from makeopts.xml files */
-static AST_LIST_HEAD_NOLOCK_STATIC(trees, tree);
-
-static const char * const makeopts_files[] = {
-	&quot;makeopts.xml&quot;
-};
-
-static char *output_makeopts = OUTPUT_MAKEOPTS_DEFAULT;
-
-/*! This is set to 1 if menuselect.makeopts pre-existed the execution of this app */
-static int existing_config = 0;
-
-/*! This is set when the --check-deps argument is provided. */
-static int check_deps = 0;
-
-#if !defined(ast_strdupa) &amp;&amp; defined(__GNUC__)
-#define ast_strdupa(s)                                                    \
-	(__extension__                                                    \
-	({                                                                \
-		const char *__old = (s);                                  \
-		size_t __len = strlen(__old) + 1;                         \
-		char *__new = __builtin_alloca(__len);                    \
-		memcpy (__new, __old, __len);                             \
-		__new;                                                    \
-	}))
-#endif
-
-/*! \brief return a pointer to the first non-whitespace character */
-static inline char *skip_blanks(char *str)
-{
-	if (!str)
-		return NULL;
-
-	while (*str &amp;&amp; *str &lt; 33)
-		str++;
-
-	return str;
-}
-
-/*! \brief Add a category to the category list, ensuring that there are no duplicates */
-static int add_category(struct category *cat)
-{
-	struct category *tmp;
-
-	AST_LIST_TRAVERSE(&amp;categories, tmp, list) {
-		if (!strcmp(tmp-&gt;name, cat-&gt;name)) {
-			fprintf(stderr, &quot;Category '%s' specified more than once!\n&quot;, cat-&gt;name);
-			return -1;
-		}
-	}
-	AST_LIST_INSERT_TAIL(&amp;categories, cat, list);
-
-	return 0;
-}
-
-/*! \brief Add a member to the member list of a category, ensuring that there are no duplicates */
-static int add_member(struct member *mem, struct category *cat)
-{
-	struct member *tmp;
-
-	AST_LIST_TRAVERSE(&amp;cat-&gt;members, tmp, list) {
-		if (!strcmp(tmp-&gt;name, mem-&gt;name)) {
-			fprintf(stderr, &quot;Member '%s' already exists in category '%s', ignoring.\n&quot;, mem-&gt;name, cat-&gt;name);
-			return -1;
-		}
-	}
-	AST_LIST_INSERT_TAIL(&amp;cat-&gt;members, mem, list);
-
-	return 0;
-}
-
-/*! \brief Free a member structure and all of its members */
-static void free_member(struct member *mem)
-{
-	struct depend *dep;
-	struct conflict *cnf;
-
-	while ((dep = AST_LIST_REMOVE_HEAD(&amp;mem-&gt;deps, list)))
-		free(dep);
-	while ((cnf = AST_LIST_REMOVE_HEAD(&amp;mem-&gt;conflicts, list)))
-		free(cnf);
-	free(mem);
-}
-
-/*! \brief Parse an input makeopts file */
-static int parse_makeopts_xml(const char *makeopts_xml)
-{
-	FILE *f;
-	struct category *cat;
-	struct tree *tree;
-	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
-	mxml_node_t *cur;
-	mxml_node_t *cur2;
-	mxml_node_t *cur3;
-	mxml_node_t *menu;
-	const char *tmp;
-
-	if (!(f = fopen(makeopts_xml, &quot;r&quot;))) {
-		fprintf(stderr, &quot;Unable to open '%s' for reading!\n&quot;, makeopts_xml);
-		return -1;
-	}
-
-	if (!(tree = calloc(1, sizeof(*tree)))) {
-		fclose(f);
-		return -1;
-	}
-
-	if (!(tree-&gt;root = mxmlLoadFile(NULL, f, MXML_OPAQUE_CALLBACK))) {
-		fclose(f);
-		free(tree);
-		return -1;
-	}
-
-	AST_LIST_INSERT_HEAD(&amp;trees, tree, list);
-
-	menu = mxmlFindElement(tree-&gt;root, tree-&gt;root, &quot;menu&quot;, NULL, NULL, MXML_DESCEND);
-	for (cur = mxmlFindElement(menu, menu, &quot;category&quot;, NULL, NULL, MXML_DESCEND);
-	     cur;
-	     cur = mxmlFindElement(cur, menu, &quot;category&quot;, NULL, NULL, MXML_DESCEND))
-	{
-		if (!(cat = calloc(1, sizeof(*cat))))
-			return -1;
-
-		cat-&gt;name = mxmlElementGetAttr(cur, &quot;name&quot;);
-		cat-&gt;displayname = mxmlElementGetAttr(cur, &quot;displayname&quot;);
-		if ((tmp = mxmlElementGetAttr(cur, &quot;positive_output&quot;)))
-			cat-&gt;positive_output = !strcasecmp(tmp, &quot;yes&quot;);
-		cat-&gt;remove_on_change = mxmlElementGetAttr(cur, &quot;remove_on_change&quot;);
-
-		if (add_category(cat)) {
-			free(cat);
-			continue;
-		}
-
-		for (cur2 = mxmlFindElement(cur, cur, &quot;member&quot;, NULL, NULL, MXML_DESCEND);
-		     cur2;
-		     cur2 = mxmlFindElement(cur2, cur, &quot;member&quot;, NULL, NULL, MXML_DESCEND))
-		{
-			if (!(mem = calloc(1, sizeof(*mem))))
-				return -1;
-			
-			mem-&gt;name = mxmlElementGetAttr(cur2, &quot;name&quot;);
-			mem-&gt;displayname = mxmlElementGetAttr(cur2, &quot;displayname&quot;);
-		
-			mem-&gt;remove_on_change = mxmlElementGetAttr(cur2, &quot;remove_on_change&quot;);
-
-			if (!cat-&gt;positive_output)
-				mem-&gt;was_enabled = mem-&gt;enabled = 1;
-	
-			cur3 = mxmlFindElement(cur2, cur2, &quot;defaultenabled&quot;, NULL, NULL, MXML_DESCEND);
-			if (cur3 &amp;&amp; cur3-&gt;child)
-				mem-&gt;defaultenabled = cur3-&gt;child-&gt;value.opaque;
-			
-			for (cur3 = mxmlFindElement(cur2, cur2, &quot;depend&quot;, NULL, NULL, MXML_DESCEND);
-			     cur3 &amp;&amp; cur3-&gt;child;
-			     cur3 = mxmlFindElement(cur3, cur2, &quot;depend&quot;, NULL, NULL, MXML_DESCEND))
-			{
-				if (!(dep = calloc(1, sizeof(*dep)))) {
-					free_member(mem);
-					return -1;
-				}
-				if (!strlen_zero(cur3-&gt;child-&gt;value.opaque)) {
-					dep-&gt;name = cur3-&gt;child-&gt;value.opaque;
-					AST_LIST_INSERT_HEAD(&amp;mem-&gt;deps, dep, list);
-				} else
-					free(dep);
-			}
-
-			for (cur3 = mxmlFindElement(cur2, cur2, &quot;conflict&quot;, NULL, NULL, MXML_DESCEND);
-			     cur3 &amp;&amp; cur3-&gt;child;
-			     cur3 = mxmlFindElement(cur3, cur2, &quot;conflict&quot;, NULL, NULL, MXML_DESCEND))
-			{
-				if (!(cnf = calloc(1, sizeof(*cnf)))) {
-					free_member(mem);
-					return -1;
-				}
-				if (!strlen_zero(cur3-&gt;child-&gt;value.opaque)) {
-					cnf-&gt;name = cur3-&gt;child-&gt;value.opaque;
-					AST_LIST_INSERT_HEAD(&amp;mem-&gt;conflicts, cnf, list);
-				} else
-					free(cnf);
-			}
-
-			if (add_member(mem, cat))
-				free_member(mem);
-		}
-	}
-
-	fclose(f);
-
-	return 0;
-}
-
-/*! \brief Process dependencies against the input dependencies file */
-static int process_deps(void)
-{
-	struct category *cat;
-	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
-	FILE *f;
-	struct dep_file {
-		char name[32];
-		int met;
-		AST_LIST_ENTRY(dep_file) list;
-	} *dep_file;
-	AST_LIST_HEAD_NOLOCK_STATIC(deps_file, dep_file);
-	char buf[80];
-	char *p;
-	int res = 0;
-
-	if (!(f = fopen(MENUSELECT_DEPS, &quot;r&quot;))) {
-		fprintf(stderr, &quot;Unable to open '%s' for reading!  Did you run ./configure ?\n&quot;, MENUSELECT_DEPS);
-		return -1;
-	}
-
-	/* Build a dependency list from the file generated by configure */	
-	while (memset(buf, 0, sizeof(buf)), fgets(buf, sizeof(buf), f)) {
-		p = buf;
-		strsep(&amp;p, &quot;=&quot;);
-		if (!p)
-			continue;
-		if (!(dep_file = calloc(1, sizeof(*dep_file))))
-			break;
-		strncpy(dep_file-&gt;name, buf, sizeof(dep_file-&gt;name) - 1);
-		dep_file-&gt;met = atoi(p);
-		AST_LIST_INSERT_TAIL(&amp;deps_file, dep_file, list);
-	}
-
-	fclose(f);
-
-	/* Process dependencies of all modules */
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			AST_LIST_TRAVERSE(&amp;mem-&gt;deps, dep, list) {
-				mem-&gt;depsfailed = 1;
-				AST_LIST_TRAVERSE(&amp;deps_file, dep_file, list) {
-					if (!strcasecmp(dep_file-&gt;name, dep-&gt;name)) {
-						if (dep_file-&gt;met)
-							mem-&gt;depsfailed = 0;
-						break;
-					}
-				}
-				if (mem-&gt;depsfailed)
-					break; /* This dependency is not met, so we can stop now */
-			}
-		}
-	}
-
-	/* Process conflicts of all modules */
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			AST_LIST_TRAVERSE(&amp;mem-&gt;conflicts, cnf, list) {
-				mem-&gt;conflictsfailed = 0;
-				AST_LIST_TRAVERSE(&amp;deps_file, dep_file, list) {
-					if (!strcasecmp(dep_file-&gt;name, cnf-&gt;name)) {
-						if (dep_file-&gt;met)
-							mem-&gt;conflictsfailed = 1;
-						break;
-					}
-				}
-				if (mem-&gt;conflictsfailed)
-					break; /* This conflict was found, so we can stop now */
-			}
-		}
-	}
-
-	/* Free the dependency list we built from the file */
-	while ((dep_file = AST_LIST_REMOVE_HEAD(&amp;deps_file, list)))
-		free(dep_file);
-
-	return res;
-}
-
-/*! \brief Iterate through all of the input makeopts files and call the parse function on them */
-static int build_member_list(void)
-{
-	int i;
-	int res = -1;
-
-	for (i = 0; i &lt; (sizeof(makeopts_files) / sizeof(makeopts_files[0])); i++) {
-		if ((res = parse_makeopts_xml(makeopts_files[i]))) {
-			fprintf(stderr, &quot;Error parsing '%s'!\n&quot;, makeopts_files[i]);
-			break;
-		}
-	}
-
-	return res;
-}
-
-/*! \brief Given the string representation of a member and category, mark it as present in a given input file */
-static void mark_as_present(const char *member, const char *category)
-{
-	struct category *cat;
-	struct member *mem;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		if (strcmp(category, cat-&gt;name))
-			continue;
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if (!strcmp(member, mem-&gt;name)) {
-				mem-&gt;was_enabled = mem-&gt;enabled = cat-&gt;positive_output;
-				break;
-			}
-		}
-		if (!mem)
-			fprintf(stderr, &quot;member '%s' in category '%s' not found, ignoring.\n&quot;, member, category);
-		break;
-	}
-
-	if (!cat)
-		fprintf(stderr, &quot;category '%s' not found! Can't mark '%s' as disabled.\n&quot;, category, member);
-}
-
-/*! \brief Toggle a member of a category at the specified index to enabled/disabled */
-void toggle_enabled(struct category *cat, int index)
-{
-	struct member *mem;
-	int i = 0;
-
-	AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-		if (i++ == index)
-			break;
-	}
-
-	if (mem &amp;&amp; !(mem-&gt;depsfailed || mem-&gt;conflictsfailed)) {
-		mem-&gt;enabled = !mem-&gt;enabled;
-	}
-}
-
-/*! \brief Process a previously failed dependency
- *
- * If a module was previously disabled because of a failed dependency
- * or a conflict, and not because the user selected it to be that way,
- * then it needs to be re-enabled by default if the problem is no longer present.
- */
-static void process_prev_failed_deps(char *buf)
-{
-	const char *cat_name, *mem_name;
-	struct category *cat;
-	struct member *mem;
-
-	cat_name = strsep(&amp;buf, &quot;=&quot;);
-	mem_name = strsep(&amp;buf, &quot;\n&quot;);
-
-	if (!cat_name || !mem_name)
-		return;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		if (strcasecmp(cat-&gt;name, cat_name))
-			continue;
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if (strcasecmp(mem-&gt;name, mem_name))
-				continue;
-
-			if (!mem-&gt;depsfailed &amp;&amp; !mem-&gt;conflictsfailed)
-				mem-&gt;enabled = 1;			
-	
-			break;
-		}
-		break;	
-	}
-
-	if (!cat || !mem)
-		fprintf(stderr, &quot;Unable to find '%s' in category '%s'\n&quot;, mem_name, cat_name);
-}
-
-/*! \brief Parse an existing output makeopts file and enable members previously selected */
-static int parse_existing_config(const char *infile)
-{
-	FILE *f;
-	char buf[2048];
-	char *category, *parse, *member;
-	int lineno = 0;
-
-	if (!(f = fopen(infile, &quot;r&quot;))) {
-#ifdef MENUSELECT_DEBUG
-		/* This isn't really an error, so only print the message in debug mode */
-		fprintf(stderr, &quot;Unable to open '%s' for reading existing config.\n&quot;, infile);
-#endif	
-		return -1;
-	}
-
-	while (fgets(buf, sizeof(buf), f)) {
-		lineno++;
-
-		if (strlen_zero(buf))
-			continue;
-
-		/* skip lines that are not for this tool */
-		if (strncasecmp(buf, &quot;MENUSELECT_&quot;, strlen(&quot;MENUSELECT_&quot;)))
-			continue;
-
-		parse = buf;
-		parse = skip_blanks(parse);
-		if (strlen_zero(parse))
-			continue;
-
-		/* Grab the category name */	
-		category = strsep(&amp;parse, &quot;=&quot;);
-		if (!parse) {
-			fprintf(stderr, &quot;Invalid string in '%s' at line '%d'!\n&quot;, output_makeopts, lineno);
-			continue;
-		}
-		
-		parse = skip_blanks(parse);
-	
-		if (!strcasecmp(category, &quot;MENUSELECT_DEPSFAILED&quot;)) {
-			process_prev_failed_deps(parse);
-			continue;
-		}
-	
-		while ((member = strsep(&amp;parse, &quot; \n&quot;))) {
-			member = skip_blanks(member);
-			if (strlen_zero(member))
-				continue;
-			mark_as_present(member, category);
-		}
-	}
-
-	fclose(f);
-
-	return 0;
-}
-
-/*! \brief Create the output makeopts file that results from the user's selections */
-static int generate_makeopts_file(void)
-{
-	FILE *f;
-	struct category *cat;
-	struct member *mem;
-
-	if (!(f = fopen(output_makeopts, &quot;w&quot;))) {
-		fprintf(stderr, &quot;Unable to open build configuration file (%s) for writing!\n&quot;, output_makeopts);
-		return -1;
-	}
-
-	/* Traverse all categories and members and output them as var/val pairs */
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		fprintf(f, &quot;%s=&quot;, cat-&gt;name);
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if ((!cat-&gt;positive_output &amp;&amp; (!mem-&gt;enabled || mem-&gt;depsfailed || mem-&gt;conflictsfailed)) ||
-			    (cat-&gt;positive_output &amp;&amp; mem-&gt;enabled &amp;&amp; !mem-&gt;depsfailed &amp;&amp; !mem-&gt;conflictsfailed))
-				fprintf(f, &quot;%s &quot;, mem-&gt;name);
-		}
-		fprintf(f, &quot;\n&quot;);
-	}
-
-	/* Output which members were disabled because of failed dependencies or conflicts */
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if (mem-&gt;depsfailed || mem-&gt;conflictsfailed)
-				fprintf(f, &quot;MENUSELECT_DEPSFAILED=%s=%s\n&quot;, cat-&gt;name, mem-&gt;name);
-		}
-	}
-
-	fclose(f);
-
-	/* Traverse all categories and members and remove any files that are supposed
-	   to be removed when an item has been changed */
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		unsigned int had_changes = 0;
-		char *file, *buf;
-
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if (mem-&gt;enabled == mem-&gt;was_enabled)
-				continue;
-
-			had_changes = 1;
-
-			if (mem-&gt;remove_on_change) {
-				for (buf = ast_strdupa(mem-&gt;remove_on_change), file = strsep(&amp;buf, &quot; &quot;);
-				     file;
-				     file = strsep(&amp;buf, &quot; &quot;))
-					unlink(file);
-			}
-		}
-
-		if (cat-&gt;remove_on_change &amp;&amp; had_changes) {
-			for (buf = ast_strdupa(cat-&gt;remove_on_change), file = strsep(&amp;buf, &quot; &quot;);
-			     file;
-			     file = strsep(&amp;buf, &quot; &quot;))
-				unlink(file);
-		}
-	}
-
-	return 0;
-}
-
-#ifdef MENUSELECT_DEBUG
-/*! \brief Print out all of the information contained in our tree */
-static void dump_member_list(void)
-{
-	struct category *cat;
-	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		fprintf(stderr, &quot;Category: '%s'\n&quot;, cat-&gt;name);
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			fprintf(stderr, &quot;   ==&gt;&gt; Member: '%s'  (%s)&quot;, mem-&gt;name, mem-&gt;enabled ? &quot;Enabled&quot; : &quot;Disabled&quot;);
-			fprintf(stderr, &quot;        Was %s\n&quot;, mem-&gt;was_enabled ? &quot;Enabled&quot; : &quot;Disabled&quot;);
-			AST_LIST_TRAVERSE(&amp;mem-&gt;deps, dep, list)
-				fprintf(stderr, &quot;      --&gt; Depends on: '%s'\n&quot;, dep-&gt;name);
-			if (!AST_LIST_EMPTY(&amp;mem-&gt;deps))
-				fprintf(stderr, &quot;      --&gt; Dependencies Met: %s\n&quot;, mem-&gt;depsfailed ? &quot;No&quot; : &quot;Yes&quot;);	
-			AST_LIST_TRAVERSE(&amp;mem-&gt;conflicts, cnf, list)
-				fprintf(stderr, &quot;      --&gt; Conflicts with: '%s'\n&quot;, cnf-&gt;name);
-			if (!AST_LIST_EMPTY(&amp;mem-&gt;conflicts))
-				fprintf(stderr, &quot;      --&gt; Conflicts Found: %s\n&quot;, mem-&gt;conflictsfailed ? &quot;Yes&quot; : &quot;No&quot;);
-		}
-	}
-}
-#endif
-
-/*! \brief Free all categories and their members */
-static void free_member_list(void)
-{
-	struct category *cat;
-	struct member *mem;
-	struct depend *dep;
-	struct conflict *cnf;
-
-	while ((cat = AST_LIST_REMOVE_HEAD(&amp;categories, list))) {
-		while ((mem = AST_LIST_REMOVE_HEAD(&amp;cat-&gt;members, list))) {
-			while ((dep = AST_LIST_REMOVE_HEAD(&amp;mem-&gt;deps, list)))
-				free(dep);
-			while ((cnf = AST_LIST_REMOVE_HEAD(&amp;mem-&gt;conflicts, list)))
-				free(cnf);
-			free(mem);
-		}
-		free(cat);
-	}
-}
-
-/*! \brief Free all of the XML trees */
-static void free_trees(void)
-{
-	struct tree *tree;
-
-	while ((tree = AST_LIST_REMOVE_HEAD(&amp;trees, list))) {
-		mxmlDelete(tree-&gt;root);
-		free(tree);
-	}
-}
-
-/*! \brief Enable/Disable all members of a category as long as dependencies have been met and no conflicts are found */
-void set_all(struct category *cat, int val)
-{
-	struct member *mem;
-
-	AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-		if (!(mem-&gt;depsfailed || mem-&gt;conflictsfailed))
-			mem-&gt;enabled = val;
-	}
-}
-
-int count_categories(void)
-{
-	struct category *cat;
-	int count = 0;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list)
-		count++;
-
-	return count;		
-}
-
-int count_members(struct category *cat)
-{
-	struct member *mem;
-	int count = 0;
-
-	AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list)
-		count++;
-
-	return count;		
-}
-
-/*! \brief Make sure an existing menuselect.makeopts disabled everything it should have */
-static int sanity_check(void)
-{
-	struct category *cat;
-	struct member *mem;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if ((mem-&gt;depsfailed || mem-&gt;conflictsfailed) &amp;&amp; mem-&gt;enabled) {
-				fprintf(stderr, &quot;\n***********************************************************\n&quot;
-				                &quot;  The existing menuselect.makeopts file did not specify    \n&quot;
-				                &quot;  that '%s' should not be included.  However, either some  \n&quot;
-				                &quot;  dependencies for this module were not found or a         \n&quot;
-				                &quot;  conflict exists.                                         \n&quot;
-				                &quot;                                                           \n&quot;
-				                &quot;  Either run 'make menuselect' or remove the existing      \n&quot;
-				                &quot;  menuselect.makeopts file to resolve this issue.          \n&quot;
-						&quot;***********************************************************\n\n&quot;, mem-&gt;name);
-				return -1;
-			}
-		}
-	}
-	return 0;	/* all good... */
-}
-
-/* \brief Set the forced default values if they exist */
-static void process_defaults(void)
-{
-	struct category *cat;
-	struct member *mem;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			if (!mem-&gt;defaultenabled)
-				continue;
-			
-			if (!strcasecmp(mem-&gt;defaultenabled, &quot;yes&quot;))
-				mem-&gt;enabled = 1;
-			else if (!strcasecmp(mem-&gt;defaultenabled, &quot;no&quot;))
-				mem-&gt;enabled = 0;
-			else
-				fprintf(stderr, &quot;Invalid defaultenabled value for '%s' in category '%s'\n&quot;, mem-&gt;name, cat-&gt;name);	
-		}
-	}
-
-}
-
-int main(int argc, char *argv[])
-{
-	int res = 0;
-	unsigned int x;
-
-	/* Parse the input XML files to build the list of available options */
-	if ((res = build_member_list()))
-		exit(res);
-	
-	/* Process module dependencies */
-	if ((res = process_deps()))
-		exit(res);
-	
-	/* The --check-deps option is used to ask this application to check to
-	 * see if that an existing menuselect.makeopts file contails all of the
-	 * modules that have dependencies that have not been met.  If this
-	 * is not the case, an informative message will be printed to the
-	 * user and the build will fail. */
-	for (x = 1; x &lt; argc; x++) {
-		if (!strcmp(argv[x], &quot;--check-deps&quot;))
-			check_deps = 1;
-		else {
-			res = parse_existing_config(argv[x]);
-			if (!res &amp;&amp; !strcasecmp(argv[x], OUTPUT_MAKEOPTS_DEFAULT))
-				existing_config = 1;
-			res = 0;
-		}
-	}
-
-#ifdef MENUSELECT_DEBUG
-	/* Dump the list produced by parsing the various input files */
-	dump_member_list();
-#endif
-
-	if (!existing_config)
-		process_defaults();
-	else if (check_deps)
-		res = sanity_check();
-
-	/* Run the menu to let the user enable/disable options */
-	if (!check_deps &amp;&amp; !res)
-		res = run_menu();
-
-	/* Write out the menuselect.makeopts file if
-	 * 1) menuselect was not executed with --check-deps
-	 * 2) menuselect was executed with --check-deps but menuselect.makeopts
-	 *    did not already exist.
-	 */
-	if ((!check_deps || !existing_config) &amp;&amp; !res)
-		res = generate_makeopts_file();
-	
-	/* free everything we allocated */
-	free_trees();
-	free_member_list();
-
-	exit(res);
-}

Modified: trunk/build_tools/menuselect.h
===================================================================
--- trunk/build_tools/menuselect.h	2006-07-05 22:02:15 UTC (rev 425)
+++ trunk/build_tools/menuselect.h	2006-07-05 22:26:39 UTC (rev 426)
@@ -1,109 +0,0 @@
-/*
- * Asterisk -- An open source telephony toolkit.
- *
- * Copyright (C) 2005-2006, Russell Bryant
- *
- * Russell Bryant &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russell at digium.com</A>&gt;
- *
- * See <A HREF="http://www.asterisk.org">http://www.asterisk.org</A> for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*!
- * \file
- *
- * \brief public data structures and defaults for menuselect
- *
- */
-
-#ifndef MENUSELECT_H
-#define MENUSELECT_H
-
-#include &quot;asterisk/linkedlists.h&quot;
-
-#define OUTPUT_MAKEOPTS_DEFAULT &quot;menuselect.makeopts&quot;
-#define MENUSELECT_DEPS         &quot;build_tools/menuselect-deps&quot;
-
-struct depend {
-	/*! the name of the dependency */
-	const char *name;
-	/*! for linking */
-	AST_LIST_ENTRY(depend) list;
-};
-
-struct conflict {
-	/*! the name of the conflict */
-	const char *name;
-	/*! for linking */
-	AST_LIST_ENTRY(conflict) list;
-};
-
-struct member {
-	/*! What will be sent to the makeopts file */
-	const char *name;
-	/*! Display name if known */
-	const char *displayname;
-	/*! Default setting */
-	const char *defaultenabled;
-	/*! Delete these file(s) if this member changes */
-	const char *remove_on_change;
-	/*! This module is currently selected */
-	unsigned int enabled:1;
-	/*! This module was enabled when the config was loaded */
-	unsigned int was_enabled:1;
-	/*! This module has failed dependencies */
-	unsigned int depsfailed:1;
-	/*! This module has failed conflicts */
-	unsigned int conflictsfailed:1;
-	/*! dependencies of this module */
-	AST_LIST_HEAD_NOLOCK(, depend) deps;
-	/*! conflicts of this module */
-	AST_LIST_HEAD_NOLOCK(, conflict) conflicts;
-	/*! for making a list of modules */
-	AST_LIST_ENTRY(member) list;
-};
-
-struct category {
-	/*! the Makefile variable */
-	const char *name;
-	/*! the name displayed in the menu */
-	const char *displayname;
-	/*! Delete these file(s) if anything in this category changes */
-	const char *remove_on_change;
-	/*! Output what is selected, as opposed to not selected */
-	unsigned int positive_output:1;
-	/*! the list of possible values to be set in this variable */
-	AST_LIST_HEAD_NOLOCK(, member) members;
-	/*! for linking */
-	AST_LIST_ENTRY(category) list;
-};
-
-extern AST_LIST_HEAD_NOLOCK(categories, category) categories;
-
-/*! This is implemented by the frontend */
-int run_menu(void);
-
-int count_categories(void);
-
-int count_members(struct category *cat);
-
-/*! \brief Toggle a member of a category at the specified index to enabled/disabled */
-void toggle_enabled(struct category *cat, int index);
-
-/*! \brief Enable/Disable all members of a category as long as dependencies have been met and no conflicts are found */
-void set_all(struct category *cat, int val);
-
-/*! \brief returns non-zero if the string is not defined, or has zero length */
-static inline int strlen_zero(const char *s)
-{
-	return (!s || (*s == '\0'));
-}
-
-#endif /* MENUSELECT_H */

Modified: trunk/build_tools/menuselect_curses.c
===================================================================
--- trunk/build_tools/menuselect_curses.c	2006-07-05 22:02:15 UTC (rev 425)
+++ trunk/build_tools/menuselect_curses.c	2006-07-05 22:26:39 UTC (rev 426)
@@ -1,374 +0,0 @@
-/*
- * Asterisk -- An open source telephony toolkit.
- *
- * Copyright (C) 2005 - 2006, Russell Bryant
- *
- * Russell Bryant &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russell at digium.com</A>&gt;
- *
- * See <A HREF="http://www.asterisk.org">http://www.asterisk.org</A> for more information about
- * the Asterisk project. Please do not directly contact
- * any of the maintainers of this project for assistance;
- * the project provides a web site, mailing lists and IRC
- * channels for your use.
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License Version 2. See the LICENSE file
- * at the top of the source tree.
- */
-
-/*
- * \file
- *
- * \author Russell Bryant &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">russell at digium.com</A>&gt;
- * 
- * \brief curses frontend for Asterisk module selection
- */
-
-#include &quot;asterisk/autoconfig.h&quot;
-
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;curses.h&gt;
-
-#include &quot;menuselect.h&quot;
-
-#define MENU_TITLE1	&quot;*************************************&quot;
-#define MENU_TITLE2	&quot;*     Asterisk Module Selection     *&quot;
-#define MENU_TITLE3	&quot;*************************************&quot;
-#define MENU_HELP	&quot;Press 'h' for help.&quot;
-
-#define TITLE_HEIGHT	7
-
-#define MIN_X		80
-#define MIN_Y		20
-
-#define PAGE_OFFSET	10
-
-
-/*! Maximum number of characters horizontally */
-static int max_x = 0;
-/*! Maximum number of characters vertically */
-static int max_y = 0;
-
-static const char * const help_info[] = {
-	&quot;scroll        =&gt; up/down arrows&quot;,
-	&quot;(de)select    =&gt; Enter&quot;,
-	&quot;select all    =&gt; F8&quot;,
-	&quot;deselect all  =&gt; F7&quot;,
-	&quot;back          =&gt; left arrow&quot;,
-	&quot;quit          =&gt; q&quot;,
-	&quot;save and quit =&gt; x&quot;,
-	&quot;&quot;,
-	&quot;XXX means dependencies have not been met&quot;
-};
-
-/*! \brief Handle a window resize in xterm */
-static void winch_handler(int sig)
-{
-	getmaxyx(stdscr, max_y, max_x);
-
-	if (max_x &lt; MIN_X - 1 || max_y &lt; MIN_Y - 1) {
-		fprintf(stderr, &quot;Terminal must be at least 80 x 25.\n&quot;);
-		max_x = MIN_X - 1;
-		max_y = MIN_Y - 1;
-	}
-}
-
-/*! \brief Display help information */
-static void show_help(WINDOW *win)
-{
-	int i;
-
-	wclear(win);
-	for (i = 0; i &lt; (sizeof(help_info) / sizeof(help_info[0])); i++) {
-		wmove(win, i, max_x / 2 - 15);
-		waddstr(win, help_info[i]);
-	}
-	wrefresh(win);
-	getch(); /* display the help until the user hits a key */
-}
-
-static void draw_main_menu(WINDOW *menu, int curopt)
-{
-	struct category *cat;
-	char buf[64];
-	int i = 0;
-
-	wclear(menu);
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		wmove(menu, i++, max_x / 2 - 10);
-		if (!strlen_zero(cat-&gt;displayname))
-			snprintf(buf, sizeof(buf), &quot;%d.%s %s&quot;, i, i &lt; 10 ? &quot; &quot; : &quot;&quot;, cat-&gt;displayname);
-		else
-			snprintf(buf, sizeof(buf), &quot;%d.%s %s&quot;, i, i &lt; 10 ? &quot; &quot; : &quot;&quot;, cat-&gt;name);
-		waddstr(menu, buf);
-	}
-
-	wmove(menu, curopt, (max_x / 2) - 15);
-	waddstr(menu, &quot;---&gt;&quot;);
-	wmove(menu, 0, 0);
-
-	wrefresh(menu);
-}
-
-static void display_mem_info(WINDOW *menu, struct member *mem, int start, int end)
-{
-	char buf[64];
-	struct depend *dep;
-	struct conflict *con;
-
-	wmove(menu, end - start + 2, max_x / 2 - 16);
-	wclrtoeol(menu);
-	wmove(menu, end - start + 3, max_x / 2 - 16);
-	wclrtoeol(menu);
-	wmove(menu, end - start + 4, max_x / 2 - 16);
-	wclrtoeol(menu);
-
-	if (mem-&gt;displayname) {
-		wmove(menu, end - start + 2, max_x / 2 - 16);
-		waddstr(menu, mem-&gt;displayname);
-	}
-	if (!AST_LIST_EMPTY(&amp;mem-&gt;deps)) {
-		wmove(menu, end - start + 3, max_x / 2 - 16);
-		strcpy(buf, &quot;Depends on: &quot;);
-		AST_LIST_TRAVERSE(&amp;mem-&gt;deps, dep, list) {
-			strncat(buf, dep-&gt;name, sizeof(buf) - strlen(buf) - 1);
-			if (AST_LIST_NEXT(dep, list))
-				strncat(buf, &quot;, &quot;, sizeof(buf) - strlen(buf) - 1);
-		}
-		waddstr(menu, buf);
-	}
-	if (!AST_LIST_EMPTY(&amp;mem-&gt;conflicts)) {
-		wmove(menu, end - start + 4, max_x / 2 - 16);
-		strcpy(buf, &quot;Conflicts with: &quot;);
-		AST_LIST_TRAVERSE(&amp;mem-&gt;conflicts, con, list) {
-			strncat(buf, con-&gt;name, sizeof(buf) - strlen(buf) - 1);
-			if (AST_LIST_NEXT(con, list))
-				strncat(buf, &quot;, &quot;, sizeof(buf) - strlen(buf) - 1);
-		}
-		waddstr(menu, buf);
-	}
-
-}
-
-static void draw_category_menu(WINDOW *menu, struct category *cat, int start, int end, int curopt, int changed)
-{
-	int i = 0;
-	int j = 0;
-	struct member *mem;
-	char buf[64];
-
-	if (!changed) {
-		/* If all we have to do is move the cursor, 
-		 * then don't clear the screen and start over */
-		AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-			i++;
-			if (curopt + 1 == i) {
-				display_mem_info(menu, mem, start, end);
-				break;
-			}
-		}
-		wmove(menu, curopt - start, max_x / 2 - 9);
-		wrefresh(menu);
-		return;
-	}
-
-	wclear(menu);
-
-	i = 0;
-	AST_LIST_TRAVERSE(&amp;cat-&gt;members, mem, list) {
-		if (i &lt; start) {
-			i++;
-			continue;
-		}
-		wmove(menu, j++, max_x / 2 - 10);
-		i++;
-		if (mem-&gt;depsfailed)
-			snprintf(buf, sizeof(buf), &quot;XXX %d.%s %s&quot;, i, i &lt; 10 ? &quot; &quot; : &quot;&quot;, mem-&gt;name);
-		else
-			snprintf(buf, sizeof(buf), &quot;[%s] %d.%s %s&quot;, mem-&gt;enabled ? &quot;*&quot; : &quot; &quot;, i, i &lt; 10 ? &quot; &quot; : &quot;&quot;, mem-&gt;name);
-		waddstr(menu, buf);
-		
-		if (curopt + 1 == i)
-			display_mem_info(menu, mem, start, end);
-
-		if (i == end)
-			break;
-	}
-
-	wmove(menu, curopt - start, max_x / 2 - 9);
-	wrefresh(menu);
-}
-
-static int run_category_menu(WINDOW *menu, int cat_num)
-{
-	struct category *cat;
-	int i = 0;
-	int start = 0;
-	int end = max_y - TITLE_HEIGHT - 6;
-	int c;
-	int curopt = 0;
-	int maxopt;
-	int changed = 1;
-
-	AST_LIST_TRAVERSE(&amp;categories, cat, list) {
-		if (i++ == cat_num)
-			break;
-	}
-	if (!cat)
-		return -1;
-
-	maxopt = count_members(cat) - 1;
-
-	draw_category_menu(menu, cat, start, end, curopt, changed);
-
-	while ((c = getch())) {
-		changed = 0;
-		switch (c) {
-		case KEY_UP:
-			if (curopt &gt; 0) {
-				curopt--;
-				if (curopt &lt; start) {
-					start--;
-					end--;
-					changed = 1;
-				}
-			}
-			break;
-		case KEY_DOWN:
-			if (curopt &lt; maxopt) {
-				curopt++;
-				if (curopt &gt; end - 1) {
-					start++;
-					end++;
-					changed = 1;
-				}
-			}
-			break;
-		case KEY_NPAGE:
-			/* XXX Move down the list by PAGE_OFFSET */
-			break;
-		case KEY_PPAGE:
-			/* XXX Move up the list by PAGE_OFFSET */
-			break;
-		case KEY_LEFT:
-		case 27:	/* Esc key */
-			return 0;
-		case KEY_RIGHT:
-		case KEY_ENTER:
-		case '\n':
-		case ' ':
-			toggle_enabled(cat, curopt);
-			changed = 1;
-			break;
-		case 'h':
-		case 'H':
-			show_help(menu);
-			changed = 1;
-			break;
-		case KEY_F(7):
-			set_all(cat, 0);
-			changed = 1;
-			break;
-		case KEY_F(8):
-			set_all(cat, 1);
-			changed = 1;
-		default:
-			break;	
-		}
-		if (c == 'x' || c == 'X' || c == 'Q' || c == 'q')
-			break;	
-		draw_category_menu(menu, cat, start, end, curopt, changed);
-	}
-
-	wrefresh(menu);
-
-	return c;
-}
-
-static void draw_title_window(WINDOW *title)
-{
-	wmove(title, 1, (max_x / 2) - (strlen(MENU_TITLE1) / 2));
-	waddstr(title, MENU_TITLE1);
-	wmove(title, 2, (max_x / 2) - (strlen(MENU_TITLE2) / 2));
-	waddstr(title, MENU_TITLE2);
-	wmove(title, 3, (max_x / 2) - (strlen(MENU_TITLE3) / 2));
-	waddstr(title, MENU_TITLE3);
-	wmove(title, 5, (max_x / 2) - (strlen(MENU_HELP) / 2));
-	waddstr(title, MENU_HELP);
-	wrefresh(title);
-}
-
-
-
-int run_menu(void)
-{
-	WINDOW *title;
-	WINDOW *menu;
-	int maxopt;
-	int curopt = 0;
-	int c;
-	int res = 0;
-
-	initscr();
-	getmaxyx(stdscr, max_y, max_x);
-	signal(SIGWINCH, winch_handler); /* handle window resizing in xterm */
-
-	if (max_x &lt; MIN_X - 1 || max_y &lt; MIN_Y - 1) {
-		fprintf(stderr, &quot;Terminal must be at least %d x %d.\n&quot;, MIN_X, MIN_Y);
-		endwin();
-		return -1;
-	}
-
-	cbreak(); /* don't buffer input until the enter key is pressed */
-	noecho(); /* don't echo user input to the screen */
-	keypad(stdscr, TRUE); /* allow the use of arrow keys */
-	clear();
-	refresh();
-
-	maxopt = count_categories() - 1;
-	
-	/* We have two windows - the title window at the top, and the menu window gets the rest */
-	title = newwin(TITLE_HEIGHT, max_x, 0, 0);
-	menu = newwin(max_y - TITLE_HEIGHT, max_x, TITLE_HEIGHT, 0);
-	draw_title_window(title);	
-	draw_main_menu(menu, curopt);
-	
-	while ((c = getch())) {
-		switch (c) {
-		case KEY_UP:
-			if (curopt &gt; 0)
-				curopt--;
-			break;
-		case KEY_DOWN:
-			if (curopt &lt; maxopt)
-				curopt++;
-			break;
-		case KEY_RIGHT:
-		case KEY_ENTER:
-		case '\n':
-		case ' ':
-			c = run_category_menu(menu, curopt);
-			break;
-		case 'h':
-		case 'H':
-			show_help(menu);
-		default:
-			break;	
-		}
-		if (c == 'q' || c == 'Q' || c == 27) {
-			res = -1;
-			break;
-		}
-		if (c == 'x' || c == 'X' || c == 's' || c == 'S')
-			break;	
-		draw_main_menu(menu, curopt);
-	}
-
-	endwin();
-
-	return res;
-}


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	<LI>Previous message: <A HREF="000420.html">[solid-pbx-svn] r425 - trunk/apps
</A></li>
	
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#421">[ date ]</a>
              <a href="thread.html#421">[ thread ]</a>
              <a href="subject.html#421">[ subject ]</a>
              <a href="author.html#421">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
