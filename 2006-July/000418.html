<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
 <HEAD>
   <TITLE> [solid-pbx-svn] r423 - in trunk: . apps channels codecs codecs/gsm codecs/gsm/inc codecs/gsm/src configs formats include/asterisk pbx
   </TITLE>
   <LINK REL="Index" HREF="http://lists.berlios.de/pipermail/solid-pbx-svn/2006-July/index.html" >
   <LINK REL="made" HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r423%20-%20in%20trunk%3A%20.%20apps%20channels%20codecs%20codecs/gsm%20codecs/gsm/inc%20codecs/gsm/src%20configs%20formats%20include/asterisk%20pbx&In-Reply-To=%3C200607052155.k65LtZkv007722%40sheep.berlios.de%3E">
   <META NAME="robots" CONTENT="index,nofollow">
   <style type="text/css">
       pre {
           white-space: pre-wrap;       /* css-2.1, curent FF, Opera, Safari */
           }
   </style>
   <META http-equiv="Content-Type" content="text/html; charset=us-ascii">
   
   <LINK REL="Next"  HREF="000419.html">
 </HEAD>
 <BODY BGCOLOR="#ffffff">
   <H1>[solid-pbx-svn] r423 - in trunk: . apps channels codecs codecs/gsm codecs/gsm/inc codecs/gsm/src configs formats include/asterisk pbx</H1>
    <B>solid-pbx-svn-admin at lists.berlios.de</B> 
    <A HREF="mailto:solid-pbx-svn%40lists.berlios.de?Subject=Re%3A%20%5Bsolid-pbx-svn%5D%20r423%20-%20in%20trunk%3A%20.%20apps%20channels%20codecs%20codecs/gsm%20codecs/gsm/inc%20codecs/gsm/src%20configs%20formats%20include/asterisk%20pbx&In-Reply-To=%3C200607052155.k65LtZkv007722%40sheep.berlios.de%3E"
       TITLE="[solid-pbx-svn] r423 - in trunk: . apps channels codecs codecs/gsm codecs/gsm/inc codecs/gsm/src configs formats include/asterisk pbx">solid-pbx-svn-admin at lists.berlios.de
       </A><BR>
    <I>Wed Jul  5 23:55:35 CEST 2006</I>
    <P><UL>
        
        <LI>Next message: <A HREF="000419.html">[solid-pbx-svn] r424 - in trunk: . res
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#418">[ date ]</a>
              <a href="thread.html#418">[ thread ]</a>
              <a href="subject.html#418">[ subject ]</a>
              <a href="author.html#418">[ author ]</a>
         </LI>
       </UL>
    <HR>  
<!--beginarticle-->
<PRE>Author: casper2
Date: 2006-07-05 23:55:19 +0200 (Wed, 05 Jul 2006)
New Revision: 423

Modified:
   trunk/BUGS
   trunk/CREDITS
   trunk/LICENSE
   trunk/Makefile
   trunk/README
   trunk/apps/Makefile
   trunk/apps/app_dial.c
   trunk/apps/app_directory.c
   trunk/apps/app_mp3.c
   trunk/apps/app_playback.c
   trunk/apps/app_voicemail.c
   trunk/asterisk.c
   trunk/channel.c
   trunk/channels/DialTone.h
   trunk/channels/Makefile
   trunk/codecs/Makefile
   trunk/codecs/codec_g723_1.c
   trunk/codecs/codec_gsm.c
   trunk/codecs/g723_slin_ex.h
   trunk/codecs/gsm/COPYRIGHT
   trunk/codecs/gsm/Makefile
   trunk/codecs/gsm/README
   trunk/codecs/gsm/inc/config.h
   trunk/codecs/gsm/inc/gsm.h
   trunk/codecs/gsm/inc/private.h
   trunk/codecs/gsm/inc/proto.h
   trunk/codecs/gsm/inc/unproto.h
   trunk/codecs/gsm/src/add.c
   trunk/codecs/gsm/src/code.c
   trunk/codecs/gsm/src/debug.c
   trunk/codecs/gsm/src/decode.c
   trunk/codecs/gsm/src/gsm_create.c
   trunk/codecs/gsm/src/gsm_decode.c
   trunk/codecs/gsm/src/gsm_destroy.c
   trunk/codecs/gsm/src/gsm_encode.c
   trunk/codecs/gsm/src/gsm_explode.c
   trunk/codecs/gsm/src/gsm_implode.c
   trunk/codecs/gsm/src/gsm_option.c
   trunk/codecs/gsm/src/gsm_print.c
   trunk/codecs/gsm/src/long_term.c
   trunk/codecs/gsm/src/lpc.c
   trunk/codecs/gsm/src/preprocess.c
   trunk/codecs/gsm/src/rpe.c
   trunk/codecs/gsm/src/short_term.c
   trunk/codecs/gsm/src/table.c
   trunk/codecs/gsm_slin_ex.h
   trunk/codecs/slin_g723_ex.h
   trunk/codecs/slin_gsm_ex.h
   trunk/configs/adtranvofr.conf.sample
   trunk/configs/extensions.conf.sample
   trunk/configs/modules.conf.sample
   trunk/configs/voicemail.conf.sample
   trunk/file.c
   trunk/formats/Makefile
   trunk/formats/format_g723.c
   trunk/formats/format_wav.c
   trunk/frame.c
   trunk/include/asterisk/channel.h
   trunk/include/asterisk/file.h
   trunk/include/asterisk/frame.h
   trunk/include/asterisk/module.h
   trunk/include/asterisk/say.h
   trunk/include/asterisk/translate.h
   trunk/loader.c
   trunk/logger.c
   trunk/pbx.c
   trunk/pbx/Makefile
   trunk/pbx/pbx_gtkconsole.c
   trunk/pbx/pbx_kdeconsole.cc
   trunk/pbx/pbx_kdeconsole.h
   trunk/pbx/pbx_kdeconsole_main.cc
   trunk/say.c
   trunk/translate.c
Log:
Revert back to r416

Modified: trunk/BUGS
===================================================================
--- trunk/BUGS	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/BUGS	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,12 +1,3 @@
-* EVERYTHING MARKED WITH &quot;XXX&quot; IN THE SOURCE REPRESENTS A BUG!  Sometimes
-  these bugs are in asterisk, and sometimes they relate to the products
-  that asterisk uses.
-
-* The MP3 decoder is completely broken
-
-* The translator API may introduce warble in the case of going in both
-  directions, but I haven't verified that.  The trouble should only enter
-  in the case of mismatched frame lengths.
 Solid PBX Bug Tracking Information
 =================================
 

Modified: trunk/CREDITS
===================================================================
--- trunk/CREDITS	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/CREDITS	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,56 +1,4 @@
-=== HARDWARE DONORS === 
 
-* Special thanks to Adtran, Inc, for their donation of an Adtran Atlas,
-and TSU 120e to the project. (<A HREF="http://www.adtran.com">http://www.adtran.com</A>)
-
-* Thanks to QuickNet Technologies for their donation of an Internet
-PhoneJack card to the project.  (<A HREF="http://www.quicknet.net">http://www.quicknet.net</A>)
-
-=== OTHER SOURCE CODE IN ASTERISK ===
-
-I did not implement the codecs in asterisk.  Here is the copyright on the
-GSM source:
-
-Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
-Technische Universitaet Berlin
-
-Any use of this software is permitted provided that this notice is not
-removed and that neither the authors nor the Technische Universitaet Berlin
-are deemed to have made any representations as to the suitability of this
-software for any purpose nor are held responsible for any defects of
-this software.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
-
-As a matter of courtesy, the authors request to be informed about uses
-this software has found, about bugs in this software, and about any
-improvements that may be of general interest.
-
-Berlin, 28.11.1994
-Jutta Degener
-Carsten Bormann
-
-And the copyright on the ADPCM source:
-
-Copyright 1992 by Stichting Mathematisch Centrum, Amsterdam, The
-Netherlands.
-
-                        All Rights Reserved
-
-Permission to use, copy, modify, and distribute this software and its
-documentation for any purpose and without fee is hereby granted,
-provided that the above copyright notice appear in all copies and that
-both that copyright notice and this permission notice appear in
-supporting documentation, and that the names of Stichting Mathematisch
-Centrum or CWI not be used in advertising or publicity pertaining to
-distribution of the software without specific, written prior permission.
-
-STICHTING MATHEMATISCH CENTRUM DISCLAIMS ALL WARRANTIES WITH REGARD TO
-THIS SOFTWARE, INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND
-FITNESS, IN NO EVENT SHALL STICHTING MATHEMATISCH CENTRUM BE LIABLE
-FOR ANY SPECIAL, INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
-WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
-ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT
-OF OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
-
 === DEVELOPMENT SUPPORT ===
 We'd like to thank the following companies for helping fund development of
 Asterisk:

Modified: trunk/LICENSE
===================================================================
--- trunk/LICENSE	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/LICENSE	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,363 +1,3 @@
-=================================================================
-Please note that Asterisk is distributed under the GNU General 
-Public License, with the following additional notices (some of
-these notices may be revised or relaxed in future releases):
-
-	a) All distributions or derivative works MUST not remove
-the name of Linux Support Services, LLC or Adtran, Inc. from 
-the product.
-
-	b) Some codecs included in the full Asterisk distribution
-*may* be covered by software patents.  
-
-	c) If You bring legal action against an organization or 
-individual for patent infringement regarding any Open Source 
-software (as defined by the Open Source Definition available at
-<A HREF="http://www.opensource.org/osd.html">http://www.opensource.org/osd.html</A>) then your right to use and/or
-distribute this software is immediately terminated.
-
-=================================================================
-
-		    GNU GENERAL PUBLIC LICENSE
-		       Version 2, June 1991
-
- Copyright (C) 1989, 1991 Free Software Foundation, Inc.
-                       59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
- Everyone is permitted to copy and distribute verbatim copies
- of this license document, but changing it is not allowed.
-
-			    Preamble
-
-  The licenses for most software are designed to take away your
-freedom to share and change it.  By contrast, the GNU General Public
-License is intended to guarantee your freedom to share and change free
-software--to make sure the software is free for all its users.  This
-General Public License applies to most of the Free Software
-Foundation's software and to any other program whose authors commit to
-using it.  (Some other Free Software Foundation software is covered by
-the GNU Library General Public License instead.)  You can apply it to
-your programs, too.
-
-  When we speak of free software, we are referring to freedom, not
-price.  Our General Public Licenses are designed to make sure that you
-have the freedom to distribute copies of free software (and charge for
-this service if you wish), that you receive source code or can get it
-if you want it, that you can change the software or use pieces of it
-in new free programs; and that you know you can do these things.
-
-  To protect your rights, we need to make restrictions that forbid
-anyone to deny you these rights or to ask you to surrender the rights.
-These restrictions translate to certain responsibilities for you if you
-distribute copies of the software, or if you modify it.
-
-  For example, if you distribute copies of such a program, whether
-gratis or for a fee, you must give the recipients all the rights that
-you have.  You must make sure that they, too, receive or can get the
-source code.  And you must show them these terms so they know their
-rights.
-
-  We protect your rights with two steps: (1) copyright the software, and
-(2) offer you this license which gives you legal permission to copy,
-distribute and/or modify the software.
-
-  Also, for each author's protection and ours, we want to make certain
-that everyone understands that there is no warranty for this free
-software.  If the software is modified by someone else and passed on, we
-want its recipients to know that what they have is not the original, so
-that any problems introduced by others will not reflect on the original
-authors' reputations.
-
-  Finally, any free program is threatened constantly by software
-patents.  We wish to avoid the danger that redistributors of a free
-program will individually obtain patent licenses, in effect making the
-program proprietary.  To prevent this, we have made it clear that any
-patent must be licensed for everyone's free use or not licensed at all.
-
-  The precise terms and conditions for copying, distribution and
-modification follow.
-
-		    GNU GENERAL PUBLIC LICENSE
-   TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
-
-  0. This License applies to any program or other work which contains
-a notice placed by the copyright holder saying it may be distributed
-under the terms of this General Public License.  The &quot;Program&quot;, below,
-refers to any such program or work, and a &quot;work based on the Program&quot;
-means either the Program or any derivative work under copyright law:
-that is to say, a work containing the Program or a portion of it,
-either verbatim or with modifications and/or translated into another
-language.  (Hereinafter, translation is included without limitation in
-the term &quot;modification&quot;.)  Each licensee is addressed as &quot;you&quot;.
-
-Activities other than copying, distribution and modification are not
-covered by this License; they are outside its scope.  The act of
-running the Program is not restricted, and the output from the Program
-is covered only if its contents constitute a work based on the
-Program (independent of having been made by running the Program).
-Whether that is true depends on what the Program does.
-
-  1. You may copy and distribute verbatim copies of the Program's
-source code as you receive it, in any medium, provided that you
-conspicuously and appropriately publish on each copy an appropriate
-copyright notice and disclaimer of warranty; keep intact all the
-notices that refer to this License and to the absence of any warranty;
-and give any other recipients of the Program a copy of this License
-along with the Program.
-
-You may charge a fee for the physical act of transferring a copy, and
-you may at your option offer warranty protection in exchange for a fee.
-
-  2. You may modify your copy or copies of the Program or any portion
-of it, thus forming a work based on the Program, and copy and
-distribute such modifications or work under the terms of Section 1
-above, provided that you also meet all of these conditions:
-
-    a) You must cause the modified files to carry prominent notices
-    stating that you changed the files and the date of any change.
-
-    b) You must cause any work that you distribute or publish, that in
-    whole or in part contains or is derived from the Program or any
-    part thereof, to be licensed as a whole at no charge to all third
-    parties under the terms of this License.
-
-    c) If the modified program normally reads commands interactively
-    when run, you must cause it, when started running for such
-    interactive use in the most ordinary way, to print or display an
-    announcement including an appropriate copyright notice and a
-    notice that there is no warranty (or else, saying that you provide
-    a warranty) and that users may redistribute the program under
-    these conditions, and telling the user how to view a copy of this
-    License.  (Exception: if the Program itself is interactive but
-    does not normally print such an announcement, your work based on
-    the Program is not required to print an announcement.)
-
-These requirements apply to the modified work as a whole.  If
-identifiable sections of that work are not derived from the Program,
-and can be reasonably considered independent and separate works in
-themselves, then this License, and its terms, do not apply to those
-sections when you distribute them as separate works.  But when you
-distribute the same sections as part of a whole which is a work based
-on the Program, the distribution of the whole must be on the terms of
-this License, whose permissions for other licensees extend to the
-entire whole, and thus to each and every part regardless of who wrote it.
-
-Thus, it is not the intent of this section to claim rights or contest
-your rights to work written entirely by you; rather, the intent is to
-exercise the right to control the distribution of derivative or
-collective works based on the Program.
-
-In addition, mere aggregation of another work not based on the Program
-with the Program (or with a work based on the Program) on a volume of
-a storage or distribution medium does not bring the other work under
-the scope of this License.
-
-  3. You may copy and distribute the Program (or a work based on it,
-under Section 2) in object code or executable form under the terms of
-Sections 1 and 2 above provided that you also do one of the following:
-
-    a) Accompany it with the complete corresponding machine-readable
-    source code, which must be distributed under the terms of Sections
-    1 and 2 above on a medium customarily used for software interchange; or,
-
-    b) Accompany it with a written offer, valid for at least three
-    years, to give any third party, for a charge no more than your
-    cost of physically performing source distribution, a complete
-    machine-readable copy of the corresponding source code, to be
-    distributed under the terms of Sections 1 and 2 above on a medium
-    customarily used for software interchange; or,
-
-    c) Accompany it with the information you received as to the offer
-    to distribute corresponding source code.  (This alternative is
-    allowed only for noncommercial distribution and only if you
-    received the program in object code or executable form with such
-    an offer, in accord with Subsection b above.)
-
-The source code for a work means the preferred form of the work for
-making modifications to it.  For an executable work, complete source
-code means all the source code for all modules it contains, plus any
-associated interface definition files, plus the scripts used to
-control compilation and installation of the executable.  However, as a
-special exception, the source code distributed need not include
-anything that is normally distributed (in either source or binary
-form) with the major components (compiler, kernel, and so on) of the
-operating system on which the executable runs, unless that component
-itself accompanies the executable.
-
-If distribution of executable or object code is made by offering
-access to copy from a designated place, then offering equivalent
-access to copy the source code from the same place counts as
-distribution of the source code, even though third parties are not
-compelled to copy the source along with the object code.
-
-  4. You may not copy, modify, sublicense, or distribute the Program
-except as expressly provided under this License.  Any attempt
-otherwise to copy, modify, sublicense or distribute the Program is
-void, and will automatically terminate your rights under this License.
-However, parties who have received copies, or rights, from you under
-this License will not have their licenses terminated so long as such
-parties remain in full compliance.
-
-  5. You are not required to accept this License, since you have not
-signed it.  However, nothing else grants you permission to modify or
-distribute the Program or its derivative works.  These actions are
-prohibited by law if you do not accept this License.  Therefore, by
-modifying or distributing the Program (or any work based on the
-Program), you indicate your acceptance of this License to do so, and
-all its terms and conditions for copying, distributing or modifying
-the Program or works based on it.
-
-  6. Each time you redistribute the Program (or any work based on the
-Program), the recipient automatically receives a license from the
-original licensor to copy, distribute or modify the Program subject to
-these terms and conditions.  You may not impose any further
-restrictions on the recipients' exercise of the rights granted herein.
-You are not responsible for enforcing compliance by third parties to
-this License.
-
-  7. If, as a consequence of a court judgment or allegation of patent
-infringement or for any other reason (not limited to patent issues),
-conditions are imposed on you (whether by court order, agreement or
-otherwise) that contradict the conditions of this License, they do not
-excuse you from the conditions of this License.  If you cannot
-distribute so as to satisfy simultaneously your obligations under this
-License and any other pertinent obligations, then as a consequence you
-may not distribute the Program at all.  For example, if a patent
-license would not permit royalty-free redistribution of the Program by
-all those who receive copies directly or indirectly through you, then
-the only way you could satisfy both it and this License would be to
-refrain entirely from distribution of the Program.
-
-If any portion of this section is held invalid or unenforceable under
-any particular circumstance, the balance of the section is intended to
-apply and the section as a whole is intended to apply in other
-circumstances.
-
-It is not the purpose of this section to induce you to infringe any
-patents or other property right claims or to contest validity of any
-such claims; this section has the sole purpose of protecting the
-integrity of the free software distribution system, which is
-implemented by public license practices.  Many people have made
-generous contributions to the wide range of software distributed
-through that system in reliance on consistent application of that
-system; it is up to the author/donor to decide if he or she is willing
-to distribute software through any other system and a licensee cannot
-impose that choice.
-
-This section is intended to make thoroughly clear what is believed to
-be a consequence of the rest of this License.
-
-  8. If the distribution and/or use of the Program is restricted in
-certain countries either by patents or by copyrighted interfaces, the
-original copyright holder who places the Program under this License
-may add an explicit geographical distribution limitation excluding
-those countries, so that distribution is permitted only in or among
-countries not thus excluded.  In such case, this License incorporates
-the limitation as if written in the body of this License.
-
-  9. The Free Software Foundation may publish revised and/or new versions
-of the General Public License from time to time.  Such new versions will
-be similar in spirit to the present version, but may differ in detail to
-address new problems or concerns.
-
-Each version is given a distinguishing version number.  If the Program
-specifies a version number of this License which applies to it and &quot;any
-later version&quot;, you have the option of following the terms and conditions
-either of that version or of any later version published by the Free
-Software Foundation.  If the Program does not specify a version number of
-this License, you may choose any version ever published by the Free Software
-Foundation.
-
-  10. If you wish to incorporate parts of the Program into other free
-programs whose distribution conditions are different, write to the author
-to ask for permission.  For software which is copyrighted by the Free
-Software Foundation, write to the Free Software Foundation; we sometimes
-make exceptions for this.  Our decision will be guided by the two goals
-of preserving the free status of all derivatives of our free software and
-of promoting the sharing and reuse of software generally.
-
-			    NO WARRANTY
-
-  11. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO WARRANTY
-FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE LAW.  EXCEPT WHEN
-OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR OTHER PARTIES
-PROVIDE THE PROGRAM &quot;AS IS&quot; WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESSED
-OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
-MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS
-TO THE QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
-PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING,
-REPAIR OR CORRECTION.
-
-  12. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
-WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY AND/OR
-REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
-INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING
-OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED
-TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY
-YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY OTHER
-PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE
-POSSIBILITY OF SUCH DAMAGES.
-
-		     END OF TERMS AND CONDITIONS
-
-	    How to Apply These Terms to Your New Programs
-
-  If you develop a new program, and you want it to be of the greatest
-possible use to the public, the best way to achieve this is to make it
-free software which everyone can redistribute and change under these terms.
-
-  To do so, attach the following notices to the program.  It is safest
-to attach them to the start of each source file to most effectively
-convey the exclusion of warranty; and each file should have at least
-the &quot;copyright&quot; line and a pointer to where the full notice is found.
-
-    &lt;one line to give the program's name and a brief idea of what it does.&gt;
-    Copyright (C) 19yy  &lt;name of author&gt;
-
-    This program is free software; you can redistribute it and/or modify
-    it under the terms of the GNU General Public License as published by
-    the Free Software Foundation; either version 2 of the License, or
-    (at your option) any later version.
-
-    This program is distributed in the hope that it will be useful,
-    but WITHOUT ANY WARRANTY; without even the implied warranty of
-    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-    GNU General Public License for more details.
-
-    You should have received a copy of the GNU General Public License
-    along with this program; if not, write to the Free Software
-    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
-
-
-Also add information on how to contact you by electronic and paper mail.
-
-If the program is interactive, make it output a short notice like this
-when it starts in an interactive mode:
-
-    Gnomovision version 69, Copyright (C) 19yy name of author
-    Gnomovision comes with ABSOLUTELY NO WARRANTY; for details type `show w'.
-    This is free software, and you are welcome to redistribute it
-    under certain conditions; type `show c' for details.
-
-The hypothetical commands `show w' and `show c' should show the appropriate
-parts of the General Public License.  Of course, the commands you use may
-be called something other than `show w' and `show c'; they could even be
-mouse-clicks or menu items--whatever suits your program.
-
-You should also get your employer (if you work as a programmer) or your
-school, if any, to sign a &quot;copyright disclaimer&quot; for the program, if
-necessary.  Here is a sample; alter the names:
-
-  Yoyodyne, Inc., hereby disclaims all copyright interest in the program
-  `Gnomovision' (which makes passes at compilers) written by James Hacker.
-
-  &lt;signature of Ty Coon&gt;, 1 April 1989
-  Ty Coon, President of Vice
-
-This General Public License does not permit incorporating your program into
-proprietary programs.  If your program is a subroutine library, you may
-consider it more useful to permit linking proprietary applications with the
-library.  If this is what you want to do, use the GNU Library General
-Public License instead of this License.
 Asterisk is distributed under the GNU General Public License version 2
 and is also available under alternative licenses negotiated directly
 with Digium, Inc. If you obtained Asterisk under the GPL, then the GPL

Modified: trunk/Makefile
===================================================================
--- trunk/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,51 +3,6 @@
 # 
 # Top level Makefile
 #
-# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
-#
-# Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-
-.EXPORT_ALL_VARIABLES:
-
-MODULES_DIR=/usr/lib/asterisk/modules
-
-DEBUG=-g #-pg
-INCLUDE=-Iinclude -I../include
-CFLAGS=-Wall -Werror -O6 $(DEBUG) $(INCLUDE) -D_REENTRANT
-CFLAGS+=$(shell if $(CC) -march=i686 -S -o /dev/null -xc /dev/null &gt;/dev/null 2&gt;&amp;1; then echo &quot;-march=i686&quot;; fi)
-SUBDIRS=channels pbx apps codecs formats
-LIBS=-ldl -lpthread #-lefence
-OBJS=io.o sched.o logger.o frame.o loader.o config.o channel.o translate.o file.o say.o pbx.o asterisk.o
-CC=gcc
-INSTALL=install
-
-all: asterisk subdirs
-
-asterisk: $(OBJS)
-	gcc -o asterisk -rdynamic $(OBJS) $(LIBS)
-
-subdirs: 
-	for x in $(SUBDIRS); do $(MAKE) -C $$x || exit 1 ; done
-
-clean:
-	for x in $(SUBDIRS); do $(MAKE) -C $$x clean || exit 1 ; done
-	rm -f *.o *.so asterisk
-
-install: all
-	mkdir -p $(MODULES_DIR)
-	for x in $(SUBDIRS); do $(MAKE) -C $$x install || exit 1 ; done
-	install -d /usr/include/asterisk
-	install include/asterisk/*.h /usr/include/asterisk
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
-# Top level Makefile
-#
 # Copyright (C) 1999-2006, Digium, Inc.
 #
 # Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at digium.com</A>&gt;

Modified: trunk/README
===================================================================
--- trunk/README	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/README	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,30 +1,3 @@
-The Asterisk Open Source PBX
-by Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-Copyright (C) 1999, Linux Support Services, LLC and Adtran, Inc.
-================================================================
-* WHAT IS ASTERISK
-  Asterisk is an Open Source PBX and telephony toolkit.  It is, in a
-sense, middleware between Internet and telephony channels on the bottom,
-and Internet and telephony applications at the top.  For more information
-on the project itself, please visit the Asterisk home page at:
-
-           <A HREF="http://www.asteriskpbx.com">http://www.asteriskpbx.com</A>
-
-
-* REQUIRED COMPONENTS
-
-== Linux ==
-  Currently, the Asterisk Open Source PBX is only known to run on the
-Linux OS, although it may be portable to other UNIX-like operating systems
-as well.
-
-== libaudiofile ==
-
-  If you want to use format_wav module, then you need a very recent
-version of libaudiofile (at least version 0.2.0, or you can apply the
-following patch to version 0.1.9):
-
-
 The Solid PBX Soft Switch Class 5
 by the Solid PBX community
 

Modified: trunk/apps/Makefile
===================================================================
--- trunk/apps/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/apps/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,33 +1,6 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
-# Makefile for PBX frontends (dynamically loaded)
-#
-# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
-#
-# Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-APPS=app_dial.so app_playback.so app_voicemail.so app_directory.so app_intercom.so app_mp3.so
-
-CFLAGS+=
-
-all: $(APPS)
-
-clean:
-	rm -f *.so *.o
-
-%.so : %.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt;
-
-install: all
-	for x in $(APPS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
 # Makefile for PBX applications
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/apps/app_dial.c
===================================================================
--- trunk/apps/app_dial.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/apps/app_dial.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,414 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Trivial application to dial a channel
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;sys/time.h&gt;
-
-#include &lt;pthread.h&gt;
-
-
-static char *tdesc = &quot;Trivial Dialing Application&quot;;
-
-static char *app = &quot;Dial&quot;;
-
-/* We define a customer &quot;local user&quot; structure because we
-   use it not only for keeping track of what is in use but
-   also for keeping track of who we're dialing. */
-
-struct localuser {
-	struct ast_channel *chan;
-	int stillgoing;
-	int allowredirect;
-	struct localuser *next;
-};
-
-LOCAL_USER_DECL;
-
-static void hanguptree(struct localuser *outgoing, struct ast_channel *exception)
-{
-	/* Hang up a tree of stuff */
-	struct localuser *oo;
-	while(outgoing) {
-		/* Hangup any existing lines we have open */
-		if (outgoing-&gt;chan != exception)
-			ast_hangup(outgoing-&gt;chan);
-		oo = outgoing;
-		outgoing=outgoing-&gt;next;
-		free(oo);
-	}
-}
-
-static struct ast_channel *wait_for_answer(struct ast_channel *in, struct localuser *outgoing, int *to, int *allowredir)
-{
-	fd_set rfds, efds;
-	struct localuser *o;
-	int found;
-	int numlines;
-	int numbusies = 0;
-	int orig = *to;
-	struct timeval tv;
-	struct ast_frame *f;
-	struct ast_channel *peer = NULL;
-	/* Watch all outgoing channels looking for an answer of some sort.  */
-	tv.tv_sec = *to / 1000;
-	tv.tv_usec = (*to % 1000) * 1000;
-	while((tv.tv_sec || tv.tv_usec) &amp;&amp; !peer) {
-		FD_ZERO(&amp;rfds);
-		FD_ZERO(&amp;efds);
-		/* Always watch the input fd */
-		FD_SET(in-&gt;fd, &amp;rfds);
-		FD_SET(in-&gt;fd, &amp;efds);
-		o = outgoing;
-		found = -1;
-		numlines = 0;
-		while(o) {
-			if (o-&gt;stillgoing) {
-				/* Pay attention to this one */
-				CHECK_BLOCKING(o-&gt;chan);
-				FD_SET(o-&gt;chan-&gt;fd, &amp;rfds);
-				FD_SET(o-&gt;chan-&gt;fd, &amp;efds);
-				if (o-&gt;chan-&gt;fd &gt; found)
-					found = o-&gt;chan-&gt;fd;
-			}
-			numlines++;
-			o = o-&gt;next;
-		}
-		/* If nobody is left, just go ahead and stop */
-		if (found&lt;0) {
-			if (numlines == numbusies) {
-				if (option_verbose &gt; 2)
-					ast_verbose( VERBOSE_PREFIX_2 &quot;Everyone is busy at this time\n&quot;);
-				/* See if there is a special busy message */
-				if (ast_exists_extension(in, in-&gt;context, in-&gt;exten, in-&gt;priority + 101)) 
-					in-&gt;priority+=100;
-			} else {
-				if (option_verbose &gt; 2)
-					ast_verbose( VERBOSE_PREFIX_2 &quot;No one is available to answer at this time\n&quot;);
-			}
-			break;
-		}
-		if (in-&gt;fd &gt; found)
-			found = in-&gt;fd;
-		if (*to &gt; -1) 
-			found = select(found + 1, &amp;rfds, NULL, &amp;efds, &amp;tv);
-		else
-			found = select(found + 1, &amp;rfds, NULL, &amp;efds, NULL);
-		if (found &lt; 0) {
-			ast_log(LOG_WARNING, &quot;select failed, returned %d (%s)\n&quot;, errno, strerror(errno));
-			*to = -1;
-			o = outgoing;
-			while(o) {
-				if (o-&gt;stillgoing) {
-					o-&gt;chan-&gt;blocking = 0;
-				}
-				o = o-&gt;next;
-			}
-			return NULL;
-		}
-		o = outgoing;
-		while(o) {
-			if (o-&gt;stillgoing) {
-				o-&gt;chan-&gt;blocking = 0;
-				if (FD_ISSET(o-&gt;chan-&gt;fd, &amp;rfds) || FD_ISSET(o-&gt;chan-&gt;fd, &amp;efds)) {
-					f = ast_read(o-&gt;chan);
-					if (f) {
-						if (f-&gt;frametype == AST_FRAME_CONTROL) {
-							switch(f-&gt;subclass) {
-						    case AST_CONTROL_ANSWER:
-								/* This is our guy if someone answered. */
-								if (!peer) {
-									if (option_verbose &gt; 2)
-										ast_verbose( VERBOSE_PREFIX_3 &quot;%s answered %s\n&quot;, o-&gt;chan-&gt;name, in-&gt;name);
-									peer = o-&gt;chan;
-									*allowredir = o-&gt;allowredirect;
-								}
-								break;
-							case AST_CONTROL_BUSY:
-								if (option_verbose &gt; 2)
-									ast_verbose( VERBOSE_PREFIX_3 &quot;%s is busy\n&quot;, o-&gt;chan-&gt;name);
-								o-&gt;stillgoing = 0;
-								numbusies++;
-								break;
-							case AST_CONTROL_RINGING:
-								if (option_verbose &gt; 2)
-									ast_verbose( VERBOSE_PREFIX_3 &quot;%s is ringing\n&quot;, o-&gt;chan-&gt;name);
-								break;
-							case AST_CONTROL_OFFHOOK:
-								/* Ignore going off hook */
-								break;
-							default:
-								ast_log(LOG_DEBUG, &quot;Dunno what to do with control type %d\n&quot;, f-&gt;subclass);
-							}
-						}
-						ast_frfree(f);
-					} else {
-						o-&gt;stillgoing = 0;
-					}
-					
-				}
-			}
-			o = o-&gt;next;
-		}
-		if (FD_ISSET(in-&gt;fd, &amp;rfds) || FD_ISSET(in-&gt;fd, &amp;efds)) {
-			/* After unblocking the entirity of the list, check for the main channel */
-			f = ast_read(in);
-#if 0
-			if (f &amp;&amp; (f-&gt;frametype != AST_FRAME_VOICE))
-					printf(&quot;Frame type: %d, %d\n&quot;, f-&gt;frametype, f-&gt;subclass);
-#endif
-			if (!f || ((f-&gt;frametype == AST_FRAME_CONTROL) &amp;&amp; (f-&gt;subclass = AST_CONTROL_HANGUP))) {
-				/* Got hung up */
-				*to=-1;
-				return NULL;
-			}
-		}
-		
-	}
-	if (!(tv.tv_sec || tv.tv_usec) &amp;&amp; (option_verbose &gt; 2))
-		ast_verbose( VERBOSE_PREFIX_3 &quot;Nobody picked up in %d ms\n&quot;, orig);
-	*to = 0;
-	return peer;
-}
-
-static int bridge_call(struct ast_channel *chan, struct ast_channel *peer, int allowredirect)
-{
-	/* Copy voice back and forth between the two channels.  Give the peer
-	   the ability to transfer calls with '#&lt;extension' syntax. */
-	struct ast_channel *cs[3];
-	int to = -1, len;
-	struct ast_frame *f;
-	struct ast_channel *who;
-	char newext[256], *ptr;
-	int res;
-	/* Answer if need be */
-	if (chan-&gt;state != AST_STATE_UP)
-		if (ast_answer(chan))
-			return -1;
-	cs[0] = chan;
-	cs[1] = peer;
-	for (/* ever */;;) {
-		who = ast_waitfor_n(cs, 2, &amp;to);
-		if (!who) {
-			ast_log(LOG_WARNING, &quot;Nobody there??\n&quot;);
-			continue;
-		}
-		f = ast_read(who);
-		if (!f || ((f-&gt;frametype == AST_FRAME_CONTROL) &amp;&amp; (f-&gt;subclass == AST_CONTROL_HANGUP))) 
-			return -1;
-		if ((f-&gt;frametype == AST_FRAME_VOICE) ||
-		    (f-&gt;frametype == AST_FRAME_DTMF)) {
-			if ((f-&gt;frametype == AST_FRAME_DTMF) &amp;&amp; (who == peer) &amp;&amp; allowredirect) {
-				if (f-&gt;subclass == '#') {
-					memset(newext, 0, sizeof(newext));
-					ptr = newext;
-					len = ast_pbx_longest_extension(chan-&gt;context) + 1;
-
-					/* Transfer */
-					if ((res=ast_streamfile(peer, &quot;pbx-transfer&quot;)))
-						break;
-					if ((res=ast_waitstream(peer, AST_DIGIT_ANY)) &lt; 0)
-						break;
-					ast_stopstream(peer);
-					if (res &gt; 0) {
-						/* If they've typed a digit already, handle it */
-						newext[0] = res;
-						ptr++;
-						len --;
-					}
-					res = ast_readstring(peer, ptr, len, 3000, 2000, &quot;#&quot;);
-					if (res)
-						break;
-					if (ast_exists_extension(chan, chan-&gt;context, newext, 1)) {
-						/* Set the channel's new extension, since it exists */
-						strncpy(chan-&gt;exten, newext, sizeof(chan-&gt;exten));
-						chan-&gt;priority = 0;
-						ast_frfree(f);
-						res=0;
-						break;
-					}
-					res = ast_streamfile(peer, &quot;pbx-invalid&quot;);
-					if (res)
-						break;
-					res = ast_waitstream(peer, AST_DIGIT_ANY);
-					ast_stopstream(peer);
-					res = 0;
-				}
-			} else {
-#if 0
-				ast_log(LOG_DEBUG, &quot;Read from %s\n&quot;, who-&gt;name);
-#endif
-				if (who == chan) 
-					ast_write(peer, f);
-				else 
-					ast_write(chan, f);
-			}
-			ast_frfree(f);
-			
-		} else
-			ast_frfree(f);
-		/* Swap who gets priority */
-		cs[2] = cs[0];
-		cs[0] = cs[1];
-		cs[1] = cs[2];
-	}
-	return res;
-}
-
-static int dial_exec(struct ast_channel *chan, void *data)
-{
-	int res=-1;
-	struct localuser *u;
-	char *info, *peers, *timeout, *tech, *number, *rest, *cur;
-	struct localuser *outgoing=NULL, *tmp;
-	struct ast_channel *peer;
-	int to;
-	int allowredir=0;
-	
-	if (!data) {
-		ast_log(LOG_WARNING, &quot;Dial requires an argument (technology1/number1&amp;technology2/number2...|optional timeout)\n&quot;);
-		return -1;
-	}
-	
-	LOCAL_USER_ADD(u);
-	
-	/* Parse our arguments */
-	info = strdup((char *)data);
-	peers = strtok(info, &quot;|&quot;);
-	if (!peers) {
-		ast_log(LOG_WARNING, &quot;Dial argument takes format (technology1/number1&amp;technology2/number2...|optional timeout)\n&quot;);
-		goto out;
-	}
-	timeout = strtok(NULL, &quot;|&quot;);
-	rest = peers;
-	do {
-		cur = strtok(rest, &quot;&amp;&quot;);
-		/* Remember where to start next time */
-		rest = strtok(NULL, &quot;\128&quot;);
-		/* Get a technology/number pair */
-		tech = strtok(cur, &quot;/&quot;);
-		number = strtok(NULL, &quot;&amp;&quot;);
-		if (!number) {
-			ast_log(LOG_WARNING, &quot;Dial argument takes format (technology1/number1&amp;technology2/number2...|optional timeout)\n&quot;);
-			goto out;
-		}
-		tmp = malloc(sizeof(struct localuser));
-		if (!tmp) {
-			ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-			goto out;
-		}
-		tmp-&gt;allowredirect = 1;
-		/* If we're dialing by extension, look at the extension to know what to dial */
-		if (!strcasecmp(number, &quot;BYEXTENSION&quot;)) {
-			if (option_debug)
-				ast_log(LOG_DEBUG, &quot;Dialing by extension %s\n&quot;, chan-&gt;exten);
-			number = chan-&gt;exten;
-			/* By default, if we're dialing by extension, don't permit redirecting */
-			tmp-&gt;allowredirect = 0;
-		}
-		/* Request the peer */
-		tmp-&gt;chan = ast_request(tech, chan-&gt;format, number);
-		if (!tmp-&gt;chan) {
-			/* If we can't, just go on to the next call */
-			ast_log(LOG_WARNING, &quot;Unable to create channel of type '%s'\n&quot;, tech);
-			free(tmp);
-			continue;
-		}
-		/* Place the call, but don't wait on the answer */
-		res = ast_call(tmp-&gt;chan, number, 0);
-		if (res) {
-			/* Again, keep going even if there's an error */
-			if (option_debug)
-				ast_log(LOG_DEBUG, &quot;ast call on peer returned %d\n&quot;, res);
-			else if (option_verbose &gt; 2)
-				ast_verbose(VERBOSE_PREFIX_3 &quot;Couldn't call %s\n&quot;, number);
-			ast_hangup(tmp-&gt;chan);
-			free(tmp);
-			continue;
-		} else
-			if (option_verbose &gt; 2)
-				ast_verbose(VERBOSE_PREFIX_3 &quot;Called %s\n&quot;, number);
-		/* Put them in the list of outgoing thingies...  We're ready now. 
-		   XXX If we're forcibly removed, these outgoing calls won't get
-		   hung up XXX */
-		tmp-&gt;stillgoing = -1;
-		tmp-&gt;next = outgoing;
-		outgoing = tmp;
-	} while(rest);
-	if (timeout)
-		to = atoi(timeout) * 1000;
-	else
-		to = -1;
-	peer = wait_for_answer(chan, outgoing, &amp;to, &amp;allowredir);
-	if (!peer) {
-		if (to) 
-			/* Musta gotten hung up */
-			res = -1;
-		 else 
-		 	/* Nobody answered, next please? */
-			res=0;
-		
-		goto out;
-	}
-	if (peer) {
-		/* Ah ha!  Someone answered within the desired timeframe.  Of course after this
-		   we will always return with -1 so that it is hung up properly after the 
-		   conversation.  */
-		hanguptree(outgoing, peer);
-		outgoing = NULL;
-		res = bridge_call(chan, peer, allowredir);
-		ast_hangup(peer);
-	}	
-out:
-	hanguptree(outgoing, NULL);
-	free(info);
-	LOCAL_USER_REMOVE(u);
-	return res;
-}
-
-int unload_module(void)
-{
-	STANDARD_HANGUP_LOCALUSERS;
-	return ast_unregister_application(app);
-}
-
-int load_module(void)
-{
-	return ast_register_application(app, dial_exec);
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/apps/app_directory.c
===================================================================
--- trunk/apps/app_directory.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/apps/app_directory.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,268 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Provide a directory of extensions
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
- 
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/config.h&gt;
-#include &lt;asterisk/say.h&gt;
-#include &lt;string.h&gt;
-#include &lt;ctype.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;stdio.h&gt;
-#include &quot;../asterisk.h&quot;
-
-static char *tdesc = &quot;Extension Directory&quot;;
-static char *app = &quot;Directory&quot;;
-
-/* For simplicity, I'm keeping the format compatible with the voicemail config,
-   but i'm open to suggestions for isolating it */
-
-#define DIRECTORY_CONFIG &quot;voicemail.conf&quot;
-
-/* How many digits to read in */
-#define NUMDIGITS 3
-
-STANDARD_LOCAL_USER;
-
-LOCAL_USER_DECL;
-
-static char *convert(char *lastname)
-{
-	char *tmp;
-	int lcount = 0;
-	tmp = malloc(NUMDIGITS + 1);
-	if (tmp) {
-		while((*lastname &gt; 32) &amp;&amp; lcount &lt; NUMDIGITS) {
-			switch(toupper(*lastname)) {
-			case '1':
-				tmp[lcount++] = '1';
-				break;
-			case '2':
-			case 'A':
-			case 'B':
-			case 'C':
-				tmp[lcount++] = '2';
-				break;
-			case '3':
-			case 'D':
-			case 'E':
-			case 'F':
-				tmp[lcount++] = '3';
-				break;
-			case '4':
-			case 'G':
-			case 'H':
-			case 'I':
-				tmp[lcount++] = '4';
-				break;
-			case '5':
-			case 'J':
-			case 'K':
-			case 'L':
-				tmp[lcount++] = '5';
-				break;
-			case '6':
-			case 'M':
-			case 'N':
-			case 'O':
-				tmp[lcount++] = '6';
-				break;
-			case '7':
-			case 'P':
-			case 'Q':
-			case 'R':
-			case 'S':
-				tmp[lcount++] = '7';
-				break;
-			case '8':
-			case 'T':
-			case 'U':
-			case 'V':
-				tmp[lcount++] = '8';
-				break;
-			case '9':
-			case 'W':
-			case 'X':
-			case 'Y':
-			case 'Z':
-				tmp[lcount++] = '9';
-				break;
-			default:
-			}
-			lastname++;
-		}
-		tmp[lcount] = '\0';
-	}
-	return tmp;
-}
-
-static int do_directory(struct ast_channel *chan, struct ast_config *cfg, char *context, char digit)
-{
-	/* Read in the first three digits..  &quot;digit&quot; is the first digit, already read */
-	char ext[NUMDIGITS + 1];
-	struct ast_variable *v;
-	int res;
-	int found=0;
-	char *start, *pos, *conv;
-	char fn[256];
-	memset(ext, 0, sizeof(ext));
-	ext[0] = digit;
-	res = ast_readstring(chan, ext + 1, NUMDIGITS, 3000, 3000, &quot;#&quot;);
-	if (!res) {
-		/* Search for all names which start with those digits */
-		v = ast_variable_browse(cfg, context);
-		while(v &amp;&amp; !res) {
-			/* Find all candidate extensions */
-			while(v) {
-				/* Find a candidate extension */
-				start = strdup(v-&gt;value);
-				if (start) {
-					strtok(start, &quot;,&quot;);
-					pos = strtok(NULL, &quot;,&quot;);
-					if (pos) {
-						/* Grab the last name */
-						if (strrchr(pos, ' '))
-							pos = strrchr(pos, ' ') + 1;
-						conv = convert(pos);
-						if (conv) {
-							if (!strcmp(conv, ext)) {
-								/* Match! */
-								found++;
-								free(conv);
-								free(start);
-								break;
-							}
-							free(conv);
-						}
-					}
-					free(start);
-				}
-				v = v-&gt;next;
-			}
-			if (v) {
-				/* We have a match -- play a greeting if they have it */
-				snprintf(fn, sizeof(fn), &quot;%s/vm/%s/greet&quot;, AST_SPOOL_DIR, v-&gt;name);
-				if (ast_fileexists(fn, NULL)) {
-					res = ast_streamfile(chan, fn);
-					if (!res)
-						res = ast_waitstream(chan, AST_DIGIT_ANY);
-					ast_stopstream(chan);
-				} else {
-					res = ast_say_digit_str(chan, v-&gt;name);
-				}
-ahem:
-				if (!res)
-					res = ast_streamfile(chan, &quot;dir-instr&quot;);
-				if (!res)
-					res = ast_waitstream(chan, AST_DIGIT_ANY);
-				if (!res)
-					res = ast_waitfordigit(chan, 3000);
-				ast_stopstream(chan);
-				if (res &gt; -1) {
-					if (res == '1') {
-						strncpy(chan-&gt;exten, v-&gt;name, sizeof(chan-&gt;exten));
-						chan-&gt;priority = 0;
-						strncpy(chan-&gt;context, context, sizeof(chan-&gt;context));
-						res = 0;
-						break;
-					} else if (res == '*') {
-						res = 0;
-						v = v-&gt;next;
-					} else {
-						res = 0;
-						goto ahem;
-					}
-				}
-			} else {
-				if (found) 
-					res = ast_streamfile(chan, &quot;dir-nomore&quot;);
-				else
-					res = ast_streamfile(chan, &quot;dir-nomatch&quot;);
-				if (!res)
-					res = 1;
-				return res;
-			}
-		}
-		
-	}
-	return res;
-}
-
-static int directory_exec(struct ast_channel *chan, void *data)
-{
-	int res = 0;
-	struct localuser *u;
-	struct ast_config *cfg;
-	if (!data) {
-		ast_log(LOG_WARNING, &quot;directory requires an argument (context)\n&quot;);
-		return -1;
-	}
-	cfg = ast_load(DIRECTORY_CONFIG);
-	if (!cfg) {
-		ast_log(LOG_WARNING, &quot;Unable to open directory configuration %s\n&quot;, DIRECTORY_CONFIG);
-		return -1;
-	}
-	LOCAL_USER_ADD(u);
-top:
-	if (!res)
-		res = ast_streamfile(chan, &quot;dir-intro&quot;);
-	if (!res)
-		res = ast_waitstream(chan, AST_DIGIT_ANY);
-	ast_stopstream(chan);
-	if (!res)
-		res = ast_waitfordigit(chan, 5000);
-	if (res &gt; 0) {
-		res = do_directory(chan, cfg, (char *)data, res);
-		if (res &gt; 0) {
-			res = ast_waitstream(chan, AST_DIGIT_ANY);
-			ast_stopstream(chan);
-			if (res &gt;= 0) {
-				goto top;
-			}
-		}
-	}
-	ast_destroy(cfg);
-	LOCAL_USER_REMOVE(u);
-	return res;
-}
-
-int unload_module(void)
-{
-	STANDARD_HANGUP_LOCALUSERS;
-	return ast_unregister_application(app);
-}
-
-int load_module(void)
-{
-	return ast_register_application(app, directory_exec);
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/apps/app_mp3.c
===================================================================
--- trunk/apps/app_mp3.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/apps/app_mp3.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,197 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Silly application to play an MP3 file -- uses mpg123
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
- 
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/frame.h&gt;
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/translate.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;sys/time.h&gt;
-
-#define MPG_123 &quot;/usr/bin/mpg123&quot;
-
-static char *tdesc = &quot;Silly MP3 Application&quot;;
-
-static char *app = &quot;MP3Player&quot;;
-
-STANDARD_LOCAL_USER;
-
-LOCAL_USER_DECL;
-
-static int mp3play(char *filename, int fd)
-{
-	int res;
-	res = fork();
-	if (res &lt; 0) 
-		ast_log(LOG_WARNING, &quot;Fork failed\n&quot;);
-	if (res)
-		return res;
-	dup2(fd, STDOUT_FILENO);
-	/* Execute mpg123, but buffer if it's a net connection */
-	if (strncmp(filename, &quot;<A HREF="http://">http://</A>&quot;, 7)) 
-	    execl(MPG_123, MPG_123, &quot;-q&quot;, &quot;-s&quot;, &quot;-b&quot;, &quot;1024&quot;, &quot;--mono&quot;, &quot;-r&quot;, &quot;8000&quot;, filename, NULL);
-	else
-	    execl(MPG_123, MPG_123, &quot;-q&quot;, &quot;-s&quot;, &quot;--mono&quot;, &quot;-r&quot;, &quot;8000&quot;, filename, NULL);
-	ast_log(LOG_WARNING, &quot;Execute of mpg123 failed\n&quot;);
-	return -1;
-}
-
-static int mp3_exec(struct ast_channel *chan, void *data)
-{
-	int res=0;
-	struct localuser *u;
-	struct ast_channel *trans;
-	int fds[2];
-	int rfds[2];
-	int ms = -1;
-	int pid;
-	int us;
-	struct timeval tv;
-	struct timeval last;
-	struct ast_frame *f;
-	struct myframe {
-		struct ast_frame f;
-		char offset[AST_FRIENDLY_OFFSET];
-		char frdata[160];
-	} myf;
-	last.tv_usec = 0;
-	last.tv_sec = 0;
-	if (!data) {
-		ast_log(LOG_WARNING, &quot;MP3 Playback requires an argument (filename)\n&quot;);
-		return -1;
-	}
-	if (pipe(fds)) {
-		ast_log(LOG_WARNING, &quot;Unable to create pipe\n&quot;);
-		return -1;
-	}
-	LOCAL_USER_ADD(u);
-	ast_stopstream(chan);
-	if (chan-&gt;format &amp; AST_FORMAT_SLINEAR)
-		trans = chan;
-	else
-		trans = ast_translator_create(chan, AST_FORMAT_SLINEAR, AST_DIRECTION_OUT);
-	if (trans) {
-		res = mp3play((char *)data, fds[1]);
-		if (res &gt;= 0) {
-			pid = res;
-			/* Order is important -- there's almost always going to be mp3...  we want to prioritize the
-			   user */
-			rfds[0] = trans-&gt;fd;
-			rfds[1] = fds[0];
-			for (;;) {
-				CHECK_BLOCKING(trans);
-				res = ast_waitfor_n_fd(rfds, 2, &amp;ms);
-				trans-&gt;blocking = 0;
-				if (res &lt; 1) {
-					ast_log(LOG_DEBUG, &quot;Hangup detected\n&quot;);
-					res = -1;
-					break;
-				} else if (res == trans-&gt;fd) {
-					f = ast_read(trans);
-					if (!f) {
-						ast_log(LOG_DEBUG, &quot;Null frame == hangup() detected\n&quot;);
-						res = -1;
-						break;
-					}
-					if (f-&gt;frametype == AST_FRAME_DTMF) {
-						ast_log(LOG_DEBUG, &quot;User pressed a key\n&quot;);
-						ast_frfree(f);
-						res = 0;
-						break;
-					}
-					ast_frfree(f);
-				} else if (res == fds[0]) {
-					gettimeofday(&amp;tv, NULL);
-					if (last.tv_sec || last.tv_usec) {
-						/* We should wait at least a frame length */
-						us = sizeof(myf.frdata) / 16 * 1000;
-						/* Subtract 1,000,000 us for each second late we've passed */
-						us -= (tv.tv_sec - last.tv_sec) * 1000000;
-						/* And one for each us late we've passed */
-						us -= (tv.tv_usec - last.tv_usec);
-						/* Sleep that long if needed */
-						if (us &gt; 0)
-							usleep(us);
-					}
-					last = tv;
-					res = read(fds[0], myf.frdata, sizeof(myf.frdata));
-					if (res &gt; 0) {
-						myf.f.frametype = AST_FRAME_VOICE;
-						myf.f.subclass = AST_FORMAT_SLINEAR;
-						myf.f.datalen = res;
-						myf.f.timelen = res / 16;
-						myf.f.mallocd = 0;
-						myf.f.offset = AST_FRIENDLY_OFFSET;
-						myf.f.src = __PRETTY_FUNCTION__;
-						myf.f.data = myf.frdata;
-						if (ast_write(trans, &amp;myf.f) &lt; 0) {
-							res = -1;
-							break;
-						}
-					} else {
-						ast_log(LOG_DEBUG, &quot;No more mp3\n&quot;);
-						res = 0;
-					}
-				} else {
-					ast_log(LOG_DEBUG, &quot;HuhHHH?\n&quot;);
-					res = -1;
-					break;
-				}
-			}
-			kill(pid, SIGTERM);
-		}
-		if (trans != chan) 
-			ast_translator_destroy(trans);
-	} else 
-		ast_log(LOG_WARNING, &quot;No translator channel available\n&quot;);
-	close(fds[0]);
-	close(fds[1]);
-	LOCAL_USER_REMOVE(u);
-	return res;
-}
-
-int unload_module(void)
-{
-	STANDARD_HANGUP_LOCALUSERS;
-	return ast_unregister_application(app);
-}
-
-int load_module(void)
-{
-	return ast_register_application(app, mp3_exec);
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/apps/app_playback.c
===================================================================
--- trunk/apps/app_playback.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/apps/app_playback.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,75 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Trivial application to playback a sound file
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
- 
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/translate.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-
-static char *tdesc = &quot;Trivial Playback Application&quot;;
-
-static char *app = &quot;Playback&quot;;
-
-STANDARD_LOCAL_USER;
-
-LOCAL_USER_DECL;
-
-static int playback_exec(struct ast_channel *chan, void *data)
-{
-	int res;
-	struct localuser *u;
-	if (!data) {
-		ast_log(LOG_WARNING, &quot;Playback requires an argument (filename)\n&quot;);
-		return -1;
-	}
-	LOCAL_USER_ADD(u);
-	ast_stopstream(chan);
-	res = ast_streamfile(chan, (char *)data);
-	if (!res)
-		res = ast_waitstream(chan, &quot;&quot;);
-	ast_stopstream(chan);
-	LOCAL_USER_REMOVE(u);
-	return res;
-}
-
-int unload_module(void)
-{
-	STANDARD_HANGUP_LOCALUSERS;
-	return ast_unregister_application(app);
-}
-
-int load_module(void)
-{
-	return ast_register_application(app, playback_exec);
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/apps/app_voicemail.c
===================================================================
--- trunk/apps/app_voicemail.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/apps/app_voicemail.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,599 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Voicemail System (did you ever think it could be so easy?)
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;asterisk/config.h&gt;
-#include &lt;asterisk/say.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &lt;time.h&gt;
-
-#include &lt;pthread.h&gt;
-#include &quot;../asterisk.h&quot;
-
-#define COMMAND_TIMEOUT 5000
-
-#define VOICEMAIL_CONFIG &quot;voicemail.conf&quot;
-#define ASTERISK_USERNAME &quot;asterisk&quot;
-
-/*
-#define HOSTNAME_OVERRIDE &quot;linux-support.net&quot;
-*/
-
-#define SENDMAIL &quot;/usr/sbin/sendmail -t&quot;
-
-#define INTRO &quot;vm-intro&quot;
-
-#define MAXMSG 100
-
-#define MAX_OTHER_FORMATS 10
-
-#define VM_SPOOL_DIR AST_SPOOL_DIR &quot;/vm&quot;
-
-
-static char *tdesc = &quot;Comedian Mail (Voicemail System)&quot;;
-
-/* Leave a message */
-static char *app = &quot;VoiceMail&quot;;
-
-/* Check mail, control, etc */
-static char *app2 = &quot;VoiceMailMain&quot;;
-
-STANDARD_LOCAL_USER;
-
-LOCAL_USER_DECL;
-
-static char *get_dir(char *ext, char *mailbox)
-{
-	char *tmp = malloc(strlen(ext) + strlen(VM_SPOOL_DIR) + 3 + strlen(mailbox));
-	sprintf(tmp, &quot;%s/%s/%s&quot;, VM_SPOOL_DIR, ext, mailbox);
-	return tmp;
-}
-static char *get_fn(char *dir, int num)
-{
-	char *tmp = malloc(strlen(dir) + 10);
-	sprintf(tmp, &quot;%s/msg%04d&quot;, dir, num);
-	return tmp;
-}
-
-static int announce_message(struct ast_channel *chan, char *dir, int msgcnt)
-{
-	char *fn;
-	int res;
-	res = ast_streamfile(chan, &quot;vm-message&quot;);
-	if (!res) {
-		res = ast_waitstream(chan, AST_DIGIT_ANY);
-		if (!res) {
-			res = ast_say_number(chan, msgcnt+1);
-			if (!res) {
-				fn = get_fn(dir, msgcnt);
-				if (fn) {
-					res = ast_streamfile(chan, fn);
-					free(fn);
-				}
-			}
-		}
-	}
-	if (res &lt; 0)
-		ast_log(LOG_WARNING, &quot;Unable to announce message\n&quot;);
-	return res;
-}
-static int sendmail(char *email, char *name, int msgnum, char *mailbox)
-{
-	FILE *p;
-	char date[256];
-	char host[256];
-	time_t t;
-	struct tm *tm;
-	p = popen(SENDMAIL, &quot;w&quot;);
-	if (p) {
-		gethostname(host, sizeof(host));
-		time(&amp;t);
-		tm = localtime(&amp;t);
-		strftime(date, sizeof(date), &quot;%a, %d %b %Y %H:%M:%S %z&quot;, tm);
-		fprintf(p, &quot;Date: %s\n&quot;, date);
-		fprintf(p, &quot;Message-ID: &lt;Asterisk-%d-%s-%d@%s&gt;\n&quot;, msgnum, mailbox, getpid(), host);
-		fprintf(p, &quot;From: Asterisk PBX &lt;%s@%s&gt;\n&quot;, ASTERISK_USERNAME,
-#ifdef HOSTNAME_OVERRIDE
-				HOSTNAME_OVERRIDE
-#else
-				host
-#endif
-				);
-		fprintf(p, &quot;To: %s &lt;%s&gt;\n&quot;, name, email);
-		fprintf(p, &quot;Subject: [PBX]: New message %d in mailbox %s\n\n&quot;, msgnum, mailbox);
-		strftime(date, sizeof(date), &quot;%A, %B %d, %Y at %r&quot;, tm);
-		fprintf(p, &quot;Dear %s:\n\n\tJust wanted to let you know you were just left a message (number %d)\n&quot;
-		           &quot;in mailbox %s, on %s so you might\n&quot;
-				   &quot;want to check it when you get a chance.  Thanks!\n\n\t\t\t\t--Asterisk\n&quot;, name, msgnum, mailbox, date);
-		fprintf(p, &quot;.\n&quot;);
-		pclose(p);
-	} else {
-		ast_log(LOG_WARNING, &quot;Unable to launch '%s'\n&quot;, SENDMAIL);
-		return -1;
-	}
-	return 0;
-}
-
-static int leave_voicemail(struct ast_channel *chan, char *ext, int silent)
-{
-	struct ast_config *cfg;
-	char *copy, *name, *passwd, *email, *dir, *fmt, *fmts, *fn=NULL;
-	char comment[256];
-	struct ast_filestream *writer, *others[MAX_OTHER_FORMATS];
-	char *sfmt[MAX_OTHER_FORMATS];
-	int res = -1, fmtcnt=0, x;
-	int msgnum;
-	int outmsg=0;
-	struct ast_frame *f;
-	
-	cfg = ast_load(VOICEMAIL_CONFIG);
-	if (!cfg) {
-		ast_log(LOG_WARNING, &quot;No such configuration file %s\n&quot;, VOICEMAIL_CONFIG);
-		return -1;
-	}
-	if ((copy = ast_variable_retrieve(cfg, chan-&gt;context, ext))) {
-		/* Make sure they have an entry in the config */
-		copy = strdup(copy);
-		passwd = strtok(copy, &quot;,&quot;);
-		name = strtok(NULL, &quot;,&quot;);
-		email = strtok(NULL, &quot;,&quot;);
-		dir = get_dir(ext, &quot;&quot;);
-		/* It's easier just to try to make it than to check for its existence */
-		if (mkdir(dir, 0700) &amp;&amp; (errno != EEXIST))
-			ast_log(LOG_WARNING, &quot;mkdir '%s' failed: %s\n&quot;, dir, strerror(errno));
-		dir = get_dir(ext, &quot;INBOX&quot;);
-		if (mkdir(dir, 0700) &amp;&amp; (errno != EEXIST))
-			ast_log(LOG_WARNING, &quot;mkdir '%s' failed: %s\n&quot;, dir, strerror(errno));
-		/* Stream an info message */
-		if (silent || !ast_streamfile(chan, INTRO)) {
-			/* Wait for the message to finish */
-			if (silent || !ast_waitstream(chan, &quot;&quot;)) {
-				fmt = ast_variable_retrieve(cfg, &quot;general&quot;, &quot;format&quot;);
-				if (fmt) {
-					fmts = strdup(fmt);
-					fmt = strtok(fmts, &quot;|&quot;);
-					msgnum = 0;
-					do {
-						if (fn)
-							free(fn);
-						fn = get_fn(dir, msgnum);
-						snprintf(comment, sizeof(comment), &quot;Voicemail from %s to %s (%s) on %s\n&quot;,
-											(chan-&gt;callerid ? chan-&gt;callerid : &quot;Unknown&quot;), 
-											name, ext, chan-&gt;name);
-						writer = ast_writefile(fn, fmt, comment, O_EXCL, 1 /* check for other formats */, 0700);
-						if (!writer &amp;&amp; (errno != EEXIST))
-							break;
-						msgnum++;
-					} while(!writer &amp;&amp; (msgnum &lt; MAXMSG));
-					if (writer) {
-						/* We need to reset these values */
-						free(fmts);
-						fmt = ast_variable_retrieve(cfg, &quot;general&quot;, &quot;format&quot;);
-						fmts = strdup(fmt);
-						strtok(fmts, &quot;|&quot;);
-						while((fmt = strtok(NULL, &quot;|&quot;))) {
-							if (fmtcnt &gt; MAX_OTHER_FORMATS - 1) {
-								ast_log(LOG_WARNING, &quot;Please increase MAX_OTHER_FORMATS in app_voicemail.c\n&quot;);
-								break;
-							}
-							sfmt[fmtcnt++] = strdup(fmt);
-						}
-						for (x=0;x&lt;fmtcnt;x++) {
-							others[x] = ast_writefile(fn, sfmt[x], comment, 0, 0, 0700);
-							if (!others[x]) {
-								/* Ick, the other format didn't work, but be sure not
-								   to leak memory here */
-								int y;
-								for(y=x+1;y &lt; fmtcnt;y++)
-									free(sfmt[y]);
-								break;
-							}
-							free(sfmt[x]);
-						}
-						if (x == fmtcnt) {
-							/* Loop forever, writing the packets we read to the writer(s), until
-							   we read a # or get a hangup */
-							if (option_verbose &gt; 2) 
-								ast_verbose( VERBOSE_PREFIX_3 &quot;Recording to %s\n&quot;, fn);
-							while((f = ast_read(chan))) {
-								if (f-&gt;frametype == AST_FRAME_VOICE) {
-									/* Write the primary format */
-									res = ast_writestream(writer, f);
-									/* And each of the others */
-									for (x=0;x&lt;fmtcnt;x++)
-										res |= ast_writestream(others[x], f);
-									ast_frfree(f);
-									/* Exit on any error */
-									if (res) {
-										ast_log(LOG_WARNING, &quot;Error writing frame\n&quot;);
-										break;
-									}
-								}
-								if (f-&gt;frametype == AST_FRAME_DTMF) {
-									if (f-&gt;subclass == '#') {
-										if (option_verbose &gt; 2) 
-											ast_verbose( VERBOSE_PREFIX_3 &quot;User ended message by pressing %c\n&quot;, f-&gt;subclass);
-										outmsg=2;
-										break;
-									}
-								}
-							}
-							if (!f) {
-								if (option_verbose &gt; 2) 
-									ast_verbose( VERBOSE_PREFIX_3 &quot;User hung up\n&quot;);
-								res = -1;
-								outmsg=1;
-							}
-						} else {
-							ast_log(LOG_WARNING, &quot;Error creating writestream '%s', format '%s'\n&quot;, fn, sfmt[x]); 
-							free(sfmt[x]);
-						}
-						ast_closestream(writer);
-						for (x=0;x&lt;fmtcnt;x++) {
-							if (!others[x])
-								break;
-							ast_closestream(others[x]);
-						}
-						if (outmsg) {
-							if (outmsg &gt; 1) {
-								/* Let them know it worked */
-								ast_streamfile(chan, &quot;vm-msgsaved&quot;);
-								ast_waitstream(chan, &quot;&quot;);
-							}
-							/* Send e-mail if applicable */
-							if (email) 
-								sendmail(email, name, msgnum, ext);
-						}
-					} else {
-						if (msgnum &lt; MAXMSG)
-							ast_log(LOG_WARNING, &quot;Error writing to mailbox %s\n&quot;, ext);
-						else
-							ast_log(LOG_WARNING, &quot;Too many messages in mailbox %s\n&quot;, ext);
-					}
-					if (fn)
-						free(fn);
-					free(fmts);
-				} else 
-					ast_log(LOG_WARNING, &quot;No format to save messages in \n&quot;);
-			}
-		} else
-			ast_log(LOG_WARNING, &quot;Unable to playback instructions\n&quot;);
-			
-		free(dir);
-		free(copy);
-	} else
-		ast_log(LOG_WARNING, &quot;No entry in voicemail config file for '%s'\n&quot;, ext);
-	ast_destroy(cfg);
-	/* Leave voicemail for someone */
-	return res;
-}
-
-static int vm_execmain(struct ast_channel *chan, void *data)
-{
-	/* XXX This is, admittedly, some pretty horrendus code XXX */
-	int res=-1;
-	int valid = 0;
-	int curmsg = 0;
-	int maxmsg = 0;
-	int x;
-	char *fn, *nfn;
-	char d;
-	struct localuser *u;
-	char username[80];
-	char password[80], *copy;
-	int deleted[MAXMSG];
-	struct ast_config *cfg;
-	int state;
-	char *dir=NULL;
-	
-	LOCAL_USER_ADD(u);
-	cfg = ast_load(VOICEMAIL_CONFIG);
-	if (!cfg) {
-		ast_log(LOG_WARNING, &quot;No voicemail configuration\n&quot;);
-		goto out;
-	}
-	if (ast_streamfile(chan, &quot;vm-login&quot;))
-		goto out;
-	do {
-		/* Prompt for, and read in the username */
-		if (ast_readstring(chan, username, sizeof(username), 2000, 5000, &quot;#&quot;))
-			goto out;
-		if (ast_streamfile(chan, &quot;vm-password&quot;))
-			goto out;
-		if (ast_readstring(chan, password, sizeof(password), 2000, 5000, &quot;#&quot;))
-			goto out;
-		copy = ast_variable_retrieve(cfg, chan-&gt;context, username);
-		if (copy) {
-			copy = strdup(copy);
-			strtok(copy, &quot;,&quot;);
-			if (!strcmp(password,copy))
-				valid++;
-			else if (option_verbose &gt; 2)
-				ast_verbose( VERBOSE_PREFIX_3 &quot;Incorrect password '%s' for user '%s'\n&quot;, password, username);
-			free(copy);
-		} else if (option_verbose &gt; 2)
-			ast_verbose( VERBOSE_PREFIX_3 &quot;No such user '%s' in config file\n&quot;, username);
-		if (!valid) {
-			if (ast_streamfile(chan, &quot;vm-incorrect&quot;))
-				break;
-			if (ast_waitstream(chan, &quot;&quot;))
-				break;
-		}
-	} while (!valid);
-	if (valid) {
-		dir = get_dir(username, &quot;INBOX&quot;);
-		if (!dir) 
-			goto out;
-
-		deleted[0] = 0;
-		/* Find out how many messages are there, mark all as
-		   not deleted. */
-		do {
-			fn = get_fn(dir, maxmsg);
-			if ((res = ast_fileexists(fn, NULL))&gt;0) {
-				maxmsg++;
-				deleted[maxmsg] = 0;
-			}
-			free(fn);
-		} while(res &gt; 0);
-		if (ast_streamfile(chan, &quot;vm-youhave&quot;))
-			goto out;
-		if ((d=ast_waitstream(chan, AST_DIGIT_ANY)) &lt; 0)
-			goto out;
-		ast_stopstream(chan);
-		if (!d) {
-			/* If they haven't interrupted us, play the message count */
-			if (maxmsg &gt; 0) {
-				if ((d = ast_say_number(chan, maxmsg)) &lt; 0)
-					goto out;
-			} else {
-				if (ast_streamfile(chan, &quot;vm-no&quot;))
-					goto out;
-				if ((d=ast_waitstream(chan, AST_DIGIT_ANY)) &lt; 0)
-					goto out;
-				ast_stopstream(chan);
-			}
-			if (!d) {
-				/* And if they still haven't, give them the last word */
-				if (ast_streamfile(chan, ((maxmsg == 1) ? &quot;vm-message&quot; : &quot;vm-messages&quot;)))
-					goto out;
-				if (ast_waitstream(chan, AST_DIGIT_ANY) &lt; 0)
-					goto out;
-				ast_stopstream(chan);
-			}
-		}
-		res = -1;
-				
-#define STATE_STARTING 1
-#define STATE_MESSAGE 2
-#define STATE_MESSAGE_PLAYING 3
-		state = STATE_STARTING;
-		ast_log(LOG_EVENT, &quot;User '%s' logged in on channel '%s' with %d message(s).\n&quot;, username, chan-&gt;name, maxmsg);
-		if (option_verbose &gt; 2)
-			ast_verbose( VERBOSE_PREFIX_3 &quot;User '%s' logged in on channel %s with %d messages\n&quot;, username, chan-&gt;name, maxmsg);
-		if (!ast_streamfile(chan, &quot;vm-instructions&quot;)) {
-			for(;;) {
-				if (chan-&gt;stream || (chan-&gt;trans &amp;&amp; chan-&gt;trans-&gt;stream)) {
-					d = ast_waitstream(chan, AST_DIGIT_ANY);
-					ast_stopstream(chan);
-					if (!d &amp;&amp; (state == STATE_MESSAGE_PLAYING)) {
-						state  = STATE_MESSAGE;
-						/* If it runs out playing a message, then give directions */
-						if (!(d = ast_streamfile(chan, &quot;vm-msginstruct&quot;)))
-							d = ast_waitstream(chan, AST_DIGIT_ANY);
-						ast_stopstream(chan);
-					}
-					if (!d)
-						d = ast_waitfordigit(chan, COMMAND_TIMEOUT);
-				} else
-					d = ast_waitfordigit(chan, COMMAND_TIMEOUT);
-				if (d &lt; 0)
-					goto out;
-restart:
-				if (!d || (d == '*')) {
-					/* If they don't say anything, play back a message.  We'll decide which one is
-					   best based up on where they are.  Ditto if they press the '*' key. */
-					switch(state) {
-					case STATE_STARTING:
-						if (ast_streamfile(chan, &quot;vm-instructions&quot;))
-							goto out;
-						break;
-					case STATE_MESSAGE:
-					case STATE_MESSAGE_PLAYING:
-						if (ast_streamfile(chan, &quot;vm-msginstruct&quot;))
-							goto out;
-						break;
-					default:
-						ast_log(LOG_WARNING, &quot;What do I do when they timeout/* in state %d?\n&quot;, state);
-					}
-				} else {
-					/* XXX Should we be command-compatible with Meridian mail?  Their system seems
-					       very confusing, but also widely used XXX */
-					/* They've entered (or started to enter) a command */
-					switch(d) {
-					case '0':
-						if (curmsg &lt; maxmsg) {
-							deleted[curmsg] = !deleted[curmsg];
-							if (deleted[curmsg]) {
-								if (ast_streamfile(chan, &quot;vm-deleted&quot;))
-									goto out;
-							} else {
-								if (ast_streamfile(chan, &quot;vm-undeleted&quot;))
-									goto out;
-							}
-						} else {
-							if (ast_streamfile(chan, &quot;vm-nomore&quot;))
-								goto out;
-						}
-						break;
-					case '1':
-						curmsg = 0;
-						if (maxmsg &gt; 0) {
-							/* Yuck */
-							if ((d = announce_message(chan, dir, curmsg)) &gt; 0)
-								goto restart;
-							else if (d &lt; 0)
-								goto out;
-						} else {
-							if (ast_streamfile(chan, &quot;vm-nomore&quot;))
-								goto out;
-						}
-						state = STATE_MESSAGE_PLAYING;
-						break;
-					case '4':
-						if (curmsg &gt; 0)
-							curmsg--;
-						/* Yuck */
-						if ((d = announce_message(chan, dir, curmsg)) &gt; 0)
-							goto restart;
-						else if (d &lt; 0)
-							goto out;
-						state = STATE_MESSAGE_PLAYING;
-						break;
-					case '5':
-						if ((d = announce_message(chan, dir, curmsg)) &gt; 0)
-							goto restart;
-						else if (d &lt; 0)
-							goto out;
-						state = STATE_MESSAGE_PLAYING;
-						break;
-					case '6':
-						if (curmsg &lt; maxmsg - 1) {
-							curmsg++;
-							if ((d = announce_message(chan, dir, curmsg)) &gt; 0)
-								goto restart;
-							else if (d &lt; 0)
-								goto out;
-						} else {
-							if (ast_streamfile(chan, &quot;vm-nomore&quot;))
-								goto out;
-						}
-						state = STATE_MESSAGE_PLAYING;
-						break;
-					/* XXX Message compose? It's easy!  Just read their # and, assuming it's in the config, 
-					       call the routine as if it were called from the PBX proper XXX */
-					case '#':
-						if (ast_streamfile(chan, &quot;vm-goodbye&quot;))
-							goto out;
-						if (ast_waitstream(chan, &quot;&quot;))
-							goto out;
-						res = 0;
-						goto out;
-						break;
-					default:
-						/* Double yuck */
-						d = '*';
-						goto restart;
-					}
-				}
-			}
-		}
-	}
-	
-out:
-	ast_stopstream(chan);
-	if (maxmsg) {
-		/* Get the deleted messages fixed */
-		curmsg = -1;
-		for (x=0;x&lt;maxmsg;x++) {
-			if (!deleted[x]) {
-				curmsg++;
-				fn = get_fn(dir, x);
-				nfn = get_fn(dir, curmsg);
-				if (strcmp(fn, nfn))
-					ast_filerename(fn, nfn, NULL);
-				free(fn);
-				free(nfn);
-			}
-		}
-		for (x = curmsg + 1; x&lt;maxmsg; x++) {
-			fn = get_fn(dir, x);
-			if (fn) {
-				ast_filedelete(fn, NULL);
-				free(fn);
-			}
-		}
-	}
-	if (dir)
-		free(dir);
-	if (cfg)
-		ast_destroy(cfg);
-	LOCAL_USER_REMOVE(u);
-	return res;
-}
-
-static int vm_exec(struct ast_channel *chan, void *data)
-{
-	int res=0, silent=0;
-	struct localuser *u;
-	char *ext = (char *)data;
-	
-	if (!data) {
-		ast_log(LOG_WARNING, &quot;vm requires an argument (extension)\n&quot;);
-		return -1;
-	}
-	LOCAL_USER_ADD(u);
-	if (*ext == 's') {
-		silent++;
-		ext++;
-	}
-	res = leave_voicemail(chan, ext, silent);
-	LOCAL_USER_REMOVE(u);
-	return res;
-}
-
-int unload_module(void)
-{
-	int res;
-	STANDARD_HANGUP_LOCALUSERS;
-	res = ast_unregister_application(app);
-	res |= ast_unregister_application(app2);
-	return res;
-}
-
-int load_module(void)
-{
-	int res;
-	res = ast_register_application(app, vm_exec);
-	if (!res)
-		res = ast_register_application(app2, vm_execmain);
-	return res;
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/asterisk.c
===================================================================
--- trunk/asterisk.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/asterisk.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,98 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Top level source file for asterisk
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;signal.h&gt;
-#include &quot;asterisk.h&quot;
-
-int option_verbose=0;
-int option_debug=0;
-int option_nofork=0;
-int option_quiet=0;
-
-static void urg_handler(int num)
-{
-	/* Called by soft_hangup to interrupt the select, read, or other
-	   system call.  We don't actually need to do anything though.  */
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Urgent handler\n&quot;);
-	return;
-}
-
-static void quit_handler(int num)
-{
-	/* Called on exit */
-	if (option_verbose)
-		ast_verbose(&quot;Asterisk ending (%d).\n&quot;, num);
-	else if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Asterisk ending (%d).\n&quot;, num);
-	exit(0);
-}
-
-int main(int argc, char *argv[])
-{
-	char c;
-	/* Check if we're root */
-	if (geteuid()) {
-		ast_log(LOG_ERROR, &quot;Must be run as root\n&quot;);
-		exit(1);
-	}
-	/* Check for options */
-	while((c=getopt(argc, argv, &quot;dvq&quot;)) != EOF) {
-		switch(c) {
-		case 'd':
-			option_debug++;
-			option_nofork++;
-			option_verbose++;
-			break;
-		case 'v':
-			option_verbose++;
-			break;
-		case 'q':
-			option_quiet++;
-			break;
-		case '?':
-			exit(1);
-		}
-	}
-	/* Print a welcome message if desired */
-	if (option_verbose) {
-		ast_verbose( &quot;Asterisk, Copyright (C) 1999 Adtran, Inc. and Linux Support Services, LLC\n&quot;);
-		ast_verbose( &quot;Written by Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;\n&quot;);
-		ast_verbose( &quot;=========================================================================\n&quot;);
-	}
-	signal(SIGURG, urg_handler);
-	signal(SIGINT, quit_handler);
-	signal(SIGTERM, quit_handler);
-	signal(SIGHUP, quit_handler);
-	if (init_logger())
-		exit(1);
-	if (load_pbx())
-		exit(1);
-	if (load_modules())
-		exit(1);
-	/* We might have the option of showing a console, but for now just
-	   do nothing... */
-	if (option_verbose)
-		ast_verbose( &quot;Asterisk Ready.\n&quot;);
-	select(0,NULL,NULL,NULL,NULL);
-	return 0;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/channel.c
===================================================================
--- trunk/channel.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/channel.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,406 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Channel Management
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;string.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;signal.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;asterisk/sched.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/channel_pvt.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/file.h&gt;
-
-struct chanlist {
-	char type[80];
-	char description[80];
-	int capabilities;
-	struct ast_channel * (*requester)(char *type, int format, void *data);
-	struct chanlist *next;
-} *backends = NULL;
-
-/* Protect the channel list (highly unlikely that two things would change
-   it at the same time, but still! */
-   
-static pthread_mutex_t chlock = PTHREAD_MUTEX_INITIALIZER;
-
-int ast_channel_register(char *type, char *description, int capabilities,
-		struct ast_channel *(*requester)(char *type, int format, void *data))
-{
-	struct chanlist *chan, *last=NULL;
-	if (pthread_mutex_lock(&amp;chlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock channel list\n&quot;);
-		return -1;
-	}
-	chan = backends;
-	while(chan) {
-		if (!strcasecmp(type, chan-&gt;type)) {
-			ast_log(LOG_WARNING, &quot;Already have a handler for type '%s'\n&quot;, type);
-			pthread_mutex_unlock(&amp;chlock);
-			return -1;
-		}
-		last = chan;
-		chan = chan-&gt;next;
-	}
-	chan = malloc(sizeof(struct chanlist));
-	if (!chan) {
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-		pthread_mutex_unlock(&amp;chlock);
-		return -1;
-	}
-	strncpy(chan-&gt;type, type, sizeof(chan-&gt;type));
-	strncpy(chan-&gt;description, description, sizeof(chan-&gt;description));
-	chan-&gt;capabilities = capabilities;
-	chan-&gt;requester = requester;
-	chan-&gt;next = NULL;
-	if (last)
-		last-&gt;next = chan;
-	else
-		backends = chan;
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Registered handler for '%s' (%s)\n&quot;, chan-&gt;type, chan-&gt;description);
-	else if (option_verbose &gt; 1)
-		ast_verbose( VERBOSE_PREFIX_2 &quot;Registered channel type '%s' (%s)\n&quot;, chan-&gt;type, chan-&gt;description);
-	pthread_mutex_unlock(&amp;chlock);
-	return 0;
-}
-
-struct ast_channel *ast_channel_alloc(void)
-{
-	struct ast_channel *tmp;
-	struct ast_channel_pvt *pvt;
-	tmp = malloc(sizeof(struct ast_channel));
-	memset(tmp, 0, sizeof(struct ast_channel));
-	if (tmp) {
-		pvt = malloc(sizeof(struct ast_channel_pvt));
-		if (pvt) {
-			memset(pvt, 0, sizeof(struct ast_channel_pvt));
-			tmp-&gt;sched = sched_context_create();
-			if (tmp-&gt;sched) {
-				tmp-&gt;fd = -1;
-				strncpy(tmp-&gt;name, &quot;**Unknown**&quot;, sizeof(tmp-&gt;name));
-				tmp-&gt;pvt = pvt;
-				tmp-&gt;state = AST_STATE_DOWN;
-				tmp-&gt;stack = -1;
-				tmp-&gt;streamid = -1;
-				strncpy(tmp-&gt;context, &quot;default&quot;, sizeof(tmp-&gt;context));
-				strncpy(tmp-&gt;exten, &quot;s&quot;, sizeof(tmp-&gt;exten));
-				tmp-&gt;priority=1;
-			} else {
-				ast_log(LOG_WARNING, &quot;Unable to create schedule context\n&quot;);
-				free(tmp);
-				tmp = NULL;
-			}
-		} else {
-			ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-			free(tmp);
-			tmp = NULL;
-		}
-	} else 
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-	return tmp;
-}
-
-int ast_softhangup(struct ast_channel *chan)
-{
-	int res = 0;
-	if (chan-&gt;stream)
-		ast_stopstream(chan);
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Soft-Hanging up channel '%s'\n&quot;, chan-&gt;name);
-	if (chan-&gt;trans)
-		ast_log(LOG_WARNING, &quot;Soft hangup called on '%s' while a translator is in place!  Expect a failure.\n&quot;, chan-&gt;name);
-	if (chan-&gt;pvt-&gt;hangup)
-		res = chan-&gt;pvt-&gt;hangup(chan);
-	if (chan-&gt;pvt-&gt;pvt)
-		ast_log(LOG_WARNING, &quot;Channel '%s' may not have been hung up properly\n&quot;, chan-&gt;name);
-	if (chan-&gt;pbx) 
-		ast_log(LOG_WARNING, &quot;PBX may not have been terminated properly on '%s'\n&quot;, chan-&gt;name);	
-	/* Interrupt any select call or such */
-	if (chan-&gt;blocking)
-		pthread_kill(chan-&gt;blocker, SIGURG);
-	return res;
-}
-
-int ast_hangup(struct ast_channel *chan)
-{
-	int res = 0;
-	if (chan-&gt;stream)
-		ast_stopstream(chan);
-	if (chan-&gt;sched)
-		sched_context_destroy(chan-&gt;sched);
-	if (chan-&gt;blocking)
-		ast_log(LOG_WARNING, &quot;Hard hangup called, while fd is blocking!  Expect a failure\n&quot;);
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Hanging up channel '%s'\n&quot;, chan-&gt;name);
-	if (chan-&gt;pvt-&gt;hangup)
-		res = chan-&gt;pvt-&gt;hangup(chan);
-	if (chan-&gt;pvt-&gt;pvt)
-		ast_log(LOG_WARNING, &quot;Channel '%s' may not have been hung up properly\n&quot;, chan-&gt;name);
-	if (chan-&gt;trans)
-		ast_log(LOG_WARNING, &quot;Hard hangup called on '%s' while a translator is in place!  Expect a failure.\n&quot;, chan-&gt;name);
-	if (chan-&gt;pbx) 
-		ast_log(LOG_WARNING, &quot;PBX may not have been terminated properly on '%s'\n&quot;, chan-&gt;name);
-	if (chan-&gt;dnid)
-		free(chan-&gt;dnid);
-	if (chan-&gt;callerid)
-		free(chan-&gt;callerid);	
-	free(chan-&gt;pvt);
-	free(chan);
-	return res;
-}
-
-void ast_channel_unregister(char *type)
-{
-	struct chanlist *chan, *last=NULL;
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Unregistering channel type '%s'\n&quot;, type);
-	if (pthread_mutex_lock(&amp;chlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock channel list\n&quot;);
-		return;
-	}
-	chan = backends;
-	while(chan) {
-		if (!strcasecmp(chan-&gt;type, type)) {
-			if (last)
-				last-&gt;next = chan-&gt;next;
-			else
-				backends = backends-&gt;next;
-			free(chan);
-			pthread_mutex_unlock(&amp;chlock);
-			return;
-		}
-		last = chan;
-		chan = chan-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;chlock);
-}
-
-int ast_answer(struct ast_channel *chan)
-{
-	/* Answer the line, if possible */
-	if (chan-&gt;state == AST_STATE_RING) {
-		if (chan-&gt;pvt-&gt;answer)
-			return chan-&gt;pvt-&gt;answer(chan);
-	}
-	return 0;
-}
-
-int ast_waitfor_n_fd(int *fds, int n, int *ms)
-{
-	/* Wait for x amount of time on a file descriptor to have input.  */
-	struct timeval tv;
-	fd_set rfds, efds;
-	int res;
-	int x, max=-1;
-	int winner = -1;
-	
-	tv.tv_sec = *ms / 1000;
-	tv.tv_usec = (*ms % 1000) * 1000;
-	FD_ZERO(&amp;rfds);
-	FD_ZERO(&amp;efds);
-	for (x=0;x&lt;n;x++) {
-		FD_SET(fds[x], &amp;rfds);
-		FD_SET(fds[x], &amp;efds);
-		if (fds[x] &gt; max)
-			max = fds[x];
-	}
-	if (*ms &gt;= 0) 
-		res = select(max + 1, &amp;rfds, NULL, &amp;efds, &amp;tv);
-	else
-		res = select(max + 1, &amp;rfds, NULL, &amp;efds, NULL);
-	for (x=0;x&lt;n;x++) {
-		if ((FD_ISSET(fds[x], &amp;rfds) || FD_ISSET(fds[x], &amp;efds)) &amp;&amp; (winner &lt; 0))
-			winner = fds[x];
-	}
-	*ms = tv.tv_sec * 1000 + tv.tv_usec / 1000;
-	if (res &lt; 0)
-		*ms = -10;
-	return winner;
-}
-
-struct ast_channel *ast_waitfor_n(struct ast_channel **c, int n, int *ms)
-{
-	/* Wait for x amount of time on a file descriptor to have input.  */
-	struct timeval tv;
-	fd_set rfds, efds;
-	int res;
-	int x, max=-1;
-	struct ast_channel *winner = NULL;
-	
-	tv.tv_sec = *ms / 1000;
-	tv.tv_usec = (*ms % 1000) * 1000;
-	FD_ZERO(&amp;rfds);
-	FD_ZERO(&amp;efds);
-	for (x=0;x&lt;n;x++) {
-		FD_SET(c[x]-&gt;fd, &amp;rfds);
-		FD_SET(c[x]-&gt;fd, &amp;efds);
-		CHECK_BLOCKING(c[x]);
-		if (c[x]-&gt;fd &gt; max)
-			max = c[x]-&gt;fd;
-	}
-	if (*ms &gt;= 0) 
-		res = select(max + 1, &amp;rfds, NULL, &amp;efds, &amp;tv);
-	else
-		res = select(max + 1, &amp;rfds, NULL, &amp;efds, NULL);
-	for (x=0;x&lt;n;x++) {
-		c[x]-&gt;blocking = 0;
-		if ((FD_ISSET(c[x]-&gt;fd, &amp;rfds) || FD_ISSET(c[x]-&gt;fd, &amp;efds)) &amp;&amp; !winner)
-			winner = c[x];
-	}
-	*ms = tv.tv_sec * 1000 + tv.tv_usec / 1000;
-	if (res &lt; 0)
-		*ms = -10;
-	return winner;
-}
-
-int ast_waitfor(struct ast_channel *c, int ms)
-{
-	if (ast_waitfor_n(&amp;c, 1, &amp;ms)) {
-		if (ms &lt; 0)
-			return -ms;
-		return ms;
-	}
-	/* Error if ms &lt; 0 */
-	if (ms &lt; 0) 
-		return -1;
-	return 0;
-}
-
-char ast_waitfordigit(struct ast_channel *c, int ms)
-{
-	struct ast_frame *f;
-	char result = 0;
-	/* Wait for a digit, no more than ms milliseconds total. */
-	while(ms &amp;&amp; !result) {
-		ms = ast_waitfor(c, ms);
-		if (ms &lt; 0) /* Error */
-			result = -1; 
-		else if (ms &gt; 0) {
-			/* Read something */
-			f = ast_read(c);
-			if (f) {
-				if (f-&gt;frametype == AST_FRAME_DTMF) 
-					result = f-&gt;subclass;
-				ast_frfree(f);
-			} else
-				result = -1;
-		}
-	}
-	return result;
-}
-
-struct ast_frame *ast_read(struct ast_channel *chan)
-{
-	struct ast_frame *f = NULL;
-	chan-&gt;blocker = pthread_self();
-	if (chan-&gt;pvt-&gt;read)
-		f = chan-&gt;pvt-&gt;read(chan);
-	else
-		ast_log(LOG_WARNING, &quot;No read routine on channel %s\n&quot;, chan);
-	return f;
-}
-
-int ast_write(struct ast_channel *chan, struct ast_frame *fr)
-{
-	int res = -1;
-	CHECK_BLOCKING(chan);
-	switch(fr-&gt;frametype) {
-	case AST_FRAME_CONTROL:
-		/* XXX Interpret control frames XXX */
-		ast_log(LOG_WARNING, &quot;Don't know how to handle control frames yet\n&quot;);
-		break;
-	case AST_FRAME_DTMF:
-		
-		if (chan-&gt;pvt-&gt;send_digit)
-			res = chan-&gt;pvt-&gt;send_digit(chan, fr-&gt;subclass);
-		break;
-	default:
-		if (chan-&gt;pvt-&gt;write)
-			res = chan-&gt;pvt-&gt;write(chan, fr);
-	}
-	chan-&gt;blocking = 0;
-	return res;
-}
-
-struct ast_channel *ast_request(char *type, int format, void *data)
-{
-	struct chanlist *chan;
-	struct ast_channel *c = NULL;
-	if (pthread_mutex_lock(&amp;chlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock channel list\n&quot;);
-		return NULL;
-	}
-	chan = backends;
-	while(chan) {
-		if (!strcasecmp(type, chan-&gt;type)) {
-			if (chan-&gt;requester)
-				c = chan-&gt;requester(type, format, data);
-			pthread_mutex_unlock(&amp;chlock);
-			break;
-		}
-		chan = chan-&gt;next;
-	}
-	if (!chan)
-		ast_log(LOG_WARNING, &quot;No channel type registered for '%s'\n&quot;, type);
-	return c;
-}
-
-int ast_call(struct ast_channel *chan, char *addr, int timeout) 
-{
-	/* Place an outgoing call, but don't wait any longer than timeout ms before returning. 
-	   If the remote end does not answer within the timeout, then do NOT hang up, but 
-	   return anyway.  */
-	int res = -1;
-	if (chan-&gt;pvt-&gt;call)
-		res = chan-&gt;pvt-&gt;call(chan, addr, timeout);
-	return res;
-}
-
-int ast_readstring(struct ast_channel *c, char *s, int len, int timeout, int ftimeout, char *enders)
-{
-	int pos=0;
-	int to = ftimeout;
-	char d;
-	if (!len)
-		return -1;
-	do {
-		if (c-&gt;streamid &gt; -1) {
-			d = ast_waitstream(c, AST_DIGIT_ANY);
-			ast_stopstream(c);
-			if (!d)
-				d = ast_waitfordigit(c, to);
-		} else {
-			d = ast_waitfordigit(c, to);
-		}
-		if (d &lt; 0)
-			return -1;
-		if (!strchr(enders, d))
-			s[pos++] = d;
-		if ((d == 0) || strchr(enders, d) || (pos &gt;= len - 1)) {
-			s[pos]='\0';
-			return 0;
-		}
-		to = timeout;
-	} while(1);
-	/* Never reached */
-	return 0;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/channels/DialTone.h
===================================================================
--- trunk/channels/DialTone.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/channels/DialTone.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,258 +3,6 @@
   *
   * Source: DialTone.ulaw
   *
-  * Copyright (C) 1999, Mark Spencer and Linux Support Services
-  *
-  * Distributed under the terms of the GNU General Public License
-  *
-  */
-
-static unsigned char DialTone[] = {
-0xff, 0xab, 0x9d, 0x96, 0x91, 0x90, 0x91, 0x96, 0x9c, 0xaa, 
-0xd9, 0x2f, 0x1f, 0x19, 0x15, 0x14, 0x15, 0x19, 0x1f, 0x2c, 
-0x4e, 0xb9, 0xa7, 0x9f, 0x9c, 0x9b, 0x9c, 0x9f, 0xa7, 0xb3, 
-0xcf, 0x47, 0x34, 0x2d, 0x2a, 0x2a, 0x2c, 0x31, 0x3a, 0x47, 
-0x5f, 0xe4, 0xd8, 0xd9, 0xe9, 0x64, 0x4f, 0x49, 0x46, 0x49, 
-0x58, 0xde, 0xc2, 0xb5, 0xad, 0xa8, 0xa6, 0xa6, 0xa9, 0xaf, 
-0xbf, 0x56, 0x32, 0x26, 0x1e, 0x1b, 0x19, 0x1a, 0x1d, 0x24, 
-0x33, 0xdd, 0xad, 0x9f, 0x98, 0x94, 0x92, 0x93, 0x97, 0x9e, 
-0xac, 0xf8, 0x2c, 0x1d, 0x16, 0x11, 0xf, 0x10, 0x15, 0x1b, 
-0x29, 0x55, 0xae, 0x9e, 0x97, 0x92, 0x90, 0x91, 0x95, 0x9c, 
-0xa8, 0xca, 0x35, 0x22, 0x1a, 0x16, 0x15, 0x16, 0x19, 0x1f, 
-0x2b, 0x47, 0xbe, 0xab, 0xa2, 0x9e, 0x9d, 0x9e, 0xa2, 0xa9, 
-0xb4, 0xcc, 0x4f, 0x3a, 0x32, 0x2f, 0x2f, 0x32, 0x39, 0x41, 
-0x4f, 0x67, 0xf5, 0xf5, 0x67, 0x51, 0x46, 0x3e, 0x3b, 0x3b, 
-0x3f, 0x4d, 0xe2, 0xbe, 0xb0, 0xa9, 0xa4, 0xa1, 0xa1, 0xa5, 
-0xab, 0xba, 0x64, 0x33, 0x25, 0x1d, 0x19, 0x17, 0x18, 0x1b, 
-0x20, 0x2e, 0x72, 0xae, 0x9f, 0x98, 0x94, 0x91, 0x92, 0x96, 
-0x9c, 0xa9, 0xd4, 0x2f, 0x1e, 0x17, 0x11, 0xf, 0x10, 0x14, 
-0x1a, 0x26, 0x48, 0xb2, 0x9f, 0x98, 0x93, 0x91, 0x92, 0x95, 
-0x9b, 0xa7, 0xc1, 0x3a, 0x25, 0x1c, 0x18, 0x16, 0x17, 0x1a, 
-0x1f, 0x2b, 0x42, 0xc6, 0xae, 0xa6, 0xa0, 0x9f, 0xa0, 0xa5, 
-0xab, 0xb6, 0xcb, 0x5a, 0x40, 0x39, 0x36, 0x37, 0x3b, 0x43, 
-0x4e, 0x60, 0x7b, 0x7c, 0x60, 0x4e, 0x41, 0x3a, 0x34, 0x32, 
-0x33, 0x39, 0x45, 0xed, 0xbd, 0xae, 0xa6, 0xa0, 0x9e, 0x9e, 
-0xa0, 0xa8, 0xb4, 0xef, 0x34, 0x24, 0x1c, 0x18, 0x16, 0x16, 
-0x19, 0x1e, 0x2b, 0x54, 0xb1, 0x9f, 0x98, 0x93, 0x91, 0x91, 
-0x95, 0x9b, 0xa6, 0xc6, 0x33, 0x1f, 0x17, 0x12, 0xf, 0x10, 
-0x13, 0x1a, 0x24, 0x3e, 0xb8, 0xa2, 0x99, 0x94, 0x92, 0x92, 
-0x96, 0x9b, 0xa6, 0xbc, 0x40, 0x29, 0x1e, 0x1a, 0x18, 0x19, 
-0x1b, 0x20, 0x2b, 0x3f, 0xcf, 0xb3, 0xa9, 0xa5, 0xa3, 0xa4, 
-0xa8, 0xae, 0xb9, 0xcc, 0x67, 0x49, 0x40, 0x3f, 0x42, 0x4a, 
-0x59, 0x79, 0xe5, 0xe4, 0x7a, 0x54, 0x43, 0x39, 0x31, 0x2d, 
-0x2c, 0x2d, 0x32, 0x3e, 0x71, 0xbd, 0xad, 0xa4, 0x9e, 0x9c, 
-0x9c, 0x9e, 0xa4, 0xaf, 0xd7, 0x36, 0x24, 0x1c, 0x17, 0x15, 
-0x15, 0x17, 0x1d, 0x28, 0x47, 0xb5, 0xa1, 0x98, 0x93, 0x90, 
-0x90, 0x93, 0x99, 0xa4, 0xbd, 0x38, 0x21, 0x18, 0x13, 0x10, 
-0x10, 0x13, 0x19, 0x22, 0x39, 0xbe, 0xa5, 0x9b, 0x96, 0x93, 
-0x93, 0x96, 0x9b, 0xa5, 0xb9, 0x4a, 0x2c, 0x20, 0x1c, 0x1a, 
-0x1a, 0x1d, 0x22, 0x2c, 0x3d, 0xdc, 0xb8, 0xad, 0xa9, 0xa8, 
-0xa9, 0xac, 0xb2, 0xbd, 0xce, 0x78, 0x54, 0x4d, 0x4f, 0x5a, 
-0xff, 0xda, 0xcf, 0xcd, 0xd4, 0xf8, 0x4e, 0x3d, 0x32, 0x2c, 
-0x29, 0x28, 0x29, 0x2d, 0x38, 0x5c, 0xbd, 0xac, 0xa2, 0x9d, 
-0x9a, 0x9a, 0x9c, 0xa0, 0xac, 0xca, 0x39, 0x25, 0x1b, 0x16, 
-0x13, 0x13, 0x16, 0x1b, 0x25, 0x3e, 0xb9, 0xa2, 0x99, 0x93, 
-0x90, 0x90, 0x93, 0x98, 0xa1, 0xb8, 0x3d, 0x24, 0x19, 0x13, 
-0x10, 0x10, 0x13, 0x18, 0x21, 0x35, 0xc7, 0xa8, 0x9d, 0x97, 
-0x95, 0x95, 0x97, 0x9c, 0xa4, 0xb6, 0x57, 0x2f, 0x24, 0x1e, 
-0x1c, 0x1c, 0x1e, 0x24, 0x2d, 0x3d, 0xf1, 0xbe, 0xb2, 0xad, 
-0xac, 0xad, 0xb1, 0xb9, 0xc3, 0xd4, 0xfa, 0x64, 0x65, 0xf9, 
-0xd9, 0xca, 0xc2, 0xbf, 0xc0, 0xc9, 0xe7, 0x4c, 0x39, 0x2e, 
-0x28, 0x24, 0x23, 0x25, 0x29, 0x33, 0x4f, 0xbf, 0xab, 0xa0, 
-0x9b, 0x99, 0x98, 0x9a, 0x9e, 0xa9, 0xc0, 0x3c, 0x26, 0x1b, 
-0x16, 0x12, 0x12, 0x14, 0x19, 0x22, 0x38, 0xbe, 0xa4, 0x9a, 
-0x93, 0x90, 0x8f, 0x92, 0x97, 0x9f, 0xb3, 0x46, 0x26, 0x1b, 
-0x15, 0x11, 0x11, 0x13, 0x18, 0x1f, 0x31, 0xd4, 0xab, 0x9e, 
-0x99, 0x96, 0x96, 0x98, 0x9c, 0xa4, 0xb4, 0x6f, 0x34, 0x28, 
-0x20, 0x1e, 0x1e, 0x20, 0x26, 0x2e, 0x3d, 0x6d, 0xc5, 0xb9, 
-0xb3, 0xb2, 0xb4, 0xba, 0xc1, 0xcd, 0xe0, 0xfc, 0xfb, 0xe0, 
-0xce, 0xc3, 0xbb, 0xb7, 0xb6, 0xb9, 0xc0, 0xda, 0x4b, 0x36, 
-0x2b, 0x25, 0x20, 0x1f, 0x20, 0x26, 0x2e, 0x46, 0xc2, 0xab, 
-0x9f, 0x9a, 0x97, 0x96, 0x98, 0x9c, 0xa5, 0xba, 0x41, 0x27, 
-0x1b, 0x15, 0x12, 0x11, 0x13, 0x18, 0x1f, 0x32, 0xc8, 0xa6, 
-0x9a, 0x94, 0x90, 0x8f, 0x91, 0x97, 0x9e, 0xaf, 0x54, 0x29, 
-0x1c, 0x16, 0x12, 0x11, 0x14, 0x18, 0x1f, 0x2e, 0xf2, 0xae, 
-0xa0, 0x9b, 0x98, 0x97, 0x99, 0x9d, 0xa5, 0xb3, 0xe4, 0x3a, 
-0x2b, 0x25, 0x21, 0x21, 0x24, 0x29, 0x30, 0x3e, 0x62, 0xcd, 
-0xbf, 0xbb, 0xbb, 0xbe, 0xc6, 0xd1, 0xe7, 0x76, 0x75, 0xe7, 
-0xcf, 0xc1, 0xb9, 0xb2, 0xaf, 0xaf, 0xb2, 0xba, 0xcf, 0x4c, 
-0x34, 0x29, 0x22, 0x1e, 0x1d, 0x1e, 0x22, 0x2b, 0x3e, 0xc7, 
-0xab, 0x9f, 0x99, 0x96, 0x95, 0x96, 0x9a, 0xa2, 0xb5, 0x4a, 
-0x28, 0x1c, 0x15, 0x11, 0x10, 0x12, 0x17, 0x1e, 0x2e, 0xd5, 
-0xa9, 0x9b, 0x95, 0x90, 0x8f, 0x91, 0x96, 0x9d, 0xac, 0x78, 
-0x2c, 0x1e, 0x17, 0x13, 0x12, 0x14, 0x18, 0x1f, 0x2d, 0x5d, 
-0xb3, 0xa4, 0x9d, 0x9a, 0x99, 0x9b, 0x9e, 0xa6, 0xb2, 0xd6, 
-0x3f, 0x2f, 0x29, 0x26, 0x26, 0x28, 0x2d, 0x35, 0x42, 0x5e, 
-0xd8, 0xca, 0xc6, 0xc9, 0xcf, 0xe4, 0x69, 0x59, 0x58, 0x64, 
-0xdf, 0xc7, 0xba, 0xb1, 0xac, 0xaa, 0xaa, 0xad, 0xb4, 0xc7, 
-0x4f, 0x33, 0x27, 0x1f, 0x1c, 0x1b, 0x1c, 0x1f, 0x27, 0x39, 
-0xce, 0xac, 0x9f, 0x99, 0x95, 0x94, 0x95, 0x99, 0x9f, 0xaf, 
-0x59, 0x2a, 0x1c, 0x16, 0x11, 0x10, 0x11, 0x16, 0x1d, 0x2b, 
-0xff, 0xab, 0x9d, 0x96, 0x91, 0x90, 0x91, 0x96, 0x9c, 0xaa, 
-0xd9, 0x2f, 0x1f, 0x19, 0x15, 0x14, 0x15, 0x19, 0x1f, 0x2c, 
-0x4e, 0xb9, 0xa7, 0x9f, 0x9c, 0x9b, 0x9c, 0x9f, 0xa7, 0xb3, 
-0xcf, 0x47, 0x34, 0x2d, 0x2a, 0x2a, 0x2c, 0x31, 0x3a, 0x47, 
-0x5f, 0xe4, 0xd8, 0xd9, 0xe9, 0x64, 0x4f, 0x49, 0x46, 0x49, 
-0x58, 0xde, 0xc2, 0xb5, 0xad, 0xa8, 0xa6, 0xa6, 0xa9, 0xaf, 
-0xbf, 0x56, 0x32, 0x26, 0x1e, 0x1b, 0x19, 0x1a, 0x1d, 0x24, 
-0x33, 0xdd, 0xad, 0x9f, 0x98, 0x94, 0x92, 0x93, 0x97, 0x9e, 
-0xac, 0xf8, 0x2c, 0x1d, 0x16, 0x11, 0xf, 0x10, 0x15, 0x1b, 
-0x29, 0x55, 0xae, 0x9e, 0x97, 0x92, 0x90, 0x91, 0x95, 0x9c, 
-0xa8, 0xca, 0x35, 0x22, 0x1a, 0x16, 0x15, 0x16, 0x19, 0x1f, 
-0x2b, 0x47, 0xbe, 0xab, 0xa2, 0x9e, 0x9d, 0x9e, 0xa2, 0xa9, 
-0xb4, 0xcc, 0x4f, 0x3a, 0x32, 0x2f, 0x2f, 0x32, 0x39, 0x41, 
-0x4f, 0x67, 0xf5, 0xf5, 0x67, 0x51, 0x46, 0x3e, 0x3b, 0x3b, 
-0x3f, 0x4d, 0xe2, 0xbe, 0xb0, 0xa9, 0xa4, 0xa1, 0xa1, 0xa5, 
-0xab, 0xba, 0x64, 0x33, 0x25, 0x1d, 0x19, 0x17, 0x18, 0x1b, 
-0x20, 0x2e, 0x72, 0xae, 0x9f, 0x98, 0x94, 0x91, 0x92, 0x96, 
-0x9c, 0xa9, 0xd4, 0x2f, 0x1e, 0x17, 0x11, 0xf, 0x10, 0x14, 
-0x1a, 0x26, 0x48, 0xb2, 0x9f, 0x98, 0x93, 0x91, 0x92, 0x95, 
-0x9b, 0xa7, 0xc1, 0x3a, 0x25, 0x1c, 0x18, 0x16, 0x17, 0x1a, 
-0x1f, 0x2b, 0x42, 0xc6, 0xae, 0xa6, 0xa0, 0x9f, 0xa0, 0xa5, 
-0xab, 0xb6, 0xcb, 0x5a, 0x40, 0x39, 0x36, 0x37, 0x3b, 0x43, 
-0x4e, 0x60, 0x7b, 0x7c, 0x60, 0x4e, 0x41, 0x3a, 0x34, 0x32, 
-0x33, 0x39, 0x45, 0xed, 0xbd, 0xae, 0xa6, 0xa0, 0x9e, 0x9e, 
-0xa0, 0xa8, 0xb4, 0xef, 0x34, 0x24, 0x1c, 0x18, 0x16, 0x16, 
-0x19, 0x1e, 0x2b, 0x54, 0xb1, 0x9f, 0x98, 0x93, 0x91, 0x91, 
-0x95, 0x9b, 0xa6, 0xc6, 0x33, 0x1f, 0x17, 0x12, 0xf, 0x10, 
-0x13, 0x1a, 0x24, 0x3e, 0xb8, 0xa2, 0x99, 0x94, 0x92, 0x92, 
-0x96, 0x9b, 0xa6, 0xbc, 0x40, 0x29, 0x1e, 0x1a, 0x18, 0x19, 
-0x1b, 0x20, 0x2b, 0x3f, 0xcf, 0xb3, 0xa9, 0xa5, 0xa3, 0xa4, 
-0xa8, 0xae, 0xb9, 0xcc, 0x67, 0x49, 0x40, 0x3f, 0x42, 0x4a, 
-0x59, 0x79, 0xe5, 0xe4, 0x7a, 0x54, 0x43, 0x39, 0x31, 0x2d, 
-0x2c, 0x2d, 0x32, 0x3e, 0x71, 0xbd, 0xad, 0xa4, 0x9e, 0x9c, 
-0x9c, 0x9e, 0xa4, 0xaf, 0xd7, 0x36, 0x24, 0x1c, 0x17, 0x15, 
-0x15, 0x17, 0x1d, 0x28, 0x47, 0xb5, 0xa1, 0x98, 0x93, 0x90, 
-0x90, 0x93, 0x99, 0xa4, 0xbd, 0x38, 0x21, 0x18, 0x13, 0x10, 
-0x10, 0x13, 0x19, 0x22, 0x39, 0xbe, 0xa5, 0x9b, 0x96, 0x93, 
-0x93, 0x96, 0x9b, 0xa5, 0xb9, 0x4a, 0x2c, 0x20, 0x1c, 0x1a, 
-0x1a, 0x1d, 0x22, 0x2c, 0x3d, 0xdc, 0xb8, 0xad, 0xa9, 0xa8, 
-0xa9, 0xac, 0xb2, 0xbd, 0xce, 0x78, 0x54, 0x4d, 0x4f, 0x5a, 
-0xff, 0xda, 0xcf, 0xcd, 0xd4, 0xf8, 0x4e, 0x3d, 0x32, 0x2c, 
-0x29, 0x28, 0x29, 0x2d, 0x38, 0x5c, 0xbd, 0xac, 0xa2, 0x9d, 
-0x9a, 0x9a, 0x9c, 0xa0, 0xac, 0xca, 0x39, 0x25, 0x1b, 0x16, 
-0x13, 0x13, 0x16, 0x1b, 0x25, 0x3e, 0xb9, 0xa2, 0x99, 0x93, 
-0x90, 0x90, 0x93, 0x98, 0xa1, 0xb8, 0x3d, 0x24, 0x19, 0x13, 
-0x10, 0x10, 0x13, 0x18, 0x21, 0x35, 0xc7, 0xa8, 0x9d, 0x97, 
-0x95, 0x95, 0x97, 0x9c, 0xa4, 0xb6, 0x57, 0x2f, 0x24, 0x1e, 
-0x1c, 0x1c, 0x1e, 0x24, 0x2d, 0x3d, 0xf1, 0xbe, 0xb2, 0xad, 
-0xac, 0xad, 0xb1, 0xb9, 0xc3, 0xd4, 0xfa, 0x64, 0x65, 0xf9, 
-0xd9, 0xca, 0xc2, 0xbf, 0xc0, 0xc9, 0xe7, 0x4c, 0x39, 0x2e, 
-0x28, 0x24, 0x23, 0x25, 0x29, 0x33, 0x4f, 0xbf, 0xab, 0xa0, 
-0x9b, 0x99, 0x98, 0x9a, 0x9e, 0xa9, 0xc0, 0x3c, 0x26, 0x1b, 
-0x16, 0x12, 0x12, 0x14, 0x19, 0x22, 0x38, 0xbe, 0xa4, 0x9a, 
-0x93, 0x90, 0x8f, 0x92, 0x97, 0x9f, 0xb3, 0x46, 0x26, 0x1b, 
-0x15, 0x11, 0x11, 0x13, 0x18, 0x1f, 0x31, 0xd4, 0xab, 0x9e, 
-0x99, 0x96, 0x96, 0x98, 0x9c, 0xa4, 0xb4, 0x6f, 0x34, 0x28, 
-0x20, 0x1e, 0x1e, 0x20, 0x26, 0x2e, 0x3d, 0x6d, 0xc5, 0xb9, 
-0xb3, 0xb2, 0xb4, 0xba, 0xc1, 0xcd, 0xe0, 0xfc, 0xfb, 0xe0, 
-0xce, 0xc3, 0xbb, 0xb7, 0xb6, 0xb9, 0xc0, 0xda, 0x4b, 0x36, 
-0x2b, 0x25, 0x20, 0x1f, 0x20, 0x26, 0x2e, 0x46, 0xc2, 0xab, 
-0x9f, 0x9a, 0x97, 0x96, 0x98, 0x9c, 0xa5, 0xba, 0x41, 0x27, 
-0x1b, 0x15, 0x12, 0x11, 0x13, 0x18, 0x1f, 0x32, 0xc8, 0xa6, 
-0x9a, 0x94, 0x90, 0x8f, 0x91, 0x97, 0x9e, 0xaf, 0x54, 0x29, 
-0x1c, 0x16, 0x12, 0x11, 0x14, 0x18, 0x1f, 0x2e, 0xf2, 0xae, 
-0xa0, 0x9b, 0x98, 0x97, 0x99, 0x9d, 0xa5, 0xb3, 0xe4, 0x3a, 
-0x2b, 0x25, 0x21, 0x21, 0x24, 0x29, 0x30, 0x3e, 0x62, 0xcd, 
-0xbf, 0xbb, 0xbb, 0xbe, 0xc6, 0xd1, 0xe7, 0x76, 0x75, 0xe7, 
-0xcf, 0xc1, 0xb9, 0xb2, 0xaf, 0xaf, 0xb2, 0xba, 0xcf, 0x4c, 
-0x34, 0x29, 0x22, 0x1e, 0x1d, 0x1e, 0x22, 0x2b, 0x3e, 0xc7, 
-0xab, 0x9f, 0x99, 0x96, 0x95, 0x96, 0x9a, 0xa2, 0xb5, 0x4a, 
-0x28, 0x1c, 0x15, 0x11, 0x10, 0x12, 0x17, 0x1e, 0x2e, 0xd5, 
-0xa9, 0x9b, 0x95, 0x90, 0x8f, 0x91, 0x96, 0x9d, 0xac, 0x78, 
-0x2c, 0x1e, 0x17, 0x13, 0x12, 0x14, 0x18, 0x1f, 0x2d, 0x5d, 
-0xb3, 0xa4, 0x9d, 0x9a, 0x99, 0x9b, 0x9e, 0xa6, 0xb2, 0xd6, 
-0x3f, 0x2f, 0x29, 0x26, 0x26, 0x28, 0x2d, 0x35, 0x42, 0x5e, 
-0xd8, 0xca, 0xc6, 0xc9, 0xcf, 0xe4, 0x69, 0x59, 0x58, 0x64, 
-0xdf, 0xc7, 0xba, 0xb1, 0xac, 0xaa, 0xaa, 0xad, 0xb4, 0xc7, 
-0x4f, 0x33, 0x27, 0x1f, 0x1c, 0x1b, 0x1c, 0x1f, 0x27, 0x39, 
-0xce, 0xac, 0x9f, 0x99, 0x95, 0x94, 0x95, 0x99, 0x9f, 0xaf, 
-0x59, 0x2a, 0x1c, 0x16, 0x11, 0x10, 0x11, 0x16, 0x1d, 0x2b, 
-0xff, 0xab, 0x9d, 0x96, 0x91, 0x90, 0x91, 0x96, 0x9c, 0xaa, 
-0xd9, 0x2f, 0x1f, 0x19, 0x15, 0x14, 0x15, 0x19, 0x1f, 0x2c, 
-0x4e, 0xb9, 0xa7, 0x9f, 0x9c, 0x9b, 0x9c, 0x9f, 0xa7, 0xb3, 
-0xcf, 0x47, 0x34, 0x2d, 0x2a, 0x2a, 0x2c, 0x31, 0x3a, 0x47, 
-0x5f, 0xe4, 0xd8, 0xd9, 0xe9, 0x64, 0x4f, 0x49, 0x46, 0x49, 
-0x58, 0xde, 0xc2, 0xb5, 0xad, 0xa8, 0xa6, 0xa6, 0xa9, 0xaf, 
-0xbf, 0x56, 0x32, 0x26, 0x1e, 0x1b, 0x19, 0x1a, 0x1d, 0x24, 
-0x33, 0xdd, 0xad, 0x9f, 0x98, 0x94, 0x92, 0x93, 0x97, 0x9e, 
-0xac, 0xf8, 0x2c, 0x1d, 0x16, 0x11, 0xf, 0x10, 0x15, 0x1b, 
-0x29, 0x55, 0xae, 0x9e, 0x97, 0x92, 0x90, 0x91, 0x95, 0x9c, 
-0xa8, 0xca, 0x35, 0x22, 0x1a, 0x16, 0x15, 0x16, 0x19, 0x1f, 
-0x2b, 0x47, 0xbe, 0xab, 0xa2, 0x9e, 0x9d, 0x9e, 0xa2, 0xa9, 
-0xb4, 0xcc, 0x4f, 0x3a, 0x32, 0x2f, 0x2f, 0x32, 0x39, 0x41, 
-0x4f, 0x67, 0xf5, 0xf5, 0x67, 0x51, 0x46, 0x3e, 0x3b, 0x3b, 
-0x3f, 0x4d, 0xe2, 0xbe, 0xb0, 0xa9, 0xa4, 0xa1, 0xa1, 0xa5, 
-0xab, 0xba, 0x64, 0x33, 0x25, 0x1d, 0x19, 0x17, 0x18, 0x1b, 
-0x20, 0x2e, 0x72, 0xae, 0x9f, 0x98, 0x94, 0x91, 0x92, 0x96, 
-0x9c, 0xa9, 0xd4, 0x2f, 0x1e, 0x17, 0x11, 0xf, 0x10, 0x14, 
-0x1a, 0x26, 0x48, 0xb2, 0x9f, 0x98, 0x93, 0x91, 0x92, 0x95, 
-0x9b, 0xa7, 0xc1, 0x3a, 0x25, 0x1c, 0x18, 0x16, 0x17, 0x1a, 
-0x1f, 0x2b, 0x42, 0xc6, 0xae, 0xa6, 0xa0, 0x9f, 0xa0, 0xa5, 
-0xab, 0xb6, 0xcb, 0x5a, 0x40, 0x39, 0x36, 0x37, 0x3b, 0x43, 
-0x4e, 0x60, 0x7b, 0x7c, 0x60, 0x4e, 0x41, 0x3a, 0x34, 0x32, 
-0x33, 0x39, 0x45, 0xed, 0xbd, 0xae, 0xa6, 0xa0, 0x9e, 0x9e, 
-0xa0, 0xa8, 0xb4, 0xef, 0x34, 0x24, 0x1c, 0x18, 0x16, 0x16, 
-0x19, 0x1e, 0x2b, 0x54, 0xb1, 0x9f, 0x98, 0x93, 0x91, 0x91, 
-0x95, 0x9b, 0xa6, 0xc6, 0x33, 0x1f, 0x17, 0x12, 0xf, 0x10, 
-0x13, 0x1a, 0x24, 0x3e, 0xb8, 0xa2, 0x99, 0x94, 0x92, 0x92, 
-0x96, 0x9b, 0xa6, 0xbc, 0x40, 0x29, 0x1e, 0x1a, 0x18, 0x19, 
-0x1b, 0x20, 0x2b, 0x3f, 0xcf, 0xb3, 0xa9, 0xa5, 0xa3, 0xa4, 
-0xa8, 0xae, 0xb9, 0xcc, 0x67, 0x49, 0x40, 0x3f, 0x42, 0x4a, 
-0x59, 0x79, 0xe5, 0xe4, 0x7a, 0x54, 0x43, 0x39, 0x31, 0x2d, 
-0x2c, 0x2d, 0x32, 0x3e, 0x71, 0xbd, 0xad, 0xa4, 0x9e, 0x9c, 
-0x9c, 0x9e, 0xa4, 0xaf, 0xd7, 0x36, 0x24, 0x1c, 0x17, 0x15, 
-0x15, 0x17, 0x1d, 0x28, 0x47, 0xb5, 0xa1, 0x98, 0x93, 0x90, 
-0x90, 0x93, 0x99, 0xa4, 0xbd, 0x38, 0x21, 0x18, 0x13, 0x10, 
-0x10, 0x13, 0x19, 0x22, 0x39, 0xbe, 0xa5, 0x9b, 0x96, 0x93, 
-0x93, 0x96, 0x9b, 0xa5, 0xb9, 0x4a, 0x2c, 0x20, 0x1c, 0x1a, 
-0x1a, 0x1d, 0x22, 0x2c, 0x3d, 0xdc, 0xb8, 0xad, 0xa9, 0xa8, 
-0xa9, 0xac, 0xb2, 0xbd, 0xce, 0x78, 0x54, 0x4d, 0x4f, 0x5a, 
-0xff, 0xda, 0xcf, 0xcd, 0xd4, 0xf8, 0x4e, 0x3d, 0x32, 0x2c, 
-0x29, 0x28, 0x29, 0x2d, 0x38, 0x5c, 0xbd, 0xac, 0xa2, 0x9d, 
-0x9a, 0x9a, 0x9c, 0xa0, 0xac, 0xca, 0x39, 0x25, 0x1b, 0x16, 
-0x13, 0x13, 0x16, 0x1b, 0x25, 0x3e, 0xb9, 0xa2, 0x99, 0x93, 
-0x90, 0x90, 0x93, 0x98, 0xa1, 0xb8, 0x3d, 0x24, 0x19, 0x13, 
-0x10, 0x10, 0x13, 0x18, 0x21, 0x35, 0xc7, 0xa8, 0x9d, 0x97, 
-0x95, 0x95, 0x97, 0x9c, 0xa4, 0xb6, 0x57, 0x2f, 0x24, 0x1e, 
-0x1c, 0x1c, 0x1e, 0x24, 0x2d, 0x3d, 0xf1, 0xbe, 0xb2, 0xad, 
-0xac, 0xad, 0xb1, 0xb9, 0xc3, 0xd4, 0xfa, 0x64, 0x65, 0xf9, 
-0xd9, 0xca, 0xc2, 0xbf, 0xc0, 0xc9, 0xe7, 0x4c, 0x39, 0x2e, 
-0x28, 0x24, 0x23, 0x25, 0x29, 0x33, 0x4f, 0xbf, 0xab, 0xa0, 
-0x9b, 0x99, 0x98, 0x9a, 0x9e, 0xa9, 0xc0, 0x3c, 0x26, 0x1b, 
-0x16, 0x12, 0x12, 0x14, 0x19, 0x22, 0x38, 0xbe, 0xa4, 0x9a, 
-0x93, 0x90, 0x8f, 0x92, 0x97, 0x9f, 0xb3, 0x46, 0x26, 0x1b, 
-0x15, 0x11, 0x11, 0x13, 0x18, 0x1f, 0x31, 0xd4, 0xab, 0x9e, 
-0x99, 0x96, 0x96, 0x98, 0x9c, 0xa4, 0xb4, 0x6f, 0x34, 0x28, 
-0x20, 0x1e, 0x1e, 0x20, 0x26, 0x2e, 0x3d, 0x6d, 0xc5, 0xb9, 
-0xb3, 0xb2, 0xb4, 0xba, 0xc1, 0xcd, 0xe0, 0xfc, 0xfb, 0xe0, 
-0xce, 0xc3, 0xbb, 0xb7, 0xb6, 0xb9, 0xc0, 0xda, 0x4b, 0x36, 
-0x2b, 0x25, 0x20, 0x1f, 0x20, 0x26, 0x2e, 0x46, 0xc2, 0xab, 
-0x9f, 0x9a, 0x97, 0x96, 0x98, 0x9c, 0xa5, 0xba, 0x41, 0x27, 
-0x1b, 0x15, 0x12, 0x11, 0x13, 0x18, 0x1f, 0x32, 0xc8, 0xa6, 
-0x9a, 0x94, 0x90, 0x8f, 0x91, 0x97, 0x9e, 0xaf, 0x54, 0x29, 
-0x1c, 0x16, 0x12, 0x11, 0x14, 0x18, 0x1f, 0x2e, 0xf2, 0xae, 
-0xa0, 0x9b, 0x98, 0x97, 0x99, 0x9d, 0xa5, 0xb3, 0xe4, 0x3a, 
-0x2b, 0x25, 0x21, 0x21, 0x24, 0x29, 0x30, 0x3e, 0x62, 0xcd, 
-0xbf, 0xbb, 0xbb, 0xbe, 0xc6, 0xd1, 0xe7, 0x76, 0x75, 0xe7, 
-0xcf, 0xc1, 0xb9, 0xb2, 0xaf, 0xaf, 0xb2, 0xba, 0xcf, 0x4c, 
-0x34, 0x29, 0x22, 0x1e, 0x1d, 0x1e, 0x22, 0x2b, 0x3e, 0xc7, 
-0xab, 0x9f, 0x99, 0x96, 0x95, 0x96, 0x9a, 0xa2, 0xb5, 0x4a, 
-0x28, 0x1c, 0x15, 0x11, 0x10, 0x12, 0x17, 0x1e, 0x2e, 0xd5, 
-0xa9, 0x9b, 0x95, 0x90, 0x8f, 0x91, 0x96, 0x9d, 0xac, 0x78, 
-0x2c, 0x1e, 0x17, 0x13, 0x12, 0x14, 0x18, 0x1f, 0x2d, 0x5d, 
-0xb3, 0xa4, 0x9d, 0x9a, 0x99, 0x9b, 0x9e, 0xa6, 0xb2, 0xd6, 
-0x3f, 0x2f, 0x29, 0x26, 0x26, 0x28, 0x2d, 0x35, 0x42, 0x5e, 
-0xd8, 0xca, 0xc6, 0xc9, 0xcf, 0xe4, 0x69, 0x59, 0x58, 0x64, 
-0xdf, 0xc7, 0xba, 0xb1, 0xac, 0xaa, 0xaa, 0xad, 0xb4, 0xc7, 
-0x4f, 0x33, 0x27, 0x1f, 0x1c, 0x1b, 0x1c, 0x1f, 0x27, 0x39, 
-0xce, 0xac, 0x9f, 0x99, 0x95, 0x94, 0x95, 0x99, 0x9f, 0xaf, 
-0x59, 0x2a, 0x1c, 0x16, 0x11, 0x10, 0x11, 0x16, 0x1d, 0x2b };
-/*
-  * 8-bit raw data
-  *
-  * Source: DialTone.ulaw
-  *
   * Copyright (C) 1999, Mark Spencer
   *
   * Distributed under the terms of the GNU General Public License

Modified: trunk/channels/Makefile
===================================================================
--- trunk/channels/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/channels/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,33 +1,6 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
-# Makefile for Channel backends (dynamically loaded)
-#
-# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
-#
-# Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-CHANNEL_LIBS=chan_vofr.so chan_ixj.so
-
-CFLAGS+=#-DVOFRDUMPER
-
-all: $(CHANNEL_LIBS)
-
-clean:
-	rm -f *.so *.o
-
-%.so : %.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt;
-
-install: all
-	for x in $(CHANNEL_LIBS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
 # Makefile for channel drivers
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/codecs/Makefile
===================================================================
--- trunk/codecs/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,78 +1,6 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
-# Makefile for PBX frontends (dynamically loaded)
-#
-# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
-#
-# Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-#
-# Uncomment if you have g723.1 code (with the same API as the Annex-A code
-# and have placed it in the g723.1 directory and/or the Annex-B code in 
-# g723.1b)
-#
-#MODG723=codec_g723_1.so codec_g723_1b.so
-MODG723=$(shell [ -f g723.1/coder.c ] &amp;&amp; echo &quot;codec_g723_1.so&quot;)
-MODG723+=$(shell [ -f g723.1b/coder2.c ] &amp;&amp; echo &quot;codec_g723_1b.so&quot;)
-
-CFLAGS+=
-
-LIBG723=g723.1/libg723.a
-LIBG723B=g723.1b/libg723b.a
-LIBGSM=gsm/lib/libgsm.a
-LIBMP3=mp3/libmp3.a
-
-CODECS+=$(MODG723) codec_gsm.so #codec_mp3_d.so
-
-all: $(CODECS)
-
-clean:
-	rm -f *.so *.o
-	make -C g723.1 clean
-	make -C g723.1b clean
-	make -C gsm clean
-	make -C mp3 clean
-
-$(LIBG723):
-	make -C g723.1 all
-
-$(LIBGSM):
-	make -C gsm lib/libgsm.a
-
-$(LIBG723B):
-	make -C g723.1b all
-
-$(LIBMP3):
-	make -C mp3 all
-
-codec_g723_1.so : codec_g723_1.o $(LIBG723)
-	$(CC) -shared -Xlinker -x -o $@ $&lt; $(LIBG723)
-
-codec_g723_1b.o : codec_g723_1.c
-	$(CC) -c -o $@ $(CFLAGS) -DANNEX_B $&lt;
-
-codec_g723_1b.so : codec_g723_1b.o $(LIBG723B)
-	$(CC) -shared -Xlinker -x -o $@ $&lt; $(LIBG723B) -lm
-
-codec_gsm.so: codec_gsm.o $(LIBGSM)
-	$(CC) -shared -Xlinker -x -o $@ $&lt; $(LIBGSM)
-
-codec_mp3_d.so: codec_mp3_d.o $(LIBMP3)
-	$(CC) -shared -Xlinker -x -o $@ $&lt; $(LIBMP3)
-
-%.so : %.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt;
-
-install: all
-	for x in $(CODECS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
 # Makefile for codec modules
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/codecs/codec_g723_1.c
===================================================================
--- trunk/codecs/codec_g723_1.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/codec_g723_1.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,362 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Translate between signed linear and G.723.1
- *
- * The G.723.1 code is not included in the Asterisk distribution because
- * it is covered with patents, and in spite of statements to the contrary,
- * the &quot;technology&quot; is extremely expensive to license.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#define TYPE_SILENCE	 0x2
-#define TYPE_HIGH	 0x0
-#define TYPE_LOW	 0x1
-#define TYPE_MASK	 0x3
-
-#include &lt;asterisk/translate.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-
-#ifdef ANNEX_B
-#include &quot;g723.1b/typedef2.h&quot;
-#include &quot;g723.1b/cst2.h&quot;
-#include &quot;g723.1b/coder2.h&quot;
-#include &quot;g723.1b/decod2.h&quot;
-#include &quot;g723.1b/deccng2.h&quot;
-#include &quot;g723.1b/codcng2.h&quot;
-#include &quot;g723.1b/vad2.h&quot;
-#else
-#include &quot;g723.1/typedef.h&quot;
-#include &quot;g723.1/cst_lbc.h&quot;
-#include &quot;g723.1/coder.h&quot;
-#include &quot;g723.1/decod.h&quot;
-#include &quot;g723.1/dec_cng.h&quot;
-#include &quot;g723.1/cod_cng.h&quot;
-#include &quot;g723.1/vad.h&quot;
-#endif
-
-/* Sample frame data */
-#include &quot;slin_g723_ex.h&quot;
-#include &quot;g723_slin_ex.h&quot;
-
-static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER;
-static int localusecnt=0;
-
-#ifdef ANNEX_B
-static char *tdesc = &quot;Annex B (floating point) G.723.1/PCM16 Codec Translator&quot;;
-#else
-static char *tdesc = &quot;Annex A (fixed point) G.723.1/PCM16 Codec Translator&quot;;
-#endif
-
-/* Globals */
-Flag UsePf = True;
-Flag UseHp = True;
-Flag UseVx = True;
-
-enum Crate WrkRate = Rate63;
-
-struct g723_encoder_pvt {
-	struct cod_state cod;
-	struct ast_frame f;
-	/* Space to build offset */
-	char offset[AST_FRIENDLY_OFFSET];
-	/* Buffer for our outgoing frame */
-	char outbuf[24];
-	/* Enough to store a full second */
-	short buf[8000];
-	int tail;
-};
-
-struct g723_decoder_pvt {
-	struct dec_state dec;
-	struct ast_frame f;
-	/* Space to build offset */
-	char offset[AST_FRIENDLY_OFFSET];
-	/* Enough to store a full second */
-	short buf[8000];
-	int tail;
-};
-
-static struct ast_translator_pvt *g723tolin_new()
-{
-	struct g723_decoder_pvt *tmp;
-	tmp = malloc(sizeof(struct g723_decoder_pvt));
-	if (tmp) {
-		Init_Decod(&amp;tmp-&gt;dec);
-	    Init_Dec_Cng(&amp;tmp-&gt;dec);
-		tmp-&gt;tail = 0;
-	}
-	return (struct ast_translator_pvt *)tmp;
-}
-
-static struct ast_frame *lintog723_sample()
-{
-	static struct ast_frame f;
-	f.frametype = AST_FRAME_VOICE;
-	f.subclass = AST_FORMAT_SLINEAR;
-	f.datalen = sizeof(slin_g723_ex);
-	/* Assume 8000 Hz */
-	f.timelen = sizeof(slin_g723_ex)/16;
-	f.mallocd = 0;
-	f.offset = 0;
-	f.src = __PRETTY_FUNCTION__;
-	f.data = slin_g723_ex;
-	return &f;
-}
-
-static struct ast_frame *g723tolin_sample()
-{
-	static struct ast_frame f;
-	f.frametype = AST_FRAME_VOICE;
-	f.subclass = AST_FORMAT_G723_1;
-	f.datalen = sizeof(g723_slin_ex);
-	/* All frames are 30 ms long */
-	f.timelen = 30;
-	f.mallocd = 0;
-	f.offset = 0;
-	f.src = __PRETTY_FUNCTION__;
-	f.data = g723_slin_ex;
-	return &f;
-}
-
-static struct ast_translator_pvt *lintog723_new()
-{
-	struct g723_encoder_pvt *tmp;
-	tmp = malloc(sizeof(struct g723_encoder_pvt));
-	if (tmp) {
-		Init_Coder(&amp;tmp-&gt;cod);
-	    /* Init Comfort Noise Functions */
-   		 if( UseVx ) {
-   	   		Init_Vad(&amp;tmp-&gt;cod);
-        	Init_Cod_Cng(&amp;tmp-&gt;cod);
-    	 }
-		tmp-&gt;tail = 0;
-	}
-	return (struct ast_translator_pvt *)tmp;
-}
-
-static struct ast_frame *g723tolin_frameout(struct ast_translator_pvt *pvt)
-{
-	struct g723_decoder_pvt *tmp = (struct g723_decoder_pvt *)pvt;
-	if (!tmp-&gt;tail)
-		return NULL;
-	/* Signed linear is no particular frame size, so just send whatever
-	   we have in the buffer in one lump sum */
-	tmp-&gt;f.frametype = AST_FRAME_VOICE;
-	tmp-&gt;f.subclass = AST_FORMAT_SLINEAR;
-	tmp-&gt;f.datalen = tmp-&gt;tail * 2;
-	/* Assume 8000 Hz */
-	tmp-&gt;f.timelen = tmp-&gt;tail / 8;
-	tmp-&gt;f.mallocd = 0;
-	tmp-&gt;f.offset = AST_FRIENDLY_OFFSET;
-	tmp-&gt;f.src = __PRETTY_FUNCTION__;
-	tmp-&gt;f.data = tmp-&gt;buf;
-	/* Reset tail pointer */
-	tmp-&gt;tail = 0;
-
-#if 0
-	/* Save a sample frame */
-	{ static int samplefr = 0;
-	if (samplefr == 80) {
-		int fd;
-		fd = open(&quot;g723.example&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-		write(fd, tmp-&gt;f.data, tmp-&gt;f.datalen);
-		close(fd);
-	} 		
-	samplefr++;
-	}
-#endif
-	return &amp;tmp-&gt;f;	
-}
-
-static int g723tolin_framein(struct ast_translator_pvt *pvt, struct ast_frame *f)
-{
-	struct g723_decoder_pvt *tmp = (struct g723_decoder_pvt *)pvt;
-#ifdef  ANNEX_B
-	FLOAT tmpdata[Frame];
-	int x;
-#endif
-	/* Assuming there's space left, decode into the current buffer at
-	   the tail location */
-	if (tmp-&gt;tail + Frame &lt; sizeof(tmp-&gt;buf)/2) {	
-#ifdef ANNEX_B
-		Decod(&amp;tmp-&gt;dec, tmpdata, f-&gt;data, 0);
-		for (x=0;x&lt;Frame;x++)
-			(tmp-&gt;buf + tmp-&gt;tail)[x] = tmpdata[x]; 
-#else
-		Decod(&amp;tmp-&gt;dec, tmp-&gt;buf + tmp-&gt;tail, f-&gt;data, 0);
-#endif
-		tmp-&gt;tail+=Frame;
-	} else {
-		ast_log(LOG_WARNING, &quot;Out of buffer space\n&quot;);
-		return -1;
-	}
-	return 0;
-}
-
-static int lintog723_framein(struct ast_translator_pvt *pvt, struct ast_frame *f)
-{
-	/* Just add the frames to our stream */
-	/* XXX We should look at how old the rest of our stream is, and if it
-	   is too old, then we should overwrite it entirely, otherwise we can
-	   get artifacts of earlier talk that do not belong */
-	struct g723_encoder_pvt *tmp = (struct g723_encoder_pvt *)pvt;
-	if (tmp-&gt;tail + f-&gt;datalen/2 &lt; sizeof(tmp-&gt;buf) / 2) {
-		memcpy(&amp;tmp-&gt;buf[tmp-&gt;tail], f-&gt;data, f-&gt;datalen);
-		tmp-&gt;tail += f-&gt;datalen/2;
-	} else {
-		ast_log(LOG_WARNING, &quot;Out of buffer space\n&quot;);
-		return -1;
-	}
-	return 0;
-}
-
-static struct ast_frame *lintog723_frameout(struct ast_translator_pvt *pvt)
-{
-	struct g723_encoder_pvt *tmp = (struct g723_encoder_pvt *)pvt;
-#ifdef ANNEX_B
-	int x;
-	FLOAT tmpdata[Frame];
-#endif
-	/* We can't work on anything less than a frame in size */
-	if (tmp-&gt;tail &lt; Frame)
-		return NULL;
-	/* Encode a frame of data */
-#ifdef ANNEX_B
-	for (x=0;x&lt;Frame;x++)
-		tmpdata[x] = tmp-&gt;buf[x];
-	Coder(&amp;tmp-&gt;cod, tmpdata, tmp-&gt;outbuf);
-#else
-	Coder(&amp;tmp-&gt;cod, tmp-&gt;buf, tmp-&gt;outbuf);
-#endif
-	tmp-&gt;f.frametype = AST_FRAME_VOICE;
-	tmp-&gt;f.subclass = AST_FORMAT_G723_1;
-	/* Assume 8000 Hz */
-	tmp-&gt;f.timelen = 30;
-	tmp-&gt;f.mallocd = 0;
-	tmp-&gt;f.offset = AST_FRIENDLY_OFFSET;
-	tmp-&gt;f.src = __PRETTY_FUNCTION__;
-	tmp-&gt;f.data = tmp-&gt;outbuf;
-	switch(tmp-&gt;outbuf[0] &amp; TYPE_MASK) {
-	case TYPE_MASK:
-	case TYPE_SILENCE:
-		tmp-&gt;f.datalen = 4;
-		break;
-	case TYPE_HIGH:
-		tmp-&gt;f.datalen = 24;
-		break;
-	case TYPE_LOW:
-		tmp-&gt;f.datalen = 20;
-		break;
-	default:
-		ast_log(LOG_WARNING, &quot;Badly encoded frame (%d)\n&quot;, tmp-&gt;outbuf[0] &amp; TYPE_MASK);
-	}
-	tmp-&gt;tail -= Frame;
-	/* Move the data at the end of the buffer to the front */
-	if (tmp-&gt;tail)
-		memmove(tmp-&gt;buf, tmp-&gt;buf + Frame, tmp-&gt;tail * 2);
-#if 0
-	/* Save to a g723 sample output file... */
-	{ 
-		static int fd = -1;
-		int delay = htonl(30);
-		short size;
-		if (fd &lt; 0)
-			fd = open(&quot;trans.g723&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0644);
-		if (fd &lt; 0)
-			ast_log(LOG_WARNING, &quot;Unable to create demo\n&quot;);
-		write(fd, &amp;delay, 4);
-		size = htons(tmp-&gt;f.datalen);
-		write(fd, &amp;size, 2);
-		write(fd, tmp-&gt;f.data, tmp-&gt;f.datalen);
-	}
-#endif
-	return &amp;tmp-&gt;f;	
-}
-
-static void g723_destroy(struct ast_translator_pvt *pvt)
-{
-	free(pvt);
-}
-
-static struct ast_translator g723tolin =
-#ifdef ANNEX_B
-	{ &quot;g723tolinb&quot;, 
-#else
-	{ &quot;g723tolin&quot;, 
-#endif
-	   AST_FORMAT_G723_1, AST_FORMAT_SLINEAR,
-	   g723tolin_new,
-	   g723tolin_framein,
-	   g723tolin_frameout,
-	   g723_destroy,
-	   g723tolin_sample
-	   };
-
-static struct ast_translator lintog723 =
-#ifdef ANNEX_B
-	{ &quot;lintog723b&quot;, 
-#else
-	{ &quot;lintog723&quot;, 
-#endif
-	   AST_FORMAT_SLINEAR, AST_FORMAT_G723_1,
-	   lintog723_new,
-	   lintog723_framein,
-	   lintog723_frameout,
-	   g723_destroy,
-	   lintog723_sample
-	   };
-
-int unload_module(void)
-{
-	int res;
-	pthread_mutex_lock(&amp;localuser_lock);
-	res = ast_unregister_translator(&amp;lintog723);
-	if (!res)
-		res = ast_unregister_translator(&amp;g723tolin);
-	if (localusecnt)
-		res = -1;
-	pthread_mutex_unlock(&amp;localuser_lock);
-	return res;
-}
-
-int load_module(void)
-{
-	int res;
-	res=ast_register_translator(&amp;g723tolin);
-	if (!res) 
-		res=ast_register_translator(&amp;lintog723);
-	else
-		ast_unregister_translator(&amp;g723tolin);
-	return res;
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * The G.723.1 code is not included in the Asterisk distribution because

Modified: trunk/codecs/codec_gsm.c
===================================================================
--- trunk/codecs/codec_gsm.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/codec_gsm.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,266 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Translate between signed linear and Global System for Mobile Communications (GSM)
- *
- * The GSM code is from TOAST.  Copyright information for that package is available
- * in  the GSM directory.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#define TYPE_SILENCE	 0x2
-#define TYPE_HIGH	 0x0
-#define TYPE_LOW	 0x1
-#define TYPE_MASK	 0x3
-
-#include &lt;asterisk/translate.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;netinet/in.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-
-#include &quot;gsm/inc/gsm.h&quot;
-
-/* Sample frame data */
-#include &quot;slin_gsm_ex.h&quot;
-#include &quot;gsm_slin_ex.h&quot;
-
-static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER;
-static int localusecnt=0;
-
-static char *tdesc = &quot;GSM/PCM16 (signed linear) Codec Translator&quot;;
-
-struct ast_translator_pvt {
-	gsm gsm;
-	struct ast_frame f;
-	/* Space to build offset */
-	char offset[AST_FRIENDLY_OFFSET];
-	/* Buffer for our outgoing frame */
-	gsm_frame outbuf;
-	/* Enough to store a full second */
-	short buf[8000];
-	int tail;
-};
-
-#define gsm_coder_pvt ast_translator_pvt
-
-static struct ast_translator_pvt *gsm_new()
-{
-	struct gsm_coder_pvt *tmp;
-	tmp = malloc(sizeof(struct gsm_coder_pvt));
-	if (tmp) {
-		if (!(tmp-&gt;gsm = gsm_create())) {
-			free(tmp);
-			tmp = NULL;
-		}
-		tmp-&gt;tail = 0;
-	}
-	return tmp;
-}
-
-static struct ast_frame *lintogsm_sample()
-{
-	static struct ast_frame f;
-	f.frametype = AST_FRAME_VOICE;
-	f.subclass = AST_FORMAT_SLINEAR;
-	f.datalen = sizeof(slin_gsm_ex);
-	/* Assume 8000 Hz */
-	f.timelen = sizeof(slin_gsm_ex)/16;
-	f.mallocd = 0;
-	f.offset = 0;
-	f.src = __PRETTY_FUNCTION__;
-	f.data = slin_gsm_ex;
-	return &f;
-}
-
-static struct ast_frame *gsmtolin_sample()
-{
-	static struct ast_frame f;
-	f.frametype = AST_FRAME_VOICE;
-	f.subclass = AST_FORMAT_GSM;
-	f.datalen = sizeof(gsm_slin_ex);
-	/* All frames are 30 ms long */
-	f.timelen = 30;
-	f.mallocd = 0;
-	f.offset = 0;
-	f.src = __PRETTY_FUNCTION__;
-	f.data = gsm_slin_ex;
-	return &f;
-}
-
-static struct ast_frame *gsmtolin_frameout(struct ast_translator_pvt *tmp)
-{
-	if (!tmp-&gt;tail)
-		return NULL;
-	/* Signed linear is no particular frame size, so just send whatever
-	   we have in the buffer in one lump sum */
-	tmp-&gt;f.frametype = AST_FRAME_VOICE;
-	tmp-&gt;f.subclass = AST_FORMAT_SLINEAR;
-	tmp-&gt;f.datalen = tmp-&gt;tail * 2;
-	/* Assume 8000 Hz */
-	tmp-&gt;f.timelen = tmp-&gt;tail / 8;
-	tmp-&gt;f.mallocd = 0;
-	tmp-&gt;f.offset = AST_FRIENDLY_OFFSET;
-	tmp-&gt;f.src = __PRETTY_FUNCTION__;
-	tmp-&gt;f.data = tmp-&gt;buf;
-	/* Reset tail pointer */
-	tmp-&gt;tail = 0;
-
-#if 0
-	/* Save a sample frame */
-	{ static int samplefr = 0;
-	if (samplefr == 80) {
-		int fd;
-		fd = open(&quot;gsm.example&quot;, O_WRONLY | O_CREAT, 0644);
-		write(fd, tmp-&gt;f.data, tmp-&gt;f.datalen);
-		close(fd);
-	} 		
-	samplefr++;
-	}
-#endif
-	return &amp;tmp-&gt;f;	
-}
-
-static int gsmtolin_framein(struct ast_translator_pvt *tmp, struct ast_frame *f)
-{
-	/* Assuming there's space left, decode into the current buffer at
-	   the tail location */
-	if (tmp-&gt;tail + 160 &lt; sizeof(tmp-&gt;buf)/2) {	
-		if (gsm_decode(tmp-&gt;gsm, f-&gt;data, tmp-&gt;buf + tmp-&gt;tail)) {
-			ast_log(LOG_WARNING, &quot;Invalid GSM data\n&quot;);
-			return -1;
-		}
-		tmp-&gt;tail+=160;
-	} else {
-		ast_log(LOG_WARNING, &quot;Out of buffer space\n&quot;);
-		return -1;
-	}
-	return 0;
-}
-
-static int lintogsm_framein(struct ast_translator_pvt *tmp, struct ast_frame *f)
-{
-	/* Just add the frames to our stream */
-	/* XXX We should look at how old the rest of our stream is, and if it
-	   is too old, then we should overwrite it entirely, otherwise we can
-	   get artifacts of earlier talk that do not belong */
-	if (tmp-&gt;tail + f-&gt;datalen &lt; sizeof(tmp-&gt;buf) / 2) {
-		memcpy(tmp-&gt;buf + tmp-&gt;tail, f-&gt;data, f-&gt;datalen);
-		tmp-&gt;tail += f-&gt;datalen/2;
-	} else {
-		ast_log(LOG_WARNING, &quot;Out of buffer space\n&quot;);
-		return -1;
-	}
-	return 0;
-}
-
-static struct ast_frame *lintogsm_frameout(struct ast_translator_pvt *tmp)
-{
-	/* We can't work on anything less than a frame in size */
-	if (tmp-&gt;tail &lt; 160)
-		return NULL;
-	/* Encode a frame of data */
-	gsm_encode(tmp-&gt;gsm, tmp-&gt;buf, tmp-&gt;outbuf);
-	tmp-&gt;f.frametype = AST_FRAME_VOICE;
-	tmp-&gt;f.subclass = AST_FORMAT_GSM;
-	tmp-&gt;f.datalen = 33;
-	/* Assume 8000 Hz -- 20 ms */
-	tmp-&gt;f.timelen = 20;
-	tmp-&gt;f.mallocd = 0;
-	tmp-&gt;f.offset = AST_FRIENDLY_OFFSET;
-	tmp-&gt;f.src = __PRETTY_FUNCTION__;
-	tmp-&gt;f.data = tmp-&gt;outbuf;
-	tmp-&gt;tail -= 160;
-	/* Move the data at the end of the buffer to the front */
-	if (tmp-&gt;tail)
-		memmove(tmp-&gt;buf, tmp-&gt;buf + 160 * 2, tmp-&gt;tail * 2);
-#if 0
-	/* Save a sample frame */
-	{ static int samplefr = 0;
-	if (samplefr == 0) {
-		int fd;
-		fd = open(&quot;gsm.example&quot;, O_WRONLY | O_CREAT, 0644);
-		write(fd, tmp-&gt;f.data, tmp-&gt;f.datalen);
-		close(fd);
-	} 		
-	samplefr++;
-	}
-#endif
-	return &amp;tmp-&gt;f;	
-}
-
-static void gsm_destroy_stuff(struct ast_translator_pvt *pvt)
-{
-	free(pvt);
-}
-
-static struct ast_translator gsmtolin =
-	{ &quot;gsmtolin&quot;, 
-	   AST_FORMAT_GSM, AST_FORMAT_SLINEAR,
-	   gsm_new,
-	   gsmtolin_framein,
-	   gsmtolin_frameout,
-	   gsm_destroy_stuff,
-	   gsmtolin_sample
-	   };
-
-static struct ast_translator lintogsm =
-	{ &quot;lintogsm&quot;, 
-	   AST_FORMAT_SLINEAR, AST_FORMAT_GSM,
-	   gsm_new,
-	   lintogsm_framein,
-	   lintogsm_frameout,
-	   gsm_destroy_stuff,
-	   lintogsm_sample
-	   };
-
-int unload_module(void)
-{
-	int res;
-	pthread_mutex_lock(&amp;localuser_lock);
-	res = ast_unregister_translator(&amp;lintogsm);
-	if (!res)
-		res = ast_unregister_translator(&amp;gsmtolin);
-	if (localusecnt)
-		res = -1;
-	pthread_mutex_unlock(&amp;localuser_lock);
-	return res;
-}
-
-int load_module(void)
-{
-	int res;
-	res=ast_register_translator(&amp;gsmtolin);
-	if (!res) 
-		res=ast_register_translator(&amp;lintogsm);
-	else
-		ast_unregister_translator(&amp;gsmtolin);
-	return res;
-}
-
-char *description(void)
-{
-	return tdesc;
-}
-
-int usecount(void)
-{
-	int res;
-	STANDARD_USECOUNT(res);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * The GSM code is from TOAST.  Copyright information for that package is available

Modified: trunk/codecs/g723_slin_ex.h
===================================================================
--- trunk/codecs/g723_slin_ex.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/g723_slin_ex.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,18 +1,3 @@
-/*
-  * 8-bit raw data
-  *
-  * Source: g723.example
-  *
-  * Copyright (C) 1999, Mark Spencer and Linux Support Services
-  *
-  * Distributed under the terms of the GNU General Public License
-  *
-  */
-
-static unsigned char g723_slin_ex[] = {
-0x4c, 0x34, 0xc2, 0xd9, 0x81, 0x80, 0xa8, 0x50, 0xd7, 0x8d, 
-0x8, 0x80, 0xf0, 0xb4, 0x40, 0x53, 0xe3, 0xe1, 0x63, 0x4e, 
-0x1a, 0x37, 0xd6, 0x0037 };
 /*! \file
   * \brief 8-bit raw data
   *

Modified: trunk/codecs/gsm/COPYRIGHT
===================================================================
--- trunk/codecs/gsm/COPYRIGHT	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/COPYRIGHT	2006-07-05 21:55:19 UTC (rev 423)
@@ -14,19 +14,3 @@
 Berlin, 28.11.1994
 Jutta Degener
 Carsten Bormann
-Copyright 1992, 1993, 1994 by Jutta Degener and Carsten Bormann,
-Technische Universitaet Berlin
-
-Any use of this software is permitted provided that this notice is not
-removed and that neither the authors nor the Technische Universitaet Berlin
-are deemed to have made any representations as to the suitability of this
-software for any purpose nor are held responsible for any defects of
-this software.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
-
-As a matter of courtesy, the authors request to be informed about uses
-this software has found, about bugs in this software, and about any
-improvements that may be of general interest.
-
-Berlin, 28.11.1994
-Jutta Degener
-Carsten Bormann

Modified: trunk/codecs/gsm/Makefile
===================================================================
--- trunk/codecs/gsm/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -7,500 +7,6 @@
 SASR	= -DSASR
 ######### Define SASR if &gt;&gt; is a signed arithmetic shift (-1 &gt;&gt; 1 == -1)
 
-MULHACK = -DUSE_FLOAT_MUL
-######### Define this if your host multiplies floats faster than integers,
-######### e.g. on a SPARCstation.
-
-FAST	= -DFAST
-######### Define together with USE_FLOAT_MUL to enable the GSM library's
-######### approximation option for incorrect, but good-enough results.
-
-# LTP_CUT	= -DLTP_CUT
-LTP_CUT	=
-######### Define to enable the GSM library's long-term correlation 
-######### approximation option---faster, but worse; works for
-######### both integer and floating point multiplications.
-######### This flag is still in the experimental stage.
-
-WAV49	= -DWAV49
-#WAV49	=
-######### Define to enable the GSM library's option to pack GSM frames 
-######### in the style used by the WAV #49 format.  If you want to write
-######### a tool that produces .WAV files which contain GSM-encoded data,
-######### define this, and read about the GSM_OPT_WAV49 option in the
-######### manual page on gsm_option(3).
-
-# Choose a compiler.  The code works both with ANSI and K&amp;R-C.
-# Use -DNeedFunctionPrototypes to compile with, -UNeedFunctionPrototypes to
-# compile without, function prototypes in the header files.
-#
-# You can use the -DSTUPID_COMPILER to circumvent some compilers'
-# static limits regarding the number of subexpressions in a statement.
-
-# CC		= cc
-# CCFLAGS 	= -c -DSTUPID_COMPILER
-
-# CC		= /usr/lang/acc
-# CCFLAGS 	= -c -O
-
-CC		= gcc -ansi -pedantic
-CCFLAGS 	+= -c -DNeedFunctionPrototypes=1 -finline-functions -funroll-loops
-
-LD 		= $(CC)
-
-# LD		= gcc
-# LDFLAGS 	=
-
-
-# If your compiler needs additional flags/libraries, regardless of
-# the source compiled, configure them here.
-
-# CCINC	= -I/usr/gnu/lib/gcc-2.1/gcc-lib/sparc-sun-sunos4.1.2/2.1/include
-######### Includes needed by $(CC)
-
-# LDINC	= -L/usr/gnu/lib/gcc-2.1/gcc-lib/sparc-sun-sunos4.1.2/2.1
-######### Library paths needed by $(LD)
-
-# LDLIB	= -lgcc
-######### Additional libraries needed by $(LD)
-
-
-# Where do you want to install libraries, binaries, a header file
-# and the manual pages?
-#
-# Leave INSTALL_ROOT empty (or just don't execute &quot;make install&quot;) to
-# not install gsm and toast outside of this directory.
-
-INSTALL_ROOT	=
-
-# Where do you want to install the gsm library, header file, and manpages?
-#
-# Leave GSM_INSTALL_ROOT empty to not install the GSM library outside of
-# this directory.
-
-GSM_INSTALL_ROOT = $(INSTALL_ROOT)
-GSM_INSTALL_LIB = $(GSM_INSTALL_ROOT)/lib
-GSM_INSTALL_INC = $(GSM_INSTALL_ROOT)/inc
-GSM_INSTALL_MAN = $(GSM_INSTALL_ROOT)/man/man3
-
-
-# Where do you want to install the toast binaries and their manpage?
-#
-# Leave TOAST_INSTALL_ROOT empty to not install the toast binaries outside
-# of this directory.
-
-TOAST_INSTALL_ROOT	  = $(INSTALL_ROOT)
-TOAST_INSTALL_BIN = $(TOAST_INSTALL_ROOT)/bin
-TOAST_INSTALL_MAN = $(TOAST_INSTALL_ROOT)/man/man1
-
-#  Other tools
-
-SHELL		= /bin/sh
-LN		= ln
-BASENAME 	= basename
-AR		= ar
-ARFLAGS		= cr
-RMFLAGS		= -f
-FIND		= find
-COMPRESS 	= compress
-COMPRESSFLAGS 	= 
-# RANLIB 	= true
-RANLIB	 	= ranlib
-
-#
-#    You shouldn't have to configure below this line if you're porting.
-# 
-
-
-# Local Directories
-
-ROOT	= .
-ADDTST	= $(ROOT)/add-test
-TST	= $(ROOT)/tst
-MAN	= $(ROOT)/man
-BIN	= $(ROOT)/bin
-SRC	= $(ROOT)/src
-LIB	= $(ROOT)/lib
-TLS	= $(ROOT)/tls
-INC	= $(ROOT)/inc
-
-# Flags
-
-# DEBUG	= -DNDEBUG
-######### Remove -DNDEBUG to enable assertions.
-
-CFLAGS	= $(CCFLAGS) $(SASR) $(DEBUG) $(MULHACK) $(FAST) $(LTP_CUT) \
-	$(WAV49) $(CCINC) -I$(INC)
-######### It's $(CC) $(CFLAGS)
-
-LFLAGS	= $(LDFLAGS) $(LDINC)
-######### It's $(LD) $(LFLAGS)
-
-
-# Targets
-
-LIBGSM	= $(LIB)/libgsm.a
-
-TOAST	= $(BIN)/toast
-UNTOAST	= $(BIN)/untoast
-TCAT	= $(BIN)/tcat
-
-# Headers
-
-GSM_HEADERS =	$(INC)/gsm.h
-
-HEADERS	=	$(INC)/proto.h		\
-		$(INC)/unproto.h	\
-		$(INC)/config.h		\
-		$(INC)/private.h	\
-		$(INC)/gsm.h		\
-		$(INC)/toast.h		\
-		$(TLS)/taste.h
-
-# Sources
-
-GSM_SOURCES =	$(SRC)/add.c		\
-		$(SRC)/code.c		\
-		$(SRC)/debug.c		\
-		$(SRC)/decode.c		\
-		$(SRC)/long_term.c	\
-		$(SRC)/lpc.c		\
-		$(SRC)/preprocess.c	\
-		$(SRC)/rpe.c		\
-		$(SRC)/gsm_destroy.c	\
-		$(SRC)/gsm_decode.c	\
-		$(SRC)/gsm_encode.c	\
-		$(SRC)/gsm_explode.c	\
-		$(SRC)/gsm_implode.c	\
-		$(SRC)/gsm_create.c	\
-		$(SRC)/gsm_print.c	\
-		$(SRC)/gsm_option.c	\
-		$(SRC)/short_term.c	\
-		$(SRC)/table.c
-
-TOAST_SOURCES = $(SRC)/toast.c 		\
-		$(SRC)/toast_lin.c	\
-		$(SRC)/toast_ulaw.c	\
-		$(SRC)/toast_alaw.c	\
-		$(SRC)/toast_audio.c
-
-SOURCES	=	$(GSM_SOURCES)		\
-		$(TOAST_SOURCES)	\
-		$(ADDTST)/add_test.c	\
-		$(TLS)/sour.c		\
-		$(TLS)/ginger.c		\
-		$(TLS)/sour1.dta	\
-		$(TLS)/sour2.dta	\
-		$(TLS)/bitter.c		\
-		$(TLS)/bitter.dta	\
-		$(TLS)/taste.c		\
-		$(TLS)/sweet.c		\
-		$(TST)/cod2lin.c	\
-		$(TST)/cod2txt.c	\
-		$(TST)/gsm2cod.c	\
-		$(TST)/lin2cod.c	\
-		$(TST)/lin2txt.c
-
-# Object files
-
-GSM_OBJECTS =	$(SRC)/add.o		\
-		$(SRC)/code.o		\
-		$(SRC)/debug.o		\
-		$(SRC)/decode.o		\
-		$(SRC)/long_term.o	\
-		$(SRC)/lpc.o		\
-		$(SRC)/preprocess.o	\
-		$(SRC)/rpe.o		\
-		$(SRC)/gsm_destroy.o	\
-		$(SRC)/gsm_decode.o	\
-		$(SRC)/gsm_encode.o	\
-		$(SRC)/gsm_explode.o	\
-		$(SRC)/gsm_implode.o	\
-		$(SRC)/gsm_create.o	\
-		$(SRC)/gsm_print.o	\
-		$(SRC)/gsm_option.o	\
-		$(SRC)/short_term.o	\
-		$(SRC)/table.o
-
-TOAST_OBJECTS =	$(SRC)/toast.o 		\
-		$(SRC)/toast_lin.o	\
-		$(SRC)/toast_ulaw.o	\
-		$(SRC)/toast_alaw.o	\
-		$(SRC)/toast_audio.o
-
-OBJECTS =	 $(GSM_OBJECTS) $(TOAST_OBJECTS)
-
-# Manuals
-
-GSM_MANUALS =	$(MAN)/gsm.3		\
-		$(MAN)/gsm_explode.3	\
-		$(MAN)/gsm_option.3	\
-		$(MAN)/gsm_print.3
-
-TOAST_MANUALS =	$(MAN)/toast.1
-
-MANUALS	= 	$(GSM_MANUALS) $(TOAST_MANUALS) $(MAN)/bitter.1
-
-# Other stuff in the distribution
-
-STUFF = 	ChangeLog			\
-		INSTALL			\
-		MACHINES		\
-		MANIFEST		\
-		Makefile		\
-		README			\
-		$(ADDTST)/add_test.dta	\
-		$(TLS)/bitter.dta	\
-		$(TST)/run
-
-
-# Install targets
-
-GSM_INSTALL_TARGETS =	\
-		$(GSM_INSTALL_LIB)/libgsm.a		\
-		$(GSM_INSTALL_INC)/gsm.h		\
-		$(GSM_INSTALL_MAN)/gsm.3		\
-		$(GSM_INSTALL_MAN)/gsm_explode.3	\
-		$(GSM_INSTALL_MAN)/gsm_option.3		\
-		$(GSM_INSTALL_MAN)/gsm_print.3
-
-TOAST_INSTALL_TARGETS =	\
-		$(TOAST_INSTALL_BIN)/toast		\
-		$(TOAST_INSTALL_BIN)/tcat		\
-		$(TOAST_INSTALL_BIN)/untoast		\
-		$(TOAST_INSTALL_MAN)/toast.1
-
-
-# Default rules
-
-.c.o:
-		$(CC) $(CFLAGS) $?
-		@-mv `$(BASENAME) $@` $@ &gt; /dev/null 2&gt;&amp;1
-
-# Target rules
-
-all:		$(LIBGSM) $(TOAST) $(TCAT) $(UNTOAST)
-		@-echo $(ROOT): Done.
-
-tst:		$(TST)/lin2cod $(TST)/cod2lin $(TOAST) $(TST)/test-result
-		@-echo tst: Done.
-
-addtst:		$(ADDTST)/add $(ADDTST)/add_test.dta
-		$(ADDTST)/add &lt; $(ADDTST)/add_test.dta &gt; /dev/null
-		@-echo addtst: Done.
-
-misc:		$(TLS)/sweet $(TLS)/bitter $(TLS)/sour $(TLS)/ginger 	\
-			$(TST)/lin2txt $(TST)/cod2txt $(TST)/gsm2cod
-		@-echo misc: Done.
-
-install:	toastinstall gsminstall
-		@-echo install: Done.
-
-
-# The basic API: libgsm
-
-$(LIBGSM):	$(LIB) $(GSM_OBJECTS)
-		-rm $(RMFLAGS) $(LIBGSM)
-		$(AR) $(ARFLAGS) $(LIBGSM) $(GSM_OBJECTS)
-		$(RANLIB) $(LIBGSM)
-
-
-# Toast, Untoast and Tcat -- the compress-like frontends to gsm.
-
-$(TOAST):	$(BIN) $(TOAST_OBJECTS) $(LIBGSM)
-		$(LD) $(LFLAGS) -o $(TOAST) $(TOAST_OBJECTS) $(LIBGSM) $(LDLIB)
-
-$(UNTOAST):	$(BIN) $(TOAST)
-		-rm $(RMFLAGS) $(UNTOAST)
-		$(LN) $(TOAST) $(UNTOAST)
-
-$(TCAT):	$(BIN) $(TOAST)
-		-rm $(RMFLAGS) $(TCAT)
-		$(LN) $(TOAST) $(TCAT)
-
-
-# The local bin and lib directories
-
-$(BIN):
-		if [ ! -d $(BIN) ] ; then mkdir $(BIN) ; fi
-
-$(LIB):
-		if [ ! -d $(LIB) ] ; then mkdir $(LIB) ; fi
-
-
-# Installation
-
-gsminstall:
-		-if [ x&quot;$(GSM_INSTALL_ROOT)&quot; != x ] ; then	\
-			make $(GSM_INSTALL_TARGETS) ;	\
-		fi
-
-toastinstall:
-		-if [ x&quot;$(TOAST_INSTALL_ROOT)&quot; != x ]; then	\
-			make $(TOAST_INSTALL_TARGETS);	\
-		fi
-
-gsmuninstall:
-		-if [ x&quot;$(GSM_INSTALL_ROOT)&quot; != x ] ; then	\
-			rm $(RMFLAGS) $(GSM_INSTALL_TARGETS) ;	\
-		fi
-
-toastuninstall:
-		-if [ x&quot;$(TOAST_INSTALL_ROOT)&quot; != x ] ; then 	\
-			rm $(RMFLAGS) $(TOAST_INSTALL_TARGETS);	\
-		fi
-
-$(TOAST_INSTALL_BIN)/toast:	$(TOAST)
-		-rm $@
-		cp $(TOAST) $@
-		chmod 755 $@
-
-$(TOAST_INSTALL_BIN)/untoast:	$(TOAST_INSTALL_BIN)/toast
-		-rm $@
-		ln $? $@
-
-$(TOAST_INSTALL_BIN)/tcat:	$(TOAST_INSTALL_BIN)/toast
-		-rm $@
-		ln $? $@
-
-$(TOAST_INSTALL_MAN)/toast.1:	$(MAN)/toast.1
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-$(GSM_INSTALL_MAN)/gsm.3:	$(MAN)/gsm.3
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-$(GSM_INSTALL_MAN)/gsm_option.3:	$(MAN)/gsm_option.3
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-$(GSM_INSTALL_MAN)/gsm_explode.3:	$(MAN)/gsm_explode.3
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-$(GSM_INSTALL_MAN)/gsm_print.3:	$(MAN)/gsm_print.3
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-$(GSM_INSTALL_INC)/gsm.h:	$(INC)/gsm.h
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-$(GSM_INSTALL_LIB)/libgsm.a:	$(LIBGSM)
-		-rm $@
-		cp $? $@
-		chmod 444 $@
-
-
-# Distribution
-
-dist:		gsm-1.0.tar.Z
-		@echo dist: Done.
-
-gsm-1.0.tar.Z:	$(STUFF) $(SOURCES) $(HEADERS) $(MANUALS)
-		(	cd $(ROOT)/..;				\
-			tar cvf - `cat $(ROOT)/gsm-1.0/MANIFEST	\
-				| sed '/^#/d'`			\
-		) | $(COMPRESS) $(COMPRESSFLAGS) &gt; $(ROOT)/gsm-1.0.tar.Z
-
-# Clean
-
-uninstall:	toastuninstall gsmuninstall
-		@-echo uninstall: Done.
-
-semi-clean:
-		-rm $(RMFLAGS)  */*.o			\
-			$(TST)/lin2cod $(TST)/lin2txt	\
-			$(TST)/cod2lin $(TST)/cod2txt	\
-			$(TST)/gsm2cod 			\
-			$(TST)/*.*.*
-		-$(FIND) . \( -name core -o -name foo \) \
-			-print | xargs rm $(RMFLAGS)
-
-clean:	semi-clean
-		-rm $(RMFLAGS) $(LIBGSM) $(ADDTST)/add		\
-			$(TOAST) $(TCAT) $(UNTOAST)	\
-			$(ROOT)/gsm-1.0.tar.Z
-
-
-# Two tools that helped me generate gsm_encode.c and gsm_decode.c,
-# but aren't generally needed to port this.
-
-$(TLS)/sweet:	$(TLS)/sweet.o $(TLS)/taste.o
-		$(LD) $(LFLAGS) -o $(TLS)/sweet \
-			$(TLS)/sweet.o $(TLS)/taste.o $(LDLIB)
-
-$(TLS)/bitter:	$(TLS)/bitter.o $(TLS)/taste.o
-		$(LD) $(LFLAGS) -o $(TLS)/bitter \
-			$(TLS)/bitter.o $(TLS)/taste.o $(LDLIB)
-
-# A version of the same family that Jeff Chilton used to implement
-# the WAV #49 GSM format.
-
-$(TLS)/ginger:	$(TLS)/ginger.o $(TLS)/taste.o
-		$(LD) $(LFLAGS) -o $(TLS)/ginger \
-			$(TLS)/ginger.o $(TLS)/taste.o $(LDLIB)
-
-$(TLS)/sour:	$(TLS)/sour.o $(TLS)/taste.o
-		$(LD) $(LFLAGS) -o $(TLS)/sour \
-			$(TLS)/sour.o $(TLS)/taste.o $(LDLIB)
-
-# Run $(ADDTST)/add &lt; $(ADDTST)/add_test.dta to make sure the
-# basic arithmetic functions work as intended.
-
-$(ADDTST)/add:	$(ADDTST)/add_test.o
-		$(LD) $(LFLAGS) -o $(ADDTST)/add $(ADDTST)/add_test.o $(LDLIB)
-
-
-# Various conversion programs between linear, text, .gsm and the code
-# format used by the tests we ran (.cod).  We paid for the test data,
-# so I guess we can't just provide them with this package.  Still,
-# if you happen to have them lying around, here's the code.
-# 
-# You can use gsm2cod | cod2txt independently to look at what's
-# coded inside the compressed frames, although this shouldn't be
-# hard to roll on your own using the gsm_print() function from
-# the API.
-
-
-$(TST)/test-result:	$(TST)/lin2cod $(TST)/cod2lin $(TOAST) $(TST)/run
-			( cd $(TST); ./run ) 
-
-$(TST)/lin2txt:		$(TST)/lin2txt.o $(LIBGSM)
-			$(LD) $(LFLAGS) -o $(TST)/lin2txt \
-				$(TST)/lin2txt.o $(LIBGSM) $(LDLIB)
-
-$(TST)/lin2cod:		$(TST)/lin2cod.o $(LIBGSM)
-			$(LD) $(LFLAGS) -o $(TST)/lin2cod \
-				$(TST)/lin2cod.o $(LIBGSM) $(LDLIB)
-
-$(TST)/gsm2cod:		$(TST)/gsm2cod.o $(LIBGSM)
-			$(LD) $(LFLAGS) -o $(TST)/gsm2cod \
-				$(TST)/gsm2cod.o $(LIBGSM) $(LDLIB)
-
-$(TST)/cod2txt:		$(TST)/cod2txt.o $(LIBGSM)
-			$(LD) $(LFLAGS) -o $(TST)/cod2txt \
-				$(TST)/cod2txt.o $(LIBGSM) $(LDLIB)
-
-$(TST)/cod2lin:		$(TST)/cod2lin.o $(LIBGSM)
-			$(LD) $(LFLAGS) -o $(TST)/cod2lin \
-				$(TST)/cod2lin.o $(LIBGSM) $(LDLIB)
-# Copyright 1992-1996 by Jutta Degener and Carsten Bormann, Technische
-# Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
-# details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
-
-# Machine- or installation dependent flags you should configure to port
-
-SASR	= -DSASR
-######### Define SASR if &gt;&gt; is a signed arithmetic shift (-1 &gt;&gt; 1 == -1)
-
 #MULHACK = -DUSE_FLOAT_MUL
 ######### Define this if your host multiplies floats faster than integers,
 ######### e.g. on a SPARCstation.

Modified: trunk/codecs/gsm/README
===================================================================
--- trunk/codecs/gsm/README	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/README	2006-07-05 21:55:19 UTC (rev 423)
@@ -35,40 +35,3 @@
 Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
 Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
 details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
-
-GSM 06.10 13 kbit/s RPE/LTP speech compression available
---------------------------------------------------------
-
-The Communications and Operating Systems Research Group (KBS) at the
-Technische Universitaet Berlin is currently working on a set of
-UNIX-based tools for computer-mediated telecooperation that will be
-made freely available.
-
-As part of this effort we are publishing an implementation of the
-European GSM 06.10 provisional standard for full-rate speech
-transcoding, prI-ETS 300 036, which uses RPE/LTP (residual pulse
-excitation/long term prediction) coding at 13 kbit/s.
-
-GSM 06.10 compresses frames of 160 13-bit samples (8 kHz sampling
-rate, i.e. a frame rate of 50 Hz) into 260 bits; for compatibility
-with typical UNIX applications, our implementation turns frames of 160
-16-bit linear samples into 33-byte frames (1650 Bytes/s).
-The quality of the algorithm is good enough for reliable speaker
-recognition; even music often survives transcoding in recognizable 
-form (given the bandwidth limitations of 8 kHz sampling rate).
-
-The interfaces offered are a front end modelled after compress(1), and
-a library API.  Compression and decompression run faster than realtime
-on most SPARCstations.  The implementation has been verified against the
-ETSI standard test patterns.
-
-Jutta Degener (<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">jutta at cs.tu-berlin.de</A>)
-Carsten Bormann (<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">cabo at cs.tu-berlin.de</A>)
-
-Communications and Operating Systems Research Group, TU Berlin
-Fax: +49.30.31425156, Phone: +49.30.31424315
-
---
-Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
-Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
-details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.

Modified: trunk/codecs/gsm/inc/config.h
===================================================================
--- trunk/codecs/gsm/inc/config.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/inc/config.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -9,43 +9,6 @@
 #ifndef	CONFIG_H
 #define	CONFIG_H
 
-/*efine	SIGHANDLER_T	int 		/* signal handlers are void	*/
-/*efine HAS_SYSV_SIGNAL	1		/* sigs not blocked/reset?	*/
-
-#define	HAS_STDLIB_H	1		/* /usr/include/stdlib.h	*/
-/*efine	HAS_LIMITS_H	1		/* /usr/include/limits.h	*/
-#define	HAS_FCNTL_H	1		/* /usr/include/fcntl.h		*/
-/*efine	HAS_ERRNO_DECL	1		/* errno.h declares errno	*/
-
-#define	HAS_FSTAT 	1		/* fstat syscall		*/
-#define	HAS_FCHMOD 	1		/* fchmod syscall		*/
-#define	HAS_CHMOD 	1		/* chmod syscall		*/
-#define	HAS_FCHOWN 	1		/* fchown syscall		*/
-#define	HAS_CHOWN 	1		/* chown syscall		*/
-/*efine	HAS__FSETMODE 	1		/* _fsetmode -- set file mode	*/
-
-#define	HAS_STRING_H 	1		/* /usr/include/string.h 	*/
-/*efine	HAS_STRINGS_H	1		/* /usr/include/strings.h 	*/
-
-#define	HAS_UNISTD_H	1		/* /usr/include/unistd.h	*/
-#define	HAS_UTIME	1		/* POSIX utime(path, times)	*/
-/*efine	HAS_UTIMES	1		/* use utimes()	syscall instead	*/
-#define	HAS_UTIME_H	1		/* UTIME header file		*/
-/*efine	HAS_UTIMBUF	1		/* struct utimbuf		*/
-/*efine	HAS_UTIMEUSEC   1		/* microseconds in utimbuf?	*/
-
-#endif	/* CONFIG_H */
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/*$Header$*/
-
-#ifndef	CONFIG_H
-#define	CONFIG_H
-
 #if 0
 efine	SIGHANDLER_T	int 		/* signal handlers are void	*/
 efine HAS_SYSV_SIGNAL	1		/* sigs not blocked/reset?	*/

Modified: trunk/codecs/gsm/inc/gsm.h
===================================================================
--- trunk/codecs/gsm/inc/gsm.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/inc/gsm.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -69,74 +69,3 @@
 #undef	GSM_P
 
 #endif	/* GSM_H */
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/*$Header$*/
-
-#ifndef	GSM_H
-#define	GSM_H
-
-#ifdef __cplusplus
-#	define	NeedFunctionPrototypes	1
-#endif
-
-#if __STDC__
-#	define	NeedFunctionPrototypes	1
-#endif
-
-#ifdef _NO_PROTO
-#	undef	NeedFunctionPrototypes
-#endif
-
-#ifdef NeedFunctionPrototypes
-#   include	&lt;stdio.h&gt;		/* for FILE * 	*/
-#endif
-
-#undef GSM_P
-#if NeedFunctionPrototypes
-#	define	GSM_P( protos )	protos
-#else
-#	define  GSM_P( protos )	( /* protos */ )
-#endif
-
-/*
- *	Interface
- */
-
-typedef struct gsm_state * 	gsm;
-typedef short		   	gsm_signal;		/* signed 16 bit */
-typedef unsigned char		gsm_byte;
-typedef gsm_byte 		gsm_frame[33];		/* 33 * 8 bits	 */
-
-#define	GSM_MAGIC		0xD		  	/* 13 kbit/s RPE-LTP */
-
-#define	GSM_PATCHLEVEL		10
-#define	GSM_MINOR		0
-#define	GSM_MAJOR		1
-
-#define	GSM_OPT_VERBOSE		1
-#define	GSM_OPT_FAST		2
-#define	GSM_OPT_LTP_CUT		3
-#define	GSM_OPT_WAV49		4
-#define	GSM_OPT_FRAME_INDEX	5
-#define	GSM_OPT_FRAME_CHAIN	6
-
-extern gsm  gsm_create 	GSM_P((void));
-extern void gsm_destroy GSM_P((gsm));	
-
-extern int  gsm_print   GSM_P((FILE *, gsm, gsm_byte  *));
-extern int  gsm_option  GSM_P((gsm, int, int *));
-
-extern void gsm_encode  GSM_P((gsm, gsm_signal *, gsm_byte  *));
-extern int  gsm_decode  GSM_P((gsm, gsm_byte   *, gsm_signal *));
-
-extern int  gsm_explode GSM_P((gsm, gsm_byte   *, gsm_signal *));
-extern void gsm_implode GSM_P((gsm, gsm_signal *, gsm_byte   *));
-
-#undef	GSM_P
-
-#endif	/* GSM_H */

Modified: trunk/codecs/gsm/inc/private.h
===================================================================
--- trunk/codecs/gsm/inc/private.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/inc/private.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -98,274 +98,6 @@
 # define GSM_L_MULT(a, b) /* word a, word b */	\
 	(((longword)(a) * (longword)(b)) &lt;&lt; 1)
 
-# define GSM_L_ADD(a, b)	\
-	( (a) &lt;  0 ? ( (b) &gt;= 0 ? (a) + (b)	\
-		 : (utmp = (ulongword)-((a) + 1) + (ulongword)-((b) + 1)) \
-		   &gt;= MAX_LONGWORD ? MIN_LONGWORD : -(longword)utmp-2 )   \
-	: ((b) &lt;= 0 ? (a) + (b)   \
-	          : (utmp = (ulongword)(a) + (ulongword)(b)) &gt;= MAX_LONGWORD \
-		    ? MAX_LONGWORD : utmp))
-
-/*
- * # define GSM_ADD(a, b)	\
- * 	((ltmp = (longword)(a) + (longword)(b)) &gt;= MAX_WORD \
- * 	? MAX_WORD : ltmp &lt;= MIN_WORD ? MIN_WORD : ltmp)
- */
-/* Nonportable, but faster: */
-
-#define	GSM_ADD(a, b)	\
-	((ulongword)((ltmp = (longword)(a) + (longword)(b)) - MIN_WORD) &gt; \
-		MAX_WORD - MIN_WORD ? (ltmp &gt; 0 ? MAX_WORD : MIN_WORD) : ltmp)
-
-# define GSM_SUB(a, b)	\
-	((ltmp = (longword)(a) - (longword)(b)) &gt;= MAX_WORD \
-	? MAX_WORD : ltmp &lt;= MIN_WORD ? MIN_WORD : ltmp)
-
-# define GSM_ABS(a)	((a) &lt; 0 ? ((a) == MIN_WORD ? MAX_WORD : -(a)) : (a))
-
-/* Use these if necessary:
-
-# define GSM_MULT_R(a, b)	gsm_mult_r(a, b)
-# define GSM_MULT(a, b)		gsm_mult(a, b)
-# define GSM_L_MULT(a, b)	gsm_L_mult(a, b)
-
-# define GSM_L_ADD(a, b)	gsm_L_add(a, b)
-# define GSM_ADD(a, b)		gsm_add(a, b)
-# define GSM_SUB(a, b)		gsm_sub(a, b)
-
-# define GSM_ABS(a)		gsm_abs(a)
-
-*/
-
-/*
- *  More prototypes from implementations..
- */
-extern void Gsm_Coder P((
-		struct gsm_state	* S,
-		word	* s,	/* [0..159] samples		IN	*/
-		word	* LARc,	/* [0..7] LAR coefficients	OUT	*/
-		word	* Nc,	/* [0..3] LTP lag		OUT 	*/
-		word	* bc,	/* [0..3] coded LTP gain	OUT 	*/
-		word	* Mc,	/* [0..3] RPE grid selection	OUT     */
-		word	* xmaxc,/* [0..3] Coded maximum amplitude OUT	*/
-		word	* xMc	/* [13*4] normalized RPE samples OUT	*/));
-
-extern void Gsm_Long_Term_Predictor P((		/* 4x for 160 samples */
-		struct gsm_state * S,
-		word	* d,	/* [0..39]   residual signal	IN	*/
-		word	* dp,	/* [-120..-1] d'		IN	*/
-		word	* e,	/* [0..40] 			OUT	*/
-		word	* dpp,	/* [0..40] 			OUT	*/
-		word	* Nc,	/* correlation lag		OUT	*/
-		word	* bc	/* gain factor			OUT	*/));
-
-extern void Gsm_LPC_Analysis P((
-		struct gsm_state * S,
-		word * s,	 /* 0..159 signals	IN/OUT	*/
-	        word * LARc));   /* 0..7   LARc's	OUT	*/
-
-extern void Gsm_Preprocess P((
-		struct gsm_state * S,
-		word * s, word * so));
-
-extern void Gsm_Encoding P((
-		struct gsm_state * S,
-		word	* e,	
-		word	* ep,	
-		word	* xmaxc,
-		word	* Mc,	
-		word	* xMc));
-
-extern void Gsm_Short_Term_Analysis_Filter P((
-		struct gsm_state * S,
-		word	* LARc,	/* coded log area ratio [0..7]  IN	*/
-		word	* d	/* st res. signal [0..159]	IN/OUT	*/));
-
-extern void Gsm_Decoder P((
-		struct gsm_state * S,
-		word	* LARcr,	/* [0..7]		IN	*/
-		word	* Ncr,		/* [0..3] 		IN 	*/
-		word	* bcr,		/* [0..3]		IN	*/
-		word	* Mcr,		/* [0..3] 		IN 	*/
-		word	* xmaxcr,	/* [0..3]		IN 	*/
-		word	* xMcr,		/* [0..13*4]		IN	*/
-		word	* s));		/* [0..159]		OUT 	*/
-
-extern void Gsm_Decoding P((
-		struct gsm_state * S,
-		word 	xmaxcr,
-		word	Mcr,
-		word	* xMcr,  	/* [0..12]		IN	*/
-		word	* erp)); 	/* [0..39]		OUT 	*/
-
-extern void Gsm_Long_Term_Synthesis_Filtering P((
-		struct gsm_state* S,
-		word	Ncr,
-		word	bcr,
-		word	* erp,		/* [0..39]		  IN 	*/
-		word	* drp)); 	/* [-120..-1] IN, [0..40] OUT 	*/
-
-void Gsm_RPE_Decoding P((
-	struct gsm_state *S,
-		word xmaxcr,
-		word Mcr,
-		word * xMcr,  /* [0..12], 3 bits             IN      */
-		word * erp)); /* [0..39]                     OUT     */
-
-void Gsm_RPE_Encoding P((
-		struct gsm_state * S,
-		word    * e,            /* -5..-1][0..39][40..44     IN/OUT  */
-		word    * xmaxc,        /*                              OUT */
-		word    * Mc,           /*                              OUT */
-		word    * xMc));        /* [0..12]                      OUT */
-
-extern void Gsm_Short_Term_Synthesis_Filter P((
-		struct gsm_state * S,
-		word	* LARcr, 	/* log area ratios [0..7]  IN	*/
-		word	* drp,		/* received d [0...39]	   IN	*/
-		word	* s));		/* signal   s [0..159]	  OUT	*/
-
-extern void Gsm_Update_of_reconstructed_short_time_residual_signal P((
-		word	* dpp,		/* [0...39]	IN	*/
-		word	* ep,		/* [0...39]	IN	*/
-		word	* dp));		/* [-120...-1]  IN/OUT 	*/
-
-/*
- *  Tables from table.c
- */
-#ifndef	GSM_TABLE_C
-
-extern word gsm_A[8], gsm_B[8], gsm_MIC[8], gsm_MAC[8];
-extern word gsm_INVA[8];
-extern word gsm_DLB[4], gsm_QLB[4];
-extern word gsm_H[11];
-extern word gsm_NRFAC[8];
-extern word gsm_FAC[8];
-
-#endif	/* GSM_TABLE_C */
-
-/*
- *  Debugging
- */
-#ifdef NDEBUG
-
-#	define	gsm_debug_words(a, b, c, d)		/* nil */
-#	define	gsm_debug_longwords(a, b, c, d)		/* nil */
-#	define	gsm_debug_word(a, b)			/* nil */
-#	define	gsm_debug_longword(a, b)		/* nil */
-
-#else	/* !NDEBUG =&gt; DEBUG */
-
-	extern void  gsm_debug_words     P((char * name, int, int, word *));
-	extern void  gsm_debug_longwords P((char * name, int, int, longword *));
-	extern void  gsm_debug_longword  P((char * name, longword));
-	extern void  gsm_debug_word      P((char * name, word));
-
-#endif /* !NDEBUG */
-
-#include &quot;unproto.h&quot;
-
-#endif	/* PRIVATE_H */
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/*$Header$*/
-
-#ifndef	PRIVATE_H
-#define	PRIVATE_H
-
-typedef short			word;		/* 16 bit signed int	*/
-typedef long			longword;	/* 32 bit signed int	*/
-
-typedef unsigned short		uword;		/* unsigned word	*/
-typedef unsigned long		ulongword;	/* unsigned longword	*/
-
-struct gsm_state {
-
-	word		dp0[ 280 ];
-
-	word		z1;		/* preprocessing.c, Offset_com. */
-	longword	L_z2;		/*                  Offset_com. */
-	int		mp;		/*                  Preemphasis	*/
-
-	word		u[8];		/* short_term_aly_filter.c	*/
-	word		LARpp[2][8]; 	/*                              */
-	word		j;		/*                              */
-
-	word            ltp_cut;        /* long_term.c, LTP crosscorr.  */
-	word		nrp; /* 40 */	/* long_term.c, synthesis	*/
-	word		v[9];		/* short_term.c, synthesis	*/
-	word		msr;		/* decoder.c,	Postprocessing	*/
-
-	char		verbose;	/* only used if !NDEBUG		*/
-	char		fast;		/* only used if FAST		*/
-
-	char		wav_fmt;	/* only used if WAV49 defined	*/
-	unsigned char	frame_index;	/*            odd/even chaining	*/
-	unsigned char	frame_chain;	/*   half-byte to carry forward	*/
-};
-
-
-#define	MIN_WORD	(-32767 - 1)
-#define	MAX_WORD	  32767
-
-#define	MIN_LONGWORD	(-2147483647 - 1)
-#define	MAX_LONGWORD	  2147483647
-
-#ifdef	SASR		/* flag: &gt;&gt; is a signed arithmetic shift right */
-#undef	SASR
-#define	SASR(x, by)	((x) &gt;&gt; (by))
-#else
-#define	SASR(x, by)	((x) &gt;= 0 ? (x) &gt;&gt; (by) : (~(-((x) + 1) &gt;&gt; (by))))
-#endif	/* SASR */
-
-#include &quot;proto.h&quot;
-
-/*
- *	Prototypes from add.c
- */
-extern word	gsm_mult 	P((word a, word b));
-extern longword gsm_L_mult 	P((word a, word b));
-extern word	gsm_mult_r	P((word a, word b));
-
-extern word	gsm_div  	P((word num, word denum));
-
-extern word	gsm_add 	P(( word a, word b ));
-extern longword gsm_L_add 	P(( longword a, longword b ));
-
-extern word	gsm_sub 	P((word a, word b));
-extern longword gsm_L_sub 	P((longword a, longword b));
-
-extern word	gsm_abs 	P((word a));
-
-extern word	gsm_norm 	P(( longword a ));
-
-extern longword gsm_L_asl  	P((longword a, int n));
-extern word	gsm_asl 	P((word a, int n));
-
-extern longword gsm_L_asr  	P((longword a, int n));
-extern word	gsm_asr  	P((word a, int n));
-
-/*
- *  Inlined functions from add.h 
- */
-
-/* 
- * #define GSM_MULT_R(a, b) (* word a, word b, !(a == b == MIN_WORD) *)	\
- *	(0x0FFFF &amp; SASR(((longword)(a) * (longword)(b) + 16384), 15))
- */
-#define GSM_MULT_R(a, b) /* word a, word b, !(a == b == MIN_WORD) */	\
-	(SASR( ((longword)(a) * (longword)(b) + 16384), 15 ))
-
-# define GSM_MULT(a,b)	 /* word a, word b, !(a == b == MIN_WORD) */	\
-	(SASR( ((longword)(a) * (longword)(b)), 15 ))
-
-# define GSM_L_MULT(a, b) /* word a, word b */	\
-	(((longword)(a) * (longword)(b)) &lt;&lt; 1)
-
 #if defined(__GNUC__) &amp;&amp; defined(__i386__)
 
 static __inline__ int GSM_L_ADD(int a, int b)

Modified: trunk/codecs/gsm/inc/proto.h
===================================================================
--- trunk/codecs/gsm/inc/proto.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/inc/proto.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -63,68 +63,3 @@
 #endif  /* !NeedFunctionPrototypes */
 
 #endif	/* PROTO_H */
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/*$Header$*/
-
-#ifndef	PROTO_H
-#define	PROTO_H
-
-#if __cplusplus
-#	define	NeedFunctionPrototypes	1
-#endif
-
-#if __STDC__
-#	define	NeedFunctionPrototypes	1
-#endif
-
-#ifdef	_NO_PROTO
-#	undef	NeedFunctionPrototypes
-#endif
-
-#undef	P	/* gnu stdio.h actually defines this... 	*/
-#undef	P0
-#undef	P1
-#undef	P2
-#undef	P3
-#undef	P4
-#undef	P5
-#undef	P6
-#undef	P7
-#undef	P8
-
-#if NeedFunctionPrototypes
-
-#	define	P( protos )	protos
-
-#	define	P0()				(void)
-#	define	P1(x, a)			(a)
-#	define	P2(x, a, b)			(a, b)
-#	define	P3(x, a, b, c)			(a, b, c)
-#	define	P4(x, a, b, c, d)		(a, b, c, d)	
-#	define	P5(x, a, b, c, d, e)		(a, b, c, d, e)
-#	define	P6(x, a, b, c, d, e, f)		(a, b, c, d, e, f)
-#	define	P7(x, a, b, c, d, e, f, g)	(a, b, c, d, e, f, g)
-#	define	P8(x, a, b, c, d, e, f, g, h)	(a, b, c, d, e, f, g, h)
-
-#else /* !NeedFunctionPrototypes */
-
-#	define	P( protos )	( /* protos */ )
-
-#	define	P0()				()
-#	define	P1(x, a)			x a;
-#	define	P2(x, a, b)			x a; b;
-#	define	P3(x, a, b, c)			x a; b; c;
-#	define	P4(x, a, b, c, d)		x a; b; c; d;
-#	define	P5(x, a, b, c, d, e)		x a; b; c; d; e;
-#	define	P6(x, a, b, c, d, e, f)		x a; b; c; d; e; f;
-#	define	P7(x, a, b, c, d, e, f, g)	x a; b; c; d; e; f; g;
-#	define	P8(x, a, b, c, d, e, f, g, h)	x a; b; c; d; e; f; g; h;
-
-#endif  /* !NeedFunctionPrototypes */
-
-#endif	/* PROTO_H */

Modified: trunk/codecs/gsm/inc/unproto.h
===================================================================
--- trunk/codecs/gsm/inc/unproto.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/inc/unproto.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -21,26 +21,3 @@
 #undef	P8
 
 #endif	/* PROTO_H */
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/*$Header$*/
-
-#ifdef	PROTO_H		/* sic */
-#undef	PROTO_H
-
-#undef	P
-#undef	P0
-#undef	P1
-#undef	P2
-#undef	P3
-#undef	P4
-#undef	P5
-#undef	P6
-#undef	P7
-#undef	P8
-
-#endif	/* PROTO_H */

Modified: trunk/codecs/gsm/src/add.c
===================================================================
--- trunk/codecs/gsm/src/add.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/add.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -23,241 +23,6 @@
 word gsm_add P2((a,b), word a, word b)
 {
 	longword sum = (longword)a + (longword)b;
-	return saturate(sum);
-}
-
-word gsm_sub P2((a,b), word a, word b)
-{
-	longword diff = (longword)a - (longword)b;
-	return saturate(diff);
-}
-
-word gsm_mult P2((a,b), word a, word b)
-{
-	if (a == MIN_WORD &amp;&amp; b == MIN_WORD) return MAX_WORD;
-	else return SASR( (longword)a * (longword)b, 15 );
-}
-
-word gsm_mult_r P2((a,b), word a, word b)
-{
-	if (b == MIN_WORD &amp;&amp; a == MIN_WORD) return MAX_WORD;
-	else {
-		longword prod = (longword)a * (longword)b + 16384;
-		prod &gt;&gt;= 15;
-		return prod &amp; 0xFFFF;
-	}
-}
-
-word gsm_abs P1((a), word a)
-{
-	return a &lt; 0 ? (a == MIN_WORD ? MAX_WORD : -a) : a;
-}
-
-longword gsm_L_mult P2((a,b),word a, word b)
-{
-	assert( a != MIN_WORD || b != MIN_WORD );
-	return ((longword)a * (longword)b) &lt;&lt; 1;
-}
-
-longword gsm_L_add P2((a,b), longword a, longword b)
-{
-	if (a &lt; 0) {
-		if (b &gt;= 0) return a + b;
-		else {
-			ulongword A = (ulongword)-(a + 1) + (ulongword)-(b + 1);
-			return A &gt;= MAX_LONGWORD ? MIN_LONGWORD :-(longword)A-2;
-		}
-	}
-	else if (b &lt;= 0) return a + b;
-	else {
-		ulongword A = (ulongword)a + (ulongword)b;
-		return A &gt; MAX_LONGWORD ? MAX_LONGWORD : A;
-	}
-}
-
-longword gsm_L_sub P2((a,b), longword a, longword b)
-{
-	if (a &gt;= 0) {
-		if (b &gt;= 0) return a - b;
-		else {
-			/* a&gt;=0, b&lt;0 */
-
-			ulongword A = (ulongword)a + -(b + 1);
-			return A &gt;= MAX_LONGWORD ? MAX_LONGWORD : (A + 1);
-		}
-	}
-	else if (b &lt;= 0) return a - b;
-	else {
-		/* a&lt;0, b&gt;0 */  
-
-		ulongword A = (ulongword)-(a + 1) + b;
-		return A &gt;= MAX_LONGWORD ? MIN_LONGWORD : -(longword)A - 1;
-	}
-}
-
-static unsigned char const bitoff[ 256 ] = {
-	 8, 7, 6, 6, 5, 5, 5, 5, 4, 4, 4, 4, 4, 4, 4, 4,
-	 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
-	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-	 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2,
-	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-	 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
-	 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
-};
-
-word gsm_norm P1((a), longword a )
-/*
- * the number of left shifts needed to normalize the 32 bit
- * variable L_var1 for positive values on the interval
- *
- * with minimum of
- * minimum of 1073741824  (01000000000000000000000000000000) and 
- * maximum of 2147483647  (01111111111111111111111111111111)
- *
- *
- * and for negative values on the interval with
- * minimum of -2147483648 (-10000000000000000000000000000000) and
- * maximum of -1073741824 ( -1000000000000000000000000000000).
- *
- * in order to normalize the result, the following
- * operation must be done: L_norm_var1 = L_var1 &lt;&lt; norm( L_var1 );
- *
- * (That's 'ffs', only from the left, not the right..)
- */
-{
-	assert(a != 0);
-
-	if (a &lt; 0) {
-		if (a &lt;= -1073741824) return 0;
-		a = ~a;
-	}
-
-	return    a &amp; 0xffff0000 
-		? ( a &amp; 0xff000000
-		  ?  -1 + bitoff[ 0xFF &amp; (a &gt;&gt; 24) ]
-		  :   7 + bitoff[ 0xFF &amp; (a &gt;&gt; 16) ] )
-		: ( a &amp; 0xff00
-		  ?  15 + bitoff[ 0xFF &amp; (a &gt;&gt; 8) ]
-		  :  23 + bitoff[ 0xFF &amp; a ] );
-}
-
-longword gsm_L_asl P2((a,n), longword a, int n)
-{
-	if (n &gt;= 32) return 0;
-	if (n &lt;= -32) return -(a &lt; 0);
-	if (n &lt; 0) return gsm_L_asr(a, -n);
-	return a &lt;&lt; n;
-}
-
-word gsm_asl P2((a,n), word a, int n)
-{
-	if (n &gt;= 16) return 0;
-	if (n &lt;= -16) return -(a &lt; 0);
-	if (n &lt; 0) return gsm_asr(a, -n);
-	return a &lt;&lt; n;
-}
-
-longword gsm_L_asr P2((a,n), longword a, int n)
-{
-	if (n &gt;= 32) return -(a &lt; 0);
-	if (n &lt;= -32) return 0;
-	if (n &lt; 0) return a &lt;&lt; -n;
-
-#	ifdef	SASR
-		return a &gt;&gt; n;
-#	else
-		if (a &gt;= 0) return a &gt;&gt; n;
-		else return -(longword)( -(ulongword)a &gt;&gt; n );
-#	endif
-}
-
-word gsm_asr P2((a,n), word a, int n)
-{
-	if (n &gt;= 16) return -(a &lt; 0);
-	if (n &lt;= -16) return 0;
-	if (n &lt; 0) return a &lt;&lt; -n;
-
-#	ifdef	SASR
-		return a &gt;&gt; n;
-#	else
-		if (a &gt;= 0) return a &gt;&gt; n;
-		else return -(word)( -(uword)a &gt;&gt; n );
-#	endif
-}
-
-/* 
- *  (From p. 46, end of section 4.2.5)
- *
- *  NOTE: The following lines gives [sic] one correct implementation
- *  	  of the div(num, denum) arithmetic operation.  Compute div
- *        which is the integer division of num by denum: with denum
- *	  &gt;= num &gt; 0
- */
-
-word gsm_div P2((num,denum), word num, word denum)
-{
-	longword	L_num   = num;
-	longword	L_denum = denum;
-	word		div 	= 0;
-	int		k 	= 15;
-
-	/* The parameter num sometimes becomes zero.
-	 * Although this is explicitly guarded against in 4.2.5,
-	 * we assume that the result should then be zero as well.
-	 */
-
-	/* assert(num != 0); */
-
-	assert(num &gt;= 0 &amp;&amp; denum &gt;= num);
-	if (num == 0)
-	    return 0;
-
-	while (k--) {
-		div   &lt;&lt;= 1;
-		L_num &lt;&lt;= 1;
-
-		if (L_num &gt;= L_denum) {
-			L_num -= L_denum;
-			div++;
-		}
-	}
-
-	return div;
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-/*
- *  See private.h for the more commonly used macro versions.
- */
-
-#include	&lt;stdio.h&gt;
-#include	&lt;assert.h&gt;
-
-#include	&quot;private.h&quot;
-#include	&quot;gsm.h&quot;
-#include	&quot;proto.h&quot;
-
-#define	saturate(x) 	\
-	((x) &lt; MIN_WORD ? MIN_WORD : (x) &gt; MAX_WORD ? MAX_WORD: (x))
-
-word gsm_add P2((a,b), word a, word b)
-{
-	longword sum = (longword)a + (longword)b;
 	return (word)saturate(sum);
 }
 

Modified: trunk/codecs/gsm/src/code.c
===================================================================
--- trunk/codecs/gsm/src/code.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/code.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -8,105 +8,6 @@
 
 #include	&quot;config.h&quot;
 
-
-#ifdef	HAS_STDLIB_H
-#include	&lt;stdlib.h&gt;
-#else
-#	include &quot;proto.h&quot;
-	extern char	* memcpy P((char *, char *, int));
-#endif
-
-#include	&quot;private.h&quot;
-#include	&quot;gsm.h&quot;
-#include	&quot;proto.h&quot;
-
-/* 
- *  4.2 FIXED POINT IMPLEMENTATION OF THE RPE-LTP CODER 
- */
-
-void Gsm_Coder P8((S,s,LARc,Nc,bc,Mc,xmaxc,xMc),
-
-	struct gsm_state	* S,
-
-	word	* s,	/* [0..159] samples		  	IN	*/
-
-/*
- * The RPE-LTD coder works on a frame by frame basis.  The length of
- * the frame is equal to 160 samples.  Some computations are done
- * once per frame to produce at the output of the coder the
- * LARc[1..8] parameters which are the coded LAR coefficients and 
- * also to realize the inverse filtering operation for the entire
- * frame (160 samples of signal d[0..159]).  These parts produce at
- * the output of the coder:
- */
-
-	word	* LARc,	/* [0..7] LAR coefficients		OUT	*/
-
-/*
- * Procedure 4.2.11 to 4.2.18 are to be executed four times per
- * frame.  That means once for each sub-segment RPE-LTP analysis of
- * 40 samples.  These parts produce at the output of the coder:
- */
-
-	word	* Nc,	/* [0..3] LTP lag			OUT 	*/
-	word	* bc,	/* [0..3] coded LTP gain		OUT 	*/
-	word	* Mc,	/* [0..3] RPE grid selection		OUT     */
-	word	* xmaxc,/* [0..3] Coded maximum amplitude	OUT	*/
-	word	* xMc	/* [13*4] normalized RPE samples	OUT	*/
-)
-{
-	int	k;
-	word	* dp  = S-&gt;dp0 + 120;	/* [ -120...-1 ] */
-	word	* dpp = dp;		/* [ 0...39 ]	 */
-
-	static word e[50];
-
-	word	so[160];
-
-	Gsm_Preprocess			(S, s, so);
-	Gsm_LPC_Analysis		(S, so, LARc);
-	Gsm_Short_Term_Analysis_Filter	(S, LARc, so);
-
-	for (k = 0; k &lt;= 3; k++, xMc += 13) {
-
-		Gsm_Long_Term_Predictor	( S,
-					 so+k*40, /* d      [0..39] IN	*/
-					 dp,	  /* dp  [-120..-1] IN	*/
-					e + 5,	  /* e      [0..39] OUT	*/
-					dpp,	  /* dpp    [0..39] OUT */
-					 Nc++,
-					 bc++);
-
-		Gsm_RPE_Encoding	( S,
-					e + 5,	/* e	  ][0..39][ IN/OUT */
-					  xmaxc++, Mc++, xMc );
-		/*
-		 * Gsm_Update_of_reconstructed_short_time_residual_signal
-		 *			( dpp, e + 5, dp );
-		 */
-
-		{ register int i;
-		  register longword ltmp;
-		  for (i = 0; i &lt;= 39; i++)
-			dp[ i ] = GSM_ADD( e[5 + i], dpp[i] );
-		}
-		dp  += 40;
-		dpp += 40;
-
-	}
-	(void)memcpy( (char *)S-&gt;dp0, (char *)(S-&gt;dp0 + 160),
-		120 * sizeof(*S-&gt;dp0) );
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include	&quot;config.h&quot;
-
 #ifdef	HAS_STRING_H
 #include	&lt;string.h&gt;
 #else

Modified: trunk/codecs/gsm/src/debug.c
===================================================================
--- trunk/codecs/gsm/src/debug.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/debug.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -74,79 +74,3 @@
 }
 
 #endif
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;private.h&quot;
-
-#ifndef	NDEBUG
-
-/* If NDEBUG _is_ defined and no debugging should be performed,
- * calls to functions in this module are #defined to nothing
- * in private.h.
- */
-
-#include &lt;stdio.h&gt;
-#include &quot;proto.h&quot;
-
-void gsm_debug_words P4( (name, from, to, ptr), 
-	char 	      * name,
-	int		from,
-	int		to,
-	word		* ptr)
-{
-	int 	nprinted = 0;
-
-	fprintf( stderr, &quot;%s [%d .. %d]: &quot;, name, from, to );
-	while (from &lt;= to) {
-		fprintf(stderr, &quot;%d &quot;, ptr[ from ] );
-		from++;
-		if (nprinted++ &gt;= 7) {
-			nprinted = 0;
-			if (from &lt; to) putc('\n', stderr);
-		}
-	}
-	putc('\n', stderr);
-}
-
-void gsm_debug_longwords P4( (name, from, to, ptr),
-	char 	      * name,
-	int		from,
-	int		to,
-	longword      * ptr)
-{
-	int 	nprinted = 0;
-
-	fprintf( stderr, &quot;%s [%d .. %d]: &quot;, name, from, to );
-	while (from &lt;= to) {
-
-		fprintf(stderr, &quot;%d &quot;, ptr[ from ] );
-		from++;
-		if (nprinted++ &gt;= 7) {
-			nprinted = 0;
-			if (from &lt; to) putc('\n', stderr);
-		}
-	}
-	putc('\n', stderr);
-}
-
-void gsm_debug_longword P2(  (name, value),
-	char		* name,
-	longword	  value	)
-{
-	fprintf(stderr, &quot;%s: %d\n&quot;, name, (long)value );
-}
-
-void gsm_debug_word P2(  (name, value),
-	char	* name,
-	word	  value	)
-{
-	fprintf(stderr, &quot;%s: %d\n&quot;, name, (long)value);
-}
-
-#endif

Modified: trunk/codecs/gsm/src/decode.c
===================================================================
--- trunk/codecs/gsm/src/decode.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/decode.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -22,72 +22,9 @@
 {
 	register int		k;
 	register word		msr = S-&gt;msr;
-	register longword	ltmp;	/* for GSM_ADD */
 	register word		tmp;
 
 	for (k = 160; k--; s++) {
-		tmp = GSM_MULT_R( msr, 28180 );
-		msr = GSM_ADD(*s, tmp);  	   /* Deemphasis 	     */
-		*s  = GSM_ADD(msr, msr) &amp; 0xFFF8;  /* Truncation &amp; Upscaling */
-	}
-	S-&gt;msr = msr;
-}
-
-void Gsm_Decoder P8((S,LARcr, Ncr,bcr,Mcr,xmaxcr,xMcr,s),
-	struct gsm_state	* S,
-
-	word		* LARcr,	/* [0..7]		IN	*/
-
-	word		* Ncr,		/* [0..3] 		IN 	*/
-	word		* bcr,		/* [0..3]		IN	*/
-	word		* Mcr,		/* [0..3] 		IN 	*/
-	word		* xmaxcr,	/* [0..3]		IN 	*/
-	word		* xMcr,		/* [0..13*4]		IN	*/
-
-	word		* s)		/* [0..159]		OUT 	*/
-{
-	int		j, k;
-	word		erp[40], wt[160];
-	word		* drp = S-&gt;dp0 + 120;
-
-	for (j=0; j &lt;= 3; j++, xmaxcr++, bcr++, Ncr++, Mcr++, xMcr += 13) {
-
-		Gsm_RPE_Decoding( S, *xmaxcr, *Mcr, xMcr, erp );
-		Gsm_Long_Term_Synthesis_Filtering( S, *Ncr, *bcr, erp, drp );
-
-		for (k = 0; k &lt;= 39; k++) wt[ j * 40 + k ] =  drp[ k ];
-	}
-
-	Gsm_Short_Term_Synthesis_Filter( S, LARcr, wt, s );
-	Postprocessing(S, s);
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &lt;stdio.h&gt;
-
-#include	&quot;private.h&quot;
-#include	&quot;gsm.h&quot;
-#include	&quot;proto.h&quot;
-
-/*
- *  4.3 FIXED POINT IMPLEMENTATION OF THE RPE-LTP DECODER
- */
-
-static void Postprocessing P2((S,s),
-	struct gsm_state	* S,
-	register word 		* s)
-{
-	register int		k;
-	register word		msr = S-&gt;msr;
-	register word		tmp;
-
-	for (k = 160; k--; s++) {
 		tmp = (word)GSM_MULT_R( msr, 28180 );
 		msr = GSM_ADD(*s, tmp);  	   /* Deemphasis 	     */
 		*s  = GSM_ADD(msr, msr) &amp; 0xFFF8;  /* Truncation &amp; Upscaling */

Modified: trunk/codecs/gsm/src/gsm_create.c
===================================================================
--- trunk/codecs/gsm/src/gsm_create.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_create.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -43,48 +43,3 @@
 
 	return r;
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-static char const	ident[] = &quot;$Header$&quot;;
-
-#include	&quot;config.h&quot;
-
-#ifdef	HAS_STRING_H
-#include	&lt;string.h&gt;
-#else
-#	include &quot;proto.h&quot;
-	extern char	* memset P((char *, int, int));
-#endif
-
-#ifdef	HAS_STDLIB_H
-#	include	&lt;stdlib.h&gt;
-#else
-#	ifdef	HAS_MALLOC_H
-#		include 	&lt;malloc.h&gt;
-#	else
-		extern char * malloc();
-#	endif
-#endif
-
-#include &lt;stdio.h&gt;
-
-#include &quot;gsm.h&quot;
-#include &quot;private.h&quot;
-#include &quot;proto.h&quot;
-
-gsm gsm_create P0()
-{
-	gsm  r;
-
-	r = (gsm)malloc(sizeof(struct gsm_state));
-	if (!r) return r;
-
-	memset((char *)r, 0, sizeof(*r));
-	r-&gt;nrp = 40;
-
-	return r;
-}

Modified: trunk/codecs/gsm/src/gsm_decode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_decode.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_decode.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -359,364 +359,3 @@
 
 	return 0;
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-int gsm_decode P3((s, c, target), gsm s, gsm_byte * c, gsm_signal * target)
-{
-	word  	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
-
-#ifdef WAV49
-	if (s-&gt;wav_fmt) {
-
-		uword sr = 0;
-
-		s-&gt;frame_index = !s-&gt;frame_index;
-		if (s-&gt;frame_index) {
-
-			sr = *c++;
-			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 5 */
-			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 10 */
-			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 15 */
-			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;			/* 20 */
-			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 25 */
-			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 30 */
-			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-
-			s-&gt;frame_chain = sr &amp; 0xf;
-		}
-		else {
-			sr = s-&gt;frame_chain;
-			sr |= (uword)*c++ &lt;&lt; 4;			/* 1 */
-			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr = *c++;
-			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			sr |= (uword)*c++ &lt;&lt; 3;
-			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 5 */
-			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 10 */
-			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 15 */
-			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 20 */
-			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;	
-			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 25 */
-			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;		
-			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 30 */
-			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-		}
-	}
-	else
-#endif
-	{
-		/* GSM_MAGIC  = (*c &gt;&gt; 4) &amp; 0xF; */
-
-		if (((*c &gt;&gt; 4) &amp; 0x0F) != GSM_MAGIC) return -1;
-
-		LARc[0]  = (*c++ &amp; 0xF) &lt;&lt; 2;		/* 1 */
-		LARc[0] |= (*c &gt;&gt; 6) &amp; 0x3;
-		LARc[1]  = *c++ &amp; 0x3F;
-		LARc[2]  = (*c &gt;&gt; 3) &amp; 0x1F;
-		LARc[3]  = (*c++ &amp; 0x7) &lt;&lt; 2;
-		LARc[3] |= (*c &gt;&gt; 6) &amp; 0x3;
-		LARc[4]  = (*c &gt;&gt; 2) &amp; 0xF;
-		LARc[5]  = (*c++ &amp; 0x3) &lt;&lt; 2;
-		LARc[5] |= (*c &gt;&gt; 6) &amp; 0x3;
-		LARc[6]  = (*c &gt;&gt; 3) &amp; 0x7;
-		LARc[7]  = *c++ &amp; 0x7;
-		Nc[0]  = (*c &gt;&gt; 1) &amp; 0x7F;
-		bc[0]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-		bc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
-		Mc[0]  = (*c &gt;&gt; 5) &amp; 0x3;
-		xmaxc[0]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-		xmaxc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[0]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[1]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[2]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[2] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[3]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[4]  = *c++ &amp; 0x7;
-		xmc[5]  = (*c &gt;&gt; 5) &amp; 0x7;
-		xmc[6]  = (*c &gt;&gt; 2) &amp; 0x7;
-		xmc[7]  = (*c++ &amp; 0x3) &lt;&lt; 1;		/* 10 */
-		xmc[7] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[8]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[9]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[10]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[10] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[11]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[12]  = *c++ &amp; 0x7;
-		Nc[1]  = (*c &gt;&gt; 1) &amp; 0x7F;
-		bc[1]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-		bc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
-		Mc[1]  = (*c &gt;&gt; 5) &amp; 0x3;
-		xmaxc[1]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-		xmaxc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[13]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[14]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[15]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[15] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[16]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[17]  = *c++ &amp; 0x7;
-		xmc[18]  = (*c &gt;&gt; 5) &amp; 0x7;
-		xmc[19]  = (*c &gt;&gt; 2) &amp; 0x7;
-		xmc[20]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-		xmc[20] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[21]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[22]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[23]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[23] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[24]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[25]  = *c++ &amp; 0x7;
-		Nc[2]  = (*c &gt;&gt; 1) &amp; 0x7F;
-		bc[2]  = (*c++ &amp; 0x1) &lt;&lt; 1;		/* 20 */
-		bc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
-		Mc[2]  = (*c &gt;&gt; 5) &amp; 0x3;
-		xmaxc[2]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-		xmaxc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[26]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[27]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[28]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[28] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[29]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[30]  = *c++ &amp; 0x7;
-		xmc[31]  = (*c &gt;&gt; 5) &amp; 0x7;
-		xmc[32]  = (*c &gt;&gt; 2) &amp; 0x7;
-		xmc[33]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-		xmc[33] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[34]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[35]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[36]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[36] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[37]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[38]  = *c++ &amp; 0x7;
-		Nc[3]  = (*c &gt;&gt; 1) &amp; 0x7F;
-		bc[3]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-		bc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
-		Mc[3]  = (*c &gt;&gt; 5) &amp; 0x3;
-		xmaxc[3]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-		xmaxc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[39]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[40]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[41]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[41] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[42]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[43]  = *c++ &amp; 0x7;			/* 30  */
-		xmc[44]  = (*c &gt;&gt; 5) &amp; 0x7;
-		xmc[45]  = (*c &gt;&gt; 2) &amp; 0x7;
-		xmc[46]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-		xmc[46] |= (*c &gt;&gt; 7) &amp; 0x1;
-		xmc[47]  = (*c &gt;&gt; 4) &amp; 0x7;
-		xmc[48]  = (*c &gt;&gt; 1) &amp; 0x7;
-		xmc[49]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-		xmc[49] |= (*c &gt;&gt; 6) &amp; 0x3;
-		xmc[50]  = (*c &gt;&gt; 3) &amp; 0x7;
-		xmc[51]  = *c &amp; 0x7;			/* 33 */
-	}
-
-	Gsm_Decoder(s, LARc, Nc, bc, Mc, xmaxc, xmc, target);
-
-	return 0;
-}

Modified: trunk/codecs/gsm/src/gsm_destroy.c
===================================================================
--- trunk/codecs/gsm/src/gsm_destroy.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_destroy.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -24,29 +24,3 @@
 {
 	if (S) free((char *)S);
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;gsm.h&quot;
-#include &quot;config.h&quot;
-#include &quot;proto.h&quot;
-
-#ifdef	HAS_STDLIB_H
-#	include	&lt;stdlib.h&gt;
-#else
-#	ifdef	HAS_MALLOC_H
-#		include 	&lt;malloc.h&gt;
-#	else
-		extern void free();
-#	endif
-#endif
-
-void gsm_destroy P1((S), gsm S)
-{
-	if (S) free((char *)S);
-}

Modified: trunk/codecs/gsm/src/gsm_encode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_encode.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_encode.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -449,454 +449,3 @@
 
 	}
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;private.h&quot;
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-void gsm_encode P3((s, source, c), gsm s, gsm_signal * source, gsm_byte * c)
-{
-	word	 	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
-
-	Gsm_Coder(s, source, LARc, Nc, bc, Mc, xmaxc, xmc);
-
-
-	/*	variable	size
-
-		GSM_MAGIC	4
-
-		LARc[0]		6
-		LARc[1]		6
-		LARc[2]		5
-		LARc[3]		5
-		LARc[4]		4
-		LARc[5]		4
-		LARc[6]		3
-		LARc[7]		3
-
-		Nc[0]		7
-		bc[0]		2
-		Mc[0]		2
-		xmaxc[0]	6
-		xmc[0]		3
-		xmc[1]		3
-		xmc[2]		3
-		xmc[3]		3
-		xmc[4]		3
-		xmc[5]		3
-		xmc[6]		3
-		xmc[7]		3
-		xmc[8]		3
-		xmc[9]		3
-		xmc[10]		3
-		xmc[11]		3
-		xmc[12]		3
-
-		Nc[1]		7
-		bc[1]		2
-		Mc[1]		2
-		xmaxc[1]	6
-		xmc[13]		3
-		xmc[14]		3
-		xmc[15]		3
-		xmc[16]		3
-		xmc[17]		3
-		xmc[18]		3
-		xmc[19]		3
-		xmc[20]		3
-		xmc[21]		3
-		xmc[22]		3
-		xmc[23]		3
-		xmc[24]		3
-		xmc[25]		3
-
-		Nc[2]		7
-		bc[2]		2
-		Mc[2]		2
-		xmaxc[2]	6
-		xmc[26]		3
-		xmc[27]		3
-		xmc[28]		3
-		xmc[29]		3
-		xmc[30]		3
-		xmc[31]		3
-		xmc[32]		3
-		xmc[33]		3
-		xmc[34]		3
-		xmc[35]		3
-		xmc[36]		3
-		xmc[37]		3
-		xmc[38]		3
-
-		Nc[3]		7
-		bc[3]		2
-		Mc[3]		2
-		xmaxc[3]	6
-		xmc[39]		3
-		xmc[40]		3
-		xmc[41]		3
-		xmc[42]		3
-		xmc[43]		3
-		xmc[44]		3
-		xmc[45]		3
-		xmc[46]		3
-		xmc[47]		3
-		xmc[48]		3
-		xmc[49]		3
-		xmc[50]		3
-		xmc[51]		3
-	*/
-
-#ifdef WAV49
-
-	if (s-&gt;wav_fmt) {
-		s-&gt;frame_index = !s-&gt;frame_index;
-		if (s-&gt;frame_index) {
-
-			uword sr;
-
-			sr = 0;
-			sr = sr &gt;&gt; 6 | LARc[0] &lt;&lt; 10;
-			sr = sr &gt;&gt; 6 | LARc[1] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 4;
-			sr = sr &gt;&gt; 5 | LARc[2] &lt;&lt; 11;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 5 | LARc[3] &lt;&lt; 11;
-			sr = sr &gt;&gt; 4 | LARc[4] &lt;&lt; 12;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 4 | LARc[5] &lt;&lt; 12;
-			sr = sr &gt;&gt; 3 | LARc[6] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | LARc[7] &lt;&lt; 13;
-			sr = sr &gt;&gt; 7 | Nc[0] &lt;&lt; 9;
-			*c++ = sr &gt;&gt; 5;
-			sr = sr &gt;&gt; 2 | bc[0] &lt;&lt; 14;
-			sr = sr &gt;&gt; 2 | Mc[0] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[0] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 3;
-			sr = sr &gt;&gt; 3 | xmc[0] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[1] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[2] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[3] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[4] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[5] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[6] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[7] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[8] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[9] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[10] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[11] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[12] &lt;&lt; 13;
-			sr = sr &gt;&gt; 7 | Nc[1] &lt;&lt; 9;
-			*c++ = sr &gt;&gt; 5;
-			sr = sr &gt;&gt; 2 | bc[1] &lt;&lt; 14;
-			sr = sr &gt;&gt; 2 | Mc[1] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[1] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 3;
-			sr = sr &gt;&gt; 3 | xmc[13] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[14] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[15] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[16] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[17] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[18] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[19] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[20] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[21] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[22] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[23] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[24] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[25] &lt;&lt; 13;
-			sr = sr &gt;&gt; 7 | Nc[2] &lt;&lt; 9;
-			*c++ = sr &gt;&gt; 5;
-			sr = sr &gt;&gt; 2 | bc[2] &lt;&lt; 14;
-			sr = sr &gt;&gt; 2 | Mc[2] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[2] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 3;
-			sr = sr &gt;&gt; 3 | xmc[26] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[27] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[28] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[29] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[30] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[31] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[32] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[33] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[34] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[35] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[36] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[37] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[38] &lt;&lt; 13;
-			sr = sr &gt;&gt; 7 | Nc[3] &lt;&lt; 9;
-			*c++ = sr &gt;&gt; 5;
-			sr = sr &gt;&gt; 2 | bc[3] &lt;&lt; 14;
-			sr = sr &gt;&gt; 2 | Mc[3] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[3] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 3;
-			sr = sr &gt;&gt; 3 | xmc[39] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[40] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[41] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[42] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[43] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[44] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[45] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[46] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[47] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[48] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[49] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[50] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[51] &lt;&lt; 13;
-			sr = sr &gt;&gt; 4;
-			*c = sr &gt;&gt; 8;
-			s-&gt;frame_chain = *c;
-		}
-		else {
-			uword sr;
-
-			sr = 0;
-			sr = sr &gt;&gt; 4 | s-&gt;frame_chain &lt;&lt; 12;
-			sr = sr &gt;&gt; 6 | LARc[0] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 6 | LARc[1] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 5 | LARc[2] &lt;&lt; 11;
-			sr = sr &gt;&gt; 5 | LARc[3] &lt;&lt; 11;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 4 | LARc[4] &lt;&lt; 12;
-			sr = sr &gt;&gt; 4 | LARc[5] &lt;&lt; 12;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | LARc[6] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | LARc[7] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 7 | Nc[0] &lt;&lt; 9;
-			sr = sr &gt;&gt; 2 | bc[0] &lt;&lt; 14;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 2 | Mc[0] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[0] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[0] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[1] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[2] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[3] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[4] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[5] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[6] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[7] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[8] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[9] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[10] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[11] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[12] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 7 | Nc[1] &lt;&lt; 9;
-			sr = sr &gt;&gt; 2 | bc[1] &lt;&lt; 14;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 2 | Mc[1] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[1] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[13] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[14] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[15] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[16] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[17] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[18] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[19] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[20] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[21] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[22] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[23] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[24] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[25] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 7 | Nc[2] &lt;&lt; 9;
-			sr = sr &gt;&gt; 2 | bc[2] &lt;&lt; 14;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 2 | Mc[2] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[2] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[26] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[27] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[28] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[29] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[30] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[31] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[32] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[33] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[34] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[35] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[36] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[37] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[38] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 7 | Nc[3] &lt;&lt; 9;
-			sr = sr &gt;&gt; 2 | bc[3] &lt;&lt; 14;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 2 | Mc[3] &lt;&lt; 14;
-			sr = sr &gt;&gt; 6 | xmaxc[3] &lt;&lt; 10;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[39] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[40] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[41] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[42] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[43] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-			sr = sr &gt;&gt; 3 | xmc[44] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[45] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[46] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 7;
-			sr = sr &gt;&gt; 3 | xmc[47] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[48] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[49] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 6;
-			sr = sr &gt;&gt; 3 | xmc[50] &lt;&lt; 13;
-			sr = sr &gt;&gt; 3 | xmc[51] &lt;&lt; 13;
-			*c++ = sr &gt;&gt; 8;
-		}
-	}
-
-	else
-
-#endif	/* WAV49 */
-	{
-
-		*c++ =   ((GSM_MAGIC &amp; 0xF) &lt;&lt; 4)		/* 1 */
-		       | ((LARc[0] &gt;&gt; 2) &amp; 0xF);
-		*c++ =   ((LARc[0] &amp; 0x3) &lt;&lt; 6)
-		       | (LARc[1] &amp; 0x3F);
-		*c++ =   ((LARc[2] &amp; 0x1F) &lt;&lt; 3)
-		       | ((LARc[3] &gt;&gt; 2) &amp; 0x7);
-		*c++ =   ((LARc[3] &amp; 0x3) &lt;&lt; 6)
-		       | ((LARc[4] &amp; 0xF) &lt;&lt; 2)
-		       | ((LARc[5] &gt;&gt; 2) &amp; 0x3);
-		*c++ =   ((LARc[5] &amp; 0x3) &lt;&lt; 6)
-		       | ((LARc[6] &amp; 0x7) &lt;&lt; 3)
-		       | (LARc[7] &amp; 0x7);
-		*c++ =   ((Nc[0] &amp; 0x7F) &lt;&lt; 1)
-		       | ((bc[0] &gt;&gt; 1) &amp; 0x1);
-		*c++ =   ((bc[0] &amp; 0x1) &lt;&lt; 7)
-		       | ((Mc[0] &amp; 0x3) &lt;&lt; 5)
-		       | ((xmaxc[0] &gt;&gt; 1) &amp; 0x1F);
-		*c++ =   ((xmaxc[0] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[0] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[1] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[2] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[2] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[3] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[4] &amp; 0x7);
-		*c++ =   ((xmc[5] &amp; 0x7) &lt;&lt; 5)			/* 10 */
-		       | ((xmc[6] &amp; 0x7) &lt;&lt; 2)
-		       | ((xmc[7] &gt;&gt; 1) &amp; 0x3);
-		*c++ =   ((xmc[7] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[8] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[9] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[10] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[10] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[11] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[12] &amp; 0x7);
-		*c++ =   ((Nc[1] &amp; 0x7F) &lt;&lt; 1)
-		       | ((bc[1] &gt;&gt; 1) &amp; 0x1);
-		*c++ =   ((bc[1] &amp; 0x1) &lt;&lt; 7)
-		       | ((Mc[1] &amp; 0x3) &lt;&lt; 5)
-		       | ((xmaxc[1] &gt;&gt; 1) &amp; 0x1F);
-		*c++ =   ((xmaxc[1] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[13] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[14] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[15] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[15] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[16] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[17] &amp; 0x7);
-		*c++ =   ((xmc[18] &amp; 0x7) &lt;&lt; 5)
-		       | ((xmc[19] &amp; 0x7) &lt;&lt; 2)
-		       | ((xmc[20] &gt;&gt; 1) &amp; 0x3);
-		*c++ =   ((xmc[20] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[21] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[22] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[23] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[23] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[24] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[25] &amp; 0x7);
-		*c++ =   ((Nc[2] &amp; 0x7F) &lt;&lt; 1)			/* 20 */
-		       | ((bc[2] &gt;&gt; 1) &amp; 0x1);
-		*c++ =   ((bc[2] &amp; 0x1) &lt;&lt; 7)
-		       | ((Mc[2] &amp; 0x3) &lt;&lt; 5)
-		       | ((xmaxc[2] &gt;&gt; 1) &amp; 0x1F);
-		*c++ =   ((xmaxc[2] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[26] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[27] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[28] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[28] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[29] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[30] &amp; 0x7);
-		*c++ =   ((xmc[31] &amp; 0x7) &lt;&lt; 5)
-		       | ((xmc[32] &amp; 0x7) &lt;&lt; 2)
-		       | ((xmc[33] &gt;&gt; 1) &amp; 0x3);
-		*c++ =   ((xmc[33] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[34] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[35] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[36] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[36] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[37] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[38] &amp; 0x7);
-		*c++ =   ((Nc[3] &amp; 0x7F) &lt;&lt; 1)
-		       | ((bc[3] &gt;&gt; 1) &amp; 0x1);
-		*c++ =   ((bc[3] &amp; 0x1) &lt;&lt; 7)
-		       | ((Mc[3] &amp; 0x3) &lt;&lt; 5)
-		       | ((xmaxc[3] &gt;&gt; 1) &amp; 0x1F);
-		*c++ =   ((xmaxc[3] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[39] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[40] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[41] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[41] &amp; 0x3) &lt;&lt; 6)			/* 30 */
-		       | ((xmc[42] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[43] &amp; 0x7);
-		*c++ =   ((xmc[44] &amp; 0x7) &lt;&lt; 5)
-		       | ((xmc[45] &amp; 0x7) &lt;&lt; 2)
-		       | ((xmc[46] &gt;&gt; 1) &amp; 0x3);
-		*c++ =   ((xmc[46] &amp; 0x1) &lt;&lt; 7)
-		       | ((xmc[47] &amp; 0x7) &lt;&lt; 4)
-		       | ((xmc[48] &amp; 0x7) &lt;&lt; 1)
-		       | ((xmc[49] &gt;&gt; 2) &amp; 0x1);
-		*c++ =   ((xmc[49] &amp; 0x3) &lt;&lt; 6)
-		       | ((xmc[50] &amp; 0x7) &lt;&lt; 3)
-		       | (xmc[51] &amp; 0x7);
-
-	}
-}

Modified: trunk/codecs/gsm/src/gsm_explode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_explode.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_explode.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -415,420 +415,3 @@
 
 	return 0;
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;private.h&quot;
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-int gsm_explode P3((s, c, target), gsm s, gsm_byte * c, gsm_signal * target)
-{
-#	define	LARc	target
-#	define	Nc	*((gsm_signal (*) [17])(target + 8))
-#	define	bc	*((gsm_signal (*) [17])(target + 9))
-#	define	Mc	*((gsm_signal (*) [17])(target + 10))
-#	define	xmaxc	*((gsm_signal (*) [17])(target + 11))
-
-
-#ifdef WAV49
-	if (s-&gt;wav_fmt) {
-
-		uword sr = 0;
-
-		if (s-&gt;frame_index == 1) {
-
-			sr = *c++;
-			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 5 */
-			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(target + 12)
-			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 10 */
-			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(target + 29 - 13)
-
-			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 15 */
-			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;			/* 20 */
-			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-
-#undef	xmc
-#define	xmc	(target + 46 - 26)
-
-			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 25 */
-			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(target + 63 - 39)
-
-			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 30 */
-			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-
-			s-&gt;frame_chain = sr &amp; 0xf;
-		}
-		else {
-			sr = s-&gt;frame_chain;
-			sr |= (uword)*c++ &lt;&lt; 4;			/* 1 */
-			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr = *c++;
-			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			sr |= (uword)*c++ &lt;&lt; 3;
-			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 5 */
-			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(target + 12)
-			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 10 */
-			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(target + 29 - 13)
-
-			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 15 */
-			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 20 */
-			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(target + 46 - 26)
-			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;	
-			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 25 */
-			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;		
-			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-
-#undef	xmc
-#define	xmc	(target + 63 - 39)
-
-			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 30 */
-			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-		}
-	}
-	else 
-#endif
-	{
-	/* GSM_MAGIC  = (*c &gt;&gt; 4) &amp; 0xF; */
-
-	if (((*c &gt;&gt; 4) &amp; 0x0F) != GSM_MAGIC) return -1;
-
-	LARc[0]  = (*c++ &amp; 0xF) &lt;&lt; 2;		/* 1 */
-	LARc[0] |= (*c &gt;&gt; 6) &amp; 0x3;
-	LARc[1]  = *c++ &amp; 0x3F;
-	LARc[2]  = (*c &gt;&gt; 3) &amp; 0x1F;
-	LARc[3]  = (*c++ &amp; 0x7) &lt;&lt; 2;
-	LARc[3] |= (*c &gt;&gt; 6) &amp; 0x3;
-	LARc[4]  = (*c &gt;&gt; 2) &amp; 0xF;
-	LARc[5]  = (*c++ &amp; 0x3) &lt;&lt; 2;
-	LARc[5] |= (*c &gt;&gt; 6) &amp; 0x3;
-	LARc[6]  = (*c &gt;&gt; 3) &amp; 0x7;
-	LARc[7]  = *c++ &amp; 0x7;
-
-	Nc[0]  = (*c &gt;&gt; 1) &amp; 0x7F;
-
-	bc[0]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-	bc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-	Mc[0]  = (*c &gt;&gt; 5) &amp; 0x3;
-
-	xmaxc[0]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-#undef	xmc
-#define	xmc	(target + 12)
-
-	xmc[0]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[1]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[2]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[2] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[3]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[4]  = *c++ &amp; 0x7;
-	xmc[5]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[6]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[7]  = (*c++ &amp; 0x3) &lt;&lt; 1;		/* 10 */
-	xmc[7] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[8]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[9]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[10]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[10] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[11]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[12]  = *c++ &amp; 0x7;
-
-	Nc[1]  = (*c &gt;&gt; 1) &amp; 0x7F;
-
-	bc[1]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-	bc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-	Mc[1]  = (*c &gt;&gt; 5) &amp; 0x3;
-
-	xmaxc[1]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-#undef	xmc
-#define	xmc	(target + 29 - 13)
-
-	xmc[13]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[14]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[15]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[15] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[16]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[17]  = *c++ &amp; 0x7;
-	xmc[18]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[19]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[20]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-	xmc[20] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[21]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[22]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[23]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[23] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[24]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[25]  = *c++ &amp; 0x7;
-
-	Nc[2]  = (*c &gt;&gt; 1) &amp; 0x7F;
-
-	bc[2]  = (*c++ &amp; 0x1) &lt;&lt; 1;		/* 20 */
-	bc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-	Mc[2]  = (*c &gt;&gt; 5) &amp; 0x3;
-
-	xmaxc[2]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-#undef	xmc
-#define	xmc	(target + 46 - 26)
-
-	xmc[26]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[27]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[28]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[28] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[29]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[30]  = *c++ &amp; 0x7;
-	xmc[31]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[32]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[33]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-	xmc[33] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[34]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[35]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[36]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[36] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[37]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[38]  = *c++ &amp; 0x7;
-
-	Nc[3]  = (*c &gt;&gt; 1) &amp; 0x7F;
-
-	bc[3]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-	bc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-	Mc[3]  = (*c &gt;&gt; 5) &amp; 0x3;
-
-	xmaxc[3]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-#undef	xmc
-#define	xmc	(target + 63 - 39)
-
-	xmc[39]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[40]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[41]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[41] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[42]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[43]  = *c++ &amp; 0x7;			/* 30  */
-	xmc[44]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[45]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[46]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-	xmc[46] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[47]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[48]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[49]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[49] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[50]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[51]  = *c &amp; 0x7;			/* 33 */
-	}
-
-	return 0;
-}

Modified: trunk/codecs/gsm/src/gsm_implode.c
===================================================================
--- trunk/codecs/gsm/src/gsm_implode.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_implode.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -513,518 +513,3 @@
 	       | (xmc[51] &amp; 0x7);
 	}
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-void gsm_implode P3((s, source, c), gsm s, gsm_signal * source, gsm_byte * c)
-{
-	/*	variable	size	index
-
-		GSM_MAGIC	4	-
-
-		LARc[0]		6	0
-		LARc[1]		6	1
-		LARc[2]		5	2
-		LARc[3]		5	3
-		LARc[4]		4	4
-		LARc[5]		4	5
-		LARc[6]		3	6
-		LARc[7]		3	7
-
-		Nc[0]		7	8
-		bc[0]		2	9
-		Mc[0]		2	10
-		xmaxc[0]	6	11
-		xmc[0]		3	12
-		xmc[1]		3	13
-		xmc[2]		3	14
-		xmc[3]		3	15
-		xmc[4]		3	16
-		xmc[5]		3	17
-		xmc[6]		3	18
-		xmc[7]		3	19
-		xmc[8]		3	20
-		xmc[9]		3	21
-		xmc[10]		3	22
-		xmc[11]		3	23
-		xmc[12]		3	24
-
-		Nc[1]		7	25
-		bc[1]		2	26
-		Mc[1]		2	27
-		xmaxc[1]	6	28
-		xmc[13]		3	29
-		xmc[14]		3	30
-		xmc[15]		3	31
-		xmc[16]		3	32
-		xmc[17]		3	33
-		xmc[18]		3	34
-		xmc[19]		3	35
-		xmc[20]		3	36
-		xmc[21]		3	37
-		xmc[22]		3	38
-		xmc[23]		3	39
-		xmc[24]		3	40
-		xmc[25]		3	41
-
-		Nc[2]		7	42
-		bc[2]		2	43
-		Mc[2]		2	44
-		xmaxc[2]	6	45
-		xmc[26]		3	46
-		xmc[27]		3	47
-		xmc[28]		3	48
-		xmc[29]		3	49
-		xmc[30]		3	50
-		xmc[31]		3	51
-		xmc[32]		3	52
-		xmc[33]		3	53
-		xmc[34]		3	54
-		xmc[35]		3	55
-		xmc[36]		3	56
-		xmc[37]		3	57
-		xmc[38]		3	58
-
-		Nc[3]		7	59
-		bc[3]		2	60
-		Mc[3]		2	61
-		xmaxc[3]	6	62
-		xmc[39]		3	63
-		xmc[40]		3	64
-		xmc[41]		3	65
-		xmc[42]		3	66
-		xmc[43]		3	67
-		xmc[44]		3	68
-		xmc[45]		3	69
-		xmc[46]		3	70
-		xmc[47]		3	71
-		xmc[48]		3	72
-		xmc[49]		3	73
-		xmc[50]		3	74
-		xmc[51]		3	75
-	*/
-
-	/*	There are 76 parameters per frame.  The first eight are
-	 * 	unique.  The remaining 68 are four identical subframes of
-	 * 	17 parameters each.  gsm_implode converts from a representation
-	 * 	of these parameters as values in one array of signed words
-	 * 	to the &quot;packed&quot; version of a GSM frame.
-	 */
-
-#	define	LARc	source
-#	define	Nc	*((gsm_signal (*) [17])(source + 8))
-#	define	bc	*((gsm_signal (*) [17])(source + 9))
-#	define	Mc	*((gsm_signal (*) [17])(source + 10))
-#	define	xmaxc	*((gsm_signal (*) [17])(source + 11))
-
-#ifdef WAV49
-	if (s-&gt;wav_fmt) {
-
-		uword sr = 0;
-		if (s-&gt;frame_index == 0) {
-
-			sr = *c++;
-			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 5 */
-			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 12)
-			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 10 */
-			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 29 - 13)
-			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 15 */
-			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;			/* 20 */
-			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 46 - 26)
-			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 25 */
-			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 4;
-			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 63 - 39)
-
-			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 30 */
-			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-
-			s-&gt;frame_chain = sr &amp; 0xf;
-		}
-		else {
-			sr = s-&gt;frame_chain;
-			sr |= (uword)*c++ &lt;&lt; 4;			/* 1 */
-			LARc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			LARc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-			sr = *c++;
-			LARc[2] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			sr |= (uword)*c++ &lt;&lt; 3;
-			LARc[3] = sr &amp; 0x1f;  sr &gt;&gt;= 5;
-			LARc[4] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			LARc[5] = sr &amp; 0xf;  sr &gt;&gt;= 4;
-			LARc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			LARc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 5 */
-			Nc[0] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			bc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[0] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[0] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 12)
-			xmc[0] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[1] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[2] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[3] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[4] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[5] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[6] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;			/* 10 */
-			xmc[7] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[8] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[9] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[10] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[11] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[12] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[1] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			bc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[1] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[1] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 29 - 13)
-			xmc[13] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[14] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 15 */
-			xmc[15] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[16] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[17] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[18] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[19] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[20] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[21] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[22] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[23] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[24] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[25] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[2] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 20 */
-			bc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[2] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[2] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 46 - 26)
-			xmc[26] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[27] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;	
-			xmc[28] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[29] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[30] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			xmc[31] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[32] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[33] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[34] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[35] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;			/* 25 */
-			xmc[36] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[37] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[38] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;
-			Nc[3] = sr &amp; 0x7f;  sr &gt;&gt;= 7;
-			sr |= (uword)*c++ &lt;&lt; 1;		
-			bc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			Mc[3] = sr &amp; 0x3;  sr &gt;&gt;= 2;
-			sr |= (uword)*c++ &lt;&lt; 5;
-			xmaxc[3] = sr &amp; 0x3f;  sr &gt;&gt;= 6;
-#undef	xmc
-#define	xmc	(source + 63 - 39)
-
-			xmc[39] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[40] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[41] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[42] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[43] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr = *c++;				/* 30 */
-			xmc[44] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[45] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 2;
-			xmc[46] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[47] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[48] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			sr |= (uword)*c++ &lt;&lt; 1;
-			xmc[49] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[50] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-			xmc[51] = sr &amp; 0x7;  sr &gt;&gt;= 3;
-		}
-	}
-	else
-#endif 
-	{
-
-	*c++ =   ((GSM_MAGIC &amp; 0xF) &lt;&lt; 4)		/* 1 */
-	       | ((LARc[0] &gt;&gt; 2) &amp; 0xF);
-	*c++ =   ((LARc[0] &amp; 0x3) &lt;&lt; 6)
-	       | (LARc[1] &amp; 0x3F);
-	*c++ =   ((LARc[2] &amp; 0x1F) &lt;&lt; 3)
-	       | ((LARc[3] &gt;&gt; 2) &amp; 0x7);
-	*c++ =   ((LARc[3] &amp; 0x3) &lt;&lt; 6)
-	       | ((LARc[4] &amp; 0xF) &lt;&lt; 2)
-	       | ((LARc[5] &gt;&gt; 2) &amp; 0x3);
-	*c++ =   ((LARc[5] &amp; 0x3) &lt;&lt; 6)
-	       | ((LARc[6] &amp; 0x7) &lt;&lt; 3)
-	       | (LARc[7] &amp; 0x7);
-
-
-	*c++ =   ((Nc[0] &amp; 0x7F) &lt;&lt; 1)
-
-
-	       | ((bc[0] &gt;&gt; 1) &amp; 0x1);
-	*c++ =   ((bc[0] &amp; 0x1) &lt;&lt; 7)
-
-
-	       | ((Mc[0] &amp; 0x3) &lt;&lt; 5)
-
-	       | ((xmaxc[0] &gt;&gt; 1) &amp; 0x1F);
-	*c++ =   ((xmaxc[0] &amp; 0x1) &lt;&lt; 7)
-
-#undef xmc
-#define	xmc	(source + 12)
-
-	       | ((xmc[0] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[1] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[2] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[2] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[3] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[4] &amp; 0x7);
-	*c++ =   ((xmc[5] &amp; 0x7) &lt;&lt; 5)			/* 10 */
-	       | ((xmc[6] &amp; 0x7) &lt;&lt; 2)
-	       | ((xmc[7] &gt;&gt; 1) &amp; 0x3);
-	*c++ =   ((xmc[7] &amp; 0x1) &lt;&lt; 7)
-	       | ((xmc[8] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[9] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[10] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[10] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[11] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[12] &amp; 0x7);
-
-
-	*c++ =   ((Nc[1] &amp; 0x7F) &lt;&lt; 1)
-
-
-	       | ((bc[1] &gt;&gt; 1) &amp; 0x1);
-	*c++ =   ((bc[1] &amp; 0x1) &lt;&lt; 7)
-
-
-	       | ((Mc[1] &amp; 0x3) &lt;&lt; 5)
-
-
-	       | ((xmaxc[1] &gt;&gt; 1) &amp; 0x1F);
-	*c++ =   ((xmaxc[1] &amp; 0x1) &lt;&lt; 7)
-
-#undef	xmc
-#define	xmc	(source + 29 - 13)
-
-	       | ((xmc[13] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[14] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[15] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[15] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[16] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[17] &amp; 0x7);
-	*c++ =   ((xmc[18] &amp; 0x7) &lt;&lt; 5)
-	       | ((xmc[19] &amp; 0x7) &lt;&lt; 2)
-	       | ((xmc[20] &gt;&gt; 1) &amp; 0x3);
-	*c++ =   ((xmc[20] &amp; 0x1) &lt;&lt; 7)
-	       | ((xmc[21] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[22] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[23] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[23] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[24] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[25] &amp; 0x7);
-
-
-	*c++ =   ((Nc[2] &amp; 0x7F) &lt;&lt; 1)			/* 20 */
-
-
-	       | ((bc[2] &gt;&gt; 1) &amp; 0x1);
-	*c++ =   ((bc[2] &amp; 0x1) &lt;&lt; 7)
-
-
-	       | ((Mc[2] &amp; 0x3) &lt;&lt; 5)
-
-
-	       | ((xmaxc[2] &gt;&gt; 1) &amp; 0x1F);
-	*c++ =   ((xmaxc[2] &amp; 0x1) &lt;&lt; 7)
-
-#undef	xmc
-#define	xmc	(source + 46 - 26)
-
-	       | ((xmc[26] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[27] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[28] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[28] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[29] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[30] &amp; 0x7);
-	*c++ =   ((xmc[31] &amp; 0x7) &lt;&lt; 5)
-	       | ((xmc[32] &amp; 0x7) &lt;&lt; 2)
-	       | ((xmc[33] &gt;&gt; 1) &amp; 0x3);
-	*c++ =   ((xmc[33] &amp; 0x1) &lt;&lt; 7)
-	       | ((xmc[34] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[35] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[36] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[36] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[37] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[38] &amp; 0x7);
-
-
-	*c++ =   ((Nc[3] &amp; 0x7F) &lt;&lt; 1)
-
-
-	       | ((bc[3] &gt;&gt; 1) &amp; 0x1);
-	*c++ =   ((bc[3] &amp; 0x1) &lt;&lt; 7)
-
-
-	       | ((Mc[3] &amp; 0x3) &lt;&lt; 5)
-
-
-	       | ((xmaxc[3] &gt;&gt; 1) &amp; 0x1F);
-	*c++ =   ((xmaxc[3] &amp; 0x1) &lt;&lt; 7)
-
-#undef	xmc
-#define	xmc	(source + 63 - 39)
-
-	       | ((xmc[39] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[40] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[41] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[41] &amp; 0x3) &lt;&lt; 6)			/* 30 */
-	       | ((xmc[42] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[43] &amp; 0x7);
-	*c++ =   ((xmc[44] &amp; 0x7) &lt;&lt; 5)
-	       | ((xmc[45] &amp; 0x7) &lt;&lt; 2)
-	       | ((xmc[46] &gt;&gt; 1) &amp; 0x3);
-	*c++ =   ((xmc[46] &amp; 0x1) &lt;&lt; 7)
-	       | ((xmc[47] &amp; 0x7) &lt;&lt; 4)
-	       | ((xmc[48] &amp; 0x7) &lt;&lt; 1)
-	       | ((xmc[49] &gt;&gt; 2) &amp; 0x1);
-	*c++ =   ((xmc[49] &amp; 0x3) &lt;&lt; 6)
-	       | ((xmc[50] &amp; 0x7) &lt;&lt; 3)
-	       | (xmc[51] &amp; 0x7);
-	}
-}

Modified: trunk/codecs/gsm/src/gsm_option.c
===================================================================
--- trunk/codecs/gsm/src/gsm_option.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_option.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -67,72 +67,3 @@
 	}
 	return result;
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-int gsm_option P3((r, opt, val), gsm r, int opt, int * val)
-{
-	int 	result = -1;
-
-	switch (opt) {
-	case GSM_OPT_LTP_CUT:
-#ifdef 	LTP_CUT
-		result = r-&gt;ltp_cut;
-		if (val) r-&gt;ltp_cut = *val;
-#endif
-		break;
-
-	case GSM_OPT_VERBOSE:
-#ifndef	NDEBUG
-		result = r-&gt;verbose;
-		if (val) r-&gt;verbose = *val;
-#endif
-		break;
-
-	case GSM_OPT_FAST:
-
-#if	defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
-		result = r-&gt;fast;
-		if (val) r-&gt;fast = !!*val;
-#endif
-		break;
-
-	case GSM_OPT_FRAME_CHAIN:
-
-#ifdef WAV49
-		result = r-&gt;frame_chain;
-		if (val) r-&gt;frame_chain = *val;
-#endif
-		break;
-
-	case GSM_OPT_FRAME_INDEX:
-
-#ifdef WAV49
-		result = r-&gt;frame_index;
-		if (val) r-&gt;frame_index = *val;
-#endif
-		break;
-
-	case GSM_OPT_WAV49:
-
-#ifdef WAV49 
-		result = r-&gt;wav_fmt;
-		if (val) r-&gt;wav_fmt = !!*val;
-#endif
-		break;
-
-	default:
-		break;
-	}
-	return result;
-}

Modified: trunk/codecs/gsm/src/gsm_print.c
===================================================================
--- trunk/codecs/gsm/src/gsm_print.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/gsm_print.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -165,170 +165,3 @@
 
 	return 0;
 }
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include	&lt;stdio.h&gt;
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-int gsm_print P3((f, s, c), FILE * f, gsm s, gsm_byte * c)
-{
-	word  	LARc[8], Nc[4], Mc[4], bc[4], xmaxc[4], xmc[13*4];
-
-	/* GSM_MAGIC  = (*c &gt;&gt; 4) &amp; 0xF; */
-
-	if (((*c &gt;&gt; 4) &amp; 0x0F) != GSM_MAGIC) return -1;
-
-	LARc[0]  = (*c++ &amp; 0xF) &lt;&lt; 2;		/* 1 */
-	LARc[0] |= (*c &gt;&gt; 6) &amp; 0x3;
-	LARc[1]  = *c++ &amp; 0x3F;
-	LARc[2]  = (*c &gt;&gt; 3) &amp; 0x1F;
-	LARc[3]  = (*c++ &amp; 0x7) &lt;&lt; 2;
-	LARc[3] |= (*c &gt;&gt; 6) &amp; 0x3;
-	LARc[4]  = (*c &gt;&gt; 2) &amp; 0xF;
-	LARc[5]  = (*c++ &amp; 0x3) &lt;&lt; 2;
-	LARc[5] |= (*c &gt;&gt; 6) &amp; 0x3;
-	LARc[6]  = (*c &gt;&gt; 3) &amp; 0x7;
-	LARc[7]  = *c++ &amp; 0x7;
-
-
-	Nc[0]  = (*c &gt;&gt; 1) &amp; 0x7F;
-	bc[0]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-	bc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
-	Mc[0]  = (*c &gt;&gt; 5) &amp; 0x3;
-	xmaxc[0]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[0] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[0]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[1]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[2]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[2] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[3]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[4]  = *c++ &amp; 0x7;
-	xmc[5]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[6]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[7]  = (*c++ &amp; 0x3) &lt;&lt; 1;		/* 10 */
-	xmc[7] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[8]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[9]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[10]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[10] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[11]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[12]  = *c++ &amp; 0x7;
-
-	Nc[1]  = (*c &gt;&gt; 1) &amp; 0x7F;
-	bc[1]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-	bc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
-	Mc[1]  = (*c &gt;&gt; 5) &amp; 0x3;
-	xmaxc[1]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[1] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[13]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[14]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[15]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[15] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[16]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[17]  = *c++ &amp; 0x7;
-	xmc[18]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[19]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[20]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-	xmc[20] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[21]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[22]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[23]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[23] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[24]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[25]  = *c++ &amp; 0x7;
-
-
-	Nc[2]  = (*c &gt;&gt; 1) &amp; 0x7F;
-	bc[2]  = (*c++ &amp; 0x1) &lt;&lt; 1;		/* 20 */
-	bc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
-	Mc[2]  = (*c &gt;&gt; 5) &amp; 0x3;
-	xmaxc[2]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[2] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[26]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[27]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[28]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[28] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[29]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[30]  = *c++ &amp; 0x7;
-	xmc[31]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[32]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[33]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-	xmc[33] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[34]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[35]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[36]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[36] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[37]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[38]  = *c++ &amp; 0x7;
-
-	Nc[3]  = (*c &gt;&gt; 1) &amp; 0x7F;
-	bc[3]  = (*c++ &amp; 0x1) &lt;&lt; 1;
-	bc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
-	Mc[3]  = (*c &gt;&gt; 5) &amp; 0x3;
-	xmaxc[3]  = (*c++ &amp; 0x1F) &lt;&lt; 1;
-	xmaxc[3] |= (*c &gt;&gt; 7) &amp; 0x1;
-
-	xmc[39]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[40]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[41]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[41] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[42]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[43]  = *c++ &amp; 0x7;			/* 30  */
-	xmc[44]  = (*c &gt;&gt; 5) &amp; 0x7;
-	xmc[45]  = (*c &gt;&gt; 2) &amp; 0x7;
-	xmc[46]  = (*c++ &amp; 0x3) &lt;&lt; 1;
-	xmc[46] |= (*c &gt;&gt; 7) &amp; 0x1;
-	xmc[47]  = (*c &gt;&gt; 4) &amp; 0x7;
-	xmc[48]  = (*c &gt;&gt; 1) &amp; 0x7;
-	xmc[49]  = (*c++ &amp; 0x1) &lt;&lt; 2;
-	xmc[49] |= (*c &gt;&gt; 6) &amp; 0x3;
-	xmc[50]  = (*c &gt;&gt; 3) &amp; 0x7;
-	xmc[51]  = *c &amp; 0x7;			/* 33 */
-
-	fprintf(f,
-	      &quot;LARc:\t%2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d  %2.2d\n&quot;,
-	       LARc[0],LARc[1],LARc[2],LARc[3],LARc[4],LARc[5],LARc[6],LARc[7]);
-
-	fprintf(f, &quot;#1: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
-		Nc[0], bc[0], Mc[0], xmaxc[0]);
-	fprintf(f,
-&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
-		xmc[0],xmc[1],xmc[2],xmc[3],xmc[4],xmc[5],xmc[6],
-		xmc[7],xmc[8],xmc[9],xmc[10],xmc[11],xmc[12] );
-
-	fprintf(f, &quot;#2: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
-		Nc[1], bc[1], Mc[1], xmaxc[1]);
-	fprintf(f,
-&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
-		xmc[13+0],xmc[13+1],xmc[13+2],xmc[13+3],xmc[13+4],xmc[13+5],
-		xmc[13+6], xmc[13+7],xmc[13+8],xmc[13+9],xmc[13+10],xmc[13+11],
-		xmc[13+12] );
-
-	fprintf(f, &quot;#3: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
-		Nc[2], bc[2], Mc[2], xmaxc[2]);
-	fprintf(f,
-&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
-		xmc[26+0],xmc[26+1],xmc[26+2],xmc[26+3],xmc[26+4],xmc[26+5],
-		xmc[26+6], xmc[26+7],xmc[26+8],xmc[26+9],xmc[26+10],xmc[26+11],
-		xmc[26+12] );
-
-	fprintf(f, &quot;#4: 	Nc %4.4d    bc %d    Mc %d    xmaxc %d\n&quot;,
-		Nc[3], bc[3], Mc[3], xmaxc[3]);
-	fprintf(f,
-&quot;\t%.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d %.2d\n&quot;,
-		xmc[39+0],xmc[39+1],xmc[39+2],xmc[39+3],xmc[39+4],xmc[39+5],
-		xmc[39+6], xmc[39+7],xmc[39+8],xmc[39+9],xmc[39+10],xmc[39+11],
-		xmc[39+12] );
-
-	return 0;
-}

Modified: trunk/codecs/gsm/src/long_term.c
===================================================================
--- trunk/codecs/gsm/src/long_term.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/long_term.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -13,955 +13,6 @@
 
 #include &quot;gsm.h&quot;
 #include &quot;proto.h&quot;
-
-/*
- *  4.2.11 .. 4.2.12 LONG TERM PREDICTOR (LTP) SECTION
- */
-
-
-/*
- * This module computes the LTP gain (bc) and the LTP lag (Nc)
- * for the long term analysis filter.   This is done by calculating a
- * maximum of the cross-correlation function between the current
- * sub-segment short term residual signal d[0..39] (output of
- * the short term analysis filter; for simplification the index
- * of this array begins at 0 and ends at 39 for each sub-segment of the
- * RPE-LTP analysis) and the previous reconstructed short term
- * residual signal dp[ -120 .. -1 ].  A dynamic scaling must be
- * performed to avoid overflow.
- */
-
- /* The next procedure exists in six versions.  First two integer
-  * version (if USE_FLOAT_MUL is not defined); then four floating
-  * point versions, twice with proper scaling (USE_FLOAT_MUL defined),
-  * once without (USE_FLOAT_MUL and FAST defined, and fast run-time
-  * option used).  Every pair has first a Cut version (see the -C
-  * option to toast or the LTP_CUT option to gsm_option()), then the
-  * uncut one.  (For a detailed explanation of why this is altogether
-  * a bad idea, see Henry Spencer and Geoff Collyer, ``#ifdef Considered
-  * Harmful''.)
-  */
-
-#ifndef  USE_FLOAT_MUL
-
-#ifdef	LTP_CUT
-
-static void Cut_Calculation_of_the_LTP_parameters P5((st, d,dp,bc_out,Nc_out),
-
-	struct gsm_state * st,
-
-	register word	* d,		/* [0..39]	IN	*/
-	register word	* dp,		/* [-120..-1]	IN	*/
-	word		* bc_out,	/* 		OUT	*/
-	word		* Nc_out	/* 		OUT	*/
-)
-{
-	register int  	k, lambda;
-	word		Nc, bc;
-	word		wt[40];
-
-	longword	L_result;
-	longword	L_max, L_power;
-	word		R, S, dmax, scal, best_k;
-	word		ltp_cut;
-
-	register word	temp, wt_k;
-
-	/*  Search of the optimum scaling of d[0..39].
-	 */
-	dmax = 0;
-	for (k = 0; k &lt;= 39; k++) {
-		temp = d[k];
-		temp = GSM_ABS( temp );
-		if (temp &gt; dmax) {
-			dmax = temp;
-			best_k = k;
-		}
-	}
-	temp = 0;
-	if (dmax == 0) scal = 0;
-	else {
-		assert(dmax &gt; 0);
-		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
-	}
-	if (temp &gt; 6) scal = 0;
-	else scal = 6 - temp;
-	assert(scal &gt;= 0);
-
-	/* Search for the maximum cross-correlation and coding of the LTP lag
-	 */
-	L_max = 0;
-	Nc    = 40;	/* index for the maximum cross-correlation */
-	wt_k  = SASR(d[best_k], scal);
-
-	for (lambda = 40; lambda &lt;= 120; lambda++) {
-		L_result = (longword)wt_k * dp[best_k - lambda];
-		if (L_result &gt; L_max) {
-			Nc    = lambda;
-			L_max = L_result;
-		}
-	}
-	*Nc_out = Nc;
-	L_max &lt;&lt;= 1;
-
-	/*  Rescaling of L_max
-	 */
-	assert(scal &lt;= 100 &amp;&amp; scal &gt;= -100);
-	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
-
-	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
-
-	/*   Compute the power of the reconstructed short term residual
-	 *   signal dp[..]
-	 */
-	L_power = 0;
-	for (k = 0; k &lt;= 39; k++) {
-
-		register longword L_temp;
-
-		L_temp   = SASR( dp[k - Nc], 3 );
-		L_power += L_temp * L_temp;
-	}
-	L_power &lt;&lt;= 1;	/* from L_MULT */
-
-	/*  Normalization of L_max and L_power
-	 */
-
-	if (L_max &lt;= 0)  {
-		*bc_out = 0;
-		return;
-	}
-	if (L_max &gt;= L_power) {
-		*bc_out = 3;
-		return;
-	}
-
-	temp = gsm_norm( L_power );
-
-	R = SASR( L_max   &lt;&lt; temp, 16 );
-	S = SASR( L_power &lt;&lt; temp, 16 );
-
-	/*  Coding of the LTP gain
-	 */
-
-	/*  Table 4.3a must be used to obtain the level DLB[i] for the
-	 *  quantization of the LTP gain b to get the coded version bc.
-	 */
-	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
-	*bc_out = bc;
-}
-
-#endif 	/* LTP_CUT */
-
-static void Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
-	register word	* d,		/* [0..39]	IN	*/
-	register word	* dp,		/* [-120..-1]	IN	*/
-	word		* bc_out,	/* 		OUT	*/
-	word		* Nc_out	/* 		OUT	*/
-)
-{
-	register int  	k, lambda;
-	word		Nc, bc;
-	word		wt[40];
-
-	longword	L_max, L_power;
-	word		R, S, dmax, scal;
-	register word	temp;
-
-	/*  Search of the optimum scaling of d[0..39].
-	 */
-	dmax = 0;
-
-	for (k = 0; k &lt;= 39; k++) {
-		temp = d[k];
-		temp = GSM_ABS( temp );
-		if (temp &gt; dmax) dmax = temp;
-	}
-
-	temp = 0;
-	if (dmax == 0) scal = 0;
-	else {
-		assert(dmax &gt; 0);
-		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
-	}
-
-	if (temp &gt; 6) scal = 0;
-	else scal = 6 - temp;
-
-	assert(scal &gt;= 0);
-
-	/*  Initialization of a working array wt
-	 */
-
-	for (k = 0; k &lt;= 39; k++) wt[k] = SASR( d[k], scal );
-
-	/* Search for the maximum cross-correlation and coding of the LTP lag
-	 */
-	L_max = 0;
-	Nc    = 40;	/* index for the maximum cross-correlation */
-
-	for (lambda = 40; lambda &lt;= 120; lambda++) {
-
-# undef STEP
-#		define STEP(k) 	(longword)wt[k] * dp[k - lambda]
-
-		register longword L_result;
-
-		L_result  = STEP(0)  ; L_result += STEP(1) ;
-		L_result += STEP(2)  ; L_result += STEP(3) ;
-		L_result += STEP(4)  ; L_result += STEP(5)  ;
-		L_result += STEP(6)  ; L_result += STEP(7)  ;
-		L_result += STEP(8)  ; L_result += STEP(9)  ;
-		L_result += STEP(10) ; L_result += STEP(11) ;
-		L_result += STEP(12) ; L_result += STEP(13) ;
-		L_result += STEP(14) ; L_result += STEP(15) ;
-		L_result += STEP(16) ; L_result += STEP(17) ;
-		L_result += STEP(18) ; L_result += STEP(19) ;
-		L_result += STEP(20) ; L_result += STEP(21) ;
-		L_result += STEP(22) ; L_result += STEP(23) ;
-		L_result += STEP(24) ; L_result += STEP(25) ;
-		L_result += STEP(26) ; L_result += STEP(27) ;
-		L_result += STEP(28) ; L_result += STEP(29) ;
-		L_result += STEP(30) ; L_result += STEP(31) ;
-		L_result += STEP(32) ; L_result += STEP(33) ;
-		L_result += STEP(34) ; L_result += STEP(35) ;
-		L_result += STEP(36) ; L_result += STEP(37) ;
-		L_result += STEP(38) ; L_result += STEP(39) ;
-
-		if (L_result &gt; L_max) {
-
-			Nc    = lambda;
-			L_max = L_result;
-		}
-	}
-
-	*Nc_out = Nc;
-
-	L_max &lt;&lt;= 1;
-
-	/*  Rescaling of L_max
-	 */
-	assert(scal &lt;= 100 &amp;&amp; scal &gt;=  -100);
-	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
-
-	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
-
-	/*   Compute the power of the reconstructed short term residual
-	 *   signal dp[..]
-	 */
-	L_power = 0;
-	for (k = 0; k &lt;= 39; k++) {
-
-		register longword L_temp;
-
-		L_temp   = SASR( dp[k - Nc], 3 );
-		L_power += L_temp * L_temp;
-	}
-	L_power &lt;&lt;= 1;	/* from L_MULT */
-
-	/*  Normalization of L_max and L_power
-	 */
-
-	if (L_max &lt;= 0)  {
-		*bc_out = 0;
-		return;
-	}
-	if (L_max &gt;= L_power) {
-		*bc_out = 3;
-		return;
-	}
-
-	temp = gsm_norm( L_power );
-
-	R = SASR( L_max   &lt;&lt; temp, 16 );
-	S = SASR( L_power &lt;&lt; temp, 16 );
-
-	/*  Coding of the LTP gain
-	 */
-
-	/*  Table 4.3a must be used to obtain the level DLB[i] for the
-	 *  quantization of the LTP gain b to get the coded version bc.
-	 */
-	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
-	*bc_out = bc;
-}
-
-#else	/* USE_FLOAT_MUL */
-
-#ifdef	LTP_CUT
-
-static void Cut_Calculation_of_the_LTP_parameters P5((st, d,dp,bc_out,Nc_out),
-	struct gsm_state * st,		/*              IN 	*/
-	register word	* d,		/* [0..39]	IN	*/
-	register word	* dp,		/* [-120..-1]	IN	*/
-	word		* bc_out,	/* 		OUT	*/
-	word		* Nc_out	/* 		OUT	*/
-)
-{
-	register int  	k, lambda;
-	word		Nc, bc;
-	word		ltp_cut;
-
-	float		wt_float[40];
-	float		dp_float_base[120], * dp_float = dp_float_base + 120;
-
-	longword	L_max, L_power;
-	word		R, S, dmax, scal;
-	register word	temp;
-
-	/*  Search of the optimum scaling of d[0..39].
-	 */
-	dmax = 0;
-
-	for (k = 0; k &lt;= 39; k++) {
-		temp = d[k];
-		temp = GSM_ABS( temp );
-		if (temp &gt; dmax) dmax = temp;
-	}
-
-	temp = 0;
-	if (dmax == 0) scal = 0;
-	else {
-		assert(dmax &gt; 0);
-		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
-	}
-
-	if (temp &gt; 6) scal = 0;
-	else scal = 6 - temp;
-
-	assert(scal &gt;= 0);
-	ltp_cut = (longword)SASR(dmax, scal) * st-&gt;ltp_cut / 100; 
-
-
-	/*  Initialization of a working array wt
-	 */
-
-	for (k = 0; k &lt; 40; k++) {
-		register word w = SASR( d[k], scal );
-		if (w &lt; 0 ? w &gt; -ltp_cut : w &lt; ltp_cut) {
-			wt_float[k] = 0.0;
-		}
-		else {
-			wt_float[k] =  w;
-		}
-	}
-	for (k = -120; k &lt;  0; k++) dp_float[k] =  dp[k];
-
-	/* Search for the maximum cross-correlation and coding of the LTP lag
-	 */
-	L_max = 0;
-	Nc    = 40;	/* index for the maximum cross-correlation */
-
-	for (lambda = 40; lambda &lt;= 120; lambda += 9) {
-
-		/*  Calculate L_result for l = lambda .. lambda + 9.
-		 */
-		register float *lp = dp_float - lambda;
-
-		register float	W;
-		register float	a = lp[-8], b = lp[-7], c = lp[-6],
-				d = lp[-5], e = lp[-4], f = lp[-3],
-				g = lp[-2], h = lp[-1];
-		register float  E; 
-		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
-				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
-
-#		undef STEP
-#		define	STEP(K, a, b, c, d, e, f, g, h) \
-			if ((W = wt_float[K]) != 0.0) {	\
-			E = W * a; S8 += E;		\
-			E = W * b; S7 += E;		\
-			E = W * c; S6 += E;		\
-			E = W * d; S5 += E;		\
-			E = W * e; S4 += E;		\
-			E = W * f; S3 += E;		\
-			E = W * g; S2 += E;		\
-			E = W * h; S1 += E;		\
-			a  = lp[K];			\
-			E = W * a; S0 += E; } else (a = lp[K])
-
-#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
-#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
-#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
-#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
-#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
-#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
-#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
-#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
-
-		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
-		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
-
-		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
-		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
-
-		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
-		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
-
-		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
-		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
-
-		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
-		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
-
-		if (S0 &gt; L_max) { L_max = S0; Nc = lambda;     }
-		if (S1 &gt; L_max) { L_max = S1; Nc = lambda + 1; }
-		if (S2 &gt; L_max) { L_max = S2; Nc = lambda + 2; }
-		if (S3 &gt; L_max) { L_max = S3; Nc = lambda + 3; }
-		if (S4 &gt; L_max) { L_max = S4; Nc = lambda + 4; }
-		if (S5 &gt; L_max) { L_max = S5; Nc = lambda + 5; }
-		if (S6 &gt; L_max) { L_max = S6; Nc = lambda + 6; }
-		if (S7 &gt; L_max) { L_max = S7; Nc = lambda + 7; }
-		if (S8 &gt; L_max) { L_max = S8; Nc = lambda + 8; }
-
-	}
-	*Nc_out = Nc;
-
-	L_max &lt;&lt;= 1;
-
-	/*  Rescaling of L_max
-	 */
-	assert(scal &lt;= 100 &amp;&amp; scal &gt;=  -100);
-	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
-
-	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
-
-	/*   Compute the power of the reconstructed short term residual
-	 *   signal dp[..]
-	 */
-	L_power = 0;
-	for (k = 0; k &lt;= 39; k++) {
-
-		register longword L_temp;
-
-		L_temp   = SASR( dp[k - Nc], 3 );
-		L_power += L_temp * L_temp;
-	}
-	L_power &lt;&lt;= 1;	/* from L_MULT */
-
-	/*  Normalization of L_max and L_power
-	 */
-
-	if (L_max &lt;= 0)  {
-		*bc_out = 0;
-		return;
-	}
-	if (L_max &gt;= L_power) {
-		*bc_out = 3;
-		return;
-	}
-
-	temp = gsm_norm( L_power );
-
-	R = SASR( L_max   &lt;&lt; temp, 16 );
-	S = SASR( L_power &lt;&lt; temp, 16 );
-
-	/*  Coding of the LTP gain
-	 */
-
-	/*  Table 4.3a must be used to obtain the level DLB[i] for the
-	 *  quantization of the LTP gain b to get the coded version bc.
-	 */
-	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
-	*bc_out = bc;
-}
-
-#endif /* LTP_CUT */
-
-static void Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
-	register word	* d,		/* [0..39]	IN	*/
-	register word	* dp,		/* [-120..-1]	IN	*/
-	word		* bc_out,	/* 		OUT	*/
-	word		* Nc_out	/* 		OUT	*/
-)
-{
-	register int  	k, lambda;
-	word		Nc, bc;
-
-	float		wt_float[40];
-	float		dp_float_base[120], * dp_float = dp_float_base + 120;
-
-	longword	L_max, L_power;
-	word		R, S, dmax, scal;
-	register word	temp;
-
-	/*  Search of the optimum scaling of d[0..39].
-	 */
-	dmax = 0;
-
-	for (k = 0; k &lt;= 39; k++) {
-		temp = d[k];
-		temp = GSM_ABS( temp );
-		if (temp &gt; dmax) dmax = temp;
-	}
-
-	temp = 0;
-	if (dmax == 0) scal = 0;
-	else {
-		assert(dmax &gt; 0);
-		temp = gsm_norm( (longword)dmax &lt;&lt; 16 );
-	}
-
-	if (temp &gt; 6) scal = 0;
-	else scal = 6 - temp;
-
-	assert(scal &gt;= 0);
-
-	/*  Initialization of a working array wt
-	 */
-
-	for (k =    0; k &lt; 40; k++) wt_float[k] =  SASR( d[k], scal );
-	for (k = -120; k &lt;  0; k++) dp_float[k] =  dp[k];
-
-	/* Search for the maximum cross-correlation and coding of the LTP lag
-	 */
-	L_max = 0;
-	Nc    = 40;	/* index for the maximum cross-correlation */
-
-	for (lambda = 40; lambda &lt;= 120; lambda += 9) {
-
-		/*  Calculate L_result for l = lambda .. lambda + 9.
-		 */
-		register float *lp = dp_float - lambda;
-
-		register float	W;
-		register float	a = lp[-8], b = lp[-7], c = lp[-6],
-				d = lp[-5], e = lp[-4], f = lp[-3],
-				g = lp[-2], h = lp[-1];
-		register float  E; 
-		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
-				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
-
-#		undef STEP
-#		define	STEP(K, a, b, c, d, e, f, g, h) \
-			W = wt_float[K];		\
-			E = W * a; S8 += E;		\
-			E = W * b; S7 += E;		\
-			E = W * c; S6 += E;		\
-			E = W * d; S5 += E;		\
-			E = W * e; S4 += E;		\
-			E = W * f; S3 += E;		\
-			E = W * g; S2 += E;		\
-			E = W * h; S1 += E;		\
-			a  = lp[K];			\
-			E = W * a; S0 += E
-
-#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
-#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
-#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
-#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
-#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
-#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
-#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
-#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
-
-		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
-		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
-
-		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
-		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
-
-		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
-		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
-
-		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
-		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
-
-		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
-		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
-
-		if (S0 &gt; L_max) { L_max = S0; Nc = lambda;     }
-		if (S1 &gt; L_max) { L_max = S1; Nc = lambda + 1; }
-		if (S2 &gt; L_max) { L_max = S2; Nc = lambda + 2; }
-		if (S3 &gt; L_max) { L_max = S3; Nc = lambda + 3; }
-		if (S4 &gt; L_max) { L_max = S4; Nc = lambda + 4; }
-		if (S5 &gt; L_max) { L_max = S5; Nc = lambda + 5; }
-		if (S6 &gt; L_max) { L_max = S6; Nc = lambda + 6; }
-		if (S7 &gt; L_max) { L_max = S7; Nc = lambda + 7; }
-		if (S8 &gt; L_max) { L_max = S8; Nc = lambda + 8; }
-	}
-	*Nc_out = Nc;
-
-	L_max &lt;&lt;= 1;
-
-	/*  Rescaling of L_max
-	 */
-	assert(scal &lt;= 100 &amp;&amp; scal &gt;=  -100);
-	L_max = L_max &gt;&gt; (6 - scal);	/* sub(6, scal) */
-
-	assert( Nc &lt;= 120 &amp;&amp; Nc &gt;= 40);
-
-	/*   Compute the power of the reconstructed short term residual
-	 *   signal dp[..]
-	 */
-	L_power = 0;
-	for (k = 0; k &lt;= 39; k++) {
-
-		register longword L_temp;
-
-		L_temp   = SASR( dp[k - Nc], 3 );
-		L_power += L_temp * L_temp;
-	}
-	L_power &lt;&lt;= 1;	/* from L_MULT */
-
-	/*  Normalization of L_max and L_power
-	 */
-
-	if (L_max &lt;= 0)  {
-		*bc_out = 0;
-		return;
-	}
-	if (L_max &gt;= L_power) {
-		*bc_out = 3;
-		return;
-	}
-
-	temp = gsm_norm( L_power );
-
-	R = SASR( L_max   &lt;&lt; temp, 16 );
-	S = SASR( L_power &lt;&lt; temp, 16 );
-
-	/*  Coding of the LTP gain
-	 */
-
-	/*  Table 4.3a must be used to obtain the level DLB[i] for the
-	 *  quantization of the LTP gain b to get the coded version bc.
-	 */
-	for (bc = 0; bc &lt;= 2; bc++) if (R &lt;= gsm_mult(S, gsm_DLB[bc])) break;
-	*bc_out = bc;
-}
-
-#ifdef	FAST
-#ifdef	LTP_CUT
-
-static void Cut_Fast_Calculation_of_the_LTP_parameters P5((st,
-							d,dp,bc_out,Nc_out),
-	struct gsm_state * st,		/*              IN	*/
-	register word	* d,		/* [0..39]	IN	*/
-	register word	* dp,		/* [-120..-1]	IN	*/
-	word		* bc_out,	/* 		OUT	*/
-	word		* Nc_out	/* 		OUT	*/
-)
-{
-	register int  	k, lambda;
-	register float	wt_float;
-	word		Nc, bc;
-	word		wt_max, best_k, ltp_cut;
-
-	float		dp_float_base[120], * dp_float = dp_float_base + 120;
-
-	register float	L_result, L_max, L_power;
-
-	wt_max = 0;
-
-	for (k = 0; k &lt; 40; ++k) {
-		if      ( d[k] &gt; wt_max) wt_max =  d[best_k = k];
-		else if (-d[k] &gt; wt_max) wt_max = -d[best_k = k];
-	}
-
-	assert(wt_max &gt;= 0);
-	wt_float = (float)wt_max;
-
-	for (k = -120; k &lt; 0; ++k) dp_float[k] = (float)dp[k];
-
-	/* Search for the maximum cross-correlation and coding of the LTP lag
-	 */
-	L_max = 0;
-	Nc    = 40;	/* index for the maximum cross-correlation */
-
-	for (lambda = 40; lambda &lt;= 120; lambda++) {
-		L_result = wt_float * dp_float[best_k - lambda];
-		if (L_result &gt; L_max) {
-			Nc    = lambda;
-			L_max = L_result;
-		}
-	}
-
-	*Nc_out = Nc;
-	if (L_max &lt;= 0.)  {
-		*bc_out = 0;
-		return;
-	}
-
-	/*  Compute the power of the reconstructed short term residual
-	 *  signal dp[..]
-	 */
-	dp_float -= Nc;
-	L_power = 0;
-	for (k = 0; k &lt; 40; ++k) {
-		register float f = dp_float[k];
-		L_power += f * f;
-	}
-
-	if (L_max &gt;= L_power) {
-		*bc_out = 3;
-		return;
-	}
-
-	/*  Coding of the LTP gain
-	 *  Table 4.3a must be used to obtain the level DLB[i] for the
-	 *  quantization of the LTP gain b to get the coded version bc.
-	 */
-	lambda = L_max / L_power * 32768.;
-	for (bc = 0; bc &lt;= 2; ++bc) if (lambda &lt;= gsm_DLB[bc]) break;
-	*bc_out = bc;
-}
-
-#endif /* LTP_CUT */
-
-static void Fast_Calculation_of_the_LTP_parameters P4((d,dp,bc_out,Nc_out),
-	register word	* d,		/* [0..39]	IN	*/
-	register word	* dp,		/* [-120..-1]	IN	*/
-	word		* bc_out,	/* 		OUT	*/
-	word		* Nc_out	/* 		OUT	*/
-)
-{
-	register int  	k, lambda;
-	word		Nc, bc;
-
-	float		wt_float[40];
-	float		dp_float_base[120], * dp_float = dp_float_base + 120;
-
-	register float	L_max, L_power;
-
-	for (k = 0; k &lt; 40; ++k) wt_float[k] = (float)d[k];
-	for (k = -120; k &lt; 0; ++k) dp_float[k] = (float)dp[k];
-
-	/* Search for the maximum cross-correlation and coding of the LTP lag
-	 */
-	L_max = 0;
-	Nc    = 40;	/* index for the maximum cross-correlation */
-
-	for (lambda = 40; lambda &lt;= 120; lambda += 9) {
-
-		/*  Calculate L_result for l = lambda .. lambda + 9.
-		 */
-		register float *lp = dp_float - lambda;
-
-		register float	W;
-		register float	a = lp[-8], b = lp[-7], c = lp[-6],
-				d = lp[-5], e = lp[-4], f = lp[-3],
-				g = lp[-2], h = lp[-1];
-		register float  E; 
-		register float  S0 = 0, S1 = 0, S2 = 0, S3 = 0, S4 = 0,
-				S5 = 0, S6 = 0, S7 = 0, S8 = 0;
-
-#		undef STEP
-#		define	STEP(K, a, b, c, d, e, f, g, h) \
-			W = wt_float[K];		\
-			E = W * a; S8 += E;		\
-			E = W * b; S7 += E;		\
-			E = W * c; S6 += E;		\
-			E = W * d; S5 += E;		\
-			E = W * e; S4 += E;		\
-			E = W * f; S3 += E;		\
-			E = W * g; S2 += E;		\
-			E = W * h; S1 += E;		\
-			a  = lp[K];			\
-			E = W * a; S0 += E
-
-#		define	STEP_A(K)	STEP(K, a, b, c, d, e, f, g, h)
-#		define	STEP_B(K)	STEP(K, b, c, d, e, f, g, h, a)
-#		define	STEP_C(K)	STEP(K, c, d, e, f, g, h, a, b)
-#		define	STEP_D(K)	STEP(K, d, e, f, g, h, a, b, c)
-#		define	STEP_E(K)	STEP(K, e, f, g, h, a, b, c, d)
-#		define	STEP_F(K)	STEP(K, f, g, h, a, b, c, d, e)
-#		define	STEP_G(K)	STEP(K, g, h, a, b, c, d, e, f)
-#		define	STEP_H(K)	STEP(K, h, a, b, c, d, e, f, g)
-
-		STEP_A( 0); STEP_B( 1); STEP_C( 2); STEP_D( 3);
-		STEP_E( 4); STEP_F( 5); STEP_G( 6); STEP_H( 7);
-
-		STEP_A( 8); STEP_B( 9); STEP_C(10); STEP_D(11);
-		STEP_E(12); STEP_F(13); STEP_G(14); STEP_H(15);
-
-		STEP_A(16); STEP_B(17); STEP_C(18); STEP_D(19);
-		STEP_E(20); STEP_F(21); STEP_G(22); STEP_H(23);
-
-		STEP_A(24); STEP_B(25); STEP_C(26); STEP_D(27);
-		STEP_E(28); STEP_F(29); STEP_G(30); STEP_H(31);
-
-		STEP_A(32); STEP_B(33); STEP_C(34); STEP_D(35);
-		STEP_E(36); STEP_F(37); STEP_G(38); STEP_H(39);
-
-		if (S0 &gt; L_max) { L_max = S0; Nc = lambda;     }
-		if (S1 &gt; L_max) { L_max = S1; Nc = lambda + 1; }
-		if (S2 &gt; L_max) { L_max = S2; Nc = lambda + 2; }
-		if (S3 &gt; L_max) { L_max = S3; Nc = lambda + 3; }
-		if (S4 &gt; L_max) { L_max = S4; Nc = lambda + 4; }
-		if (S5 &gt; L_max) { L_max = S5; Nc = lambda + 5; }
-		if (S6 &gt; L_max) { L_max = S6; Nc = lambda + 6; }
-		if (S7 &gt; L_max) { L_max = S7; Nc = lambda + 7; }
-		if (S8 &gt; L_max) { L_max = S8; Nc = lambda + 8; }
-	}
-	*Nc_out = Nc;
-
-	if (L_max &lt;= 0.)  {
-		*bc_out = 0;
-		return;
-	}
-
-	/*  Compute the power of the reconstructed short term residual
-	 *  signal dp[..]
-	 */
-	dp_float -= Nc;
-	L_power = 0;
-	for (k = 0; k &lt; 40; ++k) {
-		register float f = dp_float[k];
-		L_power += f * f;
-	}
-
-	if (L_max &gt;= L_power) {
-		*bc_out = 3;
-		return;
-	}
-
-	/*  Coding of the LTP gain
-	 *  Table 4.3a must be used to obtain the level DLB[i] for the
-	 *  quantization of the LTP gain b to get the coded version bc.
-	 */
-	lambda = L_max / L_power * 32768.;
-	for (bc = 0; bc &lt;= 2; ++bc) if (lambda &lt;= gsm_DLB[bc]) break;
-	*bc_out = bc;
-}
-
-#endif	/* FAST 	 */
-#endif	/* USE_FLOAT_MUL */
-
-
-/* 4.2.12 */
-
-static void Long_term_analysis_filtering P6((bc,Nc,dp,d,dpp,e),
-	word		bc,	/* 					IN  */
-	word		Nc,	/* 					IN  */
-	register word	* dp,	/* previous d	[-120..-1]		IN  */
-	register word	* d,	/* d		[0..39]			IN  */
-	register word	* dpp,	/* estimate	[0..39]			OUT */
-	register word	* e	/* long term res. signal [0..39]	OUT */
-)
-/*
- *  In this part, we have to decode the bc parameter to compute
- *  the samples of the estimate dpp[0..39].  The decoding of bc needs the
- *  use of table 4.3b.  The long term residual signal e[0..39]
- *  is then calculated to be fed to the RPE encoding section.
- */
-{
-	register int      k;
-	register longword ltmp;
-
-#	undef STEP
-#	define STEP(BP)					\
-	for (k = 0; k &lt;= 39; k++) {			\
-		dpp[k]  = GSM_MULT_R( BP, dp[k - Nc]);	\
-		e[k]	= GSM_SUB( d[k], dpp[k] );	\
-	}
-
-	switch (bc) {
-	case 0:	STEP(  3277 ); break;
-	case 1:	STEP( 11469 ); break;
-	case 2: STEP( 21299 ); break;
-	case 3: STEP( 32767 ); break; 
-	}
-}
-
-void Gsm_Long_Term_Predictor P7((S,d,dp,e,dpp,Nc,bc), 	/* 4x for 160 samples */
-
-	struct gsm_state	* S,
-
-	word	* d,	/* [0..39]   residual signal	IN	*/
-	word	* dp,	/* [-120..-1] d'		IN	*/
-
-	word	* e,	/* [0..39] 			OUT	*/
-	word	* dpp,	/* [0..39] 			OUT	*/
-	word	* Nc,	/* correlation lag		OUT	*/
-	word	* bc	/* gain factor			OUT	*/
-)
-{
-	assert( d  ); assert( dp ); assert( e  );
-	assert( dpp); assert( Nc ); assert( bc );
-
-#if defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
-	if (S-&gt;fast) 
-#if   defined (LTP_CUT)
-		if (S-&gt;ltp_cut)
-			Cut_Fast_Calculation_of_the_LTP_parameters(S,
-				d, dp, bc, Nc);
-		else
-#endif /* LTP_CUT */
-			Fast_Calculation_of_the_LTP_parameters(d, dp, bc, Nc );
-	else 
-#endif /* FAST &amp; USE_FLOAT_MUL */
-#ifdef LTP_CUT
-		if (S-&gt;ltp_cut)
-			Cut_Calculation_of_the_LTP_parameters(S, d, dp, bc, Nc);
-		else
-#endif
-			Calculation_of_the_LTP_parameters(d, dp, bc, Nc);
-
-	Long_term_analysis_filtering( *bc, *Nc, dp, d, dpp, e );
-}
-
-/* 4.3.2 */
-void Gsm_Long_Term_Synthesis_Filtering P5((S,Ncr,bcr,erp,drp),
-	struct gsm_state	* S,
-
-	word			Ncr,
-	word			bcr,
-	register word		* erp,	   /* [0..39]		  	 IN */
-	register word		* drp	   /* [-120..-1] IN, [-120..40] OUT */
-)
-/*
- *  This procedure uses the bcr and Ncr parameter to realize the
- *  long term synthesis filtering.  The decoding of bcr needs
- *  table 4.3b.
- */
-{
-	register longword	ltmp;	/* for ADD */
-	register int 		k;
-	word			brp, drpp, Nr;
-
-	/*  Check the limits of Nr.
-	 */
-	Nr = Ncr &lt; 40 || Ncr &gt; 120 ? S-&gt;nrp : Ncr;
-	S-&gt;nrp = Nr;
-	assert(Nr &gt;= 40 &amp;&amp; Nr &lt;= 120);
-
-	/*  Decoding of the LTP gain bcr
-	 */
-	brp = gsm_QLB[ bcr ];
-
-	/*  Computation of the reconstructed short term residual 
-	 *  signal drp[0..39]
-	 */
-	assert(brp != MIN_WORD);
-
-	for (k = 0; k &lt;= 39; k++) {
-		drpp   = GSM_MULT_R( brp, drp[ k - Nr ] );
-		drp[k] = GSM_ADD( erp[k], drpp );
-	}
-
-	/*
-	 *  Update of the reconstructed short term residual signal
-	 *  drp[ -1..-120 ]
-	 */
-
-	for (k = 0; k &lt;= 119; k++) drp[ -120 + k ] = drp[ -80 + k ];
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 #endif

Modified: trunk/codecs/gsm/src/lpc.c
===================================================================
--- trunk/codecs/gsm/src/lpc.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/lpc.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -14,347 +14,6 @@
 #include &quot;gsm.h&quot;
 #include &quot;proto.h&quot;
 
-#undef	P
-
-/*
- *  4.2.4 .. 4.2.7 LPC ANALYSIS SECTION
- */
-
-/* 4.2.4 */
-
-
-static void Autocorrelation P2((s, L_ACF),
-	word     * s,		/* [0..159]	IN/OUT  */
- 	longword * L_ACF)	/* [0..8]	OUT     */
-/*
- *  The goal is to compute the array L_ACF[k].  The signal s[i] must
- *  be scaled in order to avoid an overflow situation.
- */
-{
-	register int	k, i;
-
-	word		temp, smax, scalauto;
-
-#ifdef	USE_FLOAT_MUL
-	float		float_s[160];
-#endif
-
-	/*  Dynamic scaling of the array  s[0..159]
-	 */
-
-	/*  Search for the maximum.
-	 */
-	smax = 0;
-	for (k = 0; k &lt;= 159; k++) {
-		temp = GSM_ABS( s[k] );
-		if (temp &gt; smax) smax = temp;
-	}
-
-	/*  Computation of the scaling factor.
-	 */
-	if (smax == 0) scalauto = 0;
-	else {
-		assert(smax &gt; 0);
-		scalauto = 4 - gsm_norm( (longword)smax &lt;&lt; 16 );/* sub(4,..) */
-	}
-
-	/*  Scaling of the array s[0...159]
-	 */
-
-	if (scalauto &gt; 0) {
-
-# ifdef USE_FLOAT_MUL
-#   define SCALE(n)	\
-	case n: for (k = 0; k &lt;= 159; k++) \
-			float_s[k] = (float)	\
-				(s[k] = GSM_MULT_R(s[k], 16384 &gt;&gt; (n-1)));\
-		break;
-# else 
-#   define SCALE(n)	\
-	case n: for (k = 0; k &lt;= 159; k++) \
-			s[k] = GSM_MULT_R( s[k], 16384 &gt;&gt; (n-1) );\
-		break;
-# endif /* USE_FLOAT_MUL */
-
-		switch (scalauto) {
-		SCALE(1)
-		SCALE(2)
-		SCALE(3)
-		SCALE(4)
-		}
-# undef	SCALE
-	}
-# ifdef	USE_FLOAT_MUL
-	else for (k = 0; k &lt;= 159; k++) float_s[k] = (float) s[k];
-# endif
-
-	/*  Compute the L_ACF[..].
-	 */
-	{
-# ifdef	USE_FLOAT_MUL
-		register float * sp = float_s;
-		register float   sl = *sp;
-
-#		define STEP(k)	 L_ACF[k] += (longword)(sl * sp[ -(k) ]);
-# else
-		word  * sp = s;
-		word    sl = *sp;
-
-#		define STEP(k)	 L_ACF[k] += ((longword)sl * sp[ -(k) ]);
-# endif
-
-#	define NEXTI	 sl = *++sp
-
-
-	for (k = 9; k--; L_ACF[k] = 0) ;
-
-	STEP (0);
-	NEXTI;
-	STEP(0); STEP(1);
-	NEXTI;
-	STEP(0); STEP(1); STEP(2);
-	NEXTI;
-	STEP(0); STEP(1); STEP(2); STEP(3);
-	NEXTI;
-	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4);
-	NEXTI;
-	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5);
-	NEXTI;
-	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5); STEP(6);
-	NEXTI;
-	STEP(0); STEP(1); STEP(2); STEP(3); STEP(4); STEP(5); STEP(6); STEP(7);
-
-	for (i = 8; i &lt;= 159; i++) {
-
-		NEXTI;
-
-		STEP(0);
-		STEP(1); STEP(2); STEP(3); STEP(4);
-		STEP(5); STEP(6); STEP(7); STEP(8);
-	}
-
-	for (k = 9; k--; L_ACF[k] &lt;&lt;= 1) ; 
-
-	}
-	/*   Rescaling of the array s[0..159]
-	 */
-	if (scalauto &gt; 0) {
-		assert(scalauto &lt;= 4); 
-		for (k = 160; k--; *s++ &lt;&lt;= scalauto) ;
-	}
-}
-
-#if defined(USE_FLOAT_MUL) &amp;&amp; defined(FAST)
-
-static void Fast_Autocorrelation P2((s, L_ACF),
-	word * s,		/* [0..159]	IN/OUT  */
- 	longword * L_ACF)	/* [0..8]	OUT     */
-{
-	register int	k, i;
-	float f_L_ACF[9];
-	float scale;
-
-	float          s_f[160];
-	register float *sf = s_f;
-
-	for (i = 0; i &lt; 160; ++i) sf[i] = s[i];
-	for (k = 0; k &lt;= 8; k++) {
-		register float L_temp2 = 0;
-		register float *sfl = sf - k;
-		for (i = k; i &lt; 160; ++i) L_temp2 += sf[i] * sfl[i];
-		f_L_ACF[k] = L_temp2;
-	}
-	scale = MAX_LONGWORD / f_L_ACF[0];
-
-	for (k = 0; k &lt;= 8; k++) {
-		L_ACF[k] = f_L_ACF[k] * scale;
-	}
-}
-#endif	/* defined (USE_FLOAT_MUL) &amp;&amp; defined (FAST) */
-
-/* 4.2.5 */
-
-static void Reflection_coefficients P2( (L_ACF, r),
-	longword	* L_ACF,		/* 0...8	IN	*/
-	register word	* r			/* 0...7	OUT 	*/
-)
-{
-	register int	i, m, n;
-	register word	temp;
-	register longword ltmp;
-	word		ACF[9];	/* 0..8 */
-	word		P[  9];	/* 0..8 */
-	word		K[  9]; /* 2..8 */
-
-	/*  Schur recursion with 16 bits arithmetic.
-	 */
-
-	if (L_ACF[0] == 0) {
-		for (i = 8; i--; *r++ = 0) ;
-		return;
-	}
-
-	assert( L_ACF[0] != 0 );
-	temp = gsm_norm( L_ACF[0] );
-
-	assert(temp &gt;= 0 &amp;&amp; temp &lt; 32);
-
-	/* ? overflow ? */
-	for (i = 0; i &lt;= 8; i++) ACF[i] = SASR( L_ACF[i] &lt;&lt; temp, 16 );
-
-	/*   Initialize array P[..] and K[..] for the recursion.
-	 */
-
-	for (i = 1; i &lt;= 7; i++) K[ i ] = ACF[ i ];
-	for (i = 0; i &lt;= 8; i++) P[ i ] = ACF[ i ];
-
-	/*   Compute reflection coefficients
-	 */
-	for (n = 1; n &lt;= 8; n++, r++) {
-
-		temp = P[1];
-		temp = GSM_ABS(temp);
-		if (P[0] &lt; temp) {
-			for (i = n; i &lt;= 8; i++) *r++ = 0;
-			return;
-		}
-
-		*r = gsm_div( temp, P[0] );
-
-		assert(*r &gt;= 0);
-		if (P[1] &gt; 0) *r = -*r;		/* r[n] = sub(0, r[n]) */
-		assert (*r != MIN_WORD);
-		if (n == 8) return; 
-
-		/*  Schur recursion
-		 */
-		temp = GSM_MULT_R( P[1], *r );
-		P[0] = GSM_ADD( P[0], temp );
-
-		for (m = 1; m &lt;= 8 - n; m++) {
-			temp     = GSM_MULT_R( K[ m   ],    *r );
-			P[m]     = GSM_ADD(    P[ m+1 ],  temp );
-
-			temp     = GSM_MULT_R( P[ m+1 ],    *r );
-			K[m]     = GSM_ADD(    K[ m   ],  temp );
-		}
-	}
-}
-
-/* 4.2.6 */
-
-static void Transformation_to_Log_Area_Ratios P1((r),
-	register word	* r 			/* 0..7	   IN/OUT */
-)
-/*
- *  The following scaling for r[..] and LAR[..] has been used:
- *
- *  r[..]   = integer( real_r[..]*32768. ); -1 &lt;= real_r &lt; 1.
- *  LAR[..] = integer( real_LAR[..] * 16384 );
- *  with -1.625 &lt;= real_LAR &lt;= 1.625
- */
-{
-	register word	temp;
-	register int	i;
-
-
-	/* Computation of the LAR[0..7] from the r[0..7]
-	 */
-	for (i = 1; i &lt;= 8; i++, r++) {
-
-		temp = *r;
-		temp = GSM_ABS(temp);
-		assert(temp &gt;= 0);
-
-		if (temp &lt; 22118) {
-			temp &gt;&gt;= 1;
-		} else if (temp &lt; 31130) {
-			assert( temp &gt;= 11059 );
-			temp -= 11059;
-		} else {
-			assert( temp &gt;= 26112 );
-			temp -= 26112;
-			temp &lt;&lt;= 2;
-		}
-
-		*r = *r &lt; 0 ? -temp : temp;
-		assert( *r != MIN_WORD );
-	}
-}
-
-/* 4.2.7 */
-
-static void Quantization_and_coding P1((LAR),
-	register word * LAR    	/* [0..7]	IN/OUT	*/
-)
-{
-	register word	temp;
-	longword	ltmp;
-
-
-	/*  This procedure needs four tables; the following equations
-	 *  give the optimum scaling for the constants:
-	 *  
-	 *  A[0..7] = integer( real_A[0..7] * 1024 )
-	 *  B[0..7] = integer( real_B[0..7] *  512 )
-	 *  MAC[0..7] = maximum of the LARc[0..7]
-	 *  MIC[0..7] = minimum of the LARc[0..7]
-	 */
-
-#	undef STEP
-#	define	STEP( A, B, MAC, MIC )		\
-		temp = GSM_MULT( A,   *LAR );	\
-		temp = GSM_ADD(  temp,   B );	\
-		temp = GSM_ADD(  temp, 256 );	\
-		temp = SASR(     temp,   9 );	\
-		*LAR  =  temp&gt;MAC ? MAC - MIC : (temp&lt;MIC ? 0 : temp - MIC); \
-		LAR++;
-
-	STEP(  20480,     0,  31, -32 );
-	STEP(  20480,     0,  31, -32 );
-	STEP(  20480,  2048,  15, -16 );
-	STEP(  20480, -2560,  15, -16 );
-
-	STEP(  13964,    94,   7,  -8 );
-	STEP(  15360, -1792,   7,  -8 );
-	STEP(   8534,  -341,   3,  -4 );
-	STEP(   9036, -1144,   3,  -4 );
-
-#	undef	STEP
-}
-
-void Gsm_LPC_Analysis P3((S, s,LARc),
-	struct gsm_state *S,
-	word 		 * s,		/* 0..159 signals	IN/OUT	*/
-        word 		 * LARc)	/* 0..7   LARc's	OUT	*/
-{
-	longword	L_ACF[9];
-
-#if defined(USE_FLOAT_MUL) &amp;&amp; defined(FAST)
-	if (S-&gt;fast) Fast_Autocorrelation (s,	  L_ACF );
-	else
-#endif
-	Autocorrelation			  (s,	  L_ACF	);
-	Reflection_coefficients		  (L_ACF, LARc	);
-	Transformation_to_Log_Area_Ratios (LARc);
-	Quantization_and_coding		  (LARc);
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 #endif

Modified: trunk/codecs/gsm/src/preprocess.c
===================================================================
--- trunk/codecs/gsm/src/preprocess.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/preprocess.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -36,119 +36,6 @@
 	word		 * s,
 	word 		 * so )		/* [0..159] 	IN/OUT	*/
 {
-
-	word       z1 = S-&gt;z1;
-	longword L_z2 = S-&gt;L_z2;
-	word 	   mp = S-&gt;mp;
-
-	word 	   	s1;
-	longword      L_s2;
-
-	longword      L_temp;
-
-	word		msp, lsp;
-	word		SO;
-
-	longword	ltmp;		/* for   ADD */
-	ulongword	utmp;		/* for L_ADD */
-
-	register int		k = 160;
-
-	while (k--) {
-
-	/*  4.2.1   Downscaling of the input signal
-	 */
-		SO = SASR( *s, 3 ) &lt;&lt; 2;
-		s++;
-
-		assert (SO &gt;= -0x4000);	/* downscaled by     */
-		assert (SO &lt;=  0x3FFC);	/* previous routine. */
-
-
-	/*  4.2.2   Offset compensation
-	 * 
-	 *  This part implements a high-pass filter and requires extended
-	 *  arithmetic precision for the recursive part of this filter.
-	 *  The input of this procedure is the array so[0...159] and the
-	 *  output the array sof[ 0...159 ].
-	 */
-		/*   Compute the non-recursive part
-		 */
-
-		s1 = SO - z1;			/* s1 = gsm_sub( *so, z1 ); */
-		z1 = SO;
-
-		assert(s1 != MIN_WORD);
-
-		/*   Compute the recursive part
-		 */
-		L_s2 = s1;
-		L_s2 &lt;&lt;= 15;
-
-		/*   Execution of a 31 bv 16 bits multiplication
-		 */
-
-		msp = SASR( L_z2, 15 );
-		lsp = L_z2-((longword)msp&lt;&lt;15); /* gsm_L_sub(L_z2,(msp&lt;&lt;15)); */
-
-		L_s2  += GSM_MULT_R( lsp, 32735 );
-		L_temp = (longword)msp * 32735; /* GSM_L_MULT(msp,32735) &gt;&gt; 1;*/
-		L_z2   = GSM_L_ADD( L_temp, L_s2 );
-
-		/*    Compute sof[k] with rounding
-		 */
-		L_temp = GSM_L_ADD( L_z2, 16384 );
-
-	/*   4.2.3  Preemphasis
-	 */
-
-		msp   = GSM_MULT_R( mp, -28180 );
-		mp    = SASR( L_temp, 15 );
-		*so++ = GSM_ADD( mp, msp );
-	}
-
-	S-&gt;z1   = z1;
-	S-&gt;L_z2 = L_z2;
-	S-&gt;mp   = mp;
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include	&lt;stdio.h&gt;
-#include	&lt;assert.h&gt;
-
-#include &quot;private.h&quot;
-
-#include	&quot;gsm.h&quot;
-#include 	&quot;proto.h&quot;
-
-/*	4.2.0 .. 4.2.3	PREPROCESSING SECTION
- *  
- *  	After A-law to linear conversion (or directly from the
- *   	Ato D converter) the following scaling is assumed for
- * 	input to the RPE-LTP algorithm:
- *
- *      in:  0.1.....................12
- *	     S.v.v.v.v.v.v.v.v.v.v.v.v.*.*.*
- *
- *	Where S is the sign bit, v a valid bit, and * a &quot;don't care&quot; bit.
- * 	The original signal is called sop[..]
- *
- *      out:   0.1................... 12 
- *	     S.S.v.v.v.v.v.v.v.v.v.v.v.v.0.0
- */
-
-
-void Gsm_Preprocess P3((S, s, so),
-	struct gsm_state * S,
-	word		 * s,
-	word 		 * so )		/* [0..159] 	IN/OUT	*/
-{
 	word       	z1 = S-&gt;z1;
 	longword 	L_z2 = S-&gt;L_z2;
 	word 	   	mp = S-&gt;mp;

Modified: trunk/codecs/gsm/src/rpe.c
===================================================================
--- trunk/codecs/gsm/src/rpe.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/rpe.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -18,494 +18,6 @@
  */
 
 /* 4.2.13 */
-
-static void Weighting_filter P2((e, x),
-	register word	* e,		/* signal [-5..0.39.44]	IN  */
-	word		* x		/* signal [0..39]	OUT */
-)
-/*
- *  The coefficients of the weighting filter are stored in a table
- *  (see table 4.4).  The following scaling is used:
- *
- *	H[0..10] = integer( real_H[ 0..10] * 8192 ); 
- */
-{
-	/* word			wt[ 50 ]; */
-
-	register longword	L_result;
-	register int		k /* , i */ ;
-
-	/*  Initialization of a temporary working array wt[0...49]
-	 */
-
-	/* for (k =  0; k &lt;=  4; k++) wt[k] = 0;
-	 * for (k =  5; k &lt;= 44; k++) wt[k] = *e++;
-	 * for (k = 45; k &lt;= 49; k++) wt[k] = 0;
-	 *
-	 *  (e[-5..-1] and e[40..44] are allocated by the caller,
-	 *  are initially zero and are not written anywhere.)
-	 */
-	e -= 5;
-
-	/*  Compute the signal x[0..39]
-	 */ 
-	for (k = 0; k &lt;= 39; k++) {
-
-		L_result = 8192 &gt;&gt; 1;
-
-		/* for (i = 0; i &lt;= 10; i++) {
-		 *	L_temp   = GSM_L_MULT( wt[k+i], gsm_H[i] );
-		 *	L_result = GSM_L_ADD( L_result, L_temp );
-		 * }
-		 */
-
-#undef	STEP
-#define	STEP( i, H )	(e[ k + i ] * (longword)H)
-
-		/*  Every one of these multiplications is done twice --
-		 *  but I don't see an elegant way to optimize this. 
-		 *  Do you?
-		 */
-
-#ifdef	STUPID_COMPILER
-		L_result += STEP(	0, 	-134 ) ;
-		L_result += STEP(	1, 	-374 )  ;
-	               /* + STEP(	2, 	0    )  */
-		L_result += STEP(	3, 	2054 ) ;
-		L_result += STEP(	4, 	5741 ) ;
-		L_result += STEP(	5, 	8192 ) ;
-		L_result += STEP(	6, 	5741 ) ;
-		L_result += STEP(	7, 	2054 ) ;
-	 	       /* + STEP(	8, 	0    )  */
-		L_result += STEP(	9, 	-374 ) ;
-		L_result += STEP(	10, 	-134 ) ;
-#else
-		L_result +=
-		  STEP(	0, 	-134 ) 
-		+ STEP(	1, 	-374 ) 
-	     /* + STEP(	2, 	0    )  */
-		+ STEP(	3, 	2054 ) 
-		+ STEP(	4, 	5741 ) 
-		+ STEP(	5, 	8192 ) 
-		+ STEP(	6, 	5741 ) 
-		+ STEP(	7, 	2054 ) 
-	     /* + STEP(	8, 	0    )  */
-		+ STEP(	9, 	-374 ) 
-		+ STEP(10, 	-134 )
-		;
-#endif
-
-		/* L_result = GSM_L_ADD( L_result, L_result ); (* scaling(x2) *)
-		 * L_result = GSM_L_ADD( L_result, L_result ); (* scaling(x4) *)
-		 *
-		 * x[k] = SASR( L_result, 16 );
-		 */
-
-		/* 2 adds vs. &gt;&gt;16 =&gt; 14, minus one shift to compensate for
-		 * those we lost when replacing L_MULT by '*'.
-		 */
-
-		L_result = SASR( L_result, 13 );
-		x[k] =  (  L_result &lt; MIN_WORD ? MIN_WORD
-			: (L_result &gt; MAX_WORD ? MAX_WORD : L_result ));
-	}
-}
-
-/* 4.2.14 */
-
-static void RPE_grid_selection P3((x,xM,Mc_out),
-	word		* x,		/* [0..39]		IN  */ 
-	word		* xM,		/* [0..12]		OUT */
-	word		* Mc_out	/*			OUT */
-)
-/*
- *  The signal x[0..39] is used to select the RPE grid which is
- *  represented by Mc.
- */
-{
-	/* register word	temp1;	*/
-	register int		/* m, */  i;
-	register longword	L_result, L_temp;
-	longword		EM;	/* xxx should be L_EM? */
-	word			Mc;
-
-	longword		L_common_0_3;
-
-	EM = 0;
-	Mc = 0;
-
-	/* for (m = 0; m &lt;= 3; m++) {
-	 *	L_result = 0;
-	 *
-	 *
-	 *	for (i = 0; i &lt;= 12; i++) {
-	 *
-	 *		temp1    = SASR( x[m + 3*i], 2 );
-	 *
-	 *		assert(temp1 != MIN_WORD);
-	 *
-	 *		L_temp   = GSM_L_MULT( temp1, temp1 );
-	 *		L_result = GSM_L_ADD( L_temp, L_result );
-	 *	}
-	 * 
-	 *	if (L_result &gt; EM) {
-	 *		Mc = m;
-	 *		EM = L_result;
-	 *	}
-	 * }
-	 */
-
-#undef	STEP
-#define	STEP( m, i )		L_temp = SASR( x[m + 3 * i], 2 );	\
-				L_result += L_temp * L_temp;
-
-	/* common part of 0 and 3 */
-
-	L_result = 0;
-	STEP( 0, 1 ); STEP( 0, 2 ); STEP( 0, 3 ); STEP( 0, 4 );
-	STEP( 0, 5 ); STEP( 0, 6 ); STEP( 0, 7 ); STEP( 0, 8 );
-	STEP( 0, 9 ); STEP( 0, 10); STEP( 0, 11); STEP( 0, 12);
-	L_common_0_3 = L_result;
-
-	/* i = 0 */
-
-	STEP( 0, 0 );
-	L_result &lt;&lt;= 1;	/* implicit in L_MULT */
-	EM = L_result;
-
-	/* i = 1 */
-
-	L_result = 0;
-	STEP( 1, 0 );
-	STEP( 1, 1 ); STEP( 1, 2 ); STEP( 1, 3 ); STEP( 1, 4 );
-	STEP( 1, 5 ); STEP( 1, 6 ); STEP( 1, 7 ); STEP( 1, 8 );
-	STEP( 1, 9 ); STEP( 1, 10); STEP( 1, 11); STEP( 1, 12);
-	L_result &lt;&lt;= 1;
-	if (L_result &gt; EM) {
-		Mc = 1;
-	 	EM = L_result;
-	}
-
-	/* i = 2 */
-
-	L_result = 0;
-	STEP( 2, 0 );
-	STEP( 2, 1 ); STEP( 2, 2 ); STEP( 2, 3 ); STEP( 2, 4 );
-	STEP( 2, 5 ); STEP( 2, 6 ); STEP( 2, 7 ); STEP( 2, 8 );
-	STEP( 2, 9 ); STEP( 2, 10); STEP( 2, 11); STEP( 2, 12);
-	L_result &lt;&lt;= 1;
-	if (L_result &gt; EM) {
-		Mc = 2;
-	 	EM = L_result;
-	}
-
-	/* i = 3 */
-
-	L_result = L_common_0_3;
-	STEP( 3, 12 );
-	L_result &lt;&lt;= 1;
-	if (L_result &gt; EM) {
-		Mc = 3;
-	 	EM = L_result;
-	}
-
-	/**/
-
-	/*  Down-sampling by a factor 3 to get the selected xM[0..12]
-	 *  RPE sequence.
-	 */
-	for (i = 0; i &lt;= 12; i ++) xM[i] = x[Mc + 3*i];
-	*Mc_out = Mc;
-}
-
-/* 4.12.15 */
-
-static void APCM_quantization_xmaxc_to_exp_mant P3((xmaxc,exp_out,mant_out),
-	word		xmaxc,		/* IN 	*/
-	word		* exp_out,	/* OUT	*/
-	word		* mant_out )	/* OUT  */
-{
-	word	exp, mant;
-
-	/* Compute exponent and mantissa of the decoded version of xmaxc
-	 */
-
-	exp = 0;
-	if (xmaxc &gt; 15) exp = SASR(xmaxc, 3) - 1;
-	mant = xmaxc - (exp &lt;&lt; 3);
-
-	if (mant == 0) {
-		exp  = -4;
-		mant = 7;
-	}
-	else {
-		while (mant &lt;= 7) {
-			mant = mant &lt;&lt; 1 | 1;
-			exp--;
-		}
-		mant -= 8;
-	}
-
-	assert( exp  &gt;= -4 &amp;&amp; exp &lt;= 6 );
-	assert( mant &gt;= 0 &amp;&amp; mant &lt;= 7 );
-
-	*exp_out  = exp;
-	*mant_out = mant;
-}
-
-static void APCM_quantization P5((xM,xMc,mant_out,exp_out,xmaxc_out),
-	word		* xM,		/* [0..12]		IN	*/
-
-	word		* xMc,		/* [0..12]		OUT	*/
-	word		* mant_out,	/* 			OUT	*/
-	word		* exp_out,	/*			OUT	*/
-	word		* xmaxc_out	/*			OUT	*/
-)
-{
-	int	i, itest;
-
-	word	xmax, xmaxc, temp, temp1, temp2;
-	word	exp, mant;
-
-
-	/*  Find the maximum absolute value xmax of xM[0..12].
-	 */
-
-	xmax = 0;
-	for (i = 0; i &lt;= 12; i++) {
-		temp = xM[i];
-		temp = GSM_ABS(temp);
-		if (temp &gt; xmax) xmax = temp;
-	}
-
-	/*  Qantizing and coding of xmax to get xmaxc.
-	 */
-
-	exp   = 0;
-	temp  = SASR( xmax, 9 );
-	itest = 0;
-
-	for (i = 0; i &lt;= 5; i++) {
-
-		itest |= (temp &lt;= 0);
-		temp = SASR( temp, 1 );
-
-		assert(exp &lt;= 5);
-		if (itest == 0) exp++;		/* exp = add (exp, 1) */
-	}
-
-	assert(exp &lt;= 6 &amp;&amp; exp &gt;= 0);
-	temp = exp + 5;
-
-	assert(temp &lt;= 11 &amp;&amp; temp &gt;= 0);
-	xmaxc = gsm_add( SASR(xmax, temp), exp &lt;&lt; 3 );
-
-	/*   Quantizing and coding of the xM[0..12] RPE sequence
-	 *   to get the xMc[0..12]
-	 */
-
-	APCM_quantization_xmaxc_to_exp_mant( xmaxc, &amp;exp, &amp;mant );
-
-	/*  This computation uses the fact that the decoded version of xmaxc
-	 *  can be calculated by using the exponent and the mantissa part of
-	 *  xmaxc (logarithmic table).
-	 *  So, this method avoids any division and uses only a scaling
-	 *  of the RPE samples by a function of the exponent.  A direct 
-	 *  multiplication by the inverse of the mantissa (NRFAC[0..7]
-	 *  found in table 4.5) gives the 3 bit coded version xMc[0..12]
-	 *  of the RPE samples.
-	 */
-
-
-	/* Direct computation of xMc[0..12] using table 4.5
-	 */
-
-	assert( exp &lt;= 4096 &amp;&amp; exp &gt;= -4096);
-	assert( mant &gt;= 0 &amp;&amp; mant &lt;= 7 ); 
-
-	temp1 = 6 - exp;		/* normalization by the exponent */
-	temp2 = gsm_NRFAC[ mant ];  	/* inverse mantissa 		 */
-
-	for (i = 0; i &lt;= 12; i++) {
-
-		assert(temp1 &gt;= 0 &amp;&amp; temp1 &lt; 16);
-
-		temp = xM[i] &lt;&lt; temp1;
-		temp = GSM_MULT( temp, temp2 );
-		temp = SASR(temp, 12);
-		xMc[i] = temp + 4;		/* see note below */
-	}
-
-	/*  NOTE: This equation is used to make all the xMc[i] positive.
-	 */
-
-	*mant_out  = mant;
-	*exp_out   = exp;
-	*xmaxc_out = xmaxc;
-}
-
-/* 4.2.16 */
-
-static void APCM_inverse_quantization P4((xMc,mant,exp,xMp),
-	register word	* xMc,	/* [0..12]			IN 	*/
-	word		mant,
-	word		exp,
-	register word	* xMp)	/* [0..12]			OUT 	*/
-/* 
- *  This part is for decoding the RPE sequence of coded xMc[0..12]
- *  samples to obtain the xMp[0..12] array.  Table 4.6 is used to get
- *  the mantissa of xmaxc (FAC[0..7]).
- */
-{
-	int	i;
-	word	temp, temp1, temp2, temp3;
-	longword	ltmp;
-
-	assert( mant &gt;= 0 &amp;&amp; mant &lt;= 7 ); 
-
-	temp1 = gsm_FAC[ mant ];	/* see 4.2-15 for mant */
-	temp2 = gsm_sub( 6, exp );	/* see 4.2-15 for exp  */
-	temp3 = gsm_asl( 1, gsm_sub( temp2, 1 ));
-
-	for (i = 13; i--;) {
-
-		assert( *xMc &lt;= 7 &amp;&amp; *xMc &gt;= 0 ); 	/* 3 bit unsigned */
-
-		/* temp = gsm_sub( *xMc++ &lt;&lt; 1, 7 ); */
-		temp = (*xMc++ &lt;&lt; 1) - 7;	        /* restore sign   */
-		assert( temp &lt;= 7 &amp;&amp; temp &gt;= -7 ); 	/* 4 bit signed   */
-
-		temp &lt;&lt;= 12;				/* 16 bit signed  */
-		temp = GSM_MULT_R( temp1, temp );
-		temp = GSM_ADD( temp, temp3 );
-		*xMp++ = gsm_asr( temp, temp2 );
-	}
-}
-
-/* 4.2.17 */
-
-static void RPE_grid_positioning P3((Mc,xMp,ep),
-	word		Mc,		/* grid position	IN	*/
-	register word	* xMp,		/* [0..12]		IN	*/
-	register word	* ep		/* [0..39]		OUT	*/
-)
-/*
- *  This procedure computes the reconstructed long term residual signal
- *  ep[0..39] for the LTP analysis filter.  The inputs are the Mc
- *  which is the grid position selection and the xMp[0..12] decoded
- *  RPE samples which are upsampled by a factor of 3 by inserting zero
- *  values.
- */
-{
-	int	i = 13;
-
-	assert(0 &lt;= Mc &amp;&amp; Mc &lt;= 3);
-
-        switch (Mc) {
-                case 3: *ep++ = 0;
-                case 2:  do {
-                                *ep++ = 0;
-                case 1:         *ep++ = 0;
-                case 0:         *ep++ = *xMp++;
-                         } while (--i);
-        }
-        while (++Mc &lt; 4) *ep++ = 0;
-
-	/*
-
-	int i, k;
-	for (k = 0; k &lt;= 39; k++) ep[k] = 0;
-	for (i = 0; i &lt;= 12; i++) {
-		ep[ Mc + (3*i) ] = xMp[i];
-	}
-	*/
-}
-
-/* 4.2.18 */
-
-/*  This procedure adds the reconstructed long term residual signal
- *  ep[0..39] to the estimated signal dpp[0..39] from the long term
- *  analysis filter to compute the reconstructed short term residual
- *  signal dp[-40..-1]; also the reconstructed short term residual
- *  array dp[-120..-41] is updated.
- */
-
-#if 0	/* Has been inlined in code.c */
-void Gsm_Update_of_reconstructed_short_time_residual_signal P3((dpp, ep, dp),
-	word	* dpp,		/* [0...39]	IN	*/
-	word	* ep,		/* [0...39]	IN	*/
-	word	* dp)		/* [-120...-1]  IN/OUT 	*/
-{
-	int 		k;
-
-	for (k = 0; k &lt;= 79; k++) 
-		dp[ -120 + k ] = dp[ -80 + k ];
-
-	for (k = 0; k &lt;= 39; k++)
-		dp[ -40 + k ] = gsm_add( ep[k], dpp[k] );
-}
-#endif	/* Has been inlined in code.c */
-
-void Gsm_RPE_Encoding P5((S,e,xmaxc,Mc,xMc),
-
-	struct gsm_state * S,
-
-	word	* e,		/* -5..-1][0..39][40..44	IN/OUT  */
-	word	* xmaxc,	/* 				OUT */
-	word	* Mc,		/* 			  	OUT */
-	word	* xMc)		/* [0..12]			OUT */
-{
-	word	x[40];
-	word	xM[13], xMp[13];
-	word	mant, exp;
-
-	Weighting_filter(e, x);
-	RPE_grid_selection(x, xM, Mc);
-
-	APCM_quantization(	xM, xMc, &amp;mant, &amp;exp, xmaxc);
-	APCM_inverse_quantization(  xMc,  mant,  exp, xMp);
-
-	RPE_grid_positioning( *Mc, xMp, e );
-
-}
-
-void Gsm_RPE_Decoding P5((S, xmaxcr, Mcr, xMcr, erp),
-	struct gsm_state	* S,
-
-	word 		xmaxcr,
-	word		Mcr,
-	word		* xMcr,  /* [0..12], 3 bits 		IN	*/
-	word		* erp	 /* [0..39]			OUT 	*/
-)
-{
-	word	exp, mant;
-	word	xMp[ 13 ];
-
-	APCM_quantization_xmaxc_to_exp_mant( xmaxcr, &amp;exp, &amp;mant );
-	APCM_inverse_quantization( xMcr, mant, exp, xMp );
-	RPE_grid_positioning( Mcr, xMp, erp );
-
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
-
-/*  4.2.13 .. 4.2.17  RPE ENCODING SECTION
- */
-
-/* 4.2.13 */
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 #else

Modified: trunk/codecs/gsm/src/short_term.c
===================================================================
--- trunk/codecs/gsm/src/short_term.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/short_term.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -13,435 +13,6 @@
 
 #include &quot;gsm.h&quot;
 #include &quot;proto.h&quot;
-
-/*
- *  SHORT TERM ANALYSIS FILTERING SECTION
- */
-
-/* 4.2.8 */
-
-static void Decoding_of_the_coded_Log_Area_Ratios P2((LARc,LARpp),
-	word 	* LARc,		/* coded log area ratio	[0..7] 	IN	*/
-	word	* LARpp)	/* out: decoded ..			*/
-{
-	register word	temp1 /* , temp2 */;
-	register long	ltmp;	/* for GSM_ADD */
-
-	/*  This procedure requires for efficient implementation
-	 *  two tables.
- 	 *
-	 *  INVA[1..8] = integer( (32768 * 8) / real_A[1..8])
-	 *  MIC[1..8]  = minimum value of the LARc[1..8]
-	 */
-
-	/*  Compute the LARpp[1..8]
-	 */
-
-	/* 	for (i = 1; i &lt;= 8; i++, B++, MIC++, INVA++, LARc++, LARpp++) {
-	 *
-	 *		temp1  = GSM_ADD( *LARc, *MIC ) &lt;&lt; 10;
-	 *		temp2  = *B &lt;&lt; 1;
-	 *		temp1  = GSM_SUB( temp1, temp2 );
-	 *
-	 *		assert(*INVA != MIN_WORD);
-	 *
-	 *		temp1  = GSM_MULT_R( *INVA, temp1 );
-	 *		*LARpp = GSM_ADD( temp1, temp1 );
-	 *	}
-	 */
-
-#undef	STEP
-#define	STEP( B, MIC, INVA )	\
-		temp1    = GSM_ADD( *LARc++, MIC ) &lt;&lt; 10;	\
-		temp1    = GSM_SUB( temp1, B &lt;&lt; 1 );		\
-		temp1    = GSM_MULT_R( INVA, temp1 );		\
-		*LARpp++ = GSM_ADD( temp1, temp1 );
-
-	STEP(      0,  -32,  13107 );
-	STEP(      0,  -32,  13107 );
-	STEP(   2048,  -16,  13107 );
-	STEP(  -2560,  -16,  13107 );
-
-	STEP(     94,   -8,  19223 );
-	STEP(  -1792,   -8,  17476 );
-	STEP(   -341,   -4,  31454 );
-	STEP(  -1144,   -4,  29708 );
-
-	/* NOTE: the addition of *MIC is used to restore
-	 * 	 the sign of *LARc.
-	 */
-}
-
-/* 4.2.9 */
-/* Computation of the quantized reflection coefficients 
- */
-
-/* 4.2.9.1  Interpolation of the LARpp[1..8] to get the LARp[1..8]
- */
-
-/*
- *  Within each frame of 160 analyzed speech samples the short term
- *  analysis and synthesis filters operate with four different sets of
- *  coefficients, derived from the previous set of decoded LARs(LARpp(j-1))
- *  and the actual set of decoded LARs (LARpp(j))
- *
- * (Initial value: LARpp(j-1)[1..8] = 0.)
- */
-
-static void Coefficients_0_12 P3((LARpp_j_1, LARpp_j, LARp),
-	register word * LARpp_j_1,
-	register word * LARpp_j,
-	register word * LARp)
-{
-	register int 	i;
-	register longword ltmp;
-
-	for (i = 1; i &lt;= 8; i++, LARp++, LARpp_j_1++, LARpp_j++) {
-		*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));
-		*LARp = GSM_ADD( *LARp,  SASR( *LARpp_j_1, 1));
-	}
-}
-
-static void Coefficients_13_26 P3((LARpp_j_1, LARpp_j, LARp),
-	register word * LARpp_j_1,
-	register word * LARpp_j,
-	register word * LARp)
-{
-	register int i;
-	register longword ltmp;
-	for (i = 1; i &lt;= 8; i++, LARpp_j_1++, LARpp_j++, LARp++) {
-		*LARp = GSM_ADD( SASR( *LARpp_j_1, 1), SASR( *LARpp_j, 1 ));
-	}
-}
-
-static void Coefficients_27_39 P3((LARpp_j_1, LARpp_j, LARp),
-	register word * LARpp_j_1,
-	register word * LARpp_j,
-	register word * LARp)
-{
-	register int i;
-	register longword ltmp;
-
-	for (i = 1; i &lt;= 8; i++, LARpp_j_1++, LARpp_j++, LARp++) {
-		*LARp = GSM_ADD( SASR( *LARpp_j_1, 2 ), SASR( *LARpp_j, 2 ));
-		*LARp = GSM_ADD( *LARp, SASR( *LARpp_j, 1 ));
-	}
-}
-
-
-static void Coefficients_40_159 P2((LARpp_j, LARp),
-	register word * LARpp_j,
-	register word * LARp)
-{
-	register int i;
-
-	for (i = 1; i &lt;= 8; i++, LARp++, LARpp_j++)
-		*LARp = *LARpp_j;
-}
-
-/* 4.2.9.2 */
-
-static void LARp_to_rp P1((LARp),
-	register word * LARp)	/* [0..7] IN/OUT  */
-/*
- *  The input of this procedure is the interpolated LARp[0..7] array.
- *  The reflection coefficients, rp[i], are used in the analysis
- *  filter and in the synthesis filter.
- */
-{
-	register int 		i;
-	register word		temp;
-	register longword	ltmp;
-
-	for (i = 1; i &lt;= 8; i++, LARp++) {
-
-		/* temp = GSM_ABS( *LARp );
-	         *
-		 * if (temp &lt; 11059) temp &lt;&lt;= 1;
-		 * else if (temp &lt; 20070) temp += 11059;
-		 * else temp = GSM_ADD( temp &gt;&gt; 2, 26112 );
-		 *
-		 * *LARp = *LARp &lt; 0 ? -temp : temp;
-		 */
-
-		if (*LARp &lt; 0) {
-			temp = *LARp == MIN_WORD ? MAX_WORD : -(*LARp);
-			*LARp = - ((temp &lt; 11059) ? temp &lt;&lt; 1
-				: ((temp &lt; 20070) ? temp + 11059
-				:  GSM_ADD( temp &gt;&gt; 2, 26112 )));
-		} else {
-			temp  = *LARp;
-			*LARp =    (temp &lt; 11059) ? temp &lt;&lt; 1
-				: ((temp &lt; 20070) ? temp + 11059
-				:  GSM_ADD( temp &gt;&gt; 2, 26112 ));
-		}
-	}
-}
-
-
-/* 4.2.10 */
-static void Short_term_analysis_filtering P4((S,rp,k_n,s),
-	struct gsm_state * S,
-	register word	* rp,	/* [0..7]	IN	*/
-	register int 	k_n, 	/*   k_end - k_start	*/
-	register word	* s	/* [0..n-1]	IN/OUT	*/
-)
-/*
- *  This procedure computes the short term residual signal d[..] to be fed
- *  to the RPE-LTP loop from the s[..] signal and from the local rp[..]
- *  array (quantized reflection coefficients).  As the call of this
- *  procedure can be done in many ways (see the interpolation of the LAR
- *  coefficient), it is assumed that the computation begins with index
- *  k_start (for arrays d[..] and s[..]) and stops with index k_end
- *  (k_start and k_end are defined in 4.2.9.1).  This procedure also
- *  needs to keep the array u[0..7] in memory for each call.
- */
-{
-	register word		* u = S-&gt;u;
-	register int		i;
-	register word		di, zzz, ui, sav, rpi;
-	register longword 	ltmp;
-
-	for (; k_n--; s++) {
-
-		di = sav = *s;
-
-		for (i = 0; i &lt; 8; i++) {		/* YYY */
-
-			ui    = u[i];
-			rpi   = rp[i];
-			u[i]  = sav;
-
-			zzz   = GSM_MULT_R(rpi, di);
-			sav   = GSM_ADD(   ui,  zzz);
-
-			zzz   = GSM_MULT_R(rpi, ui);
-			di    = GSM_ADD(   di,  zzz );
-		}
-
-		*s = di;
-	}
-}
-
-#if defined(USE_FLOAT_MUL) &amp;&amp; defined(FAST)
-
-static void Fast_Short_term_analysis_filtering P4((S,rp,k_n,s),
-	struct gsm_state * S,
-	register word	* rp,	/* [0..7]	IN	*/
-	register int 	k_n, 	/*   k_end - k_start	*/
-	register word	* s	/* [0..n-1]	IN/OUT	*/
-)
-{
-	register word		* u = S-&gt;u;
-	register int		i;
-
-	float 	  uf[8],
-		 rpf[8];
-
-	register float scalef = 3.0517578125e-5;
-	register float		sav, di, temp;
-
-	for (i = 0; i &lt; 8; ++i) {
-		uf[i]  = u[i];
-		rpf[i] = rp[i] * scalef;
-	}
-	for (; k_n--; s++) {
-		sav = di = *s;
-		for (i = 0; i &lt; 8; ++i) {
-			register float rpfi = rpf[i];
-			register float ufi  = uf[i];
-
-			uf[i] = sav;
-			temp  = rpfi * di + ufi;
-			di   += rpfi * ufi;
-			sav   = temp;
-		}
-		*s = di;
-	}
-	for (i = 0; i &lt; 8; ++i) u[i] = uf[i];
-}
-#endif /* ! (defined (USE_FLOAT_MUL) &amp;&amp; defined (FAST)) */
-
-static void Short_term_synthesis_filtering P5((S,rrp,k,wt,sr),
-	struct gsm_state * S,
-	register word	* rrp,	/* [0..7]	IN	*/
-	register int	k,	/* k_end - k_start	*/
-	register word	* wt,	/* [0..k-1]	IN	*/
-	register word	* sr	/* [0..k-1]	OUT	*/
-)
-{
-	register word		* v = S-&gt;v;
-	register int		i;
-	register word		sri, tmp1, tmp2;
-	register longword	ltmp;	/* for GSM_ADD  &amp; GSM_SUB */
-
-	while (k--) {
-		sri = *wt++;
-		for (i = 8; i--;) {
-
-			/* sri = GSM_SUB( sri, gsm_mult_r( rrp[i], v[i] ) );
-			 */
-			tmp1 = rrp[i];
-			tmp2 = v[i];
-			tmp2 =  ( tmp1 == MIN_WORD &amp;&amp; tmp2 == MIN_WORD
-				? MAX_WORD
-				: 0x0FFFF &amp; (( (longword)tmp1 * (longword)tmp2
-					     + 16384) &gt;&gt; 15)) ;
-
-			sri  = GSM_SUB( sri, tmp2 );
-
-			/* v[i+1] = GSM_ADD( v[i], gsm_mult_r( rrp[i], sri ) );
-			 */
-			tmp1  = ( tmp1 == MIN_WORD &amp;&amp; sri == MIN_WORD
-				? MAX_WORD
-				: 0x0FFFF &amp; (( (longword)tmp1 * (longword)sri
-					     + 16384) &gt;&gt; 15)) ;
-
-			v[i+1] = GSM_ADD( v[i], tmp1);
-		}
-		*sr++ = v[0] = sri;
-	}
-}
-
-
-#if defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
-
-static void Fast_Short_term_synthesis_filtering P5((S,rrp,k,wt,sr),
-	struct gsm_state * S,
-	register word	* rrp,	/* [0..7]	IN	*/
-	register int	k,	/* k_end - k_start	*/
-	register word	* wt,	/* [0..k-1]	IN	*/
-	register word	* sr	/* [0..k-1]	OUT	*/
-)
-{
-	register word		* v = S-&gt;v;
-	register int		i;
-
-	float va[9], rrpa[8];
-	register float scalef = 3.0517578125e-5, temp;
-
-	for (i = 0; i &lt; 8; ++i) {
-		va[i]   = v[i];
-		rrpa[i] = (float)rrp[i] * scalef;
-	}
-	while (k--) {
-		register float sri = *wt++;
-		for (i = 8; i--;) {
-			sri -= rrpa[i] * va[i];
-			if     (sri &lt; -32768.) sri = -32768.;
-			else if (sri &gt; 32767.) sri =  32767.;
-
-			temp = va[i] + rrpa[i] * sri;
-			if     (temp &lt; -32768.) temp = -32768.;
-			else if (temp &gt; 32767.) temp =  32767.;
-			va[i+1] = temp;
-		}
-		*sr++ = va[0] = sri;
-	}
-	for (i = 0; i &lt; 9; ++i) v[i] = va[i];
-}
-
-#endif /* defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL) */
-
-void Gsm_Short_Term_Analysis_Filter P3((S,LARc,s),
-
-	struct gsm_state * S,
-
-	word	* LARc,		/* coded log area ratio [0..7]  IN	*/
-	word	* s		/* signal [0..159]		IN/OUT	*/
-)
-{
-	word		* LARpp_j	= S-&gt;LARpp[ S-&gt;j      ];
-	word		* LARpp_j_1	= S-&gt;LARpp[ S-&gt;j ^= 1 ];
-
-	word		LARp[8];
-
-#undef	FILTER
-#if 	defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
-# 	define	FILTER 	(* (S-&gt;fast			\
-			   ? Fast_Short_term_analysis_filtering	\
-		    	   : Short_term_analysis_filtering	))
-
-#else
-# 	define	FILTER	Short_term_analysis_filtering
-#endif
-
-	Decoding_of_the_coded_Log_Area_Ratios( LARc, LARpp_j );
-
-	Coefficients_0_12(  LARpp_j_1, LARpp_j, LARp );
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 13, s);
-
-	Coefficients_13_26( LARpp_j_1, LARpp_j, LARp);
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 14, s + 13);
-
-	Coefficients_27_39( LARpp_j_1, LARpp_j, LARp);
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 13, s + 27);
-
-	Coefficients_40_159( LARpp_j, LARp);
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 120, s + 40);
-}
-
-void Gsm_Short_Term_Synthesis_Filter P4((S, LARcr, wt, s),
-	struct gsm_state * S,
-
-	word	* LARcr,	/* received log area ratios [0..7] IN  */
-	word	* wt,		/* received d [0..159]		   IN  */
-
-	word	* s		/* signal   s [0..159]		  OUT  */
-)
-{
-	word		* LARpp_j	= S-&gt;LARpp[ S-&gt;j     ];
-	word		* LARpp_j_1	= S-&gt;LARpp[ S-&gt;j ^=1 ];
-
-	word		LARp[8];
-
-#undef	FILTER
-#if 	defined(FAST) &amp;&amp; defined(USE_FLOAT_MUL)
-
-# 	define	FILTER 	(* (S-&gt;fast			\
-			   ? Fast_Short_term_synthesis_filtering	\
-		    	   : Short_term_synthesis_filtering	))
-#else
-#	define	FILTER	Short_term_synthesis_filtering
-#endif
-
-	Decoding_of_the_coded_Log_Area_Ratios( LARcr, LARpp_j );
-
-	Coefficients_0_12( LARpp_j_1, LARpp_j, LARp );
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 13, wt, s );
-
-	Coefficients_13_26( LARpp_j_1, LARpp_j, LARp);
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 14, wt + 13, s + 13 );
-
-	Coefficients_27_39( LARpp_j_1, LARpp_j, LARp);
-	LARp_to_rp( LARp );
-	FILTER( S, LARp, 13, wt + 27, s + 27 );
-
-	Coefficients_40_159( LARpp_j, LARp );
-	LARp_to_rp( LARp );
-	FILTER(S, LARp, 120, wt + 40, s + 40);
-}
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-#include &lt;stdio.h&gt;
-#include &lt;assert.h&gt;
-
-#include &quot;private.h&quot;
-
-#include &quot;gsm.h&quot;
-#include &quot;proto.h&quot;
 #ifdef K6OPT
 #include &quot;k6opt.h&quot;
 

Modified: trunk/codecs/gsm/src/table.c
===================================================================
--- trunk/codecs/gsm/src/table.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm/src/table.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -61,66 +61,3 @@
  */
 /* i                  0      1       2      3      4      5      6      7   */
 word gsm_FAC[8]	= { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };
-/*
- * Copyright 1992 by Jutta Degener and Carsten Bormann, Technische
- * Universitaet Berlin.  See the accompanying file &quot;COPYRIGHT&quot; for
- * details.  THERE IS ABSOLUTELY NO WARRANTY FOR THIS SOFTWARE.
- */
-
-/* $Header$ */
-
-/*  Most of these tables are inlined at their point of use.
- */
-
-/*  4.4 TABLES USED IN THE FIXED POINT IMPLEMENTATION OF THE RPE-LTP
- *      CODER AND DECODER
- *
- *	(Most of them inlined, so watch out.)
- */
-
-#define	GSM_TABLE_C
-#include &quot;private.h&quot;
-#include	&quot;gsm.h&quot;
-
-/*  Table 4.1  Quantization of the Log.-Area Ratios
- */
-/* i 		     1      2      3        4      5      6        7       8 */
-word gsm_A[8]   = {20480, 20480, 20480,  20480,  13964,  15360,   8534,  9036};
-word gsm_B[8]   = {    0,     0,  2048,  -2560,     94,  -1792,   -341, -1144};
-word gsm_MIC[8] = { -32,   -32,   -16,    -16,     -8,     -8,     -4,    -4 };
-word gsm_MAC[8] = {  31,    31,    15,     15,      7,      7,      3,     3 };
-
-
-/*  Table 4.2  Tabulation  of 1/A[1..8]
- */
-word gsm_INVA[8]={ 13107, 13107,  13107, 13107,  19223, 17476,  31454, 29708 };
-
-
-/*   Table 4.3a  Decision level of the LTP gain quantizer
- */
-/*  bc		      0	        1	  2	     3			*/
-word gsm_DLB[4] = {  6554,    16384,	26214,	   32767	};
-
-
-/*   Table 4.3b   Quantization levels of the LTP gain quantizer
- */
-/* bc		      0          1        2          3			*/
-word gsm_QLB[4] = {  3277,    11469,	21299,	   32767	};
-
-
-/*   Table 4.4	 Coefficients of the weighting filter
- */
-/* i		    0      1   2    3   4      5      6     7   8   9    10  */
-word gsm_H[11] = {-134, -374, 0, 2054, 5741, 8192, 5741, 2054, 0, -374, -134 };
-
-
-/*   Table 4.5 	 Normalized inverse mantissa used to compute xM/xmax 
- */
-/* i		 	0        1    2      3      4      5     6      7   */
-word gsm_NRFAC[8] = { 29128, 26215, 23832, 21846, 20165, 18725, 17476, 16384 };
-
-
-/*   Table 4.6	 Normalized direct mantissa used to compute xM/xmax
- */
-/* i                  0      1       2      3      4      5      6      7   */
-word gsm_FAC[8]	= { 18431, 20479, 22527, 24575, 26623, 28671, 30719, 32767 };

Modified: trunk/codecs/gsm_slin_ex.h
===================================================================
--- trunk/codecs/gsm_slin_ex.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/gsm_slin_ex.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,19 +1,3 @@
-/*
-  * 8-bit raw data
-  *
-  * Source: gsm.example
-  *
-  * Copyright (C) 1999, Mark Spencer and Linux Support Services
-  *
-  * Distributed under the terms of the GNU General Public License
-  *
-  */
-
-static unsigned char gsm_slin_ex[] = {
-0xda, 0xa6, 0xac, 0x2d, 0xa3, 0x50, 000, 0x49, 0x24, 0x92, 
-0x49, 0x24, 0x50, 0x40, 0x49, 0x24, 0x92, 0x37, 0x24, 0x52, 
-000, 0x49, 0x24, 0x92, 0x47, 0x24, 0x50, 0x80, 0x46, 0xe3, 
-0x6d, 0xb8, 0xdc };
 /*! \file
   * \brief 8-bit raw data
   *

Modified: trunk/codecs/slin_g723_ex.h
===================================================================
--- trunk/codecs/slin_g723_ex.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/slin_g723_ex.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,39 +1,3 @@
-/*
-  * Signed 16-bit audio data
-  *
-  * Source: g723.example
-  *
-  * Copyright (C) 1999, Mark Spencer and Linux Support Services
-  *
-  * Distributed under the terms of the GNU General Public License
-  *
-  */
-
-static signed short slin_g723_ex[] = {
-0x0873, 0x06d9, 0x038c, 0x0588, 0x0409, 0x033d, 0x0311, 0xff6c, 0xfeef, 0xfd3e, 
-0xfdff, 0xff7a, 0xff6d, 0xffec, 0xff36, 0xfd62, 0xfda7, 0xfc6c, 0xfe67, 0xffe1, 
-0x003d, 0x01cc, 0x0065, 0x002a, 0xff83, 0xfed9, 0xffba, 0xfece, 0xff42, 0xff16, 
-0xfe85, 0xff31, 0xff02, 0xfdff, 0xfe32, 0xfe3f, 0xfed5, 0xff65, 0xffd4, 0x005b, 
-0xff88, 0xff01, 0xfebd, 0xfe95, 0xff46, 0xffe1, 0x00e2, 0x0165, 0x017e, 0x01c9, 
-0x0182, 0x0146, 0x00f9, 0x00ab, 0x006f, 0xffe8, 0xffd8, 0xffc4, 0xffb2, 0xfff9, 
-0xfffe, 0x0023, 0x0018, 0x000b, 0x001a, 0xfff7, 0x0014, 0x000b, 0x0004, 0x000b, 
-0xfff1, 0xff4f, 0xff3f, 0xff42, 0xff5e, 0xffd4, 0x0014, 0x0067, 0x0051, 0x003b, 
-0x0034, 0xfff9, 0x000d, 0xff54, 0xff54, 0xff52, 0xff3f, 0xffcc, 0xffe6, 0x00fc, 
-0x00fa, 0x00e4, 0x00f3, 0x0021, 0x0011, 0xffa1, 0xffab, 0xffdb, 0xffa5, 0x0009, 
-0xffd2, 0xffe6, 0x0007, 0x0096, 0x00e4, 0x00bf, 0x00ce, 0x0048, 0xffe8, 0xffab, 
-0xff8f, 0xffc3, 0xffc1, 0xfffc, 0x0002, 0xfff1, 0x000b, 0x00a7, 0x00c5, 0x00cc, 
-0x015e, 0x00e4, 0x0094, 0x0029, 0xffc7, 0xffc3, 0xff86, 0xffe4, 0xffe6, 0xffec, 
-0x000f, 0xffe3, 0x0028, 0x004b, 0xffaf, 0xffcb, 0xfedd, 0xfef8, 0xfe83, 0xfeba, 
-0xff94, 0xff94, 0xffbe, 0xffa8, 0xff0d, 0xff32, 0xff58, 0x0021, 0x0087, 0x00be, 
-0x0115, 0x007e, 0x0052, 0xfff0, 0xffc9, 0xffe8, 0xffc4, 0x0014, 0xfff0, 0xfff5, 
-0xfffe, 0xffda, 0x000b, 0x0010, 0x006f, 0x006f, 0x0052, 0x0045, 0xffee, 0xffea, 
-0xffcb, 0xffdf, 0xfffc, 0xfff0, 0x0012, 0xfff7, 0xfffe, 0x0018, 0x0050, 0x0066, 
-0x0047, 0x0028, 0xfff7, 0xffe8, 0xffec, 0x0007, 0x001d, 0x0016, 0x00c4, 0x0093, 
-0x007d, 0x0052, 0x00a5, 0x0091, 0x003c, 0x0041, 0xffd1, 0xffda, 0xffc6, 0xfff0, 
-0x001d, 0xfffe, 0x0024, 0xffee, 0xfff3, 0xfff0, 0xffea, 0x0012, 0xfff3, 0xfff7, 
-0xffda, 0xffca, 0xffda, 0xffdf, 0xfff3, 0xfff7, 0xff54, 0xff7c, 0xff8c, 0xffb9, 
-0x0012, 0x0012, 0x004c, 0x0007, 0xff50, 0xff66, 0xff54, 0xffa9, 0xffdc, 0xfff9, 
-0x0038, 0xfff9, 0x00d2, 0x0096, 0x008a, 0x0079, 0xfff5, 0x0019, 0xffad, 0xfffc };
 /*! \file
   * \brief Signed 16-bit audio data
   *

Modified: trunk/codecs/slin_gsm_ex.h
===================================================================
--- trunk/codecs/slin_gsm_ex.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/codecs/slin_gsm_ex.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,31 +1,3 @@
-/*
-  * Signed 16-bit audio data
-  *
-  * Source: gsm.example
-  *
-  * Copyright (C) 1999, Mark Spencer and Linux Support Services
-  *
-  * Distributed under the terms of the GNU General Public License
-  *
-  */
-
-static signed short slin_gsm_ex[] = {
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 0xfff8, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 0x0008, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-0x0008, 000000, 000000, 000000, 0xfff8, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 000000, 
-000000, 000000, 000000, 000000, 000000, 000000, 0x0008, 000000, 000000, 000000 };
 /*! \file
   * \brief Signed 16-bit audio data
   *

Modified: trunk/configs/adtranvofr.conf.sample
===================================================================
--- trunk/configs/adtranvofr.conf.sample	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/configs/adtranvofr.conf.sample	2006-07-05 21:55:19 UTC (rev 423)
@@ -2,43 +2,6 @@
 ; Voice over Frame Relay (Adtran style)
 ;
 ; Configuration file
-;
-[interfaces]
-;
-; Lines for which we are the user termination.  They accept incoming
-; and outgoing calls.
-;
-;user=voice00
-;user=voice01
-;user=voice02
-;user=voice03
-;user=voice04
-;user=voice05
-;user=voice06
-;user=voice07
-context=default
-user=voice13
-user=voice14
-user=voice15
-; Calls on 16 and 17 come from the outside world, so they get
-; a little bit special treatment
-context=remote
-user=voice16
-user=voice17
-;
-; Next we have lines which we only accept calls on, and typically
-; do not send outgoing calls on (i.e. these are where we are the
-; network termination)
-;
-;network=voice08
-;network=voice09
-;network=voice10
-;network=voice11
-;network=voice12
-;
-; Voice over Frame Relay (Adtran style)
-;
-; Configuration file
 
 [interfaces]
 ;

Modified: trunk/configs/extensions.conf.sample
===================================================================
--- trunk/configs/extensions.conf.sample	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/configs/extensions.conf.sample	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,122 +1,4 @@
 ;
-; Static extension configuration files, used by
-; the pbx_config module.
-;
-; The &quot;General&quot; category is for certain variables.  All other categories
-; are interpreted as extension contexts
-;
-[general]
-;
-; If static is set to no, or omitted, then the pbx_config will rewrite
-; this file when extensions are modified.  Remember that all comments
-; made in the file will be lost when that happens.
-;
-static=yes
-
-; Remote things always ring all phones first.
-[remote]
-exten=s,1,Dial,AdtranVoFR/4200&amp;AdtranVoFR/4151&amp;AdtranVoFR/4300|15
-exten=s,2,Goto,default|s|2
-
-; Local stuff
-[local]
-exten=s,1,Goto,defaults|s|2
-; Special extension for local phone numbers, long distance, etc, going
-; out via the Frame Relay interface.  Patterns are prefixed with &quot;_&quot;, which
-; is ignored.
-exten=_9NXXXXXX,1,Dial,AdtranVoFR/BYEXTENSION
-exten=_91NXXNXXXXXX,1,Dial,AdtranVoFR/BYEXTENSION
-exten=_9911,1,Dial,AdtranVoFR/BYEXTENSION
-
-[default]
-exten=s,1,Wait,0
-exten=s,2,Answer
-exten=s,3,DigitTimeout,5
-exten=s,4,ResponseTimeout,10
-exten=s,5,BackGround,welcome
-exten=*,1,Directory,default
-exten=*,2,Goto,s|4
-exten=#,1,Playback,goodbye
-exten=#,2,Hangup
-exten=100,1,Goto,other|s|1
-exten=200,1,Intercom
-exten=400,1,MP3Player,song8.mp3
-exten=401,1,MP3Player,sample.mp3
-exten=402,1,MP3Player,sunscreen.mp3
-exten=403,1,MP3Player,<A HREF="http://trode.vergenet.net:8000">http://trode.vergenet.net:8000</A>
-exten=404,1,MP3Player,<A HREF="http://216.32.166.94:14900">http://216.32.166.94:14900</A>
-exten=405,1,Playback,sample
-;
-; Here's the template for a typical extension, carefully broken apart
-; for analysis.  The others are pretty much the same, but not as well
-; documented.
-;
-; Step 1:  Play back a &quot;Please hold while I try that extension&quot; message
-exten=4300,1,Playback,transfer
-; Step 2:  Dial the numbers where Ben is likely to be.  Try for no more
-;          than 15 seconds.
-exten=4300,2,Dial,AdtranVoFR/4300|15
-; Step 3:  If there is no answer, play back a message stating that Ben is
-;          unavailable.  Alternatively, we could have rung an operator first.
-exten=4300,3,Playback,vm/4300/unavail
-; Step 4:  Send them to voicemail.
-exten=4300,4,Voicemail,4300
-; Step 5:  If they return from voicemail, go back to the top
-exten=4300,5,Goto,s|4
-; Step 103: If the Dialing is busy, it will try here first.  We'll play a
-;           special &quot;I'm busy&quot; message...
-exten=4300,103,Playback,vm/4300/busy
-; Step 104: And then continue as if it had been busy in the first place.
-exten=4300,104,Goto,4
-; Exten. 4301: Provide a short-circuit so we can transfer striaght to 
-;              voicemail.
-exten=4301,1,Goto,4300|3
-; Exten. 4302: Provide a way to ring a given phone indefinitely
-exten=4302,1,Dial,AdtranVoFR/4300
-
-exten=4200,1,Playback,transfer
-exten=4200,2,Dial,AdtranVoFR/4200|15
-exten=4200,3,Playback,vm/4200/unavail
-exten=4200,4,Voicemail,4200
-exten=4200,5,Goto,s|4
-exten=4200,103,Playback,vm/4200/busy
-exten=4200,104,Goto,4
-exten=4201,1,Goto,4200|3
-exten=4202,1,Dial,AdtranVoFR/4200
-
-exten=4230,1,Dial,PhoneJack/ixj0
-
-exten=4110,1,Playback,transfer
-;exten=4110,2,Dial,AdtranVoFR/4110|15
-exten=4110,2,Wait,5
-exten=4110,3,Playback,vm/4110/unavail
-exten=4110,4,Voicemail,4110
-exten=4110,5,Goto,s|4
-exten=4110,103,Playback,vm/4110/busy
-exten=4110,104,Goto,4
-exten=4111,1,Goto,4110|3
-exten=4112,1,Dial,AdtranVoFR/4110
-exten=4113,1,Voicemail,s4110
-
-exten=8500,1,VoicemailMain
-exten=8500,2,Goto,s|4
-exten=762,1,Playback,somepeople
-exten=762,2,Wait,4
-exten=762,3,Goto,s|4
-
-; Timeout stuff...  We could send to an operator, or just ditch them.
-exten=t,1,Goto,#|1
-exten=i,1,BackGround,invalid
-
-[other]
-exten=s,1,Playback,digits/9
-exten=s,2,Playback,digits/8
-exten=s,3,Playback,digits/7
-exten=s,4,Goto,100|1
-exten=100,1,Playback,digits/6
-exten=100,2,Playback,digits/5
-exten=100,3,Goto,default|s|4
-;
 ; Static extension configuration file, used by
 ; the pbx_config module. This is where you configure all your 
 ; inbound and outbound calls in Asterisk. 

Modified: trunk/configs/modules.conf.sample
===================================================================
--- trunk/configs/modules.conf.sample	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/configs/modules.conf.sample	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,21 +3,7 @@
 ;
 ; Module Loader configuration file
 ;
-[modules]
-autoload=yes
-;load=pbx_gtkconsole.so
-noload=pbx_gtkconsole.so
-noload=pbx_kdeconsole.so
-noload=app_intercom.so
-;load=chan_vofr.so
-;load=chan_h323.so 
 
-;
-; Asterisk configuration file
-;
-; Module Loader configuration file
-;
-
 [modules]
 autoload=yes
 ;

Modified: trunk/configs/voicemail.conf.sample
===================================================================
--- trunk/configs/voicemail.conf.sample	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/configs/voicemail.conf.sample	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,22 +1,8 @@
 ;
 ; Voicemail Configuration
 ;
-[general]
-; Default format for writing Voicemail
-; format=g723sf|rawgsm|mp3|wav
-format=g723sf|wav49|wav
 
-[default]
-4200=2345,Mark <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">Spencer,markster at linux-support.net</A>
-4300=2345,Ben <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">Rigas,ben at american-computer.net</A>
-4310=<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">2345,Sales,sales at marko.net</A>
-4069=2345,Matt <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">Brooks,matt at marko.net</A>
-4110=1379,Rob <A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">Flynn,rflynn at blueridge.net</A>
 ;
-; Voicemail Configuration
-;
-
-;
 ; NOTE: Asterisk has to edit this file to change a user's password.  This does
 ; note currently work with the &quot;#include &lt;file&gt;&quot; directive for Asterisk
 ; configuration files.  Do not use it with this configuration file.

Modified: trunk/file.c
===================================================================
--- trunk/file.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/file.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,494 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Generic File Format Support.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/frame.h&gt;
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/sched.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;asterisk/translate.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &quot;asterisk.h&quot;
-
-struct ast_format {
-	/* Name of format */
-	char name[80];
-	/* Extensions (separated by | if more than one) 
-	   this format can read.  First is assumed for writing (e.g. .mp3) */
-	char exts[80];
-	/* Format of frames it uses/provides (one only) */
-	int format;
-	/* Open an input stream, and start playback */
-	struct ast_filestream * (*open)(int fd);
-	/* Open an output stream, of a given file descriptor and comment it appropriately if applicable */
-	struct ast_filestream * (*rewrite)(int fd, char *comment);
-	/* Apply a reading filestream to a channel */
-	int (*apply)(struct ast_channel *, struct ast_filestream *);
-	/* Write a frame to a channel */
-	int (*write)(struct ast_filestream *, struct ast_frame *);
-	/* Read the next frame from the filestream (if available) */
-	struct ast_frame * (*read)(struct ast_filestream *);
-	/* Close file, and destroy filestream structure */
-	void (*close)(struct ast_filestream *);
-	/* Retrieve file comment */
-	char * (*getcomment)(struct ast_filestream *);
-	/* Link */
-	struct ast_format *next;
-};
-
-struct ast_filestream {
-	/* Everybody reserves a block of AST_RESERVED_POINTERS pointers for us */
-	struct ast_format *fmt;
-	/* Transparently translate from another format -- just once */
-	struct ast_trans_pvt *trans;
-	struct ast_tranlator_pvt *tr;
-};
-
-static pthread_mutex_t formatlock = PTHREAD_MUTEX_INITIALIZER;
-
-static struct ast_format *formats = NULL;
-
-int ast_format_register(char *name, char *exts, int format,
-						struct ast_filestream * (*open)(int fd),
-						struct ast_filestream * (*rewrite)(int fd, char *comment),
-						int (*apply)(struct ast_channel *, struct ast_filestream *),
-						int (*write)(struct ast_filestream *, struct ast_frame *),
-						struct ast_frame * (*read)(struct ast_filestream *),
-						void (*close)(struct ast_filestream *),
-						char * (*getcomment)(struct ast_filestream *))
-{
-	struct ast_format *tmp;
-	if (pthread_mutex_lock(&amp;formatlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock format list\n&quot;);
-		return -1;
-	}
-	tmp = formats;
-	while(tmp) {
-		if (!strcasecmp(name, tmp-&gt;name)) {
-			pthread_mutex_unlock(&amp;formatlock);
-			ast_log(LOG_WARNING, &quot;Tried to register '%s' format, already registered\n&quot;, name);
-			return -1;
-		}
-		tmp = tmp-&gt;next;
-	}
-	tmp = malloc(sizeof(struct ast_format));
-	if (!tmp) {
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-		pthread_mutex_unlock(&amp;formatlock);
-		return -1;
-	}
-	strncpy(tmp-&gt;name, name, sizeof(tmp-&gt;name));
-	strncpy(tmp-&gt;exts, exts, sizeof(tmp-&gt;exts));
-	tmp-&gt;open = open;
-	tmp-&gt;rewrite = rewrite;
-	tmp-&gt;apply = apply;
-	tmp-&gt;read = read;
-	tmp-&gt;write = write;
-	tmp-&gt;close = close;
-	tmp-&gt;format = format;
-	tmp-&gt;getcomment = getcomment;
-	tmp-&gt;next = formats;
-	formats = tmp;
-	pthread_mutex_unlock(&amp;formatlock);
-	if (option_verbose &gt; 1)
-		ast_verbose( VERBOSE_PREFIX_2 &quot;Registered file format %s, extension(s) %s\n&quot;, name, exts);
-	return 0;
-}
-
-int ast_format_unregister(char *name)
-{
-	struct ast_format *tmp, *tmpl = NULL;
-	if (pthread_mutex_lock(&amp;formatlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock format list\n&quot;);
-		return -1;
-	}
-	tmp = formats;
-	while(tmp) {
-		if (!strcasecmp(name, tmp-&gt;name)) {
-			if (tmpl) 
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				formats = tmp-&gt;next;
-			free(tmp);
-			pthread_mutex_unlock(&amp;formatlock);
-			if (option_verbose &gt; 1)
-				ast_verbose( VERBOSE_PREFIX_2 &quot;Unregistered format %s\n&quot;, name);
-			return 0;
-		}
-		tmp = tmp-&gt;next;
-	}
-	ast_log(LOG_WARNING, &quot;Tried to unregister format %s, already unregistered\n&quot;, name);
-	return -1;
-}
-
-int ast_stopstream(struct ast_channel *tmp)
-{
-	if (tmp-&gt;trans)
-		tmp = tmp-&gt;trans;
-	/* Stop a running stream if there is one */
-	if (!tmp-&gt;stream) 
-		return 0;
-	tmp-&gt;stream-&gt;fmt-&gt;close(tmp-&gt;stream);
-	if (tmp-&gt;master) {
-		ast_translator_destroy(tmp);
-	}
-	return 0;
-}
-
-int ast_closestream(struct ast_filestream *f)
-{
-	if (f-&gt;trans) {
-		ast_translator_free_path(f-&gt;trans);
-	}
-	/* Stop a running stream if there is one */
-	f-&gt;fmt-&gt;close(f);
-	return 0;
-}
-
-int ast_writestream(struct ast_filestream *fs, struct ast_frame *f)
-{
-	struct ast_frame_chain *fc, *f2;
-	int res = -1;
-	int count=0;
-	if (f-&gt;frametype != AST_FRAME_VOICE) {
-		ast_log(LOG_WARNING, &quot;Tried to write non-voice frame\n&quot;);
-		return -1;
-	}
-	if ((fs-&gt;fmt-&gt;format &amp; f-&gt;subclass) == f-&gt;subclass)
-		return fs-&gt;fmt-&gt;write(fs, f);
-	else {
-		/* XXX If they try to send us a type of frame that isn't the normal frame, and isn't
-		       the one we've setup a translator for, we do the &quot;wrong thing&quot; XXX */
-		if (!fs-&gt;trans) 
-			fs-&gt;trans = ast_translator_build_path(f-&gt;subclass, fs-&gt;fmt-&gt;format);
-		if (!fs-&gt;trans)
-			ast_log(LOG_WARNING, &quot;Unable to translate to format %s, source format %d\n&quot;, fs-&gt;fmt-&gt;name, f-&gt;subclass);
-		else {
-			/* Build a chain of translated frames */
-			fc = ast_translate(fs-&gt;trans, f);
-			f2 = fc;
-			while(f2) {
-				res = fs-&gt;fmt-&gt;write(fs, f2-&gt;fr);
-				if (res) {
-					ast_log(LOG_WARNING, &quot;Frame write failed\n&quot;);
-					break;
-				}
-				f2 = f2-&gt;next;
-				count++;
-				if (count &gt; 1) 
-					ast_log(LOG_DEBUG, &quot;Count is %d\n&quot;, count);
-			}
-			if (fc)
-				ast_frchain(fc);
-		}
-		return res;
-	}
-}
-
-static char *build_filename(char *filename, char *ext)
-{
-	char *fn;
-	fn = malloc(strlen(AST_SOUNDS) + strlen(filename) + strlen(ext) + 10);
-	if (fn) {
-		if (filename[0] == '/') 
-			sprintf(fn, &quot;%s.%s&quot;, filename, ext);
-		else
-			sprintf(fn, &quot;%s/%s.%s&quot;, AST_SOUNDS, filename, ext);
-	}
-	return fn;
-	
-}
-
-#define ACTION_EXISTS 1
-#define ACTION_DELETE 2
-#define ACTION_RENAME 3
-#define ACTION_OPEN   4
-
-static int ast_filehelper(char *filename, char *filename2, char *fmt, int action)
-{
-	struct stat st;
-	struct ast_format *f;
-	struct ast_filestream *s;
-	int res=0, ret = 0;
-	char *ext=NULL, *exts, *fn, *nfn;
-	struct ast_channel *trans = (struct ast_channel *)filename2;
-	
-	/* Start with negative response */
-	if (action == ACTION_EXISTS)
-		res = 0;
-	else
-		res = -1;
-	if (action == ACTION_OPEN)
-		ret = -1;
-	/* Check for a specific format */
-	if (pthread_mutex_lock(&amp;formatlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock format list\n&quot;);
-		if (action == ACTION_EXISTS)
-			return 0;
-		else
-			return -1;
-	}
-	f = formats;
-	while(f) {
-		if (!fmt || !strcasecmp(f-&gt;name, fmt)) {
-			exts = strdup(f-&gt;exts);
-			/* Try each kind of extension */
-			ext = strtok(exts, &quot;|&quot;);
-			do {
-				fn = build_filename(filename, ext);
-				if (fn) {
-					res = stat(fn, &amp;st);
-					if (!res) {
-						switch(action) {
-						case ACTION_EXISTS:
-							ret |= f-&gt;format;
-							break;
-						case ACTION_DELETE:
-							res = unlink(fn);
-							if (res)
-								ast_log(LOG_WARNING, &quot;unlink(%s) failed: %s\n&quot;, fn, strerror(errno));
-							break;
-						case ACTION_RENAME:
-							nfn = build_filename(filename2, ext);
-							if (nfn) {
-								res = rename(fn, nfn);
-								if (res)
-									ast_log(LOG_WARNING, &quot;rename(%s,%s) failed: %s\n&quot;, fn, nfn, strerror(errno));
-								free(nfn);
-							} else
-								ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-							break;
-						case ACTION_OPEN:
-							if ((ret &lt; 0) &amp;&amp; ((trans-&gt;format &amp; f-&gt;format) /* == trans-&gt;format */)) {
-								ret = open(fn, O_RDONLY);
-								if (ret &gt;= 0) {
-									s = f-&gt;open(ret);
-									if (s) {
-										s-&gt;fmt = f;
-										s-&gt;trans = NULL;
-										trans-&gt;stream = s;
-										if (f-&gt;apply(trans, s)) {
-											f-&gt;close(s);
-											trans-&gt;stream = NULL;
-											ast_log(LOG_WARNING, &quot;Unable to apply stream to channel %s\n&quot;, trans-&gt;name);
-											close(ret);
-											ret = 0;
-										}
-									} else {
-										close(ret);
-										ast_log(LOG_WARNING, &quot;Unable to open fd on %s\n&quot;, filename);
-									}
-								} else
-									ast_log(LOG_WARNING, &quot;Couldn't open file %s\n&quot;, fn);
-							}
-							break;
-						default:
-							ast_log(LOG_WARNING, &quot;Unknown helper %d\n&quot;, action);
-						}
-						/* Conveniently this logic is the same for all */
-						if (res)
-							break;
-					}
-					free(fn);
-				}
-				ext = strtok(NULL, &quot;|&quot;);
-			} while(ext);
-			free(exts);
-		}
-		f = f-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;formatlock);
-	if ((action == ACTION_EXISTS) || (action == ACTION_OPEN))
-		res = ret ? ret : -1;
-	return res;
-}
-
-int ast_fileexists(char *filename, char *fmt)
-{
-	return ast_filehelper(filename, NULL, fmt, ACTION_EXISTS);
-}
-
-int ast_filedelete(char *filename, char *fmt)
-{
-	return ast_filehelper(filename, NULL, fmt, ACTION_DELETE);
-}
-
-int ast_filerename(char *filename, char *filename2, char *fmt)
-{
-	return ast_filehelper(filename, filename2, fmt, ACTION_RENAME);
-}
-
-int ast_streamfile(struct ast_channel *chan, char *filename)
-{
-	/* This is a fairly complex routine.  Essentially we should do 
-	   the following:
-	   
-	   1) Find which file handlers produce our type of format.
-	   2) Look for a filename which it can handle.
-	   3) If we find one, then great.  
-	   *4) If not, see what files are there
-	   *5) See what we can actually support
-	   *6) Choose the one with the least costly translator path and
-	       set it up.
-		   
-		XXX * = unimplemented XXX
-	*/
-	int fd = -1;
-	struct ast_channel *trans;
-	int fmts;
-	ast_stopstream(chan);
-	fmts = ast_fileexists(filename, NULL);
-	if (fmts &lt; 1) {
-		ast_log(LOG_WARNING, &quot;File %s does not exist in any format\n&quot;, filename);
-		return -1;
-	}
-	if (fmts &amp; chan-&gt;format) {
-		/* No translation necessary -- we have a file in a format our channel can 
-		   handle */
-		trans = chan;
-	} else {
-		/* Find the best */
-		fmts = ast_translator_best_choice(chan-&gt;format, fmts);
-		if (fmts &lt; 1) {
-			ast_log(LOG_WARNING, &quot;Unable to find a translator method\n&quot;);
-			return -1;
-		}
-		trans = ast_translator_create(chan, fmts, AST_DIRECTION_OUT);
-		if (!trans) {
-			ast_log(LOG_WARNING, &quot;Unable to create translator\n&quot;);
-			return -1;
-		}
-	}
- 	fd = ast_filehelper(filename, (char *)trans, NULL, ACTION_OPEN);
-	if (fd &gt;= 0) {
-#if 0
-		ast_verbose(VERBOSE_PREFIX_3 &quot;Playing '%s'\n&quot;, filename);
-#endif
-		return 0;
-	}
-	ast_log(LOG_WARNING, &quot;Unable to open %s (format %d): %s\n&quot;, filename, chan-&gt;format, strerror(errno));
-	if (chan != trans)
-		ast_translator_destroy(trans);	
-	return -1;
-}
-
-
-struct ast_filestream *ast_writefile(char *filename, char *type, char *comment, int flags, int check, mode_t mode)
-{
-	int fd;
-	struct ast_format *f;
-	struct ast_filestream *fs=NULL;
-	char *fn;
-	char *ext;
-	if (pthread_mutex_lock(&amp;formatlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock format list\n&quot;);
-		return NULL;
-	}
-	f = formats;
-	while(f) {
-		if (!strcasecmp(f-&gt;name, type)) {
-			/* XXX Implement check XXX */
-			ext = strdup(f-&gt;exts);
-			ext = strtok(ext, &quot;|&quot;);
-			fn = build_filename(filename, ext);
-			fd = open(fn, flags | O_WRONLY | O_CREAT, mode);
-			if (fd &gt;= 0) {
-				errno = 0;
-				if ((fs = f-&gt;rewrite(fd, comment))) {
-					fs-&gt;trans = NULL;
-					fs-&gt;fmt = f;
-				} else {
-					ast_log(LOG_WARNING, &quot;Unable to rewrite %s\n&quot;, fn);
-					close(fd);
-					unlink(fn);
-				}
-			} else if (errno != EEXIST)
-				ast_log(LOG_WARNING, &quot;Unable to open file %s: %s\n&quot;, fn, strerror(errno));
-			free(fn);
-			free(ext);
-			break;
-		}
-		f = f-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;formatlock);
-	if (!f) 
-		ast_log(LOG_WARNING, &quot;No such format '%s'\n&quot;, type);
-	return fs;
-}
-
-char ast_waitstream(struct ast_channel *c, char *breakon)
-{
-	int res;
-	struct ast_frame *fr;
-	if (c-&gt;trans)
-		c=c-&gt;trans;
-	while(c-&gt;stream) {
-		res = ast_sched_wait(c-&gt;sched);
-		if (res &lt; 0) {
-			/* Okay, stop :) */
-			return 0;
-		}
-		res = ast_waitfor(c, res);
-		if (res &lt; 0) {
-			ast_log(LOG_WARNING, &quot;Select failed (%s)\n&quot;, strerror(errno));
-			return res;
-		} else
-		if (res &gt; 0) {
-			fr = ast_read(c);
-			if (!fr) {
-#if 0
-				ast_log(LOG_DEBUG, &quot;Got hung up\n&quot;);
-#endif
-				return -1;
-			}
-			
-			switch(fr-&gt;frametype) {
-			case AST_FRAME_DTMF:
-				res = fr-&gt;subclass;
-				ast_frfree(fr);
-				if (strchr(breakon, res))
-					return res;
-				break;
-			case AST_FRAME_CONTROL:
-				switch(fr-&gt;subclass) {
-				case AST_CONTROL_HANGUP:
-					ast_frfree(fr);
-					return -1;
-				default:
-					ast_log(LOG_WARNING, &quot;Unexpected control subclass '%d'\n&quot;, fr-&gt;subclass);
-				}
-			default:
-				/* Ignore */
-				ast_frfree(fr);
-			}
-		} else
-			ast_sched_runq(c-&gt;sched);
-	
-		
-	}
-	return 0;
-}
-
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/formats/Makefile
===================================================================
--- trunk/formats/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/formats/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,41 +3,6 @@
 # 
 # Makefile for file format modules
 #
-# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
-#
-# Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-FORMAT_LIBS=format_g723.so format_wav.so format_mp3.so # format_wav_gsm.so
-
-GSMLIB=../codecs/gsm/lib/libgsm.a
-
-CFLAGS+=
-
-all: $(FORMAT_LIBS)
-
-clean:
-	rm -f *.so *.o
-
-%.so : %.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt;
-
-format_wav.so : format_wav.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt; -laudiofile
-
-format_wav_gsm.so : format_wav_gsm.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt; $(LIBGSM)
-
-install: all
-	for x in $(FORMAT_LIBS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
-# Makefile for file format modules
-#
 # Copyright (C) 1999-2006, Digium, Inc.
 #
 # Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at digium.com</A>&gt;

Modified: trunk/formats/format_g723.c
===================================================================
--- trunk/formats/format_g723.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/formats/format_g723.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,346 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Old-style G.723 frame/timestamp format.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
- 
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/sched.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;arpa/inet.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;string.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;sys/time.h&gt;
-#include &quot;../channels/adtranvofr.h&quot;
-
-
-#define G723_MAX_SIZE 1024
-
-struct ast_filestream {
-	/* First entry MUST be reserved for the channel type */
-	void *reserved[AST_RESERVED_POINTERS];
-	/* This is what a filestream means to us */
-	int fd; /* Descriptor */
-	u_int32_t lasttimeout;	/* Last amount of timeout */
-	struct ast_channel *owner;
-	struct ast_filestream *next;
-	struct ast_frame *fr;	/* Frame representation of buf */
-	struct timeval orig;	/* Original frame time */
-	char buf[G723_MAX_SIZE + AST_FRIENDLY_OFFSET];	/* Buffer for sending frames, etc */
-};
-
-
-static struct ast_filestream *glist = NULL;
-static pthread_mutex_t g723_lock = PTHREAD_MUTEX_INITIALIZER;
-static int glistcnt = 0;
-
-static char *name = &quot;g723sf&quot;;
-static char *desc = &quot;G.723.1 Simple Timestamp File Format&quot;;
-static char *exts = &quot;g723&quot;;
-
-static struct ast_filestream *g723_open(int fd)
-{
-	/* We don't have any header to read or anything really, but
-	   if we did, it would go here.  We also might want to check
-	   and be sure it's a valid file.  */
-	struct ast_filestream *tmp;
-	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
-		if (pthread_mutex_lock(&amp;g723_lock)) {
-			ast_log(LOG_WARNING, &quot;Unable to lock g723 list\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		tmp-&gt;next = glist;
-		glist = tmp;
-		tmp-&gt;fd = fd;
-		tmp-&gt;owner = NULL;
-		tmp-&gt;fr = (struct ast_frame *)tmp-&gt;buf;
-		tmp-&gt;fr-&gt;data = tmp-&gt;buf + sizeof(struct ast_frame);
-		tmp-&gt;fr-&gt;frametype = AST_FRAME_VOICE;
-		tmp-&gt;fr-&gt;subclass = AST_FORMAT_G723_1;
-		/* datalen will vary for each frame */
-		tmp-&gt;fr-&gt;src = name;
-		tmp-&gt;fr-&gt;mallocd = 0;
-		tmp-&gt;lasttimeout = -1;
-		tmp-&gt;orig.tv_usec = 0;
-		tmp-&gt;orig.tv_sec = 0;
-		glistcnt++;
-		pthread_mutex_unlock(&amp;g723_lock);
-		ast_update_use_count();
-	}
-	return tmp;
-}
-
-static struct ast_filestream *g723_rewrite(int fd, char *comment)
-{
-	/* We don't have any header to read or anything really, but
-	   if we did, it would go here.  We also might want to check
-	   and be sure it's a valid file.  */
-	struct ast_filestream *tmp;
-	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
-		if (pthread_mutex_lock(&amp;g723_lock)) {
-			ast_log(LOG_WARNING, &quot;Unable to lock g723 list\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		tmp-&gt;next = glist;
-		glist = tmp;
-		tmp-&gt;fd = fd;
-		tmp-&gt;owner = NULL;
-		tmp-&gt;fr = NULL;
-		tmp-&gt;lasttimeout = -1;
-		glistcnt++;
-		pthread_mutex_unlock(&amp;g723_lock);
-		ast_update_use_count();
-	} else
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-	return tmp;
-}
-
-static struct ast_frame *g723_read(struct ast_filestream *s)
-{
-	return NULL;
-}
-
-static void g723_close(struct ast_filestream *s)
-{
-	struct ast_filestream *tmp, *tmpl = NULL;
-	if (pthread_mutex_lock(&amp;g723_lock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock g723 list\n&quot;);
-		return;
-	}
-	tmp = glist;
-	while(tmp) {
-		if (tmp == s) {
-			if (tmpl)
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				glist = tmp-&gt;next;
-			break;
-		}
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-	}
-	glistcnt--;
-	if (s-&gt;owner) {
-		s-&gt;owner-&gt;stream = NULL;
-		if (s-&gt;owner-&gt;streamid &gt; -1)
-			ast_sched_del(s-&gt;owner-&gt;sched, s-&gt;owner-&gt;streamid);
-		s-&gt;owner-&gt;streamid = -1;
-	}
-	pthread_mutex_unlock(&amp;g723_lock);
-	ast_update_use_count();
-	if (!tmp) 
-		ast_log(LOG_WARNING, &quot;Freeing a filestream we don't seem to own\n&quot;);
-	close(s-&gt;fd);
-	free(s);
-}
-
-static int ast_read_callback(void *data)
-{
-	u_int16_t size;
-	u_int32_t delay = -1;
-	int looper = 1;
-	int retval = 0;
-	int res;
-	struct ast_filestream *s = data;
-	/* Send a frame from the file to the appropriate channel */
-	while(looper) {
-		if (read(s-&gt;fd, &amp;size, 2) != 2) {
-			/* Out of data, or the file is no longer valid.  In any case
-			   go ahead and stop the stream */
-			s-&gt;owner-&gt;streamid = -1;
-			return 0;
-		}
-		/* Looks like we have a frame to read from here */
-		size = ntohs(size);
-		if (size &gt; G723_MAX_SIZE - sizeof(struct ast_frame)) {
-			ast_log(LOG_WARNING, &quot;Size %d is invalid\n&quot;, size);
-			/* The file is apparently no longer any good, as we
-			   shouldn't ever get frames even close to this 
-			   size.  */
-			s-&gt;owner-&gt;streamid = -1;
-			return 0;
-		}
-		/* Read the data into the buffer */
-		s-&gt;fr-&gt;offset = AST_FRIENDLY_OFFSET;
-		s-&gt;fr-&gt;datalen = size;
-		s-&gt;fr-&gt;data = s-&gt;buf + sizeof(struct ast_frame) + AST_FRIENDLY_OFFSET;
-		if ((res = read(s-&gt;fd, s-&gt;fr-&gt;data , size)) != size) {
-			ast_log(LOG_WARNING, &quot;Short read (%d of %d bytes) (%s)!\n&quot;, res, size, strerror(errno));
-			s-&gt;owner-&gt;streamid = -1;
-			return 0;
-		}
-		/* Read the delay for the next packet, and schedule again if necessary */
-		if (read(s-&gt;fd, &amp;delay, 4) == 4) 
-			delay = ntohl(delay);
-		else
-			delay = -1;
-		/* Average out frames &lt;= 40 ms */
-		if (delay &lt; 41)
-			s-&gt;fr-&gt;timelen = 30;
-		else
-			s-&gt;fr-&gt;timelen = delay;
-		/* Unless there is no delay, we're going to exit out as soon as we
-		   have processed the current frame. */
-		if (delay &gt; VOFR_FUDGE) {
-			looper = 0;
-			/* If there is a delay, lets schedule the next event */
-			if (delay != s-&gt;lasttimeout) {
-				/* We'll install the next timeout now. */
-				s-&gt;owner-&gt;streamid = ast_sched_add(s-&gt;owner-&gt;sched, 
-													  delay - VOFR_FUDGE, 
-													  ast_read_callback, s);
-				
-				s-&gt;lasttimeout = delay;
-			} else
-				/* Just come back again at the same time */
-				retval = -1;
-		}
-		/* Lastly, process the frame */
-		if (ast_write(s-&gt;owner, s-&gt;fr)) {
-			ast_log(LOG_WARNING, &quot;Failed to write frame\n&quot;);
-			s-&gt;owner-&gt;streamid = -1;
-			return 0;
-		}
-	}
-	return retval;
-}
-
-static int g723_apply(struct ast_channel *c, struct ast_filestream *s)
-{
-	u_int32_t delay;
-	/* Select our owner for this stream, and get the ball rolling. */
-	s-&gt;owner = c;
-	/* Read and ignore the first delay */
-	if (read(s-&gt;fd, &amp;delay, 4) != 4) {
-		ast_log(LOG_WARNING, &quot;Bad stream?\n&quot;);
-		return -1;
-	}
-	ast_read_callback(s);
-	return 0;
-}
-
-static int g723_write(struct ast_filestream *fs, struct ast_frame *f)
-{
-	struct timeval now;
-	u_int32_t delay;
-	u_int16_t size;
-	int res;
-	if (fs-&gt;fr) {
-		ast_log(LOG_WARNING, &quot;Asked to write on a read stream??\n&quot;);
-		return -1;
-	}
-	if (f-&gt;frametype != AST_FRAME_VOICE) {
-		ast_log(LOG_WARNING, &quot;Asked to write non-voice frame!\n&quot;);
-		return -1;
-	}
-	if (f-&gt;subclass != AST_FORMAT_G723_1) {
-		ast_log(LOG_WARNING, &quot;Asked to write non-g723 frame!\n&quot;);
-		return -1;
-	}
-	if (!(fs-&gt;orig.tv_usec || fs-&gt;orig.tv_sec)) {
-		/* First frame should have zeros for delay */
-		delay = 0;
-		if (gettimeofday(&amp;fs-&gt;orig, NULL)) {
-			ast_log(LOG_WARNING, &quot;gettimeofday() failed??  What is this?  Y2k?\n&quot;);
-			return -1;
-		}
-	} else {
-		if (gettimeofday(&amp;now, NULL)) {
-			ast_log(LOG_WARNING, &quot;gettimeofday() failed??  What is this?  Y2k?\n&quot;);
-			return -1;
-		}
-		delay = (now.tv_sec - fs-&gt;orig.tv_sec) * 1000 + (now.tv_usec - fs-&gt;orig.tv_usec) / 1000;
-		delay = htonl(delay);
-		fs-&gt;orig.tv_sec = now.tv_sec;
-		fs-&gt;orig.tv_usec = now.tv_usec;
-	}
-	if ((res = write(fs-&gt;fd, &amp;delay, 4)) != 4) {
-		ast_log(LOG_WARNING, &quot;Unable to write delay: res=%d (%s)\n&quot;, res, strerror(errno));
-		return -1;
-	}
-	size = htons(f-&gt;datalen);
-	if ((res =write(fs-&gt;fd, &amp;size, 2)) != 2) {
-		ast_log(LOG_WARNING, &quot;Unable to write size: res=%d (%s)\n&quot;, res, strerror(errno));
-		return -1;
-	}
-	if ((res = write(fs-&gt;fd, f-&gt;data, f-&gt;datalen)) != f-&gt;datalen) {
-		ast_log(LOG_WARNING, &quot;Unable to write frame: res=%d (%s)\n&quot;, res, strerror(errno));
-		return -1;
-	}	
-	return 0;
-}
-
-char *g723_getcomment(struct ast_filestream *s)
-{
-	return NULL;
-}
-
-int load_module()
-{
-	return ast_format_register(name, exts, AST_FORMAT_G723_1,
-								g723_open,
-								g723_rewrite,
-								g723_apply,
-								g723_write,
-								g723_read,
-								g723_close,
-								g723_getcomment);
-								
-								
-}
-
-int unload_module()
-{
-	struct ast_filestream *tmp, *tmpl;
-	if (pthread_mutex_lock(&amp;g723_lock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock g723 list\n&quot;);
-		return -1;
-	}
-	tmp = glist;
-	while(tmp) {
-		if (tmp-&gt;owner)
-			ast_softhangup(tmp-&gt;owner);
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-		free(tmpl);
-	}
-	pthread_mutex_unlock(&amp;g723_lock);
-	return ast_format_unregister(name);
-}	
-
-int usecount()
-{
-	int res;
-	if (pthread_mutex_lock(&amp;g723_lock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock g723 list\n&quot;);
-		return -1;
-	}
-	res = glistcnt;
-	pthread_mutex_unlock(&amp;g723_lock);
-	return res;
-}
-
-char *description()
-{
-	return desc;
-}
-
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/formats/format_wav.c
===================================================================
--- trunk/formats/format_wav.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/formats/format_wav.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,359 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Microsoft WAV File Format using libaudiofile 
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
- 
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/sched.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;arpa/inet.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;string.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;audiofile.h&gt;
-
-
-/* Read 320 samples at a time, max */ 
-#define WAV_MAX_SIZE 320
-
-/* Fudge in milliseconds */
-#define WAV_FUDGE 2
-
-struct ast_filestream {
-	/* First entry MUST be reserved for the channel type */
-	void *reserved[AST_RESERVED_POINTERS];
-	/* This is what a filestream means to us */
-	int fd; /* Descriptor */
-	/* Audio File */
-	AFfilesetup afs;
-	AFfilehandle af;
-	int lasttimeout;
-	struct ast_channel *owner;
-	struct ast_filestream *next;
-	struct ast_frame fr;				/* Frame information */
-	char waste[AST_FRIENDLY_OFFSET];	/* Buffer for sending frames, etc */
-	short samples[WAV_MAX_SIZE];
-};
-
-
-static struct ast_filestream *glist = NULL;
-static pthread_mutex_t wav_lock = PTHREAD_MUTEX_INITIALIZER;
-static int glistcnt = 0;
-
-static char *name = &quot;wav&quot;;
-static char *desc = &quot;Microsoft WAV format (PCM/16, 8000Hz mono)&quot;;
-static char *exts = &quot;wav&quot;;
-
-static struct ast_filestream *wav_open(int fd)
-{
-	/* We don't have any header to read or anything really, but
-	   if we did, it would go here.  We also might want to check
-	   and be sure it's a valid file.  */
-	struct ast_filestream *tmp;
-	int notok = 0;
-	int fmt, width;
-	double rate;
-	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
-		tmp-&gt;afs = afNewFileSetup();
-		if (!tmp-&gt;afs) {
-			ast_log(LOG_WARNING, &quot;Unable to create file setup\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		afInitFileFormat(tmp-&gt;afs, AF_FILE_WAVE);
-		tmp-&gt;af = afOpenFD(fd, &quot;r&quot;, tmp-&gt;afs);
-		if (!tmp-&gt;af) {
-			afFreeFileSetup(tmp-&gt;afs);
-			ast_log(LOG_WARNING, &quot;Unable to open file descriptor\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-#if 0
-		afGetFileFormat(tmp-&gt;af, &amp;version);
-		if (version != AF_FILE_WAVE) {
-			ast_log(LOG_WARNING, &quot;This is not a wave file (%d)\n&quot;, version);
-			notok++;
-		}
-#endif
-		/* Read the format and make sure it's exactly what we seek. */
-		if (afGetChannels(tmp-&gt;af, AF_DEFAULT_TRACK) != 1) {
-			ast_log(LOG_WARNING, &quot;Invalid number of channels %d.  Should be mono (1)\n&quot;, afGetChannels(tmp-&gt;af, AF_DEFAULT_TRACK));
-			notok++;
-		}
-		afGetSampleFormat(tmp-&gt;af, AF_DEFAULT_TRACK, &amp;fmt, &amp;width);
-		if (fmt != AF_SAMPFMT_TWOSCOMP) {
-			ast_log(LOG_WARNING, &quot;Input file is not signed\n&quot;);
-			notok++;
-		}
-		rate = afGetRate(tmp-&gt;af, AF_DEFAULT_TRACK);
-		if ((rate &lt; 7900) || (rate &gt; 8100)) {
-			ast_log(LOG_WARNING, &quot;Rate %f is not close enough to 8000 Hz\n&quot;, rate);
-			notok++;
-		}
-		if (width != 16) {
-			ast_log(LOG_WARNING, &quot;Input file is not 16-bit\n&quot;);
-			notok++;
-		}
-		if (notok) {
-			afCloseFile(tmp-&gt;af);
-			afFreeFileSetup(tmp-&gt;afs);
-			free(tmp);
-			return NULL;
-		}
-		if (pthread_mutex_lock(&amp;wav_lock)) {
-			afCloseFile(tmp-&gt;af);
-			afFreeFileSetup(tmp-&gt;afs);
-			ast_log(LOG_WARNING, &quot;Unable to lock wav list\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		tmp-&gt;next = glist;
-		glist = tmp;
-		tmp-&gt;fd = fd;
-		tmp-&gt;owner = NULL;
-		tmp-&gt;fr.data = tmp-&gt;samples;
-		tmp-&gt;fr.frametype = AST_FRAME_VOICE;
-		tmp-&gt;fr.subclass = AST_FORMAT_SLINEAR;
-		/* datalen will vary for each frame */
-		tmp-&gt;fr.src = name;
-		tmp-&gt;fr.mallocd = 0;
-		tmp-&gt;lasttimeout = -1;
-		glistcnt++;
-		pthread_mutex_unlock(&amp;wav_lock);
-		ast_update_use_count();
-	}
-	return tmp;
-}
-
-static struct ast_filestream *wav_rewrite(int fd, char *comment)
-{
-	/* We don't have any header to read or anything really, but
-	   if we did, it would go here.  We also might want to check
-	   and be sure it's a valid file.  */
-	struct ast_filestream *tmp;
-	if ((tmp = malloc(sizeof(struct ast_filestream)))) {
-		tmp-&gt;afs = afNewFileSetup();
-		if (!tmp-&gt;afs) {
-			ast_log(LOG_WARNING, &quot;Unable to create file setup\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		/* WAV format */
-		afInitFileFormat(tmp-&gt;afs, AF_FILE_WAVE);
-		/* Mono */
-		afInitChannels(tmp-&gt;afs, AF_DEFAULT_TRACK, 1);
-		/* Signed linear, 16-bit */
-		afInitSampleFormat(tmp-&gt;afs, AF_DEFAULT_TRACK, AF_SAMPFMT_TWOSCOMP, 16);
-		/* 8000 Hz */
-		afInitRate(tmp-&gt;afs, AF_DEFAULT_TRACK, (double)8000.0);
-		tmp-&gt;af = afOpenFD(fd, &quot;w&quot;, tmp-&gt;afs);
-		if (!tmp-&gt;af) {
-			afFreeFileSetup(tmp-&gt;afs);
-			ast_log(LOG_WARNING, &quot;Unable to open file descriptor\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		if (pthread_mutex_lock(&amp;wav_lock)) {
-			ast_log(LOG_WARNING, &quot;Unable to lock wav list\n&quot;);
-			free(tmp);
-			return NULL;
-		}
-		tmp-&gt;next = glist;
-		glist = tmp;
-		tmp-&gt;fd = fd;
-		tmp-&gt;owner = NULL;
-		tmp-&gt;lasttimeout = -1;
-		glistcnt++;
-		pthread_mutex_unlock(&amp;wav_lock);
-		ast_update_use_count();
-	} else
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-	return tmp;
-}
-
-static struct ast_frame *wav_read(struct ast_filestream *s)
-{
-	return NULL;
-}
-
-static void wav_close(struct ast_filestream *s)
-{
-	struct ast_filestream *tmp, *tmpl = NULL;
-	if (pthread_mutex_lock(&amp;wav_lock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock wav list\n&quot;);
-		return;
-	}
-	tmp = glist;
-	while(tmp) {
-		if (tmp == s) {
-			if (tmpl)
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				glist = tmp-&gt;next;
-			break;
-		}
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-	}
-	glistcnt--;
-	if (s-&gt;owner) {
-		s-&gt;owner-&gt;stream = NULL;
-		if (s-&gt;owner-&gt;streamid &gt; -1)
-			ast_sched_del(s-&gt;owner-&gt;sched, s-&gt;owner-&gt;streamid);
-		s-&gt;owner-&gt;streamid = -1;
-	}
-	pthread_mutex_unlock(&amp;wav_lock);
-	ast_update_use_count();
-	if (!tmp) 
-		ast_log(LOG_WARNING, &quot;Freeing a filestream we don't seem to own\n&quot;);
-	afCloseFile(tmp-&gt;af);
-	afFreeFileSetup(tmp-&gt;afs);
-	close(s-&gt;fd);
-	free(s);
-}
-
-static int ast_read_callback(void *data)
-{
-	u_int32_t delay = -1;
-	int retval = 0;
-	int res;
-	struct ast_filestream *s = data;
-	/* Send a frame from the file to the appropriate channel */
-
-	if ((res = afReadFrames(s-&gt;af, AF_DEFAULT_TRACK, s-&gt;samples, sizeof(s-&gt;samples)/2)) &lt; 1) {
-		if (res)
-			ast_log(LOG_WARNING, &quot;Short read (%d) (%s)!\n&quot;, res, strerror(errno));
-		s-&gt;owner-&gt;streamid = -1;
-		return 0;
-	}
-	/* Per 8 samples, one milisecond */
-	delay = res / 8;
-	s-&gt;fr.frametype = AST_FRAME_VOICE;
-	s-&gt;fr.subclass = AST_FORMAT_SLINEAR;
-	s-&gt;fr.offset = AST_FRIENDLY_OFFSET;
-	s-&gt;fr.datalen = res * 2;
-	s-&gt;fr.data = s-&gt;samples;
-	s-&gt;fr.mallocd = 0;
-	s-&gt;fr.timelen = delay;
-	/* Unless there is no delay, we're going to exit out as soon as we
-	   have processed the current frame. */
-	/* If there is a delay, lets schedule the next event */
-	if (delay != s-&gt;lasttimeout) {
-		/* We'll install the next timeout now. */
-		s-&gt;owner-&gt;streamid = ast_sched_add(s-&gt;owner-&gt;sched, 
-											  delay, 
-											  ast_read_callback, s);
-		
-		s-&gt;lasttimeout = delay;
-	} else {
-		/* Just come back again at the same time */
-		retval = -1;
-	}
-	/* Lastly, process the frame */
-	if (ast_write(s-&gt;owner, &amp;s-&gt;fr)) {
-		ast_log(LOG_WARNING, &quot;Failed to write frame\n&quot;);
-		s-&gt;owner-&gt;streamid = -1;
-		return 0;
-	}
-	
-	return retval;
-}
-
-static int wav_apply(struct ast_channel *c, struct ast_filestream *s)
-{
-	/* Select our owner for this stream, and get the ball rolling. */
-	s-&gt;owner = c;
-	ast_read_callback(s);
-	return 0;
-}
-
-static int wav_write(struct ast_filestream *fs, struct ast_frame *f)
-{
-	int res;
-	if (f-&gt;frametype != AST_FRAME_VOICE) {
-		ast_log(LOG_WARNING, &quot;Asked to write non-voice frame!\n&quot;);
-		return -1;
-	}
-	if (f-&gt;subclass != AST_FORMAT_SLINEAR) {
-		ast_log(LOG_WARNING, &quot;Asked to write non-signed linear frame (%d)!\n&quot;, f-&gt;subclass);
-		return -1;
-	}
-	if ((res = afWriteFrames(fs-&gt;af, AF_DEFAULT_TRACK, f-&gt;data, f-&gt;datalen/2)) != f-&gt;datalen/2) {
-		ast_log(LOG_WARNING, &quot;Unable to write frame: res=%d (%s)\n&quot;, res, strerror(errno));
-		return -1;
-	}	
-	return 0;
-}
-
-char *wav_getcomment(struct ast_filestream *s)
-{
-	return NULL;
-}
-
-int load_module()
-{
-	return ast_format_register(name, exts, AST_FORMAT_SLINEAR,
-								wav_open,
-								wav_rewrite,
-								wav_apply,
-								wav_write,
-								wav_read,
-								wav_close,
-								wav_getcomment);								
-								
-								
-}
-
-int unload_module()
-{
-	struct ast_filestream *tmp, *tmpl;
-	if (pthread_mutex_lock(&amp;wav_lock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock wav list\n&quot;);
-		return -1;
-	}
-	tmp = glist;
-	while(tmp) {
-		if (tmp-&gt;owner)
-			ast_softhangup(tmp-&gt;owner);
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-		free(tmpl);
-	}
-	pthread_mutex_unlock(&amp;wav_lock);
-	return ast_format_unregister(name);
-}	
-
-int usecount()
-{
-	int res;
-	if (pthread_mutex_lock(&amp;wav_lock)) {
-		ast_log(LOG_WARNING, &quot;Unable to lock wav list\n&quot;);
-		return -1;
-	}
-	res = glistcnt;
-	pthread_mutex_unlock(&amp;wav_lock);
-	return res;
-}
-
-char *description()
-{
-	return desc;
-}
-
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/frame.c
===================================================================
--- trunk/frame.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/frame.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,93 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Frame manipulation routines
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/frame.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-
-/*
- * Important: I should be made more efficient.  Frame headers should
- * most definitely be cached
- */
-
-void ast_frfree(struct ast_frame *fr)
-{
-	if (fr-&gt;mallocd &amp; AST_MALLOCD_DATA) {
-		if (fr-&gt;data) 
-			free(fr-&gt;data - fr-&gt;offset);
-	}
-	if (fr-&gt;mallocd &amp; AST_MALLOCD_SRC) {
-		if (fr-&gt;src)
-			free(fr-&gt;src);
-	}
-	if (fr-&gt;mallocd &amp; AST_MALLOCD_HDR) {
-		free(fr);
-	}
-}
-
-void ast_frchain(struct ast_frame_chain *fc)
-{
-	struct ast_frame_chain *last;
-	while(fc) {
-		last = fc;
-		fc = fc-&gt;next;
-		if (last-&gt;fr)
-			ast_frfree(last-&gt;fr);
-		free(last);
-	}
-}
-
-struct ast_frame *ast_frisolate(struct ast_frame *fr)
-{
-	struct ast_frame *out;
-	if (!(fr-&gt;mallocd &amp; AST_MALLOCD_HDR)) {
-		/* Allocate a new header if needed */
-		out = malloc(sizeof(struct ast_frame));
-		if (!out) {
-			ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-			return NULL;
-		}
-		out-&gt;frametype = fr-&gt;frametype;
-		out-&gt;subclass = fr-&gt;subclass;
-		out-&gt;datalen = 0;
-		out-&gt;timelen = fr-&gt;timelen;
-		out-&gt;offset = 0;
-		out-&gt;src = NULL;
-		out-&gt;data = NULL;
-	} else {
-		out = fr;
-	}
-	if (!(fr-&gt;mallocd &amp; AST_MALLOCD_SRC)) {
-		if (fr-&gt;src)
-			out-&gt;src = strdup(fr-&gt;src);
-	} else
-		out-&gt;src = fr-&gt;src;
-	if (!(fr-&gt;mallocd &amp; AST_MALLOCD_DATA))  {
-		out-&gt;data = malloc(fr-&gt;datalen + fr-&gt;offset);
-		out-&gt;data += fr-&gt;offset;
-		out-&gt;offset = fr-&gt;offset;
-		out-&gt;datalen = fr-&gt;datalen;
-		memcpy(out-&gt;data, fr-&gt;data, fr-&gt;datalen);
-		if (!out-&gt;data) {
-			ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-			return NULL;
-		}
-	}
-	out-&gt;mallocd = AST_MALLOCD_HDR | AST_MALLOCD_SRC | AST_MALLOCD_DATA;
-	return out;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/channel.h
===================================================================
--- trunk/include/asterisk/channel.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/include/asterisk/channel.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,156 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * General Asterisk channel definitions.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#ifndef _ASTERISK_CHANNEL_H
-#define _ASTERISK_CHANNEL_H
-
-#include &lt;asterisk/frame.h&gt;
-#include &lt;asterisk/sched.h&gt;
-#include &lt;setjmp.h&gt;
-#include &lt;pthread.h&gt;
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-
-
-#define AST_CHANNEL_NAME 80
-#define AST_CHANNEL_MAX_STACK 32
-
-/* Max length an extension can be (unique) is this number */
-#define AST_MAX_EXTENSION 80
-
-struct ast_channel {
-	char name[AST_CHANNEL_NAME];		/* ASCII Description of channel name */
-	pthread_t blocker;					/* If anyone is blocking, this is them */
-	char *blockproc;					/* Procedure causing blocking */
-	int blocking;						/* Whether or not we're blocking */
-	struct sched_context *sched;		/* Schedule context */
-	int streamid;					/* For streaming playback, the schedule ID */
-	struct ast_filestream *stream;	/* Stream itself. */
-	struct ast_channel *trans;		/* Translator if present */
-	struct ast_channel *master;		/* Master channel, if this is a translator */
-	int fd;					/* File descriptor for channel -- all must have
-						   a file descriptor! */
-	char *type;				/* Type of channel */
-	int state;				/* State of line */
-	int rings;				/* Number of rings so far */
-	int stack;				/* Current level of application */
-	int format;				/* Kinds of data this channel can
-						   	   natively handle */
-	char *dnid;				/* Malloc'd Dialed Number Identifier */
-	char *callerid;			/* Malloc'd Caller ID */
-	char context[AST_MAX_EXTENSION];	/* Current extension context */
-	char exten[AST_MAX_EXTENSION];		/* Current extension number */
-	int priority;						/* Current extension priority */
-	void *app[AST_CHANNEL_MAX_STACK];	/* Application information -- see assigned numbers */
-	struct ast_channel_pvt *pvt;
-						/* Private channel implementation details */
-	jmp_buf jmp[AST_CHANNEL_MAX_STACK];		/* Jump buffer used for returning from applications */
-	struct ast_pbx *pbx;
-	struct ast_channel *next;		/* For easy linking */
-};
-
-
-/* Bits 0-15 of state are reserved for the state (up/down) of the line */
-
-#define AST_STATE_DOWN		0		/* Channel is down and available */
-#define AST_STATE_RESERVED	1		/* Channel is down, but reserved */
-#define AST_STATE_OFFHOOK	2		/* Channel is off hook */
-#define AST_STATE_DIALING	3		/* Digits (or equivalent) have been dialed */
-#define AST_STATE_RING		4		/* Line is ringing */
-#define AST_STATE_RINGING	5		/* Remote end is ringing */
-#define AST_STATE_UP		6		/* Line is up */
-#define AST_STATE_BUSY  	7		/* Line is busy */
-
-/* Bits 16-32 of state are reserved for flags */
-
-#define AST_STATE_MUTE		(1 &lt;&lt; 16)	/* Do not transmit voice data */
-
-/* Request a channel of a given type, with data as optional information used
-   by the low level module */
-struct ast_channel *ast_request(char *type, int format, void *data);
-
-/* Called by a channel module to register the kind of channels it supports.
-   It supplies a brief type, a longer, but still short description, and a
-   routine that creates a channel */
-int ast_channel_register(char *type, char *description, int capabilities, 
-			struct ast_channel* (*requester)(char *type, int format, void *data));
-
-/* Unregister a channel class */
-void ast_channel_unregister(char *type);
-
-/* Hang up a channel -- chan is no longer valid after this call! */
-int ast_hangup(struct ast_channel *chan);
-
-/* Softly hangup up a channel -- call the protocol layer, but don't
-   destroy the channel structure (use this if you are trying to
-   safely hangup a channel managed by another thread. */
-int ast_softhangup(struct ast_channel *chan);
-
-/* Answer a ringing call */
-int ast_answer(struct ast_channel *chan);
-
-/* Place a call, take no longer than timeout ms.  Returns -1 on failure, 
-   0 on not enough time (does not auto matically stop ringing), and  
-   the number of seconds the connect took otherwise.  */
-int ast_call(struct ast_channel *chan, char *addr, int timeout);
-
-/* Misc stuff */
-
-/* Wait for input on a channel for a given # of milliseconds (&lt;0 for indefinite).  
-  Returns &lt; 0 on  failure, 0 if nothing ever arrived, and the # of ms remaining otherwise */
-int ast_waitfor(struct ast_channel *chan, int ms);
-
-/* Wait for input on an array of channels for a given # of milliseconds. Return channel
-   with activity, or NULL if none has activity.  time &quot;ms&quot; is modified in-place, if applicable */
-
-struct ast_channel *ast_waitfor_n(struct ast_channel **chan, int n, int *ms);
-
-/* This version works on fd's only.  Be careful with it. */
-int ast_waitfor_n_fd(int *fds, int n, int *ms);
-
-/* Read a frame.  Returns a frame, or NULL on error.  If it returns NULL, you
-   best just stop reading frames and assume the channel has been
-   disconnected. */
-struct ast_frame *ast_read(struct ast_channel *chan);
-
-/* Write a frame to a channel */
-int ast_write(struct ast_channel *chan, struct ast_frame *frame);
-
-/* Wait for a digit.  Returns &lt;0 on error, 0 on no entry, and the digit on success. */
-char ast_waitfordigit(struct ast_channel *c, int ms);
-
-/* Read in a digit string &quot;s&quot;, max length &quot;len&quot;, maximum timeout between 
-   digits &quot;timeout&quot; (-1 for none), terminated by anything in &quot;enders&quot;.  Give them rtimeout
-   for the first digit */
-int ast_readstring(struct ast_channel *c, char *s, int len, int timeout, int rtimeout, char *enders);
-#define CHECK_BLOCKING(c) { 	 \
-							if ((c)-&gt;blocking) \
-								ast_log(LOG_WARNING, &quot;Blocking '%s', already blocked by thread %ld in procedure %s\n&quot;, (c)-&gt;name, (c)-&gt;blocker, (c)-&gt;blockproc); \
-							else { \
-								(c)-&gt;blocker = pthread_self(); \
-								(c)-&gt;blockproc = __PRETTY_FUNCTION__; \
-									c-&gt;blocking = -1; } }
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-
-#endif
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/include/asterisk/file.h
===================================================================
--- trunk/include/asterisk/file.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/include/asterisk/file.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,88 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Generic File Format Support.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#ifndef _ASTERISK_FILE_H
-#define _ASTERISK_FILE_H
-
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/frame.h&gt;
-#include &lt;fcntl.h&gt;
-
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-
-/* Convenient for waiting */
-#define AST_DIGIT_ANY &quot;0123456789#*&quot;
-
-/* Defined by individual formats.  First item MUST be a
-   pointer for use by the stream manager */
-struct ast_filestream;
-
-/* Register a new file format capability */
-int ast_format_register(char *name, char *exts, int format,
-						struct ast_filestream * (*open)(int fd),
-						struct ast_filestream * (*rewrite)(int fd, char *comment),
-						int (*apply)(struct ast_channel *, struct ast_filestream *),
-						int (*write)(struct ast_filestream *, struct ast_frame *),
-						struct ast_frame * (*read)(struct ast_filestream *),
-						void (*close)(struct ast_filestream *),
-						char * (*getcomment)(struct ast_filestream *));
-	
-int ast_format_unregister(char *name);
-
-/* Start streaming a file */
-int ast_streamfile(struct ast_channel *c, char *filename);
-
-/* Stop playback of a stream */
-int ast_stopstream(struct ast_channel *c);
-
-/* See if a given file exists in a given format.  If fmt is NULL,  any format is accepted.*/
-int ast_fileexists(char *filename, char *fmt);
-
-/* Rename a given file in a given format, or if fmt is NULL, then do so for all */
-int ast_filerename(char *oldname, char *newname, char *fmt);
-
-/* Delete a given file in a given format, or if fmt is NULL, then do so for all */
-int ast_filedelete(char *filename, char *fmt);
-
-/* Wait for a stream to stop or for any one of a given digit to arrive,  Returns
-   0 if the stream finishes, the character if it was interrupted, and -1 on error */
-char ast_waitstream(struct ast_channel *c, char *breakon);
-
-/* Create an outgoing file stream.  oflags are flags for the open() command, and
-   if check is non-zero, then it will not write a file if there are any files that
-   start with that name and have an extension */
-struct ast_filestream *ast_writefile(char *filename, char *type, char *comment, int oflags, int check, mode_t mode);
-
-/* Send a frame to a filestream -- note: does NOT free the frame, call ast_frfree manually */
-int ast_writestream(struct ast_filestream *fs, struct ast_frame *f);
-
-/* Close a playback or recording stream */
-int ast_closestream(struct ast_filestream *f);
-
-#define AST_RESERVED_POINTERS 4
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-
-
-#endif
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/frame.h
===================================================================
--- trunk/include/asterisk/frame.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/include/asterisk/frame.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,105 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Asterisk internal frame definitions.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#ifndef _ASTERISK_FRAME_H
-#define _ASTERISK_FRAME_H
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-/* A frame of data read used to communicate between 
-   between channels and applications */
-struct ast_frame {
-	int frametype;				/* Kind of frame */
-	int subclass;				/* Subclass, frame dependent */
-	int datalen;				/* Length of data */
-	int timelen;				/* Amount of time associated with this frame */
-	int mallocd;				/* Was the data malloc'd?  i.e. should we
-								   free it when we discard the frame? */
-	int offset;					/* How far into &quot;data&quot; the data really starts */
-	char *src;					/* Optional source of frame for debugging */
-	void *data;					/* Pointer to actual data */
-};
-
-struct ast_frame_chain {
-	/* XXX Should ast_frame chain's be just prt of frames, i.e. should they just link? XXX */
-	struct ast_frame *fr;
-	struct ast_frame_chain *next;
-};
-
-#define AST_FRIENDLY_OFFSET 	64		/* It's polite for a a new frame to
-										   have at least this number of bytes
-										   of offset before your real frame data
-										   so that additional headers can be
-										   added. */
-
-#define AST_MALLOCD_HDR		(1 &lt;&lt; 0)	/* Need the header be free'd? */
-#define AST_MALLOCD_DATA	(1 &lt;&lt; 1)	/* Need the data be free'd? */
-#define AST_MALLOCD_SRC		(1 &lt;&lt; 2)	/* Need the source be free'd? (haha!) */
-
-/* Frame types */
-#define AST_FRAME_DTMF		1		/* A DTMF digit, subclass is the digit */
-#define AST_FRAME_VOICE		2		/* Voice data, subclass is AST_FORMAT_* */
-#define AST_FRAME_VIDEO		3		/* Video frame, maybe?? :) */
-#define AST_FRAME_CONTROL	4		/* A control frame, subclass is AST_CONTROL_* */
-#define AST_FRAME_NULL		5		/* An empty, useless frame */
-
-/* Data formats for capabilities and frames alike */
-#define AST_FORMAT_G723_1	(1 &lt;&lt; 0)	/* G.723.1 compression */
-#define AST_FORMAT_GSM		(1 &lt;&lt; 1)	/* GSM compression */
-#define AST_FORMAT_ULAW		(1 &lt;&lt; 2)	/* Raw mu-law data (G.711) */
-#define AST_FORMAT_ALAW		(1 &lt;&lt; 3)	/* Raw A-law data (G.711) */
-#define AST_FORMAT_MP3		(1 &lt;&lt; 4)	/* MPEG-2 layer 3 */
-#define AST_FORMAT_ADPCM	(1 &lt;&lt; 5)	/* ADPCM */
-#define AST_FORMAT_SLINEAR	(1 &lt;&lt; 6)	/* Raw 16-bit Signed Linear (8000 Hz) PCM */
-#define AST_FORMAT_MAX_AUDIO (1 &lt;&lt; 15)	/* Maximum audio format */
-#define AST_FORMAT_JPEG		(1 &lt;&lt; 16)	/* JPEG Images */
-#define AST_FORMAT_PNG		(1 &lt;&lt; 17)	/* PNG Images */
-#define AST_FORMAT_H261		(1 &lt;&lt; 18)	/* H.261 Video */
-#define AST_FORMAT_H263		(1 &lt;&lt; 19)	/* H.263 Video */
-
-/* Control frame types */
-#define AST_CONTROL_HANGUP		1			/* Other end has hungup */
-#define AST_CONTROL_RING		2			/* Local ring */
-#define AST_CONTROL_RINGING 	3			/* Remote end is ringing */
-#define AST_CONTROL_ANSWER		4			/* Remote end has answered */
-#define AST_CONTROL_BUSY		5			/* Remote end is busy */
-#define AST_CONTROL_TAKEOFFHOOK 6			/* Make it go off hook */
-#define AST_CONTROL_OFFHOOK		7			/* Line is off hook */
-
-/* Request a frame be allocated.  source is an optional source of the frame, 
-   len is the requested length, or &quot;0&quot; if the caller will supply the buffer */
-struct ast_frame *ast_fralloc(char *source, int len);
-
-/* Free a frame, and the memory it used if applicable */
-void ast_frfree(struct ast_frame *fr);
-
-/* Take a frame, and if it's not been malloc'd, make a malloc'd copy
-   and if the data hasn't been malloced then make the
-   data malloc'd.  If you need to store frames, say for queueing, then
-   you should call this function. */
-struct ast_frame *ast_frisolate(struct ast_frame *fr);
-
-void ast_frchain(struct ast_frame_chain *fc);
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-
-#endif
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/module.h
===================================================================
--- trunk/include/asterisk/module.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/include/asterisk/module.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,131 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Module definitions
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#ifndef _ASTERISK_MODULE_H
-#define _ASTERISK_MODULE_H
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-/* Every module must provide these functions */
-
-int load_module(void);			/* Initialize the module */
-int unload_module(void);		/* Cleanup all module structures, 
-					   sockets, etc */
-int usecount(void);			/* How many channels provided by this module are in use? */
-char *description(void);		/* Description of this module */
-
-#define AST_MODULE_CONFIG &quot;modules.conf&quot; /* Module configuration file */
-
-#define AST_FORCE_SOFT 0
-#define AST_FORCE_FIRM 1
-#define AST_FORCE_HARD 2
-
-/* Load a module */
-int ast_load_resource(char *resource_name);
-
-/* Unload a module.  Force unloading a module is not recommended. */
-int ast_unload_resource(char *resource_name, int force);
-
-/* Notify when usecount has been changed */
-void ast_update_use_count(void);
-
-/* Ask for a list of modules, descriptions, and use counts */
-int ast_update_module_list(int (*modentry)(char *module, char *description, int usecnt));
-
-/* Ask this procedure to be run with modules have been updated */
-int ast_loader_register(int (*updater)(void));
-
-/* No longer run me when modules are updated */
-int ast_loader_unregister(int (*updater)(void));
-
-/* Local user routines keep track of which channels are using a given module resource.
-   They can help make removing modules safer, particularly if they're in use at the time
-   they have been requested to be removed */
-
-#define STANDARD_LOCAL_USER struct localuser { \
-								struct ast_channel *chan; \
-								struct localuser *next; \
-							}
-
-#define LOCAL_USER_DECL static pthread_mutex_t localuser_lock = PTHREAD_MUTEX_INITIALIZER; \
-						static struct localuser *localusers = NULL; \
-						static int localusecnt = 0;
-
-#define LOCAL_USER_ADD(u) { \
- \
-	if (!(u=malloc(sizeof(struct localuser)))) { \
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;); \
-		return -1; \
-	} \
-	pthread_mutex_lock(&amp;localuser_lock); \
-	u-&gt;chan = chan; \
-	u-&gt;next = localusers; \
-	localusers = u; \
-	localusecnt++; \
-	pthread_mutex_unlock(&amp;localuser_lock); \
-	ast_update_use_count(); \
-}
-
-#define LOCAL_USER_REMOVE(u) { \
-	struct localuser *uc, *ul = NULL; \
-	pthread_mutex_lock(&amp;localuser_lock); \
-	uc = localusers; \
-	while (uc) { \
-		if (uc == u) { \
-			if (ul) \
-				ul-&gt;next = uc-&gt;next; \
-			else \
-				localusers = uc-&gt;next; \
-			break; \
-		} \
-		ul = uc; \
-		uc = uc-&gt;next; \
-	}\
-	free(u); \
-	localusecnt--; \
-	pthread_mutex_unlock(&amp;localuser_lock); \
-	ast_update_use_count(); \
-}
-
-#define STANDARD_HANGUP_LOCALUSERS { \
-	struct localuser *u, *ul; \
-	pthread_mutex_lock(&amp;localuser_lock); \
-	u = localusers; \
-	while(u) { \
-		ast_softhangup(u-&gt;chan); \
-		ul = u; \
-		u = u-&gt;next; \
-		free(ul); \
-	} \
-	pthread_mutex_unlock(&amp;localuser_lock); \
-	localusecnt=0; \
-}
-
-#define STANDARD_USECOUNT(res) { \
-	pthread_mutex_lock(&amp;localuser_lock); \
-	res = localusecnt; \
-	pthread_mutex_unlock(&amp;localuser_lock); \
-}
-	
-	
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-#endif
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/include/asterisk/say.h
===================================================================
--- trunk/include/asterisk/say.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/include/asterisk/say.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,36 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Say numbers and dates (maybe words one day too)
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#ifndef _ASTERISK_SAY_H
-#define _ASTERISK_SAY_H
-
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/file.h&gt;
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-int ast_say_number(struct ast_channel *chan, int num);
-int ast_say_digits(struct ast_channel *chan, int num);
-int ast_say_digit_str(struct ast_channel *chan, char *num);
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-#endif
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/include/asterisk/translate.h
===================================================================
--- trunk/include/asterisk/translate.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/include/asterisk/translate.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,80 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Translate via the use of pseudo channels
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#ifndef _ASTERISK_TRANSLATE_H
-#define _ASTERISK_TRANSLATE_H
-
-#define MAX_FORMAT 32
-
-#if defined(__cplusplus) || defined(c_plusplus)
-extern &quot;C&quot; {
-#endif
-
-#include &lt;asterisk/frame.h&gt;
-
-/* Declared by individual translators */
-struct ast_translator_pvt;
-
-struct ast_translator {
-	char name[80];
-	int srcfmt;
-	int dstfmt;
-	struct ast_translator_pvt *(*new)();
-	int (*framein)(struct ast_translator_pvt *pvt, struct ast_frame *in);
-	struct ast_frame * (*frameout)(struct ast_translator_pvt *pvt);
-	void (*destroy)(struct ast_translator_pvt *pvt);
-	/* For performance measurements */
-	/* Generate an example frame */
-	struct ast_frame * (*sample)(void);
-	/* Cost in milliseconds for encoding/decoding 1 second of sound */
-	int cost;
-	/* For linking, not to be modified by the translator */
-	struct ast_translator *next;
-};
-
-struct ast_trans_pvt;
-
-/* Create a pseudo channel which translates from a real channel into our
-   desired format.  When a translator is installed, you should not use the
-   sub channel until you have stopped the translator.  For all other
-   actions, use the real channel. Generally, translators should be created 
-   when needed and immediately destroyed when no longer needed.  */
-
-/* Directions */
-#define AST_DIRECTION_OUT  1
-#define AST_DIRECTION_IN   2
-#define AST_DIRECTION_BOTH 3
-
-extern struct ast_channel *ast_translator_create(struct ast_channel *real, int format, int direction);
-extern void ast_translator_destroy(struct ast_channel *tran);
-/* Register a Codec translator */
-extern int ast_register_translator(struct ast_translator *t);
-/* Unregister same */
-extern int ast_unregister_translator(struct ast_translator *t);
-/* Given a list of sources, and a designed destination format, which should
-   I choose? */
-extern int ast_translator_best_choice(int dst, int srcs);
-extern struct ast_trans_pvt *ast_translator_build_path(int source, int dest);
-extern void ast_translator_free_path(struct ast_trans_pvt *tr);
-extern struct ast_frame_chain *ast_translate(struct ast_trans_pvt *tr, struct ast_frame *f);
-
-
-#if defined(__cplusplus) || defined(c_plusplus)
-}
-#endif
-
-#endif
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/loader.c
===================================================================
--- trunk/loader.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/loader.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,326 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Module Loader
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;stdio.h&gt;
-#include &lt;dirent.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;string.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;asterisk/config.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;dlfcn.h&gt;
-#define __USE_GNU
-#include &lt;pthread.h&gt;
-#include &quot;asterisk.h&quot;
-
-struct module {
-	int (*load_module)(void);
-	int (*unload_module)(void);
-	int (*usecount)(void);
-	char *(*description)(void);
-	void *lib;
-	char resource[256];
-	struct module *next;
-};
-
-static struct loadupdate {
-	int (*updater)(void);
-	struct loadupdate *next;
-} *updaters = NULL;
-
-static pthread_mutex_t modlock = PTHREAD_MUTEX_INITIALIZER;
-
-static struct module *module_list=NULL;
-
-int ast_unload_resource(char *resource_name, int force)
-{
-	struct module *m, *ml = NULL;
-	int res = -1;
-	if (pthread_mutex_lock(&amp;modlock))
-		ast_log(LOG_WARNING, &quot;Failed to lock\n&quot;);
-	m = module_list;
-	while(m) {
-		if (!strcasecmp(m-&gt;resource, resource_name)) {
-			if ((res = m-&gt;usecount()) &gt; 0)  {
-				if (force) 
-					ast_log(LOG_WARNING, &quot;Warning:  Forcing removal of module %s with use count %d\n&quot;, resource_name, res);
-				else {
-					ast_log(LOG_WARNING, &quot;Soft unload failed, '%s' has use count %d\n&quot;, resource_name, res);
-					pthread_mutex_unlock(&amp;modlock);
-					return -1;
-				}
-			}
-			res = m-&gt;unload_module();
-			if (res) {
-				ast_log(LOG_WARNING, &quot;Firm unload failed for %s\n&quot;, resource_name);
-				if (force &lt;= AST_FORCE_FIRM) {
-					pthread_mutex_unlock(&amp;modlock);
-					return -1;
-				} else
-					ast_log(LOG_WARNING, &quot;** Dangerous **: Unloading resource anyway, at user request\n&quot;);
-			}
-			if (ml)
-				ml-&gt;next = m-&gt;next;
-			else
-				module_list = m-&gt;next;
-			dlclose(m-&gt;lib);
-			free(m);
-		}
-		ml = m;
-		m = m-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;modlock);
-	ast_update_use_count();
-	return res;
-}
-
-int ast_load_resource(char *resource_name)
-{
-	static char fn[256];
-	int errors=0;
-	int res;
-	struct module *m = malloc(sizeof(struct module));
-	if (!m) {
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-		return -1;
-	}
-	strncpy(m-&gt;resource, resource_name, sizeof(m-&gt;resource));
-	if (resource_name[0] == '/') {
-		strncpy(fn, resource_name, sizeof(fn));
-	} else {
-		snprintf(fn, sizeof(fn), &quot;%s/%s&quot;, AST_MODULE_DIR, resource_name);
-	}
-	m-&gt;lib = dlopen(fn, RTLD_NOW  | RTLD_GLOBAL);
-	if (!m-&gt;lib) {
-		ast_log(LOG_WARNING, &quot;%s\n&quot;, dlerror());
-		free(m);
-		return -1;
-	}
-	m-&gt;load_module = dlsym(m-&gt;lib, &quot;load_module&quot;);
-	if (!m-&gt;load_module) {
-		ast_log(LOG_WARNING, &quot;No load_module in module %s\n&quot;, fn);
-		errors++;
-	}
-	m-&gt;unload_module = dlsym(m-&gt;lib, &quot;unload_module&quot;);
-	if (!m-&gt;unload_module) {
-		ast_log(LOG_WARNING, &quot;No unload_module in module %s\n&quot;, fn);
-		errors++;
-	}
-	m-&gt;usecount = dlsym(m-&gt;lib, &quot;usecount&quot;);
-	if (!m-&gt;usecount) {
-		ast_log(LOG_WARNING, &quot;No usecount in module %s\n&quot;, fn);
-		errors++;
-	}
-	m-&gt;description = dlsym(m-&gt;lib, &quot;description&quot;);
-	if (!m-&gt;description) {
-		ast_log(LOG_WARNING, &quot;No description in module %s\n&quot;, fn);
-		errors++;
-	}
-	if (errors) {
-		ast_log(LOG_WARNING, &quot;%d error(s) loading module %s, aborted\n&quot;, errors, fn);
-		dlclose(m-&gt;lib);
-		free(m);
-		return -1;
-	}
-	if (option_verbose) 
-		ast_verbose( &quot; =&gt; (%s)\n&quot;, m-&gt;description());
-	if ((res = m-&gt;load_module())) {
-		ast_log(LOG_WARNING, &quot;%s: load_module failed, returning %d\n&quot;, m-&gt;resource, fn, res);
-		free(m);
-		return -1;
-	}
-	if (pthread_mutex_lock(&amp;modlock))
-		ast_log(LOG_WARNING, &quot;Failed to lock\n&quot;);
-	m-&gt;next = module_list;
-	module_list = m;
-	pthread_mutex_unlock(&amp;modlock);
-	ast_update_use_count();
-	return 0;
-}	
-
-int ast_resource_exists(char *resource)
-{
-	struct module *m;
-	if (pthread_mutex_lock(&amp;modlock))
-		ast_log(LOG_WARNING, &quot;Failed to lock\n&quot;);
-	m = module_list;
-	while(m) {
-		if (!strcasecmp(resource, m-&gt;resource))
-			break;
-		m = m-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;modlock);
-	if (m)
-		return -1;
-	else
-		return 0;
-}
-
-int load_modules()
-{
-	struct ast_config *cfg;
-	struct ast_variable *v;
-	if (option_verbose) 
-		ast_verbose( &quot;Asterisk Dynamic Loader Starting:\n&quot;);
-	cfg = ast_load(AST_MODULE_CONFIG);
-	if (cfg) {
-		/* Load explicitly defined modules */
-		v = ast_variable_browse(cfg, &quot;modules&quot;);
-		while(v) {
-			if (!strcasecmp(v-&gt;name, &quot;load&quot;)) {
-				if (option_debug &amp;&amp; !option_verbose)
-					ast_log(LOG_DEBUG, &quot;Loading module %s\n&quot;, v-&gt;value);
-				if (option_verbose) {
-					ast_verbose( &quot; [%s]&quot;, v-&gt;value);
-					fflush(stdout);
-				}
-				if (ast_load_resource(v-&gt;value)) {
-					ast_log(LOG_WARNING, &quot;Loading module %s failed!\n&quot;, v-&gt;value);
-					if (cfg)
-						ast_destroy(cfg);
-					return -1;
-				}
-			}
-			v=v-&gt;next;
-		}
-	}
-	if (!cfg || ast_true(ast_variable_retrieve(cfg, &quot;modules&quot;, &quot;autoload&quot;))) {
-		/* Load all modules */
-		DIR *mods;
-		struct dirent *d;
-		mods = opendir(AST_MODULE_DIR);
-		if (mods) {
-			while((d = readdir(mods))) {
-				/* Must end in .so to load it.  */
-				if ((strlen(d-&gt;d_name) &gt; 3) &amp;&amp; 
-				    !strcasecmp(d-&gt;d_name + strlen(d-&gt;d_name) - 3, &quot;.so&quot;) &amp;&amp;
-					!ast_resource_exists(d-&gt;d_name)) {
-					/* It's a shared library -- Just be sure we're allowed to load it -- kinda
-					   an inefficient way to do it, but oh well. */
-					if (cfg) {
-						v = ast_variable_browse(cfg, &quot;modules&quot;);
-						while(v) {
-							if (!strcasecmp(v-&gt;name, &quot;noload&quot;) &amp;&amp;
-							    !strcasecmp(v-&gt;value, d-&gt;d_name)) 
-								break;
-							v = v-&gt;next;
-						}
-						if (v) {
-							if (option_verbose) {
-								ast_verbose( VERBOSE_PREFIX_1 &quot;[skipping %s]\n&quot;, d-&gt;d_name);
-								fflush(stdout);
-							}
-							continue;
-						}
-						
-					}
-				    if (option_debug &amp;&amp; !option_verbose)
-						ast_log(LOG_DEBUG, &quot;Loading module %s\n&quot;, d-&gt;d_name);
-					if (option_verbose) {
-						ast_verbose( VERBOSE_PREFIX_1 &quot;[%s]&quot;, d-&gt;d_name);
-						fflush(stdout);
-					}
-					if (ast_load_resource(d-&gt;d_name)) {
-						ast_log(LOG_WARNING, &quot;Loading module %s failed!\n&quot;, d-&gt;d_name);
-						if (cfg)
-							ast_destroy(cfg);
-						return -1;
-					}
-				}
-			};
-		} else {
-			if (!option_quiet)
-				ast_log(LOG_WARNING, &quot;Unable to open modules directory &quot; AST_MODULE_DIR &quot;.\n&quot;);
-		}
-	} 
-	ast_destroy(cfg);
-	return 0;
-}
-
-void ast_update_use_count(void)
-{
-	/* Notify any module monitors that the use count for a 
-	   resource has changed */
-	struct loadupdate *m;
-	if (pthread_mutex_lock(&amp;modlock))
-		ast_log(LOG_WARNING, &quot;Failed to lock\n&quot;);
-	m = updaters;
-	while(m) {
-		m-&gt;updater();
-		m = m-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;modlock);
-	
-}
-
-int ast_update_module_list(int (*modentry)(char *module, char *description, int usecnt))
-{
-	struct module *m;
-	int unlock = -1;
-	if (pthread_mutex_trylock(&amp;modlock))
-		unlock = 0;
-	m = module_list;
-	while(m) {
-		modentry(m-&gt;resource, m-&gt;description(), m-&gt;usecount());
-		m = m-&gt;next;
-	}
-	if (unlock)
-		pthread_mutex_unlock(&amp;modlock);
-	return 0;
-}
-
-int ast_loader_register(int (*v)(void)) 
-{
-	struct loadupdate *tmp;
-	/* XXX Should be more flexible here, taking &gt; 1 verboser XXX */
-	if ((tmp = malloc(sizeof (struct loadupdate)))) {
-		tmp-&gt;updater = v;
-		if (pthread_mutex_lock(&amp;modlock))
-			ast_log(LOG_WARNING, &quot;Failed to lock\n&quot;);
-		tmp-&gt;next = updaters;
-		updaters = tmp;
-		pthread_mutex_unlock(&amp;modlock);
-		return 0;
-	}
-	return -1;
-}
-
-int ast_loader_unregister(int (*v)(void))
-{
-	int res = -1;
-	struct loadupdate *tmp, *tmpl=NULL;
-	if (pthread_mutex_lock(&amp;modlock))
-		ast_log(LOG_WARNING, &quot;Failed to lock\n&quot;);
-	tmp = updaters;
-	while(tmp) {
-		if (tmp-&gt;updater == v)	{
-			if (tmpl)
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				updaters = tmp-&gt;next;
-			break;
-		}
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-	}
-	if (tmp)
-		res = 0;
-	pthread_mutex_unlock(&amp;modlock);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/logger.c
===================================================================
--- trunk/logger.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/logger.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,208 +1,4 @@
 /*
- * Cheops Next Generation
- * 
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at marko.net</A>&gt;
- *
- * Copyright(C) 1999, Adtran, Inc.
- * 
- * Distributed under the terms of the GNU General Public License (GPL) Version 2
- *
- * Logging routines
- *
- */
-
-#include &lt;stdarg.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;time.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;errno.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;sys/stat.h&gt;
-#include &quot;asterisk.h&quot;
-
-#define AST_EVENT_LOG AST_LOG_DIR &quot;/&quot; EVENTLOG
-
-#define MAX_MSG_QUEUE 200
-
-static pthread_mutex_t msglist_lock = PTHREAD_MUTEX_INITIALIZER;
-
-static struct msglist {
-	char *msg;
-	struct msglist *next;
-} *list = NULL, *last = NULL;
-
-static int msgcnt = 0;
-
-static FILE *eventlog = NULL;
-
-static char *levels[] = {
-	&quot;DEBUG&quot;,
-	&quot;EVENT&quot;,
-	&quot;NOTICE&quot;,
-	&quot;WARNING&quot;,
-	&quot;ERROR&quot;
-};
-
-static struct verb {
-	void (*verboser)(char *string, int opos, int replacelast, int complete);
-	struct verb *next;
-} *verboser = NULL;
-
-int init_logger(void)
-{
-
-	mkdir(AST_LOG_DIR, 0755);
-	eventlog = fopen(AST_EVENT_LOG, &quot;a&quot;);
-	if (eventlog) {
-		ast_log(LOG_EVENT, &quot;Started Asterisk Event Logger\n&quot;);
-		if (option_verbose)
-			ast_verbose(&quot;Asterisk Event Logger Started\n&quot;);
-		return 0;
-	} else 
-		ast_log(LOG_ERROR, &quot;Unable to create event log: %s\n&quot;, strerror(errno));
-	return -1;
-}
-
-extern void ast_log(int level, char *file, int line, char *function, char *fmt, ...)
-{
-	char date[256];
-	time_t t;
-	struct tm *tm;
-
-	va_list ap;
-	va_start(ap, fmt);
-
-	if (level == 1 /* Event */) {
-		time(&amp;t);
-		tm = localtime(&amp;t);
-		if (tm) {
-			/* Log events into the event log file, with a different format */
-			strftime(date, sizeof(date), &quot;%b %e %T&quot;, tm);
-			fprintf(eventlog, &quot;%s asterisk[%d]: &quot;, date, getpid());
-			vfprintf(eventlog, fmt, ap);
-			fflush(eventlog);
-		} else
-			ast_log(LOG_WARNING, &quot;Unable to retrieve local time?\n&quot;);
-	} else {
-		fprintf(stdout, &quot;%s: File %s, Line %d (%s): &quot;, levels[level], file, line, function);
-		vfprintf(stdout, fmt, ap);
-		fflush(stdout);
-	}
-	va_end(ap);
-}
-
-extern void ast_verbose(char *fmt, ...)
-{
-	static char stuff[256];
-	static int pos = 0, opos;
-	static int replacelast = 0, complete;
-	struct msglist *m;
-	struct verb *v;
-	va_list ap;
-	va_start(ap, fmt);
-	pthread_mutex_lock(&amp;msglist_lock);
-	vsnprintf(stuff + pos, sizeof(stuff) - pos, fmt, ap);
-	opos = pos;
-	pos = strlen(stuff);
-	if (fmt[strlen(fmt)-1] == '\n') 
-		complete = 1;
-	else
-		complete=0;
-	if (complete) {
-		if (msgcnt &lt; MAX_MSG_QUEUE) {
-			/* Allocate new structure */
-			m = malloc(sizeof(struct msglist));
-			msgcnt++;
-		} else {
-			/* Recycle the oldest entry */
-			m = list;
-			list = list-&gt;next;
-			free(m-&gt;msg);
-		}
-		if (m) {
-			m-&gt;msg = strdup(stuff);
-			if (m-&gt;msg) {
-				if (last)
-					last-&gt;next = m;
-				else
-					list = m;
-				m-&gt;next = NULL;
-				last = m;
-			} else {
-				msgcnt--;
-				ast_log(LOG_DEBUG, &quot;Out of memory\n&quot;);
-				free(m);
-			}
-		}
-	}
-	if (verboser) {
-		v = verboser;
-		while(v) {
-			v-&gt;verboser(stuff, opos, replacelast, complete);
-			v = v-&gt;next;
-		}
-	} else
-		fprintf(stdout, stuff + opos);
-
-	if (fmt[strlen(fmt)-1] != '\n') 
-		replacelast = 1;
-	else 
-		replacelast = pos = 0;
-	
-	va_end(ap);
-	pthread_mutex_unlock(&amp;msglist_lock);
-}
-
-
-int ast_register_verbose(void (*v)(char *string, int opos, int replacelast, int complete)) 
-{
-	struct msglist *m;
-	struct verb *tmp;
-	/* XXX Should be more flexible here, taking &gt; 1 verboser XXX */
-	if ((tmp = malloc(sizeof (struct verb)))) {
-		tmp-&gt;verboser = v;
-		pthread_mutex_lock(&amp;msglist_lock);
-		tmp-&gt;next = verboser;
-		verboser = tmp;
-		m = list;
-		while(m) {
-			/* Send all the existing entries that we have queued (i.e. they're likely to have missed) */
-			v(m-&gt;msg, 0, 0, 1);
-			m = m-&gt;next;
-		}
-		pthread_mutex_unlock(&amp;msglist_lock);
-		return 0;
-	}
-	return -1;
-}
-
-int ast_unregister_verbose(void (*v)(char *string, int opos, int replacelast, int complete))
-{
-	int res = -1;
-	struct verb *tmp, *tmpl=NULL;
-	pthread_mutex_lock(&amp;msglist_lock);
-	tmp = verboser;
-	while(tmp) {
-		if (tmp-&gt;verboser == v)	{
-			if (tmpl)
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				verboser = tmp-&gt;next;
-			break;
-		}
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-	}
-	if (tmp)
-		res = 0;
-	pthread_mutex_unlock(&amp;msglist_lock);
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/pbx/Makefile
===================================================================
--- trunk/pbx/Makefile	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/pbx/Makefile	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,67 +1,6 @@
 #
 # Asterisk -- A telephony toolkit for Linux.
 # 
-# Makefile for PBX frontends (dynamically loaded)
-#
-# Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
-#
-# Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
-#
-# This program is free software, distributed under the terms of
-# the GNU General Public License
-#
-
-
-
-PBX_LIBS=pbx_config.so             # pbx_gtkconsole.so pbx_kdeconsole.so
-
-# Add GTK console if appropriate
-PBX_LIBS+=$(shell gtk-config --cflags &gt;&amp;/dev/null &amp;&amp; echo &quot;pbx_gtkconsole.so&quot;)
-# Add KDE Console if appropriate
-PBX_LIBS+=$(shell [ &quot;$$QTDIR&quot; != &quot;&quot; ] &amp;&amp; echo &quot;pbx_kdeconsole.so&quot;)
-
-
-GTK_FLAGS=`gtk-config --cflags gthread`
-GTK_LIBS=`gtk-config --libs gthread`
-#CXX=egcs
-MOC=$(QTDIR)/bin/moc
-KDE_FLAGS=-I$(KDEDIR)/include -I$(KDEDIR)/include/kde -I$(QTDIR)/include
-KDE_LIBS=-L$(KDEDIR)/lib -L$(QTDIR)/lib -lqt -lkdecore -lkdeui
-CFLAGS+=
-
-KDE_CONSOLE_OBJS=pbx_kdeconsole_main.o pbx_kdeconsole.o 
-
-all: $(PBX_LIBS)
-
-clean:
-	rm -f *.so *.o
-
-pbx_gtkconsole.o: pbx_gtkconsole.c
-	$(CC) $(CFLAGS) $(GTK_FLAGS) -c -o $@ $&lt;
-
-pbx_gtkconsole.so: pbx_gtkconsole.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt; $(GTK_LIBS)
-
-pbx_kdeconsole.o: pbx_kdeconsole.cc pbx_kdeconsole.moc
-	$(CXX) $(CFLAGS) $(KDE_FLAGS) -c -o $@ $&lt;
-
-pbx_kdeconsole_main.o: pbx_kdeconsole_main.cc pbx_kdeconsole.h
-	$(CXX) $(CFLAGS) $(KDE_FLAGS) -c -o $@ $&lt;
-
-pbx_kdeconsole.so: $(KDE_CONSOLE_OBJS)
-	$(CC) -shared -Xlinker -x -o $@ $(KDE_CONSOLE_OBJS) $(KDE_LIBS)
-
-%.moc : %.h
-	$(MOC) $&lt; -o $@
-
-%.so : %.o
-	$(CC) -shared -Xlinker -x -o $@ $&lt;
-
-install: all
-	for x in $(PBX_LIBS); do $(INSTALL) -m 755 $$x $(MODULES_DIR) ; done
-#
-# Asterisk -- A telephony toolkit for Linux.
-# 
 # Makefile for PBX modules
 #
 # Copyright (C) 1999-2006, Digium, Inc.

Modified: trunk/pbx/pbx_gtkconsole.c
===================================================================
--- trunk/pbx/pbx_gtkconsole.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/pbx/pbx_gtkconsole.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,391 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * GTK Console monitor -- very kludgy right now
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-/* 
- * I know this might seem somewhat pointless in its current phase, but one
- * of the most important parts of this module is demonstrate that modules
- * can require other external libraries and still be loaded (in this
- * case, a host of libraries involving gtk), so long as they are properly
- * linked (see the Makefile)
- */
-
-
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/config.h&gt;
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;fcntl.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdarg.h&gt;
-
-#include &lt;gtk/gtk.h&gt;
-#include &lt;glib.h&gt;
-/* For where to put dynamic tables */
-#include &quot;../asterisk.h&quot;
-
-static pthread_mutex_t verb_lock = PTHREAD_MUTEX_INITIALIZER;
-
-static pthread_t console_thread;
-
-static int inuse=0;
-static char *dtext = &quot;Asterisk PBX Console (GTK Version)&quot;;
-
-static GtkWidget *window;
-static GtkWidget *quit;
-static GtkWidget *closew;
-static GtkWidget *verb;
-static GtkWidget *modules;
-static GtkWidget *statusbar;
-
-static void update_statusbar(char *msg)
-{
-	gtk_statusbar_pop(GTK_STATUSBAR(statusbar), 1);
-	gtk_statusbar_push(GTK_STATUSBAR(statusbar), 1, msg);
-}
-
-int unload_module(void)
-{
-	if (inuse) {
-		/* Kill off the main thread */
-		pthread_cancel(console_thread);
-		gdk_threads_enter();
-		gtk_widget_destroy(window);
-		gdk_threads_leave();
-	}
-	return 0;
-}
-
-
-static void verboser(char *stuff, int opos, int replacelast, int complete)
-{
-	char *s2[2];
-	pthread_mutex_lock(&amp;verb_lock);
-	s2[0] = stuff;
-	s2[1] = NULL;
-	gdk_threads_enter();
-	if (replacelast) 
-		gtk_clist_remove(GTK_CLIST(verb), GTK_CLIST(verb)-&gt;rows - 1);
-	gtk_clist_append(GTK_CLIST(verb), s2);
-	gtk_clist_moveto(GTK_CLIST(verb), GTK_CLIST(verb)-&gt;rows - 1, 0, 0, 0);
-	gdk_threads_leave();
-	pthread_mutex_unlock(&amp;verb_lock);
-}
-
-static void remove_module()
-{
-	int res;
-	char *module;
-	char buf[256];
-	if (GTK_CLIST(modules)-&gt;selection) {
-		module= (char *)gtk_clist_get_row_data(GTK_CLIST(modules), (int) GTK_CLIST(modules)-&gt;selection-&gt;data);
-		gdk_threads_leave();
-		res = ast_unload_resource(module, 0);
-		gdk_threads_enter();
-		if (res) {
-			snprintf(buf, sizeof(buf), &quot;Module '%s' is in use&quot;, module);
-			update_statusbar(buf);
-		} else {
-			snprintf(buf, sizeof(buf), &quot;Module '%s' removed&quot;, module);
-			update_statusbar(buf);
-		}
-	}
-}
-static void reload_module()
-{
-	int res, x;
-	char *module;
-	char buf[256];
-	if (GTK_CLIST(modules)-&gt;selection) {
-		module= (char *)gtk_clist_get_row_data(GTK_CLIST(modules), (int) GTK_CLIST(modules)-&gt;selection-&gt;data);
-		module = strdup(module);
-		if (module) {
-			gdk_threads_leave();
-			res = ast_unload_resource(module, 0);
-			gdk_threads_enter();
-			if (res) {
-				snprintf(buf, sizeof(buf), &quot;Module '%s' is in use&quot;, module);
-				update_statusbar(buf);
-			} else {
-				gdk_threads_leave();
-				res = ast_load_resource(module);
-				gdk_threads_enter();
-				if (res) {
-					snprintf(buf, sizeof(buf), &quot;Error reloading module '%s'&quot;, module);
-				} else {
-					snprintf(buf, sizeof(buf), &quot;Module '%s' reloaded&quot;, module);
-				}
-				for (x=0; x &lt; GTK_CLIST(modules)-&gt;rows; x++) {
-					if (!strcmp((char *)gtk_clist_get_row_data(GTK_CLIST(modules), x), module)) {
-						gtk_clist_select_row(GTK_CLIST(modules), x, -1);
-						break;
-					}
-				}
-				update_statusbar(buf);
-				
-			}
-			free(module);
-		}
-	}
-}
-
-static void file_ok_sel(GtkWidget *w, GtkFileSelection *fs)
-{
-	char *module = gtk_file_selection_get_filename(fs);
-	char buf[256];
-	if (!strncmp(module, AST_MODULE_DIR &quot;/&quot;, strlen(AST_MODULE_DIR &quot;/&quot;))) 
-		module += strlen(AST_MODULE_DIR &quot;/&quot;);
-	gdk_threads_leave();
-	if (ast_load_resource(module)) {
-		snprintf(buf, sizeof(buf), &quot;Error loading module '%s'.&quot;, module);
-		update_statusbar(buf);
-	} else {
-		snprintf(buf, sizeof(buf), &quot;Module '%s' loaded&quot;, module);
-		update_statusbar(buf);
-	}
-	gdk_threads_enter();
-	gtk_widget_destroy(GTK_WIDGET(fs));
-}
-
-static void add_module()
-{
-	GtkWidget *filew;
-	filew = gtk_file_selection_new(&quot;Load Module&quot;);
-	gtk_signal_connect(GTK_OBJECT (GTK_FILE_SELECTION(filew)-&gt;ok_button),
-					&quot;clicked&quot;, GTK_SIGNAL_FUNC(file_ok_sel), filew);
-	gtk_signal_connect_object(GTK_OBJECT (GTK_FILE_SELECTION(filew)-&gt;cancel_button),
-					&quot;clicked&quot;, GTK_SIGNAL_FUNC(gtk_widget_destroy), GTK_OBJECT(filew));
-	gtk_file_selection_set_filename(GTK_FILE_SELECTION(filew), AST_MODULE_DIR &quot;/*.so&quot;);
-	gtk_widget_show(filew);
-}
-
-static int add_mod(char *module, char *description, int usecount)
-{
-	char use[10];
-	char *pass[4];
-	int row;
-	snprintf(use, sizeof(use), &quot;%d&quot;, usecount);
-	pass[0] = module;
-	pass[1] = description;
-	pass[2] = use;
-	pass[3] = NULL;
-	row = gtk_clist_append(GTK_CLIST(modules), pass);
-	gtk_clist_set_row_data(GTK_CLIST(modules), row, module);
-	return 0;	
-}
-
-static int mod_update(void)
-{
-	char *module= NULL;
-	/* Update the mod stuff */
-	if (GTK_CLIST(modules)-&gt;selection) {
-		module= (char *)gtk_clist_get_row_data(GTK_CLIST(modules), (int) GTK_CLIST(modules)-&gt;selection-&gt;data);
-	}
-	gdk_threads_enter();
-	gtk_clist_freeze(GTK_CLIST(modules));
-	gtk_clist_clear(GTK_CLIST(modules));
-	ast_update_module_list(add_mod);
-	if (module)
-		gtk_clist_select_row(GTK_CLIST(modules), gtk_clist_find_row_from_data(GTK_CLIST(modules), module), -1);
-	gtk_clist_thaw(GTK_CLIST(modules));
-	gdk_threads_leave();
-	return 1;
-}
-
-static void exit_now(GtkWidget *widget, gpointer data)
-{
-	ast_loader_unregister(mod_update);
-	gtk_main_quit();
-	inuse--;
-	ast_update_use_count();
-	ast_unregister_verbose(verboser);
-	ast_unload_resource(&quot;pbx_gtkconsole&quot;, 0);
-	if (option_verbose &gt; 1)
-		ast_verbose(VERBOSE_PREFIX_2 &quot;GTK Console Monitor Exiting\n&quot;);
-		
-}
-
-static void exit_completely(GtkWidget *widget, gpointer data)
-{
-	/* This is the wrong way to do this.  We need an ast_clean_exit() routine */
-	exit(0);
-}
-
-static void exit_nicely(GtkWidget *widget, gpointer data)
-{
-	fflush(stdout);
-	gtk_widget_destroy(window);
-}
-
-static void *consolethread(void *data)
-{
-	gtk_widget_show(window);
-	gdk_threads_enter();
-	gtk_main();
-	gdk_threads_leave();
-	return NULL;
-}
-
-static int show_console()
-{
-	GtkWidget *hbox;
-	GtkWidget *wbox;
-	GtkWidget *notebook;
-	GtkWidget *sw;
-	GtkWidget *bbox, *hbbox, *add, *removew, *reloadw;
-	char *modtitles[3] = { &quot;Module&quot;, &quot;Description&quot;, &quot;Use Count&quot; };
-	window = gtk_window_new(GTK_WINDOW_TOPLEVEL);
-	
-	statusbar = gtk_statusbar_new();
-	gtk_widget_show(statusbar);
-	
-	gtk_signal_connect(GTK_OBJECT(window), &quot;delete_event&quot;,
-			GTK_SIGNAL_FUNC (exit_nicely), window);
-	gtk_signal_connect(GTK_OBJECT(window), &quot;destroy&quot;,
-			GTK_SIGNAL_FUNC (exit_now), window);
-	gtk_container_set_border_width(GTK_CONTAINER(window), 10);
-
-	quit = gtk_button_new_with_label(&quot;Quit Asterisk&quot;);
-	gtk_signal_connect(GTK_OBJECT(quit), &quot;clicked&quot;,
-			GTK_SIGNAL_FUNC (exit_completely), window);
-	gtk_widget_show(quit);
-
-	closew = gtk_button_new_with_label(&quot;Close Window&quot;);
-	gtk_signal_connect(GTK_OBJECT(closew), &quot;clicked&quot;,
-			GTK_SIGNAL_FUNC (exit_nicely), window);
-	gtk_widget_show(closew);
-
-	notebook = gtk_notebook_new();
-	verb = gtk_clist_new(1);
-	gtk_clist_columns_autosize(GTK_CLIST(verb));
-	sw = gtk_scrolled_window_new(NULL, NULL);
-	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
-	gtk_container_add(GTK_CONTAINER(sw), verb);
-	gtk_widget_show(verb);
-	gtk_widget_show(sw);
-	gtk_widget_set_usize(verb, 600, 400);
-	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), sw, gtk_label_new(&quot;Verbose Status&quot;));
-
-	
-	modules = gtk_clist_new_with_titles(3, modtitles);
-	gtk_clist_columns_autosize(GTK_CLIST(modules));
-	gtk_clist_set_column_auto_resize(GTK_CLIST(modules), 0, TRUE);
-	gtk_clist_set_column_auto_resize(GTK_CLIST(modules), 1, TRUE);
-	gtk_clist_set_column_auto_resize(GTK_CLIST(modules), 2, TRUE);
-	gtk_clist_set_sort_column(GTK_CLIST(modules), 0);
-	gtk_clist_set_auto_sort(GTK_CLIST(modules), TRUE);
-	gtk_clist_column_titles_passive(GTK_CLIST(modules));
-	sw = gtk_scrolled_window_new(NULL, NULL);
-	gtk_scrolled_window_set_policy(GTK_SCROLLED_WINDOW(sw), GTK_POLICY_AUTOMATIC, GTK_POLICY_ALWAYS);
-	gtk_container_add(GTK_CONTAINER(sw), modules);
-	gtk_clist_set_selection_mode(GTK_CLIST(modules), GTK_SELECTION_BROWSE);
-	gtk_widget_show(modules);
-	gtk_widget_show(sw);
-
-	add = gtk_button_new_with_label(&quot;Load...&quot;);
-	gtk_widget_show(add);
-	removew = gtk_button_new_with_label(&quot;Unload&quot;);
-	gtk_widget_show(removew);
-	reloadw = gtk_button_new_with_label(&quot;Reload&quot;);
-	gtk_widget_show(reloadw);
-	gtk_signal_connect(GTK_OBJECT(removew), &quot;clicked&quot;,
-			GTK_SIGNAL_FUNC (remove_module), window);
-	gtk_signal_connect(GTK_OBJECT(add), &quot;clicked&quot;,
-			GTK_SIGNAL_FUNC (add_module), window);
-	gtk_signal_connect(GTK_OBJECT(reloadw), &quot;clicked&quot;,
-			GTK_SIGNAL_FUNC (reload_module), window);
-		
-	bbox = gtk_vbox_new(FALSE, 5);
-	gtk_widget_show(bbox);
-
-	gtk_widget_set_usize(bbox, 100, -1);
-	gtk_box_pack_start(GTK_BOX(bbox), add, FALSE, FALSE, 5);
-	gtk_box_pack_start(GTK_BOX(bbox), removew, FALSE, FALSE, 5);
-	gtk_box_pack_start(GTK_BOX(bbox), reloadw, FALSE, FALSE, 5);
-
-	hbbox = gtk_hbox_new(FALSE, 5);
-	gtk_widget_show(hbbox);
-	
-	gtk_box_pack_start(GTK_BOX(hbbox), sw, TRUE, TRUE, 5);
-	gtk_box_pack_start(GTK_BOX(hbbox), bbox, FALSE, FALSE, 5);
-
-	gtk_notebook_append_page(GTK_NOTEBOOK(notebook), hbbox, gtk_label_new(&quot;Module Information&quot;));
-
-	gtk_widget_show(notebook);
-
-	wbox = gtk_hbox_new(FALSE, 5);
-	gtk_widget_show(wbox);
-	gtk_box_pack_end(GTK_BOX(wbox), quit, FALSE, FALSE, 5);
-	gtk_box_pack_end(GTK_BOX(wbox), closew, FALSE, FALSE, 5);
-
-	hbox = gtk_vbox_new(FALSE, 0);
-	gtk_widget_show(hbox);
-
-	gtk_box_pack_start(GTK_BOX(hbox), notebook, TRUE, TRUE, 5);
-	gtk_box_pack_start(GTK_BOX(hbox), wbox, FALSE, FALSE, 5);
-	gtk_box_pack_start(GTK_BOX(hbox), statusbar, FALSE, FALSE, 0);
-
-
-	gtk_container_add(GTK_CONTAINER(window), hbox);
-	gtk_window_set_title(GTK_WINDOW(window), &quot;Asterisk Console&quot;);
-	pthread_create(&amp;console_thread, NULL, consolethread, NULL);
-	/* XXX Okay, seriously fix me! XXX */
-	usleep(100000);
-	ast_register_verbose(verboser);
-	gtk_clist_freeze(GTK_CLIST(verb));
-	ast_loader_register(mod_update);
-	gtk_clist_thaw(GTK_CLIST(verb));
-	mod_update();
-	update_statusbar(&quot;Asterisk Console Ready&quot;);
-	return 0;
-}
-
-
-int load_module(void)
-{
-	g_thread_init(NULL);
-	if (gtk_init_check(NULL, NULL))  {
-		/* XXX Do we need to call this twice? XXX */
-		gtk_init(NULL, NULL);
-		if (!show_console()) {
-			inuse++;
-			ast_update_use_count();
-			if (option_verbose &gt; 1)
-				ast_verbose( VERBOSE_PREFIX_2 &quot;Launched GTK Console monitor\n&quot;);		
-		} else
-			ast_log(LOG_WARNING, &quot;Unable to start GTK console\n&quot;);
-	} else {
-		if (option_debug)
-			ast_log(LOG_DEBUG, &quot;Unable to start GTK console monitor -- ignoring\n&quot;);
-		else if (option_verbose &gt; 1)
-			ast_verbose( VERBOSE_PREFIX_2 &quot;GTK is not available -- skipping monitor\n&quot;);
-	}
-	return 0;
-}
-
-int usecount(void)
-{
-	return inuse;
-}
-
-char *description(void)
-{
-	return dtext;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/pbx/pbx_kdeconsole.cc
===================================================================
--- trunk/pbx/pbx_kdeconsole.cc	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/pbx/pbx_kdeconsole.cc	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,67 +3,6 @@
  *
  * KDE Console monitor -- Class implmementation
  * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &quot;pbx_kdeconsole.moc&quot;
-
-KAsteriskConsole::KAsteriskConsole() : KTMainWindow()
-{
-	QVBoxLayout *box;
-	QFrame *f;
-	
-	f = new QFrame(this);
-	
-	setGeometry(100,100,600,400);
-	/* Menus */
-	file = new QPopupMenu();
-	file-&gt;insertItem(&quot;&amp;Exit&quot;, this, SLOT(slotExit()));
-	
-	help = kapp-&gt;getHelpMenu(TRUE, &quot;KDE Asterisk Console\nby Mark Spencer&quot;);
-	
-	setCaption(&quot;Asterisk Console&quot;);
-	
-	/* Box */
-	box = new QVBoxLayout(f, 20, 5);
-	
-	/* Menu bar creation */
-	menu = new KMenuBar(this);
-	menu-&gt;insertItem(&quot;&amp;File&quot;, file);
-	menu-&gt;insertItem(&quot;&amp;Help&quot;, help);
-	/* Verbose stuff */
-	verbose = new QListBox(f, &quot;verbose&quot;);
-	/* Exit button */
-	btnExit = new QPushButton(&quot;Exit&quot;, f, &quot;exit&quot;);
-	btnExit-&gt;show();
-	connect(btnExit,  SIGNAL(clicked()), this, SLOT(slotExit()));
-	
-	box-&gt;addWidget(verbose, 1);
-	box-&gt;addWidget(btnExit, 0);
-	setView(f, TRUE);
-	statusBar()-&gt;message(&quot;Ready&quot;, 2000);
-}
-
-void KAsteriskConsole::slotExit()
-{
-	close();
-}
-
-void KAsteriskConsole::closeEvent(QCloseEvent *)
-{
-	kapp-&gt;quit();
-}
-
-/*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * KDE Console monitor -- Class implmementation
- * 
  * Copyright (C) 1999, Mark Spencer
  *
  * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;

Modified: trunk/pbx/pbx_kdeconsole.h
===================================================================
--- trunk/pbx/pbx_kdeconsole.h	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/pbx/pbx_kdeconsole.h	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,43 +3,6 @@
  *
  * KDE Console monitor -- Header file
  * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;kapp.h&gt;
-#include &lt;ktmainwindow.h&gt;
-#include &lt;qpushbutton.h&gt;
-#include &lt;kmenubar.h&gt;
-#include &lt;qpopupmenu.h&gt;
-#include &lt;qlistbox.h&gt;
-#include &lt;qlayout.h&gt;
-#include &lt;qframe.h&gt;
-
-class KAsteriskConsole : public KTMainWindow
-{
-	Q_OBJECT
-public:
-	KAsteriskConsole();
-	void closeEvent(QCloseEvent *);
-	QListBox *verbose;
-public slots:
-	void slotExit();
-private:
-	void KAsteriskConsole::verboser(char *stuff, int opos, int replacelast, int complete);
-	QPushButton *btnExit;
-	KMenuBar *menu;
-	QPopupMenu *file, *help;
-};
-/*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * KDE Console monitor -- Header file
- * 
  * Copyright (C) 1999, Mark Spencer
  *
  * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;

Modified: trunk/pbx/pbx_kdeconsole_main.cc
===================================================================
--- trunk/pbx/pbx_kdeconsole_main.cc	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/pbx/pbx_kdeconsole_main.cc	2006-07-05 21:55:19 UTC (rev 423)
@@ -3,87 +3,6 @@
  *
  * KDE Console monitor -- Mostly glue code
  * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/module.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;pthread.h&gt;
-#include &quot;pbx_kdeconsole.h&quot;
-
-static char *dtext = &quot;KDE Console Monitor&quot;;
-
-static int inuse = 0;
-
-static KAsteriskConsole *w;
-
-static void verboser(char *stuff, int opos, int replacelast, int complete)
-{
-	const char *s2[2];
-	s2[0] = stuff;
-	s2[1] = NULL;
-	if (replacelast)  {
-		printf(&quot;Removing %d\n&quot;, w-&gt;verbose-&gt;count());
-		w-&gt;verbose-&gt;removeItem(w-&gt;verbose-&gt;count());
-	}
-	w-&gt;verbose-&gt;insertStrList(s2, 1, -1);
-	w-&gt;verbose-&gt;setBottomItem(w-&gt;verbose-&gt;count());
-}
-
-static int kde_main(int argc, char *argv[])
-{
-	KApplication a ( argc, argv );
-	w = new KAsteriskConsole();
-	a.setMainWidget(w);
-	w-&gt;show();
-	ast_register_verbose(verboser);
-	return a.exec();
-}
-
-static void *kdemain(void *data)
-{
-	/* It would appear kde really wants to be main */;
-	char *argv[1] = { &quot;asteriskconsole&quot; };
-	kde_main(1, argv);
-	return NULL;
-}
-
-extern &quot;C&quot; {
-
-int unload_module(void)
-{
-	return inuse;
-}
-
-int load_module(void)
-{
-	pthread_t t;
-	pthread_create(&amp;t, NULL, kdemain, NULL);
-	return 0;
-}
-
-int usecount(void)
-{
-	return inuse;
-}
-
-char *description(void)
-{
-	return dtext;
-}
-
-}
-/*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * KDE Console monitor -- Mostly glue code
- * 
  * Copyright (C) 1999, Mark Spencer
  *
  * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;

Modified: trunk/pbx.c
===================================================================
--- trunk/pbx.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/pbx.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,862 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Core PBX routines.
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;pthread.h&gt;
-#include &lt;asterisk/pbx.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/file.h&gt;
-#include &lt;string.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;stdio.h&gt;
-#include &lt;setjmp.h&gt;
-#include &lt;ctype.h&gt;
-
-
-/*
- * I M P O R T A N T :
- *
- *		The speed of extension handling will likely be among the most important
- * aspects of this PBX.  The switching scheme as it exists right now isn't
- * terribly bad (it's O(N+M), where N is the # of extensions and M is the avg #
- * of priorities, but a constant search time here would be great ;-) 
- *
- */
-
-
-struct ast_context;
-
-struct ast_pbx {
-	int dtimeout;					/* Timeout between digits (seconds) */
-	int rtimeout;					/* Timeout for response (seconds) */
-};
-
-/* An extension */
-struct ast_exten {
-	char exten[AST_MAX_EXTENSION];
-	int priority;
-	/* An extension */
-	struct ast_context *parent;
-	/* Application to execute */
-	char app[AST_MAX_EXTENSION];
-	/* Data to use */
-	void *data;
-	/* Data destructor */
-	void (*datad)(void *);
-	/* Next highest priority with our extension */
-	struct ast_exten *peer;
-	/* Extension with a greater ID */
-	struct ast_exten *next;
-};
-
-/* An extension context */
-struct ast_context {
-	/* Name of the context */
-	char name[AST_MAX_EXTENSION];
-	/* A lock to prevent multiple threads from clobbering the context */
-	pthread_mutex_t lock;
-	/* The root of the list of extensions */
-	struct ast_exten *root;
-	/* Link them together */
-	struct ast_context *next;
-};
-
-
-/* An application */
-struct ast_app {
-	/* Name of the application */
-	char name[AST_MAX_APP];
-	int (*execute)(struct ast_channel *chan, void *data);
-	struct ast_app *next;
-};
-
-static int pbx_builtin_answer(struct ast_channel *, void *);
-static int pbx_builtin_goto(struct ast_channel *, void *);
-static int pbx_builtin_hangup(struct ast_channel *, void *);
-static int pbx_builtin_background(struct ast_channel *, void *);
-static int pbx_builtin_dtimeout(struct ast_channel *, void *);
-static int pbx_builtin_rtimeout(struct ast_channel *, void *);
-static int pbx_builtin_wait(struct ast_channel *, void *);
-
-static struct pbx_builtin {
-	char name[AST_MAX_APP];
-	int (*execute)(struct ast_channel *chan, void *data);
-} builtins[] = 
-{
-	/* These applications are built into the PBX core and do not
-	   need separate modules */
-	{ &quot;Answer&quot;, pbx_builtin_answer },
-	{ &quot;Goto&quot;, pbx_builtin_goto },
-	{ &quot;Hangup&quot;, pbx_builtin_hangup },
-	{ &quot;DigitTimeout&quot;, pbx_builtin_dtimeout },
-	{ &quot;ResponseTimeout&quot;, pbx_builtin_rtimeout },
-	{ &quot;BackGround&quot;, pbx_builtin_background },
-	{ &quot;Wait&quot;, pbx_builtin_wait },
-};
-
-/* Lock for the application list */
-static pthread_mutex_t applock = PTHREAD_MUTEX_INITIALIZER;
-static struct ast_context *contexts = NULL;
-/* Lock for the ast_context list */
-static pthread_mutex_t conlock = PTHREAD_MUTEX_INITIALIZER;
-static struct ast_app *apps = NULL;
-
-static int pbx_exec(struct ast_channel *c, /* Channel */
-					int (*execute)(struct ast_channel *chan, void *data), 
-					void *data,				/* Data for execution */
-					int newstack)			/* Force stack increment */
-{
-	/* This function is special.  It saves the stack so that no matter
-	   how many times it is called, it returns to the same place */
-	int res;
-	int stack = c-&gt;stack;
-	if (newstack &amp;&amp; stack &gt; AST_CHANNEL_MAX_STACK - 2) {
-		/* Don't allow us to go over the max number of stacks we
-		   permit saving. */
-		ast_log(LOG_WARNING, &quot;Stack overflow, cannot create another stack\n&quot;);
-		return -1;
-	}
-	if (newstack &amp;&amp; (res = setjmp(c-&gt;jmp[++c-&gt;stack]))) {
-		/* Okay, here's where it gets weird.  If newstack is non-zero, 
-		   then we increase the stack increment, but setjmp is not going
-		   to return until longjmp is called -- when the application
-		   exec'd is finished running. */
-		if (res == 1)
-			res = 0;
-		if (c-&gt;stack != stack + 1) 
-			ast_log(LOG_WARNING, &quot;Stack returned to an unexpected place!\n&quot;);
-		else if (c-&gt;app[c-&gt;stack])
-			ast_log(LOG_WARNING, &quot;Application may have forgotten to free its memory\n&quot;);
-		c-&gt;stack = stack;
-		return res;
-	} else {
-		res = execute(c, data);
-		/* Any application that returns, we longjmp back, just in case. */
-		if (c-&gt;stack != stack + 1)
-			ast_log(LOG_WARNING, &quot;Stack is not at expected value\n&quot;);
-		longjmp(c-&gt;jmp[stack+1], res);
-		/* Never returns */
-	}
-}
-
-
-#define HELPER_EXISTS 0
-#define HELPER_SPAWN 1
-#define HELPER_EXEC 2
-
-static struct ast_app *pbx_findapp(char *app) 
-{
-	struct ast_app *tmp;
-	if (pthread_mutex_lock(&amp;applock)) {
-		ast_log(LOG_WARNING, &quot;Unable to obtain application lock\n&quot;);
-		return NULL;
-	}
-	tmp = apps;
-	while(tmp) {
-		if (!strcasecmp(tmp-&gt;name, app))
-			break;
-		tmp = tmp-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;applock);
-	return tmp;
-}
-
-static void pbx_destroy(struct ast_pbx *p)
-{
-	free(p);
-}
-
-int extension_match(char *pattern, char *data)
-{
-	int match;
-	/* If they're the same return */
-	if (!strcasecmp(pattern, data))
-		return 1;
-	/* All patterns begin with _ */
-	if (pattern[0] != '_') 
-		return 0;
-	/* Obviously must be the same length */
-	if (strlen(pattern) != strlen(data) + 1)
-		return 0;
-	/* Start optimistic */
-	match=1;
-	pattern++;
-	while(match &amp;&amp; *data &amp;&amp; *pattern) {
-		switch(toupper(*pattern)) {
-		case 'N':
-			if ((*data &lt; '2') || (*data &gt; '9'))
-				match=0;
-			break;
-		case 'X':
-			if ((*data &lt; '0') || (*data &gt; '9'))
-				match = 0;
-			break;
-		default:
-			if (*data != *pattern)
-				match =0;
-		}
-		data++;
-		pattern++;
-	}
-	return match;
-}
-
-static int pbx_extension_helper(struct ast_channel *c, char *context, char *exten, int priority, int action) 
-{
-	struct ast_context *tmp;
-	struct ast_exten *e;
-	struct ast_app *app;
-	int newstack = 0;
-	if (pthread_mutex_lock(&amp;conlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to obtain lock\n&quot;);
-		if (action == HELPER_EXISTS)
-			return 0;
-		else
-			return -1;
-	}
-	tmp = contexts;
-	while(tmp) {
-		if (!strcasecmp(tmp-&gt;name, context)) {
-			/* By locking tmp, not only can the state of its entries not
-			   change, but it cannot be destroyed either. */
-			pthread_mutex_lock(&amp;tmp-&gt;lock);
-			/* But we can relieve the conlock, as tmp will not change */
-			pthread_mutex_unlock(&amp;conlock);
-			e = tmp-&gt;root;
-			while(e) {
-				if (extension_match(e-&gt;exten, exten)) {
-					while(e) {
-						if (e-&gt;priority == priority) {
-							pthread_mutex_unlock(&amp;tmp-&gt;lock);
-							/* We have a winner! Maybe there are some races
-							   in here though. XXX */
-							switch(action) {
-							case HELPER_EXISTS:
-								return -1;
-							case HELPER_SPAWN:
-								newstack++;
-								/* Fall through */
-							case HELPER_EXEC:
-								app = pbx_findapp(e-&gt;app);
-								if (app) {
-									strncpy(c-&gt;context, context, sizeof(c-&gt;context));
-									strncpy(c-&gt;exten, exten, sizeof(c-&gt;exten));
-									c-&gt;priority = priority;
-									if (option_debug)
-										ast_log(LOG_DEBUG, &quot;Launching '%s'\n&quot;, app-&gt;name);
-									else if (option_verbose &gt; 2)
-										ast_verbose( VERBOSE_PREFIX_3 &quot;Executing %s(\&quot;%s\&quot;, \&quot;%s\&quot;) %s\n&quot;, 
-												app-&gt;name, c-&gt;name, (e-&gt;data ? (char *)e-&gt;data : NULL), (newstack ? &quot;in new stack&quot; : &quot;in same stack&quot;));
-									return pbx_exec(c, app-&gt;execute, e-&gt;data, newstack);
-								} else {
-									ast_log(LOG_WARNING, &quot;No application '%s' for extension (%s, %s, %d)\n&quot;, e-&gt;app, context, exten, priority);
-									return -1;
-								}
-							default:
-								ast_log(LOG_WARNING, &quot;Huh (%d)?\n&quot;, action);
-							}
-						}
-						e = e-&gt;peer;
-					}
-					pthread_mutex_unlock(&amp;tmp-&gt;lock);
-					if (action != HELPER_EXISTS) {
-						ast_log(LOG_WARNING, &quot;No such priority '%d' in '%s' in '%s'\n&quot;, priority, exten, context);
-						return -1;
-					} else
-						return 0;
-				}
-				e = e-&gt;next;
-			}
-			pthread_mutex_unlock(&amp;tmp-&gt;lock);
-			if (action != HELPER_EXISTS) {
-				ast_log(LOG_WARNING, &quot;No such extension '%s' in '%s'\n&quot;, exten, context);
-				return -1;
-			} else
-				return 0;
-		}
-		tmp = tmp-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;conlock);
-	if (action != HELPER_EXISTS) {
-		ast_log(LOG_WARNING, &quot;No such context '%s'\n&quot;, context);
-		return -1;
-	} else
-		return 0;
-}
-int ast_pbx_longest_extension(char *context) 
-{
-	struct ast_context *tmp;
-	struct ast_exten *e;
-	int len = 0;
-	if (pthread_mutex_lock(&amp;conlock)) {
-		ast_log(LOG_WARNING, &quot;Unable to obtain lock\n&quot;);
-		return -1;
-	}
-	tmp = contexts;
-	while(tmp) {
-		if (!strcasecmp(tmp-&gt;name, context)) {
-			/* By locking tmp, not only can the state of its entries not
-			   change, but it cannot be destroyed either. */
-			pthread_mutex_lock(&amp;tmp-&gt;lock);
-			/* But we can relieve the conlock, as tmp will not change */
-			pthread_mutex_unlock(&amp;conlock);
-			e = tmp-&gt;root;
-			while(e) {
-				if (strlen(e-&gt;exten) &gt; len)
-					len = strlen(e-&gt;exten);
-				e = e-&gt;next;
-			}
-			pthread_mutex_unlock(&amp;tmp-&gt;lock);
-			return len;
-		}
-		tmp = tmp-&gt;next;
-	}
-	ast_log(LOG_WARNING, &quot;No such context '%s'\n&quot;, context);
-	return -1;
-}
-
-int ast_exists_extension(struct ast_channel *c, char *context, char *exten, int priority) 
-{
-	return pbx_extension_helper(c, context, exten, priority, HELPER_EXISTS);
-}
-
-int ast_spawn_extension(struct ast_channel *c, char *context, char *exten, int priority) 
-{
-	return pbx_extension_helper(c, context, exten, priority, HELPER_SPAWN);
-}
-
-static void *pbx_thread(void *data)
-{
-	/* Oh joyeous kernel, we're a new thread, with nothing to do but
-	   answer this channel and get it going.  The setjmp stuff is fairly
-	   confusing, but necessary to get smooth transitions between
-	   the execution of different applications (without the use of
-	   additional threads) */
-	struct ast_channel *c = data;
-	int firstpass = 1;
-	char digit;
-	char exten[256];
-	int pos;
-	int waittime;
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;PBX_THREAD(%s)\n&quot;, c-&gt;name);
-	else if (option_verbose &gt; 1)
-		ast_verbose( VERBOSE_PREFIX_2 &quot;Accepting call on '%s'\n&quot;, c-&gt;name);
-		
-	
-	/* Start by trying whatever the channel is set to */
-	if (!ast_exists_extension(c, c-&gt;context, c-&gt;exten, c-&gt;priority)) {
-		strncpy(c-&gt;context, &quot;default&quot;, sizeof(c-&gt;context));
-		strncpy(c-&gt;exten, &quot;s&quot;, sizeof(c-&gt;exten));
-		c-&gt;priority = 1;
-	}
-	for(;;) {
-		memset(exten, 0, sizeof(exten));
-		pos = 0;
-		digit = 0;
-		while(ast_exists_extension(c, c-&gt;context, c-&gt;exten, c-&gt;priority)) {
-			if (ast_spawn_extension(c, c-&gt;context, c-&gt;exten, c-&gt;priority)) {
-				/* Something bad happened, or a hangup has been requested. */
-				if (option_debug)
-					ast_log(LOG_DEBUG, &quot;Spawn extension (%s,%s,%d) exited non-zero on '%s'\n&quot;, c-&gt;context, c-&gt;exten, c-&gt;priority, c-&gt;name);
-				else if (option_verbose &gt; 1)
-					ast_verbose( VERBOSE_PREFIX_2 &quot;Spawn extension (%s, %s, %d) exited non-zero on '%s'\n&quot;, c-&gt;context, c-&gt;exten, c-&gt;priority, c-&gt;name);
-				goto out;
-			}
-			/* If we're playing something in the background, wait for it to finish or for a digit */
-			if (c-&gt;stream) {
-				digit = ast_waitstream(c, AST_DIGIT_ANY);
-				ast_stopstream(c);
-				/* Hang up if something goes wrong */
-				if (digit &lt; 0)
-					goto out;
-				else if (digit) {
-					ast_stopstream(c);
-					exten[pos++] = digit;
-					break;
-				}
-			}
-			firstpass = 0;
-			c-&gt;priority++;
-		}
-		/* Done, wait for an extension */
-		if (digit)
-			waittime = c-&gt;pbx-&gt;dtimeout;
-		else
-			waittime = c-&gt;pbx-&gt;rtimeout;
-		while(!ast_exists_extension(c, c-&gt;context, exten, 1) &amp;&amp; (
-		       strlen(exten) &lt; ast_pbx_longest_extension(c-&gt;context))) {
-			/* As long as we're willing to wait, and as long as it's not defined, 
-			   keep reading digits until we can't possibly get a right answer anymore.  */
-			digit = ast_waitfordigit(c, waittime * 1000);
-			if (!digit)
-				/* No entry */
-				break;
-			if (digit &lt; 0)
-				/* Error, maybe a  hangup */
-				goto out;
-			exten[pos++] = digit;
-			waittime = c-&gt;pbx-&gt;dtimeout;
-		}
-		if (ast_exists_extension(c, c-&gt;context, exten, 1)) {
-			/* Prepare the next cycle */
-			strncpy(c-&gt;exten, exten, sizeof(c-&gt;exten));
-			c-&gt;priority = 1;
-		} else {
-			/* No such extension */
-			if (strlen(exten)) {
-				/* An invalid extension */
-				if (ast_exists_extension(c, c-&gt;context, &quot;i&quot;, 1)) {
-					if (option_verbose &gt; 2)
-						ast_verbose( VERBOSE_PREFIX_3 &quot;Invalid extension '%s' in context '%s' on %s\n&quot;, exten, c-&gt;context, c-&gt;name);
-					strncpy(c-&gt;exten, &quot;i&quot;, sizeof(c-&gt;exten));
-					c-&gt;priority = 1;
-				} else {
-					ast_log(LOG_WARNING, &quot;Invalid extension, but no rule 'i' in context '%s'\n&quot;, c-&gt;context);
-					goto out;
-				}
-			} else {
-				/* A simple timeout */
-				if (ast_exists_extension(c, c-&gt;context, &quot;t&quot;, 1)) {
-					if (option_verbose &gt; 2)
-						ast_verbose( VERBOSE_PREFIX_3 &quot;Timeout on %s\n&quot;, c-&gt;name);
-					strncpy(c-&gt;exten, &quot;t&quot;, sizeof(c-&gt;exten));
-					c-&gt;priority = 1;
-				} else {
-					ast_log(LOG_WARNING, &quot;Timeout, but no rule 't' in context '%s'\n&quot;, c-&gt;context);
-					goto out;
-				}
-			}	
-		}
-	}
-	if (firstpass) 
-		ast_log(LOG_WARNING, &quot;Don't know what to do with '%s'\n&quot;, c-&gt;name);
-out:
-	pbx_destroy(c-&gt;pbx);
-	c-&gt;pbx = NULL;
-	ast_hangup(c);
-	pthread_exit(NULL);
-	
-}
-
-int ast_pbx_start(struct ast_channel *c)
-{
-	pthread_t t;
-	if (!c) {
-		ast_log(LOG_WARNING, &quot;Asked to start thread on NULL channel?\n&quot;);
-		return -1;
-	}
-	if (c-&gt;pbx)
-		ast_log(LOG_WARNING, &quot;%s already has PBX structure??\n&quot;);
-	c-&gt;pbx = malloc(sizeof(struct ast_pbx));
-	if (!c-&gt;pbx) {
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-		return -1;
-	}
-	memset(c-&gt;pbx, 0, sizeof(struct ast_pbx));
-	/* Start a new thread, and get something handling this channel. */
-	if (pthread_create(&amp;t, NULL, pbx_thread, c)) {
-		ast_log(LOG_WARNING, &quot;Failed to create new channel thread\n&quot;);
-		return -1;
-	}
-	return 0;
-}
-#if 0
-int ast_remove_extension(struct ast_context *con, char *extension, int priority)
-{
-	/* XXX Implement me XXX */
-	return -1;
-}
-#endif
-int ast_register_application(char *app, int (*execute)(struct ast_channel *, void *))
-{
-	struct ast_app *tmp;
-	if (pthread_mutex_lock(&amp;applock)) {
-		ast_log(LOG_ERROR, &quot;Unable to lock application list\n&quot;);
-		return -1;
-	}
-	tmp = apps;
-	while(tmp) {
-		if (!strcasecmp(app, tmp-&gt;name)) {
-			ast_log(LOG_WARNING, &quot;Already have an application '%s'\n&quot;, app);
-			pthread_mutex_unlock(&amp;applock);
-			return -1;
-		}
-		tmp = tmp-&gt;next;
-	}
-	tmp = malloc(sizeof(struct ast_app));
-	if (tmp) {
-		strncpy(tmp-&gt;name, app, sizeof(tmp-&gt;name));
-		tmp-&gt;execute = execute;
-		tmp-&gt;next = apps;
-		apps = tmp;
-	} else {
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-		pthread_mutex_unlock(&amp;applock);
-		return -1;
-	}
-	if (option_verbose &gt; 1)
-		ast_verbose( VERBOSE_PREFIX_2 &quot;Registered application '%s'\n&quot;, tmp-&gt;name);
-	pthread_mutex_unlock(&amp;applock);
-	return 0;
-}
-
-int ast_unregister_application(char *app) {
-	struct ast_app *tmp, *tmpl = NULL;
-	if (pthread_mutex_lock(&amp;applock)) {
-		ast_log(LOG_ERROR, &quot;Unable to lock application list\n&quot;);
-		return -1;
-	}
-	tmp = apps;
-	while(tmp) {
-		if (!strcasecmp(app, tmp-&gt;name)) {
-			if (tmpl)
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				apps = tmp-&gt;next;
-			if (option_verbose &gt; 1)
-				ast_verbose( VERBOSE_PREFIX_2 &quot;Unregistered application '%s'\n&quot;, tmp-&gt;name);
-			pthread_mutex_unlock(&amp;applock);
-			return 0;
-		}
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;applock);
-	return -1;
-}
-
-struct ast_context *ast_context_create(char *name)
-{
-	struct ast_context *tmp;
-	
-	pthread_mutex_lock(&amp;conlock);
-	tmp = contexts;
-	while(tmp) {
-		if (!strcasecmp(tmp-&gt;name, name)) {
-			pthread_mutex_unlock(&amp;conlock);
-			ast_log(LOG_WARNING, &quot;Tried to register context '%s', already in use\n&quot;, name);
-			return NULL;
-		}
-		tmp = tmp-&gt;next;
-	}
-	tmp = malloc(sizeof(struct ast_context));
-	if (tmp) {
-		pthread_mutex_init(&amp;tmp-&gt;lock, NULL);
-		strncpy(tmp-&gt;name, name, sizeof(tmp-&gt;name));
-		tmp-&gt;root = NULL;
-		tmp-&gt;next = contexts;
-		contexts = tmp;
-		if (option_debug)
-			ast_log(LOG_DEBUG, &quot;Registered context '%s'\n&quot;, tmp-&gt;name);
-		else if (option_verbose &gt; 2)
-			ast_verbose( VERBOSE_PREFIX_3 &quot;Registered extension context '%s'\n&quot;, tmp-&gt;name);
-	} else
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-	
-	pthread_mutex_unlock(&amp;conlock);
-	return tmp;
-}
-
-int ast_add_extension2(struct ast_context *con,
-					  int replace, char *extension, int priority,
-					  char *application, void *data, void (*datad)(void *))
-{
-
-#define LOG { 	if (option_debug) \
-		ast_log(LOG_DEBUG, &quot;Added extension '%s' priority %d to %s\n&quot;, tmp-&gt;exten, tmp-&gt;priority, con-&gt;name); \
-	else if (option_verbose &gt; 2) \
-		ast_verbose( VERBOSE_PREFIX_3 &quot;Added extension '%s' priority %d to %s\n&quot;, tmp-&gt;exten, tmp-&gt;priority, con-&gt;name); \
-		}
-
-	/*
-	 * This is a fairly complex routine.  Different extensions are kept
-	 * in order by the extension number.  Then, extensions of different
-	 * priorities (same extension) are kept in a list, according to the
-	 * peer pointer.
-	 */
-	struct ast_exten *tmp, *e, *el = NULL, *ep = NULL;
-	int res;
-	/* Be optimistic:  Build the extension structure first */
-	tmp = malloc(sizeof(struct ast_exten));
-	if (tmp) {
-		strncpy(tmp-&gt;exten, extension, sizeof(tmp-&gt;exten));
-		tmp-&gt;priority = priority;
-		strncpy(tmp-&gt;app, application, sizeof(tmp-&gt;app));
-		tmp-&gt;data = data;
-		tmp-&gt;datad = datad;
-		tmp-&gt;peer = NULL;
-		tmp-&gt;next =  NULL;
-	} else {
-		ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-		return -1;
-	}
-	if (pthread_mutex_lock(&amp;con-&gt;lock)) {
-		free(tmp);
-		/* And properly destroy the data */
-		datad(data);
-		ast_log(LOG_WARNING, &quot;Failed to lock context '%s'\n&quot;, con-&gt;name);
-		return -1;
-	}
-	e = con-&gt;root;
-	while(e) {
-		res= strcasecmp(e-&gt;exten, extension);
-		if (res == 0) {
-			/* We have an exact match, now we find where we are
-			   and be sure there's no duplicates */
-			while(e) {
-				if (e-&gt;priority == tmp-&gt;priority) {
-					/* Can't have something exactly the same.  Is this a
-					   replacement?  If so, replace, otherwise, bonk. */
-					if (replace) {
-						if (ep) {
-							/* We're in the peer list, insert ourselves */
-							ep-&gt;peer = tmp;
-							tmp-&gt;peer = e-&gt;peer;
-						} else if (el) {
-							/* We're the first extension. Take over e's functions */
-							el-&gt;next = tmp;
-							tmp-&gt;next = e-&gt;next;
-							tmp-&gt;peer = e-&gt;peer;
-						} else {
-							/* We're the very first extension.  */
-							con-&gt;root = tmp;
-							tmp-&gt;next = e-&gt;next;
-							tmp-&gt;peer = e-&gt;peer;
-						}
-						/* Destroy the old one */
-						e-&gt;datad(e-&gt;data);
-						free(e);
-						pthread_mutex_unlock(&amp;con-&gt;lock);
-						/* And immediately return success. */
-						LOG;
-						return 0;
-					} else {
-						ast_log(LOG_WARNING, &quot;Unable to register extension '%s', priority %d in '%s', already in use\n&quot;, tmp-&gt;exten, tmp-&gt;priority, con-&gt;name);
-						tmp-&gt;datad(tmp-&gt;data);
-						free(tmp);
-						pthread_mutex_unlock(&amp;con-&gt;lock);
-						return -1;
-					}
-				} else if (e-&gt;priority &gt; tmp-&gt;priority) {
-					/* Slip ourselves in just before e */
-					if (ep) {
-						/* Easy enough, we're just in the peer list */
-						ep-&gt;peer = tmp;
-						tmp-&gt;peer = e;
-					} else if (el) {
-						/* We're the first extension in this peer list */
-						el-&gt;next = tmp;
-						tmp-&gt;next = e-&gt;next;
-						e-&gt;next = NULL;
-						tmp-&gt;peer = e;
-					} else {
-						/* We're the very first extension altogether */
-						tmp-&gt;next = con-&gt;root;
-						/* Con-&gt;root must always exist or we couldn't get here */
-						tmp-&gt;peer = con-&gt;root-&gt;peer;
-						con-&gt;root = tmp;
-					}
-					pthread_mutex_unlock(&amp;con-&gt;lock);
-					/* And immediately return success. */
-					LOG;
-					return 0;
-				}
-				ep = e;
-				e = e-&gt;peer;
-			}
-			/* If we make it here, then it's time for us to go at the very end.
-			   ep *must* be defined or we couldn't have gotten here. */
-			ep-&gt;peer = tmp;
-			pthread_mutex_unlock(&amp;con-&gt;lock);
-			/* And immediately return success. */
-			LOG;
-			return 0;
-				
-		} else if (res &gt; 0) {
-			/* Insert ourselves just before 'e'.  We're the first extension of
-			   this kind */
-			tmp-&gt;next = e;
-			if (el) {
-				/* We're in the list somewhere */
-				el-&gt;next = tmp;
-			} else {
-				/* We're at the top of the list */
-				con-&gt;root = tmp;
-			}
-			pthread_mutex_unlock(&amp;con-&gt;lock);
-			/* And immediately return success. */
-			LOG;
-			return 0;
-		}			
-			
-		el = e;
-		e = e-&gt;next;
-	}
-	/* If we fall all the way through to here, then we need to be on the end. */
-	if (el)
-		el-&gt;next = tmp;
-	else
-		con-&gt;root = tmp;
-	pthread_mutex_unlock(&amp;con-&gt;lock);
-	LOG;
-	return 0;	
-}
-
-void ast_context_destroy(struct ast_context *con)
-{
-	struct ast_context *tmp, *tmpl=NULL;
-	pthread_mutex_lock(&amp;conlock);
-	tmp = contexts;
-	while(tmp) {
-		if (tmp == con) {
-			/* Okay, let's lock the structure to be sure nobody else
-			   is searching through it. */
-			if (pthread_mutex_lock(&amp;tmp-&gt;lock)) {
-				ast_log(LOG_WARNING, &quot;Unable to lock context lock\n&quot;);
-				return;
-			}
-			if (tmpl)
-				tmpl-&gt;next = tmp-&gt;next;
-			else
-				contexts = tmp-&gt;next;
-			/* Okay, now we're safe to let it go -- in a sense, we were
-			   ready to let it go as soon as we locked it. */
-			pthread_mutex_unlock(&amp;tmp-&gt;lock);
-			free(tmp);
-			pthread_mutex_unlock(&amp;conlock);
-			return;
-		}
-		tmpl = tmp;
-		tmp = tmp-&gt;next;
-	}
-	pthread_mutex_unlock(&amp;conlock);
-}
-
-int pbx_builtin_answer(struct ast_channel *chan, void *data)
-{
-	if (chan-&gt;state != AST_STATE_RING) {
-		ast_log(LOG_WARNING, &quot;Ignoring answer request since line is not ringing\n&quot;);
-		return 0;
-	} else
-		return ast_answer(chan);
-}
-
-int pbx_builtin_hangup(struct ast_channel *chan, void *data)
-{
-	/* Just return non-zero and it will hang up */
-	return -1;
-}
-
-int pbx_builtin_wait(struct ast_channel *chan, void *data)
-{
-	/* Wait for &quot;n&quot; seconds */
-	if (data &amp;&amp; atoi((char *)data))
-		sleep(atoi((char *)data));
-	return 0;
-}
-
-int pbx_builtin_background(struct ast_channel *chan, void *data)
-{
-	int res;
-	/* Stop anything playing */
-	ast_stopstream(chan);
-	/* Stream a file */
-	res = ast_streamfile(chan, (char *)data);
-	return res;
-}
-
-int pbx_builtin_rtimeout(struct ast_channel *chan, void *data)
-{
-	/* Set the timeout for how long to wait between digits */
-	chan-&gt;pbx-&gt;rtimeout = atoi((char *)data);
-	if (option_verbose &gt; 2)
-		ast_verbose( VERBOSE_PREFIX_3 &quot;Set Response Timeout to %d\n&quot;, chan-&gt;pbx-&gt;rtimeout);
-	return 0;
-}
-
-int pbx_builtin_dtimeout(struct ast_channel *chan, void *data)
-{
-	/* Set the timeout for how long to wait between digits */
-	chan-&gt;pbx-&gt;dtimeout = atoi((char *)data);
-	if (option_verbose &gt; 2)
-		ast_verbose( VERBOSE_PREFIX_3 &quot;Set Digit Timeout to %d\n&quot;, chan-&gt;pbx-&gt;dtimeout);
-	return 0;
-}
-
-int pbx_builtin_goto(struct ast_channel *chan, void *data)
-{
-	char *s;
-	char *exten, *pri, *context;
-	if (!data) {
-		ast_log(LOG_WARNING, &quot;Goto requires an argument (optional context|optional extension|priority)\n&quot;);
-		return -1;
-	}
-	s = strdup((void *) data);
-	context = strtok(s, &quot;|&quot;);
-	exten = strtok(NULL, &quot;|&quot;);
-	if (!exten) {
-		/* Only a priority in this one */
-		pri = context;
-		exten = NULL;
-		context = NULL;
-	} else {
-		pri = strtok(NULL, &quot;|&quot;);
-		if (!pri) {
-			/* Only an extension and priority in this one */
-			pri = exten;
-			exten = context;
-			context = NULL;
-		}
-	}
-	if (atoi(pri) &lt; 0) {
-		ast_log(LOG_WARNING, &quot;Priority '%s' must be a number &gt; 0\n&quot;, pri);
-		free(s);
-		return -1;
-	}
-	/* At this point we have a priority and maybe an extension and a context */
-	chan-&gt;priority = atoi(pri) - 1;
-	if (exten)
-		strncpy(chan-&gt;exten, exten, sizeof(chan-&gt;exten));
-	if (context)
-		strncpy(chan-&gt;context, context, sizeof(chan-&gt;context));
-	if (option_verbose &gt; 2)
-		ast_verbose( VERBOSE_PREFIX_3 &quot;Goto (%s,%s,%d)\n&quot;, chan-&gt;context,chan-&gt;exten, chan-&gt;priority+1);
-	return 0;
-}
-
-int load_pbx(void)
-{
-	int x;
-	/* Initialize the PBX */
-	if (option_verbose) {
-		ast_verbose( &quot;Asterisk PBX Core Initializing\n&quot;);
-		ast_verbose( &quot;Registering builtin applications:\n&quot;);
-	}
-	for (x=0;x&lt;sizeof(builtins) / sizeof(struct pbx_builtin); x++) {
-		if (option_verbose)
-			ast_verbose( VERBOSE_PREFIX_1 &quot;[%s]\n&quot;, builtins[x].name);
-		if (ast_register_application(builtins[x].name, builtins[x].execute)) {
-			ast_log(LOG_ERROR, &quot;Unable to register builtin application '%s'\n&quot;, builtins[x].name);
-			return -1;
-		}
-	}
-	return 0;
-}
-
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.

Modified: trunk/say.c
===================================================================
--- trunk/say.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/say.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,71 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Say numbers and dates (maybe words one day too)
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/file.h&gt;
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/say.h&gt;
-#include &lt;stdio.h&gt;
-
-int ast_say_digit_str(struct ast_channel *chan, char *fn2)
-{
-	char fn[256] = &quot;&quot;;
-	int num = 0;
-	int res = 0;
-	while(fn2[num] &amp;&amp; !res) {
-		snprintf(fn, sizeof(fn), &quot;digits/%c&quot;, fn2[num]);
-		res = ast_streamfile(chan, fn);
-		if (!res) 
-			res = ast_waitstream(chan, AST_DIGIT_ANY);
-		ast_stopstream(chan);
-		num++;
-	}
-	return res;
-}
-
-int ast_say_digits(struct ast_channel *chan, int num)
-{
-	char fn2[256];
-	snprintf(fn2, sizeof(fn2), &quot;%d&quot;, num);
-	return ast_say_digit_str(chan, fn2);
-}
-int ast_say_number(struct ast_channel *chan, int num)
-{
-	int res = 0;
-	char fn[256] = &quot;&quot;;
-	while(num &amp;&amp; !res) {
-		if (num &lt; 20) {
-			snprintf(fn, sizeof(fn), &quot;digits/%d&quot;, num);
-			num = 0;
-		} else
-		if (num &lt; 100) {
-			snprintf(fn, sizeof(fn), &quot;digits/%d&quot;, (num /10) * 10);
-			num -= ((num / 10) * 10);
-		} else {
-			ast_log(LOG_DEBUG, &quot;Number '%d' is too big for me\n&quot;, num);
-			res = -1;
-		}
-		if (!res) {
-			res = ast_streamfile(chan, fn);
-			if (!res) 
-				res = ast_waitstream(chan, AST_DIGIT_ANY);
-			ast_stopstream(chan);
-		}
-		
-	}
-	return res;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2005, Digium, Inc.

Modified: trunk/translate.c
===================================================================
--- trunk/translate.c	2006-06-28 11:25:38 UTC (rev 422)
+++ trunk/translate.c	2006-07-05 21:55:19 UTC (rev 423)
@@ -1,604 +1,4 @@
 /*
- * Asterisk -- A telephony toolkit for Linux.
- *
- * Translate via the use of pseudo channels
- * 
- * Copyright (C) 1999, Adtran Inc. and Linux Support Services, LLC
- *
- * Mark Spencer &lt;<A HREF="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">markster at linux-support.net</A>&gt;
- *
- * This program is free software, distributed under the terms of
- * the GNU General Public License
- */
-
-#include &lt;asterisk/channel.h&gt;
-#include &lt;asterisk/channel_pvt.h&gt;
-#include &lt;asterisk/logger.h&gt;
-#include &lt;asterisk/translate.h&gt;
-#include &lt;asterisk/options.h&gt;
-#include &lt;sys/socket.h&gt;
-#include &lt;sys/time.h&gt;
-#include &lt;unistd.h&gt;
-#include &lt;stdlib.h&gt;
-#include &lt;pthread.h&gt;
-#include &lt;string.h&gt;
-#include &lt;stdio.h&gt;
-
-static char *type = &quot;Trans&quot;;
-
-static pthread_mutex_t list_lock = PTHREAD_MUTEX_INITIALIZER;
-static struct ast_translator *list = NULL;
-
-struct ast_translator_dir {
-	struct ast_translator *step;	/* Next step translator */
-	int cost;						/* Complete cost to destination */
-};
-
-static struct ast_translator_dir tr_matrix[MAX_FORMAT][MAX_FORMAT];
-
-struct ast_trans_pvt {
-	struct ast_translator *step;
-	struct ast_translator_pvt *state;
-	struct ast_trans_pvt *next;
-};
-
-
-static int powerof(int d)
-{
-	int x;
-	for (x = 0; x &lt; 32; x++)
-		if ((1 &lt;&lt; x) &amp; d)
-			return x;
-	ast_log(LOG_WARNING, &quot;Powerof %d: No power??\n&quot;, d);
-	return -1;
-}
-
-struct translator_pvt {
-	/* Sockets for communication */
-	int comm[2];
-	struct ast_trans_pvt *system;
-	struct ast_trans_pvt *rsystem;
-};
-
-static int translator_hangup(struct ast_channel *chan)
-{
-	ast_log(LOG_WARNING, &quot;Explicit hangup on '%s' not recommended!  Call translator_destroy() instead.\n&quot;, chan-&gt;name);
-	chan-&gt;master-&gt;trans = NULL;
-	ast_hangup(chan-&gt;master);
-	chan-&gt;master = NULL;
-	return 0;
-}
-
-static int translator_send_digit(struct ast_channel *chan, char digit)
-{
-	/* Pass digits right along */
-	if (chan-&gt;master-&gt;pvt-&gt;send_digit)
-		return chan-&gt;master-&gt;pvt-&gt;send_digit(chan-&gt;master, digit);
-	return -1;
-}
-
-static int translator_call(struct ast_channel *chan, char *addr, int timeout)
-{
-	if (chan-&gt;master-&gt;pvt-&gt;call)
-		return chan-&gt;master-&gt;pvt-&gt;call(chan-&gt;master, addr, timeout);
-	return -1;
-}
-
-static int translator_answer(struct ast_channel *chan)
-{
-	if (chan-&gt;master-&gt;pvt-&gt;answer)
-		return chan-&gt;master-&gt;pvt-&gt;answer(chan-&gt;master);
-	return -1;
-}
-
-void ast_translator_free_path(struct ast_trans_pvt *p)
-{
-	struct ast_trans_pvt *pl;
-	while(p) {
-		pl = p;
-		p = p-&gt;next;
-		if (pl-&gt;state &amp;&amp; pl-&gt;step-&gt;destroy)
-			pl-&gt;step-&gt;destroy(pl-&gt;state);
-		free(pl);
-	}
-}
-
-static void ast_translator_free(struct translator_pvt *pvt)
-{
-	ast_translator_free_path(pvt-&gt;system);
-	ast_translator_free_path(pvt-&gt;rsystem);
-	if (pvt-&gt;comm[0] &gt; -1)
-		close(pvt-&gt;comm[0]);
-	if (pvt-&gt;comm[1] &gt; -1)
-		close(pvt-&gt;comm[1]);
-	free(pvt);
-}
-
-struct ast_trans_pvt *ast_translator_build_path(int source, int dest)
-{
-	struct ast_trans_pvt *tmpr = NULL, *tmp = NULL;
-	/* One of the hardest parts:  Build a set of translators based upon
-	   the given source and destination formats */
-	source = powerof(source);
-	dest = powerof(dest);
-	while(source != dest) {
-		if (tr_matrix[source][dest].step) {
-			if (tmp) {
-				tmp-&gt;next = malloc(sizeof(struct ast_trans_pvt));
-				tmp = tmp-&gt;next;
-			} else
-				tmp = malloc(sizeof(struct ast_trans_pvt));
-
-				
-			if (tmp) {
-				tmp-&gt;next = NULL;
-				tmp-&gt;step = tr_matrix[source][dest].step;
-				tmp-&gt;state = tmp-&gt;step-&gt;new();
-				if (!tmp-&gt;state) {
-					free(tmp);
-					tmp = NULL;
-				}
-				/* Set the root, if it doesn't exist yet... */
-				if (!tmpr)
-					tmpr = tmp;
-				/* Keep going if this isn't the final destination */
-				source = tmp-&gt;step-&gt;dstfmt;
-			} else {
-				/* XXX This could leak XXX */
-				ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-				return NULL;
-			}
-		}
-	}
-	return tmpr;
-}
-
-static struct ast_frame *fd_read(int fd)
-{
-	/* XXX Wrong: Not thread safe! XXX */
-	char buf[4096];
-	int res;
-	struct ast_frame *f = (struct ast_frame *)buf;
-	/* Read a frame directly from there.  They're always in the
-	   right format. */
-	
-	if (read(fd, buf, sizeof(struct ast_frame)) 
-						== sizeof(struct ast_frame)) {
-		/* read the frame header */
-		f-&gt;mallocd = 0;
-		f-&gt;data = buf + sizeof(struct ast_frame) + AST_FRIENDLY_OFFSET;
-		f-&gt;offset = AST_FRIENDLY_OFFSET;
-		if (f-&gt;datalen &gt; sizeof(buf) - sizeof(struct ast_frame) - AST_FRIENDLY_OFFSET) {
-			/* Really bad read */
-			ast_log(LOG_WARNING, &quot;Strange read (%d bytes)\n&quot;, f-&gt;datalen);
-			return NULL;
-		}
-		if (f-&gt;datalen) {
-			if ((res = read(fd, f-&gt;data, f-&gt;datalen)) != f-&gt;datalen) {
-				/* Bad read */
-				ast_log(LOG_WARNING, &quot;How very strange, expected %d, got %d\n&quot;, f-&gt;datalen, res);
-				return NULL;
-			}
-		}
-		return ast_frisolate(f);
-	} else if (option_debug)
-		ast_log(LOG_DEBUG, &quot;NULL or invalid header\n&quot;);
-	/* Null if there was an error */
-	return NULL;
-}
-
-static struct ast_frame *translator_read(struct ast_channel *chan)
-{
-	return fd_read(chan-&gt;fd);
-}
-
-static int fd_write(int fd, struct ast_frame *frame)
-{
-	/* Write the frame exactly */
-	if (write(fd, frame, sizeof(struct ast_frame)) != sizeof(struct ast_frame)) {
-		ast_log(LOG_WARNING, &quot;Write error\n&quot;);
-		return -1;
-	}
-	if (write(fd, frame-&gt;data, frame-&gt;datalen) != frame-&gt;datalen) {
-		ast_log(LOG_WARNING, &quot;Write error\n&quot;);
-		return -1;
-	}
-	return 0;
-}
-
-static int translator_write(struct ast_channel *chan, struct ast_frame *frame)
-{
-	return fd_write(chan-&gt;fd, frame);
-}
-
-struct ast_frame_chain *ast_translate(struct ast_trans_pvt *path, struct ast_frame *f)
-{
-	struct ast_trans_pvt *p;
-	struct ast_frame *out;
-	struct ast_frame_chain *outc = NULL, *prev = NULL, *cur;
-	p = path;
-	/* Feed the first frame into the first translator */
-	p-&gt;step-&gt;framein(p-&gt;state, f);
-	while(p) {
-		/* Read all the frames from the current translator */
-		while((out = p-&gt;step-&gt;frameout(p-&gt;state)))  {
-			if (p-&gt;next) {
-				/* Feed to next layer */
-				p-&gt;next-&gt;step-&gt;framein(p-&gt;next-&gt;state, out);
-			} else {
-				/* Last layer -- actually do something */
-				cur = malloc(sizeof(struct ast_frame_chain));
-				if (!cur) {
-					/* XXX Leak majorly on a problem XXX */
-					ast_log(LOG_WARNING, &quot;Out of memory\n&quot;);
-					return NULL;
-				}
-				if (prev) 
-					prev-&gt;next = cur;
-				else
-					outc = cur;
-				cur-&gt;fr = ast_frisolate(out);
-				cur-&gt;next = NULL;
-				if (prev)
-					prev = prev-&gt;next;
-				else
-					prev = outc;
-			}
-		}
-		p = p-&gt;next;
-	}
-	return outc;
-}
-
-/* XXX There's an experimentally derived fudge factor XXX */
-#define FUDGE 4
-
-static void translator_apply(struct ast_trans_pvt *path, struct ast_frame *f, int fd, struct ast_channel *c)
-{
-	struct ast_trans_pvt *p;
-	struct ast_frame *out;
-	p = path;
-	/* Feed the first frame into the first translator */
-	p-&gt;step-&gt;framein(p-&gt;state, f);
-	while(p) {
-		/* Read all the frames from the current translator */
-		while((out = p-&gt;step-&gt;frameout(p-&gt;state)))  {
-			if (p-&gt;next) {
-				/* Feed to next layer */
-				p-&gt;next-&gt;step-&gt;framein(p-&gt;next-&gt;state, out);
-			} else {
-				if (c)
-					ast_write(c, out);
-				else
-					fd_write(fd, out);
-			}
-		}
-		p = p-&gt;next;
-	}
-}
-
-static void *translator_thread(void *data)
-{
-	struct ast_channel *real = data;
-	struct ast_frame *f;
-	int ms = -1;
-	struct translator_pvt *pvt = NULL;
-	int fd = -1;
-	int fds[2];
-	int res;
-	/* Read from the real, translate, write as necessary to the fake */
-	for(;;) {
-		if (!real-&gt;trans) {
-			ast_log(LOG_WARNING, &quot;No translator anymore\n&quot;);
-			break;
-		}
-		pvt = real-&gt;trans-&gt;pvt-&gt;pvt;
-		fd = pvt-&gt;comm[1];
-		fds[0] = fd;
-		fds[1] = real-&gt;fd;
-		CHECK_BLOCKING(real);
-		res = ast_waitfor_n_fd(fds, 2, &amp;ms);
-		real-&gt;blocking = 0;
-		if (res &gt;= 0) {
-			if (res == real-&gt;fd) {
-				f = ast_read(real);
-				if (!f) {
-					if (option_debug)
-						ast_log(LOG_DEBUG, &quot;Empty frame\n&quot;);
-					break;
-				}
-				if (f-&gt;frametype ==  AST_FRAME_VOICE) {
-					if (pvt-&gt;system)
-						translator_apply(pvt-&gt;system, f, fd, NULL);
-				} else {
-					/* If it's not voice, just pass it along */
-					fd_write(fd, f);
-				}
-				ast_frfree(f);
-			} else {
-				f = fd_read(res);
-				if (!f) {
-					if (option_debug)
-						ast_log(LOG_DEBUG, &quot;Empty (hangup) frame\n&quot;);
-					break;
-				}
-				if (f-&gt;frametype == AST_FRAME_VOICE) {
-					if (pvt-&gt;rsystem)
-						translator_apply(pvt-&gt;rsystem, f, -1, real);
-				} else {
-					ast_write(real, f);
-				}
-				ast_frfree(f);
-			}
-		} else {
-			ast_log(LOG_DEBUG, &quot;Waitfor returned non-zero\n&quot;);
-			break;
-		}
-	}
-	if (pvt)
-		pvt-&gt;comm[1] = -1;
-	if (fd &gt; -1) {
-		/* Write a bogus frame */
-		write(fd, data, 1);
-		close(fd);
-	}
-	return NULL;
-}
-
-struct ast_channel *ast_translator_create(struct ast_channel *real, int format, int direction)
-{
-	struct ast_channel *tmp;
-	struct translator_pvt *pvt;
-	pthread_t t;
-	if (real-&gt;trans) {
-		ast_log(LOG_WARNING, &quot;Translator already exists on '%s'\n&quot;, real-&gt;name);
-		return NULL;
-	}
-	if (!(pvt = malloc(sizeof(struct translator_pvt)))) {
-		ast_log(LOG_WARNING, &quot;Unable to allocate private translator on '%s'\n&quot;, real-&gt;name);
-		return NULL;
-	}
-	pvt-&gt;comm[0] = -1;
-	pvt-&gt;comm[1] = -1;
-	if (socketpair(AF_UNIX, SOCK_DGRAM, 0, pvt-&gt;comm)) {
-		ast_log(LOG_WARNING, &quot;Unable to create UNIX domain socket on '%s'\n&quot;, real-&gt;name);
-		ast_translator_free(pvt);
-	}
-	/* In to the system */
-	if (direction &amp; AST_DIRECTION_IN)
-		pvt-&gt;system = ast_translator_build_path(real-&gt;format, format);
-	else
-		pvt-&gt;system = NULL;
-	/* Out from the system */
-	if (direction &amp; AST_DIRECTION_OUT)
-		pvt-&gt;rsystem = ast_translator_build_path(format, real-&gt;format);
-	else
-		pvt-&gt;rsystem = NULL;
-	if (!pvt-&gt;system &amp;&amp; !pvt-&gt;rsystem) {
-		ast_log(LOG_WARNING, &quot;Unable to build a translation path for %s (%d to %d)\n&quot;, real-&gt;name, real-&gt;format, format);
-		ast_translator_free(pvt);
-		return NULL;
-	}
-	if (!pvt-&gt;system &amp;&amp; (direction &amp; AST_DIRECTION_IN)) {
-		ast_log(LOG_WARNING, &quot;Translation path for '%s' is one-way (reverse)\n&quot;, real-&gt;name);
-		ast_translator_free(pvt);
-		return NULL;
-	}
-	if (!pvt-&gt;rsystem &amp;&amp; (direction &amp; AST_DIRECTION_OUT)) {
-		ast_log(LOG_WARNING, &quot;Translation path for '%s' is one-way (forward)\n&quot;, real-&gt;name);
-		ast_translator_free(pvt);
-		return NULL;
-	}
-	if ((tmp = ast_channel_alloc())) {
-		snprintf(tmp-&gt;name, sizeof(tmp-&gt;name), &quot;%s/Translate:%d&quot;, real-&gt;name, format);
-		tmp-&gt;type = type;
-		tmp-&gt;fd = pvt-&gt;comm[0];
-		tmp-&gt;format = format;
-		tmp-&gt;state = real-&gt;state;
-		tmp-&gt;rings = 0;
-		tmp-&gt;pvt-&gt;pvt = pvt;
-		tmp-&gt;master = real;
-		tmp-&gt;pvt-&gt;send_digit = translator_send_digit;
-		tmp-&gt;pvt-&gt;call = translator_call;
-		tmp-&gt;pvt-&gt;hangup = translator_hangup;
-		tmp-&gt;pvt-&gt;answer = translator_answer;
-		tmp-&gt;pvt-&gt;read = translator_read;
-		tmp-&gt;pvt-&gt;write = translator_write;
-		real-&gt;trans = tmp;
-		if (option_verbose &gt; 2)
-			ast_verbose(VERBOSE_PREFIX_3 &quot;Created translator %s\n&quot;, tmp-&gt;name);
-		if (pthread_create(&amp;t, NULL, translator_thread, real) &lt; 0) {
-			ast_translator_destroy(tmp);
-			tmp = NULL;
-			ast_log(LOG_WARNING, &quot;Failed to start thread\n&quot;);
-		}
-	} else {
-		ast_translator_free(pvt);
-		ast_log(LOG_WARNING, &quot;Unable to allocate channel\n&quot;);
-	}
-	return tmp;
-} 
-
-static void rebuild_matrix()
-{
-	struct ast_translator *t;
-	int changed;
-	int x,y,z;
-	if (option_debug)
-		ast_log(LOG_DEBUG, &quot;Reseting translation matrix\n&quot;);
-	/* Use the list of translators to build a translation matrix */
-	bzero(tr_matrix, sizeof(tr_matrix));
-	t = list;
-	while(t) {
-		if (!tr_matrix[t-&gt;srcfmt][t-&gt;dstfmt].step ||
-		     tr_matrix[t-&gt;srcfmt][t-&gt;dstfmt].cost &gt; t-&gt;cost) {
-			tr_matrix[t-&gt;srcfmt][t-&gt;dstfmt].step = t;
-			tr_matrix[t-&gt;srcfmt][t-&gt;dstfmt].cost = t-&gt;cost;
-		}
-		t = t-&gt;next;
-	}
-	do {
-		changed = 0;
-		/* Don't you just love O(N^3) operations? */
-		for (x=0; x&lt; MAX_FORMAT; x++)				/* For each source format */
-			for (y=0; y &lt; MAX_FORMAT; y++) 			/* And each destination format */
-				if (x != y)							/* Except ourselves, of course */
-					for (z=0; z &lt; MAX_FORMAT; z++) 	/* And each format it might convert to */
-						if ((x!=z) &amp;&amp; (y!=z)) 		/* Don't ever convert back to us */
-							if (tr_matrix[x][y].step &amp;&amp; /* We can convert from x to y */
-								tr_matrix[y][z].step &amp;&amp; /* And from y to z and... */
-								(!tr_matrix[x][z].step || 	/* Either there isn't an x-&gt;z conversion */
-								(tr_matrix[x][y].cost + 
-								 tr_matrix[y][z].cost &lt;	/* Or we're cheaper than the existing */
-								 tr_matrix[x][z].cost)  /* solution */
-							     )) {
-								 			/* We can get from x to z via y with a cost that
-											   is the sum of the transition from x to y and
-											   from y to z */
-								 
-								 	tr_matrix[x][z].step = tr_matrix[x][y].step;
-									tr_matrix[x][z].cost = tr_matrix[x][y].cost + 
-														   tr_matrix[y][z].cost;
-									if (option_debug)
-										ast_log(LOG_DEBUG, &quot;Discovered %d cost path from %d to %d, via %d\n&quot;, tr_matrix[x][z].cost, x, z, y);
-									changed++;
-								 }
-		
-	} while (changed);
-}
-
-static void calc_cost(struct ast_translator *t)
-{
-	int sofar=0;
-	struct ast_translator_pvt *pvt;
-	struct ast_frame *f, *out;
-	struct timeval start, finish;
-	int cost;
-	/* If they don't make samples, give them a terrible score */
-	if (!t-&gt;sample) {
-		ast_log(LOG_WARNING, &quot;Translator '%s' does not produce sample frames.\n&quot;, t-&gt;name);
-		t-&gt;cost = 99999;
-		return;
-	}
-	pvt = t-&gt;new();
-	if (!pvt) {
-		ast_log(LOG_WARNING, &quot;Translator '%s' appears to be broken and will probably fail.\n&quot;, t-&gt;name);
-		t-&gt;cost = 99999;
-		return;
-	}
-	gettimeofday(&amp;start, NULL);
-	/* Call the encoder until we've processed one second of time */
-	while(sofar &lt; 1000) {
-		f = t-&gt;sample();
-		if (!f) {
-			ast_log(LOG_WARNING, &quot;Translator '%s' failed to produce a sample frame.\n&quot;, t-&gt;name);
-			t-&gt;destroy(pvt);
-			t-&gt;cost = 99999;
-			return;
-		}
-		t-&gt;framein(pvt, f);
-		ast_frfree(f);
-		while((out = t-&gt;frameout(pvt))) {
-			sofar += out-&gt;timelen;
-			ast_frfree(out);
-		}
-	}
-	gettimeofday(&amp;finish, NULL);
-	t-&gt;destroy(pvt);
-	cost = (finish.tv_sec - start.tv_sec) * 1000 + (finish.tv_usec - start.tv_usec) / 1000;
-	t-&gt;cost = cost;
-}
-
-int ast_register_translator(struct ast_translator *t)
-{
-	t-&gt;srcfmt = powerof(t-&gt;srcfmt);
-	t-&gt;dstfmt = powerof(t-&gt;dstfmt);
-	if ((t-&gt;srcfmt &gt;= MAX_FORMAT) || (t-&gt;dstfmt &gt;= MAX_FORMAT)) {
-		ast_log(LOG_WARNING, &quot;Format %d is larger than MAX_FORMAT\n&quot;, t-&gt;srcfmt);
-		return -1;
-	}
-	calc_cost(t);
-	if (option_verbose &gt; 1)
-		ast_verbose(VERBOSE_PREFIX_2 &quot;Registered translator '%s' from format %d to %d, cost %d\n&quot;, t-&gt;name, t-&gt;srcfmt, t-&gt;dstfmt, t-&gt;cost);
-	pthread_mutex_lock(&amp;list_lock);
-	t-&gt;next = list;
-	list = t;
-	rebuild_matrix();
-	pthread_mutex_unlock(&amp;list_lock);
-	return 0;
-}
-
-int ast_unregister_translator(struct ast_translator *t)
-{
-	struct ast_translator *u, *ul = NULL;
-	pthread_mutex_lock(&amp;list_lock);
-	u = list;
-	while(u) {
-		if (u == t) {
-			if (ul)
-				ul-&gt;next = u-&gt;next;
-			else
-				list = u-&gt;next;
-			break;
-		}
-		u = u-&gt;next;
-	}
-	rebuild_matrix();
-	pthread_mutex_unlock(&amp;list_lock);
-	return (u ? 0 : -1);
-}
-
-void ast_translator_destroy(struct ast_channel *trans)
-{
-	char dummy;
-	int ms = 1000;
-	if (!trans-&gt;master) {
-		ast_log(LOG_WARNING, &quot;Translator is not part of a real channel?\n&quot;);
-		return;
-	}
-	if (trans-&gt;master-&gt;trans != trans) {
-		ast_log(LOG_WARNING, &quot;Translator is not the right one!?!?\n&quot;);
-		return;
-	}
-	trans-&gt;master-&gt;trans = NULL;
-	/* Write an invalid frame to kill off the main thread, which will
-	   in turn acknowledge by writing an invalid frame back to us, unless
-	   they're already closed.  */
-	if (trans-&gt;fd &gt; -1) {
-		if (write(trans-&gt;fd, trans, 1) == 1) {
-			/* Wait for a respnose, but no more than 1 second */
-			if (ast_waitfor_n_fd(&amp;trans-&gt;fd, 1, &amp;ms) == trans-&gt;fd)
-				read(trans-&gt;fd, &amp;dummy, 1);
-		}
-	}
-	if (option_verbose &gt; 2)
-		ast_verbose(VERBOSE_PREFIX_3 &quot;Destroyed translator %s\n&quot;, trans-&gt;name);
-	close(trans-&gt;fd);
-	ast_channel_free(trans);
-}
-
-int ast_translator_best_choice(int dst, int srcs)
-{
-	/* Calculate our best source format, given costs, and a desired destination */
-	int x;
-	int best=-1;
-	int besttime=999999999;
-	dst = powerof(dst);
-	pthread_mutex_lock(&amp;list_lock);
-	for (x=0;x&lt;MAX_FORMAT;x++) {
-		if (tr_matrix[x][dst].step &amp;&amp;	/* There's a step */
-		    (tr_matrix[x][dst].cost &lt; besttime) &amp;&amp; /* We're better than what exists now */
-			(srcs &amp; (1 &lt;&lt; x)))			/* x is a valid source format */
-			{
-				best = 1 &lt;&lt; x;
-				besttime = tr_matrix[x][dst].cost;
-			}
-				
-	}
-	pthread_mutex_unlock(&amp;list_lock);
-	return best;
-}
-/*
  * Asterisk -- An open source telephony toolkit.
  *
  * Copyright (C) 1999 - 2006, Digium, Inc.


</PRE>

<!--endarticle-->
    <HR>
    <P><UL>
        <!--threads-->
	
	<LI>Next message: <A HREF="000419.html">[solid-pbx-svn] r424 - in trunk: . res
</A></li>
         <LI> <B>Messages sorted by:</B> 
              <a href="date.html#418">[ date ]</a>
              <a href="thread.html#418">[ thread ]</a>
              <a href="subject.html#418">[ subject ]</a>
              <a href="author.html#418">[ author ]</a>
         </LI>
       </UL>

<hr>
<a href="https://lists.berlios.de/mailman/listinfo/solid-pbx-svn">More information about the solid-pbx-svn
mailing list</a><br>
</body></html>
